{
  "modules": [
    {
      "key": "mesh-contract:asteria.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/asteria/index.ts",
      "name": "asteria.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from './offchain';\n",
      "dependencies": [],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:asteria.offchain.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/asteria/offchain.ts",
      "name": "asteria.offchain.ts",
      "imports": [
        {
          "module": "MeshAsteriaContract",
          "items": [],
          "line": 3,
          "raw": "export class MeshAsteriaContract extends MeshTxInitiator {",
          "source": "mesh-contract"
        }
      ],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { MeshTxInitiator, MeshTxInitiatorInput } from \"../common\";\n\nexport class MeshAsteriaContract extends MeshTxInitiator {\n\n  constructor(inputs: MeshTxInitiatorInput) {\n    super(inputs);\n  }\n\n}",
      "dependencies": [
        "MeshAsteriaContract"
      ],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:common.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/common.ts",
      "name": "common.ts",
      "imports": [
        {
          "module": "MeshTxInitiatorInput",
          "items": [],
          "line": 12,
          "raw": "export type MeshTxInitiatorInput = {",
          "source": "mesh-contract"
        },
        {
          "module": "MeshTxInitiator",
          "items": [],
          "line": 21,
          "raw": "export class MeshTxInitiator {",
          "source": "mesh-contract"
        }
      ],
      "functions": [
        {
          "name": "getScriptAddress",
          "signature": "getScriptAddress = (scriptCbor: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "scriptCbor",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 69,
          "raw": "  getScriptAddress = (scriptCbor: string) => {\n    const { address } = serializePlutusScript(\n      { code: scriptCbor, version: this.languageVersion },\n      this.stakeCredential,\n      this.networkId,\n    );\n    return address;\n  };",
          "source": "mesh-contract",
          "implementation": "  getScriptAddress = (scriptCbor: string) => {\n    const { address } = serializePlutusScript(\n      { code: scriptCbor, version: this.languageVersion },\n      this.stakeCredential,\n      this.networkId,\n    );\n    return address;\n  };"
        }
      ],
      "types": [
        {
          "name": "MeshTxInitiatorInput",
          "definition": "export type MeshTxInitiatorInput = {\n  mesh: MeshTxBuilder;\n  fetcher?: IFetcher;",
          "isPublic": true,
          "line": 12,
          "raw": "export type MeshTxInitiatorInput = {",
          "source": "mesh-contract"
        }
      ],
      "constants": [
        {
          "name": "signedTx",
          "type": "any",
          "value": "this.mesh.completeSigning();",
          "isPublic": true,
          "line": 79,
          "raw": "const signedTx = this.mesh.completeSigning();",
          "source": "mesh-contract"
        },
        {
          "name": "txHash",
          "type": "any",
          "value": "await this.mesh.submitTx(signedTx);",
          "isPublic": true,
          "line": 80,
          "raw": "const txHash = await this.mesh.submitTx(signedTx);",
          "source": "mesh-contract"
        },
        {
          "name": "utxos",
          "type": "any",
          "value": "await this.fetcher.fetchAddressUTxOs(walletAddress);",
          "isPublic": true,
          "line": 87,
          "raw": "const utxos = await this.fetcher.fetchAddressUTxOs(walletAddress);",
          "source": "mesh-contract"
        },
        {
          "name": "usedAddresses",
          "type": "any",
          "value": "await this.wallet.getUsedAddresses();",
          "isPublic": true,
          "line": 95,
          "raw": "const usedAddresses = await this.wallet.getUsedAddresses();",
          "source": "mesh-contract"
        },
        {
          "name": "unusedAddresses",
          "type": "any",
          "value": "await this.wallet.getUnusedAddresses();",
          "isPublic": true,
          "line": 99,
          "raw": "const unusedAddresses = await this.wallet.getUnusedAddresses();",
          "source": "mesh-contract"
        },
        {
          "name": "utxos",
          "type": "any",
          "value": "await this.wallet.getCollateral();",
          "isPublic": true,
          "line": 109,
          "raw": "const utxos = await this.wallet.getCollateral();",
          "source": "mesh-contract"
        },
        {
          "name": "lovelaceAmount",
          "type": "any",
          "value": "u.output.amount.find(",
          "isPublic": true,
          "line": 124,
          "raw": "const lovelaceAmount = u.output.amount.find(",
          "source": "mesh-contract"
        },
        {
          "name": "assetAmount",
          "type": "any",
          "value": "u.output.amount.find(",
          "isPublic": true,
          "line": 140,
          "raw": "const assetAmount = u.output.amount.find(",
          "source": "mesh-contract"
        },
        {
          "name": "lovelaceAmount",
          "type": "any",
          "value": "u.output.amount.find(",
          "isPublic": true,
          "line": 157,
          "raw": "const lovelaceAmount = u.output.amount.find(",
          "source": "mesh-contract"
        },
        {
          "name": "assetAmount",
          "type": "any",
          "value": "u.output.amount.find(",
          "isPublic": true,
          "line": 174,
          "raw": "const assetAmount = u.output.amount.find(",
          "source": "mesh-contract"
        },
        {
          "name": "utxos",
          "type": "any",
          "value": "await this.wallet?.getUtxos();",
          "isPublic": true,
          "line": 182,
          "raw": "const utxos = await this.wallet?.getUtxos();",
          "source": "mesh-contract"
        },
        {
          "name": "collateral",
          "type": "any",
          "value": "await this.getWalletCollateral();",
          "isPublic": true,
          "line": 183,
          "raw": "const collateral = await this.getWalletCollateral();",
          "source": "mesh-contract"
        },
        {
          "name": "walletAddress",
          "type": "any",
          "value": "await this.getWalletDappAddress();",
          "isPublic": true,
          "line": 184,
          "raw": "const walletAddress = await this.getWalletDappAddress();",
          "source": "mesh-contract"
        },
        {
          "name": "utxos",
          "type": "any",
          "value": "await this.fetcher?.fetchUTxOs(txHash);",
          "isPublic": true,
          "line": 202,
          "raw": "const utxos = await this.fetcher?.fetchUTxOs(txHash);",
          "source": "mesh-contract"
        },
        {
          "name": "scriptAddr",
          "type": "any",
          "value": "serializePlutusScript(",
          "isPublic": true,
          "line": 206,
          "raw": "const scriptAddr = serializePlutusScript(",
          "source": "mesh-contract"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  BrowserWallet,\n  IFetcher,\n  IWallet,\n  LanguageVersion,\n  MeshTxBuilder,\n  MeshWallet,\n  serializePlutusScript,\n  UTxO,\n} from \"@meshsdk/core\";\n\nexport type MeshTxInitiatorInput = {\n  mesh: MeshTxBuilder;\n  fetcher?: IFetcher;\n  wallet?: IWallet;\n  networkId?: number;\n  stakeCredential?: string;\n  version?: number;\n};\n\nexport class MeshTxInitiator {\n  mesh: MeshTxBuilder;\n  fetcher?: IFetcher;\n  wallet?: IWallet;\n  stakeCredential?: string;\n  networkId = 0;\n  version = 2;\n  languageVersion: LanguageVersion = \"V2\";\n\n  constructor({\n    mesh,\n    fetcher,\n    wallet,\n    networkId = 0,\n    stakeCredential = \"c08f0294ead5ab7ae0ce5471dd487007919297ba95230af22f25e575\",\n    version = 2,\n  }: MeshTxInitiatorInput) {\n    this.mesh = mesh;\n    if (fetcher) {\n      this.fetcher = fetcher;\n    }\n    if (wallet) {\n      this.wallet = wallet;\n    }\n\n    this.networkId = networkId;\n    switch (this.networkId) {\n      case 1:\n        this.mesh.setNetwork(\"mainnet\");\n        break;\n      default:\n        this.mesh.setNetwork(\"preprod\");\n    }\n\n    this.version = version;\n    switch (this.version) {\n      case 1:\n        this.languageVersion = \"V2\";\n        break;\n      default:\n        this.languageVersion = \"V3\";\n    }\n\n    if (stakeCredential) {\n      this.stakeCredential = stakeCredential;\n    }\n  }\n\n  getScriptAddress = (scriptCbor: string) => {\n    const { address } = serializePlutusScript(\n      { code: scriptCbor, version: this.languageVersion },\n      this.stakeCredential,\n      this.networkId,\n    );\n    return address;\n  };\n\n  protected signSubmitReset = async () => {\n    const signedTx = this.mesh.completeSigning();\n    const txHash = await this.mesh.submitTx(signedTx);\n    this.mesh.reset();\n    return txHash;\n  };\n\n  protected queryUtxos = async (walletAddress: string): Promise<UTxO[]> => {\n    if (this.fetcher) {\n      const utxos = await this.fetcher.fetchAddressUTxOs(walletAddress);\n      return utxos;\n    }\n    return [];\n  };\n\n  protected getWalletDappAddress = async () => {\n    if (this.wallet) {\n      const usedAddresses = await this.wallet.getUsedAddresses();\n      if (usedAddresses.length > 0) {\n        return usedAddresses[0];\n      }\n      const unusedAddresses = await this.wallet.getUnusedAddresses();\n      if (unusedAddresses.length > 0) {\n        return unusedAddresses[0];\n      }\n    }\n    return \"\";\n  };\n\n  protected getWalletCollateral = async (): Promise<UTxO | undefined> => {\n    if (this.wallet) {\n      const utxos = await this.wallet.getCollateral();\n      return utxos[0];\n    }\n    return undefined;\n  };\n\n  protected getWalletUtxosWithMinLovelace = async (\n    lovelace: number,\n    providedUtxos: UTxO[] = [],\n  ) => {\n    let utxos: UTxO[] = providedUtxos;\n    if (this.wallet && (!providedUtxos || providedUtxos.length === 0)) {\n      utxos = await this.wallet.getUtxos();\n    }\n    return utxos.filter((u) => {\n      const lovelaceAmount = u.output.amount.find(\n        (a: any) => a.unit === \"lovelace\",\n      )?.quantity;\n      return Number(lovelaceAmount) > lovelace;\n    });\n  };\n\n  protected getWalletUtxosWithToken = async (\n    assetHex: string,\n    userUtxos: UTxO[] = [],\n  ) => {\n    let utxos: UTxO[] = userUtxos;\n    if (this.wallet && userUtxos.length === 0) {\n      utxos = await this.wallet.getUtxos();\n    }\n    return utxos.filter((u) => {\n      const assetAmount = u.output.amount.find(\n        (a: any) => a.unit === assetHex,\n      )?.quantity;\n      return Number(assetAmount) >= 1;\n    });\n  };\n\n  protected getAddressUtxosWithMinLovelace = async (\n    walletAddress: string,\n    lovelace: number,\n    providedUtxos: UTxO[] = [],\n  ) => {\n    let utxos: UTxO[] = providedUtxos;\n    if (this.fetcher && (!providedUtxos || providedUtxos.length === 0)) {\n      utxos = await this.fetcher.fetchAddressUTxOs(walletAddress);\n    }\n    return utxos.filter((u) => {\n      const lovelaceAmount = u.output.amount.find(\n        (a: any) => a.unit === \"lovelace\",\n      )?.quantity;\n      return Number(lovelaceAmount) > lovelace;\n    });\n  };\n\n  protected getAddressUtxosWithToken = async (\n    walletAddress: string,\n    assetHex: string,\n    userUtxos: UTxO[] = [],\n  ) => {\n    let utxos: UTxO[] = userUtxos;\n    if (this.fetcher && userUtxos.length === 0) {\n      utxos = await this.fetcher.fetchAddressUTxOs(walletAddress);\n    }\n    return utxos.filter((u) => {\n      const assetAmount = u.output.amount.find(\n        (a: any) => a.unit === assetHex,\n      )?.quantity;\n      return Number(assetAmount) >= 1;\n    });\n  };\n\n  protected getWalletInfoForTx = async () => {\n    const utxos = await this.wallet?.getUtxos();\n    const collateral = await this.getWalletCollateral();\n    const walletAddress = await this.getWalletDappAddress();\n    if (!utxos || utxos?.length === 0) {\n      throw new Error(\"No utxos found\");\n    }\n    if (!collateral) {\n      throw new Error(\"No collateral found\");\n    }\n    if (!walletAddress) {\n      throw new Error(\"No wallet address found\");\n    }\n    return { utxos, collateral, walletAddress };\n  };\n\n  protected _getUtxoByTxHash = async (\n    txHash: string,\n    scriptCbor?: string,\n  ): Promise<UTxO | undefined> => {\n    if (this.fetcher) {\n      const utxos = await this.fetcher?.fetchUTxOs(txHash);\n      let scriptUtxo = utxos[0];\n\n      if (scriptCbor) {\n        const scriptAddr = serializePlutusScript(\n          { code: scriptCbor, version: this.languageVersion },\n          this.stakeCredential,\n          this.networkId,\n        ).address;\n        scriptUtxo =\n          utxos.filter((utxo) => utxo.output.address === scriptAddr)[0] ||\n          utxos[0];\n      }\n\n      return scriptUtxo;\n    }\n\n    return undefined;\n  };\n}\n",
      "dependencies": [
        "MeshTxInitiatorInput",
        "MeshTxInitiator"
      ],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:content-ownership.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/content-ownership/index.ts",
      "name": "content-ownership.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./offchain/offchain\";\n",
      "dependencies": [],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:content-ownership.offchain.common.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/content-ownership/offchain/common.ts",
      "name": "content-ownership.offchain.common.ts",
      "imports": [
        {
          "module": "blueprint",
          "items": [],
          "line": 12,
          "raw": "export { blueprint };",
          "source": "mesh-contract"
        },
        {
          "module": "InputUTxO",
          "items": [],
          "line": 14,
          "raw": "export type InputUTxO = UTxO[\"input\"];",
          "source": "mesh-contract"
        },
        {
          "module": "ScriptIndex",
          "items": [],
          "line": 16,
          "raw": "export type ScriptIndex =",
          "source": "mesh-contract"
        },
        {
          "module": "getScriptCbor",
          "items": [],
          "line": 24,
          "raw": "export const getScriptCbor = (",
          "source": "mesh-contract"
        },
        {
          "module": "getScriptHash",
          "items": [],
          "line": 69,
          "raw": "export const getScriptHash = (",
          "source": "mesh-contract"
        },
        {
          "module": "getScriptInfo",
          "items": [],
          "line": 77,
          "raw": "export const getScriptInfo = (",
          "source": "mesh-contract"
        }
      ],
      "functions": [
        {
          "name": "getScriptCbor",
          "signature": "export const getScriptCbor = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 24,
          "raw": "export const getScriptCbor = (\n  oracleParamUtxo: UTxO[\"input\"],\n  scriptIndex: ScriptIndex,\n) => {\n  const validators = blueprint.validators;\n  const oracleNFTCbor = applyParamsToScript(\n    validators[4]!.compiledCode,\n    [outputReference(oracleParamUtxo.txHash, oracleParamUtxo.outputIndex)],\n    \"JSON\",\n  );\n  const oracleNFTToParam = builtinByteString(\n    resolveScriptHash(oracleNFTCbor, \"V3\"),\n  );\n  switch (scriptIndex) {\n    case \"OracleNFT\":\n      return oracleNFTCbor;\n    case \"OracleValidator\":\n      return applyParamsToScript(validators[6]!.compiledCode, [], \"JSON\");\n    case \"ContentRegistry\":\n      return applyParamsToScript(\n        validators[0]!.compiledCode,\n        [oracleNFTToParam],\n        \"JSON\",\n      );\n    case \"ContentRefToken\":\n      return applyParamsToScript(\n        validators[2]!.compiledCode,\n        [oracleNFTToParam],\n        \"JSON\",\n      );\n    case \"OwnershipRegistry\":\n      return applyParamsToScript(\n        validators[8]!.compiledCode,\n        [oracleNFTToParam],\n        \"JSON\",\n      );\n    case \"OwnershipRefToken\":\n      return applyParamsToScript(\n        validators[10]!.compiledCode,\n        [oracleNFTToParam],\n        \"JSON\",\n      );\n  }\n};",
          "source": "mesh-contract",
          "implementation": "export const getScriptCbor = (\n  oracleParamUtxo: UTxO[\"input\"],\n  scriptIndex: ScriptIndex,\n) => {\n  const validators = blueprint.validators;\n  const oracleNFTCbor = applyParamsToScript(\n    validators[4]!.compiledCode,\n    [outputReference(oracleParamUtxo.txHash, oracleParamUtxo.outputIndex)],\n    \"JSON\",\n  );\n  const oracleNFTToParam = builtinByteString(\n    resolveScriptHash(oracleNFTCbor, \"V3\"),\n  );\n  switch (scriptIndex) {\n    case \"OracleNFT\":\n      return oracleNFTCbor;\n    case \"OracleValidator\":\n      return applyParamsToScript(validators[6]!.compiledCode, [], \"JSON\");\n    case \"ContentRegistry\":\n      return applyParamsToScript(\n        validators[0]!.compiledCode,\n        [oracleNFTToParam],\n        \"JSON\",\n      );\n    case \"ContentRefToken\":\n      return applyParamsToScript(\n        validators[2]!.compiledCode,\n        [oracleNFTToParam],\n        \"JSON\",\n      );\n    case \"OwnershipRegistry\":\n      return applyParamsToScript(\n        validators[8]!.compiledCode,\n        [oracleNFTToParam],\n        \"JSON\",\n      );\n    case \"OwnershipRefToken\":\n      return applyParamsToScript(\n        validators[10]!.compiledCode,\n        [oracleNFTToParam],\n        \"JSON\",\n      );\n  }\n};"
        },
        {
          "name": "getScriptHash",
          "signature": "export const getScriptHash = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 69,
          "raw": "export const getScriptHash = (\n  oracleParamUtxo: UTxO[\"input\"],\n  scriptIndex: ScriptIndex,\n) => {\n  const scriptCbor = getScriptCbor(oracleParamUtxo, scriptIndex);\n  return resolveScriptHash(scriptCbor, \"V3\");\n};",
          "source": "mesh-contract",
          "implementation": "export const getScriptHash = (\n  oracleParamUtxo: UTxO[\"input\"],\n  scriptIndex: ScriptIndex,\n) => {\n  const scriptCbor = getScriptCbor(oracleParamUtxo, scriptIndex);\n  return resolveScriptHash(scriptCbor, \"V3\");\n};"
        },
        {
          "name": "getScriptInfo",
          "signature": "export const getScriptInfo = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 77,
          "raw": "export const getScriptInfo = (\n  oracleParamUtxo: UTxO[\"input\"],\n  stakeCredential?: string,\n  networkId = 0,\n) => {\n  const info = {\n    oracleNFT: {\n      hash: getScriptHash(oracleParamUtxo, \"OracleNFT\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"OracleNFT\"),\n    },\n    oracleValidator: {\n      hash: getScriptHash(oracleParamUtxo, \"OracleValidator\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"OracleValidator\"),\n      address: \"\",\n    },\n    contentRegistry: {\n      hash: getScriptHash(oracleParamUtxo, \"ContentRegistry\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"ContentRegistry\"),\n      address: \"\",\n    },\n    contentRefToken: {\n      hash: getScriptHash(oracleParamUtxo, \"ContentRefToken\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"ContentRefToken\"),\n    },\n    ownershipRegistry: {\n      hash: getScriptHash(oracleParamUtxo, \"OwnershipRegistry\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"OwnershipRegistry\"),\n      address: \"\",\n    },\n    ownershipRefToken: {\n      hash: getScriptHash(oracleParamUtxo, \"OwnershipRefToken\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"OwnershipRefToken\"),\n    },\n  };\n\n  const oracleAddress = serializePlutusScript(\n    { code: info.oracleValidator.cbor, version: \"V3\" },\n    stakeCredential,\n    networkId,\n  ).address;\n  const contentRegistryAddress = serializePlutusScript(\n    { code: info.contentRegistry.cbor, version: \"V3\" },\n    stakeCredential,\n    networkId,\n  ).address;\n  const ownershipRegistryAddress = serializePlutusScript(\n    { code: info.ownershipRegistry.cbor, version: \"V3\" },\n    stakeCredential,\n    networkId,\n  ).address;\n  info.oracleValidator.address = oracleAddress;\n  info.contentRegistry.address = contentRegistryAddress;\n  info.ownershipRegistry.address = ownershipRegistryAddress;\n\n  return info;\n};",
          "source": "mesh-contract",
          "implementation": "export const getScriptInfo = (\n  oracleParamUtxo: UTxO[\"input\"],\n  stakeCredential?: string,\n  networkId = 0,\n) => {\n  const info = {\n    oracleNFT: {\n      hash: getScriptHash(oracleParamUtxo, \"OracleNFT\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"OracleNFT\"),\n    },\n    oracleValidator: {\n      hash: getScriptHash(oracleParamUtxo, \"OracleValidator\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"OracleValidator\"),\n      address: \"\",\n    },\n    contentRegistry: {\n      hash: getScriptHash(oracleParamUtxo, \"ContentRegistry\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"ContentRegistry\"),\n      address: \"\",\n    },\n    contentRefToken: {\n      hash: getScriptHash(oracleParamUtxo, \"ContentRefToken\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"ContentRefToken\"),\n    },\n    ownershipRegistry: {\n      hash: getScriptHash(oracleParamUtxo, \"OwnershipRegistry\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"OwnershipRegistry\"),\n      address: \"\",\n    },\n    ownershipRefToken: {\n      hash: getScriptHash(oracleParamUtxo, \"OwnershipRefToken\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"OwnershipRefToken\"),\n    },\n  };\n\n  const oracleAddress = serializePlutusScript(\n    { code: info.oracleValidator.cbor, version: \"V3\" },\n    stakeCredential,\n    networkId,\n  ).address;\n  const contentRegistryAddress = serializePlutusScript(\n    { code: info.contentRegistry.cbor, version: \"V3\" },\n    stakeCredential,\n    networkId,\n  ).address;\n  const ownershipRegistryAddress = serializePlutusScript(\n    { code: info.ownershipRegistry.cbor, version: \"V3\" },\n    stakeCredential,\n    networkId,\n  ).address;\n  info.oracleValidator.address = oracleAddress;\n  info.contentRegistry.address = contentRegistryAddress;\n  info.ownershipRegistry.address = ownershipRegistryAddress;\n\n  return info;\n};"
        }
      ],
      "types": [
        {
          "name": "InputUTxO",
          "definition": "export type InputUTxO = UTxO[\"input\"];",
          "isPublic": true,
          "line": 14,
          "raw": "export type InputUTxO = UTxO[\"input\"];",
          "source": "mesh-contract"
        },
        {
          "name": "ScriptIndex",
          "definition": "export type ScriptIndex =\n  | \"OracleNFT\"\n  | \"OracleValidator\"\n  | \"ContentRegistry\"\n  | \"ContentRefToken\"\n  | \"OwnershipRegistry\"\n  | \"OwnershipRefToken\";",
          "isPublic": true,
          "line": 16,
          "raw": "export type ScriptIndex =",
          "source": "mesh-contract"
        }
      ],
      "constants": [
        {
          "name": "getScriptCbor",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 24,
          "raw": "export const getScriptCbor = (",
          "source": "mesh-contract"
        },
        {
          "name": "validators",
          "type": "any",
          "value": "blueprint.validators;",
          "isPublic": true,
          "line": 28,
          "raw": "const validators = blueprint.validators;",
          "source": "mesh-contract"
        },
        {
          "name": "oracleNFTCbor",
          "type": "any",
          "value": "applyParamsToScript(",
          "isPublic": true,
          "line": 29,
          "raw": "const oracleNFTCbor = applyParamsToScript(",
          "source": "mesh-contract"
        },
        {
          "name": "oracleNFTToParam",
          "type": "any",
          "value": "builtinByteString(",
          "isPublic": true,
          "line": 34,
          "raw": "const oracleNFTToParam = builtinByteString(",
          "source": "mesh-contract"
        },
        {
          "name": "getScriptHash",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 69,
          "raw": "export const getScriptHash = (",
          "source": "mesh-contract"
        },
        {
          "name": "scriptCbor",
          "type": "any",
          "value": "getScriptCbor(oracleParamUtxo, scriptIndex);",
          "isPublic": true,
          "line": 73,
          "raw": "const scriptCbor = getScriptCbor(oracleParamUtxo, scriptIndex);",
          "source": "mesh-contract"
        },
        {
          "name": "getScriptInfo",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 77,
          "raw": "export const getScriptInfo = (",
          "source": "mesh-contract"
        },
        {
          "name": "info",
          "type": "any",
          "value": "{",
          "isPublic": true,
          "line": 82,
          "raw": "const info = {",
          "source": "mesh-contract"
        },
        {
          "name": "oracleAddress",
          "type": "any",
          "value": "serializePlutusScript(",
          "isPublic": true,
          "line": 112,
          "raw": "const oracleAddress = serializePlutusScript(",
          "source": "mesh-contract"
        },
        {
          "name": "contentRegistryAddress",
          "type": "any",
          "value": "serializePlutusScript(",
          "isPublic": true,
          "line": 117,
          "raw": "const contentRegistryAddress = serializePlutusScript(",
          "source": "mesh-contract"
        },
        {
          "name": "ownershipRegistryAddress",
          "type": "any",
          "value": "serializePlutusScript(",
          "isPublic": true,
          "line": 122,
          "raw": "const ownershipRegistryAddress = serializePlutusScript(",
          "source": "mesh-contract"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  builtinByteString,\n  outputReference,\n  resolveScriptHash,\n  serializePlutusScript,\n  UTxO,\n} from \"@meshsdk/core\";\nimport { applyParamsToScript } from \"@meshsdk/core-cst\";\n\nimport blueprint from \"../aiken-workspace/plutus.json\";\n\nexport { blueprint };\n\nexport type InputUTxO = UTxO[\"input\"];\n\nexport type ScriptIndex =\n  | \"OracleNFT\"\n  | \"OracleValidator\"\n  | \"ContentRegistry\"\n  | \"ContentRefToken\"\n  | \"OwnershipRegistry\"\n  | \"OwnershipRefToken\";\n\nexport const getScriptCbor = (\n  oracleParamUtxo: UTxO[\"input\"],\n  scriptIndex: ScriptIndex,\n) => {\n  const validators = blueprint.validators;\n  const oracleNFTCbor = applyParamsToScript(\n    validators[4]!.compiledCode,\n    [outputReference(oracleParamUtxo.txHash, oracleParamUtxo.outputIndex)],\n    \"JSON\",\n  );\n  const oracleNFTToParam = builtinByteString(\n    resolveScriptHash(oracleNFTCbor, \"V3\"),\n  );\n  switch (scriptIndex) {\n    case \"OracleNFT\":\n      return oracleNFTCbor;\n    case \"OracleValidator\":\n      return applyParamsToScript(validators[6]!.compiledCode, [], \"JSON\");\n    case \"ContentRegistry\":\n      return applyParamsToScript(\n        validators[0]!.compiledCode,\n        [oracleNFTToParam],\n        \"JSON\",\n      );\n    case \"ContentRefToken\":\n      return applyParamsToScript(\n        validators[2]!.compiledCode,\n        [oracleNFTToParam],\n        \"JSON\",\n      );\n    case \"OwnershipRegistry\":\n      return applyParamsToScript(\n        validators[8]!.compiledCode,\n        [oracleNFTToParam],\n        \"JSON\",\n      );\n    case \"OwnershipRefToken\":\n      return applyParamsToScript(\n        validators[10]!.compiledCode,\n        [oracleNFTToParam],\n        \"JSON\",\n      );\n  }\n};\n\nexport const getScriptHash = (\n  oracleParamUtxo: UTxO[\"input\"],\n  scriptIndex: ScriptIndex,\n) => {\n  const scriptCbor = getScriptCbor(oracleParamUtxo, scriptIndex);\n  return resolveScriptHash(scriptCbor, \"V3\");\n};\n\nexport const getScriptInfo = (\n  oracleParamUtxo: UTxO[\"input\"],\n  stakeCredential?: string,\n  networkId = 0,\n) => {\n  const info = {\n    oracleNFT: {\n      hash: getScriptHash(oracleParamUtxo, \"OracleNFT\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"OracleNFT\"),\n    },\n    oracleValidator: {\n      hash: getScriptHash(oracleParamUtxo, \"OracleValidator\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"OracleValidator\"),\n      address: \"\",\n    },\n    contentRegistry: {\n      hash: getScriptHash(oracleParamUtxo, \"ContentRegistry\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"ContentRegistry\"),\n      address: \"\",\n    },\n    contentRefToken: {\n      hash: getScriptHash(oracleParamUtxo, \"ContentRefToken\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"ContentRefToken\"),\n    },\n    ownershipRegistry: {\n      hash: getScriptHash(oracleParamUtxo, \"OwnershipRegistry\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"OwnershipRegistry\"),\n      address: \"\",\n    },\n    ownershipRefToken: {\n      hash: getScriptHash(oracleParamUtxo, \"OwnershipRefToken\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"OwnershipRefToken\"),\n    },\n  };\n\n  const oracleAddress = serializePlutusScript(\n    { code: info.oracleValidator.cbor, version: \"V3\" },\n    stakeCredential,\n    networkId,\n  ).address;\n  const contentRegistryAddress = serializePlutusScript(\n    { code: info.contentRegistry.cbor, version: \"V3\" },\n    stakeCredential,\n    networkId,\n  ).address;\n  const ownershipRegistryAddress = serializePlutusScript(\n    { code: info.ownershipRegistry.cbor, version: \"V3\" },\n    stakeCredential,\n    networkId,\n  ).address;\n  info.oracleValidator.address = oracleAddress;\n  info.contentRegistry.address = contentRegistryAddress;\n  info.ownershipRegistry.address = ownershipRegistryAddress;\n\n  return info;\n};\n",
      "dependencies": [
        "blueprint",
        "InputUTxO",
        "ScriptIndex",
        "getScriptCbor",
        "getScriptHash",
        "getScriptInfo"
      ],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:content-ownership.offchain.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/content-ownership/offchain/index.ts",
      "name": "content-ownership.offchain.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./offchain\";\n",
      "dependencies": [],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/content-ownership/offchain/offchain.ts",
      "name": "content-ownership.offchain.offchain.ts",
      "imports": [
        {
          "module": "MeshContentOwnershipContract",
          "items": [],
          "line": 71,
          "raw": "export class MeshContentOwnershipContract extends MeshTxInitiator {",
          "source": "mesh-contract"
        }
      ],
      "functions": [
        {
          "name": "getOwnerNativeScript",
          "signature": "getOwnerNativeScript = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 135,
          "raw": "  getOwnerNativeScript = () => {\n    const { pubKeyHash: keyHash } = deserializeAddress(this.operationAddress);\n    const nativeScript: NativeScript = {\n      type: \"all\",\n      scripts: [\n        {\n          type: \"sig\",\n          keyHash: keyHash,\n        },\n      ],\n    };\n\n    const { address: scriptAddress } = serializeNativeScript(\n      nativeScript,\n      undefined,\n      this.networkId,\n    );\n\n    return {\n      nativeScript,\n      scriptAddress,\n    };\n  };",
          "source": "mesh-contract",
          "implementation": "  getOwnerNativeScript = () => {\n    const { pubKeyHash: keyHash } = deserializeAddress(this.operationAddress);\n    const nativeScript: NativeScript = {\n      type: \"all\",\n      scripts: [\n        {\n          type: \"sig\",\n          keyHash: keyHash,\n        },\n      ],\n    };\n\n    const { address: scriptAddress } = serializeNativeScript(\n      nativeScript,\n      undefined,\n      this.networkId,\n    );\n\n    return {\n      nativeScript,\n      scriptAddress,\n    };\n  };"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "serializedOpsPlutusAddr",
          "type": "any",
          "value": "deserializeAddress(this.operationAddress);",
          "isPublic": true,
          "line": 131,
          "raw": "const serializedOpsPlutusAddr = deserializeAddress(this.operationAddress);",
          "source": "mesh-contract"
        },
        {
          "name": "nativeScript",
          "type": "NativeScript",
          "value": "{",
          "isPublic": true,
          "line": 137,
          "raw": "const nativeScript: NativeScript = {",
          "source": "mesh-contract"
        },
        {
          "name": "paramUtxo",
          "type": "any",
          "value": "utxos[0]!;",
          "isPublic": true,
          "line": 183,
          "raw": "const paramUtxo = utxos[0]!;",
          "source": "mesh-contract"
        },
        {
          "name": "script",
          "type": "any",
          "value": "blueprint.validators[4]!.compiledCode;",
          "isPublic": true,
          "line": 184,
          "raw": "const script = blueprint.validators[4]!.compiledCode;",
          "source": "mesh-contract"
        },
        {
          "name": "param",
          "type": "Data",
          "value": "mOutputReference(",
          "isPublic": true,
          "line": 185,
          "raw": "const param: Data = mOutputReference(",
          "source": "mesh-contract"
        },
        {
          "name": "paramScript",
          "type": "any",
          "value": "applyParamsToScript(script, [param]);",
          "isPublic": true,
          "line": 189,
          "raw": "const paramScript = applyParamsToScript(script, [param]);",
          "source": "mesh-contract"
        },
        {
          "name": "policyId",
          "type": "any",
          "value": "resolveScriptHash(paramScript, \"V3\");",
          "isPublic": true,
          "line": 190,
          "raw": "const policyId = resolveScriptHash(paramScript, \"V3\");",
          "source": "mesh-contract"
        },
        {
          "name": "tokenName",
          "type": "any",
          "value": "\"\";",
          "isPublic": true,
          "line": 191,
          "raw": "const tokenName = \"\";",
          "source": "mesh-contract"
        },
        {
          "name": "txHex",
          "type": "any",
          "value": "await this.mesh",
          "isPublic": true,
          "line": 193,
          "raw": "const txHex = await this.mesh",
          "source": "mesh-contract"
        },
        {
          "name": "datumValue",
          "type": "any",
          "value": "this.getOracleDatum(0, 0);",
          "isPublic": true,
          "line": 245,
          "raw": "const datumValue = this.getOracleDatum(0, 0);",
          "source": "mesh-contract"
        },
        {
          "name": "txHex",
          "type": "any",
          "value": "await this.mesh",
          "isPublic": true,
          "line": 246,
          "raw": "const txHex = await this.mesh",
          "source": "mesh-contract"
        },
        {
          "name": "txHex",
          "type": "any",
          "value": "await this.mesh",
          "isPublic": true,
          "line": 288,
          "raw": "const txHex = await this.mesh",
          "source": "mesh-contract"
        },
        {
          "name": "scriptUtxo",
          "type": "any",
          "value": "await this.fetcher!.fetchAddressUTxOs(",
          "isPublic": true,
          "line": 320,
          "raw": "const scriptUtxo = await this.fetcher!.fetchAddressUTxOs(",
          "source": "mesh-contract"
        },
        {
          "name": "currentOracleDatum",
          "type": "any",
          "value": "await this.getCurrentOracleDatum(scriptUtxo);",
          "isPublic": true,
          "line": 324,
          "raw": "const currentOracleDatum = await this.getCurrentOracleDatum(scriptUtxo);",
          "source": "mesh-contract"
        },
        {
          "name": "contentNumber",
          "type": "any",
          "value": "currentOracleDatum.fields[4].int as number;",
          "isPublic": true,
          "line": 325,
          "raw": "const contentNumber = currentOracleDatum.fields[4].int as number;",
          "source": "mesh-contract"
        },
        {
          "name": "ownershipNumber",
          "type": "any",
          "value": "currentOracleDatum.fields[7].int as number;",
          "isPublic": true,
          "line": 326,
          "raw": "const ownershipNumber = currentOracleDatum.fields[7].int as number;",
          "source": "mesh-contract"
        },
        {
          "name": "contentTokenName",
          "type": "any",
          "value": "stringToHex(`Registry (${contentNumber})`);",
          "isPublic": true,
          "line": 327,
          "raw": "const contentTokenName = stringToHex(`Registry (${contentNumber})`);",
          "source": "mesh-contract"
        },
        {
          "name": "oracleDatumValue",
          "type": "any",
          "value": "this.getOracleDatum(",
          "isPublic": true,
          "line": 332,
          "raw": "const oracleDatumValue = this.getOracleDatum(",
          "source": "mesh-contract"
        },
        {
          "name": "txHex",
          "type": "any",
          "value": "await this.mesh",
          "isPublic": true,
          "line": 339,
          "raw": "const txHex = await this.mesh",
          "source": "mesh-contract"
        },
        {
          "name": "scriptUtxo",
          "type": "any",
          "value": "await this.fetcher!.fetchAddressUTxOs(",
          "isPublic": true,
          "line": 401,
          "raw": "const scriptUtxo = await this.fetcher!.fetchAddressUTxOs(",
          "source": "mesh-contract"
        },
        {
          "name": "currentOracleDatum",
          "type": "any",
          "value": "await this.getCurrentOracleDatum(scriptUtxo);",
          "isPublic": true,
          "line": 405,
          "raw": "const currentOracleDatum = await this.getCurrentOracleDatum(scriptUtxo);",
          "source": "mesh-contract"
        },
        {
          "name": "contentNumber",
          "type": "any",
          "value": "currentOracleDatum.fields[4].int as number;",
          "isPublic": true,
          "line": 406,
          "raw": "const contentNumber = currentOracleDatum.fields[4].int as number;",
          "source": "mesh-contract"
        },
        {
          "name": "ownershipNumber",
          "type": "any",
          "value": "currentOracleDatum.fields[7].int as number;",
          "isPublic": true,
          "line": 407,
          "raw": "const ownershipNumber = currentOracleDatum.fields[7].int as number;",
          "source": "mesh-contract"
        },
        {
          "name": "ownershipTokenName",
          "type": "any",
          "value": "stringToHex(`Registry (${ownershipNumber})`);",
          "isPublic": true,
          "line": 408,
          "raw": "const ownershipTokenName = stringToHex(`Registry (${ownershipNumber})`);",
          "source": "mesh-contract"
        },
        {
          "name": "oracleDatumValue",
          "type": "any",
          "value": "this.getOracleDatum(",
          "isPublic": true,
          "line": 413,
          "raw": "const oracleDatumValue = this.getOracleDatum(",
          "source": "mesh-contract"
        },
        {
          "name": "txHex",
          "type": "any",
          "value": "await this.mesh",
          "isPublic": true,
          "line": 419,
          "raw": "const txHex = await this.mesh",
          "source": "mesh-contract"
        },
        {
          "name": "scriptUtxo",
          "type": "any",
          "value": "await this.fetcher!.fetchAddressUTxOs(",
          "isPublic": true,
          "line": 472,
          "raw": "const scriptUtxo = await this.fetcher!.fetchAddressUTxOs(",
          "source": "mesh-contract"
        },
        {
          "name": "currentOracleDatum",
          "type": "any",
          "value": "await this.getCurrentOracleDatum(scriptUtxo);",
          "isPublic": true,
          "line": 476,
          "raw": "const currentOracleDatum = await this.getCurrentOracleDatum(scriptUtxo);",
          "source": "mesh-contract"
        },
        {
          "name": "contentNumber",
          "type": "any",
          "value": "currentOracleDatum.fields[4].int as number;",
          "isPublic": true,
          "line": 478,
          "raw": "const contentNumber = currentOracleDatum.fields[4].int as number;",
          "source": "mesh-contract"
        },
        {
          "name": "ownershipNumber",
          "type": "any",
          "value": "currentOracleDatum.fields[7].int as number;",
          "isPublic": true,
          "line": 479,
          "raw": "const ownershipNumber = currentOracleDatum.fields[7].int as number;",
          "source": "mesh-contract"
        },
        {
          "name": "nativeScript",
          "type": "NativeScript",
          "value": "{",
          "isPublic": true,
          "line": 509,
          "raw": "const nativeScript: NativeScript = {",
          "source": "mesh-contract"
        },
        {
          "name": "forgingScript",
          "type": "any",
          "value": "ForgeScript.fromNativeScript(nativeScript);",
          "isPublic": true,
          "line": 519,
          "raw": "const forgingScript = ForgeScript.fromNativeScript(nativeScript);",
          "source": "mesh-contract"
        },
        {
          "name": "policyId",
          "type": "any",
          "value": "resolveScriptHash(forgingScript);",
          "isPublic": true,
          "line": 521,
          "raw": "const policyId = resolveScriptHash(forgingScript);",
          "source": "mesh-contract"
        },
        {
          "name": "tokenNameHex",
          "type": "any",
          "value": "stringToHex(tokenName);",
          "isPublic": true,
          "line": 522,
          "raw": "const tokenNameHex = stringToHex(tokenName);",
          "source": "mesh-contract"
        },
        {
          "name": "metadata",
          "type": "any",
          "value": "{ [policyId]: { [tokenName]: { ...tokenMetadata } } };",
          "isPublic": true,
          "line": 523,
          "raw": "const metadata = { [policyId]: { [tokenName]: { ...tokenMetadata } } };",
          "source": "mesh-contract"
        },
        {
          "name": "txHex",
          "type": "any",
          "value": "await this.mesh",
          "isPublic": true,
          "line": 525,
          "raw": "const txHex = await this.mesh",
          "source": "mesh-contract"
        },
        {
          "name": "registryName",
          "type": "any",
          "value": "stringToHex(`Registry (${registryNumber})`);",
          "isPublic": true,
          "line": 550,
          "raw": "const registryName = stringToHex(`Registry (${registryNumber})`);",
          "source": "mesh-contract"
        },
        {
          "name": "oracleUtxo",
          "type": "UTxO[]",
          "value": "await this.fetcher!.fetchAddressUTxOs(",
          "isPublic": true,
          "line": 551,
          "raw": "const oracleUtxo: UTxO[] = await this.fetcher!.fetchAddressUTxOs(",
          "source": "mesh-contract"
        },
        {
          "name": "contentUtxo",
          "type": "UTxO[]",
          "value": "await this.fetcher!.fetchAddressUTxOs(",
          "isPublic": true,
          "line": 555,
          "raw": "const contentUtxo: UTxO[] = await this.fetcher!.fetchAddressUTxOs(",
          "source": "mesh-contract"
        },
        {
          "name": "ownershipUtxo",
          "type": "UTxO[]",
          "value": "await this.fetcher!.fetchAddressUTxOs(",
          "isPublic": true,
          "line": 559,
          "raw": "const ownershipUtxo: UTxO[] = await this.fetcher!.fetchAddressUTxOs(",
          "source": "mesh-contract"
        },
        {
          "name": "ownerAssetClass",
          "type": "[string, string]",
          "value": "[",
          "isPublic": true,
          "line": 574,
          "raw": "const ownerAssetClass: [string, string] = [",
          "source": "mesh-contract"
        },
        {
          "name": "newContentRegistry",
          "type": "any",
          "value": "this.insertContentRegistry(",
          "isPublic": true,
          "line": 578,
          "raw": "const newContentRegistry = this.insertContentRegistry(",
          "source": "mesh-contract"
        },
        {
          "name": "newOwnershipRegistry",
          "type": "any",
          "value": "this.insertOwnershipRegistry(",
          "isPublic": true,
          "line": 582,
          "raw": "const newOwnershipRegistry = this.insertOwnershipRegistry(",
          "source": "mesh-contract"
        },
        {
          "name": "txHex",
          "type": "any",
          "value": "await this.mesh",
          "isPublic": true,
          "line": 587,
          "raw": "const txHex = await this.mesh",
          "source": "mesh-contract"
        },
        {
          "name": "contentDatam",
          "type": "ContentRegistryDatum",
          "value": "parseDatumCbor(",
          "isPublic": true,
          "line": 652,
          "raw": "const contentDatam: ContentRegistryDatum = parseDatumCbor(",
          "source": "mesh-contract"
        },
        {
          "name": "contentAtRegistry",
          "type": "any",
          "value": "contentDatam.fields[1].list;",
          "isPublic": true,
          "line": 656,
          "raw": "const contentAtRegistry = contentDatam.fields[1].list;",
          "source": "mesh-contract"
        },
        {
          "name": "decoded",
          "type": "any",
          "value": "toUTF8(contentAtRegistry[contentNumber]?.bytes!);",
          "isPublic": true,
          "line": 661,
          "raw": "const decoded = toUTF8(contentAtRegistry[contentNumber]?.bytes!);",
          "source": "mesh-contract"
        },
        {
          "name": "registryTokenNameHex",
          "type": "any",
          "value": "stringToHex(`Registry (${registryNumber})`);",
          "isPublic": true,
          "line": 674,
          "raw": "const registryTokenNameHex = stringToHex(`Registry (${registryNumber})`);",
          "source": "mesh-contract"
        },
        {
          "name": "newContentRegistry",
          "type": "any",
          "value": "this.updateContentRegistry(",
          "isPublic": true,
          "line": 677,
          "raw": "const newContentRegistry = this.updateContentRegistry(",
          "source": "mesh-contract"
        },
        {
          "name": "txBody",
          "type": "any",
          "value": "this.mesh.completeSigning();",
          "isPublic": true,
          "line": 726,
          "raw": "const txBody = this.mesh.completeSigning();",
          "source": "mesh-contract"
        },
        {
          "name": "registryTokenNameHex",
          "type": "any",
          "value": "stringToHex(`Registry (${registryNumber})`);",
          "isPublic": true,
          "line": 738,
          "raw": "const registryTokenNameHex = stringToHex(`Registry (${registryNumber})`);",
          "source": "mesh-contract"
        },
        {
          "name": "newOwnerAssetClass",
          "type": "[string, string]",
          "value": "[",
          "isPublic": true,
          "line": 743,
          "raw": "const newOwnerAssetClass: [string, string] = [",
          "source": "mesh-contract"
        },
        {
          "name": "newOwnershipRegistry",
          "type": "any",
          "value": "this.updateOwnershipRegistry(",
          "isPublic": true,
          "line": 747,
          "raw": "const newOwnershipRegistry = this.updateOwnershipRegistry(",
          "source": "mesh-contract"
        },
        {
          "name": "txBody",
          "type": "any",
          "value": "this.mesh.completeSigning();",
          "isPublic": true,
          "line": 792,
          "raw": "const txBody = this.mesh.completeSigning();",
          "source": "mesh-contract"
        },
        {
          "name": "registryTokenNameHex",
          "type": "any",
          "value": "stringToHex(`Registry (${registryNumber})`);",
          "isPublic": true,
          "line": 801,
          "raw": "const registryTokenNameHex = stringToHex(`Registry (${registryNumber})`);",
          "source": "mesh-contract"
        },
        {
          "name": "scriptUtxos",
          "type": "any",
          "value": "await this.fetcher!.fetchAddressUTxOs(",
          "isPublic": true,
          "line": 802,
          "raw": "const scriptUtxos = await this.fetcher!.fetchAddressUTxOs(",
          "source": "mesh-contract"
        },
        {
          "name": "oracleUtxo",
          "type": "any",
          "value": "await this.fetcher!.fetchAddressUTxOs(",
          "isPublic": true,
          "line": 806,
          "raw": "const oracleUtxo = await this.fetcher!.fetchAddressUTxOs(",
          "source": "mesh-contract"
        },
        {
          "name": "txHex",
          "type": "any",
          "value": "await this.mesh",
          "isPublic": true,
          "line": 817,
          "raw": "const txHex = await this.mesh",
          "source": "mesh-contract"
        },
        {
          "name": "registryTokenNameHex",
          "type": "any",
          "value": "stringToHex(`Registry (${registryNumber})`);",
          "isPublic": true,
          "line": 850,
          "raw": "const registryTokenNameHex = stringToHex(`Registry (${registryNumber})`);",
          "source": "mesh-contract"
        },
        {
          "name": "scriptUtxos",
          "type": "any",
          "value": "await this.fetcher!.fetchAddressUTxOs(",
          "isPublic": true,
          "line": 851,
          "raw": "const scriptUtxos = await this.fetcher!.fetchAddressUTxOs(",
          "source": "mesh-contract"
        },
        {
          "name": "oracleUtxo",
          "type": "any",
          "value": "await this.fetcher!.fetchAddressUTxOs(",
          "isPublic": true,
          "line": 855,
          "raw": "const oracleUtxo = await this.fetcher!.fetchAddressUTxOs(",
          "source": "mesh-contract"
        },
        {
          "name": "txHex",
          "type": "any",
          "value": "await this.mesh",
          "isPublic": true,
          "line": 866,
          "raw": "const txHex = await this.mesh",
          "source": "mesh-contract"
        },
        {
          "name": "oracleUtxo",
          "type": "any",
          "value": "await this.fetcher!.fetchAddressUTxOs(",
          "isPublic": true,
          "line": 900,
          "raw": "const oracleUtxo = await this.fetcher!.fetchAddressUTxOs(",
          "source": "mesh-contract"
        },
        {
          "name": "txHex",
          "type": "any",
          "value": "await this.mesh",
          "isPublic": true,
          "line": 906,
          "raw": "const txHex = await this.mesh",
          "source": "mesh-contract"
        },
        {
          "name": "oracleDatum",
          "type": "any",
          "value": "parseInlineDatum<any, OracleDatum>({",
          "isPublic": true,
          "line": 942,
          "raw": "const oracleDatum = parseInlineDatum<any, OracleDatum>({",
          "source": "mesh-contract"
        },
        {
          "name": "oracleAddr",
          "type": "any",
          "value": "mScriptAddress(",
          "isPublic": true,
          "line": 952,
          "raw": "const oracleAddr = mScriptAddress(",
          "source": "mesh-contract"
        },
        {
          "name": "contentRegistryAddr",
          "type": "any",
          "value": "mScriptAddress(",
          "isPublic": true,
          "line": 956,
          "raw": "const contentRegistryAddr = mScriptAddress(",
          "source": "mesh-contract"
        },
        {
          "name": "ownershipRegistryAddr",
          "type": "any",
          "value": "mScriptAddress(",
          "isPublic": true,
          "line": 960,
          "raw": "const ownershipRegistryAddr = mScriptAddress(",
          "source": "mesh-contract"
        },
        {
          "name": "registryTokenNameHex",
          "type": "any",
          "value": "stringToHex(`Registry (${registryNumber})`);",
          "isPublic": true,
          "line": 995,
          "raw": "const registryTokenNameHex = stringToHex(`Registry (${registryNumber})`);",
          "source": "mesh-contract"
        },
        {
          "name": "promises",
          "type": "Promise<UTxO[]>[]",
          "value": "[];",
          "isPublic": true,
          "line": 996,
          "raw": "const promises: Promise<UTxO[]>[] = [];",
          "source": "mesh-contract"
        },
        {
          "name": "scriptsInput",
          "type": "any",
          "value": "await Promise.all(promises);",
          "isPublic": true,
          "line": 1024,
          "raw": "const scriptsInput = await Promise.all(promises);",
          "source": "mesh-contract"
        },
        {
          "name": "contentRegistry",
          "type": "any",
          "value": "parseInlineDatum<any, ContentRegistryDatum>({",
          "isPublic": true,
          "line": 1032,
          "raw": "const contentRegistry = parseInlineDatum<any, ContentRegistryDatum>({",
          "source": "mesh-contract"
        },
        {
          "name": "newContentRegistry",
          "type": "any",
          "value": "this.getContentDatum([",
          "isPublic": true,
          "line": 1035,
          "raw": "const newContentRegistry = this.getContentDatum([",
          "source": "mesh-contract"
        },
        {
          "name": "ownershipRegistry",
          "type": "any",
          "value": "parseInlineDatum<any, OwnershipRegistryDatum>({",
          "isPublic": true,
          "line": 1046,
          "raw": "const ownershipRegistry = parseInlineDatum<any, OwnershipRegistryDatum>({",
          "source": "mesh-contract"
        },
        {
          "name": "newContentRegistry",
          "type": "any",
          "value": "this.getOwnershipDatum([",
          "isPublic": true,
          "line": 1052,
          "raw": "const newContentRegistry = this.getOwnershipDatum([",
          "source": "mesh-contract"
        },
        {
          "name": "contentRegistry",
          "type": "any",
          "value": "parseInlineDatum<any, ContentRegistryDatum>({",
          "isPublic": true,
          "line": 1064,
          "raw": "const contentRegistry = parseInlineDatum<any, ContentRegistryDatum>({",
          "source": "mesh-contract"
        },
        {
          "name": "newContentRegistry",
          "type": "any",
          "value": "this.getContentDatum(contentRegistry);",
          "isPublic": true,
          "line": 1068,
          "raw": "const newContentRegistry = this.getContentDatum(contentRegistry);",
          "source": "mesh-contract"
        },
        {
          "name": "ownershipRegistry",
          "type": "any",
          "value": "parseInlineDatum<any, OwnershipRegistryDatum>({",
          "isPublic": true,
          "line": 1077,
          "raw": "const ownershipRegistry = parseInlineDatum<any, OwnershipRegistryDatum>({",
          "source": "mesh-contract"
        },
        {
          "name": "newContentRegistry",
          "type": "any",
          "value": "this.getOwnershipDatum(ownershipRegistry);",
          "isPublic": true,
          "line": 1084,
          "raw": "const newContentRegistry = this.getOwnershipDatum(ownershipRegistry);",
          "source": "mesh-contract"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  Data,\n  deserializeAddress,\n  ForgeScript,\n  mConStr,\n  mConStr0,\n  mConStr1,\n  mOutputReference,\n  mScriptAddress,\n  NativeScript,\n  resolveScriptHash,\n  serializeNativeScript,\n  stringToHex,\n  toUTF8,\n  UTxO,\n} from \"@meshsdk/core\";\nimport {\n  applyParamsToScript,\n  parseDatumCbor,\n  parseInlineDatum,\n} from \"@meshsdk/core-cst\";\n\nimport { MeshTxInitiator, MeshTxInitiatorInput } from \"../../common\";\nimport { blueprint, getScriptCbor, getScriptInfo, ScriptIndex } from \"./common\";\nimport {\n  ContentRegistryDatum,\n  OracleDatum,\n  OwnershipRegistryDatum,\n  TransferContent,\n  UpdateContent,\n} from \"./type\";\n\n/**\n * Mesh Content Ownership Contract\n *\n * This contract is used to manage the ownership of content.\n * It facilitates on-chain record of content (i.e. file on IPFS) ownership and transfer.\n * While one cannot prefer others from obtaining a copy of the content, the app owner of the\n * contract can serve the single source of truth of who owns the content. With the blockchain\n * trace and record in place, it provides a trustless way to verify the ownership of the content\n * and facilitates further application logics such as royalties, licensing, etc.\n *\n * @example\n * ```typescript\n *  const meshTxBuilder = new MeshTxBuilder({\n *   fetcher: provider, // one of the Providers\n *   submitter: provider,\n *   verbose: true,\n * });\n *\n * const contract = new MeshContentOwnershipContract(\n *   {\n *     mesh: meshTxBuilder,\n *     fetcher: provider,\n *     wallet: wallet,\n *     networkId: 0,\n *   },\n *   {\n *     operationAddress: operationAddress, // the address of the app owner, where most of the actions should be signed by the spending key of this address\n *     paramUtxo: { outputIndex: 0, txHash: \"0000000000000000000000000000000000000000000000000000000000000000\" }, // you can get this from the output of `mintOneTimeMintingPolicy()` transaction\n *     refScriptUtxos?: { // you can get these from the output of `sendRefScriptOnchain()` transactions\n *       contentRegistry: { outputIndex: 0, txHash: \"0000000000000000000000000000000000000000000000000000000000000000\" },\n *       contentRefToken: { outputIndex: 0, txHash: \"0000000000000000000000000000000000000000000000000000000000000000\" },\n *       ownershipRegistry: { outputIndex: 0, txHash: \"0000000000000000000000000000000000000000000000000000000000000000\" },\n *       ownershipRefToken: { outputIndex: 0, txHash: \"0000000000000000000000000000000000000000000000000000000000000000\" },\n *     },\n *   },\n * );\n * ```\n */\nexport class MeshContentOwnershipContract extends MeshTxInitiator {\n  paramUtxo = {\n    txHash: \"0000000000000000000000000000000000000000000000000000000000000000\",\n    outputIndex: 0,\n  };\n  scriptInfo = getScriptInfo({\n    outputIndex: 0,\n    txHash: \"0000000000000000000000000000000000000000000000000000000000000000\",\n  });\n  refScriptUtxos = {\n    contentRefToken: {\n      txHash:\n        \"0000000000000000000000000000000000000000000000000000000000000000\",\n      outputIndex: 0,\n    },\n    ownershipRefToken: {\n      txHash:\n        \"0000000000000000000000000000000000000000000000000000000000000000\",\n      outputIndex: 0,\n    },\n    contentRegistry: {\n      txHash:\n        \"0000000000000000000000000000000000000000000000000000000000000000\",\n      outputIndex: 0,\n    },\n    ownershipRegistry: {\n      txHash:\n        \"0000000000000000000000000000000000000000000000000000000000000000\",\n      outputIndex: 0,\n    },\n  };\n  operationAddress: string;\n  opsKey: string;\n\n  constructor(\n    inputs: MeshTxInitiatorInput,\n    contract: {\n      operationAddress: string;\n      paramUtxo?: UTxO[\"input\"];\n      refScriptUtxos?: {\n        contentRegistry: UTxO[\"input\"];\n        contentRefToken: UTxO[\"input\"];\n        ownershipRegistry: UTxO[\"input\"];\n        ownershipRefToken: UTxO[\"input\"];\n      };\n    },\n  ) {\n    super(inputs);\n\n    this.paramUtxo = contract.paramUtxo || this.paramUtxo;\n    this.refScriptUtxos = contract.refScriptUtxos || this.refScriptUtxos;\n\n    this.scriptInfo = getScriptInfo(\n      this.paramUtxo,\n      this.stakeCredential,\n      this.networkId,\n    );\n\n    this.operationAddress = contract.operationAddress;\n\n    const serializedOpsPlutusAddr = deserializeAddress(this.operationAddress);\n    this.opsKey = serializedOpsPlutusAddr.pubKeyHash;\n  }\n\n  getOwnerNativeScript = () => {\n    const { pubKeyHash: keyHash } = deserializeAddress(this.operationAddress);\n    const nativeScript: NativeScript = {\n      type: \"all\",\n      scripts: [\n        {\n          type: \"sig\",\n          keyHash: keyHash,\n        },\n      ],\n    };\n\n    const { address: scriptAddress } = serializeNativeScript(\n      nativeScript,\n      undefined,\n      this.networkId,\n    );\n\n    return {\n      nativeScript,\n      scriptAddress,\n    };\n  };\n\n  /**\n   * [Setup phase]\n   * This is the first transaction you need to setup the contract.\n   *\n   * This transaction mints the one-time minting policy (a NFT) for the contract.\n   * It will be attached with the datum which serves as the single source of truth for the contract oracle.\n   *\n   * Note: You must save the `paramUtxo` for future transactions.\n   *\n   * @returns {Promise<{ txHexMintOneTimeMintingPolicy: string, txHexSetupOracleUtxo: string, paramUtxo: UTxO[\"input\"] }>}\n   *\n   * @example\n   * ```typescript\n   * const { tx, paramUtxo } = await contract.mintOneTimeMintingPolicy();\n   * const signedTx = await wallet.signTx(tx);\n   * const txHash = await wallet.submitTx(signedTx);\n   * ```\n   */\n  mintOneTimeMintingPolicy = async () => {\n    const { utxos, collateral, walletAddress } =\n      await this.getWalletInfoForTx();\n    if (utxos?.length <= 0) {\n      throw new Error(\"No UTxOs found\");\n    }\n    const paramUtxo = utxos[0]!;\n    const script = blueprint.validators[4]!.compiledCode;\n    const param: Data = mOutputReference(\n      paramUtxo.input.txHash,\n      paramUtxo.input.outputIndex,\n    );\n    const paramScript = applyParamsToScript(script, [param]);\n    const policyId = resolveScriptHash(paramScript, \"V3\");\n    const tokenName = \"\";\n\n    const txHex = await this.mesh\n      .txIn(\n        paramUtxo.input.txHash,\n        paramUtxo.input.outputIndex,\n        paramUtxo.output.amount,\n        paramUtxo.output.address,\n      )\n      .mintPlutusScriptV3()\n      .mint(\"1\", policyId, tokenName)\n      .mintingScript(paramScript)\n      .mintRedeemerValue(mConStr0([]))\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .changeAddress(walletAddress)\n      .selectUtxosFrom(utxos)\n      .complete();\n\n    this.scriptInfo = getScriptInfo(\n      paramUtxo.input,\n      this.stakeCredential,\n      this.networkId,\n    );\n\n    this.paramUtxo = paramUtxo.input;\n\n    return { tx: txHex, paramUtxo: paramUtxo.input };\n  };\n\n  /**\n   * [Setup phase]\n   * This is the second transaction you need to setup the contract.\n   *\n   * This transaction send the NFT to a oracle contract locking the datum,\n   * which serves as the single source of truth for the contract oracle with data integrity.\n   *\n   * Note: You must provide the `paramUtxo` from the `mintOneTimeMintingPolicy` transaction.\n   *\n   * @returns {Promise<string>}\n   *\n   * @example\n   * ```typescript\n   * const txHex = await contract.setupOracleUtxo();\n   * const signedTx = await wallet.signTx(txHex);\n   * const txHash = await wallet.submitTx(signedTx);\n   * ```\n   */\n  setupOracleUtxo = async () => {\n    const { utxos, walletAddress } = await this.getWalletInfoForTx();\n    const datumValue = this.getOracleDatum(0, 0);\n    const txHex = await this.mesh\n      .txOut(this.scriptInfo.oracleValidator.address, [\n        { unit: this.scriptInfo.oracleNFT.hash + \"\", quantity: \"1\" },\n      ])\n      .txOutInlineDatumValue(datumValue)\n      .changeAddress(walletAddress)\n      .selectUtxosFrom(utxos)\n      .complete();\n    return txHex;\n  };\n\n  /**\n   * [Setup phase]\n   * This are the next transactions you need to setup the contract.\n   * You need to run once for each script, and you would likely have to run one after the previous one is confirmed.\n   *\n   * This transaction sends the reference scripts to the blockchain for later transactions,\n   * boosting efficiency and avoid exceeding 16kb of transaction size limits enforced by protocol parameter.\n   *\n   * Note: You must provide the `paramUtxo` from the `mintOneTimeMintingPolicy` transaction.\n   * Note: You must save txHash (after signed and submitted) for `ContentRegistry`, `ContentRefToken`, `OwnershipRegistry`, `OwnershipRefToken` transactions for future transactions.\n   *\n   * @param scriptIndex - \"OracleNFT\" | \"OracleValidator\" | \"ContentRegistry\" | \"ContentRefToken\" | \"OwnershipRegistry\" | \"OwnershipRefToken\"\n   * @returns {Promise<string>}\n   *\n   * @example\n   * ```typescript\n   * const txHexOracleNFT = await contract.sendRefScriptOnchain(\"OracleNFT\");\n   * const signedTxOracleNFT = await wallet.signTx(txHexOracleNFT);\n   * const txHashOracleNFT = await wallet.submitTx(signedTxOracleNFT);\n   *\n   * const txHexOracleValidator = await contract.sendRefScriptOnchain(\"OracleValidator\");\n   * ... // repeat for each script\n   *\n   * const txHexOwnershipRefToken = await contract.sendRefScriptOnchain(\"OwnershipRefToken\");\n   * const signedTxOwnershipRefToken = await wallet.signTx(txHexOwnershipRefToken);\n   * const txHashOwnershipRefToken = await wallet.submitTx(signedTxOwnershipRefToken);\n   * ```\n   */\n  sendRefScriptOnchain = async (scriptIndex: ScriptIndex) => {\n    const { utxos, walletAddress } = await this.getWalletInfoForTx();\n    const { scriptAddress } = this.getOwnerNativeScript();\n    const txHex = await this.mesh\n      .txOut(scriptAddress, [])\n      .txOutReferenceScript(getScriptCbor(this.paramUtxo, scriptIndex))\n      .changeAddress(walletAddress)\n      .selectUtxosFrom(utxos)\n      .complete();\n    return txHex;\n  };\n\n  /**\n   * [Setup phase]\n   * This is the next transaction you need to setup the contract after completing all the `sendRefScriptOnchain` transactions.\n   *\n   * This transaction creates one content registry. Each registry should comes in pair with one ownership registry and\n   * each pair of registry serves around 50 records of content ownership. The application can be scaled indefinitely\n   * according to the number of parallelization needed and volumes of content expected to be managed.\n   *\n   * Note: You must provide the `paramUtxo` from the `mintOneTimeMintingPolicy` transaction.\n   * Note: You must provide the txHash for `ContentRegistry`, `ContentRefToken`, `OwnershipRegistry`, `OwnershipRefToken`\n   *\n   * @returns {Promise<string>}\n   *\n   * @example\n   * ```typescript\n   * const txHex = await contract.createContentRegistry();\n   * const signedTx = await wallet.signTx(txHex);\n   * const txHash = await wallet.submitTx(signedTx);\n   * ```\n   */\n  createContentRegistry = async () => {\n    const { utxos, collateral, walletAddress } =\n      await this.getWalletInfoForTx();\n    const scriptUtxo = await this.fetcher!.fetchAddressUTxOs(\n      this.scriptInfo.oracleValidator.address,\n      this.scriptInfo.oracleNFT.hash,\n    );\n    const currentOracleDatum = await this.getCurrentOracleDatum(scriptUtxo);\n    const contentNumber = currentOracleDatum.fields[4].int as number;\n    const ownershipNumber = currentOracleDatum.fields[7].int as number;\n    const contentTokenName = stringToHex(`Registry (${contentNumber})`);\n    const {\n      input: { txHash: oracleTxHash, outputIndex: oracleTxId },\n      output: { address: oracleAddress, amount: oracleValue },\n    } = scriptUtxo[0]!;\n    const oracleDatumValue = this.getOracleDatum(\n      contentNumber + 1,\n      ownershipNumber,\n    );\n    console.log(\"Oracle Datum\", oracleDatumValue);\n    console.log(\"this.refScriptUtxos\", this.refScriptUtxos);\n\n    const txHex = await this.mesh\n      .spendingPlutusScriptV3()\n      .txIn(oracleTxHash, oracleTxId, oracleValue, oracleAddress)\n      .txInInlineDatumPresent()\n      .txInRedeemerValue(mConStr0([]))\n      .txInScript(this.scriptInfo.oracleValidator.cbor)\n      .txOut(this.scriptInfo.oracleValidator.address, [\n        { unit: this.scriptInfo.oracleNFT.hash + \"\", quantity: \"1\" },\n      ])\n      .txOutInlineDatumValue(oracleDatumValue)\n      .txOut(this.scriptInfo.contentRegistry.address, [\n        {\n          unit: this.scriptInfo.contentRefToken.hash + contentTokenName,\n          quantity: \"1\",\n        },\n      ])\n      .txOutInlineDatumValue(mConStr0([0, []]))\n      .mintPlutusScriptV3()\n      .mint(\"1\", this.scriptInfo.contentRefToken.hash, contentTokenName)\n      .mintTxInReference(\n        this.refScriptUtxos.contentRefToken.txHash,\n        this.refScriptUtxos.contentRefToken.outputIndex,\n        (this.scriptInfo.contentRefToken.cbor.length / 2).toString(),\n        this.scriptInfo.contentRefToken.hash,\n      )\n      .mintRedeemerValue(mConStr0([]))\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .changeAddress(walletAddress)\n      .selectUtxosFrom(utxos)\n      .complete();\n\n    return txHex;\n  };\n\n  /**\n   * [Setup phase]\n   * This is the last transaction you need to setup the contract after completing all the `sendRefScriptOnchain` transactions.\n   *\n   * This transaction creates one content registry. Each registry should comes in pair with one content registry and\n   * each pair of registry serves around 50 records of content ownership. The application can be scaled indefinitely\n   * according to the number of parallelization needed and volumes of content expected to be managed.\n   *\n   * Note: You must provide the `paramUtxo` from the `mintOneTimeMintingPolicy` transaction.\n   * Note: You must provide the txHash for `ContentRegistry`, `ContentRefToken`, `OwnershipRegistry`, `OwnershipRefToken`\n   *\n   * @returns {Promise<string>}\n   *\n   * @example\n   * ```typescript\n   * const txHex = await contract.createOwnershipRegistry();\n   * const signedTx = await wallet.signTx(txHex);\n   * const txHash = await wallet.submitTx(signedTx);\n   * ```\n   */\n  createOwnershipRegistry = async () => {\n    const { utxos, collateral, walletAddress } =\n      await this.getWalletInfoForTx();\n    const scriptUtxo = await this.fetcher!.fetchAddressUTxOs(\n      this.scriptInfo.oracleValidator.address,\n      this.scriptInfo.oracleNFT.hash,\n    );\n    const currentOracleDatum = await this.getCurrentOracleDatum(scriptUtxo);\n    const contentNumber = currentOracleDatum.fields[4].int as number;\n    const ownershipNumber = currentOracleDatum.fields[7].int as number;\n    const ownershipTokenName = stringToHex(`Registry (${ownershipNumber})`);\n    const {\n      input: { txHash: oracleTxHash, outputIndex: oracleTxId },\n      output: { address: oracleAddress, amount: oracleValue },\n    } = scriptUtxo[0]!;\n    const oracleDatumValue = this.getOracleDatum(\n      contentNumber,\n      ownershipNumber + 1,\n    );\n    console.log(\"Oracle Datum\", oracleDatumValue);\n\n    const txHex = await this.mesh\n      .spendingPlutusScriptV3()\n      .txIn(oracleTxHash, oracleTxId, oracleValue, oracleAddress)\n      .txInInlineDatumPresent()\n      .txInRedeemerValue(mConStr1([]))\n      .txInScript(this.scriptInfo.oracleValidator.cbor)\n      .txOut(this.scriptInfo.oracleValidator.address, [\n        { unit: this.scriptInfo.oracleNFT.hash + \"\", quantity: \"1\" },\n      ])\n      .txOutInlineDatumValue(oracleDatumValue)\n      .txOut(this.scriptInfo.ownershipRegistry.address, [\n        {\n          unit: this.scriptInfo.ownershipRefToken.hash + ownershipTokenName,\n          quantity: \"1\",\n        },\n      ])\n      .txOutInlineDatumValue(mConStr0([0, []]))\n      .mintPlutusScriptV3()\n      .mint(\"1\", this.scriptInfo.ownershipRefToken.hash, ownershipTokenName)\n      .mintTxInReference(\n        this.refScriptUtxos.ownershipRefToken.txHash,\n        this.refScriptUtxos.ownershipRefToken.outputIndex,\n        (this.scriptInfo.ownershipRefToken.cbor.length / 2).toString(),\n        this.scriptInfo.ownershipRefToken.hash,\n      )\n      .mintRedeemerValue(mConStr0([]))\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .changeAddress(walletAddress)\n      .selectUtxosFrom(utxos)\n      .complete();\n\n    return txHex;\n  };\n\n  /**\n   * Get the current oracle data.\n   *\n   * @returns {Promise<{\n   *  contentNumber: number,\n   *  ownershipNumber: number,\n   * }>}\n   *\n   * @example\n   * ```typescript\n   * const oracleData = await contract.getOracleData();\n   * ```\n   */\n  getOracleData = async () => {\n    const scriptUtxo = await this.fetcher!.fetchAddressUTxOs(\n      this.scriptInfo.oracleValidator.address,\n      this.scriptInfo.oracleNFT.hash,\n    );\n    const currentOracleDatum = await this.getCurrentOracleDatum(scriptUtxo);\n\n    const contentNumber = currentOracleDatum.fields[4].int as number;\n    const ownershipNumber = currentOracleDatum.fields[7].int as number;\n\n    return {\n      contentNumber,\n      ownershipNumber,\n    };\n  };\n\n  /**\n   * [User]\n   *\n   * This transaction mints a user token which can be used to represent the ownership of the content. This token is used in `createContent()` transaction.\n   *\n   * @param tokenName - The name of the token that you can specify.\n   * @param tokenMetadata - The metadata of the token that you can specify.\n   * @returns {Promise<string>}\n   *\n   * @example\n   * ```typescript\n   * const tx = await contract.mintUserToken(\"MeshContentOwnership\", {\n   *   name: \"Mesh Content Ownership\",\n   *   description: \"Demo at https://meshjs.dev/smart-contracts/content-ownership\",\n   * });\n   * const signedTx = await wallet.signTx(tx, true);\n   * const txHash = await wallet.submitTx(signedTx);\n   */\n  mintUserToken = async (tokenName: string, tokenMetadata = {}) => {\n    const { utxos, walletAddress } = await this.getWalletInfoForTx();\n\n    const { pubKeyHash: keyHash } = deserializeAddress(walletAddress);\n    const nativeScript: NativeScript = {\n      type: \"all\",\n      scripts: [\n        {\n          type: \"sig\",\n          keyHash: keyHash,\n        },\n      ],\n    };\n\n    const forgingScript = ForgeScript.fromNativeScript(nativeScript);\n\n    const policyId = resolveScriptHash(forgingScript);\n    const tokenNameHex = stringToHex(tokenName);\n    const metadata = { [policyId]: { [tokenName]: { ...tokenMetadata } } };\n\n    const txHex = await this.mesh\n      .mint(\"1\", policyId, tokenNameHex)\n      .mintingScript(forgingScript)\n      .metadataValue(721, metadata)\n      .changeAddress(walletAddress)\n      .selectUtxosFrom(utxos)\n      .complete();\n\n    return txHex;\n  };\n\n  /**\n   *\n   * @param ownerAssetHex\n   * @param contentHashHex\n   * @param registryNumber\n   * @returns\n   */\n  createContent = async (\n    ownerAssetHex: string,\n    contentHashHex: string,\n    registryNumber = 0,\n  ) => {\n    const { utxos, collateral, walletAddress } =\n      await this.getWalletInfoForTx();\n    const registryName = stringToHex(`Registry (${registryNumber})`);\n    const oracleUtxo: UTxO[] = await this.fetcher!.fetchAddressUTxOs(\n      this.scriptInfo.oracleValidator.address,\n      this.scriptInfo.oracleNFT.hash,\n    );\n    const contentUtxo: UTxO[] = await this.fetcher!.fetchAddressUTxOs(\n      this.scriptInfo.contentRegistry.address,\n      this.scriptInfo.contentRefToken.hash + registryName,\n    );\n    const ownershipUtxo: UTxO[] = await this.fetcher!.fetchAddressUTxOs(\n      this.scriptInfo.ownershipRegistry.address,\n      this.scriptInfo.ownershipRefToken.hash + registryName,\n    );\n    const { txHash: oracleTxHash, outputIndex: oracleTxId } =\n      oracleUtxo[0]!.input;\n\n    const {\n      input: { txHash: contentTxHash, outputIndex: contentTxId },\n      output: { address: _contentAddress, amount: contentAmount },\n    } = contentUtxo[0]!;\n    const {\n      input: { txHash: ownershipTxHash, outputIndex: ownershipTxId },\n      output: { amount: ownershipValue, address: ownershipAddress },\n    } = ownershipUtxo[0]!;\n    const ownerAssetClass: [string, string] = [\n      ownerAssetHex.slice(0, 56),\n      ownerAssetHex.slice(56),\n    ];\n    const newContentRegistry = this.insertContentRegistry(\n      contentUtxo[0]!.output.plutusData!,\n      contentHashHex,\n    );\n    const newOwnershipRegistry = this.insertOwnershipRegistry(\n      ownershipUtxo[0]!.output.plutusData!,\n      ownerAssetClass,\n    );\n\n    const txHex = await this.mesh\n      .spendingPlutusScriptV3()\n      .txIn(\n        contentTxHash,\n        contentTxId,\n        contentAmount,\n        this.scriptInfo.contentRegistry.address,\n      )\n      .txInInlineDatumPresent()\n      .txInRedeemerValue(mConStr(0, [contentHashHex, ownerAssetClass]))\n      .spendingTxInReference(\n        this.refScriptUtxos.contentRegistry.txHash,\n        this.refScriptUtxos.contentRegistry.outputIndex,\n        (this.scriptInfo.contentRegistry.cbor.length / 2).toString(),\n        this.scriptInfo.contentRegistry.hash,\n      )\n      .txOut(this.scriptInfo.contentRegistry.address, [\n        {\n          unit: this.scriptInfo.contentRefToken.hash + registryName,\n          quantity: \"1\",\n        },\n      ])\n      .txOutInlineDatumValue(newContentRegistry)\n      .spendingPlutusScriptV3()\n      .txIn(ownershipTxHash, ownershipTxId, ownershipValue, ownershipAddress)\n      .txInInlineDatumPresent()\n      .txInRedeemerValue(mConStr(0, []))\n      .spendingTxInReference(\n        this.refScriptUtxos.ownershipRegistry.txHash,\n        this.refScriptUtxos.ownershipRegistry.outputIndex,\n        (this.scriptInfo.ownershipRegistry.cbor.length / 2).toString(),\n        this.scriptInfo.ownershipRegistry.hash,\n      )\n      .txOut(this.scriptInfo.ownershipRegistry.address, [\n        {\n          unit: this.scriptInfo.ownershipRefToken.hash + registryName,\n          quantity: \"1\",\n        },\n      ])\n      .txOutInlineDatumValue(newOwnershipRegistry)\n      .readOnlyTxInReference(oracleTxHash, oracleTxId)\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n\n    return txHex;\n  };\n\n  /**\n   * Get the content at the registry given the registry number and content number.\n   * @param registryNumber\n   * @param contentNumber\n   * @returns\n   */\n  getContent = async (registryNumber: number, contentNumber: number) => {\n    const [content] = await this.getScriptUtxos(registryNumber, [\"content\"]);\n\n    if (content === undefined) throw new Error(\"Content registry not found\");\n\n    const contentDatam: ContentRegistryDatum = parseDatumCbor(\n      content.output.plutusData!,\n    );\n\n    const contentAtRegistry = contentDatam.fields[1].list;\n\n    if (contentAtRegistry.length <= contentNumber)\n      throw new Error(\"Content not found\");\n\n    const decoded = toUTF8(contentAtRegistry[contentNumber]?.bytes!);\n\n    return decoded;\n  };\n\n  updateContent = async ({\n    ownerTokenUtxo,\n    registryNumber,\n    newContentHashHex,\n    contentNumber,\n  }: UpdateContent) => {\n    const { utxos, collateral, walletAddress } =\n      await this.getWalletInfoForTx();\n    const registryTokenNameHex = stringToHex(`Registry (${registryNumber})`);\n    const [oracle, content, ownership] =\n      await this.getScriptUtxos(registryNumber);\n    const newContentRegistry = this.updateContentRegistry(\n      content!.output.plutusData!,\n      contentNumber,\n      newContentHashHex,\n    );\n\n    await this.mesh\n      .txIn(\n        ownerTokenUtxo.input.txHash,\n        ownerTokenUtxo.input.outputIndex,\n        ownerTokenUtxo.output.amount,\n        ownerTokenUtxo.output.address,\n      )\n      .spendingPlutusScriptV3()\n      .txIn(\n        content!.input.txHash,\n        content!.input.outputIndex,\n        content!.output.amount,\n        content!.output.address,\n      )\n      .txInInlineDatumPresent()\n      .txInRedeemerValue(mConStr(1, [newContentHashHex, contentNumber]))\n      .spendingTxInReference(\n        this.refScriptUtxos.contentRegistry.txHash,\n        this.refScriptUtxos.contentRegistry.outputIndex,\n        (this.scriptInfo.contentRegistry.cbor.length / 2).toString(),\n        this.scriptInfo.contentRegistry.hash,\n      )\n      .txOut(this.scriptInfo.contentRegistry.address, [\n        {\n          unit: this.scriptInfo.contentRefToken.hash + registryTokenNameHex,\n          quantity: \"1\",\n        },\n      ])\n      .txOutInlineDatumValue(newContentRegistry)\n      .readOnlyTxInReference(oracle!.input.txHash, oracle!.input.outputIndex)\n      .readOnlyTxInReference(\n        ownership!.input.txHash,\n        ownership!.input.outputIndex,\n      )\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    const txBody = this.mesh.completeSigning();\n    return txBody;\n  };\n\n  transferContent = async ({\n    ownerTokenUtxo,\n    registryNumber,\n    newOwnerAssetHex,\n    contentNumber,\n  }: TransferContent) => {\n    const { utxos, collateral, walletAddress } =\n      await this.getWalletInfoForTx();\n    const registryTokenNameHex = stringToHex(`Registry (${registryNumber})`);\n    const [oracle, ownership] = await this.getScriptUtxos(registryNumber, [\n      \"oracle\",\n      \"ownership\",\n    ]);\n    const newOwnerAssetClass: [string, string] = [\n      newOwnerAssetHex.slice(0, 56),\n      newOwnerAssetHex.slice(56),\n    ];\n    const newOwnershipRegistry = this.updateOwnershipRegistry(\n      ownership!.output.plutusData!,\n      contentNumber,\n      newOwnerAssetClass,\n    );\n\n    await this.mesh\n      .txIn(\n        ownerTokenUtxo.input.txHash,\n        ownerTokenUtxo.input.outputIndex,\n        ownerTokenUtxo.output.amount,\n        ownerTokenUtxo.output.address,\n      )\n      .spendingPlutusScriptV3()\n      .txIn(\n        ownership!.input.txHash,\n        ownership!.input.outputIndex,\n        ownership!.output.amount,\n        ownership!.output.address,\n      )\n      .txInInlineDatumPresent()\n      .txInRedeemerValue(mConStr(1, [newOwnerAssetClass, contentNumber]))\n      .spendingTxInReference(\n        this.refScriptUtxos.ownershipRegistry.txHash,\n        this.refScriptUtxos.ownershipRegistry.outputIndex,\n        (this.scriptInfo.ownershipRegistry.cbor.length / 2).toString(),\n        this.scriptInfo.ownershipRegistry.hash,\n      )\n      .txOut(this.scriptInfo.ownershipRegistry.address, [\n        {\n          unit: this.scriptInfo.ownershipRefToken.hash + registryTokenNameHex,\n          quantity: \"1\",\n        },\n      ])\n      .txOutInlineDatumValue(newOwnershipRegistry)\n      .readOnlyTxInReference(oracle!.input.txHash, oracle!.input.outputIndex)\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    const txBody = this.mesh.completeSigning();\n    return txBody;\n  };\n\n  // Admin\n\n  stopContentRegistry = async (registryNumber: number) => {\n    const { utxos, collateral, walletAddress } =\n      await this.getWalletInfoForTx();\n    const registryTokenNameHex = stringToHex(`Registry (${registryNumber})`);\n    const scriptUtxos = await this.fetcher!.fetchAddressUTxOs(\n      this.scriptInfo.contentRegistry.address,\n      this.scriptInfo.contentRefToken.hash + registryTokenNameHex,\n    );\n    const oracleUtxo = await this.fetcher!.fetchAddressUTxOs(\n      this.scriptInfo.oracleValidator.address,\n      this.scriptInfo.oracleNFT.hash,\n    );\n    const { txHash: oracleTxHash, outputIndex: oracleTxId } =\n      oracleUtxo[0]!.input;\n    const {\n      input: { txHash: validatorTxHash, outputIndex: validatorTxId },\n      output: { amount: scriptValue, address: scriptAddress },\n    } = scriptUtxos[0]!;\n\n    const txHex = await this.mesh\n      .spendingPlutusScriptV3()\n      .txIn(validatorTxHash, validatorTxId, scriptValue, scriptAddress)\n      .txInInlineDatumPresent()\n      .txInRedeemerValue(mConStr(2, []))\n      .txInScript(this.scriptInfo.contentRegistry.cbor)\n      .mintPlutusScriptV2()\n      .mint(\"-1\", this.scriptInfo.contentRefToken.hash, registryTokenNameHex)\n      .mintTxInReference(\n        this.refScriptUtxos.contentRefToken.txHash,\n        this.refScriptUtxos.contentRefToken.outputIndex,\n        (this.scriptInfo.contentRefToken.cbor.length / 2).toString(),\n        this.scriptInfo.contentRefToken.hash,\n      )\n      .mintRedeemerValue(mConStr1([]))\n      .readOnlyTxInReference(oracleTxHash, oracleTxId)\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .requiredSignerHash(this.opsKey)\n      .selectUtxosFrom(utxos)\n      .complete();\n\n    return txHex;\n  };\n\n  stopOwnershipRegistry = async (registryNumber: number) => {\n    const { utxos, collateral, walletAddress } =\n      await this.getWalletInfoForTx();\n    const registryTokenNameHex = stringToHex(`Registry (${registryNumber})`);\n    const scriptUtxos = await this.fetcher!.fetchAddressUTxOs(\n      this.scriptInfo.ownershipRegistry.address,\n      this.scriptInfo.ownershipRefToken.hash + registryTokenNameHex,\n    );\n    const oracleUtxo = await this.fetcher!.fetchAddressUTxOs(\n      this.scriptInfo.oracleValidator.address,\n      this.scriptInfo.oracleNFT.hash,\n    );\n    const { txHash: oracleTxHash, outputIndex: oracleTxId } =\n      oracleUtxo[0]!.input;\n    const {\n      input: { txHash: validatorTxHash, outputIndex: validatorTxId },\n      output: { amount: scriptValue, address: scriptAddress },\n    } = scriptUtxos[0]!;\n\n    const txHex = await this.mesh\n      .spendingPlutusScriptV3()\n      .txIn(validatorTxHash, validatorTxId, scriptValue, scriptAddress)\n      .txInInlineDatumPresent()\n      .txInRedeemerValue(mConStr(2, []))\n      .txInScript(this.scriptInfo.ownershipRegistry.cbor)\n      .mintPlutusScriptV2()\n      .mint(\"-1\", this.scriptInfo.ownershipRefToken.hash, registryTokenNameHex)\n      .mintTxInReference(\n        this.refScriptUtxos.ownershipRefToken.txHash,\n        this.refScriptUtxos.ownershipRefToken.outputIndex,\n        (this.scriptInfo.ownershipRefToken.cbor.length / 2).toString(),\n        this.scriptInfo.ownershipRefToken.hash,\n      )\n      .mintRedeemerValue(mConStr1([]))\n      .readOnlyTxInReference(oracleTxHash, oracleTxId)\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .requiredSignerHash(this.opsKey)\n      .selectUtxosFrom(utxos)\n      .complete();\n\n    return txHex;\n  };\n\n  stopOracle = async (txInHash: string, txInId: number) => {\n    const { utxos, collateral, walletAddress } =\n      await this.getWalletInfoForTx();\n\n    const oracleUtxo = await this.fetcher!.fetchAddressUTxOs(\n      this.scriptInfo.oracleValidator.address,\n      this.scriptInfo.oracleNFT.hash,\n    );\n    const { txHash, outputIndex } = oracleUtxo[0]!.input;\n\n    const txHex = await this.mesh\n      .txIn(txInHash, txInId)\n      .spendingPlutusScriptV3()\n      .txIn(txHash, outputIndex)\n      .txInInlineDatumPresent()\n      .txInRedeemerValue(mConStr(3, []))\n      .txInScript(this.scriptInfo.oracleValidator.cbor)\n      .mintPlutusScriptV2()\n      .mint(\"-1\", this.scriptInfo.oracleNFT.hash, \"\")\n      .mintingScript(this.scriptInfo.oracleNFT.cbor)\n      .mintRedeemerValue(mConStr1([]))\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .requiredSignerHash(this.opsKey)\n      .requiredSignerHash(this.opsKey)\n      .selectUtxosFrom(utxos)\n      .complete();\n\n    return txHex;\n  };\n\n  // Helpers\n\n  protected getCurrentOracleDatum = async (utxos?: UTxO[]) => {\n    let oracleUtxo: UTxO[] = utxos || [];\n    if (oracleUtxo.length === 0) {\n      oracleUtxo = await this.fetcher!.fetchAddressUTxOs(\n        this.scriptInfo.oracleValidator.address,\n        this.scriptInfo.oracleNFT.hash,\n      );\n    }\n    const oracleDatum = parseInlineDatum<any, OracleDatum>({\n      inline_datum: oracleUtxo[0]!.output.plutusData!,\n    });\n    return oracleDatum;\n  };\n\n  protected getOracleDatum = (\n    contentRegistryCount: number,\n    ownershipRegistryCount: number,\n  ) => {\n    const oracleAddr = mScriptAddress(\n      this.scriptInfo.oracleValidator.hash,\n      this.stakeCredential,\n    );\n    const contentRegistryAddr = mScriptAddress(\n      this.scriptInfo.contentRegistry.hash,\n      this.stakeCredential,\n    );\n    const ownershipRegistryAddr = mScriptAddress(\n      this.scriptInfo.ownershipRegistry.hash,\n      this.stakeCredential,\n    );\n\n    return mConStr0([\n      this.scriptInfo.oracleNFT.hash,\n      oracleAddr,\n      this.scriptInfo.contentRefToken.hash,\n      contentRegistryAddr,\n      contentRegistryCount,\n      this.scriptInfo.ownershipRefToken.hash,\n      ownershipRegistryAddr,\n      ownershipRegistryCount,\n      this.opsKey,\n      this.opsKey,\n    ]);\n  };\n\n  protected getContentDatum = (contentArray: string[]) => {\n    return mConStr0([contentArray.length, contentArray]);\n  };\n\n  protected getOwnershipDatum = (ownershipArray: [string, string][]) => {\n    return mConStr0([ownershipArray.length, ownershipArray]);\n  };\n\n  getScriptUtxos = async (\n    registryNumber: number,\n    toFetch: (\"oracle\" | \"content\" | \"ownership\")[] = [\n      \"oracle\",\n      \"content\",\n      \"ownership\",\n    ],\n  ) => {\n    const registryTokenNameHex = stringToHex(`Registry (${registryNumber})`);\n    const promises: Promise<UTxO[]>[] = [];\n    toFetch.forEach((script) => {\n      switch (script) {\n        case \"oracle\":\n          promises.push(\n            this.fetcher!.fetchAddressUTxOs(\n              this.scriptInfo.oracleValidator.address,\n              this.scriptInfo.oracleNFT.hash,\n            ),\n          );\n          break;\n        case \"content\":\n          promises.push(\n            this.fetcher!.fetchAddressUTxOs(\n              this.scriptInfo.contentRegistry.address,\n              this.scriptInfo.contentRefToken.hash + registryTokenNameHex,\n            ),\n          );\n        case \"ownership\":\n          promises.push(\n            this.fetcher!.fetchAddressUTxOs(\n              this.scriptInfo.ownershipRegistry.address,\n              this.scriptInfo.ownershipRefToken.hash + registryTokenNameHex,\n            ),\n          );\n          break;\n      }\n    });\n    const scriptsInput = await Promise.all(promises);\n    return scriptsInput.map((utxos) => utxos[0]);\n  };\n\n  private insertContentRegistry = (\n    plutusData: string,\n    newContentHash: string,\n  ): Data => {\n    const contentRegistry = parseInlineDatum<any, ContentRegistryDatum>({\n      inline_datum: plutusData,\n    }).fields[1].list.map((plutusBytes) => plutusBytes.bytes);\n    const newContentRegistry = this.getContentDatum([\n      ...contentRegistry,\n      newContentHash,\n    ]);\n    return newContentRegistry;\n  };\n\n  private insertOwnershipRegistry = (\n    plutusData: string,\n    ownerAssetClass: [string, string],\n  ): Data => {\n    const ownershipRegistry = parseInlineDatum<any, OwnershipRegistryDatum>({\n      inline_datum: plutusData,\n    }).fields[1].list.map((plutusBytesArray): [string, string] => [\n      plutusBytesArray.list[0].bytes,\n      plutusBytesArray.list[1].bytes,\n    ]);\n    const newContentRegistry = this.getOwnershipDatum([\n      ...ownershipRegistry,\n      ownerAssetClass,\n    ]);\n    return newContentRegistry;\n  };\n\n  private updateContentRegistry = (\n    plutusData: string,\n    contentNumber: number,\n    newContentHash: string,\n  ): Data => {\n    const contentRegistry = parseInlineDatum<any, ContentRegistryDatum>({\n      inline_datum: plutusData,\n    }).fields[1].list.map((plutusBytes) => plutusBytes.bytes);\n    contentRegistry[contentNumber] = newContentHash;\n    const newContentRegistry = this.getContentDatum(contentRegistry);\n    return newContentRegistry;\n  };\n\n  private updateOwnershipRegistry = (\n    plutusData: string,\n    contentNumber: number,\n    ownerAssetClass: [string, string],\n  ): Data => {\n    const ownershipRegistry = parseInlineDatum<any, OwnershipRegistryDatum>({\n      inline_datum: plutusData,\n    }).fields[1].list.map((plutusBytesArray): [string, string] => [\n      plutusBytesArray.list[0].bytes,\n      plutusBytesArray.list[1].bytes,\n    ]);\n    ownershipRegistry[contentNumber] = ownerAssetClass;\n    const newContentRegistry = this.getOwnershipDatum(ownershipRegistry);\n    return newContentRegistry;\n  };\n}\n",
      "dependencies": [
        "MeshContentOwnershipContract"
      ],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:content-ownership.offchain.type.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/content-ownership/offchain/type.ts",
      "name": "content-ownership.offchain.type.ts",
      "imports": [
        {
          "module": "OracleDatum",
          "items": [],
          "line": 10,
          "raw": "export type OracleDatum = ConStr0<",
          "source": "mesh-contract"
        },
        {
          "module": "ContentRegistryDatum",
          "items": [],
          "line": 25,
          "raw": "export type ContentRegistryDatum = ConStr0<[Integer, List<BuiltinByteString>]>;",
          "source": "mesh-contract"
        },
        {
          "module": "OwnershipRegistryDatum",
          "items": [],
          "line": 27,
          "raw": "export type OwnershipRegistryDatum = ConStr0<",
          "source": "mesh-contract"
        },
        {
          "module": "UpdateContent",
          "items": [],
          "line": 31,
          "raw": "export type UpdateContent = {",
          "source": "mesh-contract"
        },
        {
          "module": "TransferContent",
          "items": [],
          "line": 38,
          "raw": "export type TransferContent = {",
          "source": "mesh-contract"
        }
      ],
      "functions": [],
      "types": [
        {
          "name": "OracleDatum",
          "definition": "export type OracleDatum = ConStr0<\n  [\n    BuiltinByteString, // oracle_nft: PolicyId,\n    ScriptAddress, // oracle_address: Address,\n    BuiltinByteString, // content_registry_ref_token: PolicyId,\n    ScriptAddress, // content_registry_address: Address,\n    Integer, // content_registry_count: Int,\n    BuiltinByteString, // ownership_registry_ref_token: PolicyId,\n    ScriptAddress, // ownership_registry_address: Address,\n    Integer, // ownership_registry_count: Int,\n    BuiltinByteString, // operation_key: ByteArray,\n    BuiltinByteString, // stop_key: ByteArray,\n  ]\n>;",
          "isPublic": true,
          "line": 10,
          "raw": "export type OracleDatum = ConStr0<",
          "source": "mesh-contract"
        },
        {
          "name": "ContentRegistryDatum",
          "definition": "export type ContentRegistryDatum = ConStr0<[Integer, List<BuiltinByteString>]>;",
          "isPublic": true,
          "line": 25,
          "raw": "export type ContentRegistryDatum = ConStr0<[Integer, List<BuiltinByteString>]>;",
          "source": "mesh-contract"
        },
        {
          "name": "OwnershipRegistryDatum",
          "definition": "export type OwnershipRegistryDatum = ConStr0<\n  [Integer, List<{ list: [BuiltinByteString, BuiltinByteString] }>]\n>;",
          "isPublic": true,
          "line": 27,
          "raw": "export type OwnershipRegistryDatum = ConStr0<",
          "source": "mesh-contract"
        },
        {
          "name": "UpdateContent",
          "definition": "export type UpdateContent = {\n  ownerTokenUtxo: UTxO;\n  registryNumber: number;",
          "isPublic": true,
          "line": 31,
          "raw": "export type UpdateContent = {",
          "source": "mesh-contract"
        },
        {
          "name": "TransferContent",
          "definition": "export type TransferContent = {\n  ownerTokenUtxo: UTxO;\n  registryNumber: number;",
          "isPublic": true,
          "line": 38,
          "raw": "export type TransferContent = {",
          "source": "mesh-contract"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  BuiltinByteString,\n  ConStr0,\n  Integer,\n  List,\n  ScriptAddress,\n  UTxO,\n} from \"@meshsdk/core\";\n\nexport type OracleDatum = ConStr0<\n  [\n    BuiltinByteString, // oracle_nft: PolicyId,\n    ScriptAddress, // oracle_address: Address,\n    BuiltinByteString, // content_registry_ref_token: PolicyId,\n    ScriptAddress, // content_registry_address: Address,\n    Integer, // content_registry_count: Int,\n    BuiltinByteString, // ownership_registry_ref_token: PolicyId,\n    ScriptAddress, // ownership_registry_address: Address,\n    Integer, // ownership_registry_count: Int,\n    BuiltinByteString, // operation_key: ByteArray,\n    BuiltinByteString, // stop_key: ByteArray,\n  ]\n>;\n\nexport type ContentRegistryDatum = ConStr0<[Integer, List<BuiltinByteString>]>;\n\nexport type OwnershipRegistryDatum = ConStr0<\n  [Integer, List<{ list: [BuiltinByteString, BuiltinByteString] }>]\n>;\n\nexport type UpdateContent = {\n  ownerTokenUtxo: UTxO;\n  registryNumber: number;\n  newContentHashHex: string;\n  contentNumber: number;\n};\n\nexport type TransferContent = {\n  ownerTokenUtxo: UTxO;\n  registryNumber: number;\n  newOwnerAssetHex: string;\n  contentNumber: number;\n};\n",
      "dependencies": [
        "OracleDatum",
        "ContentRegistryDatum",
        "OwnershipRegistryDatum",
        "UpdateContent",
        "TransferContent"
      ],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:escrow.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/escrow/index.ts",
      "name": "escrow.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from './offchain';\n",
      "dependencies": [],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:escrow.offchain.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/escrow/offchain.ts",
      "name": "escrow.offchain.ts",
      "imports": [
        {
          "module": "InitiationDatum",
          "items": [],
          "line": 30,
          "raw": "export type InitiationDatum = ConStr0<[PubKeyAddress, Value]>;",
          "source": "mesh-contract"
        },
        {
          "module": "initiateEscrowDatum",
          "items": [],
          "line": 31,
          "raw": "export const initiateEscrowDatum = (",
          "source": "mesh-contract"
        },
        {
          "module": "ActiveEscrowDatum",
          "items": [],
          "line": 42,
          "raw": "export type ActiveEscrowDatum = ConStr1<",
          "source": "mesh-contract"
        },
        {
          "module": "activeEscrowDatum",
          "items": [],
          "line": 45,
          "raw": "export const activeEscrowDatum = (",
          "source": "mesh-contract"
        },
        {
          "module": "RecipientDepositRedeemer",
          "items": [],
          "line": 60,
          "raw": "export type RecipientDepositRedeemer = ConStr0<[PubKeyAddress, Value]>;",
          "source": "mesh-contract"
        },
        {
          "module": "recipientDepositRedeemer",
          "items": [],
          "line": 61,
          "raw": "export const recipientDepositRedeemer = (",
          "source": "mesh-contract"
        },
        {
          "module": "MeshEscrowContract",
          "items": [],
          "line": 66,
          "raw": "export class MeshEscrowContract extends MeshTxInitiator {",
          "source": "mesh-contract"
        }
      ],
      "functions": [
        {
          "name": "initiateEscrowDatum",
          "signature": "export const initiateEscrowDatum = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 31,
          "raw": "export const initiateEscrowDatum = (\n  walletAddress: string,\n  amount: Asset[],\n): InitiationDatum => {\n  const { pubKeyHash, stakeCredentialHash } = deserializeAddress(walletAddress);\n  return conStr0([\n    pubKeyAddress(pubKeyHash, stakeCredentialHash),\n    value(amount),\n  ]);\n};",
          "source": "mesh-contract",
          "implementation": "export const initiateEscrowDatum = (\n  walletAddress: string,\n  amount: Asset[],\n): InitiationDatum => {\n  const { pubKeyHash, stakeCredentialHash } = deserializeAddress(walletAddress);\n  return conStr0([\n    pubKeyAddress(pubKeyHash, stakeCredentialHash),\n    value(amount),\n  ]);\n};"
        },
        {
          "name": "activeEscrowDatum",
          "signature": "export const activeEscrowDatum = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 45,
          "raw": "export const activeEscrowDatum = (\n  initiationDatum: InitiationDatum,\n  walletAddress: string,\n  amount: Asset[],\n): ActiveEscrowDatum => {\n  const { pubKeyHash, stakeCredentialHash } = deserializeAddress(walletAddress);\n  const [initiator, initiatorAmount] = initiationDatum.fields;\n  return conStr1([\n    initiator,\n    initiatorAmount,\n    pubKeyAddress(pubKeyHash, stakeCredentialHash),\n    value(amount),\n  ]);\n};",
          "source": "mesh-contract",
          "implementation": "export const activeEscrowDatum = (\n  initiationDatum: InitiationDatum,\n  walletAddress: string,\n  amount: Asset[],\n): ActiveEscrowDatum => {\n  const { pubKeyHash, stakeCredentialHash } = deserializeAddress(walletAddress);\n  const [initiator, initiatorAmount] = initiationDatum.fields;\n  return conStr1([\n    initiator,\n    initiatorAmount,\n    pubKeyAddress(pubKeyHash, stakeCredentialHash),\n    value(amount),\n  ]);\n};"
        },
        {
          "name": "recipientDepositRedeemer",
          "signature": "export const recipientDepositRedeemer = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 61,
          "raw": "export const recipientDepositRedeemer = (\n  recipient: string,\n  depositAmount: Asset[],\n) => initiateEscrowDatum(recipient, depositAmount);\n\nexport class MeshEscrowContract extends MeshTxInitiator {\n  scriptCbor: string;\n  scriptAddress: string;\n\n  constructor(inputs: MeshTxInitiatorInput) {\n    super(inputs);\n    this.scriptCbor = this.getScriptCbor();\n    this.scriptAddress = this.getScriptAddress(this.scriptCbor);\n  }\n\n  getScriptCbor = () => {\n    switch (this.version) {\n      case 3:\n        return applyParamsToScript(blueprintV3.validators[0]!.compiledCode, []);\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };\n\n  initiateEscrow = async (escrowAmount: Asset[]): Promise<string> => {\n    const { utxos, walletAddress } = await this.getWalletInfoForTx();\n\n    await this.mesh\n      .txOut(this.scriptAddress, escrowAmount)\n      .txOutInlineDatumValue(\n        initiateEscrowDatum(walletAddress, escrowAmount),\n        \"JSON\",\n      )\n      .changeAddress(walletAddress)\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  cancelEscrow = async (escrowUtxo: UTxO): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n\n    const inputDatum = deserializeDatum<InitiationDatum | ActiveEscrowDatum>(\n      escrowUtxo.output.plutusData!,\n    );\n\n    if (inputDatum.constructor === 1) {\n      const [\n        initiatorAddressObj,\n        initiatorAmount,\n        recipientAddressObj,\n        recipientAmount,\n      ] = inputDatum.fields;\n\n      const initiatorAddress = serializeAddressObj(\n        initiatorAddressObj,\n        this.networkId,\n      );\n      const recipientAddress = serializeAddressObj(\n        recipientAddressObj!,\n        this.networkId,\n      );\n      const initiatorToReceive =\n        MeshValue.fromValue(initiatorAmount).toAssets();\n      const recipientToReceive = MeshValue.fromValue(\n        recipientAmount!,\n      ).toAssets();\n      this.mesh\n        .txOut(initiatorAddress, initiatorToReceive)\n        .txOut(recipientAddress, recipientToReceive);\n    }\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        escrowUtxo.input.txHash,\n        escrowUtxo.input.outputIndex,\n        escrowUtxo.output.amount,\n        this.scriptAddress,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(mConStr1([]))\n      .txInScript(this.scriptCbor)\n      .requiredSignerHash(deserializeAddress(walletAddress).pubKeyHash)\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  recipientDeposit = async (\n    escrowUtxo: UTxO,\n    depositAmount: Asset[],\n  ): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n\n    const inputDatum = deserializeDatum<InitiationDatum>(\n      escrowUtxo.output.plutusData!,\n    );\n    const outputDatum = activeEscrowDatum(\n      inputDatum,\n      walletAddress,\n      depositAmount,\n    );\n\n    const inputAssets = MeshValue.fromValue(inputDatum.fields[1]).toAssets();\n    const escrowAmount = mergeAssets([...depositAmount, ...inputAssets]);\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        escrowUtxo.input.txHash,\n        escrowUtxo.input.outputIndex,\n        escrowUtxo.output.amount,\n        this.scriptAddress,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .txInRedeemerValue(\n        recipientDepositRedeemer(walletAddress, depositAmount),\n        \"JSON\",\n        DEFAULT_REDEEMER_BUDGET,\n      )\n      .txInScript(this.scriptCbor)\n      .txOut(this.scriptAddress, escrowAmount)\n      .txOutInlineDatumValue(outputDatum, \"JSON\")\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  completeEscrow = async (escrowUtxo: UTxO): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n\n    const inputDatum = deserializeDatum<ActiveEscrowDatum>(\n      escrowUtxo.output.plutusData!,\n    );\n    const [\n      initiatorAddressObj,\n      initiatorAmount,\n      recipientAddressObj,\n      recipientAmount,\n    ] = inputDatum.fields;\n    const initiatorAddress = serializeAddressObj(\n      initiatorAddressObj,\n      this.networkId,\n    );\n    const recipientAddress = serializeAddressObj(\n      recipientAddressObj,\n      this.networkId,\n    );\n    const initiatorToReceive = MeshValue.fromValue(recipientAmount).toAssets();\n    const recipientToReceive = MeshValue.fromValue(initiatorAmount).toAssets();\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        escrowUtxo.input.txHash,\n        escrowUtxo.input.outputIndex,\n        escrowUtxo.output.amount,\n        this.scriptAddress,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(mConStr2([]))\n      .txInScript(this.scriptCbor)\n      .txOut(initiatorAddress, initiatorToReceive)\n      .txOut(recipientAddress, recipientToReceive)\n      .requiredSignerHash(deserializeAddress(recipientAddress).pubKeyHash)\n      .requiredSignerHash(deserializeAddress(initiatorAddress).pubKeyHash)\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {\n    return await this._getUtxoByTxHash(txHash, this.scriptCbor);\n  };\n}",
          "source": "mesh-contract",
          "implementation": "export const recipientDepositRedeemer = (\n  recipient: string,\n  depositAmount: Asset[],\n) => initiateEscrowDatum(recipient, depositAmount);\n\nexport class MeshEscrowContract extends MeshTxInitiator {\n  scriptCbor: string;\n  scriptAddress: string;\n\n  constructor(inputs: MeshTxInitiatorInput) {\n    super(inputs);\n    this.scriptCbor = this.getScriptCbor();\n    this.scriptAddress = this.getScriptAddress(this.scriptCbor);\n  }\n\n  getScriptCbor = () => {\n    switch (this.version) {\n      case 3:\n        return applyParamsToScript(blueprintV3.validators[0]!.compiledCode, []);\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };\n\n  initiateEscrow = async (escrowAmount: Asset[]): Promise<string> => {\n    const { utxos, walletAddress } = await this.getWalletInfoForTx();\n\n    await this.mesh\n      .txOut(this.scriptAddress, escrowAmount)\n      .txOutInlineDatumValue(\n        initiateEscrowDatum(walletAddress, escrowAmount),\n        \"JSON\",\n      )\n      .changeAddress(walletAddress)\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  cancelEscrow = async (escrowUtxo: UTxO): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n\n    const inputDatum = deserializeDatum<InitiationDatum | ActiveEscrowDatum>(\n      escrowUtxo.output.plutusData!,\n    );\n\n    if (inputDatum.constructor === 1) {\n      const [\n        initiatorAddressObj,\n        initiatorAmount,\n        recipientAddressObj,\n        recipientAmount,\n      ] = inputDatum.fields;\n\n      const initiatorAddress = serializeAddressObj(\n        initiatorAddressObj,\n        this.networkId,\n      );\n      const recipientAddress = serializeAddressObj(\n        recipientAddressObj!,\n        this.networkId,\n      );\n      const initiatorToReceive =\n        MeshValue.fromValue(initiatorAmount).toAssets();\n      const recipientToReceive = MeshValue.fromValue(\n        recipientAmount!,\n      ).toAssets();\n      this.mesh\n        .txOut(initiatorAddress, initiatorToReceive)\n        .txOut(recipientAddress, recipientToReceive);\n    }\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        escrowUtxo.input.txHash,\n        escrowUtxo.input.outputIndex,\n        escrowUtxo.output.amount,\n        this.scriptAddress,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(mConStr1([]))\n      .txInScript(this.scriptCbor)\n      .requiredSignerHash(deserializeAddress(walletAddress).pubKeyHash)\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  recipientDeposit = async (\n    escrowUtxo: UTxO,\n    depositAmount: Asset[],\n  ): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n\n    const inputDatum = deserializeDatum<InitiationDatum>(\n      escrowUtxo.output.plutusData!,\n    );\n    const outputDatum = activeEscrowDatum(\n      inputDatum,\n      walletAddress,\n      depositAmount,\n    );\n\n    const inputAssets = MeshValue.fromValue(inputDatum.fields[1]).toAssets();\n    const escrowAmount = mergeAssets([...depositAmount, ...inputAssets]);\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        escrowUtxo.input.txHash,\n        escrowUtxo.input.outputIndex,\n        escrowUtxo.output.amount,\n        this.scriptAddress,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .txInRedeemerValue(\n        recipientDepositRedeemer(walletAddress, depositAmount),\n        \"JSON\",\n        DEFAULT_REDEEMER_BUDGET,\n      )\n      .txInScript(this.scriptCbor)\n      .txOut(this.scriptAddress, escrowAmount)\n      .txOutInlineDatumValue(outputDatum, \"JSON\")\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  completeEscrow = async (escrowUtxo: UTxO): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n\n    const inputDatum = deserializeDatum<ActiveEscrowDatum>(\n      escrowUtxo.output.plutusData!,\n    );\n    const [\n      initiatorAddressObj,\n      initiatorAmount,\n      recipientAddressObj,\n      recipientAmount,\n    ] = inputDatum.fields;\n    const initiatorAddress = serializeAddressObj(\n      initiatorAddressObj,\n      this.networkId,\n    );\n    const recipientAddress = serializeAddressObj(\n      recipientAddressObj,\n      this.networkId,\n    );\n    const initiatorToReceive = MeshValue.fromValue(recipientAmount).toAssets();\n    const recipientToReceive = MeshValue.fromValue(initiatorAmount).toAssets();\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        escrowUtxo.input.txHash,\n        escrowUtxo.input.outputIndex,\n        escrowUtxo.output.amount,\n        this.scriptAddress,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(mConStr2([]))\n      .txInScript(this.scriptCbor)\n      .txOut(initiatorAddress, initiatorToReceive)\n      .txOut(recipientAddress, recipientToReceive)\n      .requiredSignerHash(deserializeAddress(recipientAddress).pubKeyHash)\n      .requiredSignerHash(deserializeAddress(initiatorAddress).pubKeyHash)\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {\n    return await this._getUtxoByTxHash(txHash, this.scriptCbor);\n  };\n}"
        },
        {
          "name": "getScriptCbor",
          "signature": "getScriptCbor = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 76,
          "raw": "  getScriptCbor = () => {\n    switch (this.version) {\n      case 3:\n        return applyParamsToScript(blueprintV3.validators[0]!.compiledCode, []);\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };",
          "source": "mesh-contract",
          "implementation": "  getScriptCbor = () => {\n    switch (this.version) {\n      case 3:\n        return applyParamsToScript(blueprintV3.validators[0]!.compiledCode, []);\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };"
        }
      ],
      "types": [
        {
          "name": "InitiationDatum",
          "definition": "export type InitiationDatum = ConStr0<[PubKeyAddress, Value]>;",
          "isPublic": true,
          "line": 30,
          "raw": "export type InitiationDatum = ConStr0<[PubKeyAddress, Value]>;",
          "source": "mesh-contract"
        },
        {
          "name": "ActiveEscrowDatum",
          "definition": "export type ActiveEscrowDatum = ConStr1<\n  [PubKeyAddress, Value, PubKeyAddress, Value]\n>;",
          "isPublic": true,
          "line": 42,
          "raw": "export type ActiveEscrowDatum = ConStr1<",
          "source": "mesh-contract"
        },
        {
          "name": "RecipientDepositRedeemer",
          "definition": "export type RecipientDepositRedeemer = ConStr0<[PubKeyAddress, Value]>;",
          "isPublic": true,
          "line": 60,
          "raw": "export type RecipientDepositRedeemer = ConStr0<[PubKeyAddress, Value]>;",
          "source": "mesh-contract"
        }
      ],
      "constants": [
        {
          "name": "initiateEscrowDatum",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 31,
          "raw": "export const initiateEscrowDatum = (",
          "source": "mesh-contract"
        },
        {
          "name": "activeEscrowDatum",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 45,
          "raw": "export const activeEscrowDatum = (",
          "source": "mesh-contract"
        },
        {
          "name": "recipientDepositRedeemer",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 61,
          "raw": "export const recipientDepositRedeemer = (",
          "source": "mesh-contract"
        },
        {
          "name": "inputDatum",
          "type": "any",
          "value": "deserializeDatum<InitiationDatum | ActiveEscrowDatum>(",
          "isPublic": true,
          "line": 106,
          "raw": "const inputDatum = deserializeDatum<InitiationDatum | ActiveEscrowDatum>(",
          "source": "mesh-contract"
        },
        {
          "name": "initiatorAddress",
          "type": "any",
          "value": "serializeAddressObj(",
          "isPublic": true,
          "line": 118,
          "raw": "const initiatorAddress = serializeAddressObj(",
          "source": "mesh-contract"
        },
        {
          "name": "recipientAddress",
          "type": "any",
          "value": "serializeAddressObj(",
          "isPublic": true,
          "line": 122,
          "raw": "const recipientAddress = serializeAddressObj(",
          "source": "mesh-contract"
        },
        {
          "name": "recipientToReceive",
          "type": "any",
          "value": "MeshValue.fromValue(",
          "isPublic": true,
          "line": 128,
          "raw": "const recipientToReceive = MeshValue.fromValue(",
          "source": "mesh-contract"
        },
        {
          "name": "inputDatum",
          "type": "any",
          "value": "deserializeDatum<InitiationDatum>(",
          "isPublic": true,
          "line": 167,
          "raw": "const inputDatum = deserializeDatum<InitiationDatum>(",
          "source": "mesh-contract"
        },
        {
          "name": "outputDatum",
          "type": "any",
          "value": "activeEscrowDatum(",
          "isPublic": true,
          "line": 170,
          "raw": "const outputDatum = activeEscrowDatum(",
          "source": "mesh-contract"
        },
        {
          "name": "inputAssets",
          "type": "any",
          "value": "MeshValue.fromValue(inputDatum.fields[1]).toAssets();",
          "isPublic": true,
          "line": 176,
          "raw": "const inputAssets = MeshValue.fromValue(inputDatum.fields[1]).toAssets();",
          "source": "mesh-contract"
        },
        {
          "name": "escrowAmount",
          "type": "any",
          "value": "mergeAssets([...depositAmount, ...inputAssets]);",
          "isPublic": true,
          "line": 177,
          "raw": "const escrowAmount = mergeAssets([...depositAmount, ...inputAssets]);",
          "source": "mesh-contract"
        },
        {
          "name": "inputDatum",
          "type": "any",
          "value": "deserializeDatum<ActiveEscrowDatum>(",
          "isPublic": true,
          "line": 212,
          "raw": "const inputDatum = deserializeDatum<ActiveEscrowDatum>(",
          "source": "mesh-contract"
        },
        {
          "name": "initiatorAddress",
          "type": "any",
          "value": "serializeAddressObj(",
          "isPublic": true,
          "line": 221,
          "raw": "const initiatorAddress = serializeAddressObj(",
          "source": "mesh-contract"
        },
        {
          "name": "recipientAddress",
          "type": "any",
          "value": "serializeAddressObj(",
          "isPublic": true,
          "line": 225,
          "raw": "const recipientAddress = serializeAddressObj(",
          "source": "mesh-contract"
        },
        {
          "name": "initiatorToReceive",
          "type": "any",
          "value": "MeshValue.fromValue(recipientAmount).toAssets();",
          "isPublic": true,
          "line": 229,
          "raw": "const initiatorToReceive = MeshValue.fromValue(recipientAmount).toAssets();",
          "source": "mesh-contract"
        },
        {
          "name": "recipientToReceive",
          "type": "any",
          "value": "MeshValue.fromValue(initiatorAmount).toAssets();",
          "isPublic": true,
          "line": 230,
          "raw": "const recipientToReceive = MeshValue.fromValue(initiatorAmount).toAssets();",
          "source": "mesh-contract"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  ConStr0,\n  conStr0,\n  ConStr1,\n  conStr1,\n  DEFAULT_REDEEMER_BUDGET,\n  mConStr1,\n  mConStr2,\n  MeshValue,\n  PubKeyAddress,\n  pubKeyAddress,\n  Value,\n  value,\n} from \"@meshsdk/common\";\nimport {\n  Asset,\n  deserializeAddress,\n  deserializeDatum,\n  mergeAssets,\n  serializeAddressObj,\n  UTxO,\n} from \"@meshsdk/core\";\nimport { applyParamsToScript } from \"@meshsdk/core-cst\";\n\nimport { MeshTxInitiator, MeshTxInitiatorInput } from \"../common\";\nimport blueprintV1 from \"./aiken-workspace-v1/plutus.json\";\nimport blueprintV2 from \"./aiken-workspace-v2/plutus.json\";\nimport blueprintV3 from \"./aiken-workspace-v3/plutus.json\";\n\nexport type InitiationDatum = ConStr0<[PubKeyAddress, Value]>;\nexport const initiateEscrowDatum = (\n  walletAddress: string,\n  amount: Asset[],\n): InitiationDatum => {\n  const { pubKeyHash, stakeCredentialHash } = deserializeAddress(walletAddress);\n  return conStr0([\n    pubKeyAddress(pubKeyHash, stakeCredentialHash),\n    value(amount),\n  ]);\n};\n\nexport type ActiveEscrowDatum = ConStr1<\n  [PubKeyAddress, Value, PubKeyAddress, Value]\n>;\nexport const activeEscrowDatum = (\n  initiationDatum: InitiationDatum,\n  walletAddress: string,\n  amount: Asset[],\n): ActiveEscrowDatum => {\n  const { pubKeyHash, stakeCredentialHash } = deserializeAddress(walletAddress);\n  const [initiator, initiatorAmount] = initiationDatum.fields;\n  return conStr1([\n    initiator,\n    initiatorAmount,\n    pubKeyAddress(pubKeyHash, stakeCredentialHash),\n    value(amount),\n  ]);\n};\n\nexport type RecipientDepositRedeemer = ConStr0<[PubKeyAddress, Value]>;\nexport const recipientDepositRedeemer = (\n  recipient: string,\n  depositAmount: Asset[],\n) => initiateEscrowDatum(recipient, depositAmount);\n\nexport class MeshEscrowContract extends MeshTxInitiator {\n  scriptCbor: string;\n  scriptAddress: string;\n\n  constructor(inputs: MeshTxInitiatorInput) {\n    super(inputs);\n    this.scriptCbor = this.getScriptCbor();\n    this.scriptAddress = this.getScriptAddress(this.scriptCbor);\n  }\n\n  getScriptCbor = () => {\n    switch (this.version) {\n      case 3:\n        return applyParamsToScript(blueprintV3.validators[0]!.compiledCode, []);\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };\n\n  initiateEscrow = async (escrowAmount: Asset[]): Promise<string> => {\n    const { utxos, walletAddress } = await this.getWalletInfoForTx();\n\n    await this.mesh\n      .txOut(this.scriptAddress, escrowAmount)\n      .txOutInlineDatumValue(\n        initiateEscrowDatum(walletAddress, escrowAmount),\n        \"JSON\",\n      )\n      .changeAddress(walletAddress)\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  cancelEscrow = async (escrowUtxo: UTxO): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n\n    const inputDatum = deserializeDatum<InitiationDatum | ActiveEscrowDatum>(\n      escrowUtxo.output.plutusData!,\n    );\n\n    if (inputDatum.constructor === 1) {\n      const [\n        initiatorAddressObj,\n        initiatorAmount,\n        recipientAddressObj,\n        recipientAmount,\n      ] = inputDatum.fields;\n\n      const initiatorAddress = serializeAddressObj(\n        initiatorAddressObj,\n        this.networkId,\n      );\n      const recipientAddress = serializeAddressObj(\n        recipientAddressObj!,\n        this.networkId,\n      );\n      const initiatorToReceive =\n        MeshValue.fromValue(initiatorAmount).toAssets();\n      const recipientToReceive = MeshValue.fromValue(\n        recipientAmount!,\n      ).toAssets();\n      this.mesh\n        .txOut(initiatorAddress, initiatorToReceive)\n        .txOut(recipientAddress, recipientToReceive);\n    }\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        escrowUtxo.input.txHash,\n        escrowUtxo.input.outputIndex,\n        escrowUtxo.output.amount,\n        this.scriptAddress,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(mConStr1([]))\n      .txInScript(this.scriptCbor)\n      .requiredSignerHash(deserializeAddress(walletAddress).pubKeyHash)\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  recipientDeposit = async (\n    escrowUtxo: UTxO,\n    depositAmount: Asset[],\n  ): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n\n    const inputDatum = deserializeDatum<InitiationDatum>(\n      escrowUtxo.output.plutusData!,\n    );\n    const outputDatum = activeEscrowDatum(\n      inputDatum,\n      walletAddress,\n      depositAmount,\n    );\n\n    const inputAssets = MeshValue.fromValue(inputDatum.fields[1]).toAssets();\n    const escrowAmount = mergeAssets([...depositAmount, ...inputAssets]);\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        escrowUtxo.input.txHash,\n        escrowUtxo.input.outputIndex,\n        escrowUtxo.output.amount,\n        this.scriptAddress,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .txInRedeemerValue(\n        recipientDepositRedeemer(walletAddress, depositAmount),\n        \"JSON\",\n        DEFAULT_REDEEMER_BUDGET,\n      )\n      .txInScript(this.scriptCbor)\n      .txOut(this.scriptAddress, escrowAmount)\n      .txOutInlineDatumValue(outputDatum, \"JSON\")\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  completeEscrow = async (escrowUtxo: UTxO): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n\n    const inputDatum = deserializeDatum<ActiveEscrowDatum>(\n      escrowUtxo.output.plutusData!,\n    );\n    const [\n      initiatorAddressObj,\n      initiatorAmount,\n      recipientAddressObj,\n      recipientAmount,\n    ] = inputDatum.fields;\n    const initiatorAddress = serializeAddressObj(\n      initiatorAddressObj,\n      this.networkId,\n    );\n    const recipientAddress = serializeAddressObj(\n      recipientAddressObj,\n      this.networkId,\n    );\n    const initiatorToReceive = MeshValue.fromValue(recipientAmount).toAssets();\n    const recipientToReceive = MeshValue.fromValue(initiatorAmount).toAssets();\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        escrowUtxo.input.txHash,\n        escrowUtxo.input.outputIndex,\n        escrowUtxo.output.amount,\n        this.scriptAddress,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(mConStr2([]))\n      .txInScript(this.scriptCbor)\n      .txOut(initiatorAddress, initiatorToReceive)\n      .txOut(recipientAddress, recipientToReceive)\n      .requiredSignerHash(deserializeAddress(recipientAddress).pubKeyHash)\n      .requiredSignerHash(deserializeAddress(initiatorAddress).pubKeyHash)\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {\n    return await this._getUtxoByTxHash(txHash, this.scriptCbor);\n  };\n}\n",
      "dependencies": [
        "InitiationDatum",
        "initiateEscrowDatum",
        "ActiveEscrowDatum",
        "activeEscrowDatum",
        "RecipientDepositRedeemer",
        "recipientDepositRedeemer",
        "MeshEscrowContract"
      ],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:giftcard.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/giftcard/index.ts",
      "name": "giftcard.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from './offchain';\n",
      "dependencies": [],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:giftcard.offchain.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/giftcard/offchain.ts",
      "name": "giftcard.offchain.ts",
      "imports": [
        {
          "module": "MeshGiftCardContract",
          "items": [],
          "line": 25,
          "raw": "export class MeshGiftCardContract extends MeshTxInitiator {",
          "source": "mesh-contract"
        }
      ],
      "functions": [
        {
          "name": "redeemCbor",
          "signature": "redeemCbor = (tokenNameHex: string, policyId: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "tokenNameHex",
              "type": "string",
              "optional": false
            },
            {
              "name": "policyId",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 68,
          "raw": "  redeemCbor = (tokenNameHex: string, policyId: string) => {\n    let scriptCbor;\n    switch (this.version) {\n      case 2:\n        scriptCbor = blueprintV2.validators[2]!.compiledCode;\n        break;\n      default:\n        scriptCbor = blueprintV1.validators[1]!.compiledCode;\n    }\n\n    return applyParamsToScript(scriptCbor, [tokenNameHex, policyId]);\n  };",
          "source": "mesh-contract",
          "implementation": "  redeemCbor = (tokenNameHex: string, policyId: string) => {\n    let scriptCbor;\n    switch (this.version) {\n      case 2:\n        scriptCbor = blueprintV2.validators[2]!.compiledCode;\n        break;\n      default:\n        scriptCbor = blueprintV1.validators[1]!.compiledCode;\n    }\n\n    return applyParamsToScript(scriptCbor, [tokenNameHex, policyId]);\n  };"
        },
        {
          "name": "paramTxHash",
          "signature": "const paramTxHash = (inlineDatum[0] as BuiltinByteString).bytes;",
          "documentation": "",
          "parameters": [
            {
              "name": "inlineDatum[0] as BuiltinByteString",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 152,
          "raw": "    const paramTxHash = (inlineDatum[0] as BuiltinByteString).bytes;\n    const paramTxId = (inlineDatum[1] as Integer).int as number;\n    const tokenNameHex = (inlineDatum[2] as BuiltinByteString).bytes;\n    const giftCardScript = this.giftCardCbor(\n      tokenNameHex,\n      paramTxHash,\n      paramTxId,\n    );\n\n    const giftCardPolicy = resolveScriptHash(\n      giftCardScript,\n      this.languageVersion,\n    );\n\n    const redeemScript = this.redeemCbor(tokenNameHex, giftCardPolicy);\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        giftCardUtxo.input.txHash,\n        giftCardUtxo.input.outputIndex,\n        giftCardUtxo.output.amount,\n        giftCardUtxo.output.address,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(\"\")\n      .txInScript(redeemScript)\n      .mintPlutusScript(this.languageVersion)\n      .mint(\"-1\", giftCardPolicy, tokenNameHex)\n      .mintingScript(giftCardScript)\n      .mintRedeemerValue(mConStr1([]))\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {",
          "source": "mesh-contract",
          "implementation": "    const paramTxHash = (inlineDatum[0] as BuiltinByteString).bytes;\n    const paramTxId = (inlineDatum[1] as Integer).int as number;\n    const tokenNameHex = (inlineDatum[2] as BuiltinByteString).bytes;\n    const giftCardScript = this.giftCardCbor(\n      tokenNameHex,\n      paramTxHash,\n      paramTxId,\n    );\n\n    const giftCardPolicy = resolveScriptHash(\n      giftCardScript,\n      this.languageVersion,\n    );\n\n    const redeemScript = this.redeemCbor(tokenNameHex, giftCardPolicy);\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        giftCardUtxo.input.txHash,\n        giftCardUtxo.input.outputIndex,\n        giftCardUtxo.output.amount,\n        giftCardUtxo.output.address,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(\"\")\n      .txInScript(redeemScript)\n      .mintPlutusScript(this.languageVersion)\n      .mint(\"-1\", giftCardPolicy, tokenNameHex)\n      .mintingScript(giftCardScript)\n      .mintRedeemerValue(mConStr1([]))\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {"
        },
        {
          "name": "paramTxId",
          "signature": "const paramTxId = (inlineDatum[1] as Integer).int as number;",
          "documentation": "",
          "parameters": [
            {
              "name": "inlineDatum[1] as Integer",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 153,
          "raw": "    const paramTxId = (inlineDatum[1] as Integer).int as number;\n    const tokenNameHex = (inlineDatum[2] as BuiltinByteString).bytes;\n    const giftCardScript = this.giftCardCbor(\n      tokenNameHex,\n      paramTxHash,\n      paramTxId,\n    );\n\n    const giftCardPolicy = resolveScriptHash(\n      giftCardScript,\n      this.languageVersion,\n    );\n\n    const redeemScript = this.redeemCbor(tokenNameHex, giftCardPolicy);\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        giftCardUtxo.input.txHash,\n        giftCardUtxo.input.outputIndex,\n        giftCardUtxo.output.amount,\n        giftCardUtxo.output.address,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(\"\")\n      .txInScript(redeemScript)\n      .mintPlutusScript(this.languageVersion)\n      .mint(\"-1\", giftCardPolicy, tokenNameHex)\n      .mintingScript(giftCardScript)\n      .mintRedeemerValue(mConStr1([]))\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {",
          "source": "mesh-contract",
          "implementation": "    const paramTxId = (inlineDatum[1] as Integer).int as number;\n    const tokenNameHex = (inlineDatum[2] as BuiltinByteString).bytes;\n    const giftCardScript = this.giftCardCbor(\n      tokenNameHex,\n      paramTxHash,\n      paramTxId,\n    );\n\n    const giftCardPolicy = resolveScriptHash(\n      giftCardScript,\n      this.languageVersion,\n    );\n\n    const redeemScript = this.redeemCbor(tokenNameHex, giftCardPolicy);\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        giftCardUtxo.input.txHash,\n        giftCardUtxo.input.outputIndex,\n        giftCardUtxo.output.amount,\n        giftCardUtxo.output.address,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(\"\")\n      .txInScript(redeemScript)\n      .mintPlutusScript(this.languageVersion)\n      .mint(\"-1\", giftCardPolicy, tokenNameHex)\n      .mintingScript(giftCardScript)\n      .mintRedeemerValue(mConStr1([]))\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {"
        },
        {
          "name": "tokenNameHex",
          "signature": "const tokenNameHex = (inlineDatum[2] as BuiltinByteString).bytes;",
          "documentation": "",
          "parameters": [
            {
              "name": "inlineDatum[2] as BuiltinByteString",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 154,
          "raw": "    const tokenNameHex = (inlineDatum[2] as BuiltinByteString).bytes;\n    const giftCardScript = this.giftCardCbor(\n      tokenNameHex,\n      paramTxHash,\n      paramTxId,\n    );\n\n    const giftCardPolicy = resolveScriptHash(\n      giftCardScript,\n      this.languageVersion,\n    );\n\n    const redeemScript = this.redeemCbor(tokenNameHex, giftCardPolicy);\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        giftCardUtxo.input.txHash,\n        giftCardUtxo.input.outputIndex,\n        giftCardUtxo.output.amount,\n        giftCardUtxo.output.address,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(\"\")\n      .txInScript(redeemScript)\n      .mintPlutusScript(this.languageVersion)\n      .mint(\"-1\", giftCardPolicy, tokenNameHex)\n      .mintingScript(giftCardScript)\n      .mintRedeemerValue(mConStr1([]))\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {",
          "source": "mesh-contract",
          "implementation": "    const tokenNameHex = (inlineDatum[2] as BuiltinByteString).bytes;\n    const giftCardScript = this.giftCardCbor(\n      tokenNameHex,\n      paramTxHash,\n      paramTxId,\n    );\n\n    const giftCardPolicy = resolveScriptHash(\n      giftCardScript,\n      this.languageVersion,\n    );\n\n    const redeemScript = this.redeemCbor(tokenNameHex, giftCardPolicy);\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        giftCardUtxo.input.txHash,\n        giftCardUtxo.input.outputIndex,\n        giftCardUtxo.output.amount,\n        giftCardUtxo.output.address,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(\"\")\n      .txInScript(redeemScript)\n      .mintPlutusScript(this.languageVersion)\n      .mint(\"-1\", giftCardPolicy, tokenNameHex)\n      .mintingScript(giftCardScript)\n      .mintRedeemerValue(mConStr1([]))\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "tokenNameHex",
          "type": "any",
          "value": "stringToHex(tokenName);",
          "isPublic": true,
          "line": 87,
          "raw": "const tokenNameHex = stringToHex(tokenName);",
          "source": "mesh-contract"
        },
        {
          "name": "firstUtxo",
          "type": "any",
          "value": "utxos[0];",
          "isPublic": true,
          "line": 88,
          "raw": "const firstUtxo = utxos[0];",
          "source": "mesh-contract"
        },
        {
          "name": "remainingUtxos",
          "type": "any",
          "value": "utxos.slice(1);",
          "isPublic": true,
          "line": 90,
          "raw": "const remainingUtxos = utxos.slice(1);",
          "source": "mesh-contract"
        },
        {
          "name": "giftCardScript",
          "type": "any",
          "value": "this.giftCardCbor(",
          "isPublic": true,
          "line": 91,
          "raw": "const giftCardScript = this.giftCardCbor(",
          "source": "mesh-contract"
        },
        {
          "name": "giftCardPolicy",
          "type": "any",
          "value": "resolveScriptHash(",
          "isPublic": true,
          "line": 97,
          "raw": "const giftCardPolicy = resolveScriptHash(",
          "source": "mesh-contract"
        },
        {
          "name": "redeemScript",
          "type": "PlutusScript",
          "value": "{",
          "isPublic": true,
          "line": 102,
          "raw": "const redeemScript: PlutusScript = {",
          "source": "mesh-contract"
        },
        {
          "name": "redeemAddr",
          "type": "any",
          "value": "this.getScriptAddress(redeemScript.code);",
          "isPublic": true,
          "line": 107,
          "raw": "const redeemAddr = this.getScriptAddress(redeemScript.code);",
          "source": "mesh-contract"
        },
        {
          "name": "inlineDatum",
          "type": "any",
          "value": "deserializeDatum<List>(",
          "isPublic": true,
          "line": 149,
          "raw": "const inlineDatum = deserializeDatum<List>(",
          "source": "mesh-contract"
        },
        {
          "name": "paramTxHash",
          "type": "any",
          "value": "(inlineDatum[0] as BuiltinByteString).bytes;",
          "isPublic": true,
          "line": 152,
          "raw": "const paramTxHash = (inlineDatum[0] as BuiltinByteString).bytes;",
          "source": "mesh-contract"
        },
        {
          "name": "paramTxId",
          "type": "any",
          "value": "(inlineDatum[1] as Integer).int as number;",
          "isPublic": true,
          "line": 153,
          "raw": "const paramTxId = (inlineDatum[1] as Integer).int as number;",
          "source": "mesh-contract"
        },
        {
          "name": "tokenNameHex",
          "type": "any",
          "value": "(inlineDatum[2] as BuiltinByteString).bytes;",
          "isPublic": true,
          "line": 154,
          "raw": "const tokenNameHex = (inlineDatum[2] as BuiltinByteString).bytes;",
          "source": "mesh-contract"
        },
        {
          "name": "giftCardScript",
          "type": "any",
          "value": "this.giftCardCbor(",
          "isPublic": true,
          "line": 155,
          "raw": "const giftCardScript = this.giftCardCbor(",
          "source": "mesh-contract"
        },
        {
          "name": "giftCardPolicy",
          "type": "any",
          "value": "resolveScriptHash(",
          "isPublic": true,
          "line": 161,
          "raw": "const giftCardPolicy = resolveScriptHash(",
          "source": "mesh-contract"
        },
        {
          "name": "redeemScript",
          "type": "any",
          "value": "this.redeemCbor(tokenNameHex, giftCardPolicy);",
          "isPublic": true,
          "line": 166,
          "raw": "const redeemScript = this.redeemCbor(tokenNameHex, giftCardPolicy);",
          "source": "mesh-contract"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  builtinByteString,\n  BuiltinByteString,\n  Integer,\n  List,\n  mConStr0,\n  mConStr1,\n  outputReference,\n  PlutusScript,\n  stringToHex,\n  txOutRef,\n} from \"@meshsdk/common\";\nimport {\n  Asset,\n  deserializeDatum,\n  resolveScriptHash,\n  UTxO,\n} from \"@meshsdk/core\";\nimport { applyParamsToScript } from \"@meshsdk/core-cst\";\n\nimport { MeshTxInitiator, MeshTxInitiatorInput } from \"../common\";\nimport blueprintV1 from \"./aiken-workspace-v1/plutus.json\";\nimport blueprintV2 from \"./aiken-workspace-v2/plutus.json\";\n\nexport class MeshGiftCardContract extends MeshTxInitiator {\n  tokenNameHex: string = \"\";\n  paramUtxo: UTxO[\"input\"] = { outputIndex: 0, txHash: \"\" };\n\n  constructor(\n    inputs: MeshTxInitiatorInput,\n    tokenNameHex?: string,\n    paramUtxo?: UTxO[\"input\"],\n  ) {\n    super(inputs);\n    if (tokenNameHex) {\n      this.tokenNameHex = tokenNameHex;\n    }\n    if (paramUtxo) {\n      this.paramUtxo = paramUtxo;\n    }\n  }\n\n  giftCardCbor = (\n    tokenNameHex: string,\n    utxoTxHash: string,\n    utxoTxId: number,\n  ) => {\n    let scriptCbor;\n    let utxo;\n    switch (this.version) {\n      case 2:\n        scriptCbor = blueprintV2.validators[0]!.compiledCode;\n        utxo = outputReference(utxoTxHash, utxoTxId);\n        break;\n      default:\n        scriptCbor = blueprintV1.validators[0]!.compiledCode;\n        utxo = txOutRef(utxoTxHash, utxoTxId);\n        break;\n    }\n\n    return applyParamsToScript(\n      scriptCbor,\n      [builtinByteString(tokenNameHex), utxo],\n      \"JSON\",\n    );\n  };\n\n  redeemCbor = (tokenNameHex: string, policyId: string) => {\n    let scriptCbor;\n    switch (this.version) {\n      case 2:\n        scriptCbor = blueprintV2.validators[2]!.compiledCode;\n        break;\n      default:\n        scriptCbor = blueprintV1.validators[1]!.compiledCode;\n    }\n\n    return applyParamsToScript(scriptCbor, [tokenNameHex, policyId]);\n  };\n\n  createGiftCard = async (\n    tokenName: string,\n    giftValue: Asset[],\n  ): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n    const tokenNameHex = stringToHex(tokenName);\n    const firstUtxo = utxos[0];\n    if (firstUtxo === undefined) throw new Error(\"No UTXOs available\");\n    const remainingUtxos = utxos.slice(1);\n    const giftCardScript = this.giftCardCbor(\n      tokenNameHex,\n      firstUtxo.input.txHash,\n      firstUtxo.input.outputIndex,\n    );\n\n    const giftCardPolicy = resolveScriptHash(\n      giftCardScript,\n      this.languageVersion,\n    );\n\n    const redeemScript: PlutusScript = {\n      code: this.redeemCbor(tokenNameHex, giftCardPolicy),\n      version: this.languageVersion,\n    };\n\n    const redeemAddr = this.getScriptAddress(redeemScript.code);\n\n    await this.mesh\n      .txIn(\n        firstUtxo.input.txHash,\n        firstUtxo.input.outputIndex,\n        firstUtxo.output.amount,\n        firstUtxo.output.address,\n      )\n      .mintPlutusScript(this.languageVersion)\n      .mint(\"1\", giftCardPolicy, tokenNameHex)\n      .mintingScript(giftCardScript)\n      .mintRedeemerValue(mConStr0([]))\n      .txOut(redeemAddr, [\n        ...giftValue,\n        { unit: giftCardPolicy + tokenNameHex, quantity: \"1\" },\n      ])\n      .txOutInlineDatumValue([\n        firstUtxo.input.txHash,\n        firstUtxo.input.outputIndex,\n        tokenNameHex,\n      ])\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(remainingUtxos)\n      .complete();\n\n    this.tokenNameHex = tokenNameHex;\n    this.paramUtxo = firstUtxo.input;\n\n    return this.mesh.txHex;\n  };\n\n  redeemGiftCard = async (giftCardUtxo: UTxO): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n\n    const inlineDatum = deserializeDatum<List>(\n      giftCardUtxo.output.plutusData!,\n    ).list;\n    const paramTxHash = (inlineDatum[0] as BuiltinByteString).bytes;\n    const paramTxId = (inlineDatum[1] as Integer).int as number;\n    const tokenNameHex = (inlineDatum[2] as BuiltinByteString).bytes;\n    const giftCardScript = this.giftCardCbor(\n      tokenNameHex,\n      paramTxHash,\n      paramTxId,\n    );\n\n    const giftCardPolicy = resolveScriptHash(\n      giftCardScript,\n      this.languageVersion,\n    );\n\n    const redeemScript = this.redeemCbor(tokenNameHex, giftCardPolicy);\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        giftCardUtxo.input.txHash,\n        giftCardUtxo.input.outputIndex,\n        giftCardUtxo.output.amount,\n        giftCardUtxo.output.address,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(\"\")\n      .txInScript(redeemScript)\n      .mintPlutusScript(this.languageVersion)\n      .mint(\"-1\", giftCardPolicy, tokenNameHex)\n      .mintingScript(giftCardScript)\n      .mintRedeemerValue(mConStr1([]))\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {\n    return await this._getUtxoByTxHash(txHash);\n  };\n}\n",
      "dependencies": [
        "MeshGiftCardContract"
      ],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:hello-world.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/hello-world/index.ts",
      "name": "hello-world.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from './offchain';\n",
      "dependencies": [],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:hello-world.offchain.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/hello-world/offchain.ts",
      "name": "hello-world.offchain.ts",
      "imports": [
        {
          "module": "HelloWorldDatum",
          "items": [],
          "line": 17,
          "raw": "export type HelloWorldDatum = ConStr0<",
          "source": "mesh-contract"
        },
        {
          "module": "MeshHelloWorldContract",
          "items": [],
          "line": 21,
          "raw": "export class MeshHelloWorldContract extends MeshTxInitiator {",
          "source": "mesh-contract"
        }
      ],
      "functions": [
        {
          "name": "getScriptCbor",
          "signature": "getScriptCbor = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 31,
          "raw": "  getScriptCbor = () => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };",
          "source": "mesh-contract",
          "implementation": "  getScriptCbor = () => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };"
        }
      ],
      "types": [
        {
          "name": "HelloWorldDatum",
          "definition": "export type HelloWorldDatum = ConStr0<\n  [Integer, BuiltinByteString, BuiltinByteString]\n>;",
          "isPublic": true,
          "line": 17,
          "raw": "export type HelloWorldDatum = ConStr0<",
          "source": "mesh-contract"
        }
      ],
      "constants": [
        {
          "name": "signerHash",
          "type": "any",
          "value": "deserializeAddress(walletAddress).pubKeyHash;",
          "isPublic": true,
          "line": 43,
          "raw": "const signerHash = deserializeAddress(walletAddress).pubKeyHash;",
          "source": "mesh-contract"
        },
        {
          "name": "signerHash",
          "type": "any",
          "value": "deserializeAddress(walletAddress).pubKeyHash;",
          "isPublic": true,
          "line": 57,
          "raw": "const signerHash = deserializeAddress(walletAddress).pubKeyHash;",
          "source": "mesh-contract"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  Asset,\n  BuiltinByteString,\n  ConStr0,\n  deserializeAddress,\n  Integer,\n  mConStr0,\n  stringToHex,\n  UTxO,\n} from \"@meshsdk/core\";\nimport { applyParamsToScript } from \"@meshsdk/core-cst\";\n\nimport { MeshTxInitiator, MeshTxInitiatorInput } from \"../common\";\nimport blueprintV1 from \"./aiken-workspace-v1/plutus.json\";\nimport blueprintV2 from \"./aiken-workspace-v2/plutus.json\";\n\nexport type HelloWorldDatum = ConStr0<\n  [Integer, BuiltinByteString, BuiltinByteString]\n>;\n\nexport class MeshHelloWorldContract extends MeshTxInitiator {\n  scriptCbor: string;\n  scriptAddress: string;\n\n  constructor(inputs: MeshTxInitiatorInput) {\n    super(inputs);\n    this.scriptCbor = this.getScriptCbor();\n    this.scriptAddress = this.getScriptAddress(this.scriptCbor);\n  }\n\n  getScriptCbor = () => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };\n\n  lockAsset = async (assets: Asset[]): Promise<string> => {\n    const { utxos, walletAddress } = await this.getWalletInfoForTx();\n\n    const signerHash = deserializeAddress(walletAddress).pubKeyHash;\n\n    await this.mesh\n      .txOut(this.scriptAddress, assets)\n      .txOutDatumHashValue(mConStr0([signerHash]))\n      .changeAddress(walletAddress)\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  unlockAsset = async (scriptUtxo: UTxO, message: string): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n    const signerHash = deserializeAddress(walletAddress).pubKeyHash;\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        scriptUtxo.input.txHash,\n        scriptUtxo.input.outputIndex,\n        scriptUtxo.output.amount,\n        scriptUtxo.output.address,\n      )\n      .txInScript(this.scriptCbor)\n      .txInRedeemerValue(mConStr0([stringToHex(message)]))\n      .txInDatumValue(mConStr0([signerHash]))\n      .requiredSignerHash(signerHash)\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {\n    return await this._getUtxoByTxHash(txHash, this.scriptCbor);\n  };\n}\n",
      "dependencies": [
        "HelloWorldDatum",
        "MeshHelloWorldContract"
      ],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/index.ts",
      "name": "index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./content-ownership\";\nexport * from \"./escrow\";\nexport * from \"./giftcard\";\nexport * from \"./hello-world\";\nexport * from \"./marketplace\";\nexport * from \"./payment-splitter\";\nexport * from \"./plutus-nft\";\nexport * from \"./swap\";\nexport * from \"./vesting\";\n",
      "dependencies": [],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:marketplace.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/marketplace/index.ts",
      "name": "marketplace.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from './offchain';\n",
      "dependencies": [],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:marketplace.offchain.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/marketplace/offchain.ts",
      "name": "marketplace.offchain.ts",
      "imports": [
        {
          "module": "MarketplaceDatum",
          "items": [],
          "line": 30,
          "raw": "export type MarketplaceDatum = ConStr0<",
          "source": "mesh-contract"
        },
        {
          "module": "marketplaceDatum",
          "items": [],
          "line": 33,
          "raw": "export const marketplaceDatum = (",
          "source": "mesh-contract"
        },
        {
          "module": "MeshMarketplaceContract",
          "items": [],
          "line": 48,
          "raw": "export class MeshMarketplaceContract extends MeshTxInitiator {",
          "source": "mesh-contract"
        }
      ],
      "functions": [
        {
          "name": "marketplaceDatum",
          "signature": "export const marketplaceDatum = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 33,
          "raw": "export const marketplaceDatum = (\n  sellerAddress: string,\n  lovelaceFee: number,\n  assetHex: string,\n): MarketplaceDatum => {\n  const { pubKeyHash, stakeCredentialHash } = deserializeAddress(sellerAddress);\n  const { policyId, assetName } = parseAssetUnit(assetHex);\n  return conStr0([\n    pubKeyAddress(pubKeyHash, stakeCredentialHash),\n    integer(lovelaceFee),\n    currencySymbol(policyId),\n    tokenName(assetName),\n  ]);\n};",
          "source": "mesh-contract",
          "implementation": "export const marketplaceDatum = (\n  sellerAddress: string,\n  lovelaceFee: number,\n  assetHex: string,\n): MarketplaceDatum => {\n  const { pubKeyHash, stakeCredentialHash } = deserializeAddress(sellerAddress);\n  const { policyId, assetName } = parseAssetUnit(assetHex);\n  return conStr0([\n    pubKeyAddress(pubKeyHash, stakeCredentialHash),\n    integer(lovelaceFee),\n    currencySymbol(policyId),\n    tokenName(assetName),\n  ]);\n};"
        }
      ],
      "types": [
        {
          "name": "MarketplaceDatum",
          "definition": "export type MarketplaceDatum = ConStr0<\n  [PubKeyAddress, Integer, CurrencySymbol, TokenName]\n>;",
          "isPublic": true,
          "line": 30,
          "raw": "export type MarketplaceDatum = ConStr0<",
          "source": "mesh-contract"
        }
      ],
      "constants": [
        {
          "name": "marketplaceDatum",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 33,
          "raw": "export const marketplaceDatum = (",
          "source": "mesh-contract"
        },
        {
          "name": "assetMap",
          "type": "any",
          "value": "new Map<Unit, Quantity>();",
          "isPublic": true,
          "line": 104,
          "raw": "const assetMap = new Map<Unit, Quantity>();",
          "source": "mesh-contract"
        },
        {
          "name": "tokenForSale",
          "type": "any",
          "value": "[{ unit: asset, quantity: \"1\" }];",
          "isPublic": true,
          "line": 107,
          "raw": "const tokenForSale = [{ unit: asset, quantity: \"1\" }];",
          "source": "mesh-contract"
        },
        {
          "name": "outputDatum",
          "type": "any",
          "value": "marketplaceDatum(walletAddress, price, asset);",
          "isPublic": true,
          "line": 108,
          "raw": "const outputDatum = marketplaceDatum(walletAddress, price, asset);",
          "source": "mesh-contract"
        },
        {
          "name": "inputDatum",
          "type": "any",
          "value": "deserializeDatum<MarketplaceDatum>(",
          "isPublic": true,
          "line": 153,
          "raw": "const inputDatum = deserializeDatum<MarketplaceDatum>(",
          "source": "mesh-contract"
        },
        {
          "name": "inputLovelace",
          "type": "any",
          "value": "marketplaceUtxo.output.amount.find(",
          "isPublic": true,
          "line": 157,
          "raw": "const inputLovelace = marketplaceUtxo.output.amount.find(",
          "source": "mesh-contract"
        },
        {
          "name": "tx",
          "type": "any",
          "value": "this.mesh",
          "isPublic": true,
          "line": 161,
          "raw": "const tx = this.mesh",
          "source": "mesh-contract"
        },
        {
          "name": "ownerToReceive",
          "type": "any",
          "value": "[",
          "isPublic": true,
          "line": 189,
          "raw": "const ownerToReceive = [",
          "source": "mesh-contract"
        },
        {
          "name": "sellerAddress",
          "type": "any",
          "value": "serializeAddressObj(",
          "isPublic": true,
          "line": 202,
          "raw": "const sellerAddress = serializeAddressObj(",
          "source": "mesh-contract"
        },
        {
          "name": "sellerToReceive",
          "type": "any",
          "value": "[",
          "isPublic": true,
          "line": 206,
          "raw": "const sellerToReceive = [",
          "source": "mesh-contract"
        },
        {
          "name": "inputAsset",
          "type": "any",
          "value": "marketplaceUtxo.output.amount.find(",
          "isPublic": true,
          "line": 222,
          "raw": "const inputAsset = marketplaceUtxo.output.amount.find(",
          "source": "mesh-contract"
        },
        {
          "name": "tokenForSale",
          "type": "any",
          "value": "[{ unit: inputAsset, quantity: \"1\" }];",
          "isPublic": true,
          "line": 226,
          "raw": "const tokenForSale = [{ unit: inputAsset, quantity: \"1\" }];",
          "source": "mesh-contract"
        },
        {
          "name": "outputDatum",
          "type": "any",
          "value": "marketplaceDatum(walletAddress, newPrice, inputAsset);",
          "isPublic": true,
          "line": 227,
          "raw": "const outputDatum = marketplaceDatum(walletAddress, newPrice, inputAsset);",
          "source": "mesh-contract"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  ConStr0,\n  conStr0,\n  CurrencySymbol,\n  currencySymbol,\n  Integer,\n  integer,\n  mConStr0,\n  mConStr1,\n  parseAssetUnit,\n  PubKeyAddress,\n  pubKeyAddress,\n  TokenName,\n  tokenName,\n} from \"@meshsdk/common\";\nimport {\n  deserializeAddress,\n  deserializeDatum,\n  Quantity,\n  serializeAddressObj,\n  Unit,\n  UTxO,\n} from \"@meshsdk/core\";\nimport { applyParamsToScript } from \"@meshsdk/core-cst\";\n\nimport { MeshTxInitiator, MeshTxInitiatorInput } from \"../common\";\nimport blueprintV1 from \"./aiken-workspace-v1/plutus.json\";\nimport blueprintV2 from \"./aiken-workspace-v2/plutus.json\";\n\nexport type MarketplaceDatum = ConStr0<\n  [PubKeyAddress, Integer, CurrencySymbol, TokenName]\n>;\nexport const marketplaceDatum = (\n  sellerAddress: string,\n  lovelaceFee: number,\n  assetHex: string,\n): MarketplaceDatum => {\n  const { pubKeyHash, stakeCredentialHash } = deserializeAddress(sellerAddress);\n  const { policyId, assetName } = parseAssetUnit(assetHex);\n  return conStr0([\n    pubKeyAddress(pubKeyHash, stakeCredentialHash),\n    integer(lovelaceFee),\n    currencySymbol(policyId),\n    tokenName(assetName),\n  ]);\n};\n\nexport class MeshMarketplaceContract extends MeshTxInitiator {\n  ownerAddress: string;\n  feePercentageBasisPoint: number;\n  scriptCbor: string;\n  scriptAddress: string;\n\n  constructor(\n    inputs: MeshTxInitiatorInput,\n    ownerAddress: string,\n    feePercentageBasisPoint: number,\n  ) {\n    super(inputs);\n    this.ownerAddress = ownerAddress;\n    this.feePercentageBasisPoint = feePercentageBasisPoint;\n\n    const { pubKeyHash, stakeCredentialHash } =\n      deserializeAddress(ownerAddress);\n\n    this.scriptCbor = this.getScriptCbor(\n      pubKeyHash,\n      stakeCredentialHash,\n      feePercentageBasisPoint,\n    );\n    this.scriptAddress = this.getScriptAddress(this.scriptCbor);\n  }\n\n  getScriptCbor = (\n    pubKeyHash: string,\n    stakeCredentialHash: string,\n    feePercentageBasisPoint: number,\n  ) => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(\n          blueprintV2.validators[0]!.compiledCode,\n          [\n            pubKeyAddress(pubKeyHash, stakeCredentialHash),\n            integer(feePercentageBasisPoint),\n          ],\n          \"JSON\",\n        );\n      default:\n        return applyParamsToScript(\n          blueprintV1.validators[0]!.compiledCode,\n          [\n            pubKeyAddress(pubKeyHash, stakeCredentialHash),\n            integer(feePercentageBasisPoint),\n          ],\n          \"JSON\",\n        );\n    }\n  };\n\n  listAsset = async (asset: string, price: number) => {\n    const { utxos, walletAddress } = await this.getWalletInfoForTx();\n\n    const assetMap = new Map<Unit, Quantity>();\n    assetMap.set(asset, \"1\");\n\n    const tokenForSale = [{ unit: asset, quantity: \"1\" }];\n    const outputDatum = marketplaceDatum(walletAddress, price, asset);\n\n    await this.mesh\n      .txOut(this.scriptAddress, tokenForSale)\n      .txOutInlineDatumValue(outputDatum, \"JSON\")\n      .changeAddress(walletAddress)\n      .selectUtxosFrom(utxos)\n      .complete();\n\n    return this.mesh.txHex;\n  };\n\n  delistAsset = async (marketplaceUtxo: UTxO) => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        marketplaceUtxo.input.txHash,\n        marketplaceUtxo.input.outputIndex,\n        marketplaceUtxo.output.amount,\n        marketplaceUtxo.output.address,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(mConStr1([]))\n      .txInScript(this.scriptCbor)\n      .changeAddress(walletAddress)\n      .requiredSignerHash(deserializeAddress(walletAddress).pubKeyHash)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n\n    return this.mesh.txHex;\n  };\n\n  purchaseAsset = async (marketplaceUtxo: UTxO) => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n\n    const inputDatum = deserializeDatum<MarketplaceDatum>(\n      marketplaceUtxo.output.plutusData!,\n    );\n\n    const inputLovelace = marketplaceUtxo.output.amount.find(\n      (a) => a.unit === \"lovelace\",\n    )!.quantity;\n\n    const tx = this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        marketplaceUtxo.input.txHash,\n        marketplaceUtxo.input.outputIndex,\n        marketplaceUtxo.output.amount,\n        marketplaceUtxo.output.address,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(mConStr0([]))\n      .txInScript(this.scriptCbor)\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos);\n\n    let ownerToReceiveLovelace =\n      ((inputDatum.fields[1].int as number) * this.feePercentageBasisPoint) /\n      10000;\n    if (this.feePercentageBasisPoint > 0 && ownerToReceiveLovelace < 1000000) {\n      ownerToReceiveLovelace = 1000000;\n    }\n\n    if (ownerToReceiveLovelace > 0) {\n      const ownerToReceive = [\n        {\n          unit: \"lovelace\",\n          quantity: Math.ceil(ownerToReceiveLovelace).toString(),\n        },\n      ];\n      tx.txOut(this.ownerAddress, ownerToReceive);\n    }\n\n    const sellerToReceiveLovelace =\n      (inputDatum.fields[1].int as number) + Number(inputLovelace);\n\n    if (sellerToReceiveLovelace > 0) {\n      const sellerAddress = serializeAddressObj(\n        inputDatum.fields[0],\n        this.networkId,\n      );\n      const sellerToReceive = [\n        {\n          unit: \"lovelace\",\n          quantity: sellerToReceiveLovelace.toString(),\n        },\n      ];\n      tx.txOut(sellerAddress, sellerToReceive);\n    }\n    await tx.complete();\n\n    return this.mesh.txHex;\n  };\n\n  relistAsset = async (marketplaceUtxo: UTxO, newPrice: number) => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n    const inputAsset = marketplaceUtxo.output.amount.find(\n      (a) => a.unit !== \"lovelace\",\n    )!.unit;\n\n    const tokenForSale = [{ unit: inputAsset, quantity: \"1\" }];\n    const outputDatum = marketplaceDatum(walletAddress, newPrice, inputAsset);\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        marketplaceUtxo.input.txHash,\n        marketplaceUtxo.input.outputIndex,\n        marketplaceUtxo.output.amount,\n        marketplaceUtxo.output.address,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(mConStr1([]))\n      .txInScript(this.scriptCbor)\n      .txOut(this.scriptAddress, tokenForSale)\n      .txOutInlineDatumValue(outputDatum, \"JSON\")\n      .changeAddress(walletAddress)\n      .requiredSignerHash(deserializeAddress(walletAddress).pubKeyHash)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {\n    return await this._getUtxoByTxHash(txHash, this.scriptCbor);\n  };\n\n  static getCompiledCode = (version = 2) => {\n    switch (version) {\n      case 2:\n        return blueprintV2.validators[0]!.compiledCode;\n      default:\n        return blueprintV1.validators[0]!.compiledCode;\n    }\n  };\n}\n",
      "dependencies": [
        "MarketplaceDatum",
        "marketplaceDatum",
        "MeshMarketplaceContract"
      ],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:payment-splitter.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/payment-splitter/index.ts",
      "name": "payment-splitter.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from './offchain';\n",
      "dependencies": [],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:payment-splitter.offchain.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/payment-splitter/offchain.ts",
      "name": "payment-splitter.offchain.ts",
      "imports": [
        {
          "module": "MeshPaymentSplitterContract",
          "items": [],
          "line": 14,
          "raw": "export class MeshPaymentSplitterContract extends MeshTxInitiator {",
          "source": "mesh-contract"
        }
      ],
      "functions": [
        {
          "name": "wrapPayees",
          "signature": "wrapPayees = (payees: string[]) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "payees",
              "type": "string[]",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 19,
          "raw": "  wrapPayees = (payees: string[]) =>\n    list(\n      payees.map((payee) =>\n        builtinByteString(deserializeAddress(payee).pubKeyHash),\n      ),\n    );\n\n  constructor(inputs: MeshTxInitiatorInput, payees: string[]) {\n    super(inputs);\n\n    if (inputs.wallet) {\n      inputs.wallet.getUsedAddresses().then((addresses) => {\n        this.payees = [addresses[0]!, ...payees];\n      });\n    } else {\n      this.payees = payees;\n      console.warn(\n        \"Wallet not provided. Therefore the payment address will not be added to the payees list which makes it impossible to trigger the payout.\",\n      );\n    }\n\n    this.scriptCbor = this.getScriptCbor();\n    this.scriptAddress = this.getScriptAddress(this.scriptCbor);\n  }",
          "source": "mesh-contract",
          "implementation": "  wrapPayees = (payees: string[]) =>\n    list(\n      payees.map((payee) =>\n        builtinByteString(deserializeAddress(payee).pubKeyHash),\n      ),\n    );\n\n  constructor(inputs: MeshTxInitiatorInput, payees: string[]) {\n    super(inputs);\n\n    if (inputs.wallet) {\n      inputs.wallet.getUsedAddresses().then((addresses) => {\n        this.payees = [addresses[0]!, ...payees];\n      });\n    } else {\n      this.payees = payees;\n      console.warn(\n        \"Wallet not provided. Therefore the payment address will not be added to the payees list which makes it impossible to trigger the payout.\",\n      );\n    }\n\n    this.scriptCbor = this.getScriptCbor();\n    this.scriptAddress = this.getScriptAddress(this.scriptCbor);\n  }"
        },
        {
          "name": "getScriptCbor",
          "signature": "getScriptCbor = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 44,
          "raw": "  getScriptCbor = () => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(\n          blueprintV2.validators[0]!.compiledCode,\n          [this.wrapPayees(this.payees)],\n          \"JSON\",\n        );\n\n      default:\n        return applyParamsToScript(\n          blueprintV1.validators[0]!.compiledCode,\n          [this.wrapPayees(this.payees)],\n          \"JSON\",\n        );\n    }\n  };",
          "source": "mesh-contract",
          "implementation": "  getScriptCbor = () => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(\n          blueprintV2.validators[0]!.compiledCode,\n          [this.wrapPayees(this.payees)],\n          \"JSON\",\n        );\n\n      default:\n        return applyParamsToScript(\n          blueprintV1.validators[0]!.compiledCode,\n          [this.wrapPayees(this.payees)],\n          \"JSON\",\n        );\n    }\n  };"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "datum",
          "type": "any",
          "value": "{",
          "isPublic": true,
          "line": 70,
          "raw": "const datum = {",
          "source": "mesh-contract"
        },
        {
          "name": "tx",
          "type": "any",
          "value": "new Transaction({ initiator: this.wallet }).sendLovelace(",
          "isPublic": true,
          "line": 75,
          "raw": "const tx = new Transaction({ initiator: this.wallet }).sendLovelace(",
          "source": "mesh-contract"
        },
        {
          "name": "unsignedTx",
          "type": "any",
          "value": "await tx.build();",
          "isPublic": true,
          "line": 83,
          "raw": "const unsignedTx = await tx.build();",
          "source": "mesh-contract"
        },
        {
          "name": "script",
          "type": "PlutusScript",
          "value": "{",
          "isPublic": true,
          "line": 94,
          "raw": "const script: PlutusScript = {",
          "source": "mesh-contract"
        },
        {
          "name": "datum",
          "type": "any",
          "value": "{",
          "isPublic": true,
          "line": 102,
          "raw": "const datum = {",
          "source": "mesh-contract"
        },
        {
          "name": "redeemerData",
          "type": "any",
          "value": "\"Hello, World!\";",
          "isPublic": true,
          "line": 107,
          "raw": "const redeemerData = \"Hello, World!\";",
          "source": "mesh-contract"
        },
        {
          "name": "redeemer",
          "type": "any",
          "value": "{ data: { alternative: 0, fields: [redeemerData] } };",
          "isPublic": true,
          "line": 108,
          "raw": "const redeemer = { data: { alternative: 0, fields: [redeemerData] } };",
          "source": "mesh-contract"
        },
        {
          "name": "amount",
          "type": "any",
          "value": "utxo.output?.amount;",
          "isPublic": true,
          "line": 113,
          "raw": "const amount = utxo.output?.amount;",
          "source": "mesh-contract"
        },
        {
          "name": "unsignedTx",
          "type": "any",
          "value": "await tx.build();",
          "isPublic": true,
          "line": 135,
          "raw": "const unsignedTx = await tx.build();",
          "source": "mesh-contract"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { builtinByteString, list, PlutusScript } from \"@meshsdk/common\";\nimport {\n  BrowserWallet,\n  deserializeAddress,\n  MeshWallet,\n  Transaction,\n} from \"@meshsdk/core\";\nimport { applyParamsToScript } from \"@meshsdk/core-cst\";\n\nimport { MeshTxInitiator, MeshTxInitiatorInput } from \"../common\";\nimport blueprintV1 from \"./aiken-workspace-v1/plutus.json\";\nimport blueprintV2 from \"./aiken-workspace-v2/plutus.json\";\n\nexport class MeshPaymentSplitterContract extends MeshTxInitiator {\n  scriptCbor: string;\n  scriptAddress: string;\n  payees: string[] = [];\n\n  wrapPayees = (payees: string[]) =>\n    list(\n      payees.map((payee) =>\n        builtinByteString(deserializeAddress(payee).pubKeyHash),\n      ),\n    );\n\n  constructor(inputs: MeshTxInitiatorInput, payees: string[]) {\n    super(inputs);\n\n    if (inputs.wallet) {\n      inputs.wallet.getUsedAddresses().then((addresses) => {\n        this.payees = [addresses[0]!, ...payees];\n      });\n    } else {\n      this.payees = payees;\n      console.warn(\n        \"Wallet not provided. Therefore the payment address will not be added to the payees list which makes it impossible to trigger the payout.\",\n      );\n    }\n\n    this.scriptCbor = this.getScriptCbor();\n    this.scriptAddress = this.getScriptAddress(this.scriptCbor);\n  }\n\n  getScriptCbor = () => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(\n          blueprintV2.validators[0]!.compiledCode,\n          [this.wrapPayees(this.payees)],\n          \"JSON\",\n        );\n\n      default:\n        return applyParamsToScript(\n          blueprintV1.validators[0]!.compiledCode,\n          [this.wrapPayees(this.payees)],\n          \"JSON\",\n        );\n    }\n  };\n\n  sendLovelaceToSplitter = async (lovelaceAmount: number): Promise<string> => {\n    if (this.wallet === null || this.wallet === undefined) {\n      throw new Error(\"Wallet not provided\");\n    }\n\n    const { walletAddress } = await this.getWalletInfoForTx();\n\n    const { pubKeyHash } = deserializeAddress(walletAddress);\n    const datum = {\n      alternative: 0,\n      fields: [pubKeyHash],\n    };\n\n    const tx = new Transaction({ initiator: this.wallet }).sendLovelace(\n      {\n        address: this.scriptAddress,\n        datum: { value: datum },\n      },\n      lovelaceAmount.toString(),\n    );\n\n    const unsignedTx = await tx.build();\n    return unsignedTx;\n  };\n\n  triggerPayout = async () => {\n    if (this.wallet === null || this.wallet === undefined) {\n      throw new Error(\"Wallet not provided\");\n    }\n\n    const { walletAddress, collateral } = await this.getWalletInfoForTx();\n\n    const script: PlutusScript = {\n      code: this.scriptCbor,\n      version: this.languageVersion,\n    };\n\n    const utxos =\n      (await this.fetcher?.fetchAddressUTxOs(this.scriptAddress)) || [];\n    const { pubKeyHash } = deserializeAddress(walletAddress);\n    const datum = {\n      alternative: 0,\n      fields: [pubKeyHash],\n    };\n\n    const redeemerData = \"Hello, World!\";\n    const redeemer = { data: { alternative: 0, fields: [redeemerData] } };\n\n    let tx = new Transaction({ initiator: this.wallet });\n    let split = 0;\n    for (const utxo of utxos) {\n      const amount = utxo.output?.amount;\n      if (amount) {\n        let lovelace = amount.find((asset) => asset.unit === \"lovelace\");\n        if (lovelace) {\n          split += Math.floor(Number(lovelace.quantity) / this.payees.length);\n        }\n\n        tx = tx.redeemValue({\n          value: utxo,\n          script: script,\n          datum: datum,\n          redeemer: redeemer,\n        });\n      }\n    }\n\n    tx = tx.setCollateral([collateral]);\n    for (const payee of this.payees) {\n      tx = tx.sendLovelace(payee, split.toString());\n    }\n\n    tx = tx.setRequiredSigners([walletAddress]);\n    const unsignedTx = await tx.build();\n    return unsignedTx;\n  };\n}\n",
      "dependencies": [
        "MeshPaymentSplitterContract"
      ],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:plutus-nft.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/plutus-nft/index.ts",
      "name": "plutus-nft.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./offchain\";\n",
      "dependencies": [],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/plutus-nft/offchain.ts",
      "name": "plutus-nft.offchain.ts",
      "imports": [
        {
          "module": "MeshPlutusNFTContract",
          "items": [],
          "line": 37,
          "raw": "export class MeshPlutusNFTContract extends MeshTxInitiator {",
          "source": "mesh-contract"
        }
      ],
      "functions": [
        {
          "name": "getOracleCbor",
          "signature": "getOracleCbor = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 42,
          "raw": "  getOracleCbor = () => {\n    return applyCborEncoding(blueprint.validators[0]!.compiledCode);\n  };",
          "source": "mesh-contract",
          "implementation": "  getOracleCbor = () => {\n    return applyCborEncoding(blueprint.validators[0]!.compiledCode);\n  };"
        },
        {
          "name": "getOracleNFTCbor",
          "signature": "getOracleNFTCbor = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 46,
          "raw": "  getOracleNFTCbor = () => {\n    return applyParamsToScript(blueprint.validators[2]!.compiledCode, [\n      mOutputReference(this.paramUtxo.txHash, this.paramUtxo.outputIndex),\n    ]);\n  };",
          "source": "mesh-contract",
          "implementation": "  getOracleNFTCbor = () => {\n    return applyParamsToScript(blueprint.validators[2]!.compiledCode, [\n      mOutputReference(this.paramUtxo.txHash, this.paramUtxo.outputIndex),\n    ]);\n  };"
        },
        {
          "name": "getNFTCbor",
          "signature": "getNFTCbor = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 52,
          "raw": "  getNFTCbor = () => {\n    const oracleNftPolicyId = resolveScriptHash(this.getOracleNFTCbor(), \"V3\");\n    return applyParamsToScript(blueprint.validators[4]!.compiledCode, [\n      stringToHex(this.collectionName),\n      oracleNftPolicyId,\n    ]);\n  };",
          "source": "mesh-contract",
          "implementation": "  getNFTCbor = () => {\n    const oracleNftPolicyId = resolveScriptHash(this.getOracleNFTCbor(), \"V3\");\n    return applyParamsToScript(blueprint.validators[4]!.compiledCode, [\n      stringToHex(this.collectionName),\n      oracleNftPolicyId,\n    ]);\n  };"
        },
        {
          "name": "oracleUtxo",
          "signature": "const oracleUtxo = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 235,
          "raw": "    const oracleUtxo = (\n      await this.getAddressUtxosWithToken(this.oracleAddress, oracleNftPolicyId)\n    )[0]!;\n    const oracleDatum: OracleDatum = parseDatumCbor(\n      oracleUtxo!.output.plutusData!,\n    );\n\n    const nftIndex = oracleDatum.fields[0].int;\n    const lovelacePrice = oracleDatum.fields[1].int;\n    const feeCollectorAddressObj = oracleDatum.fields[2];\n    const feeCollectorAddress = serializeAddressObj(\n      feeCollectorAddressObj,\n      this.networkId,\n    );\n\n    const policyId = resolveScriptHash(this.getNFTCbor(), \"V3\");\n\n    return {\n      nftIndex,\n      policyId,\n      lovelacePrice,\n      oracleUtxo,\n      oracleNftPolicyId,\n      feeCollectorAddress,\n      feeCollectorAddressObj,\n    };",
          "source": "mesh-contract",
          "implementation": "    const oracleUtxo = (\n      await this.getAddressUtxosWithToken(this.oracleAddress, oracleNftPolicyId)\n    )[0]!;\n    const oracleDatum: OracleDatum = parseDatumCbor(\n      oracleUtxo!.output.plutusData!,\n    );\n\n    const nftIndex = oracleDatum.fields[0].int;\n    const lovelacePrice = oracleDatum.fields[1].int;\n    const feeCollectorAddressObj = oracleDatum.fields[2];\n    const feeCollectorAddress = serializeAddressObj(\n      feeCollectorAddressObj,\n      this.networkId,\n    );\n\n    const policyId = resolveScriptHash(this.getNFTCbor(), \"V3\");\n\n    return {\n      nftIndex,\n      policyId,\n      lovelacePrice,\n      oracleUtxo,\n      oracleNftPolicyId,\n      feeCollectorAddress,\n      feeCollectorAddressObj,\n    };"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "oracleNftPolicyId",
          "type": "any",
          "value": "resolveScriptHash(this.getOracleNFTCbor(), \"V3\");",
          "isPublic": true,
          "line": 53,
          "raw": "const oracleNftPolicyId = resolveScriptHash(this.getOracleNFTCbor(), \"V3\");",
          "source": "mesh-contract"
        },
        {
          "name": "paramUtxo",
          "type": "any",
          "value": "utxos[0]!;",
          "isPublic": true,
          "line": 98,
          "raw": "const paramUtxo = utxos[0]!;",
          "source": "mesh-contract"
        },
        {
          "name": "script",
          "type": "any",
          "value": "blueprint.validators[2]!.compiledCode;",
          "isPublic": true,
          "line": 99,
          "raw": "const script = blueprint.validators[2]!.compiledCode;",
          "source": "mesh-contract"
        },
        {
          "name": "param",
          "type": "Data",
          "value": "mOutputReference(",
          "isPublic": true,
          "line": 100,
          "raw": "const param: Data = mOutputReference(",
          "source": "mesh-contract"
        },
        {
          "name": "paramScript",
          "type": "any",
          "value": "applyParamsToScript(script, [param]);",
          "isPublic": true,
          "line": 104,
          "raw": "const paramScript = applyParamsToScript(script, [param]);",
          "source": "mesh-contract"
        },
        {
          "name": "policyId",
          "type": "any",
          "value": "resolveScriptHash(paramScript, \"V3\");",
          "isPublic": true,
          "line": 105,
          "raw": "const policyId = resolveScriptHash(paramScript, \"V3\");",
          "source": "mesh-contract"
        },
        {
          "name": "tokenName",
          "type": "any",
          "value": "\"\";",
          "isPublic": true,
          "line": 106,
          "raw": "const tokenName = \"\";",
          "source": "mesh-contract"
        },
        {
          "name": "txHex",
          "type": "any",
          "value": "await this.mesh",
          "isPublic": true,
          "line": 110,
          "raw": "const txHex = await this.mesh",
          "source": "mesh-contract"
        },
        {
          "name": "tokenName",
          "type": "any",
          "value": "`${this.collectionName} (${nftIndex})`;",
          "isPublic": true,
          "line": 175,
          "raw": "const tokenName = `${this.collectionName} (${nftIndex})`;",
          "source": "mesh-contract"
        },
        {
          "name": "tokenNameHex",
          "type": "any",
          "value": "stringToHex(tokenName);",
          "isPublic": true,
          "line": 176,
          "raw": "const tokenNameHex = stringToHex(tokenName);",
          "source": "mesh-contract"
        },
        {
          "name": "updatedOracleDatum",
          "type": "OracleDatum",
          "value": "conStr0([",
          "isPublic": true,
          "line": 178,
          "raw": "const updatedOracleDatum: OracleDatum = conStr0([",
          "source": "mesh-contract"
        },
        {
          "name": "tx",
          "type": "any",
          "value": "this.mesh",
          "isPublic": true,
          "line": 184,
          "raw": "const tx = this.mesh",
          "source": "mesh-contract"
        },
        {
          "name": "metadata",
          "type": "any",
          "value": "{ [policyId]: { [tokenName]: { ...assetMetadata } } };",
          "isPublic": true,
          "line": 202,
          "raw": "const metadata = { [policyId]: { [tokenName]: { ...assetMetadata } } };",
          "source": "mesh-contract"
        },
        {
          "name": "txHex",
          "type": "any",
          "value": "await tx.complete();",
          "isPublic": true,
          "line": 219,
          "raw": "const txHex = await tx.complete();",
          "source": "mesh-contract"
        },
        {
          "name": "oracleNftPolicyId",
          "type": "any",
          "value": "resolveScriptHash(this.getOracleNFTCbor(), \"V3\");",
          "isPublic": true,
          "line": 234,
          "raw": "const oracleNftPolicyId = resolveScriptHash(this.getOracleNFTCbor(), \"V3\");",
          "source": "mesh-contract"
        },
        {
          "name": "oracleUtxo",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 235,
          "raw": "const oracleUtxo = (",
          "source": "mesh-contract"
        },
        {
          "name": "oracleDatum",
          "type": "OracleDatum",
          "value": "parseDatumCbor(",
          "isPublic": true,
          "line": 238,
          "raw": "const oracleDatum: OracleDatum = parseDatumCbor(",
          "source": "mesh-contract"
        },
        {
          "name": "nftIndex",
          "type": "any",
          "value": "oracleDatum.fields[0].int;",
          "isPublic": true,
          "line": 242,
          "raw": "const nftIndex = oracleDatum.fields[0].int;",
          "source": "mesh-contract"
        },
        {
          "name": "lovelacePrice",
          "type": "any",
          "value": "oracleDatum.fields[1].int;",
          "isPublic": true,
          "line": 243,
          "raw": "const lovelacePrice = oracleDatum.fields[1].int;",
          "source": "mesh-contract"
        },
        {
          "name": "feeCollectorAddressObj",
          "type": "any",
          "value": "oracleDatum.fields[2];",
          "isPublic": true,
          "line": 244,
          "raw": "const feeCollectorAddressObj = oracleDatum.fields[2];",
          "source": "mesh-contract"
        },
        {
          "name": "feeCollectorAddress",
          "type": "any",
          "value": "serializeAddressObj(",
          "isPublic": true,
          "line": 245,
          "raw": "const feeCollectorAddress = serializeAddressObj(",
          "source": "mesh-contract"
        },
        {
          "name": "policyId",
          "type": "any",
          "value": "resolveScriptHash(this.getNFTCbor(), \"V3\");",
          "isPublic": true,
          "line": 250,
          "raw": "const policyId = resolveScriptHash(this.getNFTCbor(), \"V3\");",
          "source": "mesh-contract"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  AssetMetadata,\n  conStr0,\n  Data,\n  integer,\n  mConStr0,\n  mOutputReference,\n  mPubKeyAddress,\n  stringToHex,\n} from \"@meshsdk/common\";\nimport {\n  deserializeAddress,\n  resolveScriptHash,\n  serializeAddressObj,\n  serializePlutusScript,\n  UTxO,\n  applyCborEncoding,\n  applyParamsToScript,\n} from \"@meshsdk/core\";\nimport {\n  parseDatumCbor\n} from \"@meshsdk/core-cst\";\n\nimport { MeshTxInitiator, MeshTxInitiatorInput } from \"../common\";\nimport blueprint from \"./aiken-workspace/plutus.json\";\nimport { OracleDatum } from \"./type\";\n\n/**\n * Mesh Plutus NFT contract class\n * \n * This NFT minting script enables users to mint NFTs with an automatically incremented index, which increases by one for each newly minted NFT. \n * \n * To facilitate this process, the first step is to set up a one-time minting policy by minting an oracle token. This oracle token is essential as it holds the current state and index of the NFTs, acting as a reference for the minting sequence. \n * \n * With each new NFT minted, the token index within the oracle is incremented by one, ensuring a consistent and orderly progression in the numbering of the NFTs.\n */\nexport class MeshPlutusNFTContract extends MeshTxInitiator {\n  collectionName: string;\n  paramUtxo: UTxO[\"input\"] = { outputIndex: 0, txHash: \"\" };\n  oracleAddress: string;\n\n  getOracleCbor = () => {\n    return applyCborEncoding(blueprint.validators[0]!.compiledCode);\n  };\n\n  getOracleNFTCbor = () => {\n    return applyParamsToScript(blueprint.validators[2]!.compiledCode, [\n      mOutputReference(this.paramUtxo.txHash, this.paramUtxo.outputIndex),\n    ]);\n  };\n\n  getNFTCbor = () => {\n    const oracleNftPolicyId = resolveScriptHash(this.getOracleNFTCbor(), \"V3\");\n    return applyParamsToScript(blueprint.validators[4]!.compiledCode, [\n      stringToHex(this.collectionName),\n      oracleNftPolicyId,\n    ]);\n  };\n\n  constructor(\n    inputs: MeshTxInitiatorInput,\n    contract: {\n      collectionName: string;\n      paramUtxo?: UTxO[\"input\"];\n    },\n  ) {\n    super(inputs);\n    this.collectionName = contract.collectionName;\n    if (contract.paramUtxo) {\n      this.paramUtxo = contract.paramUtxo;\n    }\n    this.oracleAddress = serializePlutusScript(\n      {\n        code: applyCborEncoding(blueprint.validators[0]!.compiledCode),\n        version: \"V3\",\n      },\n      inputs.stakeCredential,\n      inputs.networkId,\n    ).address;\n  }\n\n  /**\n   * Set up a one-time minting policy by minting an oracle token. This oracle token is essential as it holds the current state and index of the NFTs, acting as a reference for the minting sequence.\n   * @param lovelacePrice - Price of the NFT in lovelace\n   * @returns - Transaction hex and paramUtxo\n   *\n   * @example\n   * ```typescript\n   * const { tx, paramUtxo } = await contract.setupOracle(lovelacePrice);\n   * ```\n   */\n  setupOracle = async (lovelacePrice: number) => {\n    const { utxos, collateral, walletAddress } =\n      await this.getWalletInfoForTx();\n    if (utxos?.length <= 0) {\n      throw new Error(\"No UTxOs found\");\n    }\n    const paramUtxo = utxos[0]!;\n    const script = blueprint.validators[2]!.compiledCode;\n    const param: Data = mOutputReference(\n      paramUtxo.input.txHash,\n      paramUtxo.input.outputIndex,\n    );\n    const paramScript = applyParamsToScript(script, [param]);\n    const policyId = resolveScriptHash(paramScript, \"V3\");\n    const tokenName = \"\";\n    const { pubKeyHash, stakeCredentialHash } =\n      deserializeAddress(walletAddress);\n\n    const txHex = await this.mesh\n      .txIn(\n        paramUtxo.input.txHash,\n        paramUtxo.input.outputIndex,\n        paramUtxo.output.amount,\n        paramUtxo.output.address,\n      )\n      .mintPlutusScriptV3()\n      .mint(\"1\", policyId, tokenName)\n      .mintingScript(paramScript)\n      .mintRedeemerValue(mConStr0([]))\n      .txOut(this.oracleAddress, [{ unit: policyId, quantity: \"1\" }])\n      .txOutInlineDatumValue(\n        mConStr0([\n          0,\n          lovelacePrice,\n          mPubKeyAddress(pubKeyHash, stakeCredentialHash),\n        ]),\n      )\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .changeAddress(walletAddress)\n      .selectUtxosFrom(utxos)\n      .complete();\n\n    this.paramUtxo = paramUtxo.input;\n\n    return { tx: txHex, paramUtxo: paramUtxo.input };\n  };\n\n  /**\n   * Mint NFT token with an automatically incremented index, which increases by one for each newly minted NFT.\n   * @param assetMetadata - Asset metadata\n   * @returns - Transaction hex\n   *\n   * @example\n   * ```typescript\n   * const assetMetadata = {\n   *  ...demoAssetMetadata,\n   * name: `Mesh Token ${oracleData.nftIndex}`,\n   * };\n   * const tx = await contract.mintPlutusNFT(assetMetadata);\n   * ```\n   */\n  mintPlutusNFT = async (assetMetadata?: AssetMetadata) => {\n    const { utxos, collateral, walletAddress } =\n      await this.getWalletInfoForTx();\n    if (utxos?.length <= 0) {\n      throw new Error(\"No UTxOs found\");\n    }\n\n    const {\n      nftIndex,\n      policyId,\n      lovelacePrice,\n      oracleUtxo,\n      oracleNftPolicyId,\n      feeCollectorAddress,\n      feeCollectorAddressObj,\n    } = await this.getOracleData();\n\n    const tokenName = `${this.collectionName} (${nftIndex})`;\n    const tokenNameHex = stringToHex(tokenName);\n\n    const updatedOracleDatum: OracleDatum = conStr0([\n      integer((nftIndex as number) + 1),\n      integer(lovelacePrice),\n      feeCollectorAddressObj,\n    ]);\n\n    const tx = this.mesh\n      .spendingPlutusScriptV3()\n      .txIn(\n        oracleUtxo.input.txHash,\n        oracleUtxo.input.outputIndex,\n        oracleUtxo.output.amount,\n        oracleUtxo.output.address,\n      )\n      .txInRedeemerValue(mConStr0([]))\n      .txInScript(this.getOracleCbor())\n      .txInInlineDatumPresent()\n      .txOut(this.oracleAddress, [{ unit: oracleNftPolicyId, quantity: \"1\" }])\n      .txOutInlineDatumValue(updatedOracleDatum, \"JSON\")\n      .mintPlutusScriptV3()\n      .mint(\"1\", policyId, tokenNameHex)\n      .mintingScript(this.getNFTCbor());\n\n    if (assetMetadata) {\n      const metadata = { [policyId]: { [tokenName]: { ...assetMetadata } } };\n      tx.metadataValue(721, metadata);\n    }\n\n    tx.mintRedeemerValue(mConStr0([]))\n      .txOut(feeCollectorAddress, [\n        { unit: \"lovelace\", quantity: lovelacePrice.toString() },\n      ])\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .changeAddress(walletAddress)\n      .selectUtxosFrom(utxos);\n\n    const txHex = await tx.complete();\n    return txHex;\n  };\n\n  /**\n   * Get the current oracle data.\n   *\n   * @returns - Oracle data\n   *\n   * @example\n   * ```typescript\n   * const oracleData = await contract.getOracleData();\n   * ```\n   */\n  getOracleData = async () => {\n    const oracleNftPolicyId = resolveScriptHash(this.getOracleNFTCbor(), \"V3\");\n    const oracleUtxo = (\n      await this.getAddressUtxosWithToken(this.oracleAddress, oracleNftPolicyId)\n    )[0]!;\n    const oracleDatum: OracleDatum = parseDatumCbor(\n      oracleUtxo!.output.plutusData!,\n    );\n\n    const nftIndex = oracleDatum.fields[0].int;\n    const lovelacePrice = oracleDatum.fields[1].int;\n    const feeCollectorAddressObj = oracleDatum.fields[2];\n    const feeCollectorAddress = serializeAddressObj(\n      feeCollectorAddressObj,\n      this.networkId,\n    );\n\n    const policyId = resolveScriptHash(this.getNFTCbor(), \"V3\");\n\n    return {\n      nftIndex,\n      policyId,\n      lovelacePrice,\n      oracleUtxo,\n      oracleNftPolicyId,\n      feeCollectorAddress,\n      feeCollectorAddressObj,\n    };\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {\n    return await this._getUtxoByTxHash(txHash);\n  };\n}\n",
      "dependencies": [
        "MeshPlutusNFTContract"
      ],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:plutus-nft.type.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/plutus-nft/type.ts",
      "name": "plutus-nft.type.ts",
      "imports": [
        {
          "module": "OracleDatum",
          "items": [],
          "line": 3,
          "raw": "export type OracleDatum = ConStr0<[Integer, Integer, PubKeyAddress]>;",
          "source": "mesh-contract"
        }
      ],
      "functions": [],
      "types": [
        {
          "name": "OracleDatum",
          "definition": "export type OracleDatum = ConStr0<[Integer, Integer, PubKeyAddress]>;",
          "isPublic": true,
          "line": 3,
          "raw": "export type OracleDatum = ConStr0<[Integer, Integer, PubKeyAddress]>;",
          "source": "mesh-contract"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { ConStr0, Integer, PubKeyAddress } from \"@meshsdk/common\";\n\nexport type OracleDatum = ConStr0<[Integer, Integer, PubKeyAddress]>;\n",
      "dependencies": [
        "OracleDatum"
      ],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:royalties.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/royalties/index.ts",
      "name": "royalties.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from './offchain';\n",
      "dependencies": [],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:royalties.offchain.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/royalties/offchain.ts",
      "name": "royalties.offchain.ts",
      "imports": [
        {
          "module": "MeshRoyaltiesContract",
          "items": [],
          "line": 3,
          "raw": "export class MeshRoyaltiesContract extends MeshTxInitiator {",
          "source": "mesh-contract"
        }
      ],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { MeshTxInitiator, MeshTxInitiatorInput } from \"../common\";\n\nexport class MeshRoyaltiesContract extends MeshTxInitiator {\n\n  constructor(inputs: MeshTxInitiatorInput) {\n    super(inputs);\n  }\n\n}",
      "dependencies": [
        "MeshRoyaltiesContract"
      ],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:swap.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/swap/index.ts",
      "name": "swap.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from './offchain';\n",
      "dependencies": [],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:swap.offchain.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/swap/offchain.ts",
      "name": "swap.offchain.ts",
      "imports": [
        {
          "module": "SwapDatum",
          "items": [],
          "line": 25,
          "raw": "export type SwapDatum = ConStr0<[PubKeyAddress, Value, Value]>;",
          "source": "mesh-contract"
        },
        {
          "module": "MeshSwapContract",
          "items": [],
          "line": 27,
          "raw": "export class MeshSwapContract extends MeshTxInitiator {",
          "source": "mesh-contract"
        }
      ],
      "functions": [
        {
          "name": "getScriptCbor",
          "signature": "getScriptCbor = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 37,
          "raw": "  getScriptCbor = () => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };",
          "source": "mesh-contract",
          "implementation": "  getScriptCbor = () => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };"
        }
      ],
      "types": [
        {
          "name": "SwapDatum",
          "definition": "export type SwapDatum = ConStr0<[PubKeyAddress, Value, Value]>;",
          "isPublic": true,
          "line": 25,
          "raw": "export type SwapDatum = ConStr0<[PubKeyAddress, Value, Value]>;",
          "source": "mesh-contract"
        }
      ],
      "constants": [
        {
          "name": "swapDatum",
          "type": "SwapDatum",
          "value": "conStr0([",
          "isPublic": true,
          "line": 54,
          "raw": "const swapDatum: SwapDatum = conStr0([",
          "source": "mesh-contract"
        },
        {
          "name": "inlineDatum",
          "type": "any",
          "value": "deserializeDatum<SwapDatum>(",
          "isPublic": true,
          "line": 79,
          "raw": "const inlineDatum = deserializeDatum<SwapDatum>(",
          "source": "mesh-contract"
        },
        {
          "name": "initiatorAddress",
          "type": "any",
          "value": "serializeAddressObj(",
          "isPublic": true,
          "line": 82,
          "raw": "const initiatorAddress = serializeAddressObj(",
          "source": "mesh-contract"
        },
        {
          "name": "initiatorToReceive",
          "type": "any",
          "value": "inlineDatum.fields[2];",
          "isPublic": true,
          "line": 86,
          "raw": "const initiatorToReceive = inlineDatum.fields[2];",
          "source": "mesh-contract"
        },
        {
          "name": "inlineDatum",
          "type": "any",
          "value": "deserializeDatum<SwapDatum>(",
          "isPublic": true,
          "line": 118,
          "raw": "const inlineDatum = deserializeDatum<SwapDatum>(",
          "source": "mesh-contract"
        },
        {
          "name": "initiatorAddress",
          "type": "any",
          "value": "serializeAddressObj(",
          "isPublic": true,
          "line": 121,
          "raw": "const initiatorAddress = serializeAddressObj(",
          "source": "mesh-contract"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  Asset,\n  conStr0,\n  ConStr0,\n  mConStr0,\n  mConStr1,\n  MeshValue,\n  pubKeyAddress,\n  PubKeyAddress,\n  UTxO,\n  value,\n  Value,\n} from \"@meshsdk/common\";\nimport {\n  deserializeAddress,\n  deserializeDatum,\n  serializeAddressObj,\n} from \"@meshsdk/core\";\nimport { applyParamsToScript } from \"@meshsdk/core-cst\";\n\nimport { MeshTxInitiator, MeshTxInitiatorInput } from \"../common\";\nimport blueprintV1 from \"./aiken-workspace-v1/plutus.json\";\nimport blueprintV2 from \"./aiken-workspace-v2/plutus.json\";\n\nexport type SwapDatum = ConStr0<[PubKeyAddress, Value, Value]>;\n\nexport class MeshSwapContract extends MeshTxInitiator {\n  scriptCbor: string;\n  scriptAddress: string;\n\n  constructor(inputs: MeshTxInitiatorInput) {\n    super(inputs);\n    this.scriptCbor = this.getScriptCbor();\n    this.scriptAddress = this.getScriptAddress(this.scriptCbor);\n  }\n\n  getScriptCbor = () => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };\n\n  initiateSwap = async (\n    toProvide: Asset[],\n    toReceive: Asset[],\n  ): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n    const { pubKeyHash, stakeCredentialHash } =\n      deserializeAddress(walletAddress);\n    const swapDatum: SwapDatum = conStr0([\n      pubKeyAddress(pubKeyHash, stakeCredentialHash),\n      value(toProvide),\n      value(toReceive),\n    ]);\n\n    await this.mesh\n      .txOut(this.scriptAddress, toProvide)\n      .txOutInlineDatumValue(swapDatum, \"JSON\")\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n\n    return this.mesh.txHex;\n  };\n\n  acceptSwap = async (swapUtxo: UTxO): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n    const inlineDatum = deserializeDatum<SwapDatum>(\n      swapUtxo.output.plutusData!,\n    );\n    const initiatorAddress = serializeAddressObj(\n      inlineDatum.fields[0],\n      this.networkId,\n    );\n    const initiatorToReceive = inlineDatum.fields[2];\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        swapUtxo.input.txHash,\n        swapUtxo.input.outputIndex,\n        swapUtxo.output.amount,\n        swapUtxo.output.address,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(mConStr1([]))\n      .txInScript(this.scriptCbor)\n      .txOut(\n        initiatorAddress,\n        MeshValue.fromValue(initiatorToReceive).toAssets(),\n      )\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  cancelSwap = async (swapUtxo: UTxO): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n    const inlineDatum = deserializeDatum<SwapDatum>(\n      swapUtxo.output.plutusData!,\n    );\n    const initiatorAddress = serializeAddressObj(\n      inlineDatum.fields[0],\n      this.networkId,\n    );\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        swapUtxo.input.txHash,\n        swapUtxo.input.outputIndex,\n        swapUtxo.output.amount,\n        swapUtxo.output.address,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(mConStr0([]))\n      .txInScript(this.scriptCbor)\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .requiredSignerHash(deserializeAddress(initiatorAddress).pubKeyHash)\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {\n    return await this._getUtxoByTxHash(txHash, this.scriptCbor);\n  };\n}\n",
      "dependencies": [
        "SwapDatum",
        "MeshSwapContract"
      ],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:vesting.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/vesting/index.ts",
      "name": "vesting.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from './offchain';\n",
      "dependencies": [],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-contract:vesting.offchain.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/vesting/offchain.ts",
      "name": "vesting.offchain.ts",
      "imports": [
        {
          "module": "VestingDatum",
          "items": [],
          "line": 21,
          "raw": "export type VestingDatum = ConStr0<",
          "source": "mesh-contract"
        },
        {
          "module": "MeshVestingContract",
          "items": [],
          "line": 25,
          "raw": "export class MeshVestingContract extends MeshTxInitiator {",
          "source": "mesh-contract"
        }
      ],
      "functions": [
        {
          "name": "getScriptCbor",
          "signature": "getScriptCbor = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 35,
          "raw": "  getScriptCbor = () => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };",
          "source": "mesh-contract",
          "implementation": "  getScriptCbor = () => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };"
        }
      ],
      "types": [
        {
          "name": "VestingDatum",
          "definition": "export type VestingDatum = ConStr0<\n  [Integer, BuiltinByteString, BuiltinByteString]\n>;",
          "isPublic": true,
          "line": 21,
          "raw": "export type VestingDatum = ConStr0<",
          "source": "mesh-contract"
        }
      ],
      "constants": [
        {
          "name": "datum",
          "type": "any",
          "value": "deserializeDatum<VestingDatum>(",
          "isPublic": true,
          "line": 77,
          "raw": "const datum = deserializeDatum<VestingDatum>(",
          "source": "mesh-contract"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  BuiltinByteString,\n  ConStr0,\n  Integer,\n  mConStr0,\n  SLOT_CONFIG_NETWORK,\n  unixTimeToEnclosingSlot,\n} from \"@meshsdk/common\";\nimport {\n  Asset,\n  deserializeAddress,\n  deserializeDatum,\n  UTxO,\n} from \"@meshsdk/core\";\nimport { applyParamsToScript } from \"@meshsdk/core-cst\";\n\nimport { MeshTxInitiator, MeshTxInitiatorInput } from \"../common\";\nimport blueprintV1 from \"./aiken-workspace-v1/plutus.json\";\nimport blueprintV2 from \"./aiken-workspace-v2/plutus.json\";\n\nexport type VestingDatum = ConStr0<\n  [Integer, BuiltinByteString, BuiltinByteString]\n>;\n\nexport class MeshVestingContract extends MeshTxInitiator {\n  scriptCbor: string;\n  scriptAddress: string;\n\n  constructor(inputs: MeshTxInitiatorInput) {\n    super(inputs);\n    this.scriptCbor = this.getScriptCbor();\n    this.scriptAddress = this.getScriptAddress(this.scriptCbor);\n  }\n\n  getScriptCbor = () => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };\n\n  depositFund = async (\n    amount: Asset[],\n    lockUntilTimeStampMs: number,\n    beneficiary: string,\n  ): Promise<string> => {\n    const { utxos, walletAddress } = await this.getWalletInfoForTx();\n\n    const { pubKeyHash: ownerPubKeyHash } = deserializeAddress(walletAddress);\n    const { pubKeyHash: beneficiaryPubKeyHash } =\n      deserializeAddress(beneficiary);\n\n    await this.mesh\n      .txOut(this.scriptAddress, amount)\n      .txOutInlineDatumValue(\n        mConStr0([\n          lockUntilTimeStampMs,\n          ownerPubKeyHash,\n          beneficiaryPubKeyHash,\n        ]),\n      )\n      .changeAddress(walletAddress)\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  withdrawFund = async (vestingUtxo: UTxO): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n    const { input: collateralInput, output: collateralOutput } = collateral;\n\n    const { pubKeyHash } = deserializeAddress(walletAddress);\n\n    const datum = deserializeDatum<VestingDatum>(\n      vestingUtxo.output.plutusData!,\n    );\n\n    const invalidBefore =\n      unixTimeToEnclosingSlot(\n        Math.min(Number(datum.fields[0].int), Date.now() - 15000),\n        this.networkId === 0\n          ? SLOT_CONFIG_NETWORK.preprod\n          : SLOT_CONFIG_NETWORK.mainnet,\n      ) + 1;\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        vestingUtxo.input.txHash,\n        vestingUtxo.input.outputIndex,\n        vestingUtxo.output.amount,\n        this.scriptAddress,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(\"\")\n      .txInScript(this.scriptCbor)\n      .txOut(walletAddress, [])\n      .txInCollateral(\n        collateralInput.txHash,\n        collateralInput.outputIndex,\n        collateralOutput.amount,\n        collateralOutput.address,\n      )\n      .invalidBefore(invalidBefore)\n      .requiredSignerHash(pubKeyHash)\n      .changeAddress(walletAddress)\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {\n    return await this._getUtxoByTxHash(txHash, this.scriptCbor);\n  };\n}\n",
      "dependencies": [
        "VestingDatum",
        "MeshVestingContract"
      ],
      "source": "mesh-contract",
      "isReExportFile": false
    },
    {
      "key": "mesh-transaction:index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/index.ts",
      "name": "index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./mesh-tx-builder\";\nexport * from \"./scripts\";\nexport * from \"./transaction\";\nexport * from \"./utils\";\nexport * from \"./tx-parser\";\n",
      "dependencies": [],
      "source": "mesh-transaction",
      "isReExportFile": false
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/cardano-sdk-adapter.ts",
      "name": "mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts",
      "imports": [
        {
          "module": "BuilderCallbacksSdkBridge",
          "items": [],
          "line": 34,
          "raw": "export class BuilderCallbacksSdkBridge",
          "source": "mesh-transaction"
        },
        {
          "module": "CardanoSdkInputSelector",
          "items": [],
          "line": 124,
          "raw": "export class CardanoSdkInputSelector implements IInputSelector {",
          "source": "mesh-transaction"
        },
        {
          "module": "StaticChangeAddressResolver",
          "items": [],
          "line": 205,
          "raw": "export class StaticChangeAddressResolver",
          "source": "mesh-transaction"
        }
      ],
      "functions": [
        {
          "name": "meshTxInToCSDKUtxo",
          "signature": "const meshTxInToCSDKUtxo = (txIn: TxIn): CSDK.Utxo => {",
          "documentation": "",
          "parameters": [
            {
              "name": "txIn",
              "type": "TxIn",
              "optional": false
            }
          ],
          "returnType": "CSDK.Utxo",
          "isPublic": true,
          "line": 224,
          "raw": "const meshTxInToCSDKUtxo = (txIn: TxIn): CSDK.Utxo => {\n  return [\n    {\n      txId: <CSDK.TransactionId>txIn.txIn.txHash,\n      index: txIn.txIn.txIndex,\n      address: <CSDK.PaymentAddress>txIn.txIn.address,\n    },\n    {\n      address: <CSDK.PaymentAddress>txIn.txIn.address,\n      value: meshAssetsToCSDKValue(txIn.txIn.amount),\n    },\n  ];\n};",
          "source": "mesh-transaction",
          "implementation": "const meshTxInToCSDKUtxo = (txIn: TxIn): CSDK.Utxo => {\n  return [\n    {\n      txId: <CSDK.TransactionId>txIn.txIn.txHash,\n      index: txIn.txIn.txIndex,\n      address: <CSDK.PaymentAddress>txIn.txIn.address,\n    },\n    {\n      address: <CSDK.PaymentAddress>txIn.txIn.address,\n      value: meshAssetsToCSDKValue(txIn.txIn.amount),\n    },\n  ];\n};"
        },
        {
          "name": "meshUtxoToCSDKUtxo",
          "signature": "const meshUtxoToCSDKUtxo = (utxo: UTxO): CSDK.Utxo => {",
          "documentation": "",
          "parameters": [
            {
              "name": "utxo",
              "type": "UTxO",
              "optional": false
            }
          ],
          "returnType": "CSDK.Utxo",
          "isPublic": true,
          "line": 238,
          "raw": "const meshUtxoToCSDKUtxo = (utxo: UTxO): CSDK.Utxo => {\n  return [\n    {\n      txId: <CSDK.TransactionId>utxo.input.txHash,\n      index: utxo.input.outputIndex,\n      address: <CSDK.PaymentAddress>utxo.output.address,\n    },\n    {\n      address: <CSDK.PaymentAddress>utxo.output.address,\n      value: meshAssetsToCSDKValue(utxo.output.amount),\n      datumHash: meshDataHashToCSDKDataHash(utxo.output.dataHash),\n      datum: meshDatumToCSDKDatum(utxo.output.plutusData),\n      scriptReference: meshScriptReferenceToCSDKScriptReference(\n        utxo.output.scriptRef,\n      ),\n    },\n  ];\n};",
          "source": "mesh-transaction",
          "implementation": "const meshUtxoToCSDKUtxo = (utxo: UTxO): CSDK.Utxo => {\n  return [\n    {\n      txId: <CSDK.TransactionId>utxo.input.txHash,\n      index: utxo.input.outputIndex,\n      address: <CSDK.PaymentAddress>utxo.output.address,\n    },\n    {\n      address: <CSDK.PaymentAddress>utxo.output.address,\n      value: meshAssetsToCSDKValue(utxo.output.amount),\n      datumHash: meshDataHashToCSDKDataHash(utxo.output.dataHash),\n      datum: meshDatumToCSDKDatum(utxo.output.plutusData),\n      scriptReference: meshScriptReferenceToCSDKScriptReference(\n        utxo.output.scriptRef,\n      ),\n    },\n  ];\n};"
        },
        {
          "name": "meshScriptReferenceToCSDKScriptReference",
          "signature": "const meshScriptReferenceToCSDKScriptReference = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 257,
          "raw": "const meshScriptReferenceToCSDKScriptReference = (\n  scriptReference?: string,\n): CSDK.Script | undefined => {\n  if (!scriptReference) {\n    return undefined;\n  }\n\n  return Serialization.Script.fromCbor(<HexBlob>scriptReference).toCore();\n};",
          "source": "mesh-transaction",
          "implementation": "const meshScriptReferenceToCSDKScriptReference = (\n  scriptReference?: string,\n): CSDK.Script | undefined => {\n  if (!scriptReference) {\n    return undefined;\n  }\n\n  return Serialization.Script.fromCbor(<HexBlob>scriptReference).toCore();\n};"
        },
        {
          "name": "meshDatumToCSDKDatum",
          "signature": "const meshDatumToCSDKDatum = (datum?: string): CSDK.PlutusData | undefined => {",
          "documentation": "",
          "parameters": [
            {
              "name": "datum",
              "type": "string",
              "optional": true
            }
          ],
          "returnType": "CSDK.PlutusData | undefined",
          "isPublic": true,
          "line": 267,
          "raw": "const meshDatumToCSDKDatum = (datum?: string): CSDK.PlutusData | undefined => {\n  if (!datum) {\n    return undefined;\n  }\n\n  return Serialization.PlutusData.fromCbor(<HexBlob>datum).toCore();\n};",
          "source": "mesh-transaction",
          "implementation": "const meshDatumToCSDKDatum = (datum?: string): CSDK.PlutusData | undefined => {\n  if (!datum) {\n    return undefined;\n  }\n\n  return Serialization.PlutusData.fromCbor(<HexBlob>datum).toCore();\n};"
        },
        {
          "name": "meshDataHashToCSDKDataHash",
          "signature": "const meshDataHashToCSDKDataHash = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 275,
          "raw": "const meshDataHashToCSDKDataHash = (\n  hash?: string,\n): CSDK.DatumHash | undefined => {\n  if (!hash) {\n    return undefined;\n  }\n  return <CSDK.DatumHash>hash;\n};",
          "source": "mesh-transaction",
          "implementation": "const meshDataHashToCSDKDataHash = (\n  hash?: string,\n): CSDK.DatumHash | undefined => {\n  if (!hash) {\n    return undefined;\n  }\n  return <CSDK.DatumHash>hash;\n};"
        },
        {
          "name": "meshAssetsToCSDKValue",
          "signature": "const meshAssetsToCSDKValue = (assets?: Asset[]): CSDK.Value => {",
          "documentation": "",
          "parameters": [
            {
              "name": "assets",
              "type": "Asset[]",
              "optional": true
            }
          ],
          "returnType": "CSDK.Value",
          "isPublic": true,
          "line": 284,
          "raw": "const meshAssetsToCSDKValue = (assets?: Asset[]): CSDK.Value => {\n  if (!assets) {\n    throw new Error(\n      \"Missing required assets. Be sure that you resolve all required UTxOs\",\n    );\n  }\n\n  let lovelace = 0n;\n  const sdkAssets = new Map<CSDK.AssetId, bigint>();\n\n  for (const asset of assets) {\n    if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n      lovelace = BigInt(asset.quantity);\n    } else {\n      const assetId = <CSDK.AssetId>asset.unit;\n      sdkAssets.set(assetId, BigInt(asset.quantity));\n    }\n  }\n\n  if (sdkAssets.size === 0) {\n    return { coins: lovelace };\n  }\n\n  return {\n    coins: lovelace,\n    assets: sdkAssets,\n  };\n};",
          "source": "mesh-transaction",
          "implementation": "const meshAssetsToCSDKValue = (assets?: Asset[]): CSDK.Value => {\n  if (!assets) {\n    throw new Error(\n      \"Missing required assets. Be sure that you resolve all required UTxOs\",\n    );\n  }\n\n  let lovelace = 0n;\n  const sdkAssets = new Map<CSDK.AssetId, bigint>();\n\n  for (const asset of assets) {\n    if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n      lovelace = BigInt(asset.quantity);\n    } else {\n      const assetId = <CSDK.AssetId>asset.unit;\n      sdkAssets.set(assetId, BigInt(asset.quantity));\n    }\n  }\n\n  if (sdkAssets.size === 0) {\n    return { coins: lovelace };\n  }\n\n  return {\n    coins: lovelace,\n    assets: sdkAssets,\n  };\n};"
        },
        {
          "name": "meshAssetsToCSDKAssets",
          "signature": "const meshAssetsToCSDKAssets = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 313,
          "raw": "const meshAssetsToCSDKAssets = (\n  assets?: Asset[],\n): CSDK.TokenMap | undefined => {\n  if (!assets) {\n    return undefined;\n  }\n\n  const sdkAssets = new Map<CSDK.AssetId, bigint>();\n\n  for (const asset of assets) {\n    if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n      throw new Error(\"Unexpected lovelace asset in assets\");\n    } else {\n      const assetId = <CSDK.AssetId>asset.unit;\n      sdkAssets.set(assetId, BigInt(asset.quantity));\n    }\n  }\n\n  return sdkAssets;\n};",
          "source": "mesh-transaction",
          "implementation": "const meshAssetsToCSDKAssets = (\n  assets?: Asset[],\n): CSDK.TokenMap | undefined => {\n  if (!assets) {\n    return undefined;\n  }\n\n  const sdkAssets = new Map<CSDK.AssetId, bigint>();\n\n  for (const asset of assets) {\n    if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n      throw new Error(\"Unexpected lovelace asset in assets\");\n    } else {\n      const assetId = <CSDK.AssetId>asset.unit;\n      sdkAssets.set(assetId, BigInt(asset.quantity));\n    }\n  }\n\n  return sdkAssets;\n};"
        },
        {
          "name": "CSDKOutputToMeshOutput",
          "signature": "const CSDKOutputToMeshOutput = (output: CSDK.TxOut): TxOutput => {",
          "documentation": "",
          "parameters": [
            {
              "name": "output",
              "type": "CSDK.TxOut",
              "optional": false
            }
          ],
          "returnType": "TxOutput",
          "isPublic": true,
          "line": 334,
          "raw": "const CSDKOutputToMeshOutput = (output: CSDK.TxOut): TxOutput => {\n  const amount = CSDKValueToMeshAssets(output.value);\n  return {\n    address: output.address,\n    amount: amount,\n  };\n};",
          "source": "mesh-transaction",
          "implementation": "const CSDKOutputToMeshOutput = (output: CSDK.TxOut): TxOutput => {\n  const amount = CSDKValueToMeshAssets(output.value);\n  return {\n    address: output.address,\n    amount: amount,\n  };\n};"
        },
        {
          "name": "CSDKValueToMeshAssets",
          "signature": "const CSDKValueToMeshAssets = (value: CSDK.Value): Asset[] => {",
          "documentation": "",
          "parameters": [
            {
              "name": "value",
              "type": "CSDK.Value",
              "optional": false
            }
          ],
          "returnType": "Asset[]",
          "isPublic": true,
          "line": 342,
          "raw": "const CSDKValueToMeshAssets = (value: CSDK.Value): Asset[] => {\n  const assets: Asset[] = [];\n\n  if (value.coins !== 0n) {\n    assets.push({\n      unit: \"lovelace\",\n      quantity: value.coins.toString(),\n    });\n  }\n\n  if (value.assets) {\n    for (const [assetId, quantity] of value.assets) {\n      assets.push({\n        unit: assetId,\n        quantity: quantity.toString(),\n      });\n    }\n  }\n\n  return assets;\n};",
          "source": "mesh-transaction",
          "implementation": "const CSDKValueToMeshAssets = (value: CSDK.Value): Asset[] => {\n  const assets: Asset[] = [];\n\n  if (value.coins !== 0n) {\n    assets.push({\n      unit: \"lovelace\",\n      quantity: value.coins.toString(),\n    });\n  }\n\n  if (value.assets) {\n    for (const [assetId, quantity] of value.assets) {\n      assets.push({\n        unit: assetId,\n        quantity: quantity.toString(),\n      });\n    }\n  }\n\n  return assets;\n};"
        },
        {
          "name": "CSDKTokenMapToMeshAssets",
          "signature": "const CSDKTokenMapToMeshAssets = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 364,
          "raw": "const CSDKTokenMapToMeshAssets = (\n  tokenMap?: CSDK.TokenMap,\n): Asset[] | undefined => {\n  if (!tokenMap) {\n    return undefined;\n  }\n\n  const assets: Asset[] = [];\n\n  for (const [assetId, quantity] of tokenMap) {\n    assets.push({\n      unit: assetId,\n      quantity: quantity.toString(),\n    });\n  }\n\n  return assets;\n};",
          "source": "mesh-transaction",
          "implementation": "const CSDKTokenMapToMeshAssets = (\n  tokenMap?: CSDK.TokenMap,\n): Asset[] | undefined => {\n  if (!tokenMap) {\n    return undefined;\n  }\n\n  const assets: Asset[] = [];\n\n  for (const [assetId, quantity] of tokenMap) {\n    assets.push({\n      unit: assetId,\n      quantity: quantity.toString(),\n    });\n  }\n\n  return assets;\n};"
        },
        {
          "name": "meshOutputToCSDKOutput",
          "signature": "const meshOutputToCSDKOutput = (output: Output): CSDK.TxOut => {",
          "documentation": "",
          "parameters": [
            {
              "name": "output",
              "type": "Output",
              "optional": false
            }
          ],
          "returnType": "CSDK.TxOut",
          "isPublic": true,
          "line": 383,
          "raw": "const meshOutputToCSDKOutput = (output: Output): CSDK.TxOut => {\n  const { dataHash, datum, scriptReference } =\n    meshOutputToCSDKOutputsScriptData(output);\n\n  return {\n    address: <CSDK.PaymentAddress>output.address,\n    value: meshAssetsToCSDKValue(output.amount),\n    datumHash: dataHash,\n    datum: datum,\n    scriptReference: scriptReference,\n  };\n};",
          "source": "mesh-transaction",
          "implementation": "const meshOutputToCSDKOutput = (output: Output): CSDK.TxOut => {\n  const { dataHash, datum, scriptReference } =\n    meshOutputToCSDKOutputsScriptData(output);\n\n  return {\n    address: <CSDK.PaymentAddress>output.address,\n    value: meshAssetsToCSDKValue(output.amount),\n    datumHash: dataHash,\n    datum: datum,\n    scriptReference: scriptReference,\n  };\n};"
        },
        {
          "name": "makeAggregatedCSDKOOutput",
          "signature": "const makeAggregatedCSDKOOutput = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 396,
          "raw": "const makeAggregatedCSDKOOutput = (\n  outputs: Output[],\n): CSDK.TxOut | undefined => {\n  let totalAssets = new Map<string, bigint>();\n\n  for (const output of outputs) {\n    totalAssets = sumAssets(totalAssets, output.amount);\n  }\n\n  if (totalAssets.size === 0) {\n    return undefined;\n  }\n\n  return {\n    address: <CSDK.PaymentAddress>FAKE_ADDRESS,\n    value: assetsMapToCSDKValue(totalAssets),\n  };\n};",
          "source": "mesh-transaction",
          "implementation": "const makeAggregatedCSDKOOutput = (\n  outputs: Output[],\n): CSDK.TxOut | undefined => {\n  let totalAssets = new Map<string, bigint>();\n\n  for (const output of outputs) {\n    totalAssets = sumAssets(totalAssets, output.amount);\n  }\n\n  if (totalAssets.size === 0) {\n    return undefined;\n  }\n\n  return {\n    address: <CSDK.PaymentAddress>FAKE_ADDRESS,\n    value: assetsMapToCSDKValue(totalAssets),\n  };\n};"
        },
        {
          "name": "meshOutputToCSDKOutputsScriptData",
          "signature": "const meshOutputToCSDKOutputsScriptData = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 415,
          "raw": "const meshOutputToCSDKOutputsScriptData = (\n  output: Output,\n): {\n  dataHash?: CSDK.DatumHash;\n  datum?: CSDK.PlutusData;\n  scriptReference?: CSDK.Script;\n} => {\n  let dataHash: CSDK.DatumHash | undefined = undefined;\n  let datum: CSDK.PlutusData | undefined = undefined;\n  let scriptReference: CSDK.Script | undefined;\n\n  if (output.datum?.type === \"Hash\") {\n    dataHash = meshDataHashToCSDKDataHash(\n      HexBlob(fromBuilderToPlutusData(output.datum.data).hash()),\n    );\n  } else if (output.datum?.type === \"Inline\") {\n    datum = meshDatumToCSDKDatum(\n      fromBuilderToPlutusData(output.datum.data).toCbor(),\n    );\n  } else if (output.datum?.type === \"Embedded\") {\n    throw new Error(\"Embedded datum is not supported\");\n  }\n\n  let meshCoreScript = undefined;\n  if (output.referenceScript) {\n    switch (output.referenceScript.version) {\n      case \"V1\": {\n        meshCoreScript = Script.newPlutusV1Script(\n          PlutusV1Script.fromCbor(HexBlob(output.referenceScript.code)),\n        );\n        break;\n      }\n      case \"V2\": {\n        meshCoreScript = Script.newPlutusV2Script(\n          PlutusV2Script.fromCbor(HexBlob(output.referenceScript.code)),\n        );\n        break;\n      }\n      case \"V3\": {\n        meshCoreScript = Script.newPlutusV3Script(\n          PlutusV3Script.fromCbor(HexBlob(output.referenceScript.code)),\n        );\n        break;\n      }\n    }\n  }\n\n  scriptReference = meshScriptReferenceToCSDKScriptReference(\n    meshCoreScript?.toCbor(),\n  );\n\n  return {\n    dataHash,\n    datum,\n    scriptReference,\n  };\n};",
          "source": "mesh-transaction",
          "implementation": "const meshOutputToCSDKOutputsScriptData = (\n  output: Output,\n): {\n  dataHash?: CSDK.DatumHash;\n  datum?: CSDK.PlutusData;\n  scriptReference?: CSDK.Script;\n} => {\n  let dataHash: CSDK.DatumHash | undefined = undefined;\n  let datum: CSDK.PlutusData | undefined = undefined;\n  let scriptReference: CSDK.Script | undefined;\n\n  if (output.datum?.type === \"Hash\") {\n    dataHash = meshDataHashToCSDKDataHash(\n      HexBlob(fromBuilderToPlutusData(output.datum.data).hash()),\n    );\n  } else if (output.datum?.type === \"Inline\") {\n    datum = meshDatumToCSDKDatum(\n      fromBuilderToPlutusData(output.datum.data).toCbor(),\n    );\n  } else if (output.datum?.type === \"Embedded\") {\n    throw new Error(\"Embedded datum is not supported\");\n  }\n\n  let meshCoreScript = undefined;\n  if (output.referenceScript) {\n    switch (output.referenceScript.version) {\n      case \"V1\": {\n        meshCoreScript = Script.newPlutusV1Script(\n          PlutusV1Script.fromCbor(HexBlob(output.referenceScript.code)),\n        );\n        break;\n      }\n      case \"V2\": {\n        meshCoreScript = Script.newPlutusV2Script(\n          PlutusV2Script.fromCbor(HexBlob(output.referenceScript.code)),\n        );\n        break;\n      }\n      case \"V3\": {\n        meshCoreScript = Script.newPlutusV3Script(\n          PlutusV3Script.fromCbor(HexBlob(output.referenceScript.code)),\n        );\n        break;\n      }\n    }\n  }\n\n  scriptReference = meshScriptReferenceToCSDKScriptReference(\n    meshCoreScript?.toCbor(),\n  );\n\n  return {\n    dataHash,\n    datum,\n    scriptReference,\n  };\n};"
        },
        {
          "name": "assetsMapToCSDKValue",
          "signature": "const assetsMapToCSDKValue = (assets: Map<string, bigint>): CSDK.Value => {",
          "documentation": "",
          "parameters": [
            {
              "name": "assets",
              "type": "Map<string, bigint>",
              "optional": false
            }
          ],
          "returnType": "CSDK.Value",
          "isPublic": true,
          "line": 473,
          "raw": "const assetsMapToCSDKValue = (assets: Map<string, bigint>): CSDK.Value => {\n  let lovelace = 0n;\n  const sdkAssets = new Map<CSDK.AssetId, bigint>();\n\n  for (const [unit, quantity] of assets) {\n    if (unit === \"lovelace\" || unit === \"\") {\n      lovelace = BigInt(quantity);\n    } else {\n      const assetId = <CSDK.AssetId>unit;\n      sdkAssets.set(assetId, BigInt(quantity));\n    }\n  }\n\n  if (sdkAssets.size === 0) {\n    return { coins: lovelace };\n  }\n\n  return {\n    coins: lovelace,\n    assets: sdkAssets,\n  };\n};",
          "source": "mesh-transaction",
          "implementation": "const assetsMapToCSDKValue = (assets: Map<string, bigint>): CSDK.Value => {\n  let lovelace = 0n;\n  const sdkAssets = new Map<CSDK.AssetId, bigint>();\n\n  for (const [unit, quantity] of assets) {\n    if (unit === \"lovelace\" || unit === \"\") {\n      lovelace = BigInt(quantity);\n    } else {\n      const assetId = <CSDK.AssetId>unit;\n      sdkAssets.set(assetId, BigInt(quantity));\n    }\n  }\n\n  if (sdkAssets.size === 0) {\n    return { coins: lovelace };\n  }\n\n  return {\n    coins: lovelace,\n    assets: sdkAssets,\n  };\n};"
        },
        {
          "name": "sumAssets",
          "signature": "const sumAssets = (a: Map<string, bigint>, b: Asset[]): Map<string, bigint> => {",
          "documentation": "",
          "parameters": [
            {
              "name": "a",
              "type": "Map<string, bigint>",
              "optional": false
            },
            {
              "name": "b",
              "type": "Asset[]",
              "optional": false
            }
          ],
          "returnType": "Map<string, bigint>",
          "isPublic": true,
          "line": 496,
          "raw": "const sumAssets = (a: Map<string, bigint>, b: Asset[]): Map<string, bigint> => {\n  for (const asset of b) {\n    const currentAmount = a.get(asset.unit) ?? 0n;\n    a.set(asset.unit, currentAmount + BigInt(asset.quantity));\n  }\n  return a;\n};",
          "source": "mesh-transaction",
          "implementation": "const sumAssets = (a: Map<string, bigint>, b: Asset[]): Map<string, bigint> => {\n  for (const asset of b) {\n    const currentAmount = a.get(asset.unit) ?? 0n;\n    a.set(asset.unit, currentAmount + BigInt(asset.quantity));\n  }\n  return a;\n};"
        },
        {
          "name": "meshImplicitCoinToCSDKImplicitCoins",
          "signature": "const meshImplicitCoinToCSDKImplicitCoins = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 504,
          "raw": "const meshImplicitCoinToCSDKImplicitCoins = (\n  implicitCoins?: ImplicitValue,\n): CardanoSelection.ImplicitValue | undefined => {\n  if (!implicitCoins) {\n    return undefined;\n  }\n  const mint = meshAssetsToCSDKAssets(implicitCoins.mint);\n  const totalInput = implicitCoins.reclaimDeposit + implicitCoins.withdrawals;\n  const CSKDImplicitCoin = {\n    withdrawals: implicitCoins.withdrawals,\n    input: totalInput,\n    deposit: implicitCoins.deposit,\n    reclaimDeposit: implicitCoins.reclaimDeposit,\n  };\n\n  return {\n    coin: CSKDImplicitCoin,\n    mint: mint,\n  };\n};",
          "source": "mesh-transaction",
          "implementation": "const meshImplicitCoinToCSDKImplicitCoins = (\n  implicitCoins?: ImplicitValue,\n): CardanoSelection.ImplicitValue | undefined => {\n  if (!implicitCoins) {\n    return undefined;\n  }\n  const mint = meshAssetsToCSDKAssets(implicitCoins.mint);\n  const totalInput = implicitCoins.reclaimDeposit + implicitCoins.withdrawals;\n  const CSKDImplicitCoin = {\n    withdrawals: implicitCoins.withdrawals,\n    input: totalInput,\n    deposit: implicitCoins.deposit,\n    reclaimDeposit: implicitCoins.reclaimDeposit,\n  };\n\n  return {\n    coin: CSKDImplicitCoin,\n    mint: mint,\n  };\n};"
        },
        {
          "name": "meshActionToCSDKRedeemer",
          "signature": "const meshActionToCSDKRedeemer = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 525,
          "raw": "const meshActionToCSDKRedeemer = (\n  action: Omit<Action, \"data\">,\n): CSDK.Redeemer => {\n  return {\n    purpose: meshRedeemerTagToCSDKRedeemerTag(action.tag),\n    index: action.index,\n    executionUnits: {\n      steps: action.budget.steps,\n      memory: action.budget.mem,\n    },\n    data: 0n,\n  };\n};",
          "source": "mesh-transaction",
          "implementation": "const meshActionToCSDKRedeemer = (\n  action: Omit<Action, \"data\">,\n): CSDK.Redeemer => {\n  return {\n    purpose: meshRedeemerTagToCSDKRedeemerTag(action.tag),\n    index: action.index,\n    executionUnits: {\n      steps: action.budget.steps,\n      memory: action.budget.mem,\n    },\n    data: 0n,\n  };\n};"
        },
        {
          "name": "CSDKRedeemerToMeshAction",
          "signature": "const CSDKRedeemerToMeshAction = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 539,
          "raw": "const CSDKRedeemerToMeshAction = (\n  redeemer: CSDK.Redeemer,\n): Omit<Action, \"data\"> => {\n  return {\n    tag: CSDKRedeemerTagToMeshRedeemerTag(redeemer.purpose),\n    index: redeemer.index,\n    budget: {\n      steps: redeemer.executionUnits.steps,\n      mem: redeemer.executionUnits.memory,\n    },\n  };\n};",
          "source": "mesh-transaction",
          "implementation": "const CSDKRedeemerToMeshAction = (\n  redeemer: CSDK.Redeemer,\n): Omit<Action, \"data\"> => {\n  return {\n    tag: CSDKRedeemerTagToMeshRedeemerTag(redeemer.purpose),\n    index: redeemer.index,\n    budget: {\n      steps: redeemer.executionUnits.steps,\n      mem: redeemer.executionUnits.memory,\n    },\n  };\n};"
        },
        {
          "name": "meshRedeemerTagToCSDKRedeemerTag",
          "signature": "const meshRedeemerTagToCSDKRedeemerTag = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 552,
          "raw": "const meshRedeemerTagToCSDKRedeemerTag = (\n  tag: RedeemerTagType,\n): CSDK.RedeemerPurpose => {\n  switch (tag) {\n    case \"SPEND\":\n      return CSDK.RedeemerPurpose.spend;\n    case \"MINT\":\n      return CSDK.RedeemerPurpose.mint;\n    case \"CERT\":\n      return CSDK.RedeemerPurpose.certificate;\n    case \"REWARD\":\n      return CSDK.RedeemerPurpose.withdrawal;\n    case \"PROPOSE\":\n      return CSDK.RedeemerPurpose.propose;\n    case \"VOTE\":\n      return CSDK.RedeemerPurpose.vote;\n  }\n};",
          "source": "mesh-transaction",
          "implementation": "const meshRedeemerTagToCSDKRedeemerTag = (\n  tag: RedeemerTagType,\n): CSDK.RedeemerPurpose => {\n  switch (tag) {\n    case \"SPEND\":\n      return CSDK.RedeemerPurpose.spend;\n    case \"MINT\":\n      return CSDK.RedeemerPurpose.mint;\n    case \"CERT\":\n      return CSDK.RedeemerPurpose.certificate;\n    case \"REWARD\":\n      return CSDK.RedeemerPurpose.withdrawal;\n    case \"PROPOSE\":\n      return CSDK.RedeemerPurpose.propose;\n    case \"VOTE\":\n      return CSDK.RedeemerPurpose.vote;\n  }\n};"
        },
        {
          "name": "CSDKRedeemerTagToMeshRedeemerTag",
          "signature": "const CSDKRedeemerTagToMeshRedeemerTag = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 571,
          "raw": "const CSDKRedeemerTagToMeshRedeemerTag = (\n  tag: CSDK.RedeemerPurpose,\n): RedeemerTagType => {\n  switch (tag) {\n    case CSDK.RedeemerPurpose.spend:\n      return \"SPEND\";\n    case CSDK.RedeemerPurpose.mint:\n      return \"MINT\";\n    case CSDK.RedeemerPurpose.certificate:\n      return \"CERT\";\n    case CSDK.RedeemerPurpose.withdrawal:\n      return \"REWARD\";\n    case CSDK.RedeemerPurpose.propose:\n      return \"PROPOSE\";\n    case CSDK.RedeemerPurpose.vote:\n      return \"VOTE\";\n  }\n};",
          "source": "mesh-transaction",
          "implementation": "const CSDKRedeemerTagToMeshRedeemerTag = (\n  tag: CSDK.RedeemerPurpose,\n): RedeemerTagType => {\n  switch (tag) {\n    case CSDK.RedeemerPurpose.spend:\n      return \"SPEND\";\n    case CSDK.RedeemerPurpose.mint:\n      return \"MINT\";\n    case CSDK.RedeemerPurpose.certificate:\n      return \"CERT\";\n    case CSDK.RedeemerPurpose.withdrawal:\n      return \"REWARD\";\n    case CSDK.RedeemerPurpose.propose:\n      return \"PROPOSE\";\n    case CSDK.RedeemerPurpose.vote:\n      return \"VOTE\";\n  }\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "costs",
          "type": "any",
          "value": "await this.builderCallback.computeMinimumCost({",
          "isPublic": true,
          "line": 60,
          "raw": "const costs = await this.builderCallback.computeMinimumCost({",
          "source": "mesh-transaction"
        },
        {
          "name": "maxSizeExceed",
          "type": "any",
          "value": "await this.builderCallback.maxSizeExceed({",
          "isPublic": true,
          "line": 78,
          "raw": "const maxSizeExceed = await this.builderCallback.maxSizeExceed({",
          "source": "mesh-transaction"
        },
        {
          "name": "newInputs",
          "type": "any",
          "value": "new Set<UTxO>();",
          "isPublic": true,
          "line": 103,
          "raw": "const newInputs = new Set<UTxO>();",
          "source": "mesh-transaction"
        },
        {
          "name": "utxoId",
          "type": "any",
          "value": "`${input[0].txId}#${input[0].index}`;",
          "isPublic": true,
          "line": 106,
          "raw": "const utxoId = `${input[0].txId}#${input[0].index}`;",
          "source": "mesh-transaction"
        },
        {
          "name": "originalUtxo",
          "type": "any",
          "value": "this.utxoMap.get(utxoId);",
          "isPublic": true,
          "line": 112,
          "raw": "const originalUtxo = this.utxoMap.get(utxoId);",
          "source": "mesh-transaction"
        },
        {
          "name": "utxoMap",
          "type": "any",
          "value": "new Map<string, UTxO>();",
          "isPublic": true,
          "line": 139,
          "raw": "const utxoMap = new Map<string, UTxO>();",
          "source": "mesh-transaction"
        },
        {
          "name": "aggregatedTxOut",
          "type": "any",
          "value": "makeAggregatedCSDKOOutput(outputs);",
          "isPublic": true,
          "line": 145,
          "raw": "const aggregatedTxOut = makeAggregatedCSDKOOutput(outputs);",
          "source": "mesh-transaction"
        },
        {
          "name": "aggregatedOuts",
          "type": "any",
          "value": "new Set<CSDK.TxOut>();",
          "isPublic": true,
          "line": 146,
          "raw": "const aggregatedOuts = new Set<CSDK.TxOut>();",
          "source": "mesh-transaction"
        },
        {
          "name": "preselectedUtoxsCSDK",
          "type": "any",
          "value": "new Set(",
          "isPublic": true,
          "line": 151,
          "raw": "const preselectedUtoxsCSDK = new Set(",
          "source": "mesh-transaction"
        },
        {
          "name": "utxoxCSDK",
          "type": "any",
          "value": "utxos.map(meshUtxoToCSDKUtxo);",
          "isPublic": true,
          "line": 154,
          "raw": "const utxoxCSDK = utxos.map(meshUtxoToCSDKUtxo);",
          "source": "mesh-transaction"
        },
        {
          "name": "selector",
          "type": "any",
          "value": "CardanoSelection.roundRobinRandomImprove({",
          "isPublic": true,
          "line": 157,
          "raw": "const selector = CardanoSelection.roundRobinRandomImprove({",
          "source": "mesh-transaction"
        },
        {
          "name": "usedUtxos",
          "type": "any",
          "value": "new Set<string>();",
          "isPublic": true,
          "line": 162,
          "raw": "const usedUtxos = new Set<string>();",
          "source": "mesh-transaction"
        },
        {
          "name": "builderCallbacksBridge",
          "type": "any",
          "value": "new BuilderCallbacksSdkBridge(",
          "isPublic": true,
          "line": 167,
          "raw": "const builderCallbacksBridge = new BuilderCallbacksSdkBridge(",
          "source": "mesh-transaction"
        },
        {
          "name": "selectResult",
          "type": "any",
          "value": "await selector.select({",
          "isPublic": true,
          "line": 174,
          "raw": "const selectResult = await selector.select({",
          "source": "mesh-transaction"
        },
        {
          "name": "newInputs",
          "type": "any",
          "value": "new Set<UTxO>();",
          "isPublic": true,
          "line": 182,
          "raw": "const newInputs = new Set<UTxO>();",
          "source": "mesh-transaction"
        },
        {
          "name": "utxoId",
          "type": "any",
          "value": "`${input[0].txId}#${input[0].index}`;",
          "isPublic": true,
          "line": 184,
          "raw": "const utxoId = `${input[0].txId}#${input[0].index}`;",
          "source": "mesh-transaction"
        },
        {
          "name": "originalUtxo",
          "type": "any",
          "value": "utxoMap.get(utxoId);",
          "isPublic": true,
          "line": 186,
          "raw": "const originalUtxo = utxoMap.get(utxoId);",
          "source": "mesh-transaction"
        },
        {
          "name": "meshTxInToCSDKUtxo",
          "type": "any",
          "value": "(txIn: TxIn): CSDK.Utxo => {",
          "isPublic": true,
          "line": 224,
          "raw": "const meshTxInToCSDKUtxo = (txIn: TxIn): CSDK.Utxo => {",
          "source": "mesh-transaction"
        },
        {
          "name": "meshUtxoToCSDKUtxo",
          "type": "any",
          "value": "(utxo: UTxO): CSDK.Utxo => {",
          "isPublic": true,
          "line": 238,
          "raw": "const meshUtxoToCSDKUtxo = (utxo: UTxO): CSDK.Utxo => {",
          "source": "mesh-transaction"
        },
        {
          "name": "meshScriptReferenceToCSDKScriptReference",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 257,
          "raw": "const meshScriptReferenceToCSDKScriptReference = (",
          "source": "mesh-transaction"
        },
        {
          "name": "meshDatumToCSDKDatum",
          "type": "any",
          "value": "(datum?: string): CSDK.PlutusData | undefined => {",
          "isPublic": true,
          "line": 267,
          "raw": "const meshDatumToCSDKDatum = (datum?: string): CSDK.PlutusData | undefined => {",
          "source": "mesh-transaction"
        },
        {
          "name": "meshDataHashToCSDKDataHash",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 275,
          "raw": "const meshDataHashToCSDKDataHash = (",
          "source": "mesh-transaction"
        },
        {
          "name": "meshAssetsToCSDKValue",
          "type": "any",
          "value": "(assets?: Asset[]): CSDK.Value => {",
          "isPublic": true,
          "line": 284,
          "raw": "const meshAssetsToCSDKValue = (assets?: Asset[]): CSDK.Value => {",
          "source": "mesh-transaction"
        },
        {
          "name": "sdkAssets",
          "type": "any",
          "value": "new Map<CSDK.AssetId, bigint>();",
          "isPublic": true,
          "line": 292,
          "raw": "const sdkAssets = new Map<CSDK.AssetId, bigint>();",
          "source": "mesh-transaction"
        },
        {
          "name": "assetId",
          "type": "any",
          "value": "<CSDK.AssetId>asset.unit;",
          "isPublic": true,
          "line": 298,
          "raw": "const assetId = <CSDK.AssetId>asset.unit;",
          "source": "mesh-transaction"
        },
        {
          "name": "meshAssetsToCSDKAssets",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 313,
          "raw": "const meshAssetsToCSDKAssets = (",
          "source": "mesh-transaction"
        },
        {
          "name": "sdkAssets",
          "type": "any",
          "value": "new Map<CSDK.AssetId, bigint>();",
          "isPublic": true,
          "line": 320,
          "raw": "const sdkAssets = new Map<CSDK.AssetId, bigint>();",
          "source": "mesh-transaction"
        },
        {
          "name": "assetId",
          "type": "any",
          "value": "<CSDK.AssetId>asset.unit;",
          "isPublic": true,
          "line": 326,
          "raw": "const assetId = <CSDK.AssetId>asset.unit;",
          "source": "mesh-transaction"
        },
        {
          "name": "CSDKOutputToMeshOutput",
          "type": "any",
          "value": "(output: CSDK.TxOut): TxOutput => {",
          "isPublic": true,
          "line": 334,
          "raw": "const CSDKOutputToMeshOutput = (output: CSDK.TxOut): TxOutput => {",
          "source": "mesh-transaction"
        },
        {
          "name": "amount",
          "type": "any",
          "value": "CSDKValueToMeshAssets(output.value);",
          "isPublic": true,
          "line": 335,
          "raw": "const amount = CSDKValueToMeshAssets(output.value);",
          "source": "mesh-transaction"
        },
        {
          "name": "CSDKValueToMeshAssets",
          "type": "any",
          "value": "(value: CSDK.Value): Asset[] => {",
          "isPublic": true,
          "line": 342,
          "raw": "const CSDKValueToMeshAssets = (value: CSDK.Value): Asset[] => {",
          "source": "mesh-transaction"
        },
        {
          "name": "assets",
          "type": "Asset[]",
          "value": "[];",
          "isPublic": true,
          "line": 343,
          "raw": "const assets: Asset[] = [];",
          "source": "mesh-transaction"
        },
        {
          "name": "CSDKTokenMapToMeshAssets",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 364,
          "raw": "const CSDKTokenMapToMeshAssets = (",
          "source": "mesh-transaction"
        },
        {
          "name": "assets",
          "type": "Asset[]",
          "value": "[];",
          "isPublic": true,
          "line": 371,
          "raw": "const assets: Asset[] = [];",
          "source": "mesh-transaction"
        },
        {
          "name": "meshOutputToCSDKOutput",
          "type": "any",
          "value": "(output: Output): CSDK.TxOut => {",
          "isPublic": true,
          "line": 383,
          "raw": "const meshOutputToCSDKOutput = (output: Output): CSDK.TxOut => {",
          "source": "mesh-transaction"
        },
        {
          "name": "makeAggregatedCSDKOOutput",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 396,
          "raw": "const makeAggregatedCSDKOOutput = (",
          "source": "mesh-transaction"
        },
        {
          "name": "meshOutputToCSDKOutputsScriptData",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 415,
          "raw": "const meshOutputToCSDKOutputsScriptData = (",
          "source": "mesh-transaction"
        },
        {
          "name": "assetsMapToCSDKValue",
          "type": "any",
          "value": "(assets: Map<string, bigint>): CSDK.Value => {",
          "isPublic": true,
          "line": 473,
          "raw": "const assetsMapToCSDKValue = (assets: Map<string, bigint>): CSDK.Value => {",
          "source": "mesh-transaction"
        },
        {
          "name": "sdkAssets",
          "type": "any",
          "value": "new Map<CSDK.AssetId, bigint>();",
          "isPublic": true,
          "line": 475,
          "raw": "const sdkAssets = new Map<CSDK.AssetId, bigint>();",
          "source": "mesh-transaction"
        },
        {
          "name": "assetId",
          "type": "any",
          "value": "<CSDK.AssetId>unit;",
          "isPublic": true,
          "line": 481,
          "raw": "const assetId = <CSDK.AssetId>unit;",
          "source": "mesh-transaction"
        },
        {
          "name": "sumAssets",
          "type": "any",
          "value": "(a: Map<string, bigint>, b: Asset[]): Map<string, bigint> => {",
          "isPublic": true,
          "line": 496,
          "raw": "const sumAssets = (a: Map<string, bigint>, b: Asset[]): Map<string, bigint> => {",
          "source": "mesh-transaction"
        },
        {
          "name": "currentAmount",
          "type": "any",
          "value": "a.get(asset.unit) ?? 0n;",
          "isPublic": true,
          "line": 498,
          "raw": "const currentAmount = a.get(asset.unit) ?? 0n;",
          "source": "mesh-transaction"
        },
        {
          "name": "meshImplicitCoinToCSDKImplicitCoins",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 504,
          "raw": "const meshImplicitCoinToCSDKImplicitCoins = (",
          "source": "mesh-transaction"
        },
        {
          "name": "mint",
          "type": "any",
          "value": "meshAssetsToCSDKAssets(implicitCoins.mint);",
          "isPublic": true,
          "line": 510,
          "raw": "const mint = meshAssetsToCSDKAssets(implicitCoins.mint);",
          "source": "mesh-transaction"
        },
        {
          "name": "totalInput",
          "type": "any",
          "value": "implicitCoins.reclaimDeposit + implicitCoins.withdrawals;",
          "isPublic": true,
          "line": 511,
          "raw": "const totalInput = implicitCoins.reclaimDeposit + implicitCoins.withdrawals;",
          "source": "mesh-transaction"
        },
        {
          "name": "CSKDImplicitCoin",
          "type": "any",
          "value": "{",
          "isPublic": true,
          "line": 512,
          "raw": "const CSKDImplicitCoin = {",
          "source": "mesh-transaction"
        },
        {
          "name": "meshActionToCSDKRedeemer",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 525,
          "raw": "const meshActionToCSDKRedeemer = (",
          "source": "mesh-transaction"
        },
        {
          "name": "CSDKRedeemerToMeshAction",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 539,
          "raw": "const CSDKRedeemerToMeshAction = (",
          "source": "mesh-transaction"
        },
        {
          "name": "meshRedeemerTagToCSDKRedeemerTag",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 552,
          "raw": "const meshRedeemerTagToCSDKRedeemerTag = (",
          "source": "mesh-transaction"
        },
        {
          "name": "CSDKRedeemerTagToMeshRedeemerTag",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 571,
          "raw": "const CSDKRedeemerTagToMeshRedeemerTag = (",
          "source": "mesh-transaction"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { Cardano as CSDK, Serialization } from \"@cardano-sdk/core\";\nimport * as CardanoSelection from \"@cardano-sdk/input-selection\";\nimport { HexBlob } from \"@cardano-sdk/util\";\n\nimport {\n  Action,\n  Asset,\n  Output,\n  RedeemerTagType,\n  TxIn,\n  TxOutput,\n  UTxO,\n} from \"@meshsdk/common\";\nimport {\n  fromBuilderToPlutusData,\n  PlutusV1Script,\n  PlutusV2Script,\n  PlutusV3Script,\n  Script,\n  TokenMap,\n} from \"@meshsdk/core-cst\";\n\nimport {\n  BuilderCallbacks,\n  IInputSelector,\n  ImplicitValue,\n  TransactionPrototype,\n} from \"./coin-selection-interface\";\n\n// Fake address used for temporary outputs during coin selection\nconst FAKE_ADDRESS =\n  \"01beffbeffbeffbeffbeffbeffbeffbeffbeffbeffbeffbeffbeffbeefbeffbeffbeffbeffbeffbeffbeffbeffbeffbeffbeffbeffbeffbeef\";\n\nexport class BuilderCallbacksSdkBridge\n  implements CardanoSelection.SelectionConstraints\n{\n  private readonly builderCallback: BuilderCallbacks;\n  private readonly utxoMap: Map<string, UTxO>;\n  private readonly usedUtxos: Set<string>;\n\n  constructor(\n    builderCallbacks: BuilderCallbacks,\n    utxoMap: Map<string, UTxO>,\n    usedUtxos: Set<string>,\n  ) {\n    this.builderCallback = builderCallbacks;\n    this.utxoMap = utxoMap;\n    this.usedUtxos = usedUtxos;\n  }\n\n  computeMinimumCoinQuantity = (output: CSDK.TxOut): CSDK.Lovelace => {\n    return this.builderCallback.computeMinimumCoinQuantity(\n      CSDKOutputToMeshOutput(output),\n    );\n  };\n\n  computeMinimumCost = async (\n    selectionSkeleton: CardanoSelection.SelectionSkeleton,\n  ): Promise<CardanoSelection.TxCosts> => {\n    const costs = await this.builderCallback.computeMinimumCost({\n      newInputs: this.getNewInputs(selectionSkeleton),\n      newOutputs: new Set<TxOutput>(),\n      change: selectionSkeleton.change.map((output) =>\n        CSDKOutputToMeshOutput(output),\n      ),\n      fee: selectionSkeleton.fee,\n    });\n\n    return {\n      fee: costs.fee,\n      redeemers: costs.redeemers?.map(meshActionToCSDKRedeemer),\n    };\n  };\n\n  computeSelectionLimit = async (\n    selectionSkeleton: CardanoSelection.SelectionSkeleton,\n  ): Promise<number> => {\n    const maxSizeExceed = await this.builderCallback.maxSizeExceed({\n      newInputs: this.getNewInputs(selectionSkeleton),\n      newOutputs: new Set<TxOutput>(),\n      change: selectionSkeleton.change.map((output) =>\n        CSDKOutputToMeshOutput(output),\n      ),\n      fee: selectionSkeleton.fee,\n    });\n\n    return maxSizeExceed\n      ? selectionSkeleton.inputs.size - 1\n      : selectionSkeleton.inputs.size + 1;\n  };\n\n  tokenBundleSizeExceedsLimit = (\n    tokenBundle: TokenMap | undefined,\n  ): boolean => {\n    return this.builderCallback.tokenBundleSizeExceedsLimit(\n      CSDKTokenMapToMeshAssets(tokenBundle),\n    );\n  };\n\n  getNewInputs = (\n    selectionSkeleton: CardanoSelection.SelectionSkeleton,\n  ): Set<UTxO> => {\n    const newInputs = new Set<UTxO>();\n\n    for (const input of selectionSkeleton.inputs) {\n      const utxoId = `${input[0].txId}#${input[0].index}`;\n\n      if (this.usedUtxos.has(utxoId)) {\n        continue;\n      }\n\n      const originalUtxo = this.utxoMap.get(utxoId);\n      if (!originalUtxo) {\n        throw new Error(`Missing required UTxO: ${utxoId}`);\n      }\n\n      newInputs.add(originalUtxo);\n    }\n\n    return newInputs;\n  };\n}\n\nexport class CardanoSdkInputSelector implements IInputSelector {\n  private readonly constraints: BuilderCallbacks;\n\n  constructor(constraints: BuilderCallbacks) {\n    this.constraints = constraints;\n  }\n\n  async select(\n    preselectedUtxos: TxIn[],\n    outputs: Output[],\n    implicitValue: ImplicitValue,\n    utxos: UTxO[],\n    changeAddress: string,\n  ): Promise<TransactionPrototype> {\n    // Create a map of UTxOs for quick lookup\n    const utxoMap = new Map<string, UTxO>();\n    for (const utxo of utxos) {\n      utxoMap.set(`${utxo.input.txHash}#${utxo.input.outputIndex}`, utxo);\n    }\n\n    // Aggregate outputs into a single output for selection\n    const aggregatedTxOut = makeAggregatedCSDKOOutput(outputs);\n    const aggregatedOuts = new Set<CSDK.TxOut>();\n    if (aggregatedTxOut) {\n      aggregatedOuts.add(aggregatedTxOut);\n    }\n    // Convert Mesh types to CSDK types\n    const preselectedUtoxsCSDK = new Set(\n      preselectedUtxos.map(meshTxInToCSDKUtxo),\n    );\n    const utxoxCSDK = utxos.map(meshUtxoToCSDKUtxo);\n\n    // Create selector with change address resolver\n    const selector = CardanoSelection.roundRobinRandomImprove({\n      changeAddressResolver: new StaticChangeAddressResolver(changeAddress),\n    });\n\n    // Track used UTxOs\n    const usedUtxos = new Set<string>();\n    for (const utxo of preselectedUtxos) {\n      usedUtxos.add(`${utxo.txIn.txHash}#${utxo.txIn.txIndex}`);\n    }\n    // Create bridge for callbacks\n    const builderCallbacksBridge = new BuilderCallbacksSdkBridge(\n      this.constraints,\n      utxoMap,\n      usedUtxos,\n    );\n\n    // Perform selection\n    const selectResult = await selector.select({\n      preSelectedUtxo: preselectedUtoxsCSDK,\n      utxo: new Set(utxoxCSDK),\n      outputs: aggregatedOuts,\n      constraints: builderCallbacksBridge,\n      implicitValue: meshImplicitCoinToCSDKImplicitCoins(implicitValue),\n    });\n    // Extract newly selected inputs\n    const newInputs = new Set<UTxO>();\n    for (const input of selectResult.selection.inputs) {\n      const utxoId = `${input[0].txId}#${input[0].index}`;\n      if (!usedUtxos.has(utxoId)) {\n        const originalUtxo = utxoMap.get(utxoId);\n        if (!originalUtxo) {\n          throw new Error(`Missing required UTxO: ${utxoId}`);\n        }\n        newInputs.add(originalUtxo);\n      }\n    }\n\n    // Return transaction prototype\n    return {\n      newInputs,\n      newOutputs: new Set(),\n      change: selectResult.selection.change.map(CSDKOutputToMeshOutput),\n      fee: selectResult.selection.fee,\n      redeemers: selectResult.redeemers?.map(CSDKRedeemerToMeshAction),\n    };\n  }\n}\n\nexport class StaticChangeAddressResolver\n  implements CardanoSelection.ChangeAddressResolver\n{\n  readonly changeAddress: string;\n\n  constructor(changeAddress: string) {\n    this.changeAddress = changeAddress;\n  }\n\n  resolve = async (\n    selection: CardanoSelection.Selection,\n  ): Promise<Array<CSDK.TxOut>> => {\n    return selection.change.map((txOut) => ({\n      ...txOut,\n      address: <CSDK.PaymentAddress>this.changeAddress,\n    }));\n  };\n}\n\nconst meshTxInToCSDKUtxo = (txIn: TxIn): CSDK.Utxo => {\n  return [\n    {\n      txId: <CSDK.TransactionId>txIn.txIn.txHash,\n      index: txIn.txIn.txIndex,\n      address: <CSDK.PaymentAddress>txIn.txIn.address,\n    },\n    {\n      address: <CSDK.PaymentAddress>txIn.txIn.address,\n      value: meshAssetsToCSDKValue(txIn.txIn.amount),\n    },\n  ];\n};\n\nconst meshUtxoToCSDKUtxo = (utxo: UTxO): CSDK.Utxo => {\n  return [\n    {\n      txId: <CSDK.TransactionId>utxo.input.txHash,\n      index: utxo.input.outputIndex,\n      address: <CSDK.PaymentAddress>utxo.output.address,\n    },\n    {\n      address: <CSDK.PaymentAddress>utxo.output.address,\n      value: meshAssetsToCSDKValue(utxo.output.amount),\n      datumHash: meshDataHashToCSDKDataHash(utxo.output.dataHash),\n      datum: meshDatumToCSDKDatum(utxo.output.plutusData),\n      scriptReference: meshScriptReferenceToCSDKScriptReference(\n        utxo.output.scriptRef,\n      ),\n    },\n  ];\n};\n\nconst meshScriptReferenceToCSDKScriptReference = (\n  scriptReference?: string,\n): CSDK.Script | undefined => {\n  if (!scriptReference) {\n    return undefined;\n  }\n\n  return Serialization.Script.fromCbor(<HexBlob>scriptReference).toCore();\n};\n\nconst meshDatumToCSDKDatum = (datum?: string): CSDK.PlutusData | undefined => {\n  if (!datum) {\n    return undefined;\n  }\n\n  return Serialization.PlutusData.fromCbor(<HexBlob>datum).toCore();\n};\n\nconst meshDataHashToCSDKDataHash = (\n  hash?: string,\n): CSDK.DatumHash | undefined => {\n  if (!hash) {\n    return undefined;\n  }\n  return <CSDK.DatumHash>hash;\n};\n\nconst meshAssetsToCSDKValue = (assets?: Asset[]): CSDK.Value => {\n  if (!assets) {\n    throw new Error(\n      \"Missing required assets. Be sure that you resolve all required UTxOs\",\n    );\n  }\n\n  let lovelace = 0n;\n  const sdkAssets = new Map<CSDK.AssetId, bigint>();\n\n  for (const asset of assets) {\n    if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n      lovelace = BigInt(asset.quantity);\n    } else {\n      const assetId = <CSDK.AssetId>asset.unit;\n      sdkAssets.set(assetId, BigInt(asset.quantity));\n    }\n  }\n\n  if (sdkAssets.size === 0) {\n    return { coins: lovelace };\n  }\n\n  return {\n    coins: lovelace,\n    assets: sdkAssets,\n  };\n};\n\nconst meshAssetsToCSDKAssets = (\n  assets?: Asset[],\n): CSDK.TokenMap | undefined => {\n  if (!assets) {\n    return undefined;\n  }\n\n  const sdkAssets = new Map<CSDK.AssetId, bigint>();\n\n  for (const asset of assets) {\n    if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n      throw new Error(\"Unexpected lovelace asset in assets\");\n    } else {\n      const assetId = <CSDK.AssetId>asset.unit;\n      sdkAssets.set(assetId, BigInt(asset.quantity));\n    }\n  }\n\n  return sdkAssets;\n};\n\nconst CSDKOutputToMeshOutput = (output: CSDK.TxOut): TxOutput => {\n  const amount = CSDKValueToMeshAssets(output.value);\n  return {\n    address: output.address,\n    amount: amount,\n  };\n};\n\nconst CSDKValueToMeshAssets = (value: CSDK.Value): Asset[] => {\n  const assets: Asset[] = [];\n\n  if (value.coins !== 0n) {\n    assets.push({\n      unit: \"lovelace\",\n      quantity: value.coins.toString(),\n    });\n  }\n\n  if (value.assets) {\n    for (const [assetId, quantity] of value.assets) {\n      assets.push({\n        unit: assetId,\n        quantity: quantity.toString(),\n      });\n    }\n  }\n\n  return assets;\n};\n\nconst CSDKTokenMapToMeshAssets = (\n  tokenMap?: CSDK.TokenMap,\n): Asset[] | undefined => {\n  if (!tokenMap) {\n    return undefined;\n  }\n\n  const assets: Asset[] = [];\n\n  for (const [assetId, quantity] of tokenMap) {\n    assets.push({\n      unit: assetId,\n      quantity: quantity.toString(),\n    });\n  }\n\n  return assets;\n};\n\nconst meshOutputToCSDKOutput = (output: Output): CSDK.TxOut => {\n  const { dataHash, datum, scriptReference } =\n    meshOutputToCSDKOutputsScriptData(output);\n\n  return {\n    address: <CSDK.PaymentAddress>output.address,\n    value: meshAssetsToCSDKValue(output.amount),\n    datumHash: dataHash,\n    datum: datum,\n    scriptReference: scriptReference,\n  };\n};\n\nconst makeAggregatedCSDKOOutput = (\n  outputs: Output[],\n): CSDK.TxOut | undefined => {\n  let totalAssets = new Map<string, bigint>();\n\n  for (const output of outputs) {\n    totalAssets = sumAssets(totalAssets, output.amount);\n  }\n\n  if (totalAssets.size === 0) {\n    return undefined;\n  }\n\n  return {\n    address: <CSDK.PaymentAddress>FAKE_ADDRESS,\n    value: assetsMapToCSDKValue(totalAssets),\n  };\n};\n\nconst meshOutputToCSDKOutputsScriptData = (\n  output: Output,\n): {\n  dataHash?: CSDK.DatumHash;\n  datum?: CSDK.PlutusData;\n  scriptReference?: CSDK.Script;\n} => {\n  let dataHash: CSDK.DatumHash | undefined = undefined;\n  let datum: CSDK.PlutusData | undefined = undefined;\n  let scriptReference: CSDK.Script | undefined;\n\n  if (output.datum?.type === \"Hash\") {\n    dataHash = meshDataHashToCSDKDataHash(\n      HexBlob(fromBuilderToPlutusData(output.datum.data).hash()),\n    );\n  } else if (output.datum?.type === \"Inline\") {\n    datum = meshDatumToCSDKDatum(\n      fromBuilderToPlutusData(output.datum.data).toCbor(),\n    );\n  } else if (output.datum?.type === \"Embedded\") {\n    throw new Error(\"Embedded datum is not supported\");\n  }\n\n  let meshCoreScript = undefined;\n  if (output.referenceScript) {\n    switch (output.referenceScript.version) {\n      case \"V1\": {\n        meshCoreScript = Script.newPlutusV1Script(\n          PlutusV1Script.fromCbor(HexBlob(output.referenceScript.code)),\n        );\n        break;\n      }\n      case \"V2\": {\n        meshCoreScript = Script.newPlutusV2Script(\n          PlutusV2Script.fromCbor(HexBlob(output.referenceScript.code)),\n        );\n        break;\n      }\n      case \"V3\": {\n        meshCoreScript = Script.newPlutusV3Script(\n          PlutusV3Script.fromCbor(HexBlob(output.referenceScript.code)),\n        );\n        break;\n      }\n    }\n  }\n\n  scriptReference = meshScriptReferenceToCSDKScriptReference(\n    meshCoreScript?.toCbor(),\n  );\n\n  return {\n    dataHash,\n    datum,\n    scriptReference,\n  };\n};\n\nconst assetsMapToCSDKValue = (assets: Map<string, bigint>): CSDK.Value => {\n  let lovelace = 0n;\n  const sdkAssets = new Map<CSDK.AssetId, bigint>();\n\n  for (const [unit, quantity] of assets) {\n    if (unit === \"lovelace\" || unit === \"\") {\n      lovelace = BigInt(quantity);\n    } else {\n      const assetId = <CSDK.AssetId>unit;\n      sdkAssets.set(assetId, BigInt(quantity));\n    }\n  }\n\n  if (sdkAssets.size === 0) {\n    return { coins: lovelace };\n  }\n\n  return {\n    coins: lovelace,\n    assets: sdkAssets,\n  };\n};\n\nconst sumAssets = (a: Map<string, bigint>, b: Asset[]): Map<string, bigint> => {\n  for (const asset of b) {\n    const currentAmount = a.get(asset.unit) ?? 0n;\n    a.set(asset.unit, currentAmount + BigInt(asset.quantity));\n  }\n  return a;\n};\n\nconst meshImplicitCoinToCSDKImplicitCoins = (\n  implicitCoins?: ImplicitValue,\n): CardanoSelection.ImplicitValue | undefined => {\n  if (!implicitCoins) {\n    return undefined;\n  }\n  const mint = meshAssetsToCSDKAssets(implicitCoins.mint);\n  const totalInput = implicitCoins.reclaimDeposit + implicitCoins.withdrawals;\n  const CSKDImplicitCoin = {\n    withdrawals: implicitCoins.withdrawals,\n    input: totalInput,\n    deposit: implicitCoins.deposit,\n    reclaimDeposit: implicitCoins.reclaimDeposit,\n  };\n\n  return {\n    coin: CSKDImplicitCoin,\n    mint: mint,\n  };\n};\n\nconst meshActionToCSDKRedeemer = (\n  action: Omit<Action, \"data\">,\n): CSDK.Redeemer => {\n  return {\n    purpose: meshRedeemerTagToCSDKRedeemerTag(action.tag),\n    index: action.index,\n    executionUnits: {\n      steps: action.budget.steps,\n      memory: action.budget.mem,\n    },\n    data: 0n,\n  };\n};\n\nconst CSDKRedeemerToMeshAction = (\n  redeemer: CSDK.Redeemer,\n): Omit<Action, \"data\"> => {\n  return {\n    tag: CSDKRedeemerTagToMeshRedeemerTag(redeemer.purpose),\n    index: redeemer.index,\n    budget: {\n      steps: redeemer.executionUnits.steps,\n      mem: redeemer.executionUnits.memory,\n    },\n  };\n};\n\nconst meshRedeemerTagToCSDKRedeemerTag = (\n  tag: RedeemerTagType,\n): CSDK.RedeemerPurpose => {\n  switch (tag) {\n    case \"SPEND\":\n      return CSDK.RedeemerPurpose.spend;\n    case \"MINT\":\n      return CSDK.RedeemerPurpose.mint;\n    case \"CERT\":\n      return CSDK.RedeemerPurpose.certificate;\n    case \"REWARD\":\n      return CSDK.RedeemerPurpose.withdrawal;\n    case \"PROPOSE\":\n      return CSDK.RedeemerPurpose.propose;\n    case \"VOTE\":\n      return CSDK.RedeemerPurpose.vote;\n  }\n};\n\nconst CSDKRedeemerTagToMeshRedeemerTag = (\n  tag: CSDK.RedeemerPurpose,\n): RedeemerTagType => {\n  switch (tag) {\n    case CSDK.RedeemerPurpose.spend:\n      return \"SPEND\";\n    case CSDK.RedeemerPurpose.mint:\n      return \"MINT\";\n    case CSDK.RedeemerPurpose.certificate:\n      return \"CERT\";\n    case CSDK.RedeemerPurpose.withdrawal:\n      return \"REWARD\";\n    case CSDK.RedeemerPurpose.propose:\n      return \"PROPOSE\";\n    case CSDK.RedeemerPurpose.vote:\n      return \"VOTE\";\n  }\n};\n",
      "dependencies": [
        "BuilderCallbacksSdkBridge",
        "CardanoSdkInputSelector",
        "StaticChangeAddressResolver"
      ],
      "source": "mesh-transaction",
      "isReExportFile": false
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.coin-selection-interface.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface.ts",
      "name": "mesh-tx-builder.coin-selection.coin-selection-interface.ts",
      "imports": [
        {
          "module": "TransactionPrototype",
          "items": [],
          "line": 10,
          "raw": "export interface TransactionPrototype {",
          "source": "mesh-transaction"
        },
        {
          "module": "ImplicitValue",
          "items": [],
          "line": 18,
          "raw": "export interface ImplicitValue {",
          "source": "mesh-transaction"
        },
        {
          "module": "TransactionCost",
          "items": [],
          "line": 25,
          "raw": "export interface TransactionCost {",
          "source": "mesh-transaction"
        },
        {
          "module": "BuilderCallbacks",
          "items": [],
          "line": 41,
          "raw": "export interface BuilderCallbacks {",
          "source": "mesh-transaction"
        },
        {
          "module": "IInputSelector",
          "items": [],
          "line": 48,
          "raw": "export interface IInputSelector {",
          "source": "mesh-transaction"
        }
      ],
      "functions": [],
      "types": [
        {
          "name": "TransactionPrototype",
          "definition": "export interface TransactionPrototype {\n  newInputs: Set<UTxO>;",
          "isPublic": true,
          "line": 10,
          "raw": "export interface TransactionPrototype {",
          "source": "mesh-transaction"
        },
        {
          "name": "ImplicitValue",
          "definition": "export interface ImplicitValue {\n  withdrawals: bigint;",
          "isPublic": true,
          "line": 18,
          "raw": "export interface ImplicitValue {",
          "source": "mesh-transaction"
        },
        {
          "name": "TransactionCost",
          "definition": "export interface TransactionCost {\n  fee: bigint;",
          "isPublic": true,
          "line": 25,
          "raw": "export interface TransactionCost {",
          "source": "mesh-transaction"
        },
        {
          "name": "BuilderCallbacks",
          "definition": "export interface BuilderCallbacks {\n  computeMinimumCost: EstimateTxCosts;",
          "isPublic": true,
          "line": 41,
          "raw": "export interface BuilderCallbacks {",
          "source": "mesh-transaction"
        },
        {
          "name": "IInputSelector",
          "definition": "export interface IInputSelector {\n  select: (\n    preselectedUtoxs: TxIn[],\n    outputs: Output[],\n    implicitValue: ImplicitValue,\n    utxos: UTxO[],\n    changeAddress: string,\n  ) => Promise<TransactionPrototype>;\n}",
          "isPublic": true,
          "line": 48,
          "raw": "export interface IInputSelector {",
          "source": "mesh-transaction"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  Action,\n  Asset,\n  Output,\n  TxIn,\n  TxOutput,\n  UTxO,\n} from '@meshsdk/common';\n\nexport interface TransactionPrototype {\n  newInputs: Set<UTxO>;\n  newOutputs: Set<TxOutput>;\n  change: Array<TxOutput>;\n  fee: bigint;\n  redeemers?: Array<Omit<Action, 'data'>>;\n}\n\nexport interface ImplicitValue {\n  withdrawals: bigint;\n  deposit: bigint;\n  reclaimDeposit: bigint;\n  mint: Asset[];\n}\n\nexport interface TransactionCost {\n  fee: bigint;\n  redeemers?: Array<Omit<Action, 'data'>>;\n}\n\nexport declare type EstimateTxCosts = (\n  selectionSkeleton: TransactionPrototype,\n) => Promise<TransactionCost>;\nexport declare type TokenBundleSizeExceedsLimit = (\n  tokenBundle?: Asset[],\n) => boolean;\nexport declare type ComputeMinimumCoinQuantity = (output: TxOutput) => bigint;\nexport declare type MaxSizeExceed = (\n  selectionSkeleton: TransactionPrototype,\n) => Promise<boolean>;\n\nexport interface BuilderCallbacks {\n  computeMinimumCost: EstimateTxCosts;\n  tokenBundleSizeExceedsLimit: TokenBundleSizeExceedsLimit;\n  computeMinimumCoinQuantity: ComputeMinimumCoinQuantity;\n  maxSizeExceed: MaxSizeExceed;\n}\n\nexport interface IInputSelector {\n  select: (\n    preselectedUtoxs: TxIn[],\n    outputs: Output[],\n    implicitValue: ImplicitValue,\n    utxos: UTxO[],\n    changeAddress: string,\n  ) => Promise<TransactionPrototype>;\n}\n",
      "dependencies": [
        "TransactionPrototype",
        "ImplicitValue",
        "TransactionCost",
        "BuilderCallbacks",
        "IInputSelector"
      ],
      "source": "mesh-transaction",
      "isReExportFile": false
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/index.ts",
      "name": "mesh-tx-builder.coin-selection.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  BuilderCallbacksSdkBridge,\n  CardanoSdkInputSelector,\n} from './cardano-sdk-adapter';\nimport * as CoinSelectionInterface from './coin-selection-interface';\n\nexport {\n  BuilderCallbacksSdkBridge,\n  CardanoSdkInputSelector,\n  CoinSelectionInterface,\n};\n",
      "dependencies": [],
      "source": "mesh-transaction",
      "isReExportFile": false
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/index.ts",
      "name": "mesh-tx-builder.index.ts",
      "imports": [
        {
          "module": "MeshTxBuilderOptions",
          "items": [],
          "line": 49,
          "raw": "export interface MeshTxBuilderOptions {",
          "source": "mesh-transaction"
        },
        {
          "module": "MeshTxBuilder",
          "items": [],
          "line": 59,
          "raw": "export class MeshTxBuilder extends MeshTxBuilderCore {",
          "source": "mesh-transaction"
        },
        {
          "module": "cloneOutput",
          "items": [],
          "line": 1799,
          "raw": "export const cloneOutput = (output: Output): Output => {",
          "source": "mesh-transaction"
        },
        {
          "module": "setLoveLace",
          "items": [],
          "line": 1803,
          "raw": "export const setLoveLace = (output: Output, lovelace: bigint): Output => {",
          "source": "mesh-transaction"
        },
        {
          "module": "getLovelace",
          "items": [],
          "line": 1822,
          "raw": "export const getLovelace = (output: Output): bigint => {",
          "source": "mesh-transaction"
        },
        {
          "module": "getOutputMinLovelace",
          "items": [],
          "line": 1831,
          "raw": "export const getOutputMinLovelace = (",
          "source": "mesh-transaction"
        }
      ],
      "functions": [
        {
          "name": "serializeMockTx",
          "signature": "serializeMockTx = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 101,
          "raw": "  serializeMockTx = () => {\n    const builderBody = this.meshTxBuilderBody;\n    const { keyHashes, byronAddresses } = this.collectAllRequiredSignatures();\n    builderBody.expectedNumberKeyWitnesses = keyHashes.size;\n    builderBody.expectedByronAddressWitnesses = Array.from(byronAddresses);\n    return this.serializer.serializeTxBodyWithMockSignatures(\n      this.meshTxBuilderBody,\n      this._protocolParams,\n    );\n  };",
          "source": "mesh-transaction",
          "implementation": "  serializeMockTx = () => {\n    const builderBody = this.meshTxBuilderBody;\n    const { keyHashes, byronAddresses } = this.collectAllRequiredSignatures();\n    builderBody.expectedNumberKeyWitnesses = keyHashes.size;\n    builderBody.expectedByronAddressWitnesses = Array.from(byronAddresses);\n    return this.serializer.serializeTxBodyWithMockSignatures(\n      this.meshTxBuilderBody,\n      this._protocolParams,\n    );\n  };"
        },
        {
          "name": "completeSync",
          "signature": "completeSync = (customizedTx?: MeshTxBuilderBody) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "customizedTx",
              "type": "MeshTxBuilderBody",
              "optional": true
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 131,
          "raw": "  completeSync = (customizedTx?: MeshTxBuilderBody) => {\n    if (customizedTx) {\n      this.meshTxBuilderBody = customizedTx;\n    } else {\n      this.queueAllLastItem();\n    }\n    this.removeDuplicateInputs();\n    this.removeDuplicateRefInputs();\n    this.addUtxosFromSelection();\n    return this.serializer.serializeTxBody(\n      this.meshTxBuilderBody,\n      this._protocolParams,\n    );\n  };",
          "source": "mesh-transaction",
          "implementation": "  completeSync = (customizedTx?: MeshTxBuilderBody) => {\n    if (customizedTx) {\n      this.meshTxBuilderBody = customizedTx;\n    } else {\n      this.queueAllLastItem();\n    }\n    this.removeDuplicateInputs();\n    this.removeDuplicateRefInputs();\n    this.addUtxosFromSelection();\n    return this.serializer.serializeTxBody(\n      this.meshTxBuilderBody,\n      this._protocolParams,\n    );\n  };"
        },
        {
          "name": "async",
          "signature": "async (): Promise<CoinSelectionInterface.TransactionPrototype> => {",
          "documentation": "",
          "parameters": [],
          "returnType": "Promise<CoinSelectionInterface.TransactionPrototype>",
          "isPublic": true,
          "line": 205,
          "raw": "    async (): Promise<CoinSelectionInterface.TransactionPrototype> => {\n      const callbacks: CoinSelectionInterface.BuilderCallbacks = {\n        computeMinimumCost: async (\n          selectionSkeleton: TransactionPrototype,\n        ): Promise<TransactionCost> => {\n          const clonedBuilder = this.clone();\n          await clonedBuilder.updateByTxPrototype(selectionSkeleton);\n\n          try {\n            await clonedBuilder.evaluateRedeemers();\n          } catch (error) {\n            if (error instanceof Error) {\n              throw new Error(`Evaluate redeemers failed: ${error.message}`);\n            } else if (typeof error === \"string\") {\n              throw new Error(`Evaluate redeemers failed: ${error}`);\n            } else if (typeof error === \"object\") {\n              throw new Error(\n                `Evaluate redeemers failed: ${JSON.stringify(error)}`,\n              );\n            } else {\n              throw new Error(`Evaluate redeemers failed: ${String(error)}`);\n            }\n          }\n          const fee = clonedBuilder.getActualFee();\n          const redeemers = clonedBuilder.getRedeemerCosts();\n          return {\n            fee,\n            redeemers,\n          };\n        },\n        tokenBundleSizeExceedsLimit: (tokenBundle) => {\n          const maxValueSize = this._protocolParams.maxValSize;\n          if (tokenBundle) {\n            const valueSize =\n              this.serializer.serializeValue(tokenBundle).length / 2;\n            return valueSize > maxValueSize;\n          }\n          return false;\n        },\n        computeMinimumCoinQuantity: (output) => {\n          return this.calculateMinLovelaceForOutput(output);\n        },\n        maxSizeExceed: async (selectionSkeleton) => {\n          const clonedBuilder = this.clone();\n          await clonedBuilder.updateByTxPrototype(selectionSkeleton);\n          const maxTxSize = this._protocolParams.maxTxSize;\n          const txSize = clonedBuilder.getSerializedSize();\n          return txSize > maxTxSize;\n        },\n      };\n\n      const currentInputs = this.meshTxBuilderBody.inputs;\n      const currentOutputs = this.meshTxBuilderBody.outputs;\n      const changeAddress = this.meshTxBuilderBody.changeAddress;\n      const utxosForSelection = await this.getUtxosForSelection();\n      const implicitValue = {\n        withdrawals: this.getTotalWithdrawal(),\n        deposit: this.getTotalDeposit(),\n        reclaimDeposit: this.getTotalRefund(),\n        mint: this.getTotalMint(),\n      };\n\n      const inputSelector = new CardanoSdkInputSelector(callbacks);\n      return await inputSelector.select(\n        currentInputs,\n        currentOutputs,\n        implicitValue,\n        utxosForSelection,\n        changeAddress,\n      );\n    };",
          "source": "mesh-transaction",
          "implementation": "    async (): Promise<CoinSelectionInterface.TransactionPrototype> => {\n      const callbacks: CoinSelectionInterface.BuilderCallbacks = {\n        computeMinimumCost: async (\n          selectionSkeleton: TransactionPrototype,\n        ): Promise<TransactionCost> => {\n          const clonedBuilder = this.clone();\n          await clonedBuilder.updateByTxPrototype(selectionSkeleton);\n\n          try {\n            await clonedBuilder.evaluateRedeemers();\n          } catch (error) {\n            if (error instanceof Error) {\n              throw new Error(`Evaluate redeemers failed: ${error.message}`);\n            } else if (typeof error === \"string\") {\n              throw new Error(`Evaluate redeemers failed: ${error}`);\n            } else if (typeof error === \"object\") {\n              throw new Error(\n                `Evaluate redeemers failed: ${JSON.stringify(error)}`,\n              );\n            } else {\n              throw new Error(`Evaluate redeemers failed: ${String(error)}`);\n            }\n          }\n          const fee = clonedBuilder.getActualFee();\n          const redeemers = clonedBuilder.getRedeemerCosts();\n          return {\n            fee,\n            redeemers,\n          };\n        },\n        tokenBundleSizeExceedsLimit: (tokenBundle) => {\n          const maxValueSize = this._protocolParams.maxValSize;\n          if (tokenBundle) {\n            const valueSize =\n              this.serializer.serializeValue(tokenBundle).length / 2;\n            return valueSize > maxValueSize;\n          }\n          return false;\n        },\n        computeMinimumCoinQuantity: (output) => {\n          return this.calculateMinLovelaceForOutput(output);\n        },\n        maxSizeExceed: async (selectionSkeleton) => {\n          const clonedBuilder = this.clone();\n          await clonedBuilder.updateByTxPrototype(selectionSkeleton);\n          const maxTxSize = this._protocolParams.maxTxSize;\n          const txSize = clonedBuilder.getSerializedSize();\n          return txSize > maxTxSize;\n        },\n      };\n\n      const currentInputs = this.meshTxBuilderBody.inputs;\n      const currentOutputs = this.meshTxBuilderBody.outputs;\n      const changeAddress = this.meshTxBuilderBody.changeAddress;\n      const utxosForSelection = await this.getUtxosForSelection();\n      const implicitValue = {\n        withdrawals: this.getTotalWithdrawal(),\n        deposit: this.getTotalDeposit(),\n        reclaimDeposit: this.getTotalRefund(),\n        mint: this.getTotalMint(),\n      };\n\n      const inputSelector = new CardanoSdkInputSelector(callbacks);\n      return await inputSelector.select(\n        currentInputs,\n        currentOutputs,\n        implicitValue,\n        utxosForSelection,\n        changeAddress,\n      );\n    };"
        },
        {
          "name": "sortTxParts",
          "signature": "sortTxParts = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 322,
          "raw": "  sortTxParts = () => {\n    this.sortInputs();\n    this.sortMints();\n    this.sortWithdrawals();\n    this.sortVotes();\n  };",
          "source": "mesh-transaction",
          "implementation": "  sortTxParts = () => {\n    this.sortInputs();\n    this.sortMints();\n    this.sortWithdrawals();\n    this.sortVotes();\n  };"
        },
        {
          "name": "sortInputs",
          "signature": "sortInputs = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 329,
          "raw": "  sortInputs = () => {\n    // Sort inputs based on txHash and txIndex\n    this.meshTxBuilderBody.inputs.sort((a, b) => {\n      if (a.txIn.txHash < b.txIn.txHash) return -1;\n      if (a.txIn.txHash > b.txIn.txHash) return 1;\n      if (a.txIn.txIndex < b.txIn.txIndex) return -1;\n      if (a.txIn.txIndex > b.txIn.txIndex) return 1;\n      return 0;\n    });\n  };",
          "source": "mesh-transaction",
          "implementation": "  sortInputs = () => {\n    // Sort inputs based on txHash and txIndex\n    this.meshTxBuilderBody.inputs.sort((a, b) => {\n      if (a.txIn.txHash < b.txIn.txHash) return -1;\n      if (a.txIn.txHash > b.txIn.txHash) return 1;\n      if (a.txIn.txIndex < b.txIn.txIndex) return -1;\n      if (a.txIn.txIndex > b.txIn.txIndex) return 1;\n      return 0;\n    });\n  };"
        },
        {
          "name": "sortMints",
          "signature": "sortMints = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 340,
          "raw": "  sortMints = () => {\n    // Sort mints based on policy id\n    this.meshTxBuilderBody.mints.sort((a, b) => {\n      if (a.policyId < b.policyId) return -1;\n      if (a.policyId > b.policyId) return 1;\n      return 0;\n    });\n  };",
          "source": "mesh-transaction",
          "implementation": "  sortMints = () => {\n    // Sort mints based on policy id\n    this.meshTxBuilderBody.mints.sort((a, b) => {\n      if (a.policyId < b.policyId) return -1;\n      if (a.policyId > b.policyId) return 1;\n      return 0;\n    });\n  };"
        },
        {
          "name": "sortWithdrawals",
          "signature": "sortWithdrawals = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 375,
          "raw": "  sortWithdrawals = () => {\n    this.meshTxBuilderBody.withdrawals.sort((a, b) => {\n      const credentialA = CstAddress.fromString(a.address)\n        ?.asReward()\n        ?.getPaymentCredential();\n      const credentialB = CstAddress.fromString(b.address)\n        ?.asReward()\n        ?.getPaymentCredential();\n      if (credentialA && credentialB) {\n        return this.compareCredentials(credentialA, credentialB);\n      }\n      return 0;\n    });\n  };",
          "source": "mesh-transaction",
          "implementation": "  sortWithdrawals = () => {\n    this.meshTxBuilderBody.withdrawals.sort((a, b) => {\n      const credentialA = CstAddress.fromString(a.address)\n        ?.asReward()\n        ?.getPaymentCredential();\n      const credentialB = CstAddress.fromString(b.address)\n        ?.asReward()\n        ?.getPaymentCredential();\n      if (credentialA && credentialB) {\n        return this.compareCredentials(credentialA, credentialB);\n      }\n      return 0;\n    });\n  };"
        },
        {
          "name": "sortVotes",
          "signature": "sortVotes = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 390,
          "raw": "  sortVotes = () => {\n    const variantOrder: Record<Voter[\"type\"], number> = {\n      ConstitutionalCommittee: 0,\n      DRep: 1,\n      StakingPool: 2,\n    };\n    this.meshTxBuilderBody.votes.sort((a, b) => {\n      const voterA = a.vote.voter;\n      const voterB = b.vote.voter;\n      const orderA = variantOrder[voterA.type];\n      const orderB = variantOrder[voterB.type];\n      if (orderA !== orderB) return orderA - orderB;\n\n      // Same variant, compare inner values\n      if (\n        voterA.type === \"ConstitutionalCommittee\" &&\n        voterB.type === \"ConstitutionalCommittee\"\n      ) {\n        const credA = voterA.hotCred;\n        const credB = voterB.hotCred;\n        // Script credentials come before Key credentials\n        if (credA.type === \"ScriptHash\" && credB.type === \"KeyHash\") {\n          return -1;\n        }\n        if (credA.type === \"KeyHash\" && credB.type === \"ScriptHash\") {\n          return 1;\n        }\n        // If same type, compare the hashes\n        if (credA.type === credB.type) {\n          const hashA =\n            credA.type === \"KeyHash\" ? credA.keyHash : credA.scriptHash;\n          const hashB =\n            credB.type === \"KeyHash\" ? credB.keyHash : credB.scriptHash;\n          if (hashA < hashB) return -1;\n          if (hashA > hashB) return 1;\n          return 0;\n        }\n        return 0;\n      }\n      if (voterA.type === \"DRep\" && voterB.type === \"DRep\") {\n        const drepA = coreToCstDRep(voterA.drepId);\n        const drepB = coreToCstDRep(voterB.drepId);\n        const scriptHashA = drepA.toScriptHash();\n        const scriptHashB = drepB.toScriptHash();\n        const keyHashA = drepA.toKeyHash();\n        const keyHashB = drepB.toKeyHash();\n\n        // Script hashes come before key hashes\n        if (scriptHashA != null && scriptHashB != null) {\n          if (scriptHashA < scriptHashB) return -1;\n          if (scriptHashA > scriptHashB) return 1;\n          return 0;\n        }\n        if (scriptHashA != null) return -1;\n        if (scriptHashB != null) return 1;\n        // If both are key hashes, compare them\n        if (keyHashA != null && keyHashB != null) {\n          if (keyHashA < keyHashB) return -1;\n          if (keyHashA > keyHashB) return 1;\n          return 0;\n        }\n        return 0;\n      }\n      if (voterA.type === \"StakingPool\" && voterB.type === \"StakingPool\") {\n        if (voterA.keyHash < voterB.keyHash) return -1;\n        if (voterA.keyHash > voterB.keyHash) return 1;\n        return 0;\n      }\n      return 0;\n    });\n  };",
          "source": "mesh-transaction",
          "implementation": "  sortVotes = () => {\n    const variantOrder: Record<Voter[\"type\"], number> = {\n      ConstitutionalCommittee: 0,\n      DRep: 1,\n      StakingPool: 2,\n    };\n    this.meshTxBuilderBody.votes.sort((a, b) => {\n      const voterA = a.vote.voter;\n      const voterB = b.vote.voter;\n      const orderA = variantOrder[voterA.type];\n      const orderB = variantOrder[voterB.type];\n      if (orderA !== orderB) return orderA - orderB;\n\n      // Same variant, compare inner values\n      if (\n        voterA.type === \"ConstitutionalCommittee\" &&\n        voterB.type === \"ConstitutionalCommittee\"\n      ) {\n        const credA = voterA.hotCred;\n        const credB = voterB.hotCred;\n        // Script credentials come before Key credentials\n        if (credA.type === \"ScriptHash\" && credB.type === \"KeyHash\") {\n          return -1;\n        }\n        if (credA.type === \"KeyHash\" && credB.type === \"ScriptHash\") {\n          return 1;\n        }\n        // If same type, compare the hashes\n        if (credA.type === credB.type) {\n          const hashA =\n            credA.type === \"KeyHash\" ? credA.keyHash : credA.scriptHash;\n          const hashB =\n            credB.type === \"KeyHash\" ? credB.keyHash : credB.scriptHash;\n          if (hashA < hashB) return -1;\n          if (hashA > hashB) return 1;\n          return 0;\n        }\n        return 0;\n      }\n      if (voterA.type === \"DRep\" && voterB.type === \"DRep\") {\n        const drepA = coreToCstDRep(voterA.drepId);\n        const drepB = coreToCstDRep(voterB.drepId);\n        const scriptHashA = drepA.toScriptHash();\n        const scriptHashB = drepB.toScriptHash();\n        const keyHashA = drepA.toKeyHash();\n        const keyHashB = drepB.toKeyHash();\n\n        // Script hashes come before key hashes\n        if (scriptHashA != null && scriptHashB != null) {\n          if (scriptHashA < scriptHashB) return -1;\n          if (scriptHashA > scriptHashB) return 1;\n          return 0;\n        }\n        if (scriptHashA != null) return -1;\n        if (scriptHashB != null) return 1;\n        // If both are key hashes, compare them\n        if (keyHashA != null && keyHashB != null) {\n          if (keyHashA < keyHashB) return -1;\n          if (keyHashA > keyHashB) return 1;\n          return 0;\n        }\n        return 0;\n      }\n      if (voterA.type === \"StakingPool\" && voterB.type === \"StakingPool\") {\n        if (voterA.keyHash < voterB.keyHash) return -1;\n        if (voterA.keyHash > voterB.keyHash) return 1;\n        return 0;\n      }\n      return 0;\n    });\n  };"
        },
        {
          "name": "completeUnbalancedSync",
          "signature": "completeUnbalancedSync = (customizedTx?: MeshTxBuilderBody) => {",
          "documentation": "  /**\n   * It builds the transaction without dependencies\n   * @param customizedTx The optional customized transaction body\n   * @returns The transaction in hex, unbalanced\n   */",
          "parameters": [
            {
              "name": "customizedTx",
              "type": "MeshTxBuilderBody",
              "optional": true
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 558,
          "raw": "  /**\n   * It builds the transaction without dependencies\n   * @param customizedTx The optional customized transaction body\n   * @returns The transaction in hex, unbalanced\n   */\n  completeUnbalancedSync = (customizedTx?: MeshTxBuilderBody) => {\n    if (customizedTx) {\n      this.meshTxBuilderBody = customizedTx;\n      if (customizedTx.fee) {\n        this.setFee(customizedTx.fee);\n      }\n    } else {\n      this.queueAllLastItem();\n    }\n    this.removeDuplicateInputs();\n    this.removeDuplicateRefInputs();\n    return this.serializer.serializeTxBody(\n      this.meshTxBuilderBody,\n      this._protocolParams,\n    );\n  };",
          "source": "mesh-transaction",
          "implementation": "  completeUnbalancedSync = (customizedTx?: MeshTxBuilderBody) => {\n    if (customizedTx) {\n      this.meshTxBuilderBody = customizedTx;\n      if (customizedTx.fee) {\n        this.setFee(customizedTx.fee);\n      }\n    } else {\n      this.queueAllLastItem();\n    }\n    this.removeDuplicateInputs();\n    this.removeDuplicateRefInputs();\n    return this.serializer.serializeTxBody(\n      this.meshTxBuilderBody,\n      this._protocolParams,\n    );\n  };"
        },
        {
          "name": "completeSigning",
          "signature": "completeSigning = () => {",
          "documentation": "  /**\n   * Complete the signing process\n   * @returns The signed transaction in hex\n   */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 579,
          "raw": "  /**\n   * Complete the signing process\n   * @returns The signed transaction in hex\n   */\n  completeSigning = () => {\n    const signedTxHex = this.serializer.addSigningKeys(\n      this.txHex,\n      this.meshTxBuilderBody.signingKey,\n    );\n    this.txHex = signedTxHex;\n    return signedTxHex;\n  };",
          "source": "mesh-transaction",
          "implementation": "  completeSigning = () => {\n    const signedTxHex = this.serializer.addSigningKeys(\n      this.txHex,\n      this.meshTxBuilderBody.signingKey,\n    );\n    this.txHex = signedTxHex;\n    return signedTxHex;\n  };"
        },
        {
          "name": "minRefScriptFee",
          "signature": "function minRefScriptFee(",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 1750,
          "raw": "function minRefScriptFee(\n  totalRefScriptsSize: bigint,\n  refScriptCoinsPerByte: number,\n): bigint {\n  const multiplier = new BigNumber(12).dividedBy(new BigNumber(10)); // 1.2\n  const sizeIncrement = new BigNumber(25600);\n  const baseFee = new BigNumber(refScriptCoinsPerByte);\n\n  const totalSize = new BigNumber(totalRefScriptsSize.toString());\n\n  return tierRefScriptFee(multiplier, sizeIncrement, baseFee, totalSize);\n}",
          "source": "mesh-transaction",
          "implementation": "function minRefScriptFee(\n  totalRefScriptsSize: bigint,\n  refScriptCoinsPerByte: number,\n): bigint {\n  const multiplier = new BigNumber(12).dividedBy(new BigNumber(10)); // 1.2\n  const sizeIncrement = new BigNumber(25600);\n  const baseFee = new BigNumber(refScriptCoinsPerByte);\n\n  const totalSize = new BigNumber(totalRefScriptsSize.toString());\n\n  return tierRefScriptFee(multiplier, sizeIncrement, baseFee, totalSize);\n}"
        },
        {
          "name": "tierRefScriptFee",
          "signature": "function tierRefScriptFee(",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 1763,
          "raw": "function tierRefScriptFee(\n  multiplier: BigNumber,\n  sizeIncrement: BigNumber,\n  baseFee: BigNumber,\n  totalSize: BigNumber,\n): bigint {\n  if (multiplier.lte(0) || sizeIncrement.eq(0)) {\n    throw new Error(\"Size increment and multiplier must be positive\");\n  }\n\n  const fullTiers = totalSize.dividedToIntegerBy(sizeIncrement);\n  const partialTierSize = totalSize.mod(sizeIncrement);\n\n  const tierPrice = baseFee.multipliedBy(sizeIncrement);\n  let acc = new BigNumber(0);\n  const one = new BigNumber(1);\n\n  if (fullTiers.gt(0)) {\n    const multiplierPow = multiplier.pow(fullTiers.toNumber());\n    const progressionEnumerator = one.minus(multiplierPow);\n    const progressionDenom = one.minus(multiplier);\n    const tierProgressionSum =\n      progressionEnumerator.dividedBy(progressionDenom);\n    acc = acc.plus(tierPrice.multipliedBy(tierProgressionSum));\n  }\n\n  if (partialTierSize.gt(0)) {\n    const multiplierPow = multiplier.pow(fullTiers.toNumber());\n    const lastTierPrice = baseFee.multipliedBy(multiplierPow);\n    const partialTierFee = lastTierPrice.multipliedBy(partialTierSize);\n    acc = acc.plus(partialTierFee);\n  }\n\n  return BigInt(acc.integerValue(BigNumber.ROUND_FLOOR).toString());\n}",
          "source": "mesh-transaction",
          "implementation": "function tierRefScriptFee(\n  multiplier: BigNumber,\n  sizeIncrement: BigNumber,\n  baseFee: BigNumber,\n  totalSize: BigNumber,\n): bigint {\n  if (multiplier.lte(0) || sizeIncrement.eq(0)) {\n    throw new Error(\"Size increment and multiplier must be positive\");\n  }\n\n  const fullTiers = totalSize.dividedToIntegerBy(sizeIncrement);\n  const partialTierSize = totalSize.mod(sizeIncrement);\n\n  const tierPrice = baseFee.multipliedBy(sizeIncrement);\n  let acc = new BigNumber(0);\n  const one = new BigNumber(1);\n\n  if (fullTiers.gt(0)) {\n    const multiplierPow = multiplier.pow(fullTiers.toNumber());\n    const progressionEnumerator = one.minus(multiplierPow);\n    const progressionDenom = one.minus(multiplier);\n    const tierProgressionSum =\n      progressionEnumerator.dividedBy(progressionDenom);\n    acc = acc.plus(tierPrice.multipliedBy(tierProgressionSum));\n  }\n\n  if (partialTierSize.gt(0)) {\n    const multiplierPow = multiplier.pow(fullTiers.toNumber());\n    const lastTierPrice = baseFee.multipliedBy(multiplierPow);\n    const partialTierFee = lastTierPrice.multipliedBy(partialTierSize);\n    acc = acc.plus(partialTierFee);\n  }\n\n  return BigInt(acc.integerValue(BigNumber.ROUND_FLOOR).toString());\n}"
        },
        {
          "name": "cloneOutput",
          "signature": "export const cloneOutput = (output: Output): Output => {",
          "documentation": "",
          "parameters": [
            {
              "name": "output",
              "type": "Output",
              "optional": false
            }
          ],
          "returnType": "Output",
          "isPublic": true,
          "line": 1799,
          "raw": "export const cloneOutput = (output: Output): Output => {\n  return JSONBig.parse(JSONBig.stringify(output));\n};",
          "source": "mesh-transaction",
          "implementation": "export const cloneOutput = (output: Output): Output => {\n  return JSONBig.parse(JSONBig.stringify(output));\n};"
        },
        {
          "name": "setLoveLace",
          "signature": "export const setLoveLace = (output: Output, lovelace: bigint): Output => {",
          "documentation": "",
          "parameters": [
            {
              "name": "output",
              "type": "Output",
              "optional": false
            },
            {
              "name": "lovelace",
              "type": "bigint",
              "optional": false
            }
          ],
          "returnType": "Output",
          "isPublic": true,
          "line": 1803,
          "raw": "export const setLoveLace = (output: Output, lovelace: bigint): Output => {\n  let lovelaceSet = false;\n  for (let asset of output.amount) {\n    if (asset.unit === \"lovelace\") {\n      asset.quantity = lovelace.toString();\n      lovelaceSet = true;\n      break;\n    }\n  }\n\n  if (!lovelaceSet) {\n    output.amount.push({\n      unit: \"lovelace\",\n      quantity: lovelace.toString(),\n    });\n  }\n  return output;\n};",
          "source": "mesh-transaction",
          "implementation": "export const setLoveLace = (output: Output, lovelace: bigint): Output => {\n  let lovelaceSet = false;\n  for (let asset of output.amount) {\n    if (asset.unit === \"lovelace\") {\n      asset.quantity = lovelace.toString();\n      lovelaceSet = true;\n      break;\n    }\n  }\n\n  if (!lovelaceSet) {\n    output.amount.push({\n      unit: \"lovelace\",\n      quantity: lovelace.toString(),\n    });\n  }\n  return output;\n};"
        },
        {
          "name": "getLovelace",
          "signature": "export const getLovelace = (output: Output): bigint => {",
          "documentation": "",
          "parameters": [
            {
              "name": "output",
              "type": "Output",
              "optional": false
            }
          ],
          "returnType": "bigint",
          "isPublic": true,
          "line": 1822,
          "raw": "export const getLovelace = (output: Output): bigint => {\n  for (let asset of output.amount) {\n    if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n      return BigInt(asset.quantity);\n    }\n  }\n  return 0n;\n};",
          "source": "mesh-transaction",
          "implementation": "export const getLovelace = (output: Output): bigint => {\n  for (let asset of output.amount) {\n    if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n      return BigInt(asset.quantity);\n    }\n  }\n  return 0n;\n};"
        },
        {
          "name": "getOutputMinLovelace",
          "signature": "export const getOutputMinLovelace = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 1831,
          "raw": "export const getOutputMinLovelace = (\n  output: Output,\n  coinsPerUtxoSize = DEFAULT_PROTOCOL_PARAMETERS.coinsPerUtxoSize,\n): bigint => {\n  const serializer = new CardanoSDKSerializer();\n  let currentOutput = cloneOutput(output);\n  let lovelace = getLovelace(currentOutput);\n  let minLovelace = 0n;\n  for (let i = 0; i < 3; i++) {\n    const txOutSize = BigInt(\n      serializer.serializeOutput(currentOutput).length / 2,\n    );\n    const txOutByteCost = BigInt(coinsPerUtxoSize);\n    const totalOutCost = (160n + BigInt(txOutSize)) * txOutByteCost;\n    minLovelace = totalOutCost;\n    if (lovelace < totalOutCost) {\n      lovelace = totalOutCost;\n    } else {\n      break;\n    }\n    currentOutput = setLoveLace(currentOutput, lovelace);\n  }\n\n  return minLovelace;\n};",
          "source": "mesh-transaction",
          "implementation": "export const getOutputMinLovelace = (\n  output: Output,\n  coinsPerUtxoSize = DEFAULT_PROTOCOL_PARAMETERS.coinsPerUtxoSize,\n): bigint => {\n  const serializer = new CardanoSDKSerializer();\n  let currentOutput = cloneOutput(output);\n  let lovelace = getLovelace(currentOutput);\n  let minLovelace = 0n;\n  for (let i = 0; i < 3; i++) {\n    const txOutSize = BigInt(\n      serializer.serializeOutput(currentOutput).length / 2,\n    );\n    const txOutByteCost = BigInt(coinsPerUtxoSize);\n    const totalOutCost = (160n + BigInt(txOutSize)) * txOutByteCost;\n    minLovelace = totalOutCost;\n    if (lovelace < totalOutCost) {\n      lovelace = totalOutCost;\n    } else {\n      break;\n    }\n    currentOutput = setLoveLace(currentOutput, lovelace);\n  }\n\n  return minLovelace;\n};"
        },
        {
          "name": "totalOutCost",
          "signature": "const totalOutCost = (160n + BigInt(txOutSize)) * txOutByteCost;",
          "documentation": "",
          "parameters": [
            {
              "name": "160n + BigInt(txOutSize",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1844,
          "raw": "    const totalOutCost = (160n + BigInt(txOutSize)) * txOutByteCost;\n    minLovelace = totalOutCost;\n    if (lovelace < totalOutCost) {\n      lovelace = totalOutCost;\n    } else {\n      break;\n    }",
          "source": "mesh-transaction",
          "implementation": "    const totalOutCost = (160n + BigInt(txOutSize)) * txOutByteCost;\n    minLovelace = totalOutCost;\n    if (lovelace < totalOutCost) {\n      lovelace = totalOutCost;\n    } else {\n      break;\n    }"
        }
      ],
      "types": [
        {
          "name": "MeshTxBuilderOptions",
          "definition": "export interface MeshTxBuilderOptions {\n  fetcher?: IFetcher;",
          "isPublic": true,
          "line": 49,
          "raw": "export interface MeshTxBuilderOptions {",
          "source": "mesh-transaction"
        }
      ],
      "constants": [
        {
          "name": "builderBody",
          "type": "any",
          "value": "this.meshTxBuilderBody;",
          "isPublic": true,
          "line": 102,
          "raw": "const builderBody = this.meshTxBuilderBody;",
          "source": "mesh-transaction"
        },
        {
          "name": "txPrototype",
          "type": "any",
          "value": "await this.selectUtxos();",
          "isPublic": true,
          "line": 182,
          "raw": "const txPrototype = await this.selectUtxos();",
          "source": "mesh-transaction"
        },
        {
          "name": "txHex",
          "type": "any",
          "value": "this.serializer.serializeTxBody(",
          "isPublic": true,
          "line": 195,
          "raw": "const txHex = this.serializer.serializeTxBody(",
          "source": "mesh-transaction"
        },
        {
          "name": "callbacks",
          "type": "CoinSelectionInterface.BuilderCallbacks",
          "value": "{",
          "isPublic": true,
          "line": 206,
          "raw": "const callbacks: CoinSelectionInterface.BuilderCallbacks = {",
          "source": "mesh-transaction"
        },
        {
          "name": "clonedBuilder",
          "type": "any",
          "value": "this.clone();",
          "isPublic": true,
          "line": 210,
          "raw": "const clonedBuilder = this.clone();",
          "source": "mesh-transaction"
        },
        {
          "name": "fee",
          "type": "any",
          "value": "clonedBuilder.getActualFee();",
          "isPublic": true,
          "line": 228,
          "raw": "const fee = clonedBuilder.getActualFee();",
          "source": "mesh-transaction"
        },
        {
          "name": "redeemers",
          "type": "any",
          "value": "clonedBuilder.getRedeemerCosts();",
          "isPublic": true,
          "line": 229,
          "raw": "const redeemers = clonedBuilder.getRedeemerCosts();",
          "source": "mesh-transaction"
        },
        {
          "name": "maxValueSize",
          "type": "any",
          "value": "this._protocolParams.maxValSize;",
          "isPublic": true,
          "line": 236,
          "raw": "const maxValueSize = this._protocolParams.maxValSize;",
          "source": "mesh-transaction"
        },
        {
          "name": "clonedBuilder",
          "type": "any",
          "value": "this.clone();",
          "isPublic": true,
          "line": 248,
          "raw": "const clonedBuilder = this.clone();",
          "source": "mesh-transaction"
        },
        {
          "name": "maxTxSize",
          "type": "any",
          "value": "this._protocolParams.maxTxSize;",
          "isPublic": true,
          "line": 250,
          "raw": "const maxTxSize = this._protocolParams.maxTxSize;",
          "source": "mesh-transaction"
        },
        {
          "name": "txSize",
          "type": "any",
          "value": "clonedBuilder.getSerializedSize();",
          "isPublic": true,
          "line": 251,
          "raw": "const txSize = clonedBuilder.getSerializedSize();",
          "source": "mesh-transaction"
        },
        {
          "name": "currentInputs",
          "type": "any",
          "value": "this.meshTxBuilderBody.inputs;",
          "isPublic": true,
          "line": 256,
          "raw": "const currentInputs = this.meshTxBuilderBody.inputs;",
          "source": "mesh-transaction"
        },
        {
          "name": "currentOutputs",
          "type": "any",
          "value": "this.meshTxBuilderBody.outputs;",
          "isPublic": true,
          "line": 257,
          "raw": "const currentOutputs = this.meshTxBuilderBody.outputs;",
          "source": "mesh-transaction"
        },
        {
          "name": "changeAddress",
          "type": "any",
          "value": "this.meshTxBuilderBody.changeAddress;",
          "isPublic": true,
          "line": 258,
          "raw": "const changeAddress = this.meshTxBuilderBody.changeAddress;",
          "source": "mesh-transaction"
        },
        {
          "name": "utxosForSelection",
          "type": "any",
          "value": "await this.getUtxosForSelection();",
          "isPublic": true,
          "line": 259,
          "raw": "const utxosForSelection = await this.getUtxosForSelection();",
          "source": "mesh-transaction"
        },
        {
          "name": "implicitValue",
          "type": "any",
          "value": "{",
          "isPublic": true,
          "line": 260,
          "raw": "const implicitValue = {",
          "source": "mesh-transaction"
        },
        {
          "name": "inputSelector",
          "type": "any",
          "value": "new CardanoSdkInputSelector(callbacks);",
          "isPublic": true,
          "line": 267,
          "raw": "const inputSelector = new CardanoSdkInputSelector(callbacks);",
          "source": "mesh-transaction"
        },
        {
          "name": "utxos",
          "type": "any",
          "value": "this.meshTxBuilderBody.extraInputs;",
          "isPublic": true,
          "line": 311,
          "raw": "const utxos = this.meshTxBuilderBody.extraInputs;",
          "source": "mesh-transaction"
        },
        {
          "name": "usedUtxos",
          "type": "any",
          "value": "new Set(",
          "isPublic": true,
          "line": 312,
          "raw": "const usedUtxos = new Set(",
          "source": "mesh-transaction"
        },
        {
          "name": "credentialA",
          "type": "any",
          "value": "CstAddress.fromString(a.address)",
          "isPublic": true,
          "line": 377,
          "raw": "const credentialA = CstAddress.fromString(a.address)",
          "source": "mesh-transaction"
        },
        {
          "name": "credentialB",
          "type": "any",
          "value": "CstAddress.fromString(b.address)",
          "isPublic": true,
          "line": 380,
          "raw": "const credentialB = CstAddress.fromString(b.address)",
          "source": "mesh-transaction"
        },
        {
          "name": "variantOrder",
          "type": "Record<Voter[\"type\"], number>",
          "value": "{",
          "isPublic": true,
          "line": 391,
          "raw": "const variantOrder: Record<Voter[\"type\"], number> = {",
          "source": "mesh-transaction"
        },
        {
          "name": "voterA",
          "type": "any",
          "value": "a.vote.voter;",
          "isPublic": true,
          "line": 397,
          "raw": "const voterA = a.vote.voter;",
          "source": "mesh-transaction"
        },
        {
          "name": "voterB",
          "type": "any",
          "value": "b.vote.voter;",
          "isPublic": true,
          "line": 398,
          "raw": "const voterB = b.vote.voter;",
          "source": "mesh-transaction"
        },
        {
          "name": "orderA",
          "type": "any",
          "value": "variantOrder[voterA.type];",
          "isPublic": true,
          "line": 399,
          "raw": "const orderA = variantOrder[voterA.type];",
          "source": "mesh-transaction"
        },
        {
          "name": "orderB",
          "type": "any",
          "value": "variantOrder[voterB.type];",
          "isPublic": true,
          "line": 400,
          "raw": "const orderB = variantOrder[voterB.type];",
          "source": "mesh-transaction"
        },
        {
          "name": "credA",
          "type": "any",
          "value": "voterA.hotCred;",
          "isPublic": true,
          "line": 408,
          "raw": "const credA = voterA.hotCred;",
          "source": "mesh-transaction"
        },
        {
          "name": "credB",
          "type": "any",
          "value": "voterB.hotCred;",
          "isPublic": true,
          "line": 409,
          "raw": "const credB = voterB.hotCred;",
          "source": "mesh-transaction"
        },
        {
          "name": "drepA",
          "type": "any",
          "value": "coreToCstDRep(voterA.drepId);",
          "isPublic": true,
          "line": 430,
          "raw": "const drepA = coreToCstDRep(voterA.drepId);",
          "source": "mesh-transaction"
        },
        {
          "name": "drepB",
          "type": "any",
          "value": "coreToCstDRep(voterB.drepId);",
          "isPublic": true,
          "line": 431,
          "raw": "const drepB = coreToCstDRep(voterB.drepId);",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptHashA",
          "type": "any",
          "value": "drepA.toScriptHash();",
          "isPublic": true,
          "line": 432,
          "raw": "const scriptHashA = drepA.toScriptHash();",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptHashB",
          "type": "any",
          "value": "drepB.toScriptHash();",
          "isPublic": true,
          "line": 433,
          "raw": "const scriptHashB = drepB.toScriptHash();",
          "source": "mesh-transaction"
        },
        {
          "name": "keyHashA",
          "type": "any",
          "value": "drepA.toKeyHash();",
          "isPublic": true,
          "line": 434,
          "raw": "const keyHashA = drepA.toKeyHash();",
          "source": "mesh-transaction"
        },
        {
          "name": "keyHashB",
          "type": "any",
          "value": "drepB.toKeyHash();",
          "isPublic": true,
          "line": 435,
          "raw": "const keyHashB = drepB.toKeyHash();",
          "source": "mesh-transaction"
        },
        {
          "name": "txEvaluation",
          "type": "any",
          "value": "await this.evaluator",
          "isPublic": true,
          "line": 468,
          "raw": "const txEvaluation = await this.evaluator",
          "source": "mesh-transaction"
        },
        {
          "name": "meshTxBuilderBody",
          "type": "any",
          "value": "this.meshTxBuilderBody;",
          "isPublic": true,
          "line": 498,
          "raw": "const meshTxBuilderBody = this.meshTxBuilderBody;",
          "source": "mesh-transaction"
        },
        {
          "name": "redeemers",
          "type": "Omit<Action, \"data\">[]",
          "value": "[];",
          "isPublic": true,
          "line": 499,
          "raw": "const redeemers: Omit<Action, \"data\">[] = [];",
          "source": "mesh-transaction"
        },
        {
          "name": "input",
          "type": "any",
          "value": "meshTxBuilderBody.inputs[i]!;",
          "isPublic": true,
          "line": 501,
          "raw": "const input = meshTxBuilderBody.inputs[i]!;",
          "source": "mesh-transaction"
        },
        {
          "name": "mint",
          "type": "any",
          "value": "meshTxBuilderBody.mints[i]!;",
          "isPublic": true,
          "line": 511,
          "raw": "const mint = meshTxBuilderBody.mints[i]!;",
          "source": "mesh-transaction"
        },
        {
          "name": "cert",
          "type": "any",
          "value": "meshTxBuilderBody.certificates[i]!;",
          "isPublic": true,
          "line": 521,
          "raw": "const cert = meshTxBuilderBody.certificates[i]!;",
          "source": "mesh-transaction"
        },
        {
          "name": "withdrawal",
          "type": "any",
          "value": "meshTxBuilderBody.withdrawals[i]!;",
          "isPublic": true,
          "line": 531,
          "raw": "const withdrawal = meshTxBuilderBody.withdrawals[i]!;",
          "source": "mesh-transaction"
        },
        {
          "name": "vote",
          "type": "any",
          "value": "meshTxBuilderBody.votes[i]!;",
          "isPublic": true,
          "line": 541,
          "raw": "const vote = meshTxBuilderBody.votes[i]!;",
          "source": "mesh-transaction"
        },
        {
          "name": "signedTxHex",
          "type": "any",
          "value": "this.serializer.addSigningKeys(",
          "isPublic": true,
          "line": 580,
          "raw": "const signedTxHex = this.serializer.addSigningKeys(",
          "source": "mesh-transaction"
        },
        {
          "name": "txHash",
          "type": "any",
          "value": "await this.submitter?.submitTx(txHex);",
          "isPublic": true,
          "line": 594,
          "raw": "const txHash = await this.submitter?.submitTx(txHex);",
          "source": "mesh-transaction"
        },
        {
          "name": "queryUTxOPromises",
          "type": "Promise<void>[]",
          "value": "[];",
          "isPublic": true,
          "line": 616,
          "raw": "const queryUTxOPromises: Promise<void>[] = [];",
          "source": "mesh-transaction"
        },
        {
          "name": "currentTxIn",
          "type": "any",
          "value": "incompleteTxIns[i]!;",
          "isPublic": true,
          "line": 627,
          "raw": "const currentTxIn = incompleteTxIns[i]!;",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "incompleteScriptSources[i]!;",
          "isPublic": true,
          "line": 633,
          "raw": "const scriptSource = incompleteScriptSources[i]!;",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "input.scriptTxIn.scriptSource;",
          "isPublic": true,
          "line": 651,
          "raw": "const scriptSource = input.scriptTxIn.scriptSource;",
          "source": "mesh-transaction"
        },
        {
          "name": "utxos",
          "type": "UTxO[]",
          "value": "this.queriedUTxOs[input.txIn.txHash]!;",
          "isPublic": true,
          "line": 657,
          "raw": "const utxos: UTxO[] = this.queriedUTxOs[input.txIn.txHash]!;",
          "source": "mesh-transaction"
        },
        {
          "name": "utxo",
          "type": "any",
          "value": "utxos?.find(",
          "isPublic": true,
          "line": 658,
          "raw": "const utxo = utxos?.find(",
          "source": "mesh-transaction"
        },
        {
          "name": "amount",
          "type": "any",
          "value": "utxo?.output.amount;",
          "isPublic": true,
          "line": 661,
          "raw": "const amount = utxo?.output.amount;",
          "source": "mesh-transaction"
        },
        {
          "name": "address",
          "type": "any",
          "value": "utxo?.output.address;",
          "isPublic": true,
          "line": 662,
          "raw": "const address = utxo?.output.address;",
          "source": "mesh-transaction"
        },
        {
          "name": "refUtxos",
          "type": "any",
          "value": "this.queriedUTxOs[scriptSource.txHash]!;",
          "isPublic": true,
          "line": 684,
          "raw": "const refUtxos = this.queriedUTxOs[scriptSource.txHash]!;",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptRefUtxo",
          "type": "any",
          "value": "refUtxos.find(",
          "isPublic": true,
          "line": 685,
          "raw": "const scriptRefUtxo = refUtxos.find(",
          "source": "mesh-transaction"
        },
        {
          "name": "refUtxos",
          "type": "any",
          "value": "this.queriedUTxOs[simpleScript.txHash]!;",
          "isPublic": true,
          "line": 702,
          "raw": "const refUtxos = this.queriedUTxOs[simpleScript.txHash]!;",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptRefUtxo",
          "type": "any",
          "value": "refUtxos.find(",
          "isPublic": true,
          "line": 703,
          "raw": "const scriptRefUtxo = refUtxos.find(",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "mint.scriptSource as ScriptSource;",
          "isPublic": true,
          "line": 733,
          "raw": "const scriptSource = mint.scriptSource as ScriptSource;",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "mint.scriptSource as SimpleScriptSourceInfo;",
          "isPublic": true,
          "line": 737,
          "raw": "const scriptSource = mint.scriptSource as SimpleScriptSourceInfo;",
          "source": "mesh-transaction"
        },
        {
          "name": "txEvaluation",
          "type": "any",
          "value": "await this.evaluator",
          "isPublic": true,
          "line": 790,
          "raw": "const txEvaluation = await this.evaluator",
          "source": "mesh-transaction"
        },
        {
          "name": "incompleteTxIns",
          "type": "any",
          "value": "[...inputs, ...collaterals].filter(",
          "isPublic": true,
          "line": 816,
          "raw": "const incompleteTxIns = [...inputs, ...collaterals].filter(",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "mint.scriptSource as ScriptSource;",
          "isPublic": true,
          "line": 850,
          "raw": "const scriptSource = mint.scriptSource as ScriptSource;",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "mint.scriptSource as SimpleScriptSourceInfo;",
          "isPublic": true,
          "line": 855,
          "raw": "const scriptSource = mint.scriptSource as SimpleScriptSourceInfo;",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "withdrawal.scriptSource as ScriptSource;",
          "isPublic": true,
          "line": 865,
          "raw": "const scriptSource = withdrawal.scriptSource as ScriptSource;",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "withdrawal.scriptSource as SimpleScriptSourceInfo;",
          "isPublic": true,
          "line": 870,
          "raw": "const scriptSource = withdrawal.scriptSource as SimpleScriptSourceInfo;",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "vote.scriptSource as ScriptSource;",
          "isPublic": true,
          "line": 880,
          "raw": "const scriptSource = vote.scriptSource as ScriptSource;",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "vote.simpleScriptSource as SimpleScriptSourceInfo;",
          "isPublic": true,
          "line": 885,
          "raw": "const scriptSource = vote.simpleScriptSource as SimpleScriptSourceInfo;",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "certificate.scriptSource as ScriptSource;",
          "isPublic": true,
          "line": 895,
          "raw": "const scriptSource = certificate.scriptSource as ScriptSource;",
          "source": "mesh-transaction"
        },
        {
          "name": "minAda",
          "type": "any",
          "value": "this.calculateMinLovelaceForOutput(output);",
          "isPublic": true,
          "line": 960,
          "raw": "const minAda = this.calculateMinLovelaceForOutput(output);",
          "source": "mesh-transaction"
        },
        {
          "name": "withdrawalCreds",
          "type": "any",
          "value": "this.getWithdrawalRequiredSignatures();",
          "isPublic": true,
          "line": 976,
          "raw": "const withdrawalCreds = this.getWithdrawalRequiredSignatures();",
          "source": "mesh-transaction"
        },
        {
          "name": "certCreds",
          "type": "any",
          "value": "this.getCertificatesRequiredSignatures();",
          "isPublic": true,
          "line": 977,
          "raw": "const certCreds = this.getCertificatesRequiredSignatures();",
          "source": "mesh-transaction"
        },
        {
          "name": "voteCreds",
          "type": "any",
          "value": "this.getVoteRequiredSignatures();",
          "isPublic": true,
          "line": 978,
          "raw": "const voteCreds = this.getVoteRequiredSignatures();",
          "source": "mesh-transaction"
        },
        {
          "name": "mintCreds",
          "type": "any",
          "value": "this.getMintRequiredSignatures();",
          "isPublic": true,
          "line": 979,
          "raw": "const mintCreds = this.getMintRequiredSignatures();",
          "source": "mesh-transaction"
        },
        {
          "name": "requiredSignatures",
          "type": "any",
          "value": "this.meshTxBuilderBody.requiredSignatures;",
          "isPublic": true,
          "line": 980,
          "raw": "const requiredSignatures = this.meshTxBuilderBody.requiredSignatures;",
          "source": "mesh-transaction"
        },
        {
          "name": "allCreds",
          "type": "any",
          "value": "new Set([",
          "isPublic": true,
          "line": 981,
          "raw": "const allCreds = new Set([",
          "source": "mesh-transaction"
        },
        {
          "name": "allByronAddresses",
          "type": "any",
          "value": "new Set([",
          "isPublic": true,
          "line": 990,
          "raw": "const allByronAddresses = new Set([",
          "source": "mesh-transaction"
        },
        {
          "name": "byronAddresses",
          "type": "any",
          "value": "new Set<string>();",
          "isPublic": true,
          "line": 1001,
          "raw": "const byronAddresses = new Set<string>();",
          "source": "mesh-transaction"
        },
        {
          "name": "paymentCreds",
          "type": "any",
          "value": "new Set<string>();",
          "isPublic": true,
          "line": 1002,
          "raw": "const paymentCreds = new Set<string>();",
          "source": "mesh-transaction"
        },
        {
          "name": "address",
          "type": "any",
          "value": "CstAddress.fromString(input.txIn.address);",
          "isPublic": true,
          "line": 1006,
          "raw": "const address = CstAddress.fromString(input.txIn.address);",
          "source": "mesh-transaction"
        },
        {
          "name": "addressDetails",
          "type": "any",
          "value": "address.getProps();",
          "isPublic": true,
          "line": 1010,
          "raw": "const addressDetails = address.getProps();",
          "source": "mesh-transaction"
        },
        {
          "name": "paymentCred",
          "type": "any",
          "value": "addressDetails.paymentPart;",
          "isPublic": true,
          "line": 1011,
          "raw": "const paymentCred = addressDetails.paymentPart;",
          "source": "mesh-transaction"
        },
        {
          "name": "nativeScript",
          "type": "any",
          "value": "this.getInputNativeScript(input);",
          "isPublic": true,
          "line": 1020,
          "raw": "const nativeScript = this.getInputNativeScript(input);",
          "source": "mesh-transaction"
        },
        {
          "name": "collateralByronAddresses",
          "type": "any",
          "value": "new Set<string>();",
          "isPublic": true,
          "line": 1036,
          "raw": "const collateralByronAddresses = new Set<string>();",
          "source": "mesh-transaction"
        },
        {
          "name": "collateralPaymentCreds",
          "type": "any",
          "value": "new Set<string>();",
          "isPublic": true,
          "line": 1037,
          "raw": "const collateralPaymentCreds = new Set<string>();",
          "source": "mesh-transaction"
        },
        {
          "name": "address",
          "type": "any",
          "value": "CstAddress.fromString(collateral.txIn.address);",
          "isPublic": true,
          "line": 1041,
          "raw": "const address = CstAddress.fromString(collateral.txIn.address);",
          "source": "mesh-transaction"
        },
        {
          "name": "addressDetails",
          "type": "any",
          "value": "address.getProps();",
          "isPublic": true,
          "line": 1045,
          "raw": "const addressDetails = address.getProps();",
          "source": "mesh-transaction"
        },
        {
          "name": "paymentCred",
          "type": "any",
          "value": "addressDetails.paymentPart;",
          "isPublic": true,
          "line": 1046,
          "raw": "const paymentCred = addressDetails.paymentPart;",
          "source": "mesh-transaction"
        },
        {
          "name": "withdrawalCreds",
          "type": "any",
          "value": "new Set<string>();",
          "isPublic": true,
          "line": 1060,
          "raw": "const withdrawalCreds = new Set<string>();",
          "source": "mesh-transaction"
        },
        {
          "name": "address",
          "type": "any",
          "value": "CstAddress.fromBech32(withdrawal.address);",
          "isPublic": true,
          "line": 1063,
          "raw": "const address = CstAddress.fromBech32(withdrawal.address);",
          "source": "mesh-transaction"
        },
        {
          "name": "addressDetails",
          "type": "any",
          "value": "address.getProps();",
          "isPublic": true,
          "line": 1064,
          "raw": "const addressDetails = address.getProps();",
          "source": "mesh-transaction"
        },
        {
          "name": "paymentCred",
          "type": "any",
          "value": "addressDetails.paymentPart;",
          "isPublic": true,
          "line": 1065,
          "raw": "const paymentCred = addressDetails.paymentPart;",
          "source": "mesh-transaction"
        },
        {
          "name": "nativeScript",
          "type": "any",
          "value": "this.getWithdrawalNativeScript(withdrawal);",
          "isPublic": true,
          "line": 1071,
          "raw": "const nativeScript = this.getWithdrawalNativeScript(withdrawal);",
          "source": "mesh-transaction"
        },
        {
          "name": "certCreds",
          "type": "any",
          "value": "new Set<string>();",
          "isPublic": true,
          "line": 1084,
          "raw": "const certCreds = new Set<string>();",
          "source": "mesh-transaction"
        },
        {
          "name": "certNativeScript",
          "type": "any",
          "value": "this.getCertificateNativeScript(cert);",
          "isPublic": true,
          "line": 1093,
          "raw": "const certNativeScript = this.getCertificateNativeScript(cert);",
          "source": "mesh-transaction"
        },
        {
          "name": "certType",
          "type": "any",
          "value": "cert.certType;",
          "isPublic": true,
          "line": 1095,
          "raw": "const certType = cert.certType;",
          "source": "mesh-transaction"
        },
        {
          "name": "cstDrep",
          "type": "any",
          "value": "coreToCstDRep(certType.drepId);",
          "isPublic": true,
          "line": 1110,
          "raw": "const cstDrep = coreToCstDRep(certType.drepId);",
          "source": "mesh-transaction"
        },
        {
          "name": "keyHash",
          "type": "any",
          "value": "cstDrep.toKeyHash();",
          "isPublic": true,
          "line": 1111,
          "raw": "const keyHash = cstDrep.toKeyHash();",
          "source": "mesh-transaction"
        },
        {
          "name": "address",
          "type": "any",
          "value": "CstAddress.fromString(certType.stakeKeyAddress);",
          "isPublic": true,
          "line": 1132,
          "raw": "const address = CstAddress.fromString(certType.stakeKeyAddress);",
          "source": "mesh-transaction"
        },
        {
          "name": "addressDetails",
          "type": "any",
          "value": "address.getProps();",
          "isPublic": true,
          "line": 1134,
          "raw": "const addressDetails = address.getProps();",
          "source": "mesh-transaction"
        },
        {
          "name": "paymentCred",
          "type": "any",
          "value": "addressDetails.paymentPart;",
          "isPublic": true,
          "line": 1135,
          "raw": "const paymentCred = addressDetails.paymentPart;",
          "source": "mesh-transaction"
        },
        {
          "name": "address",
          "type": "any",
          "value": "CstAddress.fromString(",
          "isPublic": true,
          "line": 1151,
          "raw": "const address = CstAddress.fromString(",
          "source": "mesh-transaction"
        },
        {
          "name": "addressDetails",
          "type": "any",
          "value": "address.getProps();",
          "isPublic": true,
          "line": 1155,
          "raw": "const addressDetails = address.getProps();",
          "source": "mesh-transaction"
        },
        {
          "name": "paymentCred",
          "type": "any",
          "value": "addressDetails.paymentPart;",
          "isPublic": true,
          "line": 1156,
          "raw": "const paymentCred = addressDetails.paymentPart;",
          "source": "mesh-transaction"
        },
        {
          "name": "voteCreds",
          "type": "any",
          "value": "new Set<string>();",
          "isPublic": true,
          "line": 1173,
          "raw": "const voteCreds = new Set<string>();",
          "source": "mesh-transaction"
        },
        {
          "name": "nativeScript",
          "type": "any",
          "value": "this.getVoteNativeScript(vote);",
          "isPublic": true,
          "line": 1176,
          "raw": "const nativeScript = this.getVoteNativeScript(vote);",
          "source": "mesh-transaction"
        },
        {
          "name": "voter",
          "type": "any",
          "value": "vote.vote.voter;",
          "isPublic": true,
          "line": 1183,
          "raw": "const voter = vote.vote.voter;",
          "source": "mesh-transaction"
        },
        {
          "name": "drep",
          "type": "any",
          "value": "coreToCstDRep(voter.drepId);",
          "isPublic": true,
          "line": 1185,
          "raw": "const drep = coreToCstDRep(voter.drepId);",
          "source": "mesh-transaction"
        },
        {
          "name": "keyHash",
          "type": "any",
          "value": "drep.toKeyHash();",
          "isPublic": true,
          "line": 1186,
          "raw": "const keyHash = drep.toKeyHash();",
          "source": "mesh-transaction"
        },
        {
          "name": "hotCred",
          "type": "any",
          "value": "voter.hotCred;",
          "isPublic": true,
          "line": 1193,
          "raw": "const hotCred = voter.hotCred;",
          "source": "mesh-transaction"
        },
        {
          "name": "mintCreds",
          "type": "any",
          "value": "new Set<string>();",
          "isPublic": true,
          "line": 1205,
          "raw": "const mintCreds = new Set<string>();",
          "source": "mesh-transaction"
        },
        {
          "name": "nativeScript",
          "type": "any",
          "value": "this.getMintNativeScript(mint);",
          "isPublic": true,
          "line": 1208,
          "raw": "const nativeScript = this.getMintNativeScript(mint);",
          "source": "mesh-transaction"
        },
        {
          "name": "certType",
          "type": "any",
          "value": "cert.certType;",
          "isPublic": true,
          "line": 1231,
          "raw": "const certType = cert.certType;",
          "source": "mesh-transaction"
        },
        {
          "name": "certType",
          "type": "any",
          "value": "cert.certType;",
          "isPublic": true,
          "line": 1254,
          "raw": "const certType = cert.certType;",
          "source": "mesh-transaction"
        },
        {
          "name": "assets",
          "type": "any",
          "value": "new Map<string, bigint>();",
          "isPublic": true,
          "line": 1267,
          "raw": "const assets = new Map<string, bigint>();",
          "source": "mesh-transaction"
        },
        {
          "name": "assetId",
          "type": "any",
          "value": "`${mint.policyId}${assetValue.assetName}`;",
          "isPublic": true,
          "line": 1270,
          "raw": "const assetId = `${mint.policyId}${assetValue.assetName}`;",
          "source": "mesh-transaction"
        },
        {
          "name": "pubKeys",
          "type": "any",
          "value": "new Set<string>();",
          "isPublic": true,
          "line": 1285,
          "raw": "const pubKeys = new Set<string>();",
          "source": "mesh-transaction"
        },
        {
          "name": "nativeScriptStack",
          "type": "any",
          "value": "[];",
          "isPublic": true,
          "line": 1286,
          "raw": "const nativeScriptStack = [];",
          "source": "mesh-transaction"
        },
        {
          "name": "script",
          "type": "any",
          "value": "nativeScriptStack.pop();",
          "isPublic": true,
          "line": 1289,
          "raw": "const script = nativeScriptStack.pop();",
          "source": "mesh-transaction"
        },
        {
          "name": "nOfK",
          "type": "any",
          "value": "script.asScriptNOfK();",
          "isPublic": true,
          "line": 1293,
          "raw": "const nOfK = script.asScriptNOfK();",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptAll",
          "type": "any",
          "value": "script.asScriptAll();",
          "isPublic": true,
          "line": 1299,
          "raw": "const scriptAll = script.asScriptAll();",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptAny",
          "type": "any",
          "value": "script.asScriptAny();",
          "isPublic": true,
          "line": 1305,
          "raw": "const scriptAny = script.asScriptAny();",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptPubkey",
          "type": "any",
          "value": "script.asScriptPubkey();",
          "isPublic": true,
          "line": 1311,
          "raw": "const scriptPubkey = script.asScriptPubkey();",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "cert.simpleScriptSource;",
          "isPublic": true,
          "line": 1324,
          "raw": "const scriptSource = cert.simpleScriptSource;",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "cert.simpleScriptSource;",
          "isPublic": true,
          "line": 1349,
          "raw": "const scriptSource = cert.simpleScriptSource;",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "mint.scriptSource as SimpleScriptSourceInfo;",
          "isPublic": true,
          "line": 1374,
          "raw": "const scriptSource = mint.scriptSource as SimpleScriptSourceInfo;",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSourceAlternative",
          "type": "any",
          "value": "mint.scriptSource as ScriptSource;",
          "isPublic": true,
          "line": 1375,
          "raw": "const scriptSourceAlternative = mint.scriptSource as ScriptSource;",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "withdrawal.scriptSource;",
          "isPublic": true,
          "line": 1410,
          "raw": "const scriptSource = withdrawal.scriptSource;",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "txIn.simpleScriptTxIn.scriptSource;",
          "isPublic": true,
          "line": 1433,
          "raw": "const scriptSource = txIn.simpleScriptTxIn.scriptSource;",
          "source": "mesh-transaction"
        },
        {
          "name": "utxos",
          "type": "any",
          "value": "this.queriedUTxOs[txHash];",
          "isPublic": true,
          "line": 1455,
          "raw": "const utxos = this.queriedUTxOs[txHash];",
          "source": "mesh-transaction"
        },
        {
          "name": "utxo",
          "type": "any",
          "value": "utxos.find((utxo) => utxo.input.outputIndex === index);",
          "isPublic": true,
          "line": 1460,
          "raw": "const utxo = utxos.find((utxo) => utxo.input.outputIndex === index);",
          "source": "mesh-transaction"
        },
        {
          "name": "script",
          "type": "any",
          "value": "CstScript.fromCbor(",
          "isPublic": true,
          "line": 1462,
          "raw": "const script = CstScript.fromCbor(",
          "source": "mesh-transaction"
        },
        {
          "name": "allReferenceInputs",
          "type": "any",
          "value": "this.getAllReferenceInputsSizes();",
          "isPublic": true,
          "line": 1476,
          "raw": "const allReferenceInputs = this.getAllReferenceInputsSizes();",
          "source": "mesh-transaction"
        },
        {
          "name": "referenceInputs",
          "type": "any",
          "value": "new Map<string, bigint>();",
          "isPublic": true,
          "line": 1484,
          "raw": "const referenceInputs = new Map<string, bigint>();",
          "source": "mesh-transaction"
        },
        {
          "name": "bodyReferenceInputs",
          "type": "any",
          "value": "this.getBodyReferenceInputsSizes();",
          "isPublic": true,
          "line": 1485,
          "raw": "const bodyReferenceInputs = this.getBodyReferenceInputsSizes();",
          "source": "mesh-transaction"
        },
        {
          "name": "inputsReferenceInputs",
          "type": "any",
          "value": "this.getInputsReferenceInputsSizes();",
          "isPublic": true,
          "line": 1489,
          "raw": "const inputsReferenceInputs = this.getInputsReferenceInputsSizes();",
          "source": "mesh-transaction"
        },
        {
          "name": "mintsReferenceInputs",
          "type": "any",
          "value": "this.getMintsReferenceInputsSizes();",
          "isPublic": true,
          "line": 1493,
          "raw": "const mintsReferenceInputs = this.getMintsReferenceInputsSizes();",
          "source": "mesh-transaction"
        },
        {
          "name": "votesReferenceInputs",
          "type": "any",
          "value": "this.getVotesReferenceInputsSizes();",
          "isPublic": true,
          "line": 1502,
          "raw": "const votesReferenceInputs = this.getVotesReferenceInputsSizes();",
          "source": "mesh-transaction"
        },
        {
          "name": "referenceInputs",
          "type": "[string, bigint][]",
          "value": "[];",
          "isPublic": true,
          "line": 1515,
          "raw": "const referenceInputs: [string, bigint][] = [];",
          "source": "mesh-transaction"
        },
        {
          "name": "referenceInputs",
          "type": "[string, bigint][]",
          "value": "[];",
          "isPublic": true,
          "line": 1526,
          "raw": "const referenceInputs: [string, bigint][] = [];",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "input.scriptTxIn.scriptSource;",
          "isPublic": true,
          "line": 1529,
          "raw": "const scriptSource = input.scriptTxIn.scriptSource;",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "input.simpleScriptTxIn.scriptSource;",
          "isPublic": true,
          "line": 1537,
          "raw": "const scriptSource = input.simpleScriptTxIn.scriptSource;",
          "source": "mesh-transaction"
        },
        {
          "name": "referenceInputs",
          "type": "[string, bigint][]",
          "value": "[];",
          "isPublic": true,
          "line": 1550,
          "raw": "const referenceInputs: [string, bigint][] = [];",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "mint.scriptSource;",
          "isPublic": true,
          "line": 1553,
          "raw": "const scriptSource = mint.scriptSource;",
          "source": "mesh-transaction"
        },
        {
          "name": "referenceInputs",
          "type": "[string, bigint][]",
          "value": "[];",
          "isPublic": true,
          "line": 1566,
          "raw": "const referenceInputs: [string, bigint][] = [];",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "withdrawal.scriptSource;",
          "isPublic": true,
          "line": 1572,
          "raw": "const scriptSource = withdrawal.scriptSource;",
          "source": "mesh-transaction"
        },
        {
          "name": "referenceInputs",
          "type": "[string, bigint][]",
          "value": "[];",
          "isPublic": true,
          "line": 1585,
          "raw": "const referenceInputs: [string, bigint][] = [];",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "vote.simpleScriptSource;",
          "isPublic": true,
          "line": 1588,
          "raw": "const scriptSource = vote.simpleScriptSource;",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "vote.scriptSource;",
          "isPublic": true,
          "line": 1596,
          "raw": "const scriptSource = vote.scriptSource;",
          "source": "mesh-transaction"
        },
        {
          "name": "referenceInputs",
          "type": "[string, bigint][]",
          "value": "[];",
          "isPublic": true,
          "line": 1609,
          "raw": "const referenceInputs: [string, bigint][] = [];",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "cert.simpleScriptSource;",
          "isPublic": true,
          "line": 1612,
          "raw": "const scriptSource = cert.simpleScriptSource;",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "cert.scriptSource;",
          "isPublic": true,
          "line": 1620,
          "raw": "const scriptSource = cert.scriptSource;",
          "source": "mesh-transaction"
        },
        {
          "name": "txSize",
          "type": "any",
          "value": "this.getSerializedSize();",
          "isPublic": true,
          "line": 1693,
          "raw": "const txSize = this.getSerializedSize();",
          "source": "mesh-transaction"
        },
        {
          "name": "refScriptFee",
          "type": "any",
          "value": "this.calculateRefScriptFee();",
          "isPublic": true,
          "line": 1698,
          "raw": "const refScriptFee = this.calculateRefScriptFee();",
          "source": "mesh-transaction"
        },
        {
          "name": "redeemersFee",
          "type": "any",
          "value": "this.calculateRedeemersFee();",
          "isPublic": true,
          "line": 1699,
          "raw": "const redeemersFee = this.calculateRedeemersFee();",
          "source": "mesh-transaction"
        },
        {
          "name": "minFeeCoeff",
          "type": "any",
          "value": "BigInt(this._protocolParams.minFeeA);",
          "isPublic": true,
          "line": 1700,
          "raw": "const minFeeCoeff = BigInt(this._protocolParams.minFeeA);",
          "source": "mesh-transaction"
        },
        {
          "name": "minFeeConstant",
          "type": "any",
          "value": "BigInt(this._protocolParams.minFeeB);",
          "isPublic": true,
          "line": 1701,
          "raw": "const minFeeConstant = BigInt(this._protocolParams.minFeeB);",
          "source": "mesh-transaction"
        },
        {
          "name": "minFee",
          "type": "any",
          "value": "minFeeCoeff * BigInt(txSize) + minFeeConstant;",
          "isPublic": true,
          "line": 1702,
          "raw": "const minFee = minFeeCoeff * BigInt(txSize) + minFeeConstant;",
          "source": "mesh-transaction"
        },
        {
          "name": "refSize",
          "type": "any",
          "value": "this.getTotalReferenceInputsSize();",
          "isPublic": true,
          "line": 1707,
          "raw": "const refSize = this.getTotalReferenceInputsSize();",
          "source": "mesh-transaction"
        },
        {
          "name": "refScriptFee",
          "type": "any",
          "value": "this._protocolParams.minFeeRefScriptCostPerByte;",
          "isPublic": true,
          "line": 1708,
          "raw": "const refScriptFee = this._protocolParams.minFeeRefScriptCostPerByte;",
          "source": "mesh-transaction"
        },
        {
          "name": "stepPrice",
          "type": "any",
          "value": "BigNumber(this._protocolParams.priceStep);",
          "isPublic": true,
          "line": 1714,
          "raw": "const stepPrice = BigNumber(this._protocolParams.priceStep);",
          "source": "mesh-transaction"
        },
        {
          "name": "memPrice",
          "type": "any",
          "value": "BigNumber(this._protocolParams.priceMem);",
          "isPublic": true,
          "line": 1715,
          "raw": "const memPrice = BigNumber(this._protocolParams.priceMem);",
          "source": "mesh-transaction"
        },
        {
          "name": "stepFee",
          "type": "any",
          "value": "stepPrice.multipliedBy(BigNumber(stepUnits.toString()));",
          "isPublic": true,
          "line": 1716,
          "raw": "const stepFee = stepPrice.multipliedBy(BigNumber(stepUnits.toString()));",
          "source": "mesh-transaction"
        },
        {
          "name": "memFee",
          "type": "any",
          "value": "memPrice.multipliedBy(BigNumber(memUnits.toString()));",
          "isPublic": true,
          "line": 1717,
          "raw": "const memFee = memPrice.multipliedBy(BigNumber(memUnits.toString()));",
          "source": "mesh-transaction"
        },
        {
          "name": "newBuilder",
          "type": "any",
          "value": "super._cloneCore<MeshTxBuilder>(() => {",
          "isPublic": true,
          "line": 1728,
          "raw": "const newBuilder = super._cloneCore<MeshTxBuilder>(() => {",
          "source": "mesh-transaction"
        },
        {
          "name": "multiplier",
          "type": "any",
          "value": "new BigNumber(12).dividedBy(new BigNumber(10)); // 1.2",
          "isPublic": true,
          "line": 1754,
          "raw": "const multiplier = new BigNumber(12).dividedBy(new BigNumber(10)); // 1.2",
          "source": "mesh-transaction"
        },
        {
          "name": "sizeIncrement",
          "type": "any",
          "value": "new BigNumber(25600);",
          "isPublic": true,
          "line": 1755,
          "raw": "const sizeIncrement = new BigNumber(25600);",
          "source": "mesh-transaction"
        },
        {
          "name": "baseFee",
          "type": "any",
          "value": "new BigNumber(refScriptCoinsPerByte);",
          "isPublic": true,
          "line": 1756,
          "raw": "const baseFee = new BigNumber(refScriptCoinsPerByte);",
          "source": "mesh-transaction"
        },
        {
          "name": "totalSize",
          "type": "any",
          "value": "new BigNumber(totalRefScriptsSize.toString());",
          "isPublic": true,
          "line": 1758,
          "raw": "const totalSize = new BigNumber(totalRefScriptsSize.toString());",
          "source": "mesh-transaction"
        },
        {
          "name": "fullTiers",
          "type": "any",
          "value": "totalSize.dividedToIntegerBy(sizeIncrement);",
          "isPublic": true,
          "line": 1773,
          "raw": "const fullTiers = totalSize.dividedToIntegerBy(sizeIncrement);",
          "source": "mesh-transaction"
        },
        {
          "name": "partialTierSize",
          "type": "any",
          "value": "totalSize.mod(sizeIncrement);",
          "isPublic": true,
          "line": 1774,
          "raw": "const partialTierSize = totalSize.mod(sizeIncrement);",
          "source": "mesh-transaction"
        },
        {
          "name": "tierPrice",
          "type": "any",
          "value": "baseFee.multipliedBy(sizeIncrement);",
          "isPublic": true,
          "line": 1776,
          "raw": "const tierPrice = baseFee.multipliedBy(sizeIncrement);",
          "source": "mesh-transaction"
        },
        {
          "name": "one",
          "type": "any",
          "value": "new BigNumber(1);",
          "isPublic": true,
          "line": 1778,
          "raw": "const one = new BigNumber(1);",
          "source": "mesh-transaction"
        },
        {
          "name": "multiplierPow",
          "type": "any",
          "value": "multiplier.pow(fullTiers.toNumber());",
          "isPublic": true,
          "line": 1781,
          "raw": "const multiplierPow = multiplier.pow(fullTiers.toNumber());",
          "source": "mesh-transaction"
        },
        {
          "name": "progressionEnumerator",
          "type": "any",
          "value": "one.minus(multiplierPow);",
          "isPublic": true,
          "line": 1782,
          "raw": "const progressionEnumerator = one.minus(multiplierPow);",
          "source": "mesh-transaction"
        },
        {
          "name": "progressionDenom",
          "type": "any",
          "value": "one.minus(multiplier);",
          "isPublic": true,
          "line": 1783,
          "raw": "const progressionDenom = one.minus(multiplier);",
          "source": "mesh-transaction"
        },
        {
          "name": "multiplierPow",
          "type": "any",
          "value": "multiplier.pow(fullTiers.toNumber());",
          "isPublic": true,
          "line": 1790,
          "raw": "const multiplierPow = multiplier.pow(fullTiers.toNumber());",
          "source": "mesh-transaction"
        },
        {
          "name": "lastTierPrice",
          "type": "any",
          "value": "baseFee.multipliedBy(multiplierPow);",
          "isPublic": true,
          "line": 1791,
          "raw": "const lastTierPrice = baseFee.multipliedBy(multiplierPow);",
          "source": "mesh-transaction"
        },
        {
          "name": "partialTierFee",
          "type": "any",
          "value": "lastTierPrice.multipliedBy(partialTierSize);",
          "isPublic": true,
          "line": 1792,
          "raw": "const partialTierFee = lastTierPrice.multipliedBy(partialTierSize);",
          "source": "mesh-transaction"
        },
        {
          "name": "cloneOutput",
          "type": "any",
          "value": "(output: Output): Output => {",
          "isPublic": true,
          "line": 1799,
          "raw": "export const cloneOutput = (output: Output): Output => {",
          "source": "mesh-transaction"
        },
        {
          "name": "setLoveLace",
          "type": "any",
          "value": "(output: Output, lovelace: bigint): Output => {",
          "isPublic": true,
          "line": 1803,
          "raw": "export const setLoveLace = (output: Output, lovelace: bigint): Output => {",
          "source": "mesh-transaction"
        },
        {
          "name": "getLovelace",
          "type": "any",
          "value": "(output: Output): bigint => {",
          "isPublic": true,
          "line": 1822,
          "raw": "export const getLovelace = (output: Output): bigint => {",
          "source": "mesh-transaction"
        },
        {
          "name": "getOutputMinLovelace",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 1831,
          "raw": "export const getOutputMinLovelace = (",
          "source": "mesh-transaction"
        },
        {
          "name": "serializer",
          "type": "any",
          "value": "new CardanoSDKSerializer();",
          "isPublic": true,
          "line": 1835,
          "raw": "const serializer = new CardanoSDKSerializer();",
          "source": "mesh-transaction"
        },
        {
          "name": "txOutSize",
          "type": "any",
          "value": "BigInt(",
          "isPublic": true,
          "line": 1840,
          "raw": "const txOutSize = BigInt(",
          "source": "mesh-transaction"
        },
        {
          "name": "txOutByteCost",
          "type": "any",
          "value": "BigInt(coinsPerUtxoSize);",
          "isPublic": true,
          "line": 1843,
          "raw": "const txOutByteCost = BigInt(coinsPerUtxoSize);",
          "source": "mesh-transaction"
        },
        {
          "name": "totalOutCost",
          "type": "any",
          "value": "(160n + BigInt(txOutSize)) * txOutByteCost;",
          "isPublic": true,
          "line": 1844,
          "raw": "const totalOutCost = (160n + BigInt(txOutSize)) * txOutByteCost;",
          "source": "mesh-transaction"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import BigNumber from \"bignumber.js\";\nimport JSONBig from \"json-bigint\";\n\nimport {\n  Action,\n  Asset,\n  Certificate,\n  DEFAULT_PROTOCOL_PARAMETERS,\n  IEvaluator,\n  IFetcher,\n  IMeshTxSerializer,\n  ISubmitter,\n  MeshTxBuilderBody,\n  MintItem,\n  MintParam,\n  Output,\n  Protocol,\n  ScriptSource,\n  SimpleScriptSourceInfo,\n  TxIn,\n  TxOutput,\n  UTxO,\n  Vote,\n  Voter,\n  Withdrawal,\n} from \"@meshsdk/common\";\nimport {\n  CardanoSDKSerializer,\n  CardanoSDKUtil,\n  toDRep as coreToCstDRep,\n  Address as CstAddress,\n  AddressType as CstAddressType,\n  CredentialCore as CstCredential,\n  CredentialType as CstCredentialType,\n  NativeScript as CstNativeScript,\n  Script as CstScript,\n} from \"@meshsdk/core-cst\";\n\nimport {\n  CardanoSdkInputSelector,\n  CoinSelectionInterface,\n} from \"./coin-selection\";\nimport {\n  TransactionCost,\n  TransactionPrototype,\n} from \"./coin-selection/coin-selection-interface\";\nimport { MeshTxBuilderCore } from \"./tx-builder-core\";\n\nexport interface MeshTxBuilderOptions {\n  fetcher?: IFetcher;\n  submitter?: ISubmitter;\n  evaluator?: IEvaluator;\n  serializer?: IMeshTxSerializer;\n  isHydra?: boolean;\n  params?: Partial<Protocol>;\n  verbose?: boolean;\n}\n\nexport class MeshTxBuilder extends MeshTxBuilderCore {\n  serializer: IMeshTxSerializer;\n  fetcher?: IFetcher;\n  submitter?: ISubmitter;\n  evaluator?: IEvaluator;\n  txHex: string = \"\";\n  verbose: boolean;\n  protected queriedTxHashes: Set<string> = new Set();\n  protected queriedUTxOs: { [x: string]: UTxO[] } = {};\n  protected utxosWithRefScripts: UTxO[] = [];\n\n  constructor({\n    serializer,\n    fetcher,\n    submitter,\n    evaluator,\n    params,\n    isHydra = false,\n    verbose = false,\n  }: MeshTxBuilderOptions = {}) {\n    super();\n    if (fetcher) this.fetcher = fetcher;\n    if (submitter) this.submitter = submitter;\n    if (evaluator) this.evaluator = evaluator;\n    if (params) this.protocolParams(params);\n    if (serializer) {\n      this.serializer = serializer;\n    } else {\n      this.serializer = new CardanoSDKSerializer(this._protocolParams);\n    }\n    this.verbose = verbose;\n    if (isHydra)\n      this.protocolParams({\n        minFeeA: 0,\n        minFeeB: 0,\n        priceMem: 0,\n        priceStep: 0,\n        collateralPercent: 0,\n        coinsPerUtxoSize: 0,\n      });\n  }\n\n  serializeMockTx = () => {\n    const builderBody = this.meshTxBuilderBody;\n    const { keyHashes, byronAddresses } = this.collectAllRequiredSignatures();\n    builderBody.expectedNumberKeyWitnesses = keyHashes.size;\n    builderBody.expectedByronAddressWitnesses = Array.from(byronAddresses);\n    return this.serializer.serializeTxBodyWithMockSignatures(\n      this.meshTxBuilderBody,\n      this._protocolParams,\n    );\n  };\n\n  /**\n   * It builds the transaction query the blockchain for missing information\n   * @param customizedTx The optional customized transaction body\n   * @returns The transaction in hex, unbalanced\n   */\n  completeUnbalanced = (customizedTx?: MeshTxBuilderBody): string => {\n    if (customizedTx) {\n      this.meshTxBuilderBody = customizedTx;\n    } else {\n      this.queueAllLastItem();\n    }\n    this.removeDuplicateInputs();\n    this.removeDuplicateRefInputs();\n    return this.serializer.serializeTxBody(\n      this.meshTxBuilderBody,\n      this._protocolParams,\n    );\n  };\n\n  completeSync = (customizedTx?: MeshTxBuilderBody) => {\n    if (customizedTx) {\n      this.meshTxBuilderBody = customizedTx;\n    } else {\n      this.queueAllLastItem();\n    }\n    this.removeDuplicateInputs();\n    this.removeDuplicateRefInputs();\n    this.addUtxosFromSelection();\n    return this.serializer.serializeTxBody(\n      this.meshTxBuilderBody,\n      this._protocolParams,\n    );\n  };\n\n  /**\n   * It builds the transaction and query the blockchain for missing information\n   * @param customizedTx The optional customized transaction body\n   * @returns The signed transaction in hex ready to submit / signed by client\n   */\n  complete = async (customizedTx?: Partial<MeshTxBuilderBody>) => {\n    if (customizedTx) {\n      this.meshTxBuilderBody = { ...this.meshTxBuilderBody, ...customizedTx };\n      if (customizedTx.fee) {\n        this.setFee(customizedTx.fee);\n      }\n    }\n\n    this.queueAllLastItem();\n\n    if (this.verbose) {\n      console.log(\n        \"txBodyJson - before coin selection\",\n        JSONBig.stringify(this.meshTxBuilderBody, (key, val) => {\n          if (key === \"extraInputs\") return undefined;\n          if (key === \"selectionConfig\") return undefined;\n          return val;\n        }),\n      );\n    }\n    this.removeDuplicateInputs();\n    this.removeDuplicateRefInputs();\n    // We can set scriptSize of collaterals as 0, because the ledger ignores this for fee calculations\n    for (let collateral of this.meshTxBuilderBody.collaterals) {\n      collateral.txIn.scriptSize = 0;\n    }\n    await this.completeTxParts();\n    await this.sanitizeOutputs();\n\n    this.sortTxParts();\n\n    const txPrototype = await this.selectUtxos();\n    await this.updateByTxPrototype(txPrototype, true);\n    if (this.verbose) {\n      console.log(\n        \"txBodyJson - after coin selection\",\n        JSONBig.stringify(this.meshTxBuilderBody, (key, val) => {\n          if (key === \"extraInputs\") return undefined;\n          if (key === \"selectionConfig\") return undefined;\n          return val;\n        }),\n      );\n    }\n\n    const txHex = this.serializer.serializeTxBody(\n      this.meshTxBuilderBody,\n      this._protocolParams,\n    );\n\n    this.txHex = txHex;\n    return txHex;\n  };\n\n  selectUtxos =\n    async (): Promise<CoinSelectionInterface.TransactionPrototype> => {\n      const callbacks: CoinSelectionInterface.BuilderCallbacks = {\n        computeMinimumCost: async (\n          selectionSkeleton: TransactionPrototype,\n        ): Promise<TransactionCost> => {\n          const clonedBuilder = this.clone();\n          await clonedBuilder.updateByTxPrototype(selectionSkeleton);\n\n          try {\n            await clonedBuilder.evaluateRedeemers();\n          } catch (error) {\n            if (error instanceof Error) {\n              throw new Error(`Evaluate redeemers failed: ${error.message}`);\n            } else if (typeof error === \"string\") {\n              throw new Error(`Evaluate redeemers failed: ${error}`);\n            } else if (typeof error === \"object\") {\n              throw new Error(\n                `Evaluate redeemers failed: ${JSON.stringify(error)}`,\n              );\n            } else {\n              throw new Error(`Evaluate redeemers failed: ${String(error)}`);\n            }\n          }\n          const fee = clonedBuilder.getActualFee();\n          const redeemers = clonedBuilder.getRedeemerCosts();\n          return {\n            fee,\n            redeemers,\n          };\n        },\n        tokenBundleSizeExceedsLimit: (tokenBundle) => {\n          const maxValueSize = this._protocolParams.maxValSize;\n          if (tokenBundle) {\n            const valueSize =\n              this.serializer.serializeValue(tokenBundle).length / 2;\n            return valueSize > maxValueSize;\n          }\n          return false;\n        },\n        computeMinimumCoinQuantity: (output) => {\n          return this.calculateMinLovelaceForOutput(output);\n        },\n        maxSizeExceed: async (selectionSkeleton) => {\n          const clonedBuilder = this.clone();\n          await clonedBuilder.updateByTxPrototype(selectionSkeleton);\n          const maxTxSize = this._protocolParams.maxTxSize;\n          const txSize = clonedBuilder.getSerializedSize();\n          return txSize > maxTxSize;\n        },\n      };\n\n      const currentInputs = this.meshTxBuilderBody.inputs;\n      const currentOutputs = this.meshTxBuilderBody.outputs;\n      const changeAddress = this.meshTxBuilderBody.changeAddress;\n      const utxosForSelection = await this.getUtxosForSelection();\n      const implicitValue = {\n        withdrawals: this.getTotalWithdrawal(),\n        deposit: this.getTotalDeposit(),\n        reclaimDeposit: this.getTotalRefund(),\n        mint: this.getTotalMint(),\n      };\n\n      const inputSelector = new CardanoSdkInputSelector(callbacks);\n      return await inputSelector.select(\n        currentInputs,\n        currentOutputs,\n        implicitValue,\n        utxosForSelection,\n        changeAddress,\n      );\n    };\n\n  updateByTxPrototype = async (\n    selectionSkeleton: CoinSelectionInterface.TransactionPrototype,\n    final = false,\n  ) => {\n    for (let utxo of selectionSkeleton.newInputs) {\n      this.txIn(\n        utxo.input.txHash,\n        utxo.input.outputIndex,\n        utxo.output.amount,\n        utxo.output.address,\n        utxo.output.scriptRef ? utxo.output.scriptRef.length / 2 : 0,\n      );\n    }\n\n    for (let output of selectionSkeleton.newOutputs) {\n      this.txOut(output.address, output.amount);\n    }\n\n    for (let change of selectionSkeleton.change) {\n      this.txOut(change.address, change.amount);\n    }\n\n    this.meshTxBuilderBody.fee = selectionSkeleton.fee.toString();\n    this.queueAllLastItem();\n    this.removeDuplicateInputs();\n    this.sortTxParts();\n    this.updateRedeemer(\n      this.meshTxBuilderBody,\n      selectionSkeleton.redeemers ?? [],\n      final,\n    );\n  };\n\n  getUtxosForSelection = async () => {\n    const utxos = this.meshTxBuilderBody.extraInputs;\n    const usedUtxos = new Set(\n      this.meshTxBuilderBody.inputs.map(\n        (input) => `${input.txIn.txHash}${input.txIn.txIndex}`,\n      ),\n    );\n    return utxos.filter(\n      (utxo) => !usedUtxos.has(`${utxo.input.txHash}${utxo.input.outputIndex}`),\n    );\n  };\n\n  sortTxParts = () => {\n    this.sortInputs();\n    this.sortMints();\n    this.sortWithdrawals();\n    this.sortVotes();\n  };\n\n  sortInputs = () => {\n    // Sort inputs based on txHash and txIndex\n    this.meshTxBuilderBody.inputs.sort((a, b) => {\n      if (a.txIn.txHash < b.txIn.txHash) return -1;\n      if (a.txIn.txHash > b.txIn.txHash) return 1;\n      if (a.txIn.txIndex < b.txIn.txIndex) return -1;\n      if (a.txIn.txIndex > b.txIn.txIndex) return 1;\n      return 0;\n    });\n  };\n\n  sortMints = () => {\n    // Sort mints based on policy id\n    this.meshTxBuilderBody.mints.sort((a, b) => {\n      if (a.policyId < b.policyId) return -1;\n      if (a.policyId > b.policyId) return 1;\n      return 0;\n    });\n  };\n\n  protected compareCredentials = (\n    credentialA: CstCredential,\n    credentialB: CstCredential,\n  ): number => {\n    // Script credentials come before Key credentials\n    if (\n      credentialA.type === CstCredentialType.ScriptHash &&\n      credentialB.type === CstCredentialType.KeyHash\n    ) {\n      return -1;\n    }\n    if (\n      credentialA.type === CstCredentialType.KeyHash &&\n      credentialB.type === CstCredentialType.ScriptHash\n    ) {\n      return 1;\n    }\n    // If same type, compare the hashes\n    if (credentialA.type === credentialB.type) {\n      if (credentialA.hash < credentialB.hash) return -1;\n      if (credentialA.hash > credentialB.hash) return 1;\n      return 0;\n    }\n    return 0;\n  };\n\n  sortWithdrawals = () => {\n    this.meshTxBuilderBody.withdrawals.sort((a, b) => {\n      const credentialA = CstAddress.fromString(a.address)\n        ?.asReward()\n        ?.getPaymentCredential();\n      const credentialB = CstAddress.fromString(b.address)\n        ?.asReward()\n        ?.getPaymentCredential();\n      if (credentialA && credentialB) {\n        return this.compareCredentials(credentialA, credentialB);\n      }\n      return 0;\n    });\n  };\n\n  sortVotes = () => {\n    const variantOrder: Record<Voter[\"type\"], number> = {\n      ConstitutionalCommittee: 0,\n      DRep: 1,\n      StakingPool: 2,\n    };\n    this.meshTxBuilderBody.votes.sort((a, b) => {\n      const voterA = a.vote.voter;\n      const voterB = b.vote.voter;\n      const orderA = variantOrder[voterA.type];\n      const orderB = variantOrder[voterB.type];\n      if (orderA !== orderB) return orderA - orderB;\n\n      // Same variant, compare inner values\n      if (\n        voterA.type === \"ConstitutionalCommittee\" &&\n        voterB.type === \"ConstitutionalCommittee\"\n      ) {\n        const credA = voterA.hotCred;\n        const credB = voterB.hotCred;\n        // Script credentials come before Key credentials\n        if (credA.type === \"ScriptHash\" && credB.type === \"KeyHash\") {\n          return -1;\n        }\n        if (credA.type === \"KeyHash\" && credB.type === \"ScriptHash\") {\n          return 1;\n        }\n        // If same type, compare the hashes\n        if (credA.type === credB.type) {\n          const hashA =\n            credA.type === \"KeyHash\" ? credA.keyHash : credA.scriptHash;\n          const hashB =\n            credB.type === \"KeyHash\" ? credB.keyHash : credB.scriptHash;\n          if (hashA < hashB) return -1;\n          if (hashA > hashB) return 1;\n          return 0;\n        }\n        return 0;\n      }\n      if (voterA.type === \"DRep\" && voterB.type === \"DRep\") {\n        const drepA = coreToCstDRep(voterA.drepId);\n        const drepB = coreToCstDRep(voterB.drepId);\n        const scriptHashA = drepA.toScriptHash();\n        const scriptHashB = drepB.toScriptHash();\n        const keyHashA = drepA.toKeyHash();\n        const keyHashB = drepB.toKeyHash();\n\n        // Script hashes come before key hashes\n        if (scriptHashA != null && scriptHashB != null) {\n          if (scriptHashA < scriptHashB) return -1;\n          if (scriptHashA > scriptHashB) return 1;\n          return 0;\n        }\n        if (scriptHashA != null) return -1;\n        if (scriptHashB != null) return 1;\n        // If both are key hashes, compare them\n        if (keyHashA != null && keyHashB != null) {\n          if (keyHashA < keyHashB) return -1;\n          if (keyHashA > keyHashB) return 1;\n          return 0;\n        }\n        return 0;\n      }\n      if (voterA.type === \"StakingPool\" && voterB.type === \"StakingPool\") {\n        if (voterA.keyHash < voterB.keyHash) return -1;\n        if (voterA.keyHash > voterB.keyHash) return 1;\n        return 0;\n      }\n      return 0;\n    });\n  };\n\n  evaluateRedeemers = async () => {\n    let txHex = this.serializer.serializeTxBody(\n      this.meshTxBuilderBody,\n      this._protocolParams,\n    );\n    if (this.evaluator) {\n      const txEvaluation = await this.evaluator\n        .evaluateTx(\n          txHex,\n          Object.values(this.meshTxBuilderBody.inputsForEvaluation),\n          this.meshTxBuilderBody.chainedTxs,\n        )\n        .catch((error) => {\n          if (error instanceof Error) {\n            throw new Error(\n              `Tx evaluation failed: ${error.message} \\n For txHex: ${txHex}`,\n            );\n          } else if (typeof error === \"string\") {\n            throw new Error(\n              `Tx evaluation failed: ${error} \\n For txHex: ${txHex}`,\n            );\n          } else if (typeof error === \"object\") {\n            throw new Error(\n              `Tx evaluation failed: ${JSON.stringify(error)} \\n For txHex: ${txHex}`,\n            );\n          } else {\n            throw new Error(\n              `Tx evaluation failed: ${String(error)} \\n For txHex: ${txHex}`,\n            );\n          }\n        });\n      this.updateRedeemer(this.meshTxBuilderBody, txEvaluation);\n    }\n  };\n\n  protected getRedeemerCosts = () => {\n    const meshTxBuilderBody = this.meshTxBuilderBody;\n    const redeemers: Omit<Action, \"data\">[] = [];\n    for (let i = 0; i < meshTxBuilderBody.inputs.length; i++) {\n      const input = meshTxBuilderBody.inputs[i]!;\n      if (input.type == \"Script\" && input.scriptTxIn.redeemer) {\n        redeemers.push({\n          tag: \"SPEND\",\n          index: i,\n          budget: structuredClone(input.scriptTxIn.redeemer.exUnits),\n        });\n      }\n    }\n    for (let i = 0; i < meshTxBuilderBody.mints.length; i++) {\n      const mint = meshTxBuilderBody.mints[i]!;\n      if (mint.type == \"Plutus\" && mint.redeemer) {\n        redeemers.push({\n          tag: \"MINT\",\n          index: i,\n          budget: structuredClone(mint.redeemer.exUnits),\n        });\n      }\n    }\n    for (let i = 0; i < meshTxBuilderBody.certificates.length; i++) {\n      const cert = meshTxBuilderBody.certificates[i]!;\n      if (cert.type === \"ScriptCertificate\" && cert.redeemer) {\n        redeemers.push({\n          tag: \"CERT\",\n          index: i,\n          budget: structuredClone(cert.redeemer.exUnits),\n        });\n      }\n    }\n    for (let i = 0; i < meshTxBuilderBody.withdrawals.length; i++) {\n      const withdrawal = meshTxBuilderBody.withdrawals[i]!;\n      if (withdrawal.type === \"ScriptWithdrawal\" && withdrawal.redeemer) {\n        redeemers.push({\n          tag: \"REWARD\",\n          index: i,\n          budget: structuredClone(withdrawal.redeemer.exUnits),\n        });\n      }\n    }\n    for (let i = 0; i < meshTxBuilderBody.votes.length; i++) {\n      const vote = meshTxBuilderBody.votes[i]!;\n      if (vote.type === \"ScriptVote\" && vote.redeemer) {\n        redeemers.push({\n          tag: \"VOTE\",\n          index: i,\n          budget: structuredClone(vote.redeemer.exUnits),\n        });\n      }\n    }\n    return redeemers;\n  };\n\n  /**\n   * It builds the transaction without dependencies\n   * @param customizedTx The optional customized transaction body\n   * @returns The transaction in hex, unbalanced\n   */\n  completeUnbalancedSync = (customizedTx?: MeshTxBuilderBody) => {\n    if (customizedTx) {\n      this.meshTxBuilderBody = customizedTx;\n      if (customizedTx.fee) {\n        this.setFee(customizedTx.fee);\n      }\n    } else {\n      this.queueAllLastItem();\n    }\n    this.removeDuplicateInputs();\n    this.removeDuplicateRefInputs();\n    return this.serializer.serializeTxBody(\n      this.meshTxBuilderBody,\n      this._protocolParams,\n    );\n  };\n\n  /**\n   * Complete the signing process\n   * @returns The signed transaction in hex\n   */\n  completeSigning = () => {\n    const signedTxHex = this.serializer.addSigningKeys(\n      this.txHex,\n      this.meshTxBuilderBody.signingKey,\n    );\n    this.txHex = signedTxHex;\n    return signedTxHex;\n  };\n\n  /**\n   * Submit transactions to the blockchain using the fetcher instance\n   * @param txHex The signed transaction in hex\n   * @returns\n   */\n  submitTx = async (txHex: string): Promise<string | undefined> => {\n    const txHash = await this.submitter?.submitTx(txHex);\n    return txHash;\n  };\n\n  /**\n   * Get the UTxO information from the blockchain\n   * @param txHash The TxIn object that contains the txHash and txIndex, while missing amount and address information\n   */\n  protected getUTxOInfo = async (txHash: string): Promise<void> => {\n    let utxos: UTxO[] = [];\n    if (!this.queriedTxHashes.has(txHash)) {\n      this.queriedTxHashes.add(txHash);\n      utxos = (await this.fetcher?.fetchUTxOs(txHash)) || [];\n      this.queriedUTxOs[txHash] = utxos;\n    }\n  };\n\n  protected queryAllTxInfo = (\n    incompleteTxIns: TxIn[],\n    incompleteScriptSources: ScriptSource[],\n    incompleteSimpleScriptSources: SimpleScriptSourceInfo[],\n  ) => {\n    const queryUTxOPromises: Promise<void>[] = [];\n    if (\n      (incompleteTxIns.length > 0 ||\n        incompleteScriptSources.length > 0 ||\n        incompleteSimpleScriptSources.length) &&\n      !this.fetcher\n    )\n      throw Error(\n        \"Transaction information is incomplete while no fetcher instance is provided. Provide a `fetcher`.\",\n      );\n    for (let i = 0; i < incompleteTxIns.length; i++) {\n      const currentTxIn = incompleteTxIns[i]!;\n      if (!this.isInputInfoComplete(currentTxIn)) {\n        queryUTxOPromises.push(this.getUTxOInfo(currentTxIn.txIn.txHash));\n      }\n    }\n    for (let i = 0; i < incompleteScriptSources.length; i++) {\n      const scriptSource = incompleteScriptSources[i]!;\n      if (scriptSource.type === \"Inline\") {\n        queryUTxOPromises.push(this.getUTxOInfo(scriptSource.txHash));\n      }\n    }\n    return Promise.all(queryUTxOPromises);\n  };\n\n  protected completeTxInformation = (input: TxIn) => {\n    // Adding value and address information for inputs if missing\n    if (!this.isInputInfoComplete(input)) {\n      this.completeInputInfo(input);\n    }\n    // Adding spendingScriptHash for script inputs' scriptSource if missing\n    if (\n      input.type === \"Script\" &&\n      !this.isRefScriptInfoComplete(input.scriptTxIn.scriptSource!)\n    ) {\n      const scriptSource = input.scriptTxIn.scriptSource;\n      this.completeScriptInfo(scriptSource!);\n    }\n  };\n\n  protected completeInputInfo = (input: TxIn) => {\n    const utxos: UTxO[] = this.queriedUTxOs[input.txIn.txHash]!;\n    const utxo = utxos?.find(\n      (utxo) => utxo.input.outputIndex === input.txIn.txIndex,\n    );\n    const amount = utxo?.output.amount;\n    const address = utxo?.output.address;\n    if (!amount || amount.length === 0)\n      throw Error(\n        `Couldn't find value information for ${input.txIn.txHash}#${input.txIn.txIndex}`,\n      );\n    input.txIn.amount = amount;\n\n    if (!address || address === \"\")\n      throw Error(\n        `Couldn't find address information for ${input.txIn.txHash}#${input.txIn.txIndex}`,\n      );\n    input.txIn.address = address;\n\n    if (utxo?.output.scriptRef) {\n      input.txIn.scriptSize = utxo.output.scriptRef.length / 2;\n    } else {\n      input.txIn.scriptSize = 0;\n    }\n  };\n\n  protected completeScriptInfo = (scriptSource: ScriptSource) => {\n    if (scriptSource?.type != \"Inline\") return;\n    const refUtxos = this.queriedUTxOs[scriptSource.txHash]!;\n    const scriptRefUtxo = refUtxos.find(\n      (utxo) => utxo.input.outputIndex === scriptSource.txIndex,\n    );\n    if (!scriptRefUtxo)\n      throw Error(\n        `Couldn't find script reference utxo for ${scriptSource.txHash}#${scriptSource.txIndex}`,\n      );\n    scriptSource.scriptHash = scriptRefUtxo?.output.scriptHash!;\n    scriptSource.scriptSize = (\n      scriptRefUtxo?.output.scriptRef!.length / 2\n    ).toString();\n  };\n\n  protected completeSimpleScriptInfo = (\n    simpleScript: SimpleScriptSourceInfo,\n  ) => {\n    if (simpleScript.type !== \"Inline\") return;\n    const refUtxos = this.queriedUTxOs[simpleScript.txHash]!;\n    const scriptRefUtxo = refUtxos.find(\n      (utxo) => utxo.input.outputIndex === simpleScript.txIndex,\n    );\n    if (!scriptRefUtxo)\n      throw Error(\n        `Couldn't find script reference utxo for ${simpleScript.txHash}#${simpleScript.txIndex}`,\n      );\n    simpleScript.simpleScriptHash = scriptRefUtxo?.output.scriptHash!;\n  };\n\n  protected isInputComplete = (txIn: TxIn): boolean => {\n    if (txIn.type === \"PubKey\") return this.isInputInfoComplete(txIn);\n    if (txIn.type === \"Script\") {\n      const { scriptSource } = txIn.scriptTxIn;\n      return (\n        this.isInputInfoComplete(txIn) &&\n        this.isRefScriptInfoComplete(scriptSource!)\n      );\n    }\n    return true;\n  };\n\n  protected isInputInfoComplete = (txIn: TxIn): boolean => {\n    const { amount, address, scriptSize } = txIn.txIn;\n    if (!amount || !address || scriptSize === undefined) return false;\n    return true;\n  };\n\n  protected isMintComplete = (mint: MintItem): boolean => {\n    if (mint.type === \"Plutus\") {\n      const scriptSource = mint.scriptSource as ScriptSource;\n      return this.isRefScriptInfoComplete(scriptSource);\n    }\n    if (mint.type === \"Native\") {\n      const scriptSource = mint.scriptSource as SimpleScriptSourceInfo;\n      if (scriptSource.type === \"Inline\") {\n        if (!scriptSource?.simpleScriptHash) return false;\n      }\n    }\n    return true;\n  };\n\n  protected isRefScriptInfoComplete = (scriptSource: ScriptSource): boolean => {\n    if (scriptSource?.type === \"Inline\") {\n      if (!scriptSource?.scriptHash || !scriptSource?.scriptSize) return false;\n    }\n    return true;\n  };\n\n  protected isSimpleRefScriptInfoComplete = (\n    simpleScriptSource: SimpleScriptSourceInfo,\n  ): boolean => {\n    if (simpleScriptSource.type === \"Inline\") {\n      if (\n        !simpleScriptSource.simpleScriptHash ||\n        !simpleScriptSource.scriptSize\n      )\n        return false;\n    }\n    return true;\n  };\n\n  protected completeSerialization = async (\n    customizedTx?: Partial<MeshTxBuilderBody>,\n  ) => {\n    if (customizedTx) {\n      this.meshTxBuilderBody = { ...this.meshTxBuilderBody, ...customizedTx };\n    } else {\n      this.queueAllLastItem();\n    }\n    this.removeDuplicateInputs();\n    this.removeDuplicateRefInputs();\n\n    // We can set scriptSize of collaterals as 0, because the ledger ignores this for fee calculations\n    for (let collateral of this.meshTxBuilderBody.collaterals) {\n      collateral.txIn.scriptSize = 0;\n    }\n\n    await this.completeTxParts();\n\n    let txHex = this.serializer.serializeTxBody(\n      this.meshTxBuilderBody,\n      this._protocolParams,\n    );\n\n    // Evaluating the transaction\n    if (this.evaluator) {\n      const txEvaluation = await this.evaluator\n        .evaluateTx(\n          txHex,\n          Object.values(this.meshTxBuilderBody.inputsForEvaluation) as UTxO[],\n          this.meshTxBuilderBody.chainedTxs,\n        )\n        .catch((error) => {\n          throw new Error(\n            `Tx evaluation failed: ${JSON.stringify(error)} \\n For txHex: ${txHex}`,\n          );\n        });\n      this.updateRedeemer(this.meshTxBuilderBody, txEvaluation);\n      txHex = this.serializer.serializeTxBody(\n        this.meshTxBuilderBody,\n        this._protocolParams,\n      );\n    }\n\n    this.txHex = txHex;\n    return txHex;\n  };\n\n  protected completeTxParts = async (): Promise<void> => {\n    // Checking if all inputs are complete\n    const { inputs, collaterals, mints, withdrawals, votes, certificates } =\n      this.meshTxBuilderBody;\n    const incompleteTxIns = [...inputs, ...collaterals].filter(\n      (txIn) => !this.isInputComplete(txIn),\n    );\n    let incompleteScriptSources: ScriptSource[] = [];\n    let incompleteSimpleScriptSources: SimpleScriptSourceInfo[] = [];\n\n    // Get incomplete script sources for inputs\n    inputs.forEach((txIn) => {\n      if (\n        txIn.type === \"Script\" &&\n        txIn.scriptTxIn.scriptSource?.type === \"Inline\"\n      ) {\n        if (!this.isRefScriptInfoComplete(txIn.scriptTxIn.scriptSource!)) {\n          incompleteScriptSources.push(txIn.scriptTxIn.scriptSource);\n        }\n      } else if (\n        txIn.type === \"SimpleScript\" &&\n        txIn.simpleScriptTxIn?.scriptSource?.type === \"Inline\"\n      ) {\n        if (\n          !this.isSimpleRefScriptInfoComplete(\n            txIn.simpleScriptTxIn.scriptSource!,\n          )\n        ) {\n          incompleteSimpleScriptSources.push(\n            txIn.simpleScriptTxIn.scriptSource,\n          );\n        }\n      }\n    });\n\n    // Get incomplete script sources for mints\n    mints.forEach((mint) => {\n      if (mint.type === \"Plutus\") {\n        const scriptSource = mint.scriptSource as ScriptSource;\n        if (!this.isRefScriptInfoComplete(scriptSource)) {\n          incompleteScriptSources.push(scriptSource);\n        }\n      } else if (mint.type === \"Native\") {\n        const scriptSource = mint.scriptSource as SimpleScriptSourceInfo;\n        if (!this.isSimpleRefScriptInfoComplete(scriptSource)) {\n          incompleteSimpleScriptSources.push(scriptSource);\n        }\n      }\n    });\n\n    // Get incomplete script sources for withdrawals\n    withdrawals.forEach((withdrawal) => {\n      if (withdrawal.type === \"ScriptWithdrawal\") {\n        const scriptSource = withdrawal.scriptSource as ScriptSource;\n        if (!this.isRefScriptInfoComplete(scriptSource)) {\n          incompleteScriptSources.push(scriptSource);\n        }\n      } else if (withdrawal.type === \"SimpleScriptWithdrawal\") {\n        const scriptSource = withdrawal.scriptSource as SimpleScriptSourceInfo;\n        if (!this.isSimpleRefScriptInfoComplete(scriptSource)) {\n          incompleteSimpleScriptSources.push(scriptSource);\n        }\n      }\n    });\n\n    // Get incomplete script sources for votes\n    votes.forEach((vote) => {\n      if (vote.type === \"ScriptVote\") {\n        const scriptSource = vote.scriptSource as ScriptSource;\n        if (!this.isRefScriptInfoComplete(scriptSource)) {\n          incompleteScriptSources.push(scriptSource);\n        }\n      } else if (vote.type === \"SimpleScriptVote\") {\n        const scriptSource = vote.simpleScriptSource as SimpleScriptSourceInfo;\n        if (!this.isSimpleRefScriptInfoComplete(scriptSource)) {\n          incompleteSimpleScriptSources.push(scriptSource);\n        }\n      }\n    });\n\n    // Get incomplete script sources for certificates\n    certificates.forEach((certificate) => {\n      if (certificate.type === \"ScriptCertificate\") {\n        const scriptSource = certificate.scriptSource as ScriptSource;\n        if (!this.isRefScriptInfoComplete(scriptSource)) {\n          incompleteScriptSources.push(scriptSource);\n        }\n      } else if (certificate.type === \"SimpleScriptCertificate\") {\n        const scriptSource =\n          certificate.simpleScriptSource as SimpleScriptSourceInfo;\n        if (!this.isSimpleRefScriptInfoComplete(scriptSource)) {\n          incompleteSimpleScriptSources.push(scriptSource);\n        }\n      }\n    });\n\n    // Getting all missing utxo information\n    await this.queryAllTxInfo(\n      incompleteTxIns,\n      incompleteScriptSources,\n      incompleteSimpleScriptSources,\n    );\n    // Completing all inputs\n    incompleteTxIns.forEach((txIn) => {\n      this.completeTxInformation(txIn);\n    });\n\n    // Completing all script sources\n    incompleteScriptSources.forEach((scriptSource) => {\n      this.completeScriptInfo(scriptSource);\n    });\n\n    // Completing all simple script sources\n    incompleteSimpleScriptSources.forEach((simpleScriptSource) => {\n      this.completeSimpleScriptInfo(simpleScriptSource);\n    });\n\n    this.meshTxBuilderBody.inputs.forEach((input) => {\n      if (input.txIn.scriptSize && input.txIn.scriptSize > 0) {\n        if (\n          this.meshTxBuilderBody.referenceInputs.find((refTxIn) => {\n            refTxIn.txHash === input.txIn.txHash &&\n              refTxIn.txIndex === input.txIn.txIndex;\n          }) === undefined\n        ) {\n          this.meshTxBuilderBody.referenceInputs.push({\n            txHash: input.txIn.txHash,\n            txIndex: input.txIn.txIndex,\n            scriptSize: input.txIn.scriptSize,\n          });\n        }\n      }\n    });\n    this.addUtxosFromSelection();\n\n    // Sort inputs based on txHash and txIndex\n    this.sortTxParts();\n  };\n\n  protected sanitizeOutputs = async () => {\n    this.meshTxBuilderBody.outputs.forEach((output) => {\n      let lovelaceFound = false;\n      output.amount.forEach((asset) => {\n        if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n          lovelaceFound = true;\n        }\n      });\n      if (!lovelaceFound) {\n        const minAda = this.calculateMinLovelaceForOutput(output);\n        output.amount.push({\n          unit: \"lovelace\",\n          quantity: minAda.toString(),\n        });\n      }\n    });\n  };\n\n  protected collectAllRequiredSignatures = (): {\n    keyHashes: Set<string>;\n    byronAddresses: Set<string>;\n  } => {\n    const { paymentCreds, byronAddresses } = this.getInputsRequiredSignatures();\n    const { collateralPaymentCreds, collateralByronAddresses } =\n      this.getCollateralRequiredSignatures();\n    const withdrawalCreds = this.getWithdrawalRequiredSignatures();\n    const certCreds = this.getCertificatesRequiredSignatures();\n    const voteCreds = this.getVoteRequiredSignatures();\n    const mintCreds = this.getMintRequiredSignatures();\n    const requiredSignatures = this.meshTxBuilderBody.requiredSignatures;\n    const allCreds = new Set([\n      ...paymentCreds,\n      ...withdrawalCreds,\n      ...collateralPaymentCreds,\n      ...certCreds,\n      ...voteCreds,\n      ...requiredSignatures,\n      ...mintCreds,\n    ]);\n    const allByronAddresses = new Set([\n      ...byronAddresses,\n      ...collateralByronAddresses,\n    ]);\n    return { keyHashes: allCreds, byronAddresses: allByronAddresses };\n  };\n\n  protected getInputsRequiredSignatures(): {\n    paymentCreds: Set<string>;\n    byronAddresses: Set<string>;\n  } {\n    const byronAddresses = new Set<string>();\n    const paymentCreds = new Set<string>();\n    for (let input of this.meshTxBuilderBody.inputs) {\n      if (input.type === \"PubKey\") {\n        if (input.txIn.address) {\n          const address = CstAddress.fromString(input.txIn.address);\n          if (!address) {\n            continue;\n          }\n          const addressDetails = address.getProps();\n          const paymentCred = addressDetails.paymentPart;\n          if (paymentCred?.type === CstCredentialType.KeyHash) {\n            paymentCreds.add(paymentCred.hash);\n          }\n          if (addressDetails.type === CstAddressType.Byron) {\n            byronAddresses.add(input.txIn.address);\n          }\n        }\n      } else if (input.type === \"SimpleScript\") {\n        const nativeScript = this.getInputNativeScript(input);\n        if (nativeScript) {\n          let pubKeys = this.getNativeScriptPubKeys(nativeScript);\n          for (let pubKey of pubKeys) {\n            paymentCreds.add(pubKey);\n          }\n        }\n      }\n    }\n    return { paymentCreds, byronAddresses };\n  }\n\n  protected getCollateralRequiredSignatures(): {\n    collateralPaymentCreds: Set<string>;\n    collateralByronAddresses: Set<string>;\n  } {\n    const collateralByronAddresses = new Set<string>();\n    const collateralPaymentCreds = new Set<string>();\n    for (let collateral of this.meshTxBuilderBody.collaterals) {\n      if (collateral.type === \"PubKey\") {\n        if (collateral.txIn.address) {\n          const address = CstAddress.fromString(collateral.txIn.address);\n          if (!address) {\n            continue;\n          }\n          const addressDetails = address.getProps();\n          const paymentCred = addressDetails.paymentPart;\n          if (paymentCred?.type === CstCredentialType.KeyHash) {\n            collateralPaymentCreds.add(paymentCred.hash);\n          }\n          if (addressDetails.type === CstAddressType.Byron) {\n            collateralByronAddresses.add(collateral.txIn.address);\n          }\n        }\n      }\n    }\n    return { collateralPaymentCreds, collateralByronAddresses };\n  }\n\n  protected getWithdrawalRequiredSignatures(): Set<string> {\n    const withdrawalCreds = new Set<string>();\n    for (let withdrawal of this.meshTxBuilderBody.withdrawals) {\n      if (withdrawal.type === \"PubKeyWithdrawal\") {\n        const address = CstAddress.fromBech32(withdrawal.address);\n        const addressDetails = address.getProps();\n        const paymentCred = addressDetails.paymentPart;\n        if (paymentCred?.type === CstCredentialType.KeyHash) {\n          withdrawalCreds.add(paymentCred.hash);\n        }\n      }\n      if (withdrawal.type === \"SimpleScriptWithdrawal\") {\n        const nativeScript = this.getWithdrawalNativeScript(withdrawal);\n        if (nativeScript) {\n          let pubKeys = this.getNativeScriptPubKeys(nativeScript);\n          for (let pubKey of pubKeys) {\n            withdrawalCreds.add(pubKey);\n          }\n        }\n      }\n    }\n    return withdrawalCreds;\n  }\n\n  protected getCertificatesRequiredSignatures(): Set<string> {\n    const certCreds = new Set<string>();\n    for (let cert of this.meshTxBuilderBody.certificates) {\n      if (\n        cert.type !== \"BasicCertificate\" &&\n        cert.type !== \"SimpleScriptCertificate\"\n      ) {\n        continue;\n      }\n\n      const certNativeScript = this.getCertificateNativeScript(cert);\n\n      const certType = cert.certType;\n\n      if (certType.type === \"RegisterPool\") {\n        certCreds.add(certType.poolParams.operator);\n        for (let owner of certType.poolParams.owners) {\n          certCreds.add(owner);\n        }\n      } else if (certType.type === \"RetirePool\") {\n        certCreds.add(certType.poolId);\n      } else if (\n        certType.type === \"DRepRegistration\" ||\n        certType.type === \"DRepDeregistration\" ||\n        certType.type === \"DRepUpdate\"\n      ) {\n        if (cert.type === \"BasicCertificate\") {\n          const cstDrep = coreToCstDRep(certType.drepId);\n          const keyHash = cstDrep.toKeyHash();\n          if (keyHash) {\n            certCreds.add(keyHash);\n          }\n        } else if (certNativeScript) {\n          let pubKeys = this.getNativeScriptPubKeys(certNativeScript);\n          for (let pubKey of pubKeys) {\n            certCreds.add(pubKey);\n          }\n        }\n      } else if (\n        certType.type === \"StakeRegistrationAndDelegation\" ||\n        certType.type === \"VoteRegistrationAndDelegation\" ||\n        certType.type === \"StakeVoteRegistrationAndDelegation\" ||\n        certType.type === \"VoteDelegation\" ||\n        certType.type === \"RegisterStake\" ||\n        certType.type === \"StakeAndVoteDelegation\" ||\n        certType.type === \"DelegateStake\" ||\n        certType.type === \"DeregisterStake\"\n      ) {\n        if (cert.type === \"BasicCertificate\") {\n          const address = CstAddress.fromString(certType.stakeKeyAddress);\n          if (address) {\n            const addressDetails = address.getProps();\n            const paymentCred = addressDetails.paymentPart;\n            if (paymentCred?.type === CstCredentialType.KeyHash) {\n              certCreds.add(paymentCred.hash);\n            }\n          }\n        } else if (certNativeScript) {\n          let pubKeys = this.getNativeScriptPubKeys(certNativeScript);\n          for (let pubKey of pubKeys) {\n            certCreds.add(pubKey);\n          }\n        }\n      } else if (\n        certType.type === \"CommitteeHotAuth\" ||\n        certType.type === \"CommitteeColdResign\"\n      ) {\n        if (cert.type === \"BasicCertificate\") {\n          const address = CstAddress.fromString(\n            certType.committeeColdKeyAddress,\n          );\n          if (address) {\n            const addressDetails = address.getProps();\n            const paymentCred = addressDetails.paymentPart;\n            if (paymentCred?.type === CstCredentialType.KeyHash) {\n              certCreds.add(paymentCred.hash);\n            }\n          }\n        } else if (certNativeScript) {\n          let pubKeys = this.getNativeScriptPubKeys(certNativeScript);\n          for (let pubKey of pubKeys) {\n            certCreds.add(pubKey);\n          }\n        }\n      }\n    }\n    return certCreds;\n  }\n\n  protected getVoteRequiredSignatures(): Set<string> {\n    const voteCreds = new Set<string>();\n    for (let vote of this.meshTxBuilderBody.votes) {\n      if (vote.type !== \"SimpleScriptVote\") {\n        const nativeScript = this.getVoteNativeScript(vote);\n        if (nativeScript) {\n          let pubKeys = this.getNativeScriptPubKeys(nativeScript);\n          for (let pubKey of pubKeys) {\n            voteCreds.add(pubKey);\n          }\n        } else if (vote.type === \"BasicVote\") {\n          const voter = vote.vote.voter;\n          if (voter.type === \"DRep\") {\n            const drep = coreToCstDRep(voter.drepId);\n            const keyHash = drep.toKeyHash();\n            if (keyHash) {\n              voteCreds.add(keyHash);\n            }\n          } else if (voter.type === \"StakingPool\") {\n            voteCreds.add(voter.keyHash);\n          } else if (voter.type === \"ConstitutionalCommittee\") {\n            const hotCred = voter.hotCred;\n            if (hotCred.type === \"KeyHash\") {\n              voteCreds.add(hotCred.keyHash);\n            }\n          }\n        }\n      }\n    }\n    return voteCreds;\n  }\n\n  protected getMintRequiredSignatures = (): Set<string> => {\n    const mintCreds = new Set<string>();\n    for (let mint of this.meshTxBuilderBody.mints) {\n      if (mint.type === \"Native\") {\n        const nativeScript = this.getMintNativeScript(mint);\n        if (nativeScript) {\n          let pubKeys = this.getNativeScriptPubKeys(nativeScript);\n          for (let pubKey of pubKeys) {\n            mintCreds.add(pubKey);\n          }\n        }\n      }\n    }\n    return mintCreds;\n  };\n\n  protected getTotalWithdrawal = (): bigint => {\n    let accum = 0n;\n    for (let withdrawal of this.meshTxBuilderBody.withdrawals) {\n      accum += BigInt(withdrawal.coin);\n    }\n    return accum;\n  };\n\n  protected getTotalDeposit = () => {\n    let accum = 0n;\n    for (let cert of this.meshTxBuilderBody.certificates) {\n      const certType = cert.certType;\n      if (certType.type === \"RegisterStake\") {\n        if (cert.certType) {\n          accum += BigInt(this._protocolParams.keyDeposit);\n        }\n      } else if (certType.type === \"RegisterPool\") {\n        accum += BigInt(this._protocolParams.poolDeposit);\n      } else if (certType.type === \"DRepRegistration\") {\n        accum += BigInt(certType.coin);\n      } else if (certType.type === \"StakeRegistrationAndDelegation\") {\n        accum += BigInt(certType.coin);\n      } else if (certType.type === \"VoteRegistrationAndDelegation\") {\n        accum += BigInt(certType.coin);\n      } else if (certType.type === \"StakeVoteRegistrationAndDelegation\") {\n        accum += BigInt(certType.coin);\n      }\n    }\n    return accum;\n  };\n\n  protected getTotalRefund = (): bigint => {\n    let accum = 0n;\n    for (let cert of this.meshTxBuilderBody.certificates) {\n      const certType = cert.certType;\n      if (certType.type === \"DeregisterStake\") {\n        if (cert.certType) {\n          accum += BigInt(this._protocolParams.keyDeposit);\n        }\n      } else if (certType.type === \"DRepDeregistration\") {\n        accum += BigInt(certType.coin);\n      }\n    }\n    return accum;\n  };\n\n  protected getTotalMint = (): Asset[] => {\n    const assets = new Map<string, bigint>();\n    for (let mint of this.meshTxBuilderBody.mints) {\n      for (let assetValue of mint.mintValue) {\n        const assetId = `${mint.policyId}${assetValue.assetName}`;\n        let amount = assets.get(assetId) ?? 0n;\n        amount += BigInt(assetValue.amount);\n        assets.set(assetId, amount);\n      }\n    }\n    return Array.from(assets).map(([assetId, amount]) => ({\n      unit: assetId,\n      quantity: amount.toString(),\n    }));\n  };\n\n  protected getNativeScriptPubKeys = (\n    nativeScript: CstNativeScript,\n  ): Set<string> => {\n    const pubKeys = new Set<string>();\n    const nativeScriptStack = [];\n    nativeScriptStack.push(nativeScript);\n    while (nativeScriptStack.length > 0) {\n      const script = nativeScriptStack.pop();\n      if (script === undefined) {\n        continue;\n      }\n      const nOfK = script.asScriptNOfK();\n      if (nOfK) {\n        for (let script of nOfK.nativeScripts()) {\n          nativeScriptStack.push(script);\n        }\n      }\n      const scriptAll = script.asScriptAll();\n      if (scriptAll) {\n        for (let script of scriptAll.nativeScripts()) {\n          nativeScriptStack.push(script);\n        }\n      }\n      const scriptAny = script.asScriptAny();\n      if (scriptAny) {\n        for (let script of scriptAny.nativeScripts()) {\n          nativeScriptStack.push(script);\n        }\n      }\n      const scriptPubkey = script.asScriptPubkey();\n      if (scriptPubkey) {\n        pubKeys.add(scriptPubkey.keyHash());\n      }\n    }\n    return pubKeys;\n  };\n\n  protected getVoteNativeScript = (cert: Vote): CstNativeScript | undefined => {\n    if (cert.type !== \"SimpleScriptVote\") {\n      return undefined;\n    }\n\n    const scriptSource = cert.simpleScriptSource;\n    if (scriptSource === undefined) {\n      return undefined;\n    }\n\n    if (scriptSource.type === \"Inline\") {\n      return this.getInlinedNativeScript(\n        scriptSource.txHash,\n        scriptSource.txIndex,\n      );\n    }\n    if (scriptSource.type === \"Provided\") {\n      return CstNativeScript.fromCbor(\n        <CardanoSDKUtil.HexBlob>scriptSource.scriptCode,\n      );\n    }\n  };\n\n  protected getCertificateNativeScript = (\n    cert: Certificate,\n  ): CstNativeScript | undefined => {\n    if (cert.type !== \"SimpleScriptCertificate\") {\n      return undefined;\n    }\n\n    const scriptSource = cert.simpleScriptSource;\n    if (scriptSource === undefined) {\n      return undefined;\n    }\n\n    if (scriptSource.type === \"Inline\") {\n      return this.getInlinedNativeScript(\n        scriptSource.txHash,\n        scriptSource.txIndex,\n      );\n    }\n    if (scriptSource.type === \"Provided\") {\n      return CstNativeScript.fromCbor(\n        <CardanoSDKUtil.HexBlob>scriptSource.scriptCode,\n      );\n    }\n  };\n\n  protected getMintNativeScript = (\n    mint: MintParam,\n  ): CstNativeScript | undefined => {\n    if (mint.type !== \"Native\") {\n      return undefined;\n    }\n\n    const scriptSource = mint.scriptSource as SimpleScriptSourceInfo;\n    const scriptSourceAlternative = mint.scriptSource as ScriptSource;\n    if (scriptSource === undefined) {\n      return undefined;\n    }\n\n    if (scriptSource.type === \"Inline\") {\n      return this.getInlinedNativeScript(\n        scriptSource.txHash,\n        scriptSource.txIndex,\n      );\n    }\n    if (scriptSource.type === \"Provided\") {\n      if (scriptSource.scriptCode != undefined) {\n        return CstNativeScript.fromCbor(\n          <CardanoSDKUtil.HexBlob>scriptSource.scriptCode,\n        );\n      }\n    }\n\n    if (scriptSourceAlternative.type === \"Provided\") {\n      if (scriptSourceAlternative.script != undefined) {\n        return CstNativeScript.fromCbor(\n          <CardanoSDKUtil.HexBlob>scriptSourceAlternative.script.code,\n        );\n      }\n    }\n  };\n\n  protected getWithdrawalNativeScript = (\n    withdrawal: Withdrawal,\n  ): CstNativeScript | undefined => {\n    if (withdrawal.type !== \"SimpleScriptWithdrawal\") {\n      return undefined;\n    }\n\n    const scriptSource = withdrawal.scriptSource;\n    if (scriptSource === undefined) {\n      return undefined;\n    }\n\n    if (scriptSource.type === \"Inline\") {\n      return this.getInlinedNativeScript(\n        scriptSource.txHash,\n        scriptSource.txIndex,\n      );\n    }\n    if (scriptSource.type === \"Provided\") {\n      return CstNativeScript.fromCbor(\n        <CardanoSDKUtil.HexBlob>scriptSource.scriptCode,\n      );\n    }\n  };\n\n  protected getInputNativeScript(txIn: TxIn): CstNativeScript | undefined {\n    if (txIn.type !== \"SimpleScript\") {\n      return undefined;\n    }\n\n    const scriptSource = txIn.simpleScriptTxIn.scriptSource;\n    if (scriptSource === undefined) {\n      return undefined;\n    }\n\n    if (scriptSource.type === \"Inline\") {\n      return this.getInlinedNativeScript(\n        scriptSource.txHash,\n        scriptSource.txIndex,\n      );\n    }\n    if (scriptSource.type === \"Provided\") {\n      return CstNativeScript.fromCbor(\n        <CardanoSDKUtil.HexBlob>scriptSource.scriptCode,\n      );\n    }\n  }\n\n  protected getInlinedNativeScript = (\n    txHash: string,\n    index: number,\n  ): CstNativeScript | undefined => {\n    const utxos = this.queriedUTxOs[txHash];\n    if (!utxos) {\n      return undefined;\n    }\n\n    const utxo = utxos.find((utxo) => utxo.input.outputIndex === index);\n    if (utxo?.output.scriptRef) {\n      const script = CstScript.fromCbor(\n        <CardanoSDKUtil.HexBlob>utxo.output.scriptRef,\n      );\n      return script.asNative();\n    }\n    return undefined;\n  };\n\n  protected makeTxId = (txHash: string, index: number): string => {\n    return `${txHash}-${index}`;\n  };\n\n  protected getTotalReferenceInputsSize = (): bigint => {\n    let accum = 0n;\n    const allReferenceInputs = this.getAllReferenceInputsSizes();\n    for (const [_, scriptSize] of allReferenceInputs) {\n      accum += scriptSize;\n    }\n    return accum;\n  };\n\n  protected getAllReferenceInputsSizes = (): Map<string, bigint> => {\n    const referenceInputs = new Map<string, bigint>();\n    const bodyReferenceInputs = this.getBodyReferenceInputsSizes();\n    for (const [txId, scriptSize] of bodyReferenceInputs) {\n      referenceInputs.set(txId, scriptSize);\n    }\n    const inputsReferenceInputs = this.getInputsReferenceInputsSizes();\n    for (const [txId, scriptSize] of inputsReferenceInputs) {\n      referenceInputs.set(txId, scriptSize);\n    }\n    const mintsReferenceInputs = this.getMintsReferenceInputsSizes();\n    for (const [txId, scriptSize] of mintsReferenceInputs) {\n      referenceInputs.set(txId, scriptSize);\n    }\n    const withdrawalsReferenceInputs =\n      this.getWithdrawalsReferenceInputsSizes();\n    for (const [txId, scriptSize] of withdrawalsReferenceInputs) {\n      referenceInputs.set(txId, scriptSize);\n    }\n    const votesReferenceInputs = this.getVotesReferenceInputsSizes();\n    for (const [txId, scriptSize] of votesReferenceInputs) {\n      referenceInputs.set(txId, scriptSize);\n    }\n    const certificatesReferenceInputs =\n      this.getCertificatesReferenceInputsSizes();\n    for (const [txId, scriptSize] of certificatesReferenceInputs) {\n      referenceInputs.set(txId, scriptSize);\n    }\n    return referenceInputs;\n  };\n\n  protected getBodyReferenceInputsSizes = (): [string, bigint][] => {\n    const referenceInputs: [string, bigint][] = [];\n    for (const refTxIn of this.meshTxBuilderBody.referenceInputs) {\n      referenceInputs.push([\n        this.makeTxId(refTxIn.txHash, refTxIn.txIndex),\n        BigInt(refTxIn.scriptSize ?? 0),\n      ]);\n    }\n    return referenceInputs;\n  };\n\n  protected getInputsReferenceInputsSizes = (): [string, bigint][] => {\n    const referenceInputs: [string, bigint][] = [];\n    for (const input of this.meshTxBuilderBody.inputs) {\n      if (input.type === \"Script\") {\n        const scriptSource = input.scriptTxIn.scriptSource;\n        if (scriptSource?.type === \"Inline\") {\n          referenceInputs.push([\n            this.makeTxId(scriptSource.txHash, scriptSource.txIndex),\n            BigInt(scriptSource.scriptSize ?? 0),\n          ]);\n        }\n      } else if (input.type === \"SimpleScript\") {\n        const scriptSource = input.simpleScriptTxIn.scriptSource;\n        if (scriptSource?.type === \"Inline\") {\n          referenceInputs.push([\n            this.makeTxId(scriptSource.txHash, scriptSource.txIndex),\n            BigInt(scriptSource.scriptSize ?? 0),\n          ]);\n        }\n      }\n    }\n    return referenceInputs;\n  };\n\n  protected getMintsReferenceInputsSizes = (): [string, bigint][] => {\n    const referenceInputs: [string, bigint][] = [];\n    for (const mint of this.meshTxBuilderBody.mints) {\n      if (mint.type === \"Plutus\" || mint.type === \"Native\") {\n        const scriptSource = mint.scriptSource;\n        if (scriptSource?.type == \"Inline\") {\n          referenceInputs.push([\n            this.makeTxId(scriptSource.txHash, scriptSource.txIndex),\n            BigInt(scriptSource.scriptSize ?? 0),\n          ]);\n        }\n      }\n    }\n    return referenceInputs;\n  };\n\n  protected getWithdrawalsReferenceInputsSizes = (): [string, bigint][] => {\n    const referenceInputs: [string, bigint][] = [];\n    for (const withdrawal of this.meshTxBuilderBody.withdrawals) {\n      if (\n        withdrawal.type === \"SimpleScriptWithdrawal\" ||\n        withdrawal.type === \"ScriptWithdrawal\"\n      ) {\n        const scriptSource = withdrawal.scriptSource;\n        if (scriptSource?.type === \"Inline\") {\n          referenceInputs.push([\n            this.makeTxId(scriptSource.txHash, scriptSource.txIndex),\n            BigInt(scriptSource.scriptSize ?? 0),\n          ]);\n        }\n      }\n    }\n    return referenceInputs;\n  };\n\n  protected getVotesReferenceInputsSizes = (): [string, bigint][] => {\n    const referenceInputs: [string, bigint][] = [];\n    for (const vote of this.meshTxBuilderBody.votes) {\n      if (vote.type === \"SimpleScriptVote\") {\n        const scriptSource = vote.simpleScriptSource;\n        if (scriptSource?.type === \"Inline\") {\n          referenceInputs.push([\n            this.makeTxId(scriptSource.txHash, scriptSource.txIndex),\n            BigInt(scriptSource.scriptSize ?? 0),\n          ]);\n        }\n      } else if (vote.type === \"ScriptVote\") {\n        const scriptSource = vote.scriptSource;\n        if (scriptSource?.type === \"Inline\") {\n          referenceInputs.push([\n            this.makeTxId(scriptSource.txHash, scriptSource.txIndex),\n            BigInt(scriptSource.scriptSize ?? 0),\n          ]);\n        }\n      }\n    }\n    return referenceInputs;\n  };\n\n  protected getCertificatesReferenceInputsSizes = (): [string, bigint][] => {\n    const referenceInputs: [string, bigint][] = [];\n    for (const cert of this.meshTxBuilderBody.certificates) {\n      if (cert.type === \"SimpleScriptCertificate\") {\n        const scriptSource = cert.simpleScriptSource;\n        if (scriptSource?.type === \"Inline\") {\n          referenceInputs.push([\n            this.makeTxId(scriptSource.txHash, scriptSource.txIndex),\n            BigInt(scriptSource.scriptSize ?? 0),\n          ]);\n        }\n      } else if (cert.type === \"ScriptCertificate\") {\n        const scriptSource = cert.scriptSource;\n        if (scriptSource?.type === \"Inline\") {\n          referenceInputs.push([\n            this.makeTxId(scriptSource.txHash, scriptSource.txIndex),\n            BigInt(scriptSource.scriptSize ?? 0),\n          ]);\n        }\n      }\n    }\n    return referenceInputs;\n  };\n\n  getTotalExecutionUnits = (): {\n    memUnits: bigint;\n    stepUnits: bigint;\n  } => {\n    let memUnits = 0n;\n    let stepUnits = 0n;\n    for (let input of this.meshTxBuilderBody.inputs) {\n      if (input.type === \"Script\" && input.scriptTxIn.redeemer) {\n        memUnits += BigInt(input.scriptTxIn.redeemer.exUnits.mem);\n        stepUnits += BigInt(input.scriptTxIn.redeemer.exUnits.steps);\n      }\n    }\n    for (let mint of this.meshTxBuilderBody.mints) {\n      if (mint.type === \"Plutus\" && mint.redeemer) {\n        memUnits += BigInt(mint.redeemer.exUnits.mem);\n        stepUnits += BigInt(mint.redeemer.exUnits.steps);\n      }\n    }\n    for (let cert of this.meshTxBuilderBody.certificates) {\n      if (cert.type === \"ScriptCertificate\" && cert.redeemer) {\n        memUnits += BigInt(cert.redeemer.exUnits.mem);\n        stepUnits += BigInt(cert.redeemer.exUnits.steps);\n      }\n    }\n    for (let withdrawal of this.meshTxBuilderBody.withdrawals) {\n      if (withdrawal.type === \"ScriptWithdrawal\" && withdrawal.redeemer) {\n        memUnits += BigInt(withdrawal.redeemer.exUnits.mem);\n        stepUnits += BigInt(withdrawal.redeemer.exUnits.steps);\n      }\n    }\n    for (let vote of this.meshTxBuilderBody.votes) {\n      if (vote.type === \"ScriptVote\" && vote.redeemer) {\n        memUnits += BigInt(vote.redeemer.exUnits.mem);\n        stepUnits += BigInt(vote.redeemer.exUnits.steps);\n      }\n    }\n    memUnits = BigInt(\n      new BigNumber(memUnits).integerValue(BigNumber.ROUND_CEIL).toString(),\n    );\n    stepUnits = BigInt(\n      new BigNumber(stepUnits).integerValue(BigNumber.ROUND_CEIL).toString(),\n    );\n    return {\n      memUnits,\n      stepUnits,\n    };\n  };\n\n  getSerializedSize = (): number => {\n    return this.serializeMockTx().length / 2;\n  };\n\n  getActualFee = (): bigint => {\n    if (this.manualFee) {\n      return BigInt(this.manualFee);\n    } else {\n      return this.calculateFee();\n    }\n  };\n\n  calculateFee = (): bigint => {\n    const txSize = this.getSerializedSize();\n    return this.calculateFeeForSerializedTx(txSize);\n  };\n\n  calculateFeeForSerializedTx = (txSize: number): bigint => {\n    const refScriptFee = this.calculateRefScriptFee();\n    const redeemersFee = this.calculateRedeemersFee();\n    const minFeeCoeff = BigInt(this._protocolParams.minFeeA);\n    const minFeeConstant = BigInt(this._protocolParams.minFeeB);\n    const minFee = minFeeCoeff * BigInt(txSize) + minFeeConstant;\n    return minFee + refScriptFee + redeemersFee;\n  };\n\n  calculateRefScriptFee = (): bigint => {\n    const refSize = this.getTotalReferenceInputsSize();\n    const refScriptFee = this._protocolParams.minFeeRefScriptCostPerByte;\n    return minRefScriptFee(refSize, refScriptFee);\n  };\n\n  calculateRedeemersFee = (): bigint => {\n    const { memUnits, stepUnits } = this.getTotalExecutionUnits();\n    const stepPrice = BigNumber(this._protocolParams.priceStep);\n    const memPrice = BigNumber(this._protocolParams.priceMem);\n    const stepFee = stepPrice.multipliedBy(BigNumber(stepUnits.toString()));\n    const memFee = memPrice.multipliedBy(BigNumber(memUnits.toString()));\n    return BigInt(\n      stepFee.plus(memFee).integerValue(BigNumber.ROUND_CEIL).toString(),\n    );\n  };\n\n  calculateMinLovelaceForOutput = (output: Output): bigint => {\n    return getOutputMinLovelace(output, this._protocolParams.coinsPerUtxoSize);\n  };\n\n  protected clone(): MeshTxBuilder {\n    const newBuilder = super._cloneCore<MeshTxBuilder>(() => {\n      return new MeshTxBuilder({\n        serializer: this.serializer,\n        fetcher: this.fetcher,\n        submitter: this.submitter,\n        evaluator: this.evaluator,\n        verbose: this.verbose,\n        params: { ...this._protocolParams },\n      });\n    });\n\n    newBuilder.txHex = this.txHex;\n\n    newBuilder.queriedTxHashes = structuredClone(this.queriedTxHashes);\n\n    newBuilder.queriedUTxOs = structuredClone(this.queriedUTxOs);\n    newBuilder.utxosWithRefScripts = structuredClone(this.utxosWithRefScripts);\n\n    return newBuilder;\n  }\n}\n\nfunction minRefScriptFee(\n  totalRefScriptsSize: bigint,\n  refScriptCoinsPerByte: number,\n): bigint {\n  const multiplier = new BigNumber(12).dividedBy(new BigNumber(10)); // 1.2\n  const sizeIncrement = new BigNumber(25600);\n  const baseFee = new BigNumber(refScriptCoinsPerByte);\n\n  const totalSize = new BigNumber(totalRefScriptsSize.toString());\n\n  return tierRefScriptFee(multiplier, sizeIncrement, baseFee, totalSize);\n}\n\nfunction tierRefScriptFee(\n  multiplier: BigNumber,\n  sizeIncrement: BigNumber,\n  baseFee: BigNumber,\n  totalSize: BigNumber,\n): bigint {\n  if (multiplier.lte(0) || sizeIncrement.eq(0)) {\n    throw new Error(\"Size increment and multiplier must be positive\");\n  }\n\n  const fullTiers = totalSize.dividedToIntegerBy(sizeIncrement);\n  const partialTierSize = totalSize.mod(sizeIncrement);\n\n  const tierPrice = baseFee.multipliedBy(sizeIncrement);\n  let acc = new BigNumber(0);\n  const one = new BigNumber(1);\n\n  if (fullTiers.gt(0)) {\n    const multiplierPow = multiplier.pow(fullTiers.toNumber());\n    const progressionEnumerator = one.minus(multiplierPow);\n    const progressionDenom = one.minus(multiplier);\n    const tierProgressionSum =\n      progressionEnumerator.dividedBy(progressionDenom);\n    acc = acc.plus(tierPrice.multipliedBy(tierProgressionSum));\n  }\n\n  if (partialTierSize.gt(0)) {\n    const multiplierPow = multiplier.pow(fullTiers.toNumber());\n    const lastTierPrice = baseFee.multipliedBy(multiplierPow);\n    const partialTierFee = lastTierPrice.multipliedBy(partialTierSize);\n    acc = acc.plus(partialTierFee);\n  }\n\n  return BigInt(acc.integerValue(BigNumber.ROUND_FLOOR).toString());\n}\n\nexport const cloneOutput = (output: Output): Output => {\n  return JSONBig.parse(JSONBig.stringify(output));\n};\n\nexport const setLoveLace = (output: Output, lovelace: bigint): Output => {\n  let lovelaceSet = false;\n  for (let asset of output.amount) {\n    if (asset.unit === \"lovelace\") {\n      asset.quantity = lovelace.toString();\n      lovelaceSet = true;\n      break;\n    }\n  }\n\n  if (!lovelaceSet) {\n    output.amount.push({\n      unit: \"lovelace\",\n      quantity: lovelace.toString(),\n    });\n  }\n  return output;\n};\n\nexport const getLovelace = (output: Output): bigint => {\n  for (let asset of output.amount) {\n    if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n      return BigInt(asset.quantity);\n    }\n  }\n  return 0n;\n};\n\nexport const getOutputMinLovelace = (\n  output: Output,\n  coinsPerUtxoSize = DEFAULT_PROTOCOL_PARAMETERS.coinsPerUtxoSize,\n): bigint => {\n  const serializer = new CardanoSDKSerializer();\n  let currentOutput = cloneOutput(output);\n  let lovelace = getLovelace(currentOutput);\n  let minLovelace = 0n;\n  for (let i = 0; i < 3; i++) {\n    const txOutSize = BigInt(\n      serializer.serializeOutput(currentOutput).length / 2,\n    );\n    const txOutByteCost = BigInt(coinsPerUtxoSize);\n    const totalOutCost = (160n + BigInt(txOutSize)) * txOutByteCost;\n    minLovelace = totalOutCost;\n    if (lovelace < totalOutCost) {\n      lovelace = totalOutCost;\n    } else {\n      break;\n    }\n    currentOutput = setLoveLace(currentOutput, lovelace);\n  }\n\n  return minLovelace;\n};\n\nexport * from \"./utils\";\n",
      "dependencies": [
        "MeshTxBuilderOptions",
        "MeshTxBuilder",
        "cloneOutput",
        "setLoveLace",
        "getLovelace",
        "getOutputMinLovelace"
      ],
      "source": "mesh-transaction",
      "isReExportFile": false
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/tx-builder-core.ts",
      "name": "mesh-tx-builder.tx-builder-core.ts",
      "imports": [
        {
          "module": "MeshTxBuilderCore",
          "items": [],
          "line": 44,
          "raw": "export class MeshTxBuilderCore {",
          "source": "mesh-transaction"
        }
      ],
      "functions": [
        {
          "name": "txInScript",
          "signature": "txInScript = (scriptCbor: string) => {",
          "documentation": "  /**\n   * Set the script for transaction input\n   * @param {string} scriptCbor The CborHex of the script\n   * @param version Optional - The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "scriptCbor",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 131,
          "raw": "  /**\n   * Set the script for transaction input\n   * @param {string} scriptCbor The CborHex of the script\n   * @param version Optional - The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */\n  txInScript = (scriptCbor: string) => {\n    if (!this.txInQueueItem) throw Error(\"Undefined input\");\n    if (this.txInQueueItem.type === \"PubKey\") {\n      this.txInQueueItem = {\n        type: \"SimpleScript\",\n        txIn: this.txInQueueItem.txIn,\n        simpleScriptTxIn: {\n          scriptSource: {\n            type: \"Provided\",\n            scriptCode: scriptCbor,\n          },\n        },\n      };\n    }\n    if (this.txInQueueItem.type === \"Script\") {\n      this.txInQueueItem.scriptTxIn.scriptSource = {\n        type: \"Provided\",\n        script: {\n          code: scriptCbor,\n          version: this.plutusSpendingScriptVersion || \"V2\",\n        },\n      };\n    }\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  txInScript = (scriptCbor: string) => {\n    if (!this.txInQueueItem) throw Error(\"Undefined input\");\n    if (this.txInQueueItem.type === \"PubKey\") {\n      this.txInQueueItem = {\n        type: \"SimpleScript\",\n        txIn: this.txInQueueItem.txIn,\n        simpleScriptTxIn: {\n          scriptSource: {\n            type: \"Provided\",\n            scriptCode: scriptCbor,\n          },\n        },\n      };\n    }\n    if (this.txInQueueItem.type === \"Script\") {\n      this.txInQueueItem.scriptTxIn.scriptSource = {\n        type: \"Provided\",\n        script: {\n          code: scriptCbor,\n          version: this.plutusSpendingScriptVersion || \"V2\",\n        },\n      };\n    }\n    return this;\n  };"
        },
        {
          "name": "txInInlineDatumPresent",
          "signature": "txInInlineDatumPresent = () => {",
          "documentation": "  /**\n   * Tell the transaction builder that the input UTxO has inlined datum\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 203,
          "raw": "  /**\n   * Tell the transaction builder that the input UTxO has inlined datum\n   * @returns The MeshTxBuilder instance\n   */\n  txInInlineDatumPresent = () => {\n    if (!this.txInQueueItem) throw Error(\"Undefined input\");\n    if (this.txInQueueItem.type === \"PubKey\")\n      throw Error(\n        \"Inline datum present attempted to be called a non script input\",\n      );\n    if (this.txInQueueItem.type === \"SimpleScript\")\n      throw Error(\n        \"Inline datum present attempted to be called on a simple script input\",\n      );\n    const { txHash, txIndex } = this.txInQueueItem.txIn;\n    if (txHash && txIndex.toString()) {\n      this.txInQueueItem.scriptTxIn.datumSource = {\n        type: \"Inline\",\n        txHash,\n        txIndex,\n      };\n    }\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  txInInlineDatumPresent = () => {\n    if (!this.txInQueueItem) throw Error(\"Undefined input\");\n    if (this.txInQueueItem.type === \"PubKey\")\n      throw Error(\n        \"Inline datum present attempted to be called a non script input\",\n      );\n    if (this.txInQueueItem.type === \"SimpleScript\")\n      throw Error(\n        \"Inline datum present attempted to be called on a simple script input\",\n      );\n    const { txHash, txIndex } = this.txInQueueItem.txIn;\n    if (txHash && txIndex.toString()) {\n      this.txInQueueItem.scriptTxIn.datumSource = {\n        type: \"Inline\",\n        txHash,\n        txIndex,\n      };\n    }\n    return this;\n  };"
        },
        {
          "name": "txOut",
          "signature": "txOut = (address: string, amount: Asset[]) => {",
          "documentation": "  /**\n   * Set the output for transaction\n   * @param {string} address The recipient of the output\n   * @param {Asset[]} amount The amount of other native assets attached with UTxO\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "address",
              "type": "string",
              "optional": false
            },
            {
              "name": "amount",
              "type": "Asset[]",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 301,
          "raw": "  /**\n   * Set the output for transaction\n   * @param {string} address The recipient of the output\n   * @param {Asset[]} amount The amount of other native assets attached with UTxO\n   * @returns The MeshTxBuilder instance\n   */\n  txOut = (address: string, amount: Asset[]) => {\n    if (this.txOutput) {\n      this.meshTxBuilderBody.outputs.push(this.txOutput);\n      this.txOutput = undefined;\n    }\n    this.txOutput = {\n      address,\n      amount,\n    };\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  txOut = (address: string, amount: Asset[]) => {\n    if (this.txOutput) {\n      this.meshTxBuilderBody.outputs.push(this.txOutput);\n      this.txOutput = undefined;\n    }\n    this.txOutput = {\n      address,\n      amount,\n    };\n    return this;\n  };"
        },
        {
          "name": "spendingPlutusScript",
          "signature": "spendingPlutusScript = (languageVersion: LanguageVersion) => {",
          "documentation": "  /**\n   * Set the reference script to be attached with the output\n   * @param languageVersion The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "languageVersion",
              "type": "LanguageVersion",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 443,
          "raw": "  /**\n   * Set the reference script to be attached with the output\n   * @param languageVersion The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */\n  spendingPlutusScript = (languageVersion: LanguageVersion) => {\n    // This flag should signal a start to a script input\n    // The next step after will be to add a tx-in\n    // After which, we will REQUIRE, script, datum and redeemer info\n    // for unlocking this particular input\n    this.addingPlutusScriptInput = true;\n    this.plutusSpendingScriptVersion = languageVersion;\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  spendingPlutusScript = (languageVersion: LanguageVersion) => {\n    // This flag should signal a start to a script input\n    // The next step after will be to add a tx-in\n    // After which, we will REQUIRE, script, datum and redeemer info\n    // for unlocking this particular input\n    this.addingPlutusScriptInput = true;\n    this.plutusSpendingScriptVersion = languageVersion;\n    return this;\n  };"
        },
        {
          "name": "spendingPlutusScriptV1",
          "signature": "spendingPlutusScriptV1 = () => {",
          "documentation": "  /**\n   * Set the instruction that it is currently using V1 Plutus spending scripts\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 456,
          "raw": "  /**\n   * Set the instruction that it is currently using V1 Plutus spending scripts\n   * @returns The MeshTxBuilder instance\n   */\n  spendingPlutusScriptV1 = () => {\n    // This flag should signal a start to a script input\n    // The next step after will be to add a tx-in\n    // After which, we will REQUIRE, script, datum and redeemer info\n    // for unlocking this particular input\n    this.addingPlutusScriptInput = true;\n    this.plutusSpendingScriptVersion = \"V1\";\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  spendingPlutusScriptV1 = () => {\n    // This flag should signal a start to a script input\n    // The next step after will be to add a tx-in\n    // After which, we will REQUIRE, script, datum and redeemer info\n    // for unlocking this particular input\n    this.addingPlutusScriptInput = true;\n    this.plutusSpendingScriptVersion = \"V1\";\n    return this;\n  };"
        },
        {
          "name": "spendingPlutusScriptV2",
          "signature": "spendingPlutusScriptV2 = () => {",
          "documentation": "  /**\n   * Set the instruction that it is currently using V2 Plutus spending scripts\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 469,
          "raw": "  /**\n   * Set the instruction that it is currently using V2 Plutus spending scripts\n   * @returns The MeshTxBuilder instance\n   */\n  spendingPlutusScriptV2 = () => {\n    // This flag should signal a start to a script input\n    // The next step after will be to add a tx-in\n    // After which, we will REQUIRE, script, datum and redeemer info\n    // for unlocking this particular input\n    this.addingPlutusScriptInput = true;\n    this.plutusSpendingScriptVersion = \"V2\";\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  spendingPlutusScriptV2 = () => {\n    // This flag should signal a start to a script input\n    // The next step after will be to add a tx-in\n    // After which, we will REQUIRE, script, datum and redeemer info\n    // for unlocking this particular input\n    this.addingPlutusScriptInput = true;\n    this.plutusSpendingScriptVersion = \"V2\";\n    return this;\n  };"
        },
        {
          "name": "spendingPlutusScriptV3",
          "signature": "spendingPlutusScriptV3 = () => {",
          "documentation": "  /**\n   * Set the instruction that it is currently using V3 Plutus spending scripts\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 482,
          "raw": "  /**\n   * Set the instruction that it is currently using V3 Plutus spending scripts\n   * @returns The MeshTxBuilder instance\n   */\n  spendingPlutusScriptV3 = () => {\n    // This flag should signal a start to a script input\n    // The next step after will be to add a tx-in\n    // After which, we will REQUIRE, script, datum and redeemer info\n    // for unlocking this particular input\n    this.addingPlutusScriptInput = true;\n    this.plutusSpendingScriptVersion = \"V3\";\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  spendingPlutusScriptV3 = () => {\n    // This flag should signal a start to a script input\n    // The next step after will be to add a tx-in\n    // After which, we will REQUIRE, script, datum and redeemer info\n    // for unlocking this particular input\n    this.addingPlutusScriptInput = true;\n    this.plutusSpendingScriptVersion = \"V3\";\n    return this;\n  };"
        },
        {
          "name": "spendingReferenceTxInInlineDatumPresent",
          "signature": "spendingReferenceTxInInlineDatumPresent = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 532,
          "raw": "  spendingReferenceTxInInlineDatumPresent = () => {\n    this.txInInlineDatumPresent();\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  spendingReferenceTxInInlineDatumPresent = () => {\n    this.txInInlineDatumPresent();\n    return this;\n  };"
        },
        {
          "name": "mintPlutusScript",
          "signature": "mintPlutusScript = (languageVersion: LanguageVersion) => {",
          "documentation": "  /**\n   * Set the minting script for the current mint\n   * @param languageVersion The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "languageVersion",
              "type": "LanguageVersion",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 577,
          "raw": "  /**\n   * Set the minting script for the current mint\n   * @param languageVersion The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */\n  mintPlutusScript = (languageVersion: LanguageVersion) => {\n    this.addingPlutusMint = true;\n    this.plutusMintingScriptVersion = languageVersion;\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  mintPlutusScript = (languageVersion: LanguageVersion) => {\n    this.addingPlutusMint = true;\n    this.plutusMintingScriptVersion = languageVersion;\n    return this;\n  };"
        },
        {
          "name": "mintPlutusScriptV1",
          "signature": "mintPlutusScriptV1 = () => {",
          "documentation": "  /**\n   * Set the instruction that it is currently using V1 Plutus minting scripts\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 586,
          "raw": "  /**\n   * Set the instruction that it is currently using V1 Plutus minting scripts\n   * @returns The MeshTxBuilder instance\n   */\n  mintPlutusScriptV1 = () => {\n    this.addingPlutusMint = true;\n    this.plutusMintingScriptVersion = \"V1\";\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  mintPlutusScriptV1 = () => {\n    this.addingPlutusMint = true;\n    this.plutusMintingScriptVersion = \"V1\";\n    return this;\n  };"
        },
        {
          "name": "mintPlutusScriptV2",
          "signature": "mintPlutusScriptV2 = () => {",
          "documentation": "  /**\n   * Set the instruction that it is currently using V2 Plutus minting scripts\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 595,
          "raw": "  /**\n   * Set the instruction that it is currently using V2 Plutus minting scripts\n   * @returns The MeshTxBuilder instance\n   */\n  mintPlutusScriptV2 = () => {\n    this.addingPlutusMint = true;\n    this.plutusMintingScriptVersion = \"V2\";\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  mintPlutusScriptV2 = () => {\n    this.addingPlutusMint = true;\n    this.plutusMintingScriptVersion = \"V2\";\n    return this;\n  };"
        },
        {
          "name": "mintPlutusScriptV3",
          "signature": "mintPlutusScriptV3 = () => {",
          "documentation": "  /**\n   * Set the instruction that it is currently using V3 Plutus minting scripts\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 604,
          "raw": "  /**\n   * Set the instruction that it is currently using V3 Plutus minting scripts\n   * @returns The MeshTxBuilder instance\n   */\n  mintPlutusScriptV3 = () => {\n    this.addingPlutusMint = true;\n    this.plutusMintingScriptVersion = \"V3\";\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  mintPlutusScriptV3 = () => {\n    this.addingPlutusMint = true;\n    this.plutusMintingScriptVersion = \"V3\";\n    return this;\n  };"
        },
        {
          "name": "mint",
          "signature": "mint = (quantity: string, policy: string, name: string) => {",
          "documentation": "  /**\n   * Set the minting value of transaction\n   * @param quantity The quantity of asset to be minted\n   * @param policy The policy id of the asset to be minted\n   * @param name The hex of token name of the asset to be minted\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "quantity",
              "type": "string",
              "optional": false
            },
            {
              "name": "policy",
              "type": "string",
              "optional": false
            },
            {
              "name": "name",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 617,
          "raw": "  /**\n   * Set the minting value of transaction\n   * @param quantity The quantity of asset to be minted\n   * @param policy The policy id of the asset to be minted\n   * @param name The hex of token name of the asset to be minted\n   * @returns The MeshTxBuilder instance\n   */\n  mint = (quantity: string, policy: string, name: string) => {\n    if (this.mintItem) {\n      this.queueMint();\n    }\n    this.mintItem = {\n      type: this.addingPlutusMint ? \"Plutus\" : \"Native\",\n      policyId: policy,\n      assetName: name,\n      amount: quantity,\n    };\n    this.addingPlutusMint = false;\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  mint = (quantity: string, policy: string, name: string) => {\n    if (this.mintItem) {\n      this.queueMint();\n    }\n    this.mintItem = {\n      type: this.addingPlutusMint ? \"Plutus\" : \"Native\",\n      policyId: policy,\n      assetName: name,\n      amount: quantity,\n    };\n    this.addingPlutusMint = false;\n    return this;\n  };"
        },
        {
          "name": "mintingScript",
          "signature": "mintingScript = (scriptCBOR: string) => {",
          "documentation": "  /**\n   * Set the minting script of current mint\n   * @param scriptCBOR The CBOR hex of the minting policy script\n   * @param version Optional - The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "scriptCBOR",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 637,
          "raw": "  /**\n   * Set the minting script of current mint\n   * @param scriptCBOR The CBOR hex of the minting policy script\n   * @param version Optional - The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */\n  mintingScript = (scriptCBOR: string) => {\n    if (!this.mintItem) throw Error(\"Undefined mint\");\n    if (!this.mintItem.type) throw Error(\"Mint information missing\");\n    if (this.mintItem.type === \"Native\") {\n      this.mintItem.scriptSource = {\n        type: \"Provided\",\n        scriptCode: scriptCBOR,\n      };\n    }\n    if (this.mintItem.type === \"Plutus\") {\n      this.mintItem.scriptSource = {\n        type: \"Provided\",\n        script: {\n          code: scriptCBOR,\n          version: this.plutusMintingScriptVersion || \"V2\",\n        },\n      };\n    }\n\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  mintingScript = (scriptCBOR: string) => {\n    if (!this.mintItem) throw Error(\"Undefined mint\");\n    if (!this.mintItem.type) throw Error(\"Mint information missing\");\n    if (this.mintItem.type === \"Native\") {\n      this.mintItem.scriptSource = {\n        type: \"Provided\",\n        scriptCode: scriptCBOR,\n      };\n    }\n    if (this.mintItem.type === \"Plutus\") {\n      this.mintItem.scriptSource = {\n        type: \"Provided\",\n        script: {\n          code: scriptCBOR,\n          version: this.plutusMintingScriptVersion || \"V2\",\n        },\n      };\n    }\n\n    return this;\n  };"
        },
        {
          "name": "requiredSignerHash",
          "signature": "requiredSignerHash = (pubKeyHash: string) => {",
          "documentation": "  /**\n   * Set the required signer of the transaction\n   * @param pubKeyHash The PubKeyHash of the required signer\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "pubKeyHash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 743,
          "raw": "  /**\n   * Set the required signer of the transaction\n   * @param pubKeyHash The PubKeyHash of the required signer\n   * @returns The MeshTxBuilder instance\n   */\n  requiredSignerHash = (pubKeyHash: string) => {\n    this.meshTxBuilderBody.requiredSignatures.push(pubKeyHash);\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  requiredSignerHash = (pubKeyHash: string) => {\n    this.meshTxBuilderBody.requiredSignatures.push(pubKeyHash);\n    return this;\n  };"
        },
        {
          "name": "withdrawalPlutusScript",
          "signature": "withdrawalPlutusScript = (languageVersion: LanguageVersion) => {",
          "documentation": "  /**\n   * Set the instruction that it is currently using V1 Plutus withdrawal scripts\n   * @param languageVersion The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "languageVersion",
              "type": "LanguageVersion",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 782,
          "raw": "  /**\n   * Set the instruction that it is currently using V1 Plutus withdrawal scripts\n   * @param languageVersion The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */\n  withdrawalPlutusScript = (languageVersion: LanguageVersion) => {\n    this.addingPlutusWithdrawal = true;\n    this.plutusWithdrawalScriptVersion = languageVersion;\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  withdrawalPlutusScript = (languageVersion: LanguageVersion) => {\n    this.addingPlutusWithdrawal = true;\n    this.plutusWithdrawalScriptVersion = languageVersion;\n    return this;\n  };"
        },
        {
          "name": "withdrawalPlutusScriptV1",
          "signature": "withdrawalPlutusScriptV1 = () => {",
          "documentation": "  /**\n   * Set the instruction that it is currently using a Plutus withdrawal scripts\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 791,
          "raw": "  /**\n   * Set the instruction that it is currently using a Plutus withdrawal scripts\n   * @returns The MeshTxBuilder instance\n   */\n  withdrawalPlutusScriptV1 = () => {\n    this.addingPlutusWithdrawal = true;\n    this.plutusWithdrawalScriptVersion = \"V1\";\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  withdrawalPlutusScriptV1 = () => {\n    this.addingPlutusWithdrawal = true;\n    this.plutusWithdrawalScriptVersion = \"V1\";\n    return this;\n  };"
        },
        {
          "name": "withdrawalPlutusScriptV2",
          "signature": "withdrawalPlutusScriptV2 = () => {",
          "documentation": "  /**\n   * Set the instruction that it is currently using V2 Plutus withdrawal scripts\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 801,
          "raw": "  /**\n   * Set the instruction that it is currently using V2 Plutus withdrawal scripts\n   * @returns The MeshTxBuilder instance\n   */\n  withdrawalPlutusScriptV2 = () => {\n    this.addingPlutusWithdrawal = true;\n    this.plutusWithdrawalScriptVersion = \"V2\";\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  withdrawalPlutusScriptV2 = () => {\n    this.addingPlutusWithdrawal = true;\n    this.plutusWithdrawalScriptVersion = \"V2\";\n    return this;\n  };"
        },
        {
          "name": "withdrawalPlutusScriptV3",
          "signature": "withdrawalPlutusScriptV3 = () => {",
          "documentation": "  /**\n   * Set the instruction that it is currently using V3 Plutus withdrawal scripts\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 811,
          "raw": "  /**\n   * Set the instruction that it is currently using V3 Plutus withdrawal scripts\n   * @returns The MeshTxBuilder instance\n   */\n  withdrawalPlutusScriptV3 = () => {\n    this.addingPlutusWithdrawal = true;\n    this.plutusWithdrawalScriptVersion = \"V3\";\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  withdrawalPlutusScriptV3 = () => {\n    this.addingPlutusWithdrawal = true;\n    this.plutusWithdrawalScriptVersion = \"V3\";\n    return this;\n  };"
        },
        {
          "name": "withdrawal",
          "signature": "withdrawal = (rewardAddress: string, coin: string) => {",
          "documentation": "  /**\n   * Withdraw stake rewards in the MeshTxBuilder instance\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @param coin The amount of lovelaces in the withdrawal\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "rewardAddress",
              "type": "string",
              "optional": false
            },
            {
              "name": "coin",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 823,
          "raw": "  /**\n   * Withdraw stake rewards in the MeshTxBuilder instance\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @param coin The amount of lovelaces in the withdrawal\n   * @returns The MeshTxBuilder instance\n   */\n  withdrawal = (rewardAddress: string, coin: string) => {\n    if (this.withdrawalItem) {\n      this.queueWithdrawal();\n    }\n    if (this.addingPlutusWithdrawal) {\n      const withdrawal: Withdrawal = {\n        type: \"ScriptWithdrawal\",\n        address: rewardAddress,\n        coin: coin,\n      };\n      this.withdrawalItem = withdrawal;\n      this.addingPlutusWithdrawal = false;\n      return this;\n    }\n\n    const withdrawal: Withdrawal = {\n      type: \"PubKeyWithdrawal\",\n      address: rewardAddress,\n      coin: coin,\n    };\n    this.withdrawalItem = withdrawal;\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  withdrawal = (rewardAddress: string, coin: string) => {\n    if (this.withdrawalItem) {\n      this.queueWithdrawal();\n    }\n    if (this.addingPlutusWithdrawal) {\n      const withdrawal: Withdrawal = {\n        type: \"ScriptWithdrawal\",\n        address: rewardAddress,\n        coin: coin,\n      };\n      this.withdrawalItem = withdrawal;\n      this.addingPlutusWithdrawal = false;\n      return this;\n    }\n\n    const withdrawal: Withdrawal = {\n      type: \"PubKeyWithdrawal\",\n      address: rewardAddress,\n      coin: coin,\n    };\n    this.withdrawalItem = withdrawal;\n    return this;\n  };"
        },
        {
          "name": "withdrawalScript",
          "signature": "withdrawalScript = (scriptCbor: string) => {",
          "documentation": "  /**\n   * Add a withdrawal script to the MeshTxBuilder instance\n   * @param scriptCbor The script in CBOR format\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "scriptCbor",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 852,
          "raw": "  /**\n   * Add a withdrawal script to the MeshTxBuilder instance\n   * @param scriptCbor The script in CBOR format\n   * @returns The MeshTxBuilder instance\n   */\n  withdrawalScript = (scriptCbor: string) => {\n    if (!this.withdrawalItem)\n      throw Error(\"withdrawalScript: Undefined withdrawal\");\n    if (this.withdrawalItem.type === \"PubKeyWithdrawal\") {\n      this.withdrawalItem = {\n        type: \"SimpleScriptWithdrawal\",\n        address: this.withdrawalItem.address,\n        coin: this.withdrawalItem.coin,\n        scriptSource: {\n          type: \"Provided\",\n          scriptCode: scriptCbor,\n        },\n      };\n    } else {\n      this.withdrawalItem.scriptSource = {\n        type: \"Provided\",\n        script: {\n          code: scriptCbor,\n          version: this.plutusWithdrawalScriptVersion || \"V2\",\n        },\n      };\n    }\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  withdrawalScript = (scriptCbor: string) => {\n    if (!this.withdrawalItem)\n      throw Error(\"withdrawalScript: Undefined withdrawal\");\n    if (this.withdrawalItem.type === \"PubKeyWithdrawal\") {\n      this.withdrawalItem = {\n        type: \"SimpleScriptWithdrawal\",\n        address: this.withdrawalItem.address,\n        coin: this.withdrawalItem.coin,\n        scriptSource: {\n          type: \"Provided\",\n          scriptCode: scriptCbor,\n        },\n      };\n    } else {\n      this.withdrawalItem.scriptSource = {\n        type: \"Provided\",\n        script: {\n          code: scriptCbor,\n          version: this.plutusWithdrawalScriptVersion || \"V2\",\n        },\n      };\n    }\n    return this;\n  };"
        },
        {
          "name": "votePlutusScript",
          "signature": "votePlutusScript = (languageVersion: LanguageVersion) => {",
          "documentation": "  /**\n   * Set the instruction that it is currently using a Plutus voting scripts\n   * @param languageVersion The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "languageVersion",
              "type": "LanguageVersion",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 940,
          "raw": "  /**\n   * Set the instruction that it is currently using a Plutus voting scripts\n   * @param languageVersion The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */\n  votePlutusScript = (languageVersion: LanguageVersion) => {\n    this.addingPlutusVote = true;\n    this.plutusVoteScriptVersion = languageVersion;\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  votePlutusScript = (languageVersion: LanguageVersion) => {\n    this.addingPlutusVote = true;\n    this.plutusVoteScriptVersion = languageVersion;\n    return this;\n  };"
        },
        {
          "name": "votePlutusScriptV1",
          "signature": "votePlutusScriptV1 = () => {",
          "documentation": "  /**\n   * Set the instruction that it is currently using V1 Plutus voting scripts\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 949,
          "raw": "  /**\n   * Set the instruction that it is currently using V1 Plutus voting scripts\n   * @returns The MeshTxBuilder instance\n   */\n  votePlutusScriptV1 = () => {\n    this.addingPlutusVote = true;\n    this.plutusVoteScriptVersion = \"V1\";\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  votePlutusScriptV1 = () => {\n    this.addingPlutusVote = true;\n    this.plutusVoteScriptVersion = \"V1\";\n    return this;\n  };"
        },
        {
          "name": "votePlutusScriptV2",
          "signature": "votePlutusScriptV2 = () => {",
          "documentation": "  /**\n   * Set the instruction that it is currently using V2 Plutus voting scripts\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 959,
          "raw": "  /**\n   * Set the instruction that it is currently using V2 Plutus voting scripts\n   * @returns The MeshTxBuilder instance\n   */\n  votePlutusScriptV2 = () => {\n    this.addingPlutusVote = true;\n    this.plutusVoteScriptVersion = \"V2\";\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  votePlutusScriptV2 = () => {\n    this.addingPlutusVote = true;\n    this.plutusVoteScriptVersion = \"V2\";\n    return this;\n  };"
        },
        {
          "name": "votePlutusScriptV3",
          "signature": "votePlutusScriptV3 = () => {",
          "documentation": "  /**\n   * Set the instruction that it is currently using V3 Plutus voting scripts\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 969,
          "raw": "  /**\n   * Set the instruction that it is currently using V3 Plutus voting scripts\n   * @returns The MeshTxBuilder instance\n   */\n  votePlutusScriptV3 = () => {\n    this.addingPlutusVote = true;\n    this.plutusVoteScriptVersion = \"V3\";\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  votePlutusScriptV3 = () => {\n    this.addingPlutusVote = true;\n    this.plutusVoteScriptVersion = \"V3\";\n    return this;\n  };"
        },
        {
          "name": "voteScript",
          "signature": "voteScript = (scriptCbor: string) => {",
          "documentation": "  /**\n   * Add a voting script to the MeshTxBuilder instance\n   * @param scriptCbor The script in CBOR format\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "scriptCbor",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1021,
          "raw": "  /**\n   * Add a voting script to the MeshTxBuilder instance\n   * @param scriptCbor The script in CBOR format\n   * @returns The MeshTxBuilder instance\n   */\n  voteScript = (scriptCbor: string) => {\n    if (!this.voteItem) throw Error(\"voteScript: Undefined vote\");\n    if (this.voteItem.type === \"BasicVote\") {\n      this.voteItem = {\n        type: \"SimpleScriptVote\",\n        vote: this.voteItem.vote,\n        simpleScriptSource: {\n          type: \"Provided\",\n          scriptCode: scriptCbor,\n        },\n      };\n    } else if (this.voteItem.type === \"ScriptVote\") {\n      this.voteItem.scriptSource = {\n        type: \"Provided\",\n        script: {\n          code: scriptCbor,\n          version: this.plutusVoteScriptVersion || \"V2\",\n        },\n      };\n    } else if (this.voteItem.type === \"SimpleScriptVote\") {\n      throw Error(\"voteScript: Script is already defined for current vote\");\n    }\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  voteScript = (scriptCbor: string) => {\n    if (!this.voteItem) throw Error(\"voteScript: Undefined vote\");\n    if (this.voteItem.type === \"BasicVote\") {\n      this.voteItem = {\n        type: \"SimpleScriptVote\",\n        vote: this.voteItem.vote,\n        simpleScriptSource: {\n          type: \"Provided\",\n          scriptCode: scriptCbor,\n        },\n      };\n    } else if (this.voteItem.type === \"ScriptVote\") {\n      this.voteItem.scriptSource = {\n        type: \"Provided\",\n        script: {\n          code: scriptCbor,\n          version: this.plutusVoteScriptVersion || \"V2\",\n        },\n      };\n    } else if (this.voteItem.type === \"SimpleScriptVote\") {\n      throw Error(\"voteScript: Script is already defined for current vote\");\n    }\n    return this;\n  };"
        },
        {
          "name": "registerPoolCertificate",
          "signature": "registerPoolCertificate = (poolParams: PoolParams) => {",
          "documentation": "  /**\n   * Creates a pool registration certificate, and adds it to the transaction\n   * @param poolParams Parameters for pool registration\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "poolParams",
              "type": "PoolParams",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1114,
          "raw": "  /**\n   * Creates a pool registration certificate, and adds it to the transaction\n   * @param poolParams Parameters for pool registration\n   * @returns The MeshTxBuilder instance\n   */\n  registerPoolCertificate = (poolParams: PoolParams) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"RegisterPool\",\n        poolParams,\n      },\n    });\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  registerPoolCertificate = (poolParams: PoolParams) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"RegisterPool\",\n        poolParams,\n      },\n    });\n    return this;\n  };"
        },
        {
          "name": "registerStakeCertificate",
          "signature": "registerStakeCertificate = (rewardAddress: string) => {",
          "documentation": "  /**\n   * Creates a stake registration certificate, and adds it to the transaction\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "rewardAddress",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1130,
          "raw": "  /**\n   * Creates a stake registration certificate, and adds it to the transaction\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @returns The MeshTxBuilder instance\n   */\n  registerStakeCertificate = (rewardAddress: string) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"RegisterStake\",\n        stakeKeyAddress: rewardAddress,\n      },\n    });\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  registerStakeCertificate = (rewardAddress: string) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"RegisterStake\",\n        stakeKeyAddress: rewardAddress,\n      },\n    });\n    return this;\n  };"
        },
        {
          "name": "delegateStakeCertificate",
          "signature": "delegateStakeCertificate = (rewardAddress: string, poolId: string) => {",
          "documentation": "  /**\n   * Creates a stake delegation certificate, and adds it to the transaction\n   * This will delegate stake from the corresponding stake address to the pool\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @param poolId poolId can be in either bech32 or hex form\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "rewardAddress",
              "type": "string",
              "optional": false
            },
            {
              "name": "poolId",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1148,
          "raw": "  /**\n   * Creates a stake delegation certificate, and adds it to the transaction\n   * This will delegate stake from the corresponding stake address to the pool\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @param poolId poolId can be in either bech32 or hex form\n   * @returns The MeshTxBuilder instance\n   */\n  delegateStakeCertificate = (rewardAddress: string, poolId: string) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"DelegateStake\",\n        stakeKeyAddress: rewardAddress,\n        poolId,\n      },\n    });\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  delegateStakeCertificate = (rewardAddress: string, poolId: string) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"DelegateStake\",\n        stakeKeyAddress: rewardAddress,\n        poolId,\n      },\n    });\n    return this;\n  };"
        },
        {
          "name": "deregisterStakeCertificate",
          "signature": "deregisterStakeCertificate = (rewardAddress: string) => {",
          "documentation": "  /**\n   * Creates a stake deregister certificate, and adds it to the transaction\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "rewardAddress",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1165,
          "raw": "  /**\n   * Creates a stake deregister certificate, and adds it to the transaction\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @returns The MeshTxBuilder instance\n   */\n  deregisterStakeCertificate = (rewardAddress: string) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"DeregisterStake\",\n        stakeKeyAddress: rewardAddress,\n      },\n    });\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  deregisterStakeCertificate = (rewardAddress: string) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"DeregisterStake\",\n        stakeKeyAddress: rewardAddress,\n      },\n    });\n    return this;\n  };"
        },
        {
          "name": "retirePoolCertificate",
          "signature": "retirePoolCertificate = (poolId: string, epoch: number) => {",
          "documentation": "  /**\n   * Creates a pool retire certificate, and adds it to the transaction\n   * @param poolId poolId can be in either bech32 or hex form\n   * @param epoch The intended epoch to retire the pool\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "poolId",
              "type": "string",
              "optional": false
            },
            {
              "name": "epoch",
              "type": "number",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1182,
          "raw": "  /**\n   * Creates a pool retire certificate, and adds it to the transaction\n   * @param poolId poolId can be in either bech32 or hex form\n   * @param epoch The intended epoch to retire the pool\n   * @returns The MeshTxBuilder instance\n   */\n  retirePoolCertificate = (poolId: string, epoch: number) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"RetirePool\",\n        poolId,\n        epoch,\n      },\n    });\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  retirePoolCertificate = (poolId: string, epoch: number) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"RetirePool\",\n        poolId,\n        epoch,\n      },\n    });\n    return this;\n  };"
        },
        {
          "name": "drepUpdateCertificate",
          "signature": "drepUpdateCertificate = (drepId: string, anchor?: Anchor) => {",
          "documentation": "  /**\n   * Update DRep certificate, and adds it to the transaction\n   * @param drepId The bech32 drep id (i.e. starts with `drep1xxxxx`)\n   * @param anchor The DRep anchor, consists of a URL and a hash of the doc\n   */",
          "parameters": [
            {
              "name": "drepId",
              "type": "string",
              "optional": false
            },
            {
              "name": "anchor",
              "type": "Anchor",
              "optional": true
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1244,
          "raw": "  /**\n   * Update DRep certificate, and adds it to the transaction\n   * @param drepId The bech32 drep id (i.e. starts with `drep1xxxxx`)\n   * @param anchor The DRep anchor, consists of a URL and a hash of the doc\n   */\n  drepUpdateCertificate = (drepId: string, anchor?: Anchor) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"DRepUpdate\",\n        drepId,\n        anchor,\n      },\n    });\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  drepUpdateCertificate = (drepId: string, anchor?: Anchor) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"DRepUpdate\",\n        drepId,\n        anchor,\n      },\n    });\n    return this;\n  };"
        },
        {
          "name": "voteDelegationCertificate",
          "signature": "voteDelegationCertificate = (drep: DRep, rewardAddress: string) => {",
          "documentation": "  /**\n   * Dregister DRep certificate, and adds it to the transaction\n   * @param drepId The bech32 drep id (i.e. starts with `drep1xxxxx`)\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "drep",
              "type": "DRep",
              "optional": false
            },
            {
              "name": "rewardAddress",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1262,
          "raw": "  /**\n   * Dregister DRep certificate, and adds it to the transaction\n   * @param drepId The bech32 drep id (i.e. starts with `drep1xxxxx`)\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @returns The MeshTxBuilder instance\n   */\n  voteDelegationCertificate = (drep: DRep, rewardAddress: string) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"VoteDelegation\",\n        drep,\n        stakeKeyAddress: rewardAddress,\n      },\n    });\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  voteDelegationCertificate = (drep: DRep, rewardAddress: string) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"VoteDelegation\",\n        drep,\n        stakeKeyAddress: rewardAddress,\n      },\n    });\n    return this;\n  };"
        },
        {
          "name": "certificateScript",
          "signature": "certificateScript = (scriptCbor: string, version?: LanguageVersion) => {",
          "documentation": "  /**\n   * Adds a script witness to the certificate\n   * @param scriptCbor The CborHex of the script\n   * @param version Optional - The plutus version of the script, null version implies Native Script\n   */",
          "parameters": [
            {
              "name": "scriptCbor",
              "type": "string",
              "optional": false
            },
            {
              "name": "version",
              "type": "LanguageVersion",
              "optional": true
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1279,
          "raw": "  /**\n   * Adds a script witness to the certificate\n   * @param scriptCbor The CborHex of the script\n   * @param version Optional - The plutus version of the script, null version implies Native Script\n   */\n  certificateScript = (scriptCbor: string, version?: LanguageVersion) => {\n    const currentCert = this.meshTxBuilderBody.certificates.pop();\n    if (!currentCert) {\n      throw Error(\n        \"Certificate script attempted to be defined, but no certificate was found\",\n      );\n    }\n    if (!version) {\n      this.meshTxBuilderBody.certificates.push({\n        type: \"SimpleScriptCertificate\",\n        certType: currentCert.certType,\n        simpleScriptSource: {\n          type: \"Provided\",\n          scriptCode: scriptCbor,\n        },\n      });\n    } else {\n      this.meshTxBuilderBody.certificates.push({\n        type: \"ScriptCertificate\",\n        certType: currentCert.certType,\n        scriptSource: {\n          type: \"Provided\",\n          script: {\n            code: scriptCbor,\n            version,\n          },\n        },\n        redeemer:\n          currentCert.type === \"ScriptCertificate\"\n            ? currentCert.redeemer\n            : undefined,\n      });\n    }\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  certificateScript = (scriptCbor: string, version?: LanguageVersion) => {\n    const currentCert = this.meshTxBuilderBody.certificates.pop();\n    if (!currentCert) {\n      throw Error(\n        \"Certificate script attempted to be defined, but no certificate was found\",\n      );\n    }\n    if (!version) {\n      this.meshTxBuilderBody.certificates.push({\n        type: \"SimpleScriptCertificate\",\n        certType: currentCert.certType,\n        simpleScriptSource: {\n          type: \"Provided\",\n          scriptCode: scriptCbor,\n        },\n      });\n    } else {\n      this.meshTxBuilderBody.certificates.push({\n        type: \"ScriptCertificate\",\n        certType: currentCert.certType,\n        scriptSource: {\n          type: \"Provided\",\n          script: {\n            code: scriptCbor,\n            version,\n          },\n        },\n        redeemer:\n          currentCert.type === \"ScriptCertificate\"\n            ? currentCert.redeemer\n            : undefined,\n      });\n    }\n    return this;\n  };"
        },
        {
          "name": "changeAddress",
          "signature": "changeAddress = (addr: string) => {",
          "documentation": "  /**\n   * Configure the address to accept change UTxO\n   * @param addr The address to accept change UTxO\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "addr",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1399,
          "raw": "  /**\n   * Configure the address to accept change UTxO\n   * @param addr The address to accept change UTxO\n   * @returns The MeshTxBuilder instance\n   */\n  changeAddress = (addr: string) => {\n    this.meshTxBuilderBody.changeAddress = addr;\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  changeAddress = (addr: string) => {\n    this.meshTxBuilderBody.changeAddress = addr;\n    return this;\n  };"
        },
        {
          "name": "invalidBefore",
          "signature": "invalidBefore = (slot: number) => {",
          "documentation": "  /**\n   * Set the transaction valid interval to be valid only after the slot\n   * @param slot The transaction is valid only after this slot\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "slot",
              "type": "number",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1409,
          "raw": "  /**\n   * Set the transaction valid interval to be valid only after the slot\n   * @param slot The transaction is valid only after this slot\n   * @returns The MeshTxBuilder instance\n   */\n  invalidBefore = (slot: number) => {\n    this.meshTxBuilderBody.validityRange.invalidBefore = slot;\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  invalidBefore = (slot: number) => {\n    this.meshTxBuilderBody.validityRange.invalidBefore = slot;\n    return this;\n  };"
        },
        {
          "name": "invalidHereafter",
          "signature": "invalidHereafter = (slot: number) => {",
          "documentation": "  /**\n   * Set the transaction valid interval to be valid only before the slot\n   * @param slot The transaction is valid only before this slot\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "slot",
              "type": "number",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1419,
          "raw": "  /**\n   * Set the transaction valid interval to be valid only before the slot\n   * @param slot The transaction is valid only before this slot\n   * @returns The MeshTxBuilder instance\n   */\n  invalidHereafter = (slot: number) => {\n    this.meshTxBuilderBody.validityRange.invalidHereafter = slot;\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  invalidHereafter = (slot: number) => {\n    this.meshTxBuilderBody.validityRange.invalidHereafter = slot;\n    return this;\n  };"
        },
        {
          "name": "signingKey",
          "signature": "signingKey = (skeyHex: string) => {",
          "documentation": "  /**\n   * Sign the transaction with the private key\n   * @param skeyHex The private key in cborHex (with or without 5820 prefix, i.e. the format when generated from cardano-cli)\n   * @returns\n   */",
          "parameters": [
            {
              "name": "skeyHex",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1448,
          "raw": "  /**\n   * Sign the transaction with the private key\n   * @param skeyHex The private key in cborHex (with or without 5820 prefix, i.e. the format when generated from cardano-cli)\n   * @returns\n   */\n  signingKey = (skeyHex: string) => {\n    this.meshTxBuilderBody.signingKey.push(skeyHex);\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  signingKey = (skeyHex: string) => {\n    this.meshTxBuilderBody.signingKey.push(skeyHex);\n    return this;\n  };"
        },
        {
          "name": "selectUtxosFrom",
          "signature": "selectUtxosFrom = (extraInputs: UTxO[]) => {",
          "documentation": "  /**\n   * Selects utxos to fill output value and puts them into inputs\n   * @param extraInputs The inputs already placed into the object will remain, these extra inputs will be used to fill the remaining  value needed\n   */",
          "parameters": [
            {
              "name": "extraInputs",
              "type": "UTxO[]",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1457,
          "raw": "  /**\n   * Selects utxos to fill output value and puts them into inputs\n   * @param extraInputs The inputs already placed into the object will remain, these extra inputs will be used to fill the remaining  value needed\n   */\n  selectUtxosFrom = (extraInputs: UTxO[]) => {\n    for (const input of extraInputs) {\n      const address = input.output.address;\n      if (!address) {\n        throw Error(\"Address is missing from the extra input\");\n      }\n      const decodedAddress = Address.fromString(<HexBlob>address);\n      if (\n        decodedAddress?.getProps().paymentPart?.type !== CredentialType.KeyHash\n      ) {\n        throw Error(\"Only KeyHash address is supported for utxo selection\");\n      }\n    }\n    this.meshTxBuilderBody.extraInputs = extraInputs;\n    this.meshTxBuilderBody.selectionConfig = {\n      ...this.meshTxBuilderBody.selectionConfig,\n    };\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  selectUtxosFrom = (extraInputs: UTxO[]) => {\n    for (const input of extraInputs) {\n      const address = input.output.address;\n      if (!address) {\n        throw Error(\"Address is missing from the extra input\");\n      }\n      const decodedAddress = Address.fromString(<HexBlob>address);\n      if (\n        decodedAddress?.getProps().paymentPart?.type !== CredentialType.KeyHash\n      ) {\n        throw Error(\"Only KeyHash address is supported for utxo selection\");\n      }\n    }\n    this.meshTxBuilderBody.extraInputs = extraInputs;\n    this.meshTxBuilderBody.selectionConfig = {\n      ...this.meshTxBuilderBody.selectionConfig,\n    };\n    return this;\n  };"
        },
        {
          "name": "protocolParams",
          "signature": "protocolParams = (params: Partial<Protocol>) => {",
          "documentation": "  /**\n   * Set the protocol parameters to be used for the transaction other than the default one\n   * @param params (Part of) the protocol parameters to be used for the transaction\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "params",
              "type": "Partial<Protocol>",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1482,
          "raw": "  /**\n   * Set the protocol parameters to be used for the transaction other than the default one\n   * @param params (Part of) the protocol parameters to be used for the transaction\n   * @returns The MeshTxBuilder instance\n   */\n  protocolParams = (params: Partial<Protocol>) => {\n    const updatedParams = { ...DEFAULT_PROTOCOL_PARAMETERS, ...params };\n    this._protocolParams = updatedParams;\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  protocolParams = (params: Partial<Protocol>) => {\n    const updatedParams = { ...DEFAULT_PROTOCOL_PARAMETERS, ...params };\n    this._protocolParams = updatedParams;\n    return this;\n  };"
        },
        {
          "name": "setFee",
          "signature": "setFee = (fee: string) => {",
          "documentation": "  /**\n   * Sets a specific fee for the transaction to use\n   * @param fee The specified fee\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "fee",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1493,
          "raw": "  /**\n   * Sets a specific fee for the transaction to use\n   * @param fee The specified fee\n   * @returns The MeshTxBuilder instance\n   */\n  setFee = (fee: string) => {\n    this.manualFee = fee;\n    this.meshTxBuilderBody.fee = fee;\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  setFee = (fee: string) => {\n    this.manualFee = fee;\n    this.meshTxBuilderBody.fee = fee;\n    return this;\n  };"
        },
        {
          "name": "setTotalCollateral",
          "signature": "setTotalCollateral = (collateral: string) => {",
          "documentation": "  /**\n   * Sets a total collateral for the transaction to use, a collateral return\n   * will be generated to either the change address or the specified collateral return address\n   * @param collateral The specified collateral\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "collateral",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1505,
          "raw": "  /**\n   * Sets a total collateral for the transaction to use, a collateral return\n   * will be generated to either the change address or the specified collateral return address\n   * @param collateral The specified collateral\n   * @returns The MeshTxBuilder instance\n   */\n  setTotalCollateral = (collateral: string) => {\n    this.meshTxBuilderBody.totalCollateral = collateral;\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  setTotalCollateral = (collateral: string) => {\n    this.meshTxBuilderBody.totalCollateral = collateral;\n    return this;\n  };"
        },
        {
          "name": "setCollateralReturnAddress",
          "signature": "setCollateralReturnAddress = (address: string) => {",
          "documentation": "  /**\n   * Sets the collateral return address, if none is set, the change address will be used\n   * @param address The address to use for collateral return\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "address",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1515,
          "raw": "  /**\n   * Sets the collateral return address, if none is set, the change address will be used\n   * @param address The address to use for collateral return\n   * @returns The MeshTxBuilder instance\n   */\n  setCollateralReturnAddress = (address: string) => {\n    this.meshTxBuilderBody.collateralReturnAddress = address;\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  setCollateralReturnAddress = (address: string) => {\n    this.meshTxBuilderBody.collateralReturnAddress = address;\n    return this;\n  };"
        },
        {
          "name": "setNetwork",
          "signature": "setNetwork = (network: Network | number[][]) => {",
          "documentation": "  /**\n   * Sets the network to use, this is mainly to know the cost models to be used to calculate script integrity hash\n   * @param network The specific network this transaction is being built for (\"testnet\" | \"preview\" | \"preprod\" | \"mainnet\")\n   * @returns The MeshTxBuilder instance\n   */",
          "parameters": [
            {
              "name": "network",
              "type": "Network | number[][]",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1525,
          "raw": "  /**\n   * Sets the network to use, this is mainly to know the cost models to be used to calculate script integrity hash\n   * @param network The specific network this transaction is being built for (\"testnet\" | \"preview\" | \"preprod\" | \"mainnet\")\n   * @returns The MeshTxBuilder instance\n   */\n  setNetwork = (network: Network | number[][]) => {\n    this.meshTxBuilderBody.network = network;\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  setNetwork = (network: Network | number[][]) => {\n    this.meshTxBuilderBody.network = network;\n    return this;\n  };"
        },
        {
          "name": "chainTx",
          "signature": "chainTx(txHex: string): this {",
          "documentation": "  /**\n   * Add a transaction that is used as input, but not yet reflected on the global blockchain\n   * @param txHex The transaction hex of chained transaction\n   * @returns The MeshTxBuilderCore instance\n   */",
          "parameters": [
            {
              "name": "txHex",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "this",
          "isPublic": true,
          "line": 1535,
          "raw": "  /**\n   * Add a transaction that is used as input, but not yet reflected on the global blockchain\n   * @param txHex The transaction hex of chained transaction\n   * @returns The MeshTxBuilderCore instance\n   */\n  chainTx(txHex: string): this {\n    this.meshTxBuilderBody.chainedTxs.push(txHex);\n    return this;\n  }",
          "source": "mesh-transaction",
          "implementation": "  chainTx(txHex: string): this {\n    this.meshTxBuilderBody.chainedTxs.push(txHex);\n    return this;\n  }"
        },
        {
          "name": "addUtxosFromSelection",
          "signature": "addUtxosFromSelection = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 1853,
          "raw": "  addUtxosFromSelection = () => {\n    const requiredAssets = this.meshTxBuilderBody.outputs.reduce(\n      (map, output) => {\n        const outputAmount = output.amount;\n        outputAmount.forEach((asset) => {\n          const { unit, quantity } = asset;\n          const existingQuantity = Number(map.get(unit)) || 0;\n          map.set(unit, String(existingQuantity + Number(quantity)));\n        });\n        return map;\n      },\n      new Map<Unit, Quantity>(),\n    );\n    this.meshTxBuilderBody.inputs.reduce((map, input) => {\n      const inputAmount = input.txIn.amount;\n      inputAmount?.forEach((asset) => {\n        const { unit, quantity } = asset;\n        const existingQuantity = Number(map.get(unit)) || 0;\n        map.set(unit, String(existingQuantity - Number(quantity)));\n      });\n      return map;\n    }, requiredAssets);\n    this.meshTxBuilderBody.mints.reduce((map, mint) => {\n      for (const assetValue of mint.mintValue) {\n        const mintAmount: Asset = {\n          unit: mint.policyId + assetValue.assetName,\n          quantity: String(assetValue.amount),\n        };\n        const existingQuantity = Number(map.get(mintAmount.unit)) || 0;\n        map.set(\n          mintAmount.unit,\n          String(existingQuantity - Number(mintAmount.quantity)),\n        );\n      }\n      return map;\n    }, requiredAssets);\n    const selectionConfig = this.meshTxBuilderBody.selectionConfig;\n\n    const utxoSelection = new UtxoSelection(\n      selectionConfig.threshold,\n      selectionConfig.includeTxFees,\n    );\n\n    let selectedInputs: UTxO[] = [];\n    switch (selectionConfig.strategy) {\n      case \"keepRelevant\":\n        selectedInputs = utxoSelection.keepRelevant(\n          requiredAssets,\n          this.meshTxBuilderBody.extraInputs,\n        );\n      case \"largestFirst\":\n        selectedInputs = utxoSelection.largestFirst(\n          requiredAssets,\n          this.meshTxBuilderBody.extraInputs,\n        );\n        break;\n\n      case \"largestFirstMultiAsset\":\n        selectedInputs = utxoSelection.largestFirstMultiAsset(\n          requiredAssets,\n          this.meshTxBuilderBody.extraInputs,\n        );\n        break;\n\n      default:\n        selectedInputs = utxoSelection.experimental(\n          requiredAssets,\n          this.meshTxBuilderBody.extraInputs,\n        );\n        break;\n    }\n\n    selectedInputs.forEach((input) => {\n      const pubKeyTxIn: PubKeyTxIn = {\n        type: \"PubKey\",\n        txIn: {\n          txHash: input.input.txHash,\n          txIndex: input.input.outputIndex,\n          amount: input.output.amount,\n          address: input.output.address,\n        },\n      };\n      this.meshTxBuilderBody.inputs.push(pubKeyTxIn);\n      // If an input selected has script ref, then we must\n      // provide the script size to the tx builder also\n      if (input.output.scriptRef) {\n        this.meshTxBuilderBody.referenceInputs.push({\n          txHash: input.input.txHash,\n          txIndex: input.input.outputIndex,\n          scriptSize: input.output.scriptRef!.length / 2,\n        });\n      }\n      this.inputForEvaluation(input);\n    });\n  };",
          "source": "mesh-transaction",
          "implementation": "  addUtxosFromSelection = () => {\n    const requiredAssets = this.meshTxBuilderBody.outputs.reduce(\n      (map, output) => {\n        const outputAmount = output.amount;\n        outputAmount.forEach((asset) => {\n          const { unit, quantity } = asset;\n          const existingQuantity = Number(map.get(unit)) || 0;\n          map.set(unit, String(existingQuantity + Number(quantity)));\n        });\n        return map;\n      },\n      new Map<Unit, Quantity>(),\n    );\n    this.meshTxBuilderBody.inputs.reduce((map, input) => {\n      const inputAmount = input.txIn.amount;\n      inputAmount?.forEach((asset) => {\n        const { unit, quantity } = asset;\n        const existingQuantity = Number(map.get(unit)) || 0;\n        map.set(unit, String(existingQuantity - Number(quantity)));\n      });\n      return map;\n    }, requiredAssets);\n    this.meshTxBuilderBody.mints.reduce((map, mint) => {\n      for (const assetValue of mint.mintValue) {\n        const mintAmount: Asset = {\n          unit: mint.policyId + assetValue.assetName,\n          quantity: String(assetValue.amount),\n        };\n        const existingQuantity = Number(map.get(mintAmount.unit)) || 0;\n        map.set(\n          mintAmount.unit,\n          String(existingQuantity - Number(mintAmount.quantity)),\n        );\n      }\n      return map;\n    }, requiredAssets);\n    const selectionConfig = this.meshTxBuilderBody.selectionConfig;\n\n    const utxoSelection = new UtxoSelection(\n      selectionConfig.threshold,\n      selectionConfig.includeTxFees,\n    );\n\n    let selectedInputs: UTxO[] = [];\n    switch (selectionConfig.strategy) {\n      case \"keepRelevant\":\n        selectedInputs = utxoSelection.keepRelevant(\n          requiredAssets,\n          this.meshTxBuilderBody.extraInputs,\n        );\n      case \"largestFirst\":\n        selectedInputs = utxoSelection.largestFirst(\n          requiredAssets,\n          this.meshTxBuilderBody.extraInputs,\n        );\n        break;\n\n      case \"largestFirstMultiAsset\":\n        selectedInputs = utxoSelection.largestFirstMultiAsset(\n          requiredAssets,\n          this.meshTxBuilderBody.extraInputs,\n        );\n        break;\n\n      default:\n        selectedInputs = utxoSelection.experimental(\n          requiredAssets,\n          this.meshTxBuilderBody.extraInputs,\n        );\n        break;\n    }\n\n    selectedInputs.forEach((input) => {\n      const pubKeyTxIn: PubKeyTxIn = {\n        type: \"PubKey\",\n        txIn: {\n          txHash: input.input.txHash,\n          txIndex: input.input.outputIndex,\n          amount: input.output.amount,\n          address: input.output.address,\n        },\n      };\n      this.meshTxBuilderBody.inputs.push(pubKeyTxIn);\n      // If an input selected has script ref, then we must\n      // provide the script size to the tx builder also\n      if (input.output.scriptRef) {\n        this.meshTxBuilderBody.referenceInputs.push({\n          txHash: input.input.txHash,\n          txIndex: input.input.outputIndex,\n          scriptSize: input.output.scriptRef!.length / 2,\n        });\n      }\n      this.inputForEvaluation(input);\n    });\n  };"
        },
        {
          "name": "removeDuplicateInputs",
          "signature": "removeDuplicateInputs = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 1949,
          "raw": "  removeDuplicateInputs = () => {\n    const { inputs } = this.meshTxBuilderBody;\n    const getTxInId = (txIn: TxInParameter): string =>\n      `${txIn.txHash}#${txIn.txIndex}`;\n    const currentTxInIds: string[] = [];\n    const addedInputs: TxIn[] = [];\n    for (let i = 0; i < inputs.length; i += 1) {\n      const currentInput = inputs[i]!;\n      const currentTxInId = getTxInId(currentInput.txIn);\n      if (currentTxInIds.includes(currentTxInId)) {\n        continue;\n      } else {\n        currentTxInIds.push(currentTxInId);\n        addedInputs.push(currentInput);\n      }\n    }\n    this.meshTxBuilderBody.inputs = addedInputs;\n  };",
          "source": "mesh-transaction",
          "implementation": "  removeDuplicateInputs = () => {\n    const { inputs } = this.meshTxBuilderBody;\n    const getTxInId = (txIn: TxInParameter): string =>\n      `${txIn.txHash}#${txIn.txIndex}`;\n    const currentTxInIds: string[] = [];\n    const addedInputs: TxIn[] = [];\n    for (let i = 0; i < inputs.length; i += 1) {\n      const currentInput = inputs[i]!;\n      const currentTxInId = getTxInId(currentInput.txIn);\n      if (currentTxInIds.includes(currentTxInId)) {\n        continue;\n      } else {\n        currentTxInIds.push(currentTxInId);\n        addedInputs.push(currentInput);\n      }\n    }\n    this.meshTxBuilderBody.inputs = addedInputs;\n  };"
        },
        {
          "name": "getTxInId",
          "signature": "const getTxInId = (txIn: TxInParameter): string =>",
          "documentation": "",
          "parameters": [
            {
              "name": "txIn",
              "type": "TxInParameter",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 1951,
          "raw": "    const getTxInId = (txIn: TxInParameter): string =>\n      `${txIn.txHash}#${txIn.txIndex}`;",
          "source": "mesh-transaction",
          "implementation": "    const getTxInId = (txIn: TxInParameter): string =>\n      `${txIn.txHash}#${txIn.txIndex}`;"
        },
        {
          "name": "removeDuplicateRefInputs",
          "signature": "removeDuplicateRefInputs = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 1968,
          "raw": "  removeDuplicateRefInputs = () => {\n    const { referenceInputs } = this.meshTxBuilderBody;\n    const getTxInId = (txIn: RefTxIn): string =>\n      `${txIn.txHash}#${txIn.txIndex}`;\n    const currentTxInIds: string[] = [];\n    const addedInputs: RefTxIn[] = [];\n    for (let i = 0; i < referenceInputs.length; i += 1) {\n      const currentInput = referenceInputs[i]!;\n      const currentTxInId = getTxInId(currentInput);\n      if (currentTxInIds.includes(currentTxInId)) {\n        continue;\n      } else {\n        currentTxInIds.push(currentTxInId);\n        addedInputs.push(currentInput);\n      }\n    }\n    this.meshTxBuilderBody.referenceInputs = addedInputs;\n  };",
          "source": "mesh-transaction",
          "implementation": "  removeDuplicateRefInputs = () => {\n    const { referenceInputs } = this.meshTxBuilderBody;\n    const getTxInId = (txIn: RefTxIn): string =>\n      `${txIn.txHash}#${txIn.txIndex}`;\n    const currentTxInIds: string[] = [];\n    const addedInputs: RefTxIn[] = [];\n    for (let i = 0; i < referenceInputs.length; i += 1) {\n      const currentInput = referenceInputs[i]!;\n      const currentTxInId = getTxInId(currentInput);\n      if (currentTxInIds.includes(currentTxInId)) {\n        continue;\n      } else {\n        currentTxInIds.push(currentTxInId);\n        addedInputs.push(currentInput);\n      }\n    }\n    this.meshTxBuilderBody.referenceInputs = addedInputs;\n  };"
        },
        {
          "name": "getTxInId",
          "signature": "const getTxInId = (txIn: RefTxIn): string =>",
          "documentation": "",
          "parameters": [
            {
              "name": "txIn",
              "type": "RefTxIn",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 1970,
          "raw": "    const getTxInId = (txIn: RefTxIn): string =>\n      `${txIn.txHash}#${txIn.txIndex}`;",
          "source": "mesh-transaction",
          "implementation": "    const getTxInId = (txIn: RefTxIn): string =>\n      `${txIn.txHash}#${txIn.txIndex}`;"
        },
        {
          "name": "emptyTxBuilderBody",
          "signature": "emptyTxBuilderBody = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 1987,
          "raw": "  emptyTxBuilderBody = () => {\n    this.meshTxBuilderBody = emptyTxBuilderBody();\n    return emptyTxBuilderBody;\n  };",
          "source": "mesh-transaction",
          "implementation": "  emptyTxBuilderBody = () => {\n    this.meshTxBuilderBody = emptyTxBuilderBody();\n    return emptyTxBuilderBody;\n  };"
        },
        {
          "name": "reset",
          "signature": "reset = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 1992,
          "raw": "  reset = () => {\n    this.meshTxBuilderBody = emptyTxBuilderBody();\n    this.txEvaluationMultiplier = 1;\n    this.txOutput = undefined;\n    this.addingPlutusScriptInput = false;\n    this.plutusSpendingScriptVersion = undefined;\n    this.addingPlutusMint = false;\n    this.plutusMintingScriptVersion = undefined;\n    this.addingPlutusWithdrawal = false;\n    this.addingPlutusVote = false;\n    this.plutusWithdrawalScriptVersion = undefined;\n    this._protocolParams = DEFAULT_PROTOCOL_PARAMETERS;\n    this.mintItem = undefined;\n    this.txInQueueItem = undefined;\n    this.withdrawalItem = undefined;\n    this.voteItem = undefined;\n    this.collateralQueueItem = undefined;\n    this.refScriptTxInQueueItem = undefined;\n  };",
          "source": "mesh-transaction",
          "implementation": "  reset = () => {\n    this.meshTxBuilderBody = emptyTxBuilderBody();\n    this.txEvaluationMultiplier = 1;\n    this.txOutput = undefined;\n    this.addingPlutusScriptInput = false;\n    this.plutusSpendingScriptVersion = undefined;\n    this.addingPlutusMint = false;\n    this.plutusMintingScriptVersion = undefined;\n    this.addingPlutusWithdrawal = false;\n    this.addingPlutusVote = false;\n    this.plutusWithdrawalScriptVersion = undefined;\n    this._protocolParams = DEFAULT_PROTOCOL_PARAMETERS;\n    this.mintItem = undefined;\n    this.txInQueueItem = undefined;\n    this.withdrawalItem = undefined;\n    this.voteItem = undefined;\n    this.collateralQueueItem = undefined;\n    this.refScriptTxInQueueItem = undefined;\n  };"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "withdrawal",
          "type": "Withdrawal",
          "value": "{",
          "isPublic": true,
          "line": 828,
          "raw": "const withdrawal: Withdrawal = {",
          "source": "mesh-transaction"
        },
        {
          "name": "withdrawal",
          "type": "Withdrawal",
          "value": "{",
          "isPublic": true,
          "line": 838,
          "raw": "const withdrawal: Withdrawal = {",
          "source": "mesh-transaction"
        },
        {
          "name": "vote",
          "type": "Vote",
          "value": "{",
          "isPublic": true,
          "line": 992,
          "raw": "const vote: Vote = {",
          "source": "mesh-transaction"
        },
        {
          "name": "vote",
          "type": "Vote",
          "value": "{",
          "isPublic": true,
          "line": 1003,
          "raw": "const vote: Vote = {",
          "source": "mesh-transaction"
        },
        {
          "name": "currentCert",
          "type": "any",
          "value": "this.meshTxBuilderBody.certificates.pop();",
          "isPublic": true,
          "line": 1280,
          "raw": "const currentCert = this.meshTxBuilderBody.certificates.pop();",
          "source": "mesh-transaction"
        },
        {
          "name": "currentCert",
          "type": "any",
          "value": "this.meshTxBuilderBody.certificates.pop();",
          "isPublic": true,
          "line": 1330,
          "raw": "const currentCert = this.meshTxBuilderBody.certificates.pop();",
          "source": "mesh-transaction"
        },
        {
          "name": "currentCert",
          "type": "any",
          "value": "this.meshTxBuilderBody.certificates.pop();",
          "isPublic": true,
          "line": 1373,
          "raw": "const currentCert = this.meshTxBuilderBody.certificates.pop();",
          "source": "mesh-transaction"
        },
        {
          "name": "address",
          "type": "any",
          "value": "input.output.address;",
          "isPublic": true,
          "line": 1459,
          "raw": "const address = input.output.address;",
          "source": "mesh-transaction"
        },
        {
          "name": "decodedAddress",
          "type": "any",
          "value": "Address.fromString(<HexBlob>address);",
          "isPublic": true,
          "line": 1463,
          "raw": "const decodedAddress = Address.fromString(<HexBlob>address);",
          "source": "mesh-transaction"
        },
        {
          "name": "updatedParams",
          "type": "any",
          "value": "{ ...DEFAULT_PROTOCOL_PARAMETERS, ...params };",
          "isPublic": true,
          "line": 1483,
          "raw": "const updatedParams = { ...DEFAULT_PROTOCOL_PARAMETERS, ...params };",
          "source": "mesh-transaction"
        },
        {
          "name": "utxoId",
          "type": "any",
          "value": "`${input.input.txHash}${input.input.outputIndex}`;",
          "isPublic": true,
          "line": 1546,
          "raw": "const utxoId = `${input.input.txHash}${input.input.outputIndex}`;",
          "source": "mesh-transaction"
        },
        {
          "name": "currentUtxo",
          "type": "any",
          "value": "this.meshTxBuilderBody.inputsForEvaluation[utxoId];",
          "isPublic": true,
          "line": 1547,
          "raw": "const currentUtxo = this.meshTxBuilderBody.inputsForEvaluation[utxoId];",
          "source": "mesh-transaction"
        },
        {
          "name": "updatedUtxo",
          "type": "UTxO",
          "value": "{ ...currentUtxo };",
          "isPublic": true,
          "line": 1557,
          "raw": "const updatedUtxo: UTxO = { ...currentUtxo };",
          "source": "mesh-transaction"
        },
        {
          "name": "currentMint",
          "type": "MintItem",
          "value": "this.mintItem;",
          "isPublic": true,
          "line": 1623,
          "raw": "const currentMint: MintItem = this.mintItem;",
          "source": "mesh-transaction"
        },
        {
          "name": "txEvaluationMultiplier",
          "type": "any",
          "value": "doNotUseMultiplier",
          "isPublic": true,
          "line": 1748,
          "raw": "const txEvaluationMultiplier = doNotUseMultiplier",
          "source": "mesh-transaction"
        },
        {
          "name": "input",
          "type": "any",
          "value": "meshTxBuilderBody.inputs[redeemerEvaluation.index];",
          "isPublic": true,
          "line": 1754,
          "raw": "const input = meshTxBuilderBody.inputs[redeemerEvaluation.index];",
          "source": "mesh-transaction"
        },
        {
          "name": "mint",
          "type": "any",
          "value": "meshTxBuilderBody.mints[redeemerEvaluation.index];",
          "isPublic": true,
          "line": 1771,
          "raw": "const mint = meshTxBuilderBody.mints[redeemerEvaluation.index];",
          "source": "mesh-transaction"
        },
        {
          "name": "cert",
          "type": "any",
          "value": "meshTxBuilderBody.certificates[redeemerEvaluation.index];",
          "isPublic": true,
          "line": 1801,
          "raw": "const cert = meshTxBuilderBody.certificates[redeemerEvaluation.index];",
          "source": "mesh-transaction"
        },
        {
          "name": "vote",
          "type": "any",
          "value": "meshTxBuilderBody.votes[redeemerEvaluation.index];",
          "isPublic": true,
          "line": 1834,
          "raw": "const vote = meshTxBuilderBody.votes[redeemerEvaluation.index];",
          "source": "mesh-transaction"
        },
        {
          "name": "requiredAssets",
          "type": "any",
          "value": "this.meshTxBuilderBody.outputs.reduce(",
          "isPublic": true,
          "line": 1854,
          "raw": "const requiredAssets = this.meshTxBuilderBody.outputs.reduce(",
          "source": "mesh-transaction"
        },
        {
          "name": "outputAmount",
          "type": "any",
          "value": "output.amount;",
          "isPublic": true,
          "line": 1856,
          "raw": "const outputAmount = output.amount;",
          "source": "mesh-transaction"
        },
        {
          "name": "existingQuantity",
          "type": "any",
          "value": "Number(map.get(unit)) || 0;",
          "isPublic": true,
          "line": 1859,
          "raw": "const existingQuantity = Number(map.get(unit)) || 0;",
          "source": "mesh-transaction"
        },
        {
          "name": "inputAmount",
          "type": "any",
          "value": "input.txIn.amount;",
          "isPublic": true,
          "line": 1867,
          "raw": "const inputAmount = input.txIn.amount;",
          "source": "mesh-transaction"
        },
        {
          "name": "existingQuantity",
          "type": "any",
          "value": "Number(map.get(unit)) || 0;",
          "isPublic": true,
          "line": 1870,
          "raw": "const existingQuantity = Number(map.get(unit)) || 0;",
          "source": "mesh-transaction"
        },
        {
          "name": "mintAmount",
          "type": "Asset",
          "value": "{",
          "isPublic": true,
          "line": 1877,
          "raw": "const mintAmount: Asset = {",
          "source": "mesh-transaction"
        },
        {
          "name": "existingQuantity",
          "type": "any",
          "value": "Number(map.get(mintAmount.unit)) || 0;",
          "isPublic": true,
          "line": 1881,
          "raw": "const existingQuantity = Number(map.get(mintAmount.unit)) || 0;",
          "source": "mesh-transaction"
        },
        {
          "name": "selectionConfig",
          "type": "any",
          "value": "this.meshTxBuilderBody.selectionConfig;",
          "isPublic": true,
          "line": 1889,
          "raw": "const selectionConfig = this.meshTxBuilderBody.selectionConfig;",
          "source": "mesh-transaction"
        },
        {
          "name": "utxoSelection",
          "type": "any",
          "value": "new UtxoSelection(",
          "isPublic": true,
          "line": 1891,
          "raw": "const utxoSelection = new UtxoSelection(",
          "source": "mesh-transaction"
        },
        {
          "name": "pubKeyTxIn",
          "type": "PubKeyTxIn",
          "value": "{",
          "isPublic": true,
          "line": 1926,
          "raw": "const pubKeyTxIn: PubKeyTxIn = {",
          "source": "mesh-transaction"
        },
        {
          "name": "getTxInId",
          "type": "any",
          "value": "(txIn: TxInParameter): string =>",
          "isPublic": true,
          "line": 1951,
          "raw": "const getTxInId = (txIn: TxInParameter): string =>",
          "source": "mesh-transaction"
        },
        {
          "name": "currentTxInIds",
          "type": "string[]",
          "value": "[];",
          "isPublic": true,
          "line": 1953,
          "raw": "const currentTxInIds: string[] = [];",
          "source": "mesh-transaction"
        },
        {
          "name": "addedInputs",
          "type": "TxIn[]",
          "value": "[];",
          "isPublic": true,
          "line": 1954,
          "raw": "const addedInputs: TxIn[] = [];",
          "source": "mesh-transaction"
        },
        {
          "name": "currentInput",
          "type": "any",
          "value": "inputs[i]!;",
          "isPublic": true,
          "line": 1956,
          "raw": "const currentInput = inputs[i]!;",
          "source": "mesh-transaction"
        },
        {
          "name": "currentTxInId",
          "type": "any",
          "value": "getTxInId(currentInput.txIn);",
          "isPublic": true,
          "line": 1957,
          "raw": "const currentTxInId = getTxInId(currentInput.txIn);",
          "source": "mesh-transaction"
        },
        {
          "name": "getTxInId",
          "type": "any",
          "value": "(txIn: RefTxIn): string =>",
          "isPublic": true,
          "line": 1970,
          "raw": "const getTxInId = (txIn: RefTxIn): string =>",
          "source": "mesh-transaction"
        },
        {
          "name": "currentTxInIds",
          "type": "string[]",
          "value": "[];",
          "isPublic": true,
          "line": 1972,
          "raw": "const currentTxInIds: string[] = [];",
          "source": "mesh-transaction"
        },
        {
          "name": "addedInputs",
          "type": "RefTxIn[]",
          "value": "[];",
          "isPublic": true,
          "line": 1973,
          "raw": "const addedInputs: RefTxIn[] = [];",
          "source": "mesh-transaction"
        },
        {
          "name": "currentInput",
          "type": "any",
          "value": "referenceInputs[i]!;",
          "isPublic": true,
          "line": 1975,
          "raw": "const currentInput = referenceInputs[i]!;",
          "source": "mesh-transaction"
        },
        {
          "name": "currentTxInId",
          "type": "any",
          "value": "getTxInId(currentInput);",
          "isPublic": true,
          "line": 1976,
          "raw": "const currentTxInId = getTxInId(currentInput);",
          "source": "mesh-transaction"
        },
        {
          "name": "newBuilder",
          "type": "any",
          "value": "createInstance();",
          "isPublic": true,
          "line": 2017,
          "raw": "const newBuilder = createInstance();",
          "source": "mesh-transaction"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { HexBlob } from \"@cardano-sdk/util\";\nimport JSONBig from \"json-bigint\";\n\nimport {\n  Action,\n  Anchor,\n  Asset,\n  Budget,\n  BuilderData,\n  cloneTxBuilderBody,\n  Data,\n  DEFAULT_PROTOCOL_PARAMETERS,\n  DEFAULT_REDEEMER_BUDGET,\n  DRep,\n  DREP_DEPOSIT,\n  emptyTxBuilderBody,\n  LanguageVersion,\n  MeshTxBuilderBody,\n  Metadatum,\n  MintItem,\n  MintParam,\n  Network,\n  Output,\n  PoolParams,\n  Protocol,\n  PubKeyTxIn,\n  Quantity,\n  Redeemer,\n  RefTxIn,\n  TxIn,\n  TxInParameter,\n  Unit,\n  UTxO,\n  UtxoSelection,\n  Vote,\n  Voter,\n  VotingProcedure,\n  Withdrawal,\n} from \"@meshsdk/common\";\nimport { Address, CredentialType } from \"@meshsdk/core-cst\";\n\nimport { metadataObjToMap } from \"../utils\";\n\nexport class MeshTxBuilderCore {\n  txEvaluationMultiplier = 1;\n  private txOutput?: Output;\n  private addingPlutusScriptInput = false;\n  private plutusSpendingScriptVersion: LanguageVersion | undefined;\n  private addingPlutusMint = false;\n  private plutusMintingScriptVersion: LanguageVersion | undefined;\n  private addingPlutusWithdrawal = false;\n  private plutusWithdrawalScriptVersion: LanguageVersion | undefined;\n  private addingPlutusVote = false;\n  private plutusVoteScriptVersion: LanguageVersion | undefined;\n\n  protected manualFee: string | undefined;\n\n  protected _protocolParams: Protocol = DEFAULT_PROTOCOL_PARAMETERS;\n\n  protected mintItem?: MintItem;\n\n  protected txInQueueItem?: TxIn;\n\n  protected withdrawalItem?: Withdrawal;\n\n  protected voteItem?: Vote;\n\n  protected collateralQueueItem?: PubKeyTxIn;\n\n  protected refScriptTxInQueueItem?: RefTxIn;\n\n  meshTxBuilderBody: MeshTxBuilderBody;\n\n  constructor() {\n    this.meshTxBuilderBody = emptyTxBuilderBody();\n  }\n\n  /**\n   * Set the input for transaction\n   * @param txHash The transaction hash of the input UTxO\n   * @param txIndex The transaction index of the input UTxO\n   * @param amount The asset amount of index of the input UTxO\n   * @param address The address of the input UTxO\n   * @param scriptSize The size of the ref script at this input (if there isn't one, explicitly put 0 as scriptSize for offline tx building)\n   * @returns The MeshTxBuilder instance\n   */\n  txIn = (\n    txHash: string,\n    txIndex: number,\n    amount?: Asset[],\n    address?: string,\n    scriptSize?: number,\n  ) => {\n    if (this.txInQueueItem) {\n      this.queueInput();\n    }\n    if (!this.addingPlutusScriptInput) {\n      this.txInQueueItem = {\n        type: \"PubKey\",\n        txIn: {\n          txHash: txHash,\n          txIndex: txIndex,\n          amount: amount,\n          address: address,\n          scriptSize: scriptSize,\n        },\n      };\n    } else {\n      this.txInQueueItem = {\n        type: \"Script\",\n        txIn: {\n          txHash: txHash,\n          txIndex: txIndex,\n          amount: amount,\n          address: address,\n          scriptSize: scriptSize,\n        },\n        scriptTxIn: {},\n      };\n    }\n    this.addingPlutusScriptInput = false;\n    return this;\n  };\n\n  /**\n   * Set the script for transaction input\n   * @param {string} scriptCbor The CborHex of the script\n   * @param version Optional - The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */\n  txInScript = (scriptCbor: string) => {\n    if (!this.txInQueueItem) throw Error(\"Undefined input\");\n    if (this.txInQueueItem.type === \"PubKey\") {\n      this.txInQueueItem = {\n        type: \"SimpleScript\",\n        txIn: this.txInQueueItem.txIn,\n        simpleScriptTxIn: {\n          scriptSource: {\n            type: \"Provided\",\n            scriptCode: scriptCbor,\n          },\n        },\n      };\n    }\n    if (this.txInQueueItem.type === \"Script\") {\n      this.txInQueueItem.scriptTxIn.scriptSource = {\n        type: \"Provided\",\n        script: {\n          code: scriptCbor,\n          version: this.plutusSpendingScriptVersion || \"V2\",\n        },\n      };\n    }\n    return this;\n  };\n\n  /**\n   * Set the input datum for transaction input\n   * @param datum The datum in Mesh Data type, JSON in raw constructor like format, or CBOR hex string\n   * @param type The datum type, either Mesh Data type, JSON in raw constructor like format, or CBOR hex string. Default to be Mesh type\n   * @returns The MeshTxBuilder instance\n   */\n  txInDatumValue = (\n    datum: BuilderData[\"content\"],\n    type: BuilderData[\"type\"] = \"Mesh\",\n  ) => {\n    if (!this.txInQueueItem) throw Error(\"Undefined input\");\n    if (this.txInQueueItem.type === \"PubKey\")\n      throw Error(\"Datum value attempted to be called a non script input\");\n    if (this.txInQueueItem.type === \"SimpleScript\")\n      throw Error(\n        \"Datum value attempted to be called on a simple script input\",\n      );\n\n    let content = datum;\n    if (type === \"JSON\") {\n      content = this.castRawDataToJsonString(datum as object | string);\n    }\n    if (type === \"Mesh\") {\n      this.txInQueueItem.scriptTxIn.datumSource = {\n        type: \"Provided\",\n        data: {\n          type,\n          content: datum as Data,\n        },\n      };\n      return this;\n    }\n    this.txInQueueItem.scriptTxIn.datumSource = {\n      type: \"Provided\",\n      data: {\n        type,\n        content: content as string,\n      },\n    };\n    return this;\n  };\n\n  /**\n   * Tell the transaction builder that the input UTxO has inlined datum\n   * @returns The MeshTxBuilder instance\n   */\n  txInInlineDatumPresent = () => {\n    if (!this.txInQueueItem) throw Error(\"Undefined input\");\n    if (this.txInQueueItem.type === \"PubKey\")\n      throw Error(\n        \"Inline datum present attempted to be called a non script input\",\n      );\n    if (this.txInQueueItem.type === \"SimpleScript\")\n      throw Error(\n        \"Inline datum present attempted to be called on a simple script input\",\n      );\n    const { txHash, txIndex } = this.txInQueueItem.txIn;\n    if (txHash && txIndex.toString()) {\n      this.txInQueueItem.scriptTxIn.datumSource = {\n        type: \"Inline\",\n        txHash,\n        txIndex,\n      };\n    }\n    return this;\n  };\n\n  /**\n   * Native script - Set the reference input where it would also be spent in the transaction\n   * @param txHash The transaction hash of the reference UTxO\n   * @param txIndex The transaction index of the reference UTxO\n   * @param spendingScriptHash The script hash of the spending script\n   * @returns The MeshTxBuilder instance\n   */\n  simpleScriptTxInReference = (\n    txHash: string,\n    txIndex: number,\n    spendingScriptHash?: string,\n    scriptSize?: string,\n  ) => {\n    if (!this.txInQueueItem) throw Error(\"Undefined input\");\n    if (this.txInQueueItem.type === \"Script\") {\n      throw Error(\n        \"simpleScriptTxInReference called on a plutus script, use spendingTxInReference instead\",\n      );\n    }\n    if (this.txInQueueItem.type === \"SimpleScript\") {\n      throw Error(\n        \"simpleScriptTxInReference called on a native script input that already has a script defined\",\n      );\n    }\n    if (this.txInQueueItem.type === \"PubKey\") {\n      this.txInQueueItem = {\n        type: \"SimpleScript\",\n        txIn: this.txInQueueItem.txIn,\n        simpleScriptTxIn: {\n          scriptSource: {\n            type: \"Inline\",\n            txHash,\n            txIndex,\n            simpleScriptHash: spendingScriptHash,\n            scriptSize,\n          },\n        },\n      };\n    }\n    return this;\n  };\n\n  /**\n   * Set the redeemer for the reference input to be spent in same transaction\n   * @param redeemer The redeemer in Mesh Data type, JSON in raw constructor like format, or CBOR hex string\n   * @param type The redeemer data type, either Mesh Data type, JSON in raw constructor like format, or CBOR hex string. Default to be Mesh type\n   * @param exUnits The execution units budget for the redeemer\n   * @returns The MeshTxBuilder instance\n   */\n  txInRedeemerValue = (\n    redeemer: BuilderData[\"content\"],\n    type: BuilderData[\"type\"] = \"Mesh\",\n    exUnits = { ...DEFAULT_REDEEMER_BUDGET },\n  ) => {\n    if (!this.txInQueueItem) throw Error(\"Undefined input\");\n    if (this.txInQueueItem.type === \"PubKey\")\n      throw Error(\n        \"Spending tx in reference redeemer attempted to be called a non script input\",\n      );\n    if (this.txInQueueItem.type === \"SimpleScript\")\n      throw Error(\n        \"Spending tx in reference redeemer attempted to be called on a simple script input\",\n      );\n    this.txInQueueItem.scriptTxIn.redeemer = this.castBuilderDataToRedeemer(\n      redeemer,\n      type,\n      exUnits,\n    );\n    return this;\n  };\n\n  /**\n   * Set the output for transaction\n   * @param {string} address The recipient of the output\n   * @param {Asset[]} amount The amount of other native assets attached with UTxO\n   * @returns The MeshTxBuilder instance\n   */\n  txOut = (address: string, amount: Asset[]) => {\n    if (this.txOutput) {\n      this.meshTxBuilderBody.outputs.push(this.txOutput);\n      this.txOutput = undefined;\n    }\n    this.txOutput = {\n      address,\n      amount,\n    };\n    return this;\n  };\n\n  /**\n   * Set the output datum hash for transaction\n   * @param datum The datum in Mesh Data type, JSON in raw constructor like format, or CBOR hex string\n   * @param type The datum type, either Mesh Data type, JSON in raw constructor like format, or CBOR hex string. Default to be Mesh type\n   * @returns The MeshTxBuilder instance\n   */\n  txOutDatumHashValue = (\n    datum: BuilderData[\"content\"],\n    type: BuilderData[\"type\"] = \"Mesh\",\n  ) => {\n    let content = datum;\n    if (this.txOutput) {\n      if (type === \"Mesh\") {\n        this.txOutput.datum = {\n          type: \"Hash\",\n          data: {\n            type,\n            content: content as Data,\n          },\n        };\n        return this;\n      }\n      if (type === \"JSON\") {\n        content = this.castRawDataToJsonString(datum as object | string);\n      }\n      this.txOutput.datum = {\n        type: \"Hash\",\n        data: {\n          type,\n          content: content as string,\n        },\n      };\n    }\n    return this;\n  };\n\n  /**\n   * Set the output inline datum for transaction\n   * @param datum The datum in Mesh Data type, JSON in raw constructor like format, or CBOR hex string\n   * @param type The datum type, either Mesh Data type, JSON in raw constructor like format, or CBOR hex string. Default to be Mesh type\n   * @returns The MeshTxBuilder instance\n   */\n  txOutInlineDatumValue = (\n    datum: BuilderData[\"content\"],\n    type: BuilderData[\"type\"] = \"Mesh\",\n  ) => {\n    let content = datum;\n    if (this.txOutput) {\n      if (type === \"Mesh\") {\n        this.txOutput.datum = {\n          type: \"Inline\",\n          data: {\n            type,\n            content: content as Data,\n          },\n        };\n        return this;\n      }\n      if (type === \"JSON\") {\n        content = this.castRawDataToJsonString(datum as object | string);\n      }\n      this.txOutput.datum = {\n        type: \"Inline\",\n        data: {\n          type,\n          content: content as string,\n        },\n      };\n    }\n    return this;\n  };\n\n  /**\n   * Set the output embed datum for transaction\n   * @param datum The datum in Mesh Data type, JSON in raw constructor like format, or CBOR hex string\n   * @param type The datum type, either Mesh Data type, JSON in raw constructor like format, or CBOR hex string. Default to be Mesh type\n   * @returns The MeshTxBuilder instance\n   */\n\n  txOutDatumEmbedValue = (\n    datum: BuilderData[\"content\"],\n    type: BuilderData[\"type\"] = \"Mesh\",\n  ) => {\n    let content = datum;\n    if (this.txOutput) {\n      if (type === \"Mesh\") {\n        this.txOutput.datum = {\n          type: \"Embedded\",\n          data: {\n            type,\n            content: content as Data,\n          },\n        };\n        return this;\n      }\n      if (type === \"JSON\") {\n        content = this.castRawDataToJsonString(datum as object | string);\n      }\n      this.txOutput.datum = {\n        type: \"Embedded\",\n        data: {\n          type,\n          content: content as string,\n        },\n      };\n    }\n    return this;\n  };\n\n  /**\n   * Set the reference script to be attached with the output\n   * @param scriptCbor The CBOR hex of the script to be attached to UTxO as reference script\n   * @param version Optional - The Plutus script version. Default to be V3 (Plutus V3)\n   * @returns The MeshTxBuilder instance\n   */\n  txOutReferenceScript = (\n    scriptCbor: string,\n    version: LanguageVersion = \"V3\",\n  ) => {\n    if (this.txOutput) {\n      this.txOutput.referenceScript = { code: scriptCbor, version };\n    }\n    return this;\n  };\n\n  /**\n   * Set the reference script to be attached with the output\n   * @param languageVersion The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */\n  spendingPlutusScript = (languageVersion: LanguageVersion) => {\n    // This flag should signal a start to a script input\n    // The next step after will be to add a tx-in\n    // After which, we will REQUIRE, script, datum and redeemer info\n    // for unlocking this particular input\n    this.addingPlutusScriptInput = true;\n    this.plutusSpendingScriptVersion = languageVersion;\n    return this;\n  };\n  /**\n   * Set the instruction that it is currently using V1 Plutus spending scripts\n   * @returns The MeshTxBuilder instance\n   */\n  spendingPlutusScriptV1 = () => {\n    // This flag should signal a start to a script input\n    // The next step after will be to add a tx-in\n    // After which, we will REQUIRE, script, datum and redeemer info\n    // for unlocking this particular input\n    this.addingPlutusScriptInput = true;\n    this.plutusSpendingScriptVersion = \"V1\";\n    return this;\n  };\n  /**\n   * Set the instruction that it is currently using V2 Plutus spending scripts\n   * @returns The MeshTxBuilder instance\n   */\n  spendingPlutusScriptV2 = () => {\n    // This flag should signal a start to a script input\n    // The next step after will be to add a tx-in\n    // After which, we will REQUIRE, script, datum and redeemer info\n    // for unlocking this particular input\n    this.addingPlutusScriptInput = true;\n    this.plutusSpendingScriptVersion = \"V2\";\n    return this;\n  };\n  /**\n   * Set the instruction that it is currently using V3 Plutus spending scripts\n   * @returns The MeshTxBuilder instance\n   */\n  spendingPlutusScriptV3 = () => {\n    // This flag should signal a start to a script input\n    // The next step after will be to add a tx-in\n    // After which, we will REQUIRE, script, datum and redeemer info\n    // for unlocking this particular input\n    this.addingPlutusScriptInput = true;\n    this.plutusSpendingScriptVersion = \"V3\";\n    return this;\n  };\n\n  /**\n   * Set the reference input where it would also be spent in the transaction\n   * @param txHash The transaction hash of the reference UTxO\n   * @param txIndex The transaction index of the reference UTxO\n   * @param scriptSize The script size in bytes of the spending script (can be obtained by script hex length / 2)\n   * @param scriptHash The script hash of the spending script\n   * @returns The MeshTxBuilder instance\n   */\n  spendingTxInReference = (\n    txHash: string,\n    txIndex: number,\n    scriptSize?: string,\n    scriptHash?: string,\n  ) => {\n    if (!this.txInQueueItem) throw Error(\"Undefined input\");\n    if (this.txInQueueItem.type === \"PubKey\")\n      throw Error(\n        \"Spending tx in reference attempted to be called a non script input\",\n      );\n    if (this.txInQueueItem.type === \"SimpleScript\")\n      throw Error(\n        \"Spending tx in reference attempted to be called on a simple script input\",\n      );\n    this.txInQueueItem.scriptTxIn.scriptSource = {\n      type: \"Inline\",\n      txHash,\n      txIndex,\n      scriptHash,\n      version: this.plutusSpendingScriptVersion || \"V2\",\n      scriptSize,\n    };\n    return this;\n  };\n\n  /**\n   * [Alias of txInInlineDatumPresent] Set the instruction that the reference input has inline datum\n   * @returns The MeshTxBuilder instance\n   */\n  // Unsure how this is different from the --tx-in-inline-datum-present flag\n  // It seems to just be different based on if the script is a reference input\n  spendingReferenceTxInInlineDatumPresent = () => {\n    this.txInInlineDatumPresent();\n    return this;\n  };\n\n  /**\n   * [Alias of txInRedeemerValue] Set the redeemer for the reference input to be spent in same transaction\n   * @param redeemer The redeemer in Mesh Data type, JSON in raw constructor like format, or CBOR hex string\n   * @param type The redeemer data type, either Mesh Data type, JSON in raw constructor like format, or CBOR hex string. Default to be Mesh type\n   * @param exUnits The execution units budget for the redeemer\n   * @returns The MeshTxBuilder instance\n   */\n  spendingReferenceTxInRedeemerValue = (\n    redeemer: BuilderData[\"content\"],\n    type: BuilderData[\"type\"] = \"Mesh\",\n    exUnits = { ...DEFAULT_REDEEMER_BUDGET },\n  ) => {\n    this.txInRedeemerValue(redeemer, type, exUnits);\n    return this;\n  };\n\n  /**\n   * Specify a read only reference input. This reference input is not witnessing anything it is simply provided in the plutus script context.\n   * @param txHash The transaction hash of the reference UTxO\n   * @param txIndex The transaction index of the reference UTxO\n   * @returns The MeshTxBuilder instance\n   */\n  readOnlyTxInReference = (\n    txHash: string,\n    txIndex: number,\n    scriptSize?: number,\n  ) => {\n    this.meshTxBuilderBody.referenceInputs.push({\n      txHash,\n      txIndex,\n      scriptSize,\n    });\n    return this;\n  };\n\n  /**\n   * Set the minting script for the current mint\n   * @param languageVersion The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */\n  mintPlutusScript = (languageVersion: LanguageVersion) => {\n    this.addingPlutusMint = true;\n    this.plutusMintingScriptVersion = languageVersion;\n    return this;\n  };\n  /**\n   * Set the instruction that it is currently using V1 Plutus minting scripts\n   * @returns The MeshTxBuilder instance\n   */\n  mintPlutusScriptV1 = () => {\n    this.addingPlutusMint = true;\n    this.plutusMintingScriptVersion = \"V1\";\n    return this;\n  };\n  /**\n   * Set the instruction that it is currently using V2 Plutus minting scripts\n   * @returns The MeshTxBuilder instance\n   */\n  mintPlutusScriptV2 = () => {\n    this.addingPlutusMint = true;\n    this.plutusMintingScriptVersion = \"V2\";\n    return this;\n  };\n  /**\n   * Set the instruction that it is currently using V3 Plutus minting scripts\n   * @returns The MeshTxBuilder instance\n   */\n  mintPlutusScriptV3 = () => {\n    this.addingPlutusMint = true;\n    this.plutusMintingScriptVersion = \"V3\";\n    return this;\n  };\n\n  /**\n   * Set the minting value of transaction\n   * @param quantity The quantity of asset to be minted\n   * @param policy The policy id of the asset to be minted\n   * @param name The hex of token name of the asset to be minted\n   * @returns The MeshTxBuilder instance\n   */\n  mint = (quantity: string, policy: string, name: string) => {\n    if (this.mintItem) {\n      this.queueMint();\n    }\n    this.mintItem = {\n      type: this.addingPlutusMint ? \"Plutus\" : \"Native\",\n      policyId: policy,\n      assetName: name,\n      amount: quantity,\n    };\n    this.addingPlutusMint = false;\n    return this;\n  };\n\n  /**\n   * Set the minting script of current mint\n   * @param scriptCBOR The CBOR hex of the minting policy script\n   * @param version Optional - The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */\n  mintingScript = (scriptCBOR: string) => {\n    if (!this.mintItem) throw Error(\"Undefined mint\");\n    if (!this.mintItem.type) throw Error(\"Mint information missing\");\n    if (this.mintItem.type === \"Native\") {\n      this.mintItem.scriptSource = {\n        type: \"Provided\",\n        scriptCode: scriptCBOR,\n      };\n    }\n    if (this.mintItem.type === \"Plutus\") {\n      this.mintItem.scriptSource = {\n        type: \"Provided\",\n        script: {\n          code: scriptCBOR,\n          version: this.plutusMintingScriptVersion || \"V2\",\n        },\n      };\n    }\n\n    return this;\n  };\n\n  /**\n   * Use reference script for minting\n   * @param txHash The transaction hash of the UTxO\n   * @param txIndex The transaction index of the UTxO\n   * @param scriptSize The script size in bytes of the script (can be obtained by script hex length / 2)\n   * @param scriptHash The script hash of the script\n   * @returns The MeshTxBuilder instance\n   */\n  mintTxInReference = (\n    txHash: string,\n    txIndex: number,\n    scriptSize?: string,\n    scriptHash?: string,\n  ) => {\n    if (!this.mintItem) throw Error(\"Undefined mint\");\n    if (!this.mintItem.type) throw Error(\"Mint information missing\");\n    if (this.mintItem.type == \"Native\") {\n      throw Error(\n        \"Mint tx in reference can only be used on plutus script tokens\",\n      );\n    }\n    if (!this.mintItem.policyId)\n      throw Error(\"PolicyId information missing from mint asset\");\n    this.mintItem.scriptSource = {\n      type: \"Inline\",\n      txHash,\n      txIndex,\n      version: this.plutusMintingScriptVersion,\n      scriptSize,\n      scriptHash,\n    };\n    return this;\n  };\n\n  /**\n   * Set the redeemer for minting\n   * @param redeemer The redeemer in Mesh Data type, JSON in raw constructor like format, or CBOR hex string\n   * @param type The redeemer data type, either Mesh Data type, JSON in raw constructor like format, or CBOR hex string. Default to be Mesh type\n   * @param exUnits The execution units budget for the redeemer\n   * @returns The MeshTxBuilder instance\n   */\n  mintReferenceTxInRedeemerValue = (\n    redeemer: BuilderData[\"content\"],\n    type: BuilderData[\"type\"] = \"Mesh\",\n    exUnits = { ...DEFAULT_REDEEMER_BUDGET },\n  ) => {\n    if (!this.mintItem) throw Error(\"Undefined mint\");\n    if (this.mintItem.type == \"Native\") {\n      throw Error(\n        \"Mint tx in reference can only be used on plutus script tokens\",\n      );\n    } else if (this.mintItem.type == \"Plutus\") {\n      if (!this.mintItem.policyId)\n        throw Error(\"PolicyId information missing from mint asset\");\n    }\n    this.mintItem.redeemer = this.castBuilderDataToRedeemer(\n      redeemer,\n      type,\n      exUnits,\n    );\n    return this;\n  };\n\n  /**\n   * Set the redeemer for the reference input to be spent in same transaction\n   * @param redeemer The redeemer in Mesh Data type, JSON in raw constructor like format, or CBOR hex string\n   * @param type The redeemer data type, either Mesh Data type, JSON in raw constructor like format, or CBOR hex string. Default to be Mesh type\n   * @param exUnits The execution units budget for the redeemer\n   * @returns The MeshTxBuilder instance\n   */\n  mintRedeemerValue = (\n    redeemer: BuilderData[\"content\"],\n    type: BuilderData[\"type\"] = \"Mesh\",\n    exUnits = { ...DEFAULT_REDEEMER_BUDGET },\n  ) => {\n    this.mintReferenceTxInRedeemerValue(redeemer, type, exUnits);\n    return this;\n  };\n\n  /**\n   * Set the required signer of the transaction\n   * @param pubKeyHash The PubKeyHash of the required signer\n   * @returns The MeshTxBuilder instance\n   */\n  requiredSignerHash = (pubKeyHash: string) => {\n    this.meshTxBuilderBody.requiredSignatures.push(pubKeyHash);\n    return this;\n  };\n\n  /**\n   * Set the collateral UTxO for the transaction\n   * @param txHash The transaction hash of the collateral UTxO\n   * @param txIndex The transaction index of the collateral UTxO\n   * @param amount The asset amount of index of the collateral UTxO\n   * @param address The address of the collateral UTxO\n   * @returns The MeshTxBuilder instance\n   */\n  txInCollateral = (\n    txHash: string,\n    txIndex: number,\n    amount?: Asset[],\n    address?: string,\n  ) => {\n    if (this.collateralQueueItem) {\n      this.meshTxBuilderBody.collaterals.push(this.collateralQueueItem);\n    }\n    this.collateralQueueItem = {\n      type: \"PubKey\",\n      txIn: {\n        txHash: txHash,\n        txIndex: txIndex,\n        amount,\n        address,\n      },\n    };\n    return this;\n  };\n\n  /**\n   * Set the instruction that it is currently using V1 Plutus withdrawal scripts\n   * @param languageVersion The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */\n  withdrawalPlutusScript = (languageVersion: LanguageVersion) => {\n    this.addingPlutusWithdrawal = true;\n    this.plutusWithdrawalScriptVersion = languageVersion;\n    return this;\n  };\n  /**\n   * Set the instruction that it is currently using a Plutus withdrawal scripts\n   * @returns The MeshTxBuilder instance\n   */\n  withdrawalPlutusScriptV1 = () => {\n    this.addingPlutusWithdrawal = true;\n    this.plutusWithdrawalScriptVersion = \"V1\";\n    return this;\n  };\n\n  /**\n   * Set the instruction that it is currently using V2 Plutus withdrawal scripts\n   * @returns The MeshTxBuilder instance\n   */\n  withdrawalPlutusScriptV2 = () => {\n    this.addingPlutusWithdrawal = true;\n    this.plutusWithdrawalScriptVersion = \"V2\";\n    return this;\n  };\n\n  /**\n   * Set the instruction that it is currently using V3 Plutus withdrawal scripts\n   * @returns The MeshTxBuilder instance\n   */\n  withdrawalPlutusScriptV3 = () => {\n    this.addingPlutusWithdrawal = true;\n    this.plutusWithdrawalScriptVersion = \"V3\";\n    return this;\n  };\n\n  /**\n   * Withdraw stake rewards in the MeshTxBuilder instance\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @param coin The amount of lovelaces in the withdrawal\n   * @returns The MeshTxBuilder instance\n   */\n  withdrawal = (rewardAddress: string, coin: string) => {\n    if (this.withdrawalItem) {\n      this.queueWithdrawal();\n    }\n    if (this.addingPlutusWithdrawal) {\n      const withdrawal: Withdrawal = {\n        type: \"ScriptWithdrawal\",\n        address: rewardAddress,\n        coin: coin,\n      };\n      this.withdrawalItem = withdrawal;\n      this.addingPlutusWithdrawal = false;\n      return this;\n    }\n\n    const withdrawal: Withdrawal = {\n      type: \"PubKeyWithdrawal\",\n      address: rewardAddress,\n      coin: coin,\n    };\n    this.withdrawalItem = withdrawal;\n    return this;\n  };\n\n  /**\n   * Add a withdrawal script to the MeshTxBuilder instance\n   * @param scriptCbor The script in CBOR format\n   * @returns The MeshTxBuilder instance\n   */\n  withdrawalScript = (scriptCbor: string) => {\n    if (!this.withdrawalItem)\n      throw Error(\"withdrawalScript: Undefined withdrawal\");\n    if (this.withdrawalItem.type === \"PubKeyWithdrawal\") {\n      this.withdrawalItem = {\n        type: \"SimpleScriptWithdrawal\",\n        address: this.withdrawalItem.address,\n        coin: this.withdrawalItem.coin,\n        scriptSource: {\n          type: \"Provided\",\n          scriptCode: scriptCbor,\n        },\n      };\n    } else {\n      this.withdrawalItem.scriptSource = {\n        type: \"Provided\",\n        script: {\n          code: scriptCbor,\n          version: this.plutusWithdrawalScriptVersion || \"V2\",\n        },\n      };\n    }\n    return this;\n  };\n\n  /**\n   * Add a withdrawal reference to the MeshTxBuilder instance\n   * @param txHash The transaction hash of reference UTxO\n   * @param txIndex The transaction index of reference UTxO\n   * @param scriptSize The script size in bytes of the withdrawal script (can be obtained by script hex length / 2)\n   * @param scriptHash The script hash of the withdrawal script\n   * @returns The MeshTxBuilder instance\n   */\n  withdrawalTxInReference = (\n    txHash: string,\n    txIndex: number,\n    scriptSize?: string,\n    scriptHash?: string,\n  ) => {\n    if (!this.withdrawalItem)\n      throw Error(\"withdrawalTxInReference: Undefined withdrawal\");\n    if (this.withdrawalItem.type === \"PubKeyWithdrawal\")\n      throw Error(\n        \"withdrawalTxInReference: Adding script reference to pub key withdrawal\",\n      );\n    this.withdrawalItem.scriptSource = {\n      type: \"Inline\",\n      txHash,\n      txIndex,\n      scriptHash,\n      version: this.plutusWithdrawalScriptVersion || \"V2\",\n      scriptSize,\n    };\n    return this;\n  };\n\n  /**\n   * Set the transaction withdrawal redeemer value in the MeshTxBuilder instance\n   * @param redeemer The redeemer in Mesh Data type, JSON in raw constructor like format, or CBOR hex string\n   * @param type The redeemer data type, either Mesh Data type, JSON in raw constructor like format, or CBOR hex string. Default to be Mesh type\n   * @param exUnits The execution units budget for the redeemer\n   * @returns The MeshTxBuilder instance\n   */\n  withdrawalRedeemerValue = (\n    redeemer: BuilderData[\"content\"],\n    type: BuilderData[\"type\"] = \"Mesh\",\n    exUnits = { ...DEFAULT_REDEEMER_BUDGET },\n  ) => {\n    if (!this.withdrawalItem)\n      throw Error(\"withdrawalRedeemerValue: Undefined withdrawal\");\n    if (!(this.withdrawalItem.type === \"ScriptWithdrawal\"))\n      throw Error(\n        \"withdrawalRedeemerValue: Adding redeemer to non plutus withdrawal\",\n      );\n    this.withdrawalItem.redeemer = this.castBuilderDataToRedeemer(\n      redeemer,\n      type,\n      exUnits,\n    );\n\n    return this;\n  };\n\n  /**\n   * Set the instruction that it is currently using a Plutus voting scripts\n   * @param languageVersion The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */\n  votePlutusScript = (languageVersion: LanguageVersion) => {\n    this.addingPlutusVote = true;\n    this.plutusVoteScriptVersion = languageVersion;\n    return this;\n  };\n  /**\n   * Set the instruction that it is currently using V1 Plutus voting scripts\n   * @returns The MeshTxBuilder instance\n   */\n  votePlutusScriptV1 = () => {\n    this.addingPlutusVote = true;\n    this.plutusVoteScriptVersion = \"V1\";\n    return this;\n  };\n\n  /**\n   * Set the instruction that it is currently using V2 Plutus voting scripts\n   * @returns The MeshTxBuilder instance\n   */\n  votePlutusScriptV2 = () => {\n    this.addingPlutusVote = true;\n    this.plutusVoteScriptVersion = \"V2\";\n    return this;\n  };\n\n  /**\n   * Set the instruction that it is currently using V3 Plutus voting scripts\n   * @returns The MeshTxBuilder instance\n   */\n  votePlutusScriptV3 = () => {\n    this.addingPlutusVote = true;\n    this.plutusVoteScriptVersion = \"V3\";\n    return this;\n  };\n\n  /**\n   * Add a vote in the MeshTxBuilder instance\n   * @param voter The voter, can be a ConstitutionalCommitee, a DRep or a StakePool\n   * @param govActionId - The transaction hash and transaction id of the governance action\n   * @param votingProcedure - The voting kind (Yes, No, Abstain) with an optional anchor\n   * @returns The MeshTxBuilder instance\n   */\n  vote = (\n    voter: Voter,\n    govActionId: RefTxIn,\n    votingProcedure: VotingProcedure,\n  ) => {\n    if (this.voteItem) {\n      this.queueVote();\n    }\n\n    if (this.addingPlutusVote) {\n      const vote: Vote = {\n        type: \"ScriptVote\",\n        vote: {\n          voter,\n          govActionId,\n          votingProcedure,\n        },\n      };\n      this.voteItem = vote;\n      this.addingPlutusVote = false;\n    } else {\n      const vote: Vote = {\n        type: \"BasicVote\",\n        vote: {\n          voter,\n          govActionId,\n          votingProcedure,\n        },\n      };\n      this.voteItem = vote;\n    }\n    return this;\n  };\n\n  /**\n   * Add a voting script to the MeshTxBuilder instance\n   * @param scriptCbor The script in CBOR format\n   * @returns The MeshTxBuilder instance\n   */\n  voteScript = (scriptCbor: string) => {\n    if (!this.voteItem) throw Error(\"voteScript: Undefined vote\");\n    if (this.voteItem.type === \"BasicVote\") {\n      this.voteItem = {\n        type: \"SimpleScriptVote\",\n        vote: this.voteItem.vote,\n        simpleScriptSource: {\n          type: \"Provided\",\n          scriptCode: scriptCbor,\n        },\n      };\n    } else if (this.voteItem.type === \"ScriptVote\") {\n      this.voteItem.scriptSource = {\n        type: \"Provided\",\n        script: {\n          code: scriptCbor,\n          version: this.plutusVoteScriptVersion || \"V2\",\n        },\n      };\n    } else if (this.voteItem.type === \"SimpleScriptVote\") {\n      throw Error(\"voteScript: Script is already defined for current vote\");\n    }\n    return this;\n  };\n\n  /**\n   * Add a vote reference to the MeshTxBuilder instance\n   * @param txHash The transaction hash of reference UTxO\n   * @param txIndex The transaction index of reference UTxO\n   * @param scriptSize The script size in bytes of the vote script (can be obtained by script hex length / 2)\n   * @param scriptHash The script hash of the vote script\n   * @returns The MeshTxBuilder instance\n   */\n  voteTxInReference = (\n    txHash: string,\n    txIndex: number,\n    scriptSize?: string,\n    scriptHash?: string,\n  ) => {\n    if (!this.voteItem) throw Error(\"voteTxInReference: Undefined vote\");\n    if (this.voteItem.type === \"BasicVote\")\n      throw Error(\"voteTxInReference: Adding script reference to a basic vote\");\n    if (this.voteItem.type === \"ScriptVote\") {\n      this.voteItem.scriptSource = {\n        type: \"Inline\",\n        txHash,\n        txIndex,\n        scriptHash,\n        version: this.plutusWithdrawalScriptVersion || \"V2\",\n        scriptSize,\n      };\n    } else if (this.voteItem.type === \"SimpleScriptVote\") {\n      this.voteItem.simpleScriptSource = {\n        type: \"Inline\",\n        txHash,\n        txIndex,\n        scriptSize,\n        simpleScriptHash: scriptHash,\n      };\n    }\n\n    return this;\n  };\n\n  /**\n   * Set the transaction vote redeemer value in the MeshTxBuilder instance\n   * @param redeemer The redeemer in Mesh Data type, JSON in raw constructor like format, or CBOR hex string\n   * @param type The redeemer data type, either Mesh Data type, JSON in raw constructor like format, or CBOR hex string\n   * @param exUnits The execution units budget for the redeemer\n   * @returns The MeshTxBuilder instance\n   */\n  voteRedeemerValue = (\n    redeemer: BuilderData[\"content\"],\n    type: BuilderData[\"type\"] = \"Mesh\",\n    exUnits = { ...DEFAULT_REDEEMER_BUDGET },\n  ) => {\n    if (!this.voteItem) throw Error(\"voteRedeemerValue: Undefined vote\");\n    if (!(this.voteItem.type === \"ScriptVote\"))\n      throw Error(\"voteRedeemerValue: Adding redeemer to non plutus vote\");\n    this.voteItem.redeemer = this.castBuilderDataToRedeemer(\n      redeemer,\n      type,\n      exUnits,\n    );\n\n    return this;\n  };\n\n  /**\n   * Creates a pool registration certificate, and adds it to the transaction\n   * @param poolParams Parameters for pool registration\n   * @returns The MeshTxBuilder instance\n   */\n  registerPoolCertificate = (poolParams: PoolParams) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"RegisterPool\",\n        poolParams,\n      },\n    });\n    return this;\n  };\n\n  /**\n   * Creates a stake registration certificate, and adds it to the transaction\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @returns The MeshTxBuilder instance\n   */\n  registerStakeCertificate = (rewardAddress: string) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"RegisterStake\",\n        stakeKeyAddress: rewardAddress,\n      },\n    });\n    return this;\n  };\n\n  /**\n   * Creates a stake delegation certificate, and adds it to the transaction\n   * This will delegate stake from the corresponding stake address to the pool\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @param poolId poolId can be in either bech32 or hex form\n   * @returns The MeshTxBuilder instance\n   */\n  delegateStakeCertificate = (rewardAddress: string, poolId: string) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"DelegateStake\",\n        stakeKeyAddress: rewardAddress,\n        poolId,\n      },\n    });\n    return this;\n  };\n\n  /**\n   * Creates a stake deregister certificate, and adds it to the transaction\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @returns The MeshTxBuilder instance\n   */\n  deregisterStakeCertificate = (rewardAddress: string) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"DeregisterStake\",\n        stakeKeyAddress: rewardAddress,\n      },\n    });\n    return this;\n  };\n\n  /**\n   * Creates a pool retire certificate, and adds it to the transaction\n   * @param poolId poolId can be in either bech32 or hex form\n   * @param epoch The intended epoch to retire the pool\n   * @returns The MeshTxBuilder instance\n   */\n  retirePoolCertificate = (poolId: string, epoch: number) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"RetirePool\",\n        poolId,\n        epoch,\n      },\n    });\n    return this;\n  };\n\n  /**\n   * Registers DRep certificate, and adds it to the transaction\n   * @param drepId The bech32 drep id (i.e. starts with `drep1xxxxx`)\n   * @param anchor The DRep anchor, consists of a URL and a hash of the doc\n   * @param coin DRep registration deposit\n   * @returns The MeshTxBuilder instance\n   */\n  drepRegistrationCertificate = (\n    drepId: string,\n    anchor?: Anchor,\n    coin: string = DREP_DEPOSIT,\n  ) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"DRepRegistration\",\n        drepId,\n        coin: Number(coin),\n        anchor,\n      },\n    });\n    return this;\n  };\n\n  /**\n   * Dregister DRep certificate, and adds it to the transaction\n   * @param drepId The bech32 drep id (i.e. starts with `drep1xxxxx`)\n   * @param coin DRep registration deposit\n   * @returns The MeshTxBuilder instance\n   */\n  drepDeregistrationCertificate = (\n    drepId: string,\n    coin: string = DREP_DEPOSIT,\n  ) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"DRepDeregistration\",\n        drepId,\n        coin: Number(coin),\n      },\n    });\n    return this;\n  };\n\n  /**\n   * Update DRep certificate, and adds it to the transaction\n   * @param drepId The bech32 drep id (i.e. starts with `drep1xxxxx`)\n   * @param anchor The DRep anchor, consists of a URL and a hash of the doc\n   */\n  drepUpdateCertificate = (drepId: string, anchor?: Anchor) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"DRepUpdate\",\n        drepId,\n        anchor,\n      },\n    });\n    return this;\n  };\n\n  /**\n   * Dregister DRep certificate, and adds it to the transaction\n   * @param drepId The bech32 drep id (i.e. starts with `drep1xxxxx`)\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @returns The MeshTxBuilder instance\n   */\n  voteDelegationCertificate = (drep: DRep, rewardAddress: string) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"VoteDelegation\",\n        drep,\n        stakeKeyAddress: rewardAddress,\n      },\n    });\n    return this;\n  };\n\n  /**\n   * Adds a script witness to the certificate\n   * @param scriptCbor The CborHex of the script\n   * @param version Optional - The plutus version of the script, null version implies Native Script\n   */\n  certificateScript = (scriptCbor: string, version?: LanguageVersion) => {\n    const currentCert = this.meshTxBuilderBody.certificates.pop();\n    if (!currentCert) {\n      throw Error(\n        \"Certificate script attempted to be defined, but no certificate was found\",\n      );\n    }\n    if (!version) {\n      this.meshTxBuilderBody.certificates.push({\n        type: \"SimpleScriptCertificate\",\n        certType: currentCert.certType,\n        simpleScriptSource: {\n          type: \"Provided\",\n          scriptCode: scriptCbor,\n        },\n      });\n    } else {\n      this.meshTxBuilderBody.certificates.push({\n        type: \"ScriptCertificate\",\n        certType: currentCert.certType,\n        scriptSource: {\n          type: \"Provided\",\n          script: {\n            code: scriptCbor,\n            version,\n          },\n        },\n        redeemer:\n          currentCert.type === \"ScriptCertificate\"\n            ? currentCert.redeemer\n            : undefined,\n      });\n    }\n    return this;\n  };\n\n  /**\n   * Adds a script witness to the certificate\n   * @param txHash The transaction hash of the reference UTxO\n   * @param txIndex The transaction index of the reference UTxO\n   * @param scriptSize The size of the plutus script in bytes referenced (can be obtained by script hex length / 2)\n   * @param scriptHash The script hash of the spending script\n   * @param version The plutus version of the script, null version implies Native Script\n   */\n  certificateTxInReference = (\n    txHash: string,\n    txIndex: number,\n    scriptSize?: string,\n    scriptHash?: string,\n    version?: LanguageVersion,\n  ) => {\n    const currentCert = this.meshTxBuilderBody.certificates.pop();\n    if (!currentCert) {\n      throw Error(\n        \"Certificate script reference attempted to be defined, but no certificate was found\",\n      );\n    }\n    if (!version) {\n      this.meshTxBuilderBody.certificates.push({\n        type: \"SimpleScriptCertificate\",\n        certType: currentCert.certType,\n        simpleScriptSource: {\n          type: \"Inline\",\n          txHash,\n          txIndex,\n          simpleScriptHash: scriptHash,\n        },\n      });\n    } else {\n      this.meshTxBuilderBody.certificates.push({\n        type: \"ScriptCertificate\",\n        certType: currentCert.certType,\n        scriptSource: {\n          type: \"Inline\",\n          txHash,\n          txIndex,\n          scriptHash,\n          scriptSize,\n          version,\n        },\n        redeemer:\n          currentCert.type === \"ScriptCertificate\"\n            ? currentCert.redeemer\n            : undefined,\n      });\n    }\n    return this;\n  };\n\n  certificateRedeemerValue = (\n    redeemer: BuilderData[\"content\"],\n    type: BuilderData[\"type\"] = \"Mesh\",\n    exUnits = { ...DEFAULT_REDEEMER_BUDGET },\n  ) => {\n    const currentCert = this.meshTxBuilderBody.certificates.pop();\n    if (!currentCert) {\n      throw Error(\n        \"Certificate redeemer value attempted to be defined, but no certificate was found\",\n      );\n    }\n    if (currentCert.type === \"ScriptCertificate\") {\n      currentCert.redeemer = this.castBuilderDataToRedeemer(\n        redeemer,\n        type,\n        exUnits,\n      );\n    } else {\n      throw Error(\n        \"Redeemer value attempted to be defined, but certificate has no script defined, or no script version was defined\",\n      );\n    }\n    this.meshTxBuilderBody.certificates.push(currentCert);\n    return this;\n  };\n\n  /**\n   * Configure the address to accept change UTxO\n   * @param addr The address to accept change UTxO\n   * @returns The MeshTxBuilder instance\n   */\n  changeAddress = (addr: string) => {\n    this.meshTxBuilderBody.changeAddress = addr;\n    return this;\n  };\n\n  /**\n   * Set the transaction valid interval to be valid only after the slot\n   * @param slot The transaction is valid only after this slot\n   * @returns The MeshTxBuilder instance\n   */\n  invalidBefore = (slot: number) => {\n    this.meshTxBuilderBody.validityRange.invalidBefore = slot;\n    return this;\n  };\n\n  /**\n   * Set the transaction valid interval to be valid only before the slot\n   * @param slot The transaction is valid only before this slot\n   * @returns The MeshTxBuilder instance\n   */\n  invalidHereafter = (slot: number) => {\n    this.meshTxBuilderBody.validityRange.invalidHereafter = slot;\n    return this;\n  };\n\n  /**\n   * Add metadata to the transaction\n   * @param label The label of the metadata, preferably number\n   * @param metadata The metadata in any format\n   * @returns The MeshTxBuilder instance\n   */\n  metadataValue = (\n    label: number | bigint | string,\n    metadata: Metadatum | object,\n  ) => {\n    label = BigInt(label);\n    if (typeof metadata === \"object\" && !(metadata instanceof Map)) {\n      this.meshTxBuilderBody.metadata.set(label, metadataObjToMap(metadata));\n    } else {\n      this.meshTxBuilderBody.metadata.set(label, metadata);\n    }\n    return this;\n  };\n\n  /**\n   * Sign the transaction with the private key\n   * @param skeyHex The private key in cborHex (with or without 5820 prefix, i.e. the format when generated from cardano-cli)\n   * @returns\n   */\n  signingKey = (skeyHex: string) => {\n    this.meshTxBuilderBody.signingKey.push(skeyHex);\n    return this;\n  };\n\n  /**\n   * Selects utxos to fill output value and puts them into inputs\n   * @param extraInputs The inputs already placed into the object will remain, these extra inputs will be used to fill the remaining  value needed\n   */\n  selectUtxosFrom = (extraInputs: UTxO[]) => {\n    for (const input of extraInputs) {\n      const address = input.output.address;\n      if (!address) {\n        throw Error(\"Address is missing from the extra input\");\n      }\n      const decodedAddress = Address.fromString(<HexBlob>address);\n      if (\n        decodedAddress?.getProps().paymentPart?.type !== CredentialType.KeyHash\n      ) {\n        throw Error(\"Only KeyHash address is supported for utxo selection\");\n      }\n    }\n    this.meshTxBuilderBody.extraInputs = extraInputs;\n    this.meshTxBuilderBody.selectionConfig = {\n      ...this.meshTxBuilderBody.selectionConfig,\n    };\n    return this;\n  };\n\n  /**\n   * Set the protocol parameters to be used for the transaction other than the default one\n   * @param params (Part of) the protocol parameters to be used for the transaction\n   * @returns The MeshTxBuilder instance\n   */\n  protocolParams = (params: Partial<Protocol>) => {\n    const updatedParams = { ...DEFAULT_PROTOCOL_PARAMETERS, ...params };\n    this._protocolParams = updatedParams;\n    return this;\n  };\n\n  /**\n   * Sets a specific fee for the transaction to use\n   * @param fee The specified fee\n   * @returns The MeshTxBuilder instance\n   */\n  setFee = (fee: string) => {\n    this.manualFee = fee;\n    this.meshTxBuilderBody.fee = fee;\n    return this;\n  };\n\n  /**\n   * Sets a total collateral for the transaction to use, a collateral return\n   * will be generated to either the change address or the specified collateral return address\n   * @param collateral The specified collateral\n   * @returns The MeshTxBuilder instance\n   */\n  setTotalCollateral = (collateral: string) => {\n    this.meshTxBuilderBody.totalCollateral = collateral;\n    return this;\n  };\n\n  /**\n   * Sets the collateral return address, if none is set, the change address will be used\n   * @param address The address to use for collateral return\n   * @returns The MeshTxBuilder instance\n   */\n  setCollateralReturnAddress = (address: string) => {\n    this.meshTxBuilderBody.collateralReturnAddress = address;\n    return this;\n  };\n\n  /**\n   * Sets the network to use, this is mainly to know the cost models to be used to calculate script integrity hash\n   * @param network The specific network this transaction is being built for (\"testnet\" | \"preview\" | \"preprod\" | \"mainnet\")\n   * @returns The MeshTxBuilder instance\n   */\n  setNetwork = (network: Network | number[][]) => {\n    this.meshTxBuilderBody.network = network;\n    return this;\n  };\n\n  /**\n   * Add a transaction that is used as input, but not yet reflected on the global blockchain\n   * @param txHex The transaction hex of chained transaction\n   * @returns The MeshTxBuilderCore instance\n   */\n  chainTx(txHex: string): this {\n    this.meshTxBuilderBody.chainedTxs.push(txHex);\n    return this;\n  }\n\n  /**\n   * Add a transaction input to provide information for offline evaluation\n   * @param input The input to be added\n   * @returns The MeshTxBuilderCore instance\n   */\n  inputForEvaluation(input: UTxO) {\n    const utxoId = `${input.input.txHash}${input.input.outputIndex}`;\n    const currentUtxo = this.meshTxBuilderBody.inputsForEvaluation[utxoId];\n\n    if (currentUtxo) {\n      const {\n        dataHash: currentDataHash,\n        plutusData: currentPlutusData,\n        scriptRef: currentScriptRef,\n        scriptHash: currentScriptHash,\n      } = currentUtxo.output;\n\n      const updatedUtxo: UTxO = { ...currentUtxo };\n      if (currentDataHash) updatedUtxo.output.dataHash = currentDataHash;\n      if (currentPlutusData) updatedUtxo.output.plutusData = currentPlutusData;\n      if (currentScriptRef) updatedUtxo.output.scriptRef = currentScriptRef;\n      if (currentScriptHash) updatedUtxo.output.scriptHash = currentScriptHash;\n\n      this.meshTxBuilderBody.inputsForEvaluation[utxoId] = updatedUtxo;\n    } else {\n      this.meshTxBuilderBody.inputsForEvaluation[utxoId] = input;\n    }\n    return this;\n  }\n\n  protected queueAllLastItem = () => {\n    if (this.txOutput) {\n      this.meshTxBuilderBody.outputs.push(this.txOutput);\n      this.txOutput = undefined;\n    }\n    if (this.txInQueueItem) {\n      this.queueInput();\n    }\n    if (this.collateralQueueItem) {\n      this.meshTxBuilderBody.collaterals.push(this.collateralQueueItem);\n      this.collateralQueueItem = undefined;\n    }\n    if (this.mintItem) {\n      this.queueMint();\n    }\n    if (this.withdrawalItem) {\n      this.queueWithdrawal();\n    }\n    if (this.voteItem) {\n      this.queueVote();\n    }\n  };\n\n  private queueInput = () => {\n    if (!this.txInQueueItem) throw Error(\"queueInput: Undefined input\");\n    if (this.txInQueueItem.type === \"Script\") {\n      if (!this.txInQueueItem.scriptTxIn) {\n        throw Error(\n          \"queueInput: Script input does not contain script, datum, or redeemer information\",\n        );\n      } else {\n        if (!this.txInQueueItem.scriptTxIn.datumSource)\n          throw Error(\n            \"queueInput: Script input does not contain datum information\",\n          );\n        if (!this.txInQueueItem.scriptTxIn.redeemer)\n          throw Error(\n            \"queueInput: Script input does not contain redeemer information\",\n          );\n        if (!this.txInQueueItem.scriptTxIn.scriptSource)\n          throw Error(\n            \"queueInput: Script input does not contain script information\",\n          );\n      }\n    }\n    this.meshTxBuilderBody.inputs.push(this.txInQueueItem);\n    this.txInQueueItem = undefined;\n  };\n\n  private queueMint = () => {\n    if (!this.mintItem) throw Error(\"queueMint: Undefined mint\");\n    if (!this.mintItem.scriptSource)\n      throw Error(\"queueMint: Missing mint script information\");\n    const currentMint: MintItem = this.mintItem;\n    const samePolicyIdMints: MintParam | undefined =\n      this.meshTxBuilderBody.mints.find((mint) => {\n        return mint.policyId === currentMint.policyId;\n      });\n    if (samePolicyIdMints !== undefined) {\n      if (\n        JSONBig.stringify(currentMint.redeemer) !==\n        JSONBig.stringify(samePolicyIdMints.redeemer)\n      ) {\n        throw Error(\n          \"queueMint: Redeemer for the same policy id must be the same\",\n        );\n      }\n      if (\n        JSONBig.stringify(currentMint.scriptSource) !==\n        JSONBig.stringify(samePolicyIdMints.scriptSource)\n      ) {\n        throw Error(\n          \"queueMint: Script source for the same policy id must be the same\",\n        );\n      }\n      samePolicyIdMints.mintValue.push({\n        assetName: currentMint.assetName,\n        amount: currentMint.amount,\n      });\n    } else {\n      this.meshTxBuilderBody.mints.push({\n        type: currentMint.type,\n        policyId: currentMint.policyId,\n        scriptSource: currentMint.scriptSource,\n        redeemer: currentMint.redeemer,\n        mintValue: [\n          {\n            assetName: currentMint.assetName,\n            amount: currentMint.amount,\n          },\n        ],\n      });\n    }\n    this.mintItem = undefined;\n  };\n\n  private queueWithdrawal = () => {\n    if (!this.withdrawalItem)\n      throw Error(\"queueWithdrawal: Undefined withdrawal\");\n    if (this.withdrawalItem.type === \"ScriptWithdrawal\") {\n      if (!this.withdrawalItem.scriptSource) {\n        throw Error(\"queueWithdrawal: Missing withdrawal script information\");\n      }\n      if (!this.withdrawalItem.redeemer) {\n        throw Error(\"queueWithdrawal: Missing withdrawal redeemer information\");\n      }\n    } else if (this.withdrawalItem.type === \"SimpleScriptWithdrawal\") {\n      if (!this.withdrawalItem.scriptSource) {\n        throw Error(\"queueWithdrawal: Missing withdrawal script information\");\n      }\n    }\n    this.meshTxBuilderBody.withdrawals.push(this.withdrawalItem);\n    this.withdrawalItem = undefined;\n  };\n\n  private queueVote = () => {\n    if (!this.voteItem) {\n      throw Error(\"queueVote: Undefined vote\");\n    }\n    if (this.voteItem.type === \"ScriptVote\") {\n      if (!this.voteItem.scriptSource) {\n        throw Error(\"queueVote: Missing vote script information\");\n      }\n      if (!this.voteItem.redeemer) {\n        throw Error(\"queueVote: Missing vote redeemer information\");\n      }\n    } else if (this.voteItem.type === \"SimpleScriptVote\") {\n      if (!this.voteItem.simpleScriptSource) {\n        throw Error(\"queueVote: Missing vote script information\");\n      }\n    }\n    this.meshTxBuilderBody.votes.push(this.voteItem);\n    this.voteItem = undefined;\n  };\n\n  protected castRawDataToJsonString = (rawData: object | string) => {\n    if (typeof rawData === \"object\") {\n      return JSONBig.stringify(rawData);\n    } else {\n      return rawData as string;\n    }\n  };\n\n  protected castBuilderDataToRedeemer = (\n    redeemer: BuilderData[\"content\"],\n    type: BuilderData[\"type\"] = \"Mesh\",\n    exUnits = { ...DEFAULT_REDEEMER_BUDGET },\n  ): Redeemer => {\n    let red: Redeemer;\n    let content = redeemer;\n    if (type === \"Mesh\") {\n      red = {\n        data: {\n          type,\n          content: content as Data,\n        },\n        exUnits,\n      };\n      return red;\n    }\n    if (type === \"JSON\") {\n      content = this.castRawDataToJsonString(redeemer as object | string);\n    }\n    red = {\n      data: {\n        type,\n        content: content as string,\n      },\n      exUnits,\n    };\n    return red;\n  };\n\n  protected updateRedeemer = (\n    meshTxBuilderBody: MeshTxBuilderBody,\n    txEvaluation: Omit<Action, \"data\">[],\n    doNotUseMultiplier: boolean = false,\n  ) => {\n    const txEvaluationMultiplier = doNotUseMultiplier\n      ? 1\n      : this.txEvaluationMultiplier;\n    txEvaluation.forEach((redeemerEvaluation) => {\n      switch (redeemerEvaluation.tag) {\n        case \"SPEND\": {\n          const input = meshTxBuilderBody.inputs[redeemerEvaluation.index];\n          if (!input) {\n            throw Error(\n              `updateRedeemer: Input not found for index ${redeemerEvaluation.index}`,\n            );\n          }\n          if (input.type == \"Script\" && input.scriptTxIn.redeemer) {\n            input.scriptTxIn.redeemer.exUnits.mem = Math.floor(\n              redeemerEvaluation.budget.mem * txEvaluationMultiplier,\n            );\n            input.scriptTxIn.redeemer.exUnits.steps = Math.floor(\n              redeemerEvaluation.budget.steps * txEvaluationMultiplier,\n            );\n          }\n          break;\n        }\n        case \"MINT\": {\n          const mint = meshTxBuilderBody.mints[redeemerEvaluation.index];\n          if (!mint) {\n            throw Error(\n              `updateRedeemer: Mint not found for index ${redeemerEvaluation.index}`,\n            );\n          }\n          if (mint.type == \"Plutus\" && mint.redeemer) {\n            let newExUnits: Budget = {\n              mem: Math.floor(\n                redeemerEvaluation.budget.mem * txEvaluationMultiplier,\n              ),\n              steps: Math.floor(\n                redeemerEvaluation.budget.steps * txEvaluationMultiplier,\n              ),\n            };\n            // It's possible to have multiple mints with the same policy id but different\n            // asset name, so we need to loop over the mints after evaluation\n            for (\n              let i = redeemerEvaluation.index;\n              i < meshTxBuilderBody.mints.length;\n              i++\n            ) {\n              if (meshTxBuilderBody.mints[i]!.policyId === mint.policyId) {\n                meshTxBuilderBody.mints[i]!.redeemer!.exUnits = newExUnits;\n              }\n            }\n          }\n          break;\n        }\n        case \"CERT\":\n          const cert = meshTxBuilderBody.certificates[redeemerEvaluation.index];\n          if (!cert) {\n            throw Error(\n              `updateRedeemer: Cert not found for index ${redeemerEvaluation.index}`,\n            );\n          }\n          if (cert.type === \"ScriptCertificate\" && cert.redeemer) {\n            cert.redeemer.exUnits.mem = Math.floor(\n              redeemerEvaluation.budget.mem * txEvaluationMultiplier,\n            );\n            cert.redeemer.exUnits.steps = Math.floor(\n              redeemerEvaluation.budget.steps * txEvaluationMultiplier,\n            );\n          }\n          break;\n        case \"REWARD\":\n          const withdrawal =\n            meshTxBuilderBody.withdrawals[redeemerEvaluation.index];\n          if (!withdrawal) {\n            throw Error(\n              `updateRedeemer: Withdrawal not found for index ${redeemerEvaluation.index}`,\n            );\n          }\n          if (withdrawal.type === \"ScriptWithdrawal\" && withdrawal.redeemer) {\n            withdrawal.redeemer.exUnits.mem = Math.floor(\n              redeemerEvaluation.budget.mem * txEvaluationMultiplier,\n            );\n            withdrawal.redeemer.exUnits.steps = Math.floor(\n              redeemerEvaluation.budget.steps * txEvaluationMultiplier,\n            );\n          }\n          break;\n        case \"VOTE\":\n          const vote = meshTxBuilderBody.votes[redeemerEvaluation.index];\n          if (!vote) {\n            throw Error(\n              `updateRedeemer: Vote not found for index ${redeemerEvaluation.index}`,\n            );\n          }\n          if (vote.type === \"ScriptVote\" && vote.redeemer) {\n            vote.redeemer.exUnits.mem = Math.floor(\n              redeemerEvaluation.budget.mem * txEvaluationMultiplier,\n            );\n            vote.redeemer.exUnits.steps = Math.floor(\n              redeemerEvaluation.budget.steps * txEvaluationMultiplier,\n            );\n          }\n          break;\n      }\n    });\n  };\n\n  addUtxosFromSelection = () => {\n    const requiredAssets = this.meshTxBuilderBody.outputs.reduce(\n      (map, output) => {\n        const outputAmount = output.amount;\n        outputAmount.forEach((asset) => {\n          const { unit, quantity } = asset;\n          const existingQuantity = Number(map.get(unit)) || 0;\n          map.set(unit, String(existingQuantity + Number(quantity)));\n        });\n        return map;\n      },\n      new Map<Unit, Quantity>(),\n    );\n    this.meshTxBuilderBody.inputs.reduce((map, input) => {\n      const inputAmount = input.txIn.amount;\n      inputAmount?.forEach((asset) => {\n        const { unit, quantity } = asset;\n        const existingQuantity = Number(map.get(unit)) || 0;\n        map.set(unit, String(existingQuantity - Number(quantity)));\n      });\n      return map;\n    }, requiredAssets);\n    this.meshTxBuilderBody.mints.reduce((map, mint) => {\n      for (const assetValue of mint.mintValue) {\n        const mintAmount: Asset = {\n          unit: mint.policyId + assetValue.assetName,\n          quantity: String(assetValue.amount),\n        };\n        const existingQuantity = Number(map.get(mintAmount.unit)) || 0;\n        map.set(\n          mintAmount.unit,\n          String(existingQuantity - Number(mintAmount.quantity)),\n        );\n      }\n      return map;\n    }, requiredAssets);\n    const selectionConfig = this.meshTxBuilderBody.selectionConfig;\n\n    const utxoSelection = new UtxoSelection(\n      selectionConfig.threshold,\n      selectionConfig.includeTxFees,\n    );\n\n    let selectedInputs: UTxO[] = [];\n    switch (selectionConfig.strategy) {\n      case \"keepRelevant\":\n        selectedInputs = utxoSelection.keepRelevant(\n          requiredAssets,\n          this.meshTxBuilderBody.extraInputs,\n        );\n      case \"largestFirst\":\n        selectedInputs = utxoSelection.largestFirst(\n          requiredAssets,\n          this.meshTxBuilderBody.extraInputs,\n        );\n        break;\n\n      case \"largestFirstMultiAsset\":\n        selectedInputs = utxoSelection.largestFirstMultiAsset(\n          requiredAssets,\n          this.meshTxBuilderBody.extraInputs,\n        );\n        break;\n\n      default:\n        selectedInputs = utxoSelection.experimental(\n          requiredAssets,\n          this.meshTxBuilderBody.extraInputs,\n        );\n        break;\n    }\n\n    selectedInputs.forEach((input) => {\n      const pubKeyTxIn: PubKeyTxIn = {\n        type: \"PubKey\",\n        txIn: {\n          txHash: input.input.txHash,\n          txIndex: input.input.outputIndex,\n          amount: input.output.amount,\n          address: input.output.address,\n        },\n      };\n      this.meshTxBuilderBody.inputs.push(pubKeyTxIn);\n      // If an input selected has script ref, then we must\n      // provide the script size to the tx builder also\n      if (input.output.scriptRef) {\n        this.meshTxBuilderBody.referenceInputs.push({\n          txHash: input.input.txHash,\n          txIndex: input.input.outputIndex,\n          scriptSize: input.output.scriptRef!.length / 2,\n        });\n      }\n      this.inputForEvaluation(input);\n    });\n  };\n\n  removeDuplicateInputs = () => {\n    const { inputs } = this.meshTxBuilderBody;\n    const getTxInId = (txIn: TxInParameter): string =>\n      `${txIn.txHash}#${txIn.txIndex}`;\n    const currentTxInIds: string[] = [];\n    const addedInputs: TxIn[] = [];\n    for (let i = 0; i < inputs.length; i += 1) {\n      const currentInput = inputs[i]!;\n      const currentTxInId = getTxInId(currentInput.txIn);\n      if (currentTxInIds.includes(currentTxInId)) {\n        continue;\n      } else {\n        currentTxInIds.push(currentTxInId);\n        addedInputs.push(currentInput);\n      }\n    }\n    this.meshTxBuilderBody.inputs = addedInputs;\n  };\n\n  removeDuplicateRefInputs = () => {\n    const { referenceInputs } = this.meshTxBuilderBody;\n    const getTxInId = (txIn: RefTxIn): string =>\n      `${txIn.txHash}#${txIn.txIndex}`;\n    const currentTxInIds: string[] = [];\n    const addedInputs: RefTxIn[] = [];\n    for (let i = 0; i < referenceInputs.length; i += 1) {\n      const currentInput = referenceInputs[i]!;\n      const currentTxInId = getTxInId(currentInput);\n      if (currentTxInIds.includes(currentTxInId)) {\n        continue;\n      } else {\n        currentTxInIds.push(currentTxInId);\n        addedInputs.push(currentInput);\n      }\n    }\n    this.meshTxBuilderBody.referenceInputs = addedInputs;\n  };\n\n  emptyTxBuilderBody = () => {\n    this.meshTxBuilderBody = emptyTxBuilderBody();\n    return emptyTxBuilderBody;\n  };\n\n  reset = () => {\n    this.meshTxBuilderBody = emptyTxBuilderBody();\n    this.txEvaluationMultiplier = 1;\n    this.txOutput = undefined;\n    this.addingPlutusScriptInput = false;\n    this.plutusSpendingScriptVersion = undefined;\n    this.addingPlutusMint = false;\n    this.plutusMintingScriptVersion = undefined;\n    this.addingPlutusWithdrawal = false;\n    this.addingPlutusVote = false;\n    this.plutusWithdrawalScriptVersion = undefined;\n    this._protocolParams = DEFAULT_PROTOCOL_PARAMETERS;\n    this.mintItem = undefined;\n    this.txInQueueItem = undefined;\n    this.withdrawalItem = undefined;\n    this.voteItem = undefined;\n    this.collateralQueueItem = undefined;\n    this.refScriptTxInQueueItem = undefined;\n  };\n\n  protected _cloneCore<T extends MeshTxBuilderCore>(\n    createInstance: () => T,\n  ): T {\n    this.queueAllLastItem();\n\n    const newBuilder = createInstance();\n\n    newBuilder.meshTxBuilderBody = cloneTxBuilderBody(this.meshTxBuilderBody);\n\n    newBuilder.txEvaluationMultiplier = this.txEvaluationMultiplier;\n    newBuilder.txOutput = this.txOutput\n      ? structuredClone(this.txOutput)\n      : undefined;\n\n    // Clone boolean flags\n    newBuilder.addingPlutusScriptInput = this.addingPlutusScriptInput;\n    newBuilder.plutusSpendingScriptVersion = this.plutusSpendingScriptVersion;\n    newBuilder.addingPlutusMint = this.addingPlutusMint;\n    newBuilder.plutusMintingScriptVersion = this.plutusMintingScriptVersion;\n    newBuilder.addingPlutusWithdrawal = this.addingPlutusWithdrawal;\n    newBuilder.plutusWithdrawalScriptVersion =\n      this.plutusWithdrawalScriptVersion;\n    newBuilder.addingPlutusVote = this.addingPlutusVote;\n    newBuilder.plutusVoteScriptVersion = this.plutusVoteScriptVersion;\n\n    newBuilder._protocolParams = structuredClone(this._protocolParams);\n\n    newBuilder.mintItem = this.mintItem\n      ? structuredClone(this.mintItem)\n      : undefined;\n    newBuilder.txInQueueItem = this.txInQueueItem\n      ? structuredClone(this.txInQueueItem)\n      : undefined;\n    newBuilder.withdrawalItem = this.withdrawalItem\n      ? structuredClone(this.withdrawalItem)\n      : undefined;\n    newBuilder.voteItem = this.voteItem\n      ? structuredClone(this.voteItem)\n      : undefined;\n    newBuilder.collateralQueueItem = this.collateralQueueItem\n      ? structuredClone(this.collateralQueueItem)\n      : undefined;\n    newBuilder.refScriptTxInQueueItem = this.refScriptTxInQueueItem\n      ? structuredClone(this.refScriptTxInQueueItem)\n      : undefined;\n    newBuilder.manualFee = this.manualFee;\n\n    return newBuilder;\n  }\n}\n",
      "dependencies": [
        "MeshTxBuilderCore"
      ],
      "source": "mesh-transaction",
      "isReExportFile": false
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.utils.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/utils.ts",
      "name": "mesh-tx-builder.utils.ts",
      "imports": [
        {
          "module": "utxoToTxIn",
          "items": [],
          "line": 19,
          "raw": "export const utxoToTxIn = (utxo: UTxO): [string, number, Asset[], string] => {",
          "source": "mesh-transaction"
        },
        {
          "module": "getUtxoMinLovelace",
          "items": [],
          "line": 34,
          "raw": "export const getUtxoMinLovelace = (",
          "source": "mesh-transaction"
        }
      ],
      "functions": [
        {
          "name": "utxoToTxIn",
          "signature": "export const utxoToTxIn = (utxo: UTxO): [string, number, Asset[], string] => {",
          "documentation": "/**\n * Convert UTxO to TxIn parameters in array for MeshTxBuilder\n * @param utxo UTxO\n * @returns [txHash, outputIndex, amount, address]\n */",
          "parameters": [
            {
              "name": "utxo",
              "type": "UTxO",
              "optional": false
            }
          ],
          "returnType": "[string, number, Asset[], string]",
          "isPublic": true,
          "line": 19,
          "raw": "/**\n * Convert UTxO to TxIn parameters in array for MeshTxBuilder\n * @param utxo UTxO\n * @returns [txHash, outputIndex, amount, address]\n */\nexport const utxoToTxIn = (utxo: UTxO): [string, number, Asset[], string] => {\n  return [\n    utxo.input.txHash,\n    utxo.input.outputIndex,\n    utxo.output.amount,\n    utxo.output.address,\n  ];\n};",
          "source": "mesh-transaction",
          "implementation": "export const utxoToTxIn = (utxo: UTxO): [string, number, Asset[], string] => {\n  return [\n    utxo.input.txHash,\n    utxo.input.outputIndex,\n    utxo.output.amount,\n    utxo.output.address,\n  ];\n};"
        },
        {
          "name": "getUtxoMinLovelace",
          "signature": "export const getUtxoMinLovelace = (",
          "documentation": "/**\n * Calculate minimum lovelace required for a UTxO output\n * @param utxo Output of utxo\n * @param coinsPerUtxoSize From protocol parameters\n * @returns Minimum lovelace required for the UTxO\n */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 34,
          "raw": "/**\n * Calculate minimum lovelace required for a UTxO output\n * @param utxo Output of utxo\n * @param coinsPerUtxoSize From protocol parameters\n * @returns Minimum lovelace required for the UTxO\n */\nexport const getUtxoMinLovelace = (\n  utxo: TxOutput,\n  coinsPerUtxoSize = DEFAULT_PROTOCOL_PARAMETERS.coinsPerUtxoSize,\n): bigint => {\n  const referenceScript: PlutusScript | undefined = utxo.scriptRef\n    ? { code: utxo.scriptRef, version: \"V3\" } // Language version is not relevant in min utxo calculation\n    : undefined;\n\n  let datum:\n    | {\n        type: \"Hash\" | \"Inline\" | \"Embedded\";\n        data: BuilderData;\n      }\n    | undefined;\n\n  if (utxo.plutusData) {\n    datum = {\n      type: \"Inline\",\n      data: {\n        content: utxo.plutusData,\n        type: \"CBOR\",\n      },\n    };\n  } else if (utxo.dataHash) {\n    datum = {\n      type: \"Hash\",\n      data: {\n        content: utxo.dataHash, // usually this should be entire datum cbor, but irrelevant in min utxo calculation\n        type: \"CBOR\",\n      },\n    };\n  }\n\n  const output: Output = {\n    address: utxo.address,\n    amount: utxo.amount,\n    referenceScript,\n    datum,\n  };\n  const minLovelace = getOutputMinLovelace(output, coinsPerUtxoSize);\n  return minLovelace;\n};",
          "source": "mesh-transaction",
          "implementation": "export const getUtxoMinLovelace = (\n  utxo: TxOutput,\n  coinsPerUtxoSize = DEFAULT_PROTOCOL_PARAMETERS.coinsPerUtxoSize,\n): bigint => {\n  const referenceScript: PlutusScript | undefined = utxo.scriptRef\n    ? { code: utxo.scriptRef, version: \"V3\" } // Language version is not relevant in min utxo calculation\n    : undefined;\n\n  let datum:\n    | {\n        type: \"Hash\" | \"Inline\" | \"Embedded\";\n        data: BuilderData;\n      }\n    | undefined;\n\n  if (utxo.plutusData) {\n    datum = {\n      type: \"Inline\",\n      data: {\n        content: utxo.plutusData,\n        type: \"CBOR\",\n      },\n    };\n  } else if (utxo.dataHash) {\n    datum = {\n      type: \"Hash\",\n      data: {\n        content: utxo.dataHash, // usually this should be entire datum cbor, but irrelevant in min utxo calculation\n        type: \"CBOR\",\n      },\n    };\n  }\n\n  const output: Output = {\n    address: utxo.address,\n    amount: utxo.amount,\n    referenceScript,\n    datum,\n  };\n  const minLovelace = getOutputMinLovelace(output, coinsPerUtxoSize);\n  return minLovelace;\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "utxoToTxIn",
          "type": "any",
          "value": "(utxo: UTxO): [string, number, Asset[], string] => {",
          "isPublic": true,
          "line": 19,
          "raw": "export const utxoToTxIn = (utxo: UTxO): [string, number, Asset[], string] => {",
          "source": "mesh-transaction"
        },
        {
          "name": "getUtxoMinLovelace",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 34,
          "raw": "export const getUtxoMinLovelace = (",
          "source": "mesh-transaction"
        },
        {
          "name": "referenceScript",
          "type": "PlutusScript | undefined",
          "value": "utxo.scriptRef",
          "isPublic": true,
          "line": 38,
          "raw": "const referenceScript: PlutusScript | undefined = utxo.scriptRef",
          "source": "mesh-transaction"
        },
        {
          "name": "output",
          "type": "Output",
          "value": "{",
          "isPublic": true,
          "line": 67,
          "raw": "const output: Output = {",
          "source": "mesh-transaction"
        },
        {
          "name": "minLovelace",
          "type": "any",
          "value": "getOutputMinLovelace(output, coinsPerUtxoSize);",
          "isPublic": true,
          "line": 73,
          "raw": "const minLovelace = getOutputMinLovelace(output, coinsPerUtxoSize);",
          "source": "mesh-transaction"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  Asset,\n  BuilderData,\n  DEFAULT_PROTOCOL_PARAMETERS,\n  Output,\n  PlutusScript,\n  TxOutput,\n  UTxO,\n} from \"@meshsdk/common\";\nimport { deserializePlutusScript } from \"@meshsdk/core-cst\";\n\nimport { getOutputMinLovelace } from \".\";\n\n/**\n * Convert UTxO to TxIn parameters in array for MeshTxBuilder\n * @param utxo UTxO\n * @returns [txHash, outputIndex, amount, address]\n */\nexport const utxoToTxIn = (utxo: UTxO): [string, number, Asset[], string] => {\n  return [\n    utxo.input.txHash,\n    utxo.input.outputIndex,\n    utxo.output.amount,\n    utxo.output.address,\n  ];\n};\n\n/**\n * Calculate minimum lovelace required for a UTxO output\n * @param utxo Output of utxo\n * @param coinsPerUtxoSize From protocol parameters\n * @returns Minimum lovelace required for the UTxO\n */\nexport const getUtxoMinLovelace = (\n  utxo: TxOutput,\n  coinsPerUtxoSize = DEFAULT_PROTOCOL_PARAMETERS.coinsPerUtxoSize,\n): bigint => {\n  const referenceScript: PlutusScript | undefined = utxo.scriptRef\n    ? { code: utxo.scriptRef, version: \"V3\" } // Language version is not relevant in min utxo calculation\n    : undefined;\n\n  let datum:\n    | {\n        type: \"Hash\" | \"Inline\" | \"Embedded\";\n        data: BuilderData;\n      }\n    | undefined;\n\n  if (utxo.plutusData) {\n    datum = {\n      type: \"Inline\",\n      data: {\n        content: utxo.plutusData,\n        type: \"CBOR\",\n      },\n    };\n  } else if (utxo.dataHash) {\n    datum = {\n      type: \"Hash\",\n      data: {\n        content: utxo.dataHash, // usually this should be entire datum cbor, but irrelevant in min utxo calculation\n        type: \"CBOR\",\n      },\n    };\n  }\n\n  const output: Output = {\n    address: utxo.address,\n    amount: utxo.amount,\n    referenceScript,\n    datum,\n  };\n  const minLovelace = getOutputMinLovelace(output, coinsPerUtxoSize);\n  return minLovelace;\n};\n",
      "dependencies": [
        "utxoToTxIn",
        "getUtxoMinLovelace"
      ],
      "source": "mesh-transaction",
      "isReExportFile": false
    },
    {
      "key": "mesh-transaction:scripts.forge.script.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/scripts/forge.script.ts",
      "name": "scripts.forge.script.ts",
      "imports": [
        {
          "module": "ForgeScript",
          "items": [],
          "line": 10,
          "raw": "export class ForgeScript {",
          "source": "mesh-transaction"
        }
      ],
      "functions": [],
      "types": [],
      "constants": [
        {
          "name": "keyHash",
          "type": "any",
          "value": "deserializeEd25519KeyHash(resolvePaymentKeyHash(address));",
          "isPublic": true,
          "line": 12,
          "raw": "const keyHash = deserializeEd25519KeyHash(resolvePaymentKeyHash(address));",
          "source": "mesh-transaction"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import type { NativeScript } from \"@meshsdk/common\";\n\nimport {\n  buildScriptPubkey,\n  deserializeEd25519KeyHash,\n  toNativeScript,\n  resolvePaymentKeyHash,\n} from \"@meshsdk/core-cst\";\n\nexport class ForgeScript {\n  static withOneSignature(address: string): string {\n    const keyHash = deserializeEd25519KeyHash(resolvePaymentKeyHash(address));\n    return buildScriptPubkey(keyHash).toCbor();\n  }\n\n  // static withAtLeastNSignatures(\n  //   addresses: string[], minimumRequired: number,\n  // ): string {\n  //   const nativeScripts = csl.NativeScripts.new();\n\n  //   addresses.forEach((address) => {\n  //     const keyHash = deserializeEd25519KeyHash(\n  //       resolvePaymentKeyHash(address),\n  //     );\n  //     nativeScripts.add(buildScriptPubkey(keyHash));\n  //   });\n\n  //   const scriptNOfK = csl.ScriptNOfK.new(minimumRequired, nativeScripts);\n  //   return csl.NativeScript.new_script_any(scriptNOfK).to_hex();\n  // }\n\n  // static withAnySignature(addresses: string[]): string {\n  //   const nativeScripts = csl.NativeScripts.new();\n\n  //   addresses.forEach((address) => {\n  //     const keyHash = deserializeEd25519KeyHash(\n  //       resolvePaymentKeyHash(address),\n  //     );\n  //     nativeScripts.add(buildScriptPubkey(keyHash));\n  //   });\n\n  //   const scriptAny = csl.ScriptAny.new(nativeScripts);\n  //   return csl.NativeScript.new_script_any(scriptAny).to_hex();\n  // }\n\n  // static withAllSignatures(addresses: string[]): string {\n  //   const nativeScripts = csl.NativeScripts.new();\n\n  //   addresses.forEach((address) => {\n  //     const keyHash = deserializeEd25519KeyHash(\n  //       resolvePaymentKeyHash(address),\n  //     );\n  //     nativeScripts.add(buildScriptPubkey(keyHash));\n  //   });\n\n  //   const scriptAll = csl.ScriptAll.new(nativeScripts);\n  //   return csl.NativeScript.new_script_any(scriptAll).to_hex();\n  // }\n\n  static fromNativeScript(script: NativeScript): string {\n    return toNativeScript(script).toCbor();\n  }\n}\n",
      "dependencies": [
        "ForgeScript"
      ],
      "source": "mesh-transaction",
      "isReExportFile": false
    },
    {
      "key": "mesh-transaction:scripts.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/scripts/index.ts",
      "name": "scripts.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./forge.script\";\n",
      "dependencies": [],
      "source": "mesh-transaction",
      "isReExportFile": false
    },
    {
      "key": "mesh-transaction:transaction.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/transaction/index.ts",
      "name": "transaction.index.ts",
      "imports": [
        {
          "module": "TransactionOptions",
          "items": [],
          "line": 39,
          "raw": "export interface TransactionOptions extends MeshTxBuilderOptions {",
          "source": "mesh-transaction"
        },
        {
          "module": "Transaction",
          "items": [],
          "line": 46,
          "raw": "export class Transaction {",
          "source": "mesh-transaction"
        }
      ],
      "functions": [
        {
          "name": "sendAssets",
          "signature": "sendAssets(recipient: Recipient, assets: Asset[] | string): Transaction {",
          "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * @param recipient The recipient of the output.\n   * @param assets The assets to send. Provide string for lovelace and Asset[] for tokens and/or lovelace.\n   * @returns The transaction builder.\n   * @see {@link https://meshjs.dev/apis/transaction#sendAssets}\n   */",
          "parameters": [
            {
              "name": "recipient",
              "type": "Recipient",
              "optional": false
            },
            {
              "name": "assets",
              "type": "Asset[] | string",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "isPublic": true,
          "line": 133,
          "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * @param recipient The recipient of the output.\n   * @param assets The assets to send. Provide string for lovelace and Asset[] for tokens and/or lovelace.\n   * @returns The transaction builder.\n   * @see {@link https://meshjs.dev/apis/transaction#sendAssets}\n   */\n  sendAssets(recipient: Recipient, assets: Asset[] | string): Transaction {\n    if (typeof assets === \"string\") {\n      assets = [\n        {\n          unit: \"lovelace\",\n          quantity: assets,\n        },\n      ];\n    }\n    if (typeof recipient === \"string\") {\n      this.txBuilder.txOut(recipient, assets);\n    }\n    if (typeof recipient === \"object\") {\n      this.txBuilder.txOut(recipient.address, assets);\n      if (recipient.datum) {\n        if (recipient.datum.inline) {\n          this.txBuilder.txOutInlineDatumValue(recipient.datum.value);\n        } else {\n          this.txBuilder.txOutDatumHashValue(recipient.datum.value);\n        }\n      }\n    }\n\n    return this;\n  }",
          "source": "mesh-transaction",
          "implementation": "  sendAssets(recipient: Recipient, assets: Asset[] | string): Transaction {\n    if (typeof assets === \"string\") {\n      assets = [\n        {\n          unit: \"lovelace\",\n          quantity: assets,\n        },\n      ];\n    }\n    if (typeof recipient === \"string\") {\n      this.txBuilder.txOut(recipient, assets);\n    }\n    if (typeof recipient === \"object\") {\n      this.txBuilder.txOut(recipient.address, assets);\n      if (recipient.datum) {\n        if (recipient.datum.inline) {\n          this.txBuilder.txOutInlineDatumValue(recipient.datum.value);\n        } else {\n          this.txBuilder.txOutDatumHashValue(recipient.datum.value);\n        }\n      }\n    }\n\n    return this;\n  }"
        },
        {
          "name": "sendLovelace",
          "signature": "sendLovelace(recipient: Recipient, lovelace: string): Transaction {",
          "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Use sendAssets instead:\n   * ```ts\n   * this.sendAssets(recipient, lovelace);\n   * ```\n   *\n   * Deprecation reason - Unnecessary implementation which might cause confusion.\n   *\n   * @param {Recipient} recipient The recipient of the transaction.\n   * @param {string} lovelace The amount of lovelace to send.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#sendAda}\n   */",
          "parameters": [
            {
              "name": "recipient",
              "type": "Recipient",
              "optional": false
            },
            {
              "name": "lovelace",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "isPublic": true,
          "line": 175,
          "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Use sendAssets instead:\n   * ```ts\n   * this.sendAssets(recipient, lovelace);\n   * ```\n   *\n   * Deprecation reason - Unnecessary implementation which might cause confusion.\n   *\n   * @param {Recipient} recipient The recipient of the transaction.\n   * @param {string} lovelace The amount of lovelace to send.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#sendAda}\n   */\n  sendLovelace(recipient: Recipient, lovelace: string): Transaction {\n    return this.sendAssets(recipient, lovelace);\n  }",
          "source": "mesh-transaction",
          "implementation": "  sendLovelace(recipient: Recipient, lovelace: string): Transaction {\n    return this.sendAssets(recipient, lovelace);\n  }"
        },
        {
          "name": "sendToken",
          "signature": "sendToken(recipient: Recipient, ticker: Token, amount: string): Transaction {",
          "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Please use sendAssets with helper function to obtain token unit instead:\n   * ```ts\n   * const assets = [{ unit: SUPPORTED_TOKENS.GIMBAL, quantity: \"100\" }]\n   * transaction.sendAssets(recipient, assets)\n   * ```\n   *\n   * Deprecation reason - Required maintenance on tokens.\n   *\n   * @param {Recipient} recipient The recipient of the transaction.\n   * @param {Token} ticker The ticker of the token to send.\n   * @param {string} amount The amount of the token to send.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#sendToken}\n   */",
          "parameters": [
            {
              "name": "recipient",
              "type": "Recipient",
              "optional": false
            },
            {
              "name": "ticker",
              "type": "Token",
              "optional": false
            },
            {
              "name": "amount",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "isPublic": true,
          "line": 197,
          "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Please use sendAssets with helper function to obtain token unit instead:\n   * ```ts\n   * const assets = [{ unit: SUPPORTED_TOKENS.GIMBAL, quantity: \"100\" }]\n   * transaction.sendAssets(recipient, assets)\n   * ```\n   *\n   * Deprecation reason - Required maintenance on tokens.\n   *\n   * @param {Recipient} recipient The recipient of the transaction.\n   * @param {Token} ticker The ticker of the token to send.\n   * @param {string} amount The amount of the token to send.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#sendToken}\n   */\n  sendToken(recipient: Recipient, ticker: Token, amount: string): Transaction {\n    const assets = [{ unit: SUPPORTED_TOKENS[ticker], quantity: amount }];\n    return this.sendAssets(recipient, assets);\n  }",
          "source": "mesh-transaction",
          "implementation": "  sendToken(recipient: Recipient, ticker: Token, amount: string): Transaction {\n    const assets = [{ unit: SUPPORTED_TOKENS[ticker], quantity: amount }];\n    return this.sendAssets(recipient, assets);\n  }"
        },
        {
          "name": "sendValue",
          "signature": "sendValue(recipient: Recipient, value: UTxO): Transaction {",
          "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * ```ts\n   * const assets = value.output.amount;\n   * this.sendAssets(recipient, assets);\n   * ```\n   * Deprecation reason - Unnecessary implementation which might cause confusion.\n   *\n   * @param {Recipient} recipient The recipient of the output.\n   * @param {UTxO} value The UTxO value of the output.\n   * @returns {Transaction} The Transaction object.\n   */",
          "parameters": [
            {
              "name": "recipient",
              "type": "Recipient",
              "optional": false
            },
            {
              "name": "value",
              "type": "UTxO",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "isPublic": true,
          "line": 216,
          "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * ```ts\n   * const assets = value.output.amount;\n   * this.sendAssets(recipient, assets);\n   * ```\n   * Deprecation reason - Unnecessary implementation which might cause confusion.\n   *\n   * @param {Recipient} recipient The recipient of the output.\n   * @param {UTxO} value The UTxO value of the output.\n   * @returns {Transaction} The Transaction object.\n   */\n  sendValue(recipient: Recipient, value: UTxO): Transaction {\n    const assets = value.output.amount;\n    return this.sendAssets(recipient, assets);\n  }",
          "source": "mesh-transaction",
          "implementation": "  sendValue(recipient: Recipient, value: UTxO): Transaction {\n    const assets = value.output.amount;\n    return this.sendAssets(recipient, assets);\n  }"
        },
        {
          "name": "setTxInputs",
          "signature": "setTxInputs(inputs: UTxO[]): Transaction {",
          "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * @param {UTxO[]} inputs The inputs to set.\n   * @returns {Transaction} The transaction.\n   */",
          "parameters": [
            {
              "name": "inputs",
              "type": "UTxO[]",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "isPublic": true,
          "line": 228,
          "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * @param {UTxO[]} inputs The inputs to set.\n   * @returns {Transaction} The transaction.\n   */\n  setTxInputs(inputs: UTxO[]): Transaction {\n    inputs.forEach((input) => {\n      this.txBuilder.txIn(\n        input.input.txHash,\n        input.input.outputIndex,\n        input.output.amount,\n        input.output.address,\n        input.output.scriptRef ? input.output.scriptRef.length / 2 : 0,\n      );\n    });\n\n    return this;\n  }",
          "source": "mesh-transaction",
          "implementation": "  setTxInputs(inputs: UTxO[]): Transaction {\n    inputs.forEach((input) => {\n      this.txBuilder.txIn(\n        input.input.txHash,\n        input.input.outputIndex,\n        input.output.amount,\n        input.output.address,\n        input.output.scriptRef ? input.output.scriptRef.length / 2 : 0,\n      );\n    });\n\n    return this;\n  }"
        },
        {
          "name": "setTxRefInputs",
          "signature": "setTxRefInputs(inputs: UTxO[]): Transaction {",
          "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * @param {UTxO[]} inputs The reference inputs to set.\n   * @returns {Transaction} The transaction.\n   */",
          "parameters": [
            {
              "name": "inputs",
              "type": "UTxO[]",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "isPublic": true,
          "line": 249,
          "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * @param {UTxO[]} inputs The reference inputs to set.\n   * @returns {Transaction} The transaction.\n   */\n  setTxRefInputs(inputs: UTxO[]): Transaction {\n    inputs.forEach((input) => {\n      this.txBuilder.readOnlyTxInReference(\n        input.input.txHash,\n        input.input.outputIndex,\n      );\n    });\n\n    return this;\n  }",
          "source": "mesh-transaction",
          "implementation": "  setTxRefInputs(inputs: UTxO[]): Transaction {\n    inputs.forEach((input) => {\n      this.txBuilder.readOnlyTxInReference(\n        input.input.txHash,\n        input.input.outputIndex,\n      );\n    });\n\n    return this;\n  }"
        },
        {
          "name": "setNativeScriptInput",
          "signature": "setNativeScriptInput(script: NativeScript, utxo: UTxO): Transaction {",
          "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the native script for the transaction.\n   * @param {NativeScript} script The native script to spend from.\n   * @param {UTxO} utxo The UTxO attached to the script.\n   * @returns {Transaction} The Transaction object.\n   */",
          "parameters": [
            {
              "name": "script",
              "type": "NativeScript",
              "optional": false
            },
            {
              "name": "utxo",
              "type": "UTxO",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "isPublic": true,
          "line": 269,
          "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the native script for the transaction.\n   * @param {NativeScript} script The native script to spend from.\n   * @param {UTxO} utxo The UTxO attached to the script.\n   * @returns {Transaction} The Transaction object.\n   */\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): Transaction {\n    const { scriptCbor } =\n      this.txBuilder.serializer.deserializer.script.deserializeNativeScript(\n        script,\n      );\n    this.txBuilder\n      .txIn(\n        utxo.input.txHash,\n        utxo.input.outputIndex,\n        utxo.output.amount,\n        utxo.output.address,\n      )\n      .txInScript(scriptCbor!);\n\n    return this;\n  }",
          "source": "mesh-transaction",
          "implementation": "  setNativeScriptInput(script: NativeScript, utxo: UTxO): Transaction {\n    const { scriptCbor } =\n      this.txBuilder.serializer.deserializer.script.deserializeNativeScript(\n        script,\n      );\n    this.txBuilder\n      .txIn(\n        utxo.input.txHash,\n        utxo.input.outputIndex,\n        utxo.output.amount,\n        utxo.output.address,\n      )\n      .txInScript(scriptCbor!);\n\n    return this;\n  }"
        },
        {
          "name": "setChangeAddress",
          "signature": "setChangeAddress(changeAddress: string): Transaction {",
          "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the change address for the transaction.\n   *\n   * @param {string} changeAddress The change address.\n   * @returns {Transaction} The Transaction object.\n   */",
          "parameters": [
            {
              "name": "changeAddress",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "isPublic": true,
          "line": 552,
          "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the change address for the transaction.\n   *\n   * @param {string} changeAddress The change address.\n   * @returns {Transaction} The Transaction object.\n   */\n  setChangeAddress(changeAddress: string): Transaction {\n    this.txBuilder.changeAddress(changeAddress);\n    return this;\n  }",
          "source": "mesh-transaction",
          "implementation": "  setChangeAddress(changeAddress: string): Transaction {\n    this.txBuilder.changeAddress(changeAddress);\n    return this;\n  }"
        },
        {
          "name": "setCollateral",
          "signature": "setCollateral(collateral: UTxO[]): Transaction {",
          "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the collateral for the transaction.\n   *\n   * @param {UTxO[]} collateral - Set the UTxO for collateral.\n   * @returns {Transaction} The Transaction object.\n   */",
          "parameters": [
            {
              "name": "collateral",
              "type": "UTxO[]",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "isPublic": true,
          "line": 566,
          "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the collateral for the transaction.\n   *\n   * @param {UTxO[]} collateral - Set the UTxO for collateral.\n   * @returns {Transaction} The Transaction object.\n   */\n  setCollateral(collateral: UTxO[]): Transaction {\n    collateral.forEach((collateralUtxo) => {\n      this.txBuilder.txInCollateral(\n        collateralUtxo.input.txHash,\n        collateralUtxo.input.outputIndex,\n        collateralUtxo.output.amount,\n        collateralUtxo.output.address,\n      );\n    });\n\n    return this;\n  }",
          "source": "mesh-transaction",
          "implementation": "  setCollateral(collateral: UTxO[]): Transaction {\n    collateral.forEach((collateralUtxo) => {\n      this.txBuilder.txInCollateral(\n        collateralUtxo.input.txHash,\n        collateralUtxo.input.outputIndex,\n        collateralUtxo.output.amount,\n        collateralUtxo.output.address,\n      );\n    });\n\n    return this;\n  }"
        },
        {
          "name": "setNetwork",
          "signature": "setNetwork = (network: Network) => {",
          "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the network to use, this is mainly to know the cost models to be used to calculate script integrity hash\n   * @param network The specific network this transaction is being built for (\"testnet\" | \"preview\" | \"preprod\" | \"mainnet\")\n   * @returns The Transaction object.\n   */",
          "parameters": [
            {
              "name": "network",
              "type": "Network",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 587,
          "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the network to use, this is mainly to know the cost models to be used to calculate script integrity hash\n   * @param network The specific network this transaction is being built for (\"testnet\" | \"preview\" | \"preprod\" | \"mainnet\")\n   * @returns The Transaction object.\n   */\n  setNetwork = (network: Network) => {\n    this.txBuilder.setNetwork(network);\n    return this;\n  };",
          "source": "mesh-transaction",
          "implementation": "  setNetwork = (network: Network) => {\n    this.txBuilder.setNetwork(network);\n    return this;\n  };"
        },
        {
          "name": "setRequiredSigners",
          "signature": "setRequiredSigners(addresses: string[]): Transaction {",
          "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the required signers for the transaction.\n   *\n   * @param {string[]} addresses The addresses of the required signers.\n   * @returns {Transaction} The Transaction object.\n   */",
          "parameters": [
            {
              "name": "addresses",
              "type": "string[]",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "isPublic": true,
          "line": 601,
          "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the required signers for the transaction.\n   *\n   * @param {string[]} addresses The addresses of the required signers.\n   * @returns {Transaction} The Transaction object.\n   */\n  setRequiredSigners(addresses: string[]): Transaction {\n    addresses.forEach((address) => {\n      const { pubKeyHash } =\n        this.txBuilder.serializer.deserializer.key.deserializeAddress(address);\n      this.txBuilder.requiredSignerHash(pubKeyHash);\n    });\n\n    return this;\n  }",
          "source": "mesh-transaction",
          "implementation": "  setRequiredSigners(addresses: string[]): Transaction {\n    addresses.forEach((address) => {\n      const { pubKeyHash } =\n        this.txBuilder.serializer.deserializer.key.deserializeAddress(address);\n      this.txBuilder.requiredSignerHash(pubKeyHash);\n    });\n\n    return this;\n  }"
        },
        {
          "name": "setTimeToExpire",
          "signature": "setTimeToExpire(slot: string): Transaction {",
          "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   *  Set the time to live for the transaction.\n   *\n   * @param {string} slot The slot number to expire the transaction at.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#setTimeLimit}\n   */",
          "parameters": [
            {
              "name": "slot",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "isPublic": true,
          "line": 621,
          "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   *  Set the time to live for the transaction.\n   *\n   * @param {string} slot The slot number to expire the transaction at.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#setTimeLimit}\n   */\n  setTimeToExpire(slot: string): Transaction {\n    this.txBuilder.invalidHereafter(Number(slot));\n    return this;\n  }",
          "source": "mesh-transaction",
          "implementation": "  setTimeToExpire(slot: string): Transaction {\n    this.txBuilder.invalidHereafter(Number(slot));\n    return this;\n  }"
        },
        {
          "name": "setTimeToStart",
          "signature": "setTimeToStart(slot: string): Transaction {",
          "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   *  Sets the start slot for the transaction.\n   *\n   * @param {string} slot The start slot for the transaction.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#setTimeLimit}\n   */",
          "parameters": [
            {
              "name": "slot",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "isPublic": true,
          "line": 636,
          "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   *  Sets the start slot for the transaction.\n   *\n   * @param {string} slot The start slot for the transaction.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#setTimeLimit}\n   */\n  setTimeToStart(slot: string): Transaction {\n    this.txBuilder.invalidBefore(Number(slot));\n    return this;\n  }",
          "source": "mesh-transaction",
          "implementation": "  setTimeToStart(slot: string): Transaction {\n    this.txBuilder.invalidBefore(Number(slot));\n    return this;\n  }"
        },
        {
          "name": "setMetadata",
          "signature": "setMetadata(label: number, metadata: Metadatum | object): Transaction {",
          "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   *  Add a JSON metadata entry to the transaction.\n   *\n   * @param {number} label The label to use for the metadata entry.\n   * @param {unknown} metadata The value to use for the metadata entry.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#setMetadata}\n   */",
          "parameters": [
            {
              "name": "label",
              "type": "number",
              "optional": false
            },
            {
              "name": "metadata",
              "type": "Metadatum | object",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "isPublic": true,
          "line": 652,
          "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   *  Add a JSON metadata entry to the transaction.\n   *\n   * @param {number} label The label to use for the metadata entry.\n   * @param {unknown} metadata The value to use for the metadata entry.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#setMetadata}\n   */\n  setMetadata(label: number, metadata: Metadatum | object): Transaction {\n    this.txBuilder.metadataValue(label, metadata);\n    return this;\n  }",
          "source": "mesh-transaction",
          "implementation": "  setMetadata(label: number, metadata: Metadatum | object): Transaction {\n    this.txBuilder.metadataValue(label, metadata);\n    return this;\n  }"
        },
        {
          "name": "withdrawRewards",
          "signature": "withdrawRewards(rewardAddress: string, lovelace: string): Transaction {",
          "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */",
          "parameters": [
            {
              "name": "rewardAddress",
              "type": "string",
              "optional": false
            },
            {
              "name": "lovelace",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "isPublic": true,
          "line": 661,
          "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  withdrawRewards(rewardAddress: string, lovelace: string): Transaction {\n    this.txBuilder.withdrawal(rewardAddress, lovelace);\n    return this;\n  }",
          "source": "mesh-transaction",
          "implementation": "  withdrawRewards(rewardAddress: string, lovelace: string): Transaction {\n    this.txBuilder.withdrawal(rewardAddress, lovelace);\n    return this;\n  }"
        },
        {
          "name": "delegateStake",
          "signature": "delegateStake(rewardAddress: string, poolId: string): Transaction {",
          "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */",
          "parameters": [
            {
              "name": "rewardAddress",
              "type": "string",
              "optional": false
            },
            {
              "name": "poolId",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "isPublic": true,
          "line": 670,
          "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  delegateStake(rewardAddress: string, poolId: string): Transaction {\n    this.txBuilder.delegateStakeCertificate(\n      rewardAddress,\n      this.txBuilder.serializer.deserializer.cert.deserializePoolId(poolId),\n    );\n    return this;\n  }",
          "source": "mesh-transaction",
          "implementation": "  delegateStake(rewardAddress: string, poolId: string): Transaction {\n    this.txBuilder.delegateStakeCertificate(\n      rewardAddress,\n      this.txBuilder.serializer.deserializer.cert.deserializePoolId(poolId),\n    );\n    return this;\n  }"
        },
        {
          "name": "deregisterStake",
          "signature": "deregisterStake(rewardAddress: string): Transaction {",
          "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */",
          "parameters": [
            {
              "name": "rewardAddress",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "isPublic": true,
          "line": 682,
          "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  deregisterStake(rewardAddress: string): Transaction {\n    this.txBuilder.deregisterStakeCertificate(rewardAddress);\n    return this;\n  }",
          "source": "mesh-transaction",
          "implementation": "  deregisterStake(rewardAddress: string): Transaction {\n    this.txBuilder.deregisterStakeCertificate(rewardAddress);\n    return this;\n  }"
        },
        {
          "name": "registerStake",
          "signature": "registerStake(rewardAddress: string): Transaction {",
          "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */",
          "parameters": [
            {
              "name": "rewardAddress",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "isPublic": true,
          "line": 691,
          "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  registerStake(rewardAddress: string): Transaction {\n    this.txBuilder.registerStakeCertificate(rewardAddress);\n    return this;\n  }",
          "source": "mesh-transaction",
          "implementation": "  registerStake(rewardAddress: string): Transaction {\n    this.txBuilder.registerStakeCertificate(rewardAddress);\n    return this;\n  }"
        },
        {
          "name": "registerPool",
          "signature": "registerPool(params: PoolParams): Transaction {",
          "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */",
          "parameters": [
            {
              "name": "params",
              "type": "PoolParams",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "isPublic": true,
          "line": 700,
          "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  registerPool(params: PoolParams): Transaction {\n    this.txBuilder.registerPoolCertificate(params);\n    return this;\n  }",
          "source": "mesh-transaction",
          "implementation": "  registerPool(params: PoolParams): Transaction {\n    this.txBuilder.registerPoolCertificate(params);\n    return this;\n  }"
        },
        {
          "name": "retirePool",
          "signature": "retirePool(poolId: string, epochNo: number): Transaction {",
          "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */",
          "parameters": [
            {
              "name": "poolId",
              "type": "string",
              "optional": false
            },
            {
              "name": "epochNo",
              "type": "number",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "isPublic": true,
          "line": 709,
          "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  retirePool(poolId: string, epochNo: number): Transaction {\n    this.txBuilder.retirePoolCertificate(poolId, epochNo);\n    return this;\n  }",
          "source": "mesh-transaction",
          "implementation": "  retirePool(poolId: string, epochNo: number): Transaction {\n    this.txBuilder.retirePoolCertificate(poolId, epochNo);\n    return this;\n  }"
        },
        {
          "name": "mask",
          "signature": "function mask(",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 808,
          "raw": "function mask(\n  metadatum: Serialization.TransactionMetadatum,\n): Serialization.TransactionMetadatum {\n  switch (metadatum.getKind()) {\n    case Serialization.TransactionMetadatumKind.Text:\n      return Serialization.TransactionMetadatum.newText(\n        \"0\".repeat(metadatum.asText()?.length ?? 0),\n      );\n    case Serialization.TransactionMetadatumKind.Bytes:\n    case Serialization.TransactionMetadatumKind.Integer:\n      return metadatum;\n    case Serialization.TransactionMetadatumKind.List:\n      const list = new Serialization.MetadatumList();\n      for (let i = 0; i < (metadatum.asList()?.getLength() ?? 0); i++) {\n        list.add(mask(metadatum.asList()?.get(i)!));\n      }\n      return Serialization.TransactionMetadatum.newList(list);\n    case Serialization.TransactionMetadatumKind.Map:\n      const map = new Serialization.MetadatumMap();\n      for (let i = 0; i < (metadatum.asMap()?.getLength() ?? 0); i++) {\n        const key = metadatum.asMap()?.getKeys().get(i)!;\n        const value = metadatum.asMap()?.get(key)!;\n        map.insert(key, mask(value));\n      }\n      return Serialization.TransactionMetadatum.newMap(map);\n    default:\n      throw new Error(`Unsupported metadatum kind: ${metadatum.getKind()}`);\n  }\n}",
          "source": "mesh-transaction",
          "implementation": "function mask(\n  metadatum: Serialization.TransactionMetadatum,\n): Serialization.TransactionMetadatum {\n  switch (metadatum.getKind()) {\n    case Serialization.TransactionMetadatumKind.Text:\n      return Serialization.TransactionMetadatum.newText(\n        \"0\".repeat(metadatum.asText()?.length ?? 0),\n      );\n    case Serialization.TransactionMetadatumKind.Bytes:\n    case Serialization.TransactionMetadatumKind.Integer:\n      return metadatum;\n    case Serialization.TransactionMetadatumKind.List:\n      const list = new Serialization.MetadatumList();\n      for (let i = 0; i < (metadatum.asList()?.getLength() ?? 0); i++) {\n        list.add(mask(metadatum.asList()?.get(i)!));\n      }\n      return Serialization.TransactionMetadatum.newList(list);\n    case Serialization.TransactionMetadatumKind.Map:\n      const map = new Serialization.MetadatumMap();\n      for (let i = 0; i < (metadatum.asMap()?.getLength() ?? 0); i++) {\n        const key = metadatum.asMap()?.getKeys().get(i)!;\n        const value = metadatum.asMap()?.get(key)!;\n        map.insert(key, mask(value));\n      }\n      return Serialization.TransactionMetadatum.newMap(map);\n    default:\n      throw new Error(`Unsupported metadatum kind: ${metadatum.getKind()}`);\n  }\n}"
        }
      ],
      "types": [
        {
          "name": "TransactionOptions",
          "definition": "export interface TransactionOptions extends MeshTxBuilderOptions {\n  initiator: IInitiator;",
          "isPublic": true,
          "line": 39,
          "raw": "export interface TransactionOptions extends MeshTxBuilderOptions {",
          "source": "mesh-transaction"
        }
      ],
      "constants": [
        {
          "name": "tx",
          "type": "any",
          "value": "deserializeTx(cborTx);",
          "isPublic": true,
          "line": 57,
          "raw": "const tx = deserializeTx(cborTx);",
          "source": "mesh-transaction"
        },
        {
          "name": "txAuxData",
          "type": "any",
          "value": "tx.auxiliaryData() ?? new Serialization.AuxiliaryData();",
          "isPublic": true,
          "line": 58,
          "raw": "const txAuxData = tx.auxiliaryData() ?? new Serialization.AuxiliaryData();",
          "source": "mesh-transaction"
        },
        {
          "name": "tx",
          "type": "any",
          "value": "deserializeTx(cborTx);",
          "isPublic": true,
          "line": 79,
          "raw": "const tx = deserializeTx(cborTx);",
          "source": "mesh-transaction"
        },
        {
          "name": "tx",
          "type": "any",
          "value": "deserializeTx(cborTx);",
          "isPublic": true,
          "line": 84,
          "raw": "const tx = deserializeTx(cborTx);",
          "source": "mesh-transaction"
        },
        {
          "name": "txMetadata",
          "type": "any",
          "value": "tx.auxiliaryData()?.metadata();",
          "isPublic": true,
          "line": 85,
          "raw": "const txMetadata = tx.auxiliaryData()?.metadata();",
          "source": "mesh-transaction"
        },
        {
          "name": "mockMetadata",
          "type": "any",
          "value": "new Map<",
          "isPublic": true,
          "line": 88,
          "raw": "const mockMetadata = new Map<",
          "source": "mesh-transaction"
        },
        {
          "name": "txAuxData",
          "type": "any",
          "value": "tx.auxiliaryData();",
          "isPublic": true,
          "line": 97,
          "raw": "const txAuxData = tx.auxiliaryData();",
          "source": "mesh-transaction"
        },
        {
          "name": "tx",
          "type": "any",
          "value": "deserializeTx(cborTx);",
          "isPublic": true,
          "line": 107,
          "raw": "const tx = deserializeTx(cborTx);",
          "source": "mesh-transaction"
        },
        {
          "name": "tx",
          "type": "any",
          "value": "deserializeTx(cborTx);",
          "isPublic": true,
          "line": 112,
          "raw": "const tx = deserializeTx(cborTx);",
          "source": "mesh-transaction"
        },
        {
          "name": "txAuxData",
          "type": "any",
          "value": "tx.auxiliaryData() ?? new Serialization.AuxiliaryData();",
          "isPublic": true,
          "line": 113,
          "raw": "const txAuxData = tx.auxiliaryData() ?? new Serialization.AuxiliaryData();",
          "source": "mesh-transaction"
        },
        {
          "name": "assets",
          "type": "any",
          "value": "[{ unit: SUPPORTED_TOKENS[ticker], quantity: amount }];",
          "isPublic": true,
          "line": 198,
          "raw": "const assets = [{ unit: SUPPORTED_TOKENS[ticker], quantity: amount }];",
          "source": "mesh-transaction"
        },
        {
          "name": "assets",
          "type": "any",
          "value": "value.output.amount;",
          "isPublic": true,
          "line": 217,
          "raw": "const assets = value.output.amount;",
          "source": "mesh-transaction"
        },
        {
          "name": "red",
          "type": "any",
          "value": "redeemer || {",
          "isPublic": true,
          "line": 298,
          "raw": "const red = redeemer || {",
          "source": "mesh-transaction"
        },
        {
          "name": "scriptRef",
          "type": "any",
          "value": "fromScriptRef(script.output.scriptRef);",
          "isPublic": true,
          "line": 323,
          "raw": "const scriptRef = fromScriptRef(script.output.scriptRef);",
          "source": "mesh-transaction"
        },
        {
          "name": "assetQuantity",
          "type": "any",
          "value": "mint.assetQuantity;",
          "isPublic": true,
          "line": 372,
          "raw": "const assetQuantity = mint.assetQuantity;",
          "source": "mesh-transaction"
        },
        {
          "name": "referenceAssetNameHex",
          "type": "any",
          "value": "CIP68_100(assetNameHex);",
          "isPublic": true,
          "line": 374,
          "raw": "const referenceAssetNameHex = CIP68_100(assetNameHex);",
          "source": "mesh-transaction"
        },
        {
          "name": "script",
          "type": "any",
          "value": "fromScriptRef(forgeScript.output.scriptRef);",
          "isPublic": true,
          "line": 425,
          "raw": "const script = fromScriptRef(forgeScript.output.scriptRef);",
          "source": "mesh-transaction"
        },
        {
          "name": "assetQuantity",
          "type": "any",
          "value": "\"-\" + asset.quantity;",
          "isPublic": true,
          "line": 529,
          "raw": "const assetQuantity = \"-\" + asset.quantity;",
          "source": "mesh-transaction"
        },
        {
          "name": "mint",
          "type": "Mint",
          "value": "{",
          "isPublic": true,
          "line": 530,
          "raw": "const mint: Mint = {",
          "source": "mesh-transaction"
        },
        {
          "name": "collaterals",
          "type": "any",
          "value": "await this.initiator.getCollateral();",
          "isPublic": true,
          "line": 763,
          "raw": "const collaterals = await this.initiator.getCollateral();",
          "source": "mesh-transaction"
        },
        {
          "name": "utxos",
          "type": "any",
          "value": "await this.initiator.getUtxos();",
          "isPublic": true,
          "line": 768,
          "raw": "const utxos = await this.initiator.getUtxos();",
          "source": "mesh-transaction"
        },
        {
          "name": "pureLovelaceUtxos",
          "type": "any",
          "value": "utxos.filter(",
          "isPublic": true,
          "line": 769,
          "raw": "const pureLovelaceUtxos = utxos.filter(",
          "source": "mesh-transaction"
        },
        {
          "name": "utxos",
          "type": "any",
          "value": "await this.initiator.getUtxos();",
          "isPublic": true,
          "line": 795,
          "raw": "const utxos = await this.initiator.getUtxos();",
          "source": "mesh-transaction"
        },
        {
          "name": "changeAddress",
          "type": "any",
          "value": "await this.initiator.getChangeAddress();",
          "isPublic": true,
          "line": 802,
          "raw": "const changeAddress = await this.initiator.getChangeAddress();",
          "source": "mesh-transaction"
        },
        {
          "name": "list",
          "type": "any",
          "value": "new Serialization.MetadatumList();",
          "isPublic": true,
          "line": 820,
          "raw": "const list = new Serialization.MetadatumList();",
          "source": "mesh-transaction"
        },
        {
          "name": "map",
          "type": "any",
          "value": "new Serialization.MetadatumMap();",
          "isPublic": true,
          "line": 826,
          "raw": "const map = new Serialization.MetadatumMap();",
          "source": "mesh-transaction"
        },
        {
          "name": "key",
          "type": "any",
          "value": "metadatum.asMap()?.getKeys().get(i)!;",
          "isPublic": true,
          "line": 828,
          "raw": "const key = metadatum.asMap()?.getKeys().get(i)!;",
          "source": "mesh-transaction"
        },
        {
          "name": "value",
          "type": "any",
          "value": "metadatum.asMap()?.get(key)!;",
          "isPublic": true,
          "line": 829,
          "raw": "const value = metadatum.asMap()?.get(key)!;",
          "source": "mesh-transaction"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  Action,\n  Asset,\n  Budget,\n  CIP68_100,\n  CIP68_222,\n  Data,\n  DEFAULT_REDEEMER_BUDGET,\n  hexToString,\n  IInitiator,\n  metadataToCip68,\n  Metadatum,\n  Mint,\n  NativeScript,\n  Network,\n  PlutusScript,\n  POLICY_ID_LENGTH,\n  PoolParams,\n  Recipient,\n  stringToHex,\n  SUPPORTED_TOKENS,\n  Token,\n  UTxO,\n} from \"@meshsdk/common\";\nimport {\n  Cardano,\n  CardanoSDKUtil,\n  deserializeNativeScript,\n  deserializePlutusScript,\n  deserializeTx,\n  fromScriptRef,\n  Serialization,\n  Transaction as Tx,\n} from \"@meshsdk/core-cst\";\n\nimport { MeshTxBuilder, MeshTxBuilderOptions } from \"../mesh-tx-builder\";\nimport { mergeContents, metadataObjToMap } from \"../utils\";\n\nexport interface TransactionOptions extends MeshTxBuilderOptions {\n  initiator: IInitiator;\n}\n\n/**\n * Deprecated - Use `MeshTxBuilder` instead\n */\nexport class Transaction {\n  txBuilder: MeshTxBuilder;\n  initiator: IInitiator;\n  isCollateralNeeded: boolean = false;\n\n  constructor(options: TransactionOptions) {\n    this.txBuilder = new MeshTxBuilder(options);\n    this.initiator = options.initiator;\n  }\n\n  static attachMetadata(cborTx: string, cborTxMetadata: string) {\n    const tx = deserializeTx(cborTx);\n    const txAuxData = tx.auxiliaryData() ?? new Serialization.AuxiliaryData();\n\n    txAuxData.setMetadata(\n      Serialization.GeneralTransactionMetadata.fromCbor(\n        CardanoSDKUtil.HexBlob(cborTxMetadata),\n      ),\n    );\n\n    if (\n      Cardano.computeAuxiliaryDataHash(txAuxData.toCore())?.toString() !==\n      tx.body().auxiliaryDataHash()?.toString()\n    ) {\n      throw new Error(\n        \"[Transaction] attachMetadata: The metadata hash does not match the auxiliary data hash.\",\n      );\n    }\n\n    return new Tx(tx.body(), tx.witnessSet(), txAuxData).toCbor().toString();\n  }\n\n  static deattachMetadata(cborTx: string) {\n    const tx = deserializeTx(cborTx);\n    return new Tx(tx.body(), tx.witnessSet()).toCbor().toString();\n  }\n\n  static maskMetadata(cborTx: string) {\n    const tx = deserializeTx(cborTx);\n    const txMetadata = tx.auxiliaryData()?.metadata();\n\n    if (txMetadata !== undefined) {\n      const mockMetadata = new Map<\n        bigint,\n        Serialization.TransactionMetadatum\n      >();\n      txMetadata\n        .metadata()\n        ?.forEach((metadatum, label) =>\n          mockMetadata.set(label, mask(metadatum)),\n        );\n      const txAuxData = tx.auxiliaryData();\n      txMetadata.setMetadata(mockMetadata);\n      txAuxData?.setMetadata(txMetadata);\n      return new Tx(tx.body(), tx.witnessSet(), txAuxData).toCbor().toString();\n    }\n\n    return cborTx;\n  }\n\n  static readMetadata(cborTx: string) {\n    const tx = deserializeTx(cborTx);\n    return tx.auxiliaryData()?.metadata()?.toCbor().toString() ?? \"\";\n  }\n\n  static writeMetadata(cborTx: string, cborTxMetadata: string) {\n    const tx = deserializeTx(cborTx);\n    const txAuxData = tx.auxiliaryData() ?? new Serialization.AuxiliaryData();\n\n    txAuxData.setMetadata(\n      Serialization.GeneralTransactionMetadata.fromCbor(\n        CardanoSDKUtil.HexBlob(cborTxMetadata),\n      ),\n    );\n\n    return new Tx(tx.body(), tx.witnessSet(), txAuxData).toCbor().toString();\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * @param recipient The recipient of the output.\n   * @param assets The assets to send. Provide string for lovelace and Asset[] for tokens and/or lovelace.\n   * @returns The transaction builder.\n   * @see {@link https://meshjs.dev/apis/transaction#sendAssets}\n   */\n  sendAssets(recipient: Recipient, assets: Asset[] | string): Transaction {\n    if (typeof assets === \"string\") {\n      assets = [\n        {\n          unit: \"lovelace\",\n          quantity: assets,\n        },\n      ];\n    }\n    if (typeof recipient === \"string\") {\n      this.txBuilder.txOut(recipient, assets);\n    }\n    if (typeof recipient === \"object\") {\n      this.txBuilder.txOut(recipient.address, assets);\n      if (recipient.datum) {\n        if (recipient.datum.inline) {\n          this.txBuilder.txOutInlineDatumValue(recipient.datum.value);\n        } else {\n          this.txBuilder.txOutDatumHashValue(recipient.datum.value);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Use sendAssets instead:\n   * ```ts\n   * this.sendAssets(recipient, lovelace);\n   * ```\n   *\n   * Deprecation reason - Unnecessary implementation which might cause confusion.\n   *\n   * @param {Recipient} recipient The recipient of the transaction.\n   * @param {string} lovelace The amount of lovelace to send.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#sendAda}\n   */\n  sendLovelace(recipient: Recipient, lovelace: string): Transaction {\n    return this.sendAssets(recipient, lovelace);\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Please use sendAssets with helper function to obtain token unit instead:\n   * ```ts\n   * const assets = [{ unit: SUPPORTED_TOKENS.GIMBAL, quantity: \"100\" }]\n   * transaction.sendAssets(recipient, assets)\n   * ```\n   *\n   * Deprecation reason - Required maintenance on tokens.\n   *\n   * @param {Recipient} recipient The recipient of the transaction.\n   * @param {Token} ticker The ticker of the token to send.\n   * @param {string} amount The amount of the token to send.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#sendToken}\n   */\n  sendToken(recipient: Recipient, ticker: Token, amount: string): Transaction {\n    const assets = [{ unit: SUPPORTED_TOKENS[ticker], quantity: amount }];\n    return this.sendAssets(recipient, assets);\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * ```ts\n   * const assets = value.output.amount;\n   * this.sendAssets(recipient, assets);\n   * ```\n   * Deprecation reason - Unnecessary implementation which might cause confusion.\n   *\n   * @param {Recipient} recipient The recipient of the output.\n   * @param {UTxO} value The UTxO value of the output.\n   * @returns {Transaction} The Transaction object.\n   */\n  sendValue(recipient: Recipient, value: UTxO): Transaction {\n    const assets = value.output.amount;\n    return this.sendAssets(recipient, assets);\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * @param {UTxO[]} inputs The inputs to set.\n   * @returns {Transaction} The transaction.\n   */\n  setTxInputs(inputs: UTxO[]): Transaction {\n    inputs.forEach((input) => {\n      this.txBuilder.txIn(\n        input.input.txHash,\n        input.input.outputIndex,\n        input.output.amount,\n        input.output.address,\n        input.output.scriptRef ? input.output.scriptRef.length / 2 : 0,\n      );\n    });\n\n    return this;\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * @param {UTxO[]} inputs The reference inputs to set.\n   * @returns {Transaction} The transaction.\n   */\n  setTxRefInputs(inputs: UTxO[]): Transaction {\n    inputs.forEach((input) => {\n      this.txBuilder.readOnlyTxInReference(\n        input.input.txHash,\n        input.input.outputIndex,\n      );\n    });\n\n    return this;\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the native script for the transaction.\n   * @param {NativeScript} script The native script to spend from.\n   * @param {UTxO} utxo The UTxO attached to the script.\n   * @returns {Transaction} The Transaction object.\n   */\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): Transaction {\n    const { scriptCbor } =\n      this.txBuilder.serializer.deserializer.script.deserializeNativeScript(\n        script,\n      );\n    this.txBuilder\n      .txIn(\n        utxo.input.txHash,\n        utxo.input.outputIndex,\n        utxo.output.amount,\n        utxo.output.address,\n      )\n      .txInScript(scriptCbor!);\n\n    return this;\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  // TODO: nuke this probably as the input type is too confusing\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): Transaction {\n    const { value, script, datum, redeemer } = options;\n    const red = redeemer || {\n      data: { alternative: 0, fields: [\"mesh\"] },\n      budget: DEFAULT_REDEEMER_BUDGET,\n    };\n\n    if (\"code\" in script) {\n      // Provided script for redemption\n      this.isCollateralNeeded = true;\n      this.spendingPlutusScript(script)\n        .txIn(\n          value.input.txHash,\n          value.input.outputIndex,\n          value.output.amount,\n          value.output.address,\n          value.output.scriptRef ? value.output.scriptRef.length / 2 : 0,\n        )\n        .txInScript(script.code)\n        .txInRedeemerValue(red.data, \"Mesh\", red.budget);\n    }\n\n    if (\"output\" in script) {\n      // Reference script for redemption\n      if (!script.output.scriptRef) {\n        throw new Error(\"redeemValue: No script reference found in UTxO\");\n      }\n      const scriptRef = fromScriptRef(script.output.scriptRef);\n      if (!scriptRef || !(\"code\" in scriptRef)) {\n        throw new Error(\"redeemValue: Script reference not found\");\n      }\n\n      this.isCollateralNeeded = true;\n      this.spendingPlutusScript(scriptRef)\n        .txIn(\n          value.input.txHash,\n          value.input.outputIndex,\n          value.output.amount,\n          value.output.address,\n        )\n        .spendingTxInReference(\n          script.input.txHash,\n          script.input.outputIndex,\n          (script.output.scriptRef.length / 2).toString(),\n          script.output.scriptHash,\n        )\n        .txInRedeemerValue(red.data, \"Mesh\", red.budget);\n    }\n\n    if (datum) {\n      // Provided datum for redemption\n      this.txBuilder.txInDatumValue(datum);\n    } else {\n      // Reference datum for redemption\n      this.txBuilder.txInInlineDatumPresent();\n    }\n    // if (typeof datum === \"object\" && \"output\" in datum) {\n    //   // Reference datum for redemption\n    // } else {\n    //   // Provided datum for redemption\n    //   if (datum) {\n    //   }\n    // }\n\n    return this;\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  mintAsset(\n    forgeScript: string | PlutusScript | UTxO,\n    mint: Mint,\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget },\n  ): Transaction {\n    const assetQuantity = mint.assetQuantity;\n    let assetNameHex = stringToHex(mint.assetName);\n    const referenceAssetNameHex = CIP68_100(assetNameHex);\n    if (mint.cip68ScriptAddress) {\n      assetNameHex = CIP68_222(assetNameHex);\n    }\n    let policyId = \"\";\n    switch (typeof forgeScript) {\n      case \"string\":\n        policyId = deserializeNativeScript(forgeScript).hash().toString();\n        this.txBuilder\n          .mint(assetQuantity, policyId, assetNameHex)\n          .mintingScript(forgeScript);\n        if (mint.cip68ScriptAddress) {\n          this.txBuilder\n            .mint(assetQuantity, policyId, referenceAssetNameHex)\n            .mintingScript(forgeScript);\n        }\n\n        break;\n\n      case \"object\":\n        if (!redeemer)\n          throw new Error(\n            \"burnAsset: Redeemer data is required for Plutus minting\",\n          );\n        if (\"code\" in forgeScript) {\n          // Burn plutus script assets with provided script\n          policyId = deserializePlutusScript(\n            forgeScript.code,\n            forgeScript.version,\n          )\n            .hash()\n            .toString();\n\n          this.isCollateralNeeded = true;\n          this.mintPlutusScript(forgeScript)\n            .mint(assetQuantity, policyId, assetNameHex)\n            .mintingScript(forgeScript.code)\n            .mintRedeemerValue(redeemer.data, \"Mesh\", redeemer.budget);\n          if (mint.cip68ScriptAddress) {\n            this.mintPlutusScript(forgeScript)\n              .mint(assetQuantity, policyId, referenceAssetNameHex)\n              .mintingScript(forgeScript.code)\n              .mintRedeemerValue(redeemer.data, \"Mesh\", redeemer.budget);\n          }\n          break;\n        }\n        if (\"output\" in forgeScript) {\n          // Burn plutus script assets with reference script\n          if (!forgeScript.output.scriptRef) {\n            throw new Error(\"mintAsset: No script reference found in UTxO\");\n          }\n          const script = fromScriptRef(forgeScript.output.scriptRef);\n          if (!script) {\n            throw new Error(\"mintAsset: Script reference not found\");\n          }\n\n          if (\"code\" in script) {\n            policyId = deserializePlutusScript(script.code, script.version)\n              .hash()\n              .toString();\n\n            this.isCollateralNeeded = true;\n            this.mintPlutusScript(script)\n              .mint(assetQuantity, policyId, assetNameHex)\n              .mintTxInReference(\n                forgeScript.input.txHash,\n                forgeScript.input.outputIndex,\n                (forgeScript.output.scriptRef.length / 2).toString(),\n                forgeScript.output.scriptHash,\n              )\n              .mintRedeemerValue(redeemer.data, \"Mesh\", redeemer.budget);\n            if (mint.cip68ScriptAddress) {\n              this.mintPlutusScript(script)\n                .mint(assetQuantity, policyId, referenceAssetNameHex)\n                .mintTxInReference(\n                  forgeScript.input.txHash,\n                  forgeScript.input.outputIndex,\n                  (forgeScript.output.scriptRef.length / 2).toString(),\n                  forgeScript.output.scriptHash,\n                )\n                .mintRedeemerValue(redeemer.data, \"Mesh\", redeemer.budget);\n              break;\n            }\n\n            break;\n          } else {\n            // TODO: to implement reference script minting for native script tokens\n            throw new Error(\n              \"mintAsset: Reference script minting not implemented\",\n            );\n            // this.txBuilder\n            //   .mint(assetQuantity, policyId, assetName)\n            //   .mintTxInReference(\n            //     forgeScript.input.txHash,\n            //     forgeScript.input.outputIndex\n            //   );\n          }\n        }\n        break;\n    }\n\n    if (mint.recipient) {\n      this.sendAssets(mint.recipient, [\n        { unit: policyId + assetNameHex, quantity: mint.assetQuantity },\n      ]);\n    }\n    if (mint.cip68ScriptAddress) {\n      this.sendAssets(\n        {\n          address: mint.cip68ScriptAddress,\n          datum: { inline: true, value: metadataToCip68(mint.metadata) },\n        },\n        [\n          {\n            unit: policyId + referenceAssetNameHex,\n            quantity: mint.assetQuantity,\n          },\n        ],\n      );\n    }\n    if (!mint.cip68ScriptAddress && mint.metadata && mint.label) {\n      if (mint.label === \"721\" || mint.label === \"20\") {\n        let currentMetadata = this.txBuilder.meshTxBuilderBody.metadata;\n        if (currentMetadata.get(BigInt(mint.label)) === undefined) {\n          this.setMetadata(Number(mint.label), {\n            [policyId]: { [mint.assetName]: mint.metadata },\n          });\n        } else {\n          let metadataMap = metadataObjToMap({\n            [policyId]: { [mint.assetName]: mint.metadata },\n          } as object);\n          let newMetadata = mergeContents(\n            currentMetadata.get(BigInt(mint.label)) as Metadatum,\n            metadataMap,\n            mint.label === \"721\" ? 2 : 0,\n          );\n          this.setMetadata(Number(mint.label), newMetadata);\n        }\n      } else {\n        this.setMetadata(Number(mint.label), mint.metadata);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  burnAsset(\n    forgeScript: string | PlutusScript | UTxO,\n    asset: Asset,\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget },\n  ): Transaction {\n    const assetQuantity = \"-\" + asset.quantity;\n    const mint: Mint = {\n      assetName: hexToString(asset.unit.slice(POLICY_ID_LENGTH)),\n      assetQuantity: assetQuantity,\n    };\n    try {\n      this.mintAsset(forgeScript, mint, redeemer);\n    } catch (error) {\n      throw new Error(\"burnAsset: \" + error);\n    }\n\n    return this;\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the change address for the transaction.\n   *\n   * @param {string} changeAddress The change address.\n   * @returns {Transaction} The Transaction object.\n   */\n  setChangeAddress(changeAddress: string): Transaction {\n    this.txBuilder.changeAddress(changeAddress);\n    return this;\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the collateral for the transaction.\n   *\n   * @param {UTxO[]} collateral - Set the UTxO for collateral.\n   * @returns {Transaction} The Transaction object.\n   */\n  setCollateral(collateral: UTxO[]): Transaction {\n    collateral.forEach((collateralUtxo) => {\n      this.txBuilder.txInCollateral(\n        collateralUtxo.input.txHash,\n        collateralUtxo.input.outputIndex,\n        collateralUtxo.output.amount,\n        collateralUtxo.output.address,\n      );\n    });\n\n    return this;\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the network to use, this is mainly to know the cost models to be used to calculate script integrity hash\n   * @param network The specific network this transaction is being built for (\"testnet\" | \"preview\" | \"preprod\" | \"mainnet\")\n   * @returns The Transaction object.\n   */\n  setNetwork = (network: Network) => {\n    this.txBuilder.setNetwork(network);\n    return this;\n  };\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the required signers for the transaction.\n   *\n   * @param {string[]} addresses The addresses of the required signers.\n   * @returns {Transaction} The Transaction object.\n   */\n  setRequiredSigners(addresses: string[]): Transaction {\n    addresses.forEach((address) => {\n      const { pubKeyHash } =\n        this.txBuilder.serializer.deserializer.key.deserializeAddress(address);\n      this.txBuilder.requiredSignerHash(pubKeyHash);\n    });\n\n    return this;\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   *  Set the time to live for the transaction.\n   *\n   * @param {string} slot The slot number to expire the transaction at.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#setTimeLimit}\n   */\n  setTimeToExpire(slot: string): Transaction {\n    this.txBuilder.invalidHereafter(Number(slot));\n    return this;\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   *  Sets the start slot for the transaction.\n   *\n   * @param {string} slot The start slot for the transaction.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#setTimeLimit}\n   */\n  setTimeToStart(slot: string): Transaction {\n    this.txBuilder.invalidBefore(Number(slot));\n    return this;\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   *  Add a JSON metadata entry to the transaction.\n   *\n   * @param {number} label The label to use for the metadata entry.\n   * @param {unknown} metadata The value to use for the metadata entry.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#setMetadata}\n   */\n  setMetadata(label: number, metadata: Metadatum | object): Transaction {\n    this.txBuilder.metadataValue(label, metadata);\n    return this;\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  withdrawRewards(rewardAddress: string, lovelace: string): Transaction {\n    this.txBuilder.withdrawal(rewardAddress, lovelace);\n    return this;\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  delegateStake(rewardAddress: string, poolId: string): Transaction {\n    this.txBuilder.delegateStakeCertificate(\n      rewardAddress,\n      this.txBuilder.serializer.deserializer.cert.deserializePoolId(poolId),\n    );\n    return this;\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  deregisterStake(rewardAddress: string): Transaction {\n    this.txBuilder.deregisterStakeCertificate(rewardAddress);\n    return this;\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  registerStake(rewardAddress: string): Transaction {\n    this.txBuilder.registerStakeCertificate(rewardAddress);\n    return this;\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  registerPool(params: PoolParams): Transaction {\n    this.txBuilder.registerPoolCertificate(params);\n    return this;\n  }\n\n  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  retirePool(poolId: string, epochNo: number): Transaction {\n    this.txBuilder.retirePoolCertificate(poolId, epochNo);\n    return this;\n  }\n\n  async build(balanced: Boolean = true): Promise<string> {\n    try {\n      await this.addCollateralIfNeeded();\n      await this.addTxInputsAsNeeded();\n      await this.addChangeAddress();\n      if (balanced) {\n        return this.txBuilder.complete();\n      } else {\n        return this.txBuilder.completeUnbalanced();\n      }\n    } catch (error) {\n      throw new Error(\n        `[Transaction] An error occurred during build: ${error}.`,\n      );\n    }\n  }\n\n  protected mintPlutusScript(script: PlutusScript) {\n    switch (script.version) {\n      case \"V1\":\n        this.txBuilder.mintPlutusScriptV1();\n        break;\n      case \"V2\":\n        this.txBuilder.mintPlutusScriptV2();\n        break;\n      case \"V3\":\n        this.txBuilder.mintPlutusScriptV3();\n        break;\n    }\n    return this.txBuilder;\n  }\n\n  protected spendingPlutusScript(script: PlutusScript) {\n    switch (script.version) {\n      case \"V1\":\n        this.txBuilder.spendingPlutusScriptV1();\n        break;\n      case \"V2\":\n        this.txBuilder.spendingPlutusScriptV2();\n        break;\n      case \"V3\":\n        this.txBuilder.spendingPlutusScriptV3();\n        break;\n    }\n    return this.txBuilder;\n  }\n\n  private async addCollateralIfNeeded() {\n    if (this.isCollateralNeeded) {\n      const collaterals = await this.initiator.getCollateral();\n      if (collaterals.length > 0) {\n        this.setCollateral(collaterals);\n        return;\n      }\n      const utxos = await this.initiator.getUtxos();\n      const pureLovelaceUtxos = utxos.filter(\n        (utxo) => utxo.output.amount.length === 1,\n      );\n\n      pureLovelaceUtxos.sort((a, b) => {\n        return (\n          Number(a.output.amount[0]?.quantity!) -\n          Number(a.output.amount[0]?.quantity!)\n        );\n      });\n\n      for (const utxo of pureLovelaceUtxos) {\n        if (Number(utxo.output.amount[0]?.quantity!) >= 5000000) {\n          return [utxo];\n        }\n      }\n\n      if (pureLovelaceUtxos.length === 0) {\n        throw new Error(\"No pure lovelace utxos found for collateral\");\n      }\n      this.setCollateral([pureLovelaceUtxos[0]!]);\n    }\n  }\n\n  private async addTxInputsAsNeeded() {\n    if (this.txBuilder.meshTxBuilderBody.extraInputs.length === 0) {\n      const utxos = await this.initiator.getUtxos();\n      this.txBuilder.selectUtxosFrom(utxos);\n    }\n  }\n\n  private async addChangeAddress() {\n    if (this.txBuilder.meshTxBuilderBody.changeAddress === \"\") {\n      const changeAddress = await this.initiator.getChangeAddress();\n      this.setChangeAddress(changeAddress);\n    }\n  }\n}\n\nfunction mask(\n  metadatum: Serialization.TransactionMetadatum,\n): Serialization.TransactionMetadatum {\n  switch (metadatum.getKind()) {\n    case Serialization.TransactionMetadatumKind.Text:\n      return Serialization.TransactionMetadatum.newText(\n        \"0\".repeat(metadatum.asText()?.length ?? 0),\n      );\n    case Serialization.TransactionMetadatumKind.Bytes:\n    case Serialization.TransactionMetadatumKind.Integer:\n      return metadatum;\n    case Serialization.TransactionMetadatumKind.List:\n      const list = new Serialization.MetadatumList();\n      for (let i = 0; i < (metadatum.asList()?.getLength() ?? 0); i++) {\n        list.add(mask(metadatum.asList()?.get(i)!));\n      }\n      return Serialization.TransactionMetadatum.newList(list);\n    case Serialization.TransactionMetadatumKind.Map:\n      const map = new Serialization.MetadatumMap();\n      for (let i = 0; i < (metadatum.asMap()?.getLength() ?? 0); i++) {\n        const key = metadatum.asMap()?.getKeys().get(i)!;\n        const value = metadatum.asMap()?.get(key)!;\n        map.insert(key, mask(value));\n      }\n      return Serialization.TransactionMetadatum.newMap(map);\n    default:\n      throw new Error(`Unsupported metadatum kind: ${metadatum.getKind()}`);\n  }\n}\n",
      "dependencies": [
        "TransactionOptions",
        "Transaction"
      ],
      "source": "mesh-transaction",
      "isReExportFile": false
    },
    {
      "key": "mesh-transaction:transaction.transaction-v2.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/transaction/transaction-v2.ts",
      "name": "transaction.transaction-v2.ts",
      "imports": [
        {
          "module": "TransactionV2",
          "items": [],
          "line": 17,
          "raw": "export interface TransactionV2 {",
          "source": "mesh-transaction"
        }
      ],
      "functions": [
        {
          "name": "sendLovelace",
          "signature": "sendLovelace(recipient: Recipient, lovelace: string): this;",
          "documentation": "",
          "parameters": [
            {
              "name": "recipient",
              "type": "Recipient",
              "optional": false
            },
            {
              "name": "lovelace",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "this;",
          "isPublic": true,
          "line": 25,
          "raw": "  sendLovelace(recipient: Recipient, lovelace: string): this;\n  sendToken(recipient: Recipient, ticker: Token, amount: string): this;\n  sendValue(recipient: Recipient, value: UTxO): this;\n  setTxInputs(inputs: UTxO[]): this;\n  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;",
          "source": "mesh-transaction",
          "implementation": "  sendLovelace(recipient: Recipient, lovelace: string): this;\n  sendToken(recipient: Recipient, ticker: Token, amount: string): this;\n  sendValue(recipient: Recipient, value: UTxO): this;\n  setTxInputs(inputs: UTxO[]): this;\n  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;"
        },
        {
          "name": "sendToken",
          "signature": "sendToken(recipient: Recipient, ticker: Token, amount: string): this;",
          "documentation": "",
          "parameters": [
            {
              "name": "recipient",
              "type": "Recipient",
              "optional": false
            },
            {
              "name": "ticker",
              "type": "Token",
              "optional": false
            },
            {
              "name": "amount",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "this;",
          "isPublic": true,
          "line": 26,
          "raw": "  sendToken(recipient: Recipient, ticker: Token, amount: string): this;\n  sendValue(recipient: Recipient, value: UTxO): this;\n  setTxInputs(inputs: UTxO[]): this;\n  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;",
          "source": "mesh-transaction",
          "implementation": "  sendToken(recipient: Recipient, ticker: Token, amount: string): this;\n  sendValue(recipient: Recipient, value: UTxO): this;\n  setTxInputs(inputs: UTxO[]): this;\n  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;"
        },
        {
          "name": "sendValue",
          "signature": "sendValue(recipient: Recipient, value: UTxO): this;",
          "documentation": "",
          "parameters": [
            {
              "name": "recipient",
              "type": "Recipient",
              "optional": false
            },
            {
              "name": "value",
              "type": "UTxO",
              "optional": false
            }
          ],
          "returnType": "this;",
          "isPublic": true,
          "line": 27,
          "raw": "  sendValue(recipient: Recipient, value: UTxO): this;\n  setTxInputs(inputs: UTxO[]): this;\n  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;",
          "source": "mesh-transaction",
          "implementation": "  sendValue(recipient: Recipient, value: UTxO): this;\n  setTxInputs(inputs: UTxO[]): this;\n  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;"
        },
        {
          "name": "setTxInputs",
          "signature": "setTxInputs(inputs: UTxO[]): this;",
          "documentation": "",
          "parameters": [
            {
              "name": "inputs",
              "type": "UTxO[]",
              "optional": false
            }
          ],
          "returnType": "this;",
          "isPublic": true,
          "line": 28,
          "raw": "  setTxInputs(inputs: UTxO[]): this;\n  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;",
          "source": "mesh-transaction",
          "implementation": "  setTxInputs(inputs: UTxO[]): this;\n  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;"
        },
        {
          "name": "setTxRefInputs",
          "signature": "setTxRefInputs(inputs: UTxO[]): this;",
          "documentation": "",
          "parameters": [
            {
              "name": "inputs",
              "type": "UTxO[]",
              "optional": false
            }
          ],
          "returnType": "this;",
          "isPublic": true,
          "line": 29,
          "raw": "  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;",
          "source": "mesh-transaction",
          "implementation": "  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;"
        },
        {
          "name": "setNativeScriptInput",
          "signature": "setNativeScriptInput(script: NativeScript, utxo: UTxO): this;",
          "documentation": "",
          "parameters": [
            {
              "name": "script",
              "type": "NativeScript",
              "optional": false
            },
            {
              "name": "utxo",
              "type": "UTxO",
              "optional": false
            }
          ],
          "returnType": "this;",
          "isPublic": true,
          "line": 30,
          "raw": "  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;",
          "source": "mesh-transaction",
          "implementation": "  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;"
        },
        {
          "name": "setChangeAddress",
          "signature": "setChangeAddress(changeAddress: string): this;",
          "documentation": "",
          "parameters": [
            {
              "name": "changeAddress",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "this;",
          "isPublic": true,
          "line": 47,
          "raw": "  setChangeAddress(changeAddress: string): this;",
          "source": "mesh-transaction",
          "implementation": "  setChangeAddress(changeAddress: string): this;"
        },
        {
          "name": "setCollateral",
          "signature": "setCollateral(collateral: UTxO[]): this;",
          "documentation": "",
          "parameters": [
            {
              "name": "collateral",
              "type": "UTxO[]",
              "optional": false
            }
          ],
          "returnType": "this;",
          "isPublic": true,
          "line": 48,
          "raw": "  setCollateral(collateral: UTxO[]): this;",
          "source": "mesh-transaction",
          "implementation": "  setCollateral(collateral: UTxO[]): this;"
        },
        {
          "name": "setRequiredSigners",
          "signature": "setRequiredSigners(addresses: string[]): this;",
          "documentation": "",
          "parameters": [
            {
              "name": "addresses",
              "type": "string[]",
              "optional": false
            }
          ],
          "returnType": "this;",
          "isPublic": true,
          "line": 49,
          "raw": "  setRequiredSigners(addresses: string[]): this;",
          "source": "mesh-transaction",
          "implementation": "  setRequiredSigners(addresses: string[]): this;"
        },
        {
          "name": "setTimeToExpire",
          "signature": "setTimeToExpire(slot: string): this;",
          "documentation": "",
          "parameters": [
            {
              "name": "slot",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "this;",
          "isPublic": true,
          "line": 50,
          "raw": "  setTimeToExpire(slot: string): this;",
          "source": "mesh-transaction",
          "implementation": "  setTimeToExpire(slot: string): this;"
        },
        {
          "name": "setTimeToStart",
          "signature": "setTimeToStart(slot: string): this;",
          "documentation": "",
          "parameters": [
            {
              "name": "slot",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "this;",
          "isPublic": true,
          "line": 51,
          "raw": "  setTimeToStart(slot: string): this;",
          "source": "mesh-transaction",
          "implementation": "  setTimeToStart(slot: string): this;"
        },
        {
          "name": "withdrawRewards",
          "signature": "withdrawRewards(rewardAddress: string, lovelace: string): this;",
          "documentation": "",
          "parameters": [
            {
              "name": "rewardAddress",
              "type": "string",
              "optional": false
            },
            {
              "name": "lovelace",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "this;",
          "isPublic": true,
          "line": 56,
          "raw": "  withdrawRewards(rewardAddress: string, lovelace: string): this;",
          "source": "mesh-transaction",
          "implementation": "  withdrawRewards(rewardAddress: string, lovelace: string): this;"
        },
        {
          "name": "delegateStake",
          "signature": "delegateStake(rewardAddress: string, poolId: string): this;",
          "documentation": "",
          "parameters": [
            {
              "name": "rewardAddress",
              "type": "string",
              "optional": false
            },
            {
              "name": "poolId",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "this;",
          "isPublic": true,
          "line": 57,
          "raw": "  delegateStake(rewardAddress: string, poolId: string): this;",
          "source": "mesh-transaction",
          "implementation": "  delegateStake(rewardAddress: string, poolId: string): this;"
        },
        {
          "name": "deregisterStake",
          "signature": "deregisterStake(rewardAddress: string): this;",
          "documentation": "",
          "parameters": [
            {
              "name": "rewardAddress",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "this;",
          "isPublic": true,
          "line": 58,
          "raw": "  deregisterStake(rewardAddress: string): this;",
          "source": "mesh-transaction",
          "implementation": "  deregisterStake(rewardAddress: string): this;"
        },
        {
          "name": "registerStake",
          "signature": "registerStake(rewardAddress: string): this;",
          "documentation": "",
          "parameters": [
            {
              "name": "rewardAddress",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "this;",
          "isPublic": true,
          "line": 59,
          "raw": "  registerStake(rewardAddress: string): this;",
          "source": "mesh-transaction",
          "implementation": "  registerStake(rewardAddress: string): this;"
        },
        {
          "name": "registerPool",
          "signature": "registerPool(params: PoolParams): this;",
          "documentation": "",
          "parameters": [
            {
              "name": "params",
              "type": "PoolParams",
              "optional": false
            }
          ],
          "returnType": "this;",
          "isPublic": true,
          "line": 60,
          "raw": "  registerPool(params: PoolParams): this;",
          "source": "mesh-transaction",
          "implementation": "  registerPool(params: PoolParams): this;"
        },
        {
          "name": "retirePool",
          "signature": "retirePool(poolId: string, epochNo: number): this;",
          "documentation": "",
          "parameters": [
            {
              "name": "poolId",
              "type": "string",
              "optional": false
            },
            {
              "name": "epochNo",
              "type": "number",
              "optional": false
            }
          ],
          "returnType": "this;",
          "isPublic": true,
          "line": 61,
          "raw": "  retirePool(poolId: string, epochNo: number): this;",
          "source": "mesh-transaction",
          "implementation": "  retirePool(poolId: string, epochNo: number): this;"
        },
        {
          "name": "spendUtxo",
          "signature": "spendUtxo(utxo: UTxO, redeemer?: Data): this;",
          "documentation": "",
          "parameters": [
            {
              "name": "utxo",
              "type": "UTxO",
              "optional": false
            },
            {
              "name": "redeemer",
              "type": "Data",
              "optional": true
            }
          ],
          "returnType": "this;",
          "isPublic": true,
          "line": 62,
          "raw": "  spendUtxo(utxo: UTxO, redeemer?: Data): this;",
          "source": "mesh-transaction",
          "implementation": "  spendUtxo(utxo: UTxO, redeemer?: Data): this;"
        }
      ],
      "types": [
        {
          "name": "TransactionV2",
          "definition": "export interface TransactionV2 {\n  sendAssets(\n    receiver: string,\n    assets: Asset[],\n    datum?: Data,\n    inlineScript?: string,\n    isInline?: boolean,\n  ): this;",
          "isPublic": true,
          "line": 17,
          "raw": "export interface TransactionV2 {",
          "source": "mesh-transaction"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  Action,\n  Asset,\n  Budget,\n  Data,\n  Mint,\n  NativeScript,\n  PlutusScript,\n  PoolParams,\n  Recipient,\n  Token,\n  UTxO,\n} from \"@meshsdk/common\";\n\nimport type { MetadataMergeLevel } from \"../utils/metadata\";\n\nexport interface TransactionV2 {\n  sendAssets(\n    receiver: string,\n    assets: Asset[],\n    datum?: Data,\n    inlineScript?: string,\n    isInline?: boolean,\n  ): this;\n  sendLovelace(recipient: Recipient, lovelace: string): this;\n  sendToken(recipient: Recipient, ticker: Token, amount: string): this;\n  sendValue(recipient: Recipient, value: UTxO): this;\n  setTxInputs(inputs: UTxO[]): this;\n  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;\n  mintAsset(\n    forgeScript: string | PlutusScript | UTxO,\n    mint: Mint,\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget },\n  ): this;\n  burnAsset(\n    forgeScript: string | PlutusScript | UTxO,\n    asset: Asset,\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget },\n  ): this;\n  setChangeAddress(changeAddress: string): this;\n  setCollateral(collateral: UTxO[]): this;\n  setRequiredSigners(addresses: string[]): this;\n  setTimeToExpire(slot: string): this;\n  setTimeToStart(slot: string): this;\n  setMetadata(\n    label: number,\n    metadata: unknown\n  ): this;\n  withdrawRewards(rewardAddress: string, lovelace: string): this;\n  delegateStake(rewardAddress: string, poolId: string): this;\n  deregisterStake(rewardAddress: string): this;\n  registerStake(rewardAddress: string): this;\n  registerPool(params: PoolParams): this;\n  retirePool(poolId: string, epochNo: number): this;\n  spendUtxo(utxo: UTxO, redeemer?: Data): this;\n}\n",
      "dependencies": [
        "TransactionV2"
      ],
      "source": "mesh-transaction",
      "isReExportFile": false
    },
    {
      "key": "mesh-transaction:tx-parser.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/tx-parser/index.ts",
      "name": "tx-parser.index.ts",
      "imports": [
        {
          "module": "TxParser",
          "items": [],
          "line": 8,
          "raw": "export class TxParser {",
          "source": "mesh-transaction"
        }
      ],
      "functions": [
        {
          "name": "getBuilderBody",
          "signature": "getBuilderBody = () => this.serializer.parser.getBuilderBody();",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 59,
          "raw": "  getBuilderBody = () => this.serializer.parser.getBuilderBody();",
          "source": "mesh-transaction",
          "implementation": "  getBuilderBody = () => this.serializer.parser.getBuilderBody();"
        },
        {
          "name": "getBuilderBodyWithoutChange",
          "signature": "getBuilderBodyWithoutChange = () =>",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 61,
          "raw": "  getBuilderBodyWithoutChange = () =>",
          "source": "mesh-transaction",
          "implementation": "  getBuilderBodyWithoutChange = () =>"
        },
        {
          "name": "toTester",
          "signature": "toTester = () => this.serializer.parser.toTester();",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 64,
          "raw": "  toTester = () => this.serializer.parser.toTester();",
          "source": "mesh-transaction",
          "implementation": "  toTester = () => this.serializer.parser.toTester();"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "resolvedUtxos",
          "type": "UTxO[]",
          "value": "[...providedUtxos];",
          "isPublic": true,
          "line": 15,
          "raw": "const resolvedUtxos: UTxO[] = [...providedUtxos];",
          "source": "mesh-transaction"
        },
        {
          "name": "resolvedUtxosSet",
          "type": "Set<string>",
          "value": "new Set(",
          "isPublic": true,
          "line": 17,
          "raw": "const resolvedUtxosSet: Set<string> = new Set(",
          "source": "mesh-transaction"
        },
        {
          "name": "toResolveUtxos",
          "type": "Record<string, number[]>",
          "value": "{};",
          "isPublic": true,
          "line": 22,
          "raw": "const toResolveUtxos: Record<string, number[]> = {};",
          "source": "mesh-transaction"
        },
        {
          "name": "fetchResult",
          "type": "Record<string, UTxO[]>",
          "value": "{};",
          "isPublic": true,
          "line": 23,
          "raw": "const fetchResult: Record<string, UTxO[]> = {};",
          "source": "mesh-transaction"
        },
        {
          "name": "outputIndices",
          "type": "any",
          "value": "toResolveUtxos[txHash];",
          "isPublic": true,
          "line": 37,
          "raw": "const outputIndices = toResolveUtxos[txHash];",
          "source": "mesh-transaction"
        },
        {
          "name": "utxos",
          "type": "any",
          "value": "await this.fetcher.fetchUTxOs(txHash);",
          "isPublic": true,
          "line": 43,
          "raw": "const utxos = await this.fetcher.fetchUTxOs(txHash);",
          "source": "mesh-transaction"
        },
        {
          "name": "utxoData",
          "type": "any",
          "value": "utxos.find(",
          "isPublic": true,
          "line": 45,
          "raw": "const utxoData = utxos.find(",
          "source": "mesh-transaction"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { IFetcher, IMeshTxSerializer, UTxO } from \"@meshsdk/common\";\n\n/**\n * TxParser class to parse transaction hex strings and resolve UTxOs.\n *\n * It is used for either manipulating transactions or for unit testing transaction buildings.\n */\nexport class TxParser {\n  constructor(\n    public serializer: IMeshTxSerializer,\n    public fetcher?: IFetcher,\n  ) {}\n\n  parse = async (txHex: string, providedUtxos: UTxO[] = []) => {\n    const resolvedUtxos: UTxO[] = [...providedUtxos];\n\n    const resolvedUtxosSet: Set<string> = new Set(\n      providedUtxos.map(\n        (utxo) => `${utxo.input.txHash}#${utxo.input.outputIndex}`,\n      ),\n    );\n    const toResolveUtxos: Record<string, number[]> = {};\n    const fetchResult: Record<string, UTxO[]> = {};\n\n    // parse utxo inputs\n    this.serializer.parser.getRequiredInputs(txHex).forEach((input) => {\n      if (!resolvedUtxosSet.has(`${input.txHash}#${input.outputIndex}`)) {\n        if (!toResolveUtxos[input.txHash]) {\n          toResolveUtxos[input.txHash] = [];\n        }\n        toResolveUtxos[input.txHash]!.push(input.outputIndex);\n      }\n    });\n\n    // fetch missing utxos\n    for (const txHash in toResolveUtxos) {\n      const outputIndices = toResolveUtxos[txHash];\n      if (!this.fetcher) {\n        throw new Error(\n          \"Fetcher is not provided. Cannot resolve UTxOs without fetcher.\",\n        );\n      }\n      const utxos = await this.fetcher.fetchUTxOs(txHash);\n      outputIndices?.forEach((outputIndex) => {\n        const utxoData = utxos.find(\n          (utxo) => utxo.input.outputIndex === outputIndex,\n        );\n        if (!utxoData) {\n          throw new Error(`UTxO not found: ${txHash}:${outputIndex}`);\n        }\n        resolvedUtxos.push(utxoData);\n      });\n    }\n\n    this.serializer.parser.parse(txHex, resolvedUtxos);\n    return this.serializer.parser.getBuilderBody();\n  };\n\n  getBuilderBody = () => this.serializer.parser.getBuilderBody();\n\n  getBuilderBodyWithoutChange = () =>\n    this.serializer.parser.getBuilderBodyWithoutChange();\n\n  toTester = () => this.serializer.parser.toTester();\n}\n",
      "dependencies": [
        "TxParser"
      ],
      "source": "mesh-transaction",
      "isReExportFile": false
    },
    {
      "key": "mesh-transaction:utils.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/utils/index.ts",
      "name": "utils.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./metadata\";\n",
      "dependencies": [],
      "source": "mesh-transaction",
      "isReExportFile": false
    },
    {
      "key": "mesh-transaction:utils.metadata.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/utils/metadata.ts",
      "name": "utils.metadata.ts",
      "imports": [
        {
          "module": "MetadataMergeLevel",
          "items": [],
          "line": 5,
          "raw": "export type MetadataMergeLevel = boolean | number;",
          "source": "mesh-transaction"
        },
        {
          "module": "metadataObjToMap",
          "items": [],
          "line": 7,
          "raw": "export const metadataObjToMap = (metadata: any): Metadatum => {",
          "source": "mesh-transaction"
        },
        {
          "module": "mergeContents",
          "items": [],
          "line": 62,
          "raw": "export const mergeContents = (",
          "source": "mesh-transaction"
        }
      ],
      "functions": [
        {
          "name": "metadataObjToMap",
          "signature": "export const metadataObjToMap = (metadata: any): Metadatum => {",
          "documentation": "",
          "parameters": [
            {
              "name": "metadata",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "Metadatum",
          "isPublic": true,
          "line": 7,
          "raw": "export const metadataObjToMap = (metadata: any): Metadatum => {\n  if (typeof metadata === \"bigint\") {\n    return metadata;\n  } else if (typeof metadata === \"string\") {\n    return metadata;\n  } else if (typeof metadata === \"number\") {\n    return metadata;\n  } else if (metadata instanceof Uint8Array) {\n    return metadata;\n  } else if (Array.isArray(metadata)) {\n    // Recursively process each element in the array\n    return metadata.map(metadataObjToMap);\n  } else if (metadata && typeof metadata === \"object\") {\n    // Convert to MetadatumMap recursively\n    const map: MetadatumMap = new Map();\n    if (metadata instanceof Map) {\n      // for Map\n      metadata.forEach((value, key) => {\n        map.set(metadataObjToMap(key), metadataObjToMap(value));\n      });\n    } else {\n      // for Object\n      Object.entries(metadata).forEach(([key, value]) => {\n        map.set(metadataObjToMap(key), metadataObjToMap(value));\n      });\n    }\n    return map;\n  } else {\n    throw new Error(\"Metadata map conversion: Unsupported metadata type\");\n  }\n};",
          "source": "mesh-transaction",
          "implementation": "export const metadataObjToMap = (metadata: any): Metadatum => {\n  if (typeof metadata === \"bigint\") {\n    return metadata;\n  } else if (typeof metadata === \"string\") {\n    return metadata;\n  } else if (typeof metadata === \"number\") {\n    return metadata;\n  } else if (metadata instanceof Uint8Array) {\n    return metadata;\n  } else if (Array.isArray(metadata)) {\n    // Recursively process each element in the array\n    return metadata.map(metadataObjToMap);\n  } else if (metadata && typeof metadata === \"object\") {\n    // Convert to MetadatumMap recursively\n    const map: MetadatumMap = new Map();\n    if (metadata instanceof Map) {\n      // for Map\n      metadata.forEach((value, key) => {\n        map.set(metadataObjToMap(key), metadataObjToMap(value));\n      });\n    } else {\n      // for Object\n      Object.entries(metadata).forEach(([key, value]) => {\n        map.set(metadataObjToMap(key), metadataObjToMap(value));\n      });\n    }\n    return map;\n  } else {\n    throw new Error(\"Metadata map conversion: Unsupported metadata type\");\n  }\n};"
        },
        {
          "name": "mergeContents",
          "signature": "export const mergeContents = (",
          "documentation": "/**\n * Recursively merge two metadata. Returns the 2nd item if the maximum allowed\n * merge depth has passed.\n *\n * Merging maps ({ key: value }):\n * Two maps are merged by recursively including the (key, value) pairs from both the maps.\n * When further merge isn't allowed (by currentDepth), the 2nd item is preferred,\n * replacing the 1st item.\n *\n * Merging arrays:\n * Two arrays are merged by concatenating them.\n * When merge isn't allowed (by currentDepth), the 2nd array is returned.\n *\n * Merging primitive types (number, string, etc.):\n * Primitive types are not merged in the sense of concatenating. In case they are the same,\n * either of them can be considered as the \"merged value\". 2nd item is returned here.\n * When merge isn't allowed (by currentDepth), the 2nd item is returned.\n *\n * @param a first item\n * @param b second item\n * @param currentDepth the current merge depth; decreases in a recursive call\n * @returns merged item or a preferred item, chosen according to currentDepth\n */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 62,
          "raw": "/**\n * Recursively merge two metadata. Returns the 2nd item if the maximum allowed\n * merge depth has passed.\n *\n * Merging maps ({ key: value }):\n * Two maps are merged by recursively including the (key, value) pairs from both the maps.\n * When further merge isn't allowed (by currentDepth), the 2nd item is preferred,\n * replacing the 1st item.\n *\n * Merging arrays:\n * Two arrays are merged by concatenating them.\n * When merge isn't allowed (by currentDepth), the 2nd array is returned.\n *\n * Merging primitive types (number, string, etc.):\n * Primitive types are not merged in the sense of concatenating. In case they are the same,\n * either of them can be considered as the \"merged value\". 2nd item is returned here.\n * When merge isn't allowed (by currentDepth), the 2nd item is returned.\n *\n * @param a first item\n * @param b second item\n * @param currentDepth the current merge depth; decreases in a recursive call\n * @returns merged item or a preferred item, chosen according to currentDepth\n */\nexport const mergeContents = (\n  a: Metadatum,\n  b: Metadatum,\n  currentDepth: number,\n): Metadatum => {\n  // Handle no merge\n  if (currentDepth <= 0) {\n    return b;\n  }\n  // Handle merging of maps\n  if (a instanceof Map && b instanceof Map) {\n    b.forEach((value: Metadatum, key: Metadatum) => {\n      if (a.has(key)) {\n        a.set(\n          key,\n          mergeContents(a.get(key) as Metadatum, value, currentDepth - 1),\n        );\n      } else {\n        a.set(key, value);\n      }\n    });\n    return a;\n  }\n  // Handle merging of arrays\n  else if (Array.isArray(a) && Array.isArray(b)) {\n    return [...a, ...b];\n  }\n  // Handle merging of primitive types\n  if (\n    (typeof a === \"number\" ||\n      typeof a === \"bigint\" ||\n      typeof a === \"string\" ||\n      a instanceof Uint8Array) &&\n    (typeof b === \"number\" ||\n      typeof b === \"bigint\" ||\n      typeof b === \"string\" ||\n      b instanceof Uint8Array)\n  ) {\n    if (typeof a === typeof b) {\n      if (a === b) {\n        // Equal primitive types (string, number or bigint)\n        return b;\n      }\n      if (\n        a instanceof Uint8Array &&\n        b instanceof Uint8Array &&\n        areUint8ArraysEqual(a, b)\n      ) {\n        // Equal Uint8Array values\n        return b;\n      }\n    }\n    // If values are not equal or types are mismatched\n    throw new Error(\n      `Tx metadata merge error: cannot merge ${JSONBig.stringify(a)} with ${JSONBig.stringify(b)}`,\n    );\n  }\n\n  // Unsupported or mismatched types\n  throw new Error(\n    `Tx metadata merge error: cannot merge ${getMetadatumType(a)} type with ${getMetadatumType(b)} type`,\n  );\n};",
          "source": "mesh-transaction",
          "implementation": "export const mergeContents = (\n  a: Metadatum,\n  b: Metadatum,\n  currentDepth: number,\n): Metadatum => {\n  // Handle no merge\n  if (currentDepth <= 0) {\n    return b;\n  }\n  // Handle merging of maps\n  if (a instanceof Map && b instanceof Map) {\n    b.forEach((value: Metadatum, key: Metadatum) => {\n      if (a.has(key)) {\n        a.set(\n          key,\n          mergeContents(a.get(key) as Metadatum, value, currentDepth - 1),\n        );\n      } else {\n        a.set(key, value);\n      }\n    });\n    return a;\n  }\n  // Handle merging of arrays\n  else if (Array.isArray(a) && Array.isArray(b)) {\n    return [...a, ...b];\n  }\n  // Handle merging of primitive types\n  if (\n    (typeof a === \"number\" ||\n      typeof a === \"bigint\" ||\n      typeof a === \"string\" ||\n      a instanceof Uint8Array) &&\n    (typeof b === \"number\" ||\n      typeof b === \"bigint\" ||\n      typeof b === \"string\" ||\n      b instanceof Uint8Array)\n  ) {\n    if (typeof a === typeof b) {\n      if (a === b) {\n        // Equal primitive types (string, number or bigint)\n        return b;\n      }\n      if (\n        a instanceof Uint8Array &&\n        b instanceof Uint8Array &&\n        areUint8ArraysEqual(a, b)\n      ) {\n        // Equal Uint8Array values\n        return b;\n      }\n    }\n    // If values are not equal or types are mismatched\n    throw new Error(\n      `Tx metadata merge error: cannot merge ${JSONBig.stringify(a)} with ${JSONBig.stringify(b)}`,\n    );\n  }\n\n  // Unsupported or mismatched types\n  throw new Error(\n    `Tx metadata merge error: cannot merge ${getMetadatumType(a)} type with ${getMetadatumType(b)} type`,\n  );\n};"
        },
        {
          "name": "getMergeDepth",
          "signature": "const getMergeDepth = (mergeOption: MetadataMergeLevel): number => {",
          "documentation": "",
          "parameters": [
            {
              "name": "mergeOption",
              "type": "MetadataMergeLevel",
              "optional": false
            }
          ],
          "returnType": "number",
          "isPublic": true,
          "line": 126,
          "raw": "const getMergeDepth = (mergeOption: MetadataMergeLevel): number => {\n  return typeof mergeOption === \"number\"\n    ? mergeOption\n    : mergeOption === true\n      ? 1\n      : 0;\n};",
          "source": "mesh-transaction",
          "implementation": "const getMergeDepth = (mergeOption: MetadataMergeLevel): number => {\n  return typeof mergeOption === \"number\"\n    ? mergeOption\n    : mergeOption === true\n      ? 1\n      : 0;\n};"
        },
        {
          "name": "getMetadatumType",
          "signature": "const getMetadatumType = (a: Metadatum): string => {",
          "documentation": "",
          "parameters": [
            {
              "name": "a",
              "type": "Metadatum",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 134,
          "raw": "const getMetadatumType = (a: Metadatum): string => {\n  if (a instanceof Map) return \"map\";\n  if (Array.isArray(a)) return \"array\";\n  return \"primitive\";\n};",
          "source": "mesh-transaction",
          "implementation": "const getMetadatumType = (a: Metadatum): string => {\n  if (a instanceof Map) return \"map\";\n  if (Array.isArray(a)) return \"array\";\n  return \"primitive\";\n};"
        },
        {
          "name": "areUint8ArraysEqual",
          "signature": "const areUint8ArraysEqual = (a: Uint8Array, b: Uint8Array): boolean => {",
          "documentation": "",
          "parameters": [
            {
              "name": "a",
              "type": "Uint8Array",
              "optional": false
            },
            {
              "name": "b",
              "type": "Uint8Array",
              "optional": false
            }
          ],
          "returnType": "boolean",
          "isPublic": true,
          "line": 140,
          "raw": "const areUint8ArraysEqual = (a: Uint8Array, b: Uint8Array): boolean => {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};",
          "source": "mesh-transaction",
          "implementation": "const areUint8ArraysEqual = (a: Uint8Array, b: Uint8Array): boolean => {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};"
        }
      ],
      "types": [
        {
          "name": "MetadataMergeLevel",
          "definition": "export type MetadataMergeLevel = boolean | number;",
          "isPublic": true,
          "line": 5,
          "raw": "export type MetadataMergeLevel = boolean | number;",
          "source": "mesh-transaction"
        }
      ],
      "constants": [
        {
          "name": "metadataObjToMap",
          "type": "any",
          "value": "(metadata: any): Metadatum => {",
          "isPublic": true,
          "line": 7,
          "raw": "export const metadataObjToMap = (metadata: any): Metadatum => {",
          "source": "mesh-transaction"
        },
        {
          "name": "map",
          "type": "MetadatumMap",
          "value": "new Map();",
          "isPublic": true,
          "line": 21,
          "raw": "const map: MetadatumMap = new Map();",
          "source": "mesh-transaction"
        },
        {
          "name": "mergeContents",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 62,
          "raw": "export const mergeContents = (",
          "source": "mesh-transaction"
        },
        {
          "name": "getMergeDepth",
          "type": "any",
          "value": "(mergeOption: MetadataMergeLevel): number => {",
          "isPublic": true,
          "line": 126,
          "raw": "const getMergeDepth = (mergeOption: MetadataMergeLevel): number => {",
          "source": "mesh-transaction"
        },
        {
          "name": "getMetadatumType",
          "type": "any",
          "value": "(a: Metadatum): string => {",
          "isPublic": true,
          "line": 134,
          "raw": "const getMetadatumType = (a: Metadatum): string => {",
          "source": "mesh-transaction"
        },
        {
          "name": "areUint8ArraysEqual",
          "type": "any",
          "value": "(a: Uint8Array, b: Uint8Array): boolean => {",
          "isPublic": true,
          "line": 140,
          "raw": "const areUint8ArraysEqual = (a: Uint8Array, b: Uint8Array): boolean => {",
          "source": "mesh-transaction"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import JSONBig from \"json-bigint\";\n\nimport type { Metadatum, MetadatumMap } from \"@meshsdk/common\";\n\nexport type MetadataMergeLevel = boolean | number;\n\nexport const metadataObjToMap = (metadata: any): Metadatum => {\n  if (typeof metadata === \"bigint\") {\n    return metadata;\n  } else if (typeof metadata === \"string\") {\n    return metadata;\n  } else if (typeof metadata === \"number\") {\n    return metadata;\n  } else if (metadata instanceof Uint8Array) {\n    return metadata;\n  } else if (Array.isArray(metadata)) {\n    // Recursively process each element in the array\n    return metadata.map(metadataObjToMap);\n  } else if (metadata && typeof metadata === \"object\") {\n    // Convert to MetadatumMap recursively\n    const map: MetadatumMap = new Map();\n    if (metadata instanceof Map) {\n      // for Map\n      metadata.forEach((value, key) => {\n        map.set(metadataObjToMap(key), metadataObjToMap(value));\n      });\n    } else {\n      // for Object\n      Object.entries(metadata).forEach(([key, value]) => {\n        map.set(metadataObjToMap(key), metadataObjToMap(value));\n      });\n    }\n    return map;\n  } else {\n    throw new Error(\"Metadata map conversion: Unsupported metadata type\");\n  }\n};\n\n/**\n * Recursively merge two metadata. Returns the 2nd item if the maximum allowed\n * merge depth has passed.\n *\n * Merging maps ({ key: value }):\n * Two maps are merged by recursively including the (key, value) pairs from both the maps.\n * When further merge isn't allowed (by currentDepth), the 2nd item is preferred,\n * replacing the 1st item.\n *\n * Merging arrays:\n * Two arrays are merged by concatenating them.\n * When merge isn't allowed (by currentDepth), the 2nd array is returned.\n *\n * Merging primitive types (number, string, etc.):\n * Primitive types are not merged in the sense of concatenating. In case they are the same,\n * either of them can be considered as the \"merged value\". 2nd item is returned here.\n * When merge isn't allowed (by currentDepth), the 2nd item is returned.\n *\n * @param a first item\n * @param b second item\n * @param currentDepth the current merge depth; decreases in a recursive call\n * @returns merged item or a preferred item, chosen according to currentDepth\n */\nexport const mergeContents = (\n  a: Metadatum,\n  b: Metadatum,\n  currentDepth: number,\n): Metadatum => {\n  // Handle no merge\n  if (currentDepth <= 0) {\n    return b;\n  }\n  // Handle merging of maps\n  if (a instanceof Map && b instanceof Map) {\n    b.forEach((value: Metadatum, key: Metadatum) => {\n      if (a.has(key)) {\n        a.set(\n          key,\n          mergeContents(a.get(key) as Metadatum, value, currentDepth - 1),\n        );\n      } else {\n        a.set(key, value);\n      }\n    });\n    return a;\n  }\n  // Handle merging of arrays\n  else if (Array.isArray(a) && Array.isArray(b)) {\n    return [...a, ...b];\n  }\n  // Handle merging of primitive types\n  if (\n    (typeof a === \"number\" ||\n      typeof a === \"bigint\" ||\n      typeof a === \"string\" ||\n      a instanceof Uint8Array) &&\n    (typeof b === \"number\" ||\n      typeof b === \"bigint\" ||\n      typeof b === \"string\" ||\n      b instanceof Uint8Array)\n  ) {\n    if (typeof a === typeof b) {\n      if (a === b) {\n        // Equal primitive types (string, number or bigint)\n        return b;\n      }\n      if (\n        a instanceof Uint8Array &&\n        b instanceof Uint8Array &&\n        areUint8ArraysEqual(a, b)\n      ) {\n        // Equal Uint8Array values\n        return b;\n      }\n    }\n    // If values are not equal or types are mismatched\n    throw new Error(\n      `Tx metadata merge error: cannot merge ${JSONBig.stringify(a)} with ${JSONBig.stringify(b)}`,\n    );\n  }\n\n  // Unsupported or mismatched types\n  throw new Error(\n    `Tx metadata merge error: cannot merge ${getMetadatumType(a)} type with ${getMetadatumType(b)} type`,\n  );\n};\n\nconst getMergeDepth = (mergeOption: MetadataMergeLevel): number => {\n  return typeof mergeOption === \"number\"\n    ? mergeOption\n    : mergeOption === true\n      ? 1\n      : 0;\n};\n\nconst getMetadatumType = (a: Metadatum): string => {\n  if (a instanceof Map) return \"map\";\n  if (Array.isArray(a)) return \"array\";\n  return \"primitive\";\n};\n\nconst areUint8ArraysEqual = (a: Uint8Array, b: Uint8Array): boolean => {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n",
      "dependencies": [
        "MetadataMergeLevel",
        "metadataObjToMap",
        "mergeContents"
      ],
      "source": "mesh-transaction",
      "isReExportFile": false
    },
    {
      "key": "mesh-wallet:app.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/app/index.ts",
      "name": "app.index.ts",
      "imports": [
        {
          "module": "AppWalletKeyType",
          "items": [],
          "line": 13,
          "raw": "export type AppWalletKeyType =",
          "source": "mesh-wallet"
        },
        {
          "module": "CreateAppWalletOptions",
          "items": [],
          "line": 28,
          "raw": "export type CreateAppWalletOptions = {",
          "source": "mesh-wallet"
        },
        {
          "module": "AppWallet",
          "items": [],
          "line": 35,
          "raw": "export class AppWallet implements ISigner, ISubmitter {",
          "source": "mesh-wallet"
        }
      ],
      "functions": [
        {
          "name": "getEnterpriseAddress",
          "signature": "getEnterpriseAddress(accountIndex = 0, keyIndex = 0): string {",
          "documentation": "",
          "parameters": [
            {
              "name": "accountIndex",
              "type": "any",
              "optional": false
            },
            {
              "name": "keyIndex",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 120,
          "raw": "  getEnterpriseAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.enterpriseAddressBech32;\n  }",
          "source": "mesh-wallet",
          "implementation": "  getEnterpriseAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.enterpriseAddressBech32;\n  }"
        },
        {
          "name": "getPaymentAddress",
          "signature": "getPaymentAddress(accountIndex = 0, keyIndex = 0): string {",
          "documentation": "",
          "parameters": [
            {
              "name": "accountIndex",
              "type": "any",
              "optional": false
            },
            {
              "name": "keyIndex",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 125,
          "raw": "  getPaymentAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.baseAddressBech32;\n  }",
          "source": "mesh-wallet",
          "implementation": "  getPaymentAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.baseAddressBech32;\n  }"
        },
        {
          "name": "getRewardAddress",
          "signature": "getRewardAddress(accountIndex = 0, keyIndex = 0): string {",
          "documentation": "",
          "parameters": [
            {
              "name": "accountIndex",
              "type": "any",
              "optional": false
            },
            {
              "name": "keyIndex",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 130,
          "raw": "  getRewardAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.rewardAddressBech32;\n  }",
          "source": "mesh-wallet",
          "implementation": "  getRewardAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.rewardAddressBech32;\n  }"
        },
        {
          "name": "getNetworkId",
          "signature": "getNetworkId(): number {",
          "documentation": "",
          "parameters": [],
          "returnType": "number",
          "isPublic": true,
          "line": 135,
          "raw": "  getNetworkId(): number {\n    return this._wallet.getNetworkId();\n  }",
          "source": "mesh-wallet",
          "implementation": "  getNetworkId(): number {\n    return this._wallet.getNetworkId();\n  }"
        },
        {
          "name": "submitTx",
          "signature": "submitTx(tx: string): Promise<string> {",
          "documentation": "",
          "parameters": [
            {
              "name": "tx",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Promise<string>",
          "isPublic": true,
          "line": 236,
          "raw": "  submitTx(tx: string): Promise<string> {\n    if (!this._submitter) {\n      throw new Error(\n        \"[AppWallet] Submitter is required to submit transactions. Please provide a submitter.\",\n      );\n    }\n    return this._submitter.submitTx(tx);\n  }",
          "source": "mesh-wallet",
          "implementation": "  submitTx(tx: string): Promise<string> {\n    if (!this._submitter) {\n      throw new Error(\n        \"[AppWallet] Submitter is required to submit transactions. Please provide a submitter.\",\n      );\n    }\n    return this._submitter.submitTx(tx);\n  }"
        }
      ],
      "types": [
        {
          "name": "AppWalletKeyType",
          "definition": "export type AppWalletKeyType =\n  | {\n      type: \"root\";\n      bech32: string;",
          "isPublic": true,
          "line": 13,
          "raw": "export type AppWalletKeyType =",
          "source": "mesh-wallet"
        },
        {
          "name": "CreateAppWalletOptions",
          "definition": "export type CreateAppWalletOptions = {\n  networkId: number;\n  fetcher?: IFetcher;",
          "isPublic": true,
          "line": 28,
          "raw": "export type CreateAppWalletOptions = {",
          "source": "mesh-wallet"
        }
      ],
      "constants": [
        {
          "name": "utxos",
          "type": "any",
          "value": "await this.getUnspentOutputs(accountIndex, addressType);",
          "isPublic": true,
          "line": 96,
          "raw": "const utxos = await this.getUnspentOutputs(accountIndex, addressType);",
          "source": "mesh-wallet"
        },
        {
          "name": "pureAdaUtxos",
          "type": "any",
          "value": "utxos.filter((utxo) => {",
          "isPublic": true,
          "line": 99,
          "raw": "const pureAdaUtxos = utxos.filter((utxo) => {",
          "source": "mesh-wallet"
        },
        {
          "name": "account",
          "type": "any",
          "value": "this._wallet.getAccount(accountIndex, keyIndex);",
          "isPublic": true,
          "line": 121,
          "raw": "const account = this._wallet.getAccount(accountIndex, keyIndex);",
          "source": "mesh-wallet"
        },
        {
          "name": "account",
          "type": "any",
          "value": "this._wallet.getAccount(accountIndex, keyIndex);",
          "isPublic": true,
          "line": 126,
          "raw": "const account = this._wallet.getAccount(accountIndex, keyIndex);",
          "source": "mesh-wallet"
        },
        {
          "name": "account",
          "type": "any",
          "value": "this._wallet.getAccount(accountIndex, keyIndex);",
          "isPublic": true,
          "line": 131,
          "raw": "const account = this._wallet.getAccount(accountIndex, keyIndex);",
          "source": "mesh-wallet"
        },
        {
          "name": "account",
          "type": "any",
          "value": "this._wallet.getAccount(accountIndex);",
          "isPublic": true,
          "line": 160,
          "raw": "const account = this._wallet.getAccount(accountIndex);",
          "source": "mesh-wallet"
        },
        {
          "name": "utxos",
          "type": "any",
          "value": "await this._fetcher.fetchAddressUTxOs(",
          "isPublic": true,
          "line": 162,
          "raw": "const utxos = await this._fetcher.fetchAddressUTxOs(",
          "source": "mesh-wallet"
        },
        {
          "name": "tx",
          "type": "any",
          "value": "deserializeTx(unsignedTx);",
          "isPublic": true,
          "line": 193,
          "raw": "const tx = deserializeTx(unsignedTx);",
          "source": "mesh-wallet"
        },
        {
          "name": "newSignatures",
          "type": "any",
          "value": "this._wallet.signTx(",
          "isPublic": true,
          "line": 203,
          "raw": "const newSignatures = this._wallet.signTx(",
          "source": "mesh-wallet"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { DataSignature, IFetcher, ISigner, ISubmitter } from \"@meshsdk/common\";\nimport {\n  Address,\n  deserializeTx,\n  toAddress,\n  toTxUnspentOutput,\n  TransactionUnspentOutput,\n} from \"@meshsdk/core-cst\";\n\nimport { EmbeddedWallet } from \"../embedded\";\nimport { GetAddressType } from \"../types\";\n\nexport type AppWalletKeyType =\n  | {\n      type: \"root\";\n      bech32: string;\n    }\n  | {\n      type: \"cli\";\n      payment: string;\n      stake?: string;\n    }\n  | {\n      type: \"mnemonic\";\n      words: string[];\n    };\n\nexport type CreateAppWalletOptions = {\n  networkId: number;\n  fetcher?: IFetcher;\n  submitter?: ISubmitter;\n  key: AppWalletKeyType;\n};\n\nexport class AppWallet implements ISigner, ISubmitter {\n  private readonly _fetcher?: IFetcher;\n  private readonly _submitter?: ISubmitter;\n  private readonly _wallet: EmbeddedWallet;\n\n  constructor(options: CreateAppWalletOptions) {\n    this._fetcher = options.fetcher;\n    this._submitter = options.submitter;\n\n    switch (options.key.type) {\n      case \"mnemonic\":\n        this._wallet = new EmbeddedWallet({\n          networkId: options.networkId,\n          key: {\n            type: \"mnemonic\",\n            words: options.key.words,\n          },\n        });\n        break;\n      case \"root\":\n        this._wallet = new EmbeddedWallet({\n          networkId: options.networkId,\n          key: {\n            type: \"root\",\n            bech32: options.key.bech32,\n          },\n        });\n        break;\n      case \"cli\":\n        this._wallet = new EmbeddedWallet({\n          networkId: options.networkId,\n          key: {\n            type: \"cli\",\n            payment: options.key.payment,\n            stake: options.key.stake,\n          },\n        });\n    }\n  }\n\n  /**\n   * Initializes the wallet. This is a required call as fetching addresses from the wallet is an async operation.\n   * @returns void\n   */\n  async init() {\n    if (this._wallet) {\n      await this._wallet.init();\n    }\n  }\n\n  /**\n   * Get a list of UTXOs to be used as collateral inputs for transactions with plutus script inputs.\n   *\n   * This is used in transaction building.\n   *\n   * @returns a list of UTXOs\n   */\n  async getCollateralUnspentOutput(\n    accountIndex = 0,\n    addressType: GetAddressType = \"payment\",\n  ): Promise<TransactionUnspentOutput[]> {\n    const utxos = await this.getUnspentOutputs(accountIndex, addressType);\n\n    // find utxos that are pure ADA-only\n    const pureAdaUtxos = utxos.filter((utxo) => {\n      return utxo.output().amount().multiasset() === undefined;\n    });\n\n    // sort utxos by their lovelace amount\n    pureAdaUtxos.sort((a, b) => {\n      return (\n        Number(a.output().amount().coin()) - Number(b.output().amount().coin())\n      );\n    });\n\n    // return the smallest utxo but not less than 5000000 lovelace\n    for (const utxo of pureAdaUtxos) {\n      if (Number(utxo.output().amount().coin()) >= 5000000) {\n        return [utxo];\n      }\n    }\n\n    return [];\n  }\n\n  getEnterpriseAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.enterpriseAddressBech32;\n  }\n\n  getPaymentAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.baseAddressBech32;\n  }\n\n  getRewardAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.rewardAddressBech32;\n  }\n\n  getNetworkId(): number {\n    return this._wallet.getNetworkId();\n  }\n\n  getUsedAddress(\n    accountIndex = 0,\n    keyIndex = 0,\n    addressType: GetAddressType = \"payment\",\n  ): Address {\n    if (addressType === \"enterprise\") {\n      return toAddress(this.getEnterpriseAddress(accountIndex, keyIndex));\n    } else {\n      return toAddress(this.getPaymentAddress(accountIndex, keyIndex));\n    }\n  }\n\n  async getUnspentOutputs(\n    accountIndex = 0,\n    addressType: GetAddressType = \"payment\",\n  ): Promise<TransactionUnspentOutput[]> {\n    if (!this._fetcher) {\n      throw new Error(\n        \"[AppWallet] Fetcher is required to fetch UTxOs. Please provide a fetcher.\",\n      );\n    }\n    const account = this._wallet.getAccount(accountIndex);\n\n    const utxos = await this._fetcher.fetchAddressUTxOs(\n      addressType == \"enterprise\"\n        ? account.enterpriseAddressBech32\n        : account.baseAddressBech32,\n    );\n\n    return utxos.map((utxo) => toTxUnspentOutput(utxo));\n  }\n\n  async signData(\n    address: string,\n    payload: string,\n    accountIndex = 0,\n    keyIndex = 0,\n  ): Promise<DataSignature> {\n    try {\n      return this._wallet.signData(address, payload, accountIndex, keyIndex);\n    } catch (error) {\n      throw new Error(\n        `[AppWallet] An error occurred during signData: ${error}.`,\n      );\n    }\n  }\n\n  async signTx(\n    unsignedTx: string,\n    partialSign = false,\n    accountIndex = 0,\n    keyIndex = 0,\n  ): Promise<string> {\n    try {\n      const tx = deserializeTx(unsignedTx);\n      if (\n        !partialSign &&\n        tx.witnessSet().vkeys() !== undefined &&\n        tx.witnessSet().vkeys()!.size() !== 0\n      )\n        throw new Error(\n          \"Signatures already exist in the transaction in a non partial sign call\",\n        );\n\n      const newSignatures = this._wallet.signTx(\n        unsignedTx,\n        accountIndex,\n        keyIndex,\n      );\n\n      let signedTx = EmbeddedWallet.addWitnessSets(unsignedTx, [newSignatures]);\n      return signedTx;\n    } catch (error) {\n      throw new Error(`[AppWallet] An error occurred during signTx: ${error}.`);\n    }\n  }\n\n  signTxSync(\n    unsignedTx: string,\n    partialSign = false,\n    accountIndex = 0,\n    keyIndex = 0,\n  ): string {\n    try {\n      throw new Error(`[AppWallet] signTxSync() is not implemented.`);\n    } catch (error) {\n      throw new Error(`[AppWallet] An error occurred during signTx: ${error}.`);\n    }\n  }\n\n  async signTxs(\n    unsignedTxs: string[],\n    partialSign: boolean,\n  ): Promise<string[]> {\n    throw new Error(`[AppWallet] signTxs() is not implemented.`);\n  }\n\n  submitTx(tx: string): Promise<string> {\n    if (!this._submitter) {\n      throw new Error(\n        \"[AppWallet] Submitter is required to submit transactions. Please provide a submitter.\",\n      );\n    }\n    return this._submitter.submitTx(tx);\n  }\n\n  static brew(strength = 256): string[] {\n    return EmbeddedWallet.generateMnemonic(strength);\n  }\n}\n",
      "dependencies": [
        "AppWalletKeyType",
        "CreateAppWalletOptions",
        "AppWallet"
      ],
      "source": "mesh-wallet",
      "isReExportFile": false
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/browser/browser-wallet.ts",
      "name": "browser.browser-wallet.ts",
      "imports": [
        {
          "module": "BrowserWallet",
          "items": [],
          "line": 58,
          "raw": "export class BrowserWallet implements IWallet {",
          "source": "mesh-wallet"
        }
      ],
      "functions": [
        {
          "name": "getNetworkId",
          "signature": "getNetworkId(): Promise<number> {",
          "documentation": "  /**\n   * Returns the network ID of the currently connected account. 0 is testnet and 1 is mainnet but other networks can possibly be returned by wallets. Those other network ID values are not governed by CIP-30. This result will stay the same unless the connected account has changed.\n   *\n   * @returns network ID\n   */",
          "parameters": [],
          "returnType": "Promise<number>",
          "isPublic": true,
          "line": 207,
          "raw": "  /**\n   * Returns the network ID of the currently connected account. 0 is testnet and 1 is mainnet but other networks can possibly be returned by wallets. Those other network ID values are not governed by CIP-30. This result will stay the same unless the connected account has changed.\n   *\n   * @returns network ID\n   */\n  getNetworkId(): Promise<number> {\n    return this._walletInstance.getNetworkId();\n  }",
          "source": "mesh-wallet",
          "implementation": "  getNetworkId(): Promise<number> {\n    return this._walletInstance.getNetworkId();\n  }"
        },
        {
          "name": "submitTx",
          "signature": "submitTx(tx: string): Promise<string> {",
          "documentation": "  /**\n   * Submits the signed transaction to the blockchain network.\n   *\n   * As wallets should already have this ability to submit transaction, we allow apps to request that a transaction be sent through it. If the wallet accepts the transaction and tries to send it, it shall return the transaction ID for the app to track. The wallet can return error messages or failure if there was an error in sending it.\n   *\n   * @param tx\n   * @returns a transaction hash\n   */",
          "parameters": [
            {
              "name": "tx",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Promise<string>",
          "isPublic": true,
          "line": 365,
          "raw": "  /**\n   * Submits the signed transaction to the blockchain network.\n   *\n   * As wallets should already have this ability to submit transaction, we allow apps to request that a transaction be sent through it. If the wallet accepts the transaction and tries to send it, it shall return the transaction ID for the app to track. The wallet can return error messages or failure if there was an error in sending it.\n   *\n   * @param tx\n   * @returns a transaction hash\n   */\n  submitTx(tx: string): Promise<string> {\n    return this._walletInstance.submitTx(tx);\n  }",
          "source": "mesh-wallet",
          "implementation": "  submitTx(tx: string): Promise<string> {\n    return this._walletInstance.submitTx(tx);\n  }"
        },
        {
          "name": "utxos",
          "signature": "const utxos = (await this._walletInstance.getUtxos()) ?? [];",
          "documentation": "",
          "parameters": [
            {
              "name": "await this._walletInstance.getUtxos(",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 414,
          "raw": "    const utxos = (await this._walletInstance.getUtxos()) ?? [];\n    return utxos.map((u) => deserializeTxUnspentOutput(u));\n  }\n\n  /**\n   * A helper function to get the assets in the wallet.\n   *\n   * @returns a list of assets\n   */\n  async getAssets(): Promise<AssetExtended[]> {",
          "source": "mesh-wallet",
          "implementation": "    const utxos = (await this._walletInstance.getUtxos()) ?? [];\n    return utxos.map((u) => deserializeTxUnspentOutput(u));\n  }\n\n  /**\n   * A helper function to get the assets in the wallet.\n   *\n   * @returns a list of assets\n   */\n  async getAssets(): Promise<AssetExtended[]> {"
        },
        {
          "name": "dRepIDHash",
          "signature": "const dRepIDHash = (await dRepID.hash()).hex();",
          "documentation": "",
          "parameters": [
            {
              "name": "await dRepID.hash(",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 600,
          "raw": "    const dRepIDHash = (await dRepID.hash()).hex();\n    return {\n      dRepKeyHex,\n      dRepID,\n      dRepIDHash,\n    };",
          "source": "mesh-wallet",
          "implementation": "    const dRepIDHash = (await dRepID.hash()).hex();\n    return {\n      dRepKeyHex,\n      dRepID,\n      dRepIDHash,\n    };"
        }
      ],
      "types": [
        {
          "name": "Window",
          "definition": "interface Window {\n    cardano: Cardano;",
          "isPublic": true,
          "line": 43,
          "raw": "interface Window {",
          "source": "mesh-wallet"
        }
      ],
      "constants": [
        {
          "name": "_wallet",
          "type": "any",
          "value": "window.cardano[key];",
          "isPublic": true,
          "line": 103,
          "raw": "const _wallet = window.cardano[key];",
          "source": "mesh-wallet"
        },
        {
          "name": "walletInstance",
          "type": "any",
          "value": "await BrowserWallet.resolveInstance(",
          "isPublic": true,
          "line": 134,
          "raw": "const walletInstance = await BrowserWallet.resolveInstance(",
          "source": "mesh-wallet"
        },
        {
          "name": "balance",
          "type": "any",
          "value": "await this._walletInstance.getBalance();",
          "isPublic": true,
          "line": 160,
          "raw": "const balance = await this._walletInstance.getBalance();",
          "source": "mesh-wallet"
        },
        {
          "name": "changeAddress",
          "type": "any",
          "value": "await this._walletInstance.getChangeAddress();",
          "isPublic": true,
          "line": 170,
          "raw": "const changeAddress = await this._walletInstance.getChangeAddress();",
          "source": "mesh-wallet"
        },
        {
          "name": "deserializedCollateral",
          "type": "any",
          "value": "await this.getCollateralUnspentOutput();",
          "isPublic": true,
          "line": 183,
          "raw": "const deserializedCollateral = await this.getCollateralUnspentOutput();",
          "source": "mesh-wallet"
        },
        {
          "name": "rewardAddresses",
          "type": "any",
          "value": "await this._walletInstance.getRewardAddresses();",
          "isPublic": true,
          "line": 217,
          "raw": "const rewardAddresses = await this._walletInstance.getRewardAddresses();",
          "source": "mesh-wallet"
        },
        {
          "name": "unusedAddresses",
          "type": "any",
          "value": "await this._walletInstance.getUnusedAddresses();",
          "isPublic": true,
          "line": 227,
          "raw": "const unusedAddresses = await this._walletInstance.getUnusedAddresses();",
          "source": "mesh-wallet"
        },
        {
          "name": "usedAddresses",
          "type": "any",
          "value": "await this._walletInstance.getUsedAddresses();",
          "isPublic": true,
          "line": 239,
          "raw": "const usedAddresses = await this._walletInstance.getUsedAddresses();",
          "source": "mesh-wallet"
        },
        {
          "name": "deserializedUTxOs",
          "type": "any",
          "value": "await this.getUsedUTxOs();",
          "isPublic": true,
          "line": 249,
          "raw": "const deserializedUTxOs = await this.getUsedUTxOs();",
          "source": "mesh-wallet"
        },
        {
          "name": "_payload",
          "type": "any",
          "value": "convertFromUTF8 ? fromUTF8(payload) : payload;",
          "isPublic": true,
          "line": 272,
          "raw": "const _payload = convertFromUTF8 ? fromUTF8(payload) : payload;",
          "source": "mesh-wallet"
        },
        {
          "name": "signerAddress",
          "type": "any",
          "value": "toAddress(address).toBytes().toString();",
          "isPublic": true,
          "line": 278,
          "raw": "const signerAddress = toAddress(address).toBytes().toString();",
          "source": "mesh-wallet"
        },
        {
          "name": "witness",
          "type": "any",
          "value": "await this._walletInstance.signTx(unsignedTx, partialSign);",
          "isPublic": true,
          "line": 290,
          "raw": "const witness = await this._walletInstance.signTx(unsignedTx, partialSign);",
          "source": "mesh-wallet"
        },
        {
          "name": "signedTxs",
          "type": "string[]",
          "value": "[];",
          "isPublic": true,
          "line": 337,
          "raw": "const signedTxs: string[] = [];",
          "source": "mesh-wallet"
        },
        {
          "name": "unsignedTx",
          "type": "any",
          "value": "unsignedTxs[i]!;",
          "isPublic": true,
          "line": 339,
          "raw": "const unsignedTx = unsignedTxs[i]!;",
          "source": "mesh-wallet"
        },
        {
          "name": "cWitness",
          "type": "any",
          "value": "witnessSets[i]!;",
          "isPublic": true,
          "line": 340,
          "raw": "const cWitness = witnessSets[i]!;",
          "source": "mesh-wallet"
        },
        {
          "name": "signedTx",
          "type": "any",
          "value": "BrowserWallet.addBrowserWitnesses(",
          "isPublic": true,
          "line": 346,
          "raw": "const signedTx = BrowserWallet.addBrowserWitnesses(",
          "source": "mesh-wallet"
        },
        {
          "name": "usedAddresses",
          "type": "any",
          "value": "await this._walletInstance.getUsedAddresses();",
          "isPublic": true,
          "line": 377,
          "raw": "const usedAddresses = await this._walletInstance.getUsedAddresses();",
          "source": "mesh-wallet"
        },
        {
          "name": "utxos",
          "type": "any",
          "value": "(await this._walletInstance.getUtxos()) ?? [];",
          "isPublic": true,
          "line": 414,
          "raw": "const utxos = (await this._walletInstance.getUtxos()) ?? [];",
          "source": "mesh-wallet"
        },
        {
          "name": "balance",
          "type": "any",
          "value": "await this.getBalance();",
          "isPublic": true,
          "line": 424,
          "raw": "const balance = await this.getBalance();",
          "source": "mesh-wallet"
        },
        {
          "name": "policyId",
          "type": "any",
          "value": "v.unit.slice(0, POLICY_ID_LENGTH);",
          "isPublic": true,
          "line": 428,
          "raw": "const policyId = v.unit.slice(0, POLICY_ID_LENGTH);",
          "source": "mesh-wallet"
        },
        {
          "name": "assetName",
          "type": "any",
          "value": "v.unit.slice(POLICY_ID_LENGTH);",
          "isPublic": true,
          "line": 429,
          "raw": "const assetName = v.unit.slice(POLICY_ID_LENGTH);",
          "source": "mesh-wallet"
        },
        {
          "name": "fingerprint",
          "type": "any",
          "value": "resolveFingerprint(policyId, assetName);",
          "isPublic": true,
          "line": 430,
          "raw": "const fingerprint = resolveFingerprint(policyId, assetName);",
          "source": "mesh-wallet"
        },
        {
          "name": "balance",
          "type": "any",
          "value": "await this.getBalance();",
          "isPublic": true,
          "line": 448,
          "raw": "const balance = await this.getBalance();",
          "source": "mesh-wallet"
        },
        {
          "name": "nativeAsset",
          "type": "any",
          "value": "balance.find((v) => v.unit === \"lovelace\");",
          "isPublic": true,
          "line": 449,
          "raw": "const nativeAsset = balance.find((v) => v.unit === \"lovelace\");",
          "source": "mesh-wallet"
        },
        {
          "name": "assets",
          "type": "any",
          "value": "await this.getAssets();",
          "isPublic": true,
          "line": 461,
          "raw": "const assets = await this.getAssets();",
          "source": "mesh-wallet"
        },
        {
          "name": "balance",
          "type": "any",
          "value": "await this.getBalance();",
          "isPublic": true,
          "line": 471,
          "raw": "const balance = await this.getBalance();",
          "source": "mesh-wallet"
        },
        {
          "name": "pubDRepKey",
          "type": "any",
          "value": "await this.getPubDRepKey();",
          "isPublic": true,
          "line": 491,
          "raw": "const pubDRepKey = await this.getPubDRepKey();",
          "source": "mesh-wallet"
        },
        {
          "name": "dRepIDCip105",
          "type": "any",
          "value": "hexToBech32(\"drep\", dRepIDHash);",
          "isPublic": true,
          "line": 497,
          "raw": "const dRepIDCip105 = hexToBech32(\"drep\", dRepIDHash);",
          "source": "mesh-wallet"
        },
        {
          "name": "pubDRepKey",
          "type": "any",
          "value": "await this._walletInstance.cip95.getPubDRepKey();",
          "isPublic": true,
          "line": 523,
          "raw": "const pubDRepKey = await this._walletInstance.cip95.getPubDRepKey();",
          "source": "mesh-wallet"
        },
        {
          "name": "pubStakeKeyHashes",
          "type": "any",
          "value": "await Promise.all(",
          "isPublic": true,
          "line": 544,
          "raw": "const pubStakeKeyHashes = await Promise.all(",
          "source": "mesh-wallet"
        },
        {
          "name": "pubStakeKeyHashes",
          "type": "any",
          "value": "await Promise.all(",
          "isPublic": true,
          "line": 575,
          "raw": "const pubStakeKeyHashes = await Promise.all(",
          "source": "mesh-wallet"
        },
        {
          "name": "dRepKeyHex",
          "type": "any",
          "value": "Ed25519PublicKeyHex(dRepKey);",
          "isPublic": true,
          "line": 598,
          "raw": "const dRepKeyHex = Ed25519PublicKeyHex(dRepKey);",
          "source": "mesh-wallet"
        },
        {
          "name": "dRepID",
          "type": "any",
          "value": "Ed25519PublicKey.fromHex(dRepKeyHex);",
          "isPublic": true,
          "line": 599,
          "raw": "const dRepID = Ed25519PublicKey.fromHex(dRepKeyHex);",
          "source": "mesh-wallet"
        },
        {
          "name": "dRepIDHash",
          "type": "any",
          "value": "(await dRepID.hash()).hex();",
          "isPublic": true,
          "line": 600,
          "raw": "const dRepIDHash = (await dRepID.hash()).hex();",
          "source": "mesh-wallet"
        },
        {
          "name": "wallet",
          "type": "any",
          "value": "window.cardano[walletName];",
          "isPublic": true,
          "line": 615,
          "raw": "const wallet = window.cardano[walletName];",
          "source": "mesh-wallet"
        },
        {
          "name": "cWitness",
          "type": "any",
          "value": "Serialization.TransactionWitnessSet.fromCbor(",
          "isPublic": true,
          "line": 625,
          "raw": "const cWitness = Serialization.TransactionWitnessSet.fromCbor(",
          "source": "mesh-wallet"
        },
        {
          "name": "_supportedExtensions",
          "type": "any",
          "value": "window?.cardano?.[wallet]?.supportedExtensions;",
          "isPublic": true,
          "line": 653,
          "raw": "const _supportedExtensions = window?.cardano?.[wallet]?.supportedExtensions;",
          "source": "mesh-wallet"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  Asset,\n  AssetExtended,\n  DataSignature,\n  DEFAULT_PROTOCOL_PARAMETERS,\n  Extension,\n  fromUTF8,\n  IWallet,\n  POLICY_ID_LENGTH,\n  resolveFingerprint,\n  UTxO,\n  Wallet,\n} from \"@meshsdk/common\";\nimport {\n  Address,\n  addressToBech32,\n  AddressType,\n  blake2b,\n  buildDRepID,\n  CardanoSDKUtil,\n  deserializeAddress,\n  deserializeTx,\n  deserializeTxUnspentOutput,\n  deserializeValue,\n  DRep,\n  Ed25519KeyHashHex,\n  Ed25519PublicKey,\n  Ed25519PublicKeyHex,\n  fromTxUnspentOutput,\n  fromValue,\n  hexToBech32,\n  Serialization,\n  toAddress,\n  Transaction,\n  TransactionUnspentOutput,\n  VkeyWitness,\n} from \"@meshsdk/core-cst\";\n\nimport { WalletStaticMethods } from \"../embedded\";\nimport { Cardano, WalletInstance } from \"../types\";\n\ndeclare global {\n  interface Window {\n    cardano: Cardano;\n  }\n}\n\n/**\n * Browser Wallet provides a set of APIs to interact with the blockchain. This wallet is compatible with Mesh transaction builders.\n *\n * These wallets APIs are in accordance to CIP-30, which defines the API for apps to communicate with the user's wallet. Additional utility functions provided for developers that are useful for building applications.\n * ```javascript\n * import { BrowserWallet } from '@meshsdk/core';\n *\n * const wallet = await BrowserWallet.enable('eternl');\n * ```\n */\nexport class BrowserWallet implements IWallet {\n  walletInstance: WalletInstance;\n\n  private constructor(\n    readonly _walletInstance: WalletInstance,\n    readonly _walletName: string,\n  ) {\n    this.walletInstance = { ..._walletInstance };\n  }\n\n  /**\n   * Returns a list of wallets installed on user's device. Each wallet is an object with the following properties:\n   * - A name is provided to display wallet's name on the user interface.\n   * - A version is provided to display wallet's version on the user interface.\n   * - An icon is provided to display wallet's icon on the user interface.\n   *\n   * @returns a list of wallet names\n   */\n  static async getAvailableWallets({\n    injectFn = undefined,\n  }: {\n    injectFn?: () => Promise<void>;\n  } = {}): Promise<Wallet[]> {\n    if (window === undefined) return [];\n\n    if (injectFn) await injectFn();\n\n    return BrowserWallet.getInstalledWallets();\n  }\n\n  /**\n   * Returns a list of wallets installed on user's device. Each wallet is an object with the following properties:\n   * - A name is provided to display wallet's name on the user interface.\n   * - A version is provided to display wallet's version on the user interface.\n   * - An icon is provided to display wallet's icon on the user interface.\n   *\n   * @returns a list of wallet names\n   */\n  static getInstalledWallets(): Wallet[] {\n    if (window === undefined) return [];\n    if (window.cardano === undefined) return [];\n\n    let wallets: Wallet[] = [];\n    for (const key in window.cardano) {\n      try {\n        const _wallet = window.cardano[key];\n        if (_wallet === undefined) continue;\n        if (_wallet.name === undefined) continue;\n        if (_wallet.icon === undefined) continue;\n        if (_wallet.apiVersion === undefined) continue;\n        wallets.push({\n          id: key,\n          name: key == \"nufiSnap\" ? \"MetaMask\" : _wallet.name,\n          icon: _wallet.icon,\n          version: _wallet.apiVersion,\n        });\n      } catch (e) {}\n    }\n\n    return wallets;\n  }\n\n  /**\n   * This is the entrypoint to start communication with the user's wallet. The wallet should request the user's permission to connect the web page to the user's wallet, and if permission has been granted, the wallet will be returned and exposing the full API for the app to use.\n   *\n   * Query BrowserWallet.getInstalledWallets() to get a list of available wallets, then provide the wallet name for which wallet the user would like to connect with.\n   *\n   * @param walletName - the name of the wallet to enable (e.g. \"eternl\", \"begin\")\n   * @param extensions - optional, a list of CIPs that the wallet should support\n   * @returns WalletInstance\n   */\n  static async enable(\n    walletName: string,\n    extensions: Extension[] = [],\n  ): Promise<BrowserWallet> {\n    try {\n      const walletInstance = await BrowserWallet.resolveInstance(\n        walletName,\n        extensions,\n      );\n\n      if (walletInstance !== undefined)\n        return new BrowserWallet(walletInstance, walletName);\n\n      throw new Error(`Couldn't create an instance of wallet: ${walletName}`);\n    } catch (error) {\n      throw new Error(\n        `[BrowserWallet] An error occurred during enable: ${JSON.stringify(\n          error,\n        )}.`,\n      );\n    }\n  }\n\n  /**\n   * Returns a list of assets in the wallet. This API will return every assets in the wallet. Each asset is an object with the following properties:\n   * - A unit is provided to display asset's name on the user interface.\n   * - A quantity is provided to display asset's quantity on the user interface.\n   *\n   * @returns a list of assets and their quantities\n   */\n  async getBalance(): Promise<Asset[]> {\n    const balance = await this._walletInstance.getBalance();\n    return fromValue(deserializeValue(balance));\n  }\n\n  /**\n   * Returns an address owned by the wallet that should be used as a change address to return leftover assets during transaction creation back to the connected wallet.\n   *\n   * @returns an address\n   */\n  async getChangeAddress(): Promise<string> {\n    const changeAddress = await this._walletInstance.getChangeAddress();\n    return addressToBech32(deserializeAddress(changeAddress));\n  }\n\n  /**\n   * This function shall return a list of one or more UTXOs (unspent transaction outputs) controlled by the wallet that are required to reach AT LEAST the combined ADA value target specified in amount AND the best suitable to be used as collateral inputs for transactions with plutus script inputs (pure ADA-only UTXOs).\n   *\n   * If this cannot be attained, an error message with an explanation of the blocking problem shall be returned. NOTE: wallets are free to return UTXOs that add up to a greater total ADA value than requested in the amount parameter, but wallets must never return any result where UTXOs would sum up to a smaller total ADA value, instead in a case like that an error message must be returned.\n   *\n   * @param limit\n   * @returns a list of UTXOs\n   */\n  async getCollateral(): Promise<UTxO[]> {\n    const deserializedCollateral = await this.getCollateralUnspentOutput();\n    return deserializedCollateral.map((dc) => fromTxUnspentOutput(dc));\n  }\n\n  /**\n   * Return a list of supported CIPs of the wallet.\n   *\n   * @returns a list of CIPs\n   */\n  async getExtensions(): Promise<number[]> {\n    try {\n      const _extensions: { cip: number }[] =\n        await this._walletInstance.getExtensions();\n      return _extensions.map((e) => e.cip);\n    } catch (e) {\n      return [];\n    }\n  }\n\n  /**\n   * Returns the network ID of the currently connected account. 0 is testnet and 1 is mainnet but other networks can possibly be returned by wallets. Those other network ID values are not governed by CIP-30. This result will stay the same unless the connected account has changed.\n   *\n   * @returns network ID\n   */\n  getNetworkId(): Promise<number> {\n    return this._walletInstance.getNetworkId();\n  }\n\n  /**\n   * Returns a list of reward addresses owned by the wallet. A reward address is a stake address that is used to receive rewards from staking, generally starts from `stake` prefix.\n   *\n   * @returns a list of reward addresses\n   */\n  async getRewardAddresses(): Promise<string[]> {\n    const rewardAddresses = await this._walletInstance.getRewardAddresses();\n    return rewardAddresses.map((ra) => addressToBech32(deserializeAddress(ra)));\n  }\n\n  /**\n   * Returns a list of unused addresses controlled by the wallet.\n   *\n   * @returns a list of unused addresses\n   */\n  async getUnusedAddresses(): Promise<string[]> {\n    const unusedAddresses = await this._walletInstance.getUnusedAddresses();\n    return unusedAddresses.map((una) =>\n      addressToBech32(deserializeAddress(una)),\n    );\n  }\n\n  /**\n   * Returns a list of used addresses controlled by the wallet.\n   *\n   * @returns a list of used addresses\n   */\n  async getUsedAddresses(): Promise<string[]> {\n    const usedAddresses = await this._walletInstance.getUsedAddresses();\n    return usedAddresses.map((usa) => addressToBech32(deserializeAddress(usa)));\n  }\n\n  /**\n   * Return a list of all UTXOs (unspent transaction outputs) controlled by the wallet.\n   *\n   * @returns a list of UTXOs\n   */\n  async getUtxos(): Promise<UTxO[]> {\n    const deserializedUTxOs = await this.getUsedUTxOs();\n    return deserializedUTxOs.map((du) => fromTxUnspentOutput(du));\n  }\n\n  /**\n   * This endpoint utilizes the [CIP-8 - Message Signing](https://cips.cardano.org/cips/cip8/) to sign arbitrary data, to verify the data was signed by the owner of the private key.\n   *\n   * @param payload - the data to be signed\n   * @param address - optional, if not provided, the first staking address will be used\n   * @returns a signature\n   */\n  async signData(\n    payload: string,\n    address?: string | undefined,\n    convertFromUTF8 = true,\n  ): Promise<DataSignature> {\n    if (address === undefined) {\n      address = (await this.getUsedAddresses())[0]!;\n      if (address === undefined) {\n        address = await this.getChangeAddress();\n      }\n    }\n\n    const _payload = convertFromUTF8 ? fromUTF8(payload) : payload;\n\n    if (address.startsWith(\"drep1\")) {\n      return this._walletInstance.cip95!.signData(address, _payload);\n    }\n\n    const signerAddress = toAddress(address).toBytes().toString();\n    return this._walletInstance.signData(signerAddress, _payload);\n  }\n\n  /**\n   * Requests user to sign the provided transaction (tx). The wallet should ask the user for permission, and if given, try to sign the supplied body and return a signed transaction. partialSign should be true if the transaction provided requires multiple signatures.\n   *\n   * @param unsignedTx - a transaction in CBOR\n   * @param partialSign - if the transaction is signed partially\n   * @returns a signed transaction in CBOR\n   */\n  async signTx(unsignedTx: string, partialSign = false): Promise<string> {\n    const witness = await this._walletInstance.signTx(unsignedTx, partialSign);\n    if (witness === \"\") {\n      return unsignedTx;\n    }\n    return BrowserWallet.addBrowserWitnesses(unsignedTx, witness);\n  }\n\n  /**\n   * Experimental feature - sign multiple transactions at once (Supported wallet(s): Typhon)\n   *\n   * @param unsignedTxs - array of unsigned transactions in CborHex string\n   * @param partialSign - if the transactions are signed partially\n   * @returns array of signed transactions CborHex string\n   */\n  async signTxs(unsignedTxs: string[], partialSign = false): Promise<string[]> {\n    let witnessSets: string[] | undefined = undefined;\n    // Hardcoded behavior customized for different wallet for now as there is no standard confirmed\n    switch (this._walletName) {\n      case \"Typhon Wallet\":\n        if (this._walletInstance.signTxs) {\n          witnessSets = await this._walletInstance.signTxs(\n            unsignedTxs,\n            partialSign,\n          );\n        }\n        break;\n      default:\n        if (this._walletInstance.signTxs) {\n          witnessSets = await this._walletInstance.signTxs(\n            unsignedTxs.map((cbor) => ({\n              cbor,\n              partialSign,\n            })),\n          );\n        } else if (this._walletInstance.experimental.signTxs) {\n          witnessSets = await this._walletInstance.experimental.signTxs(\n            unsignedTxs.map((cbor) => ({\n              cbor,\n              partialSign,\n            })),\n          );\n        }\n        break;\n    }\n\n    if (!witnessSets) throw new Error(\"Wallet does not support signTxs\");\n\n    const signedTxs: string[] = [];\n    for (let i = 0; i < witnessSets.length; i++) {\n      const unsignedTx = unsignedTxs[i]!;\n      const cWitness = witnessSets[i]!;\n      if (cWitness === \"\") {\n        // It's possible that txs are signed just to give\n        // browser wallet the tx context\n        signedTxs.push(unsignedTx);\n      } else {\n        const signedTx = BrowserWallet.addBrowserWitnesses(\n          unsignedTx,\n          cWitness,\n        );\n        signedTxs.push(signedTx);\n      }\n    }\n\n    return signedTxs;\n  }\n\n  /**\n   * Submits the signed transaction to the blockchain network.\n   *\n   * As wallets should already have this ability to submit transaction, we allow apps to request that a transaction be sent through it. If the wallet accepts the transaction and tries to send it, it shall return the transaction ID for the app to track. The wallet can return error messages or failure if there was an error in sending it.\n   *\n   * @param tx\n   * @returns a transaction hash\n   */\n  submitTx(tx: string): Promise<string> {\n    return this._walletInstance.submitTx(tx);\n  }\n\n  /**\n   * Get a used address of type Address from the wallet.\n   *\n   * This is used in transaction building.\n   *\n   * @returns an Address object\n   */\n  async getUsedAddress(): Promise<Address> {\n    const usedAddresses = await this._walletInstance.getUsedAddresses();\n    if (usedAddresses.length === 0) throw new Error(\"No used addresses found\");\n    return deserializeAddress(usedAddresses[0]!);\n  }\n\n  /**\n   * Get a list of UTXOs to be used as collateral inputs for transactions with plutus script inputs.\n   *\n   * This is used in transaction building.\n   *\n   * @returns a list of UTXOs\n   */\n  async getCollateralUnspentOutput(\n    limit = DEFAULT_PROTOCOL_PARAMETERS.maxCollateralInputs,\n  ): Promise<TransactionUnspentOutput[]> {\n    let collateral: string[] = [];\n    try {\n      collateral = (await this._walletInstance.getCollateral()) ?? [];\n    } catch (e) {\n      try {\n        collateral =\n          (await this._walletInstance.experimental.getCollateral()) ?? [];\n      } catch (e) {\n        console.error(e);\n      }\n    }\n    return collateral.map((c) => deserializeTxUnspentOutput(c)).slice(0, limit);\n  }\n\n  /**\n   * Get a list of UTXOs to be used for transaction building.\n   *\n   * This is used in transaction building.\n   *\n   * @returns a list of UTXOs\n   */\n  async getUsedUTxOs(): Promise<TransactionUnspentOutput[]> {\n    const utxos = (await this._walletInstance.getUtxos()) ?? [];\n    return utxos.map((u) => deserializeTxUnspentOutput(u));\n  }\n\n  /**\n   * A helper function to get the assets in the wallet.\n   *\n   * @returns a list of assets\n   */\n  async getAssets(): Promise<AssetExtended[]> {\n    const balance = await this.getBalance();\n    return balance\n      .filter((v) => v.unit !== \"lovelace\")\n      .map((v) => {\n        const policyId = v.unit.slice(0, POLICY_ID_LENGTH);\n        const assetName = v.unit.slice(POLICY_ID_LENGTH);\n        const fingerprint = resolveFingerprint(policyId, assetName);\n\n        return {\n          unit: v.unit,\n          policyId,\n          assetName,\n          fingerprint,\n          quantity: v.quantity,\n        };\n      });\n  }\n\n  /**\n   * A helper function to get the lovelace balance in the wallet.\n   *\n   * @returns lovelace balance\n   */\n  async getLovelace(): Promise<string> {\n    const balance = await this.getBalance();\n    const nativeAsset = balance.find((v) => v.unit === \"lovelace\");\n\n    return nativeAsset !== undefined ? nativeAsset.quantity : \"0\";\n  }\n\n  /**\n   * A helper function to get the assets of a specific policy ID in the wallet.\n   *\n   * @param policyId\n   * @returns a list of assets\n   */\n  async getPolicyIdAssets(policyId: string): Promise<AssetExtended[]> {\n    const assets = await this.getAssets();\n    return assets.filter((v) => v.policyId === policyId);\n  }\n\n  /**\n   * A helper function to get the policy IDs of all the assets in the wallet.\n   *\n   * @returns a list of policy IDs\n   */\n  async getPolicyIds(): Promise<string[]> {\n    const balance = await this.getBalance();\n    return Array.from(\n      new Set(balance.map((v) => v.unit.slice(0, POLICY_ID_LENGTH))),\n    ).filter((p) => p !== \"lovelace\");\n  }\n\n  /**\n   * The connected wallet account provides the account's public DRep Key, derivation as described in CIP-0105.\n   * These are used by the client to identify the user's on-chain CIP-1694 interactions, i.e. if a user has registered to be a DRep.\n   *\n   * @returns DRep object\n   */\n  async getDRep(): Promise<\n    | {\n        publicKey: string;\n        publicKeyHash: string;\n        dRepIDCip105: string;\n      }\n    | undefined\n  > {\n    const pubDRepKey = await this.getPubDRepKey();\n    try {\n      if (pubDRepKey === undefined) return undefined;\n\n      const { dRepIDHash } = await BrowserWallet.dRepKeyToDRepID(pubDRepKey);\n\n      const dRepIDCip105 = hexToBech32(\"drep\", dRepIDHash);\n\n      // const dRepIDBech32 = buildDRepID(dRepKey, await this.getNetworkId());\n      // console.log(66, \"dRepIDBech32\", dRepIDBech32, dRepIDCip105 === dRepIDBech32);\n\n      return {\n        publicKey: pubDRepKey,\n        publicKeyHash: dRepIDHash,\n        dRepIDCip105: dRepIDCip105,\n      };\n    } catch (e) {\n      console.error(e);\n      return undefined;\n    }\n  }\n\n  /**\n   * The connected wallet account provides the account's public DRep Key, derivation as described in CIP-0105.\n   * These are used by the client to identify the user's on-chain CIP-1694 interactions, i.e. if a user has registered to be a DRep.\n   *\n   * @returns wallet account's public DRep Key\n   */\n  async getPubDRepKey(): Promise<string | undefined> {\n    try {\n      if (this._walletInstance.cip95 === undefined) return undefined;\n\n      const pubDRepKey = await this._walletInstance.cip95.getPubDRepKey();\n      return pubDRepKey;\n    } catch (e) {\n      console.error(e);\n      return undefined;\n    }\n  }\n\n  async getRegisteredPubStakeKeys(): Promise<\n    | {\n        pubStakeKeys: string[];\n        pubStakeKeyHashes: string[];\n      }\n    | undefined\n  > {\n    try {\n      if (this._walletInstance.cip95 === undefined) return undefined;\n\n      const pubStakeKeys =\n        await this._walletInstance.cip95.getRegisteredPubStakeKeys();\n\n      const pubStakeKeyHashes = await Promise.all(\n        pubStakeKeys.map(async (pubStakeKey) => {\n          const { dRepIDHash } =\n            await BrowserWallet.dRepKeyToDRepID(pubStakeKey);\n          return dRepIDHash;\n        }),\n      );\n\n      return {\n        pubStakeKeys: pubStakeKeys,\n        pubStakeKeyHashes: pubStakeKeyHashes,\n      };\n    } catch (e) {\n      console.error(e);\n      return undefined;\n    }\n  }\n\n  async getUnregisteredPubStakeKeys(): Promise<\n    | {\n        pubStakeKeys: string[];\n        pubStakeKeyHashes: string[];\n      }\n    | undefined\n  > {\n    try {\n      if (this._walletInstance.cip95 === undefined) return undefined;\n\n      const pubStakeKeys =\n        await this._walletInstance.cip95.getUnregisteredPubStakeKeys();\n\n      const pubStakeKeyHashes = await Promise.all(\n        pubStakeKeys.map(async (pubStakeKey) => {\n          const { dRepIDHash } =\n            await BrowserWallet.dRepKeyToDRepID(pubStakeKey);\n          return dRepIDHash;\n        }),\n      );\n\n      return {\n        pubStakeKeys: pubStakeKeys,\n        pubStakeKeyHashes: pubStakeKeyHashes,\n      };\n    } catch (e) {\n      console.error(e);\n      return undefined;\n    }\n  }\n\n  private static async dRepKeyToDRepID(dRepKey: string): Promise<{\n    dRepKeyHex: Ed25519PublicKeyHex;\n    dRepID: Ed25519PublicKey;\n    dRepIDHash: Ed25519KeyHashHex;\n  }> {\n    const dRepKeyHex = Ed25519PublicKeyHex(dRepKey);\n    const dRepID = Ed25519PublicKey.fromHex(dRepKeyHex);\n    const dRepIDHash = (await dRepID.hash()).hex();\n    return {\n      dRepKeyHex,\n      dRepID,\n      dRepIDHash,\n    };\n  }\n\n  private static resolveInstance(\n    walletName: string,\n    extensions: Extension[] = [],\n  ) {\n    if (window.cardano === undefined) return undefined;\n    if (window.cardano[walletName] === undefined) return undefined;\n\n    const wallet = window.cardano[walletName];\n\n    if (extensions.length > 0) {\n      return wallet.enable({ extensions: extensions });\n    } else {\n      return wallet?.enable();\n    }\n  }\n\n  static addBrowserWitnesses(unsignedTx: string, witnesses: string) {\n    const cWitness = Serialization.TransactionWitnessSet.fromCbor(\n      CardanoSDKUtil.HexBlob(witnesses),\n    )\n      .vkeys()\n      ?.values();\n\n    if (cWitness === undefined) {\n      return unsignedTx;\n    }\n\n    let tx = deserializeTx(unsignedTx);\n    // let tx = Transaction.fromCbor(CardanoSDK.TxCBOR(txHex));\n    let witnessSet = tx.witnessSet();\n    let witnessSetVkeys = witnessSet.vkeys();\n    let witnessSetVkeysValues: Serialization.VkeyWitness[] = witnessSetVkeys\n      ? [...witnessSetVkeys.values(), ...cWitness]\n      : [...cWitness];\n    witnessSet.setVkeys(\n      Serialization.CborSet.fromCore(\n        witnessSetVkeysValues.map((vkw) => vkw.toCore()),\n        VkeyWitness.fromCore,\n      ),\n    );\n\n    return new Transaction(tx.body(), witnessSet, tx.auxiliaryData()).toCbor();\n  }\n\n  static getSupportedExtensions(wallet: string) {\n    const _supportedExtensions = window?.cardano?.[wallet]?.supportedExtensions;\n    if (_supportedExtensions) return _supportedExtensions;\n    else return [];\n  }\n}\n",
      "dependencies": [
        "BrowserWallet"
      ],
      "source": "mesh-wallet",
      "isReExportFile": false
    },
    {
      "key": "mesh-wallet:browser.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/browser/index.ts",
      "name": "browser.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./browser-wallet\";\nexport * from \"./webauthn\";\n",
      "dependencies": [],
      "source": "mesh-wallet",
      "isReExportFile": false
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.connect.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/browser/webauthn/auth/connect.ts",
      "name": "browser.webauthn.auth.connect.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [
        {
          "name": "responseRegister",
          "type": "any",
          "value": "await register({ serverUrl, username });",
          "isPublic": true,
          "line": 15,
          "raw": "const responseRegister = await register({ serverUrl, username });",
          "source": "mesh-wallet"
        },
        {
          "name": "loginRes",
          "type": "any",
          "value": "await handleLogin({ serverUrl, username });",
          "isPublic": true,
          "line": 20,
          "raw": "const loginRes = await handleLogin({ serverUrl, username });",
          "source": "mesh-wallet"
        },
        {
          "name": "wallet",
          "type": "any",
          "value": "await buildWalletFromPasskey(",
          "isPublic": true,
          "line": 22,
          "raw": "const wallet = await buildWalletFromPasskey(",
          "source": "mesh-wallet"
        },
        {
          "name": "responseLogin",
          "type": "any",
          "value": "await login({ serverUrl, username });",
          "isPublic": true,
          "line": 41,
          "raw": "const responseLogin = await login({ serverUrl, username });",
          "source": "mesh-wallet"
        },
        {
          "name": "authJSON",
          "type": "any",
          "value": "responseLogin.authJSON;",
          "isPublic": true,
          "line": 43,
          "raw": "const authJSON = responseLogin.authJSON;",
          "source": "mesh-wallet"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { buildWalletFromPasskey } from \"../cardano/build-wallet-from-passkey\";\nimport { ERRORCODES } from \"../common\";\nimport { login } from \"./login\";\nimport { register } from \"./register\";\n\nexport async function connect({\n  username,\n  password,\n  serverUrl,\n}: {\n  username: string;\n  password: string;\n  serverUrl: string;\n}) {\n  const responseRegister = await register({ serverUrl, username });\n  if (\n    responseRegister.success ||\n    responseRegister.error.errorCode == ERRORCODES.USEREXISTS\n  ) {\n    const loginRes = await handleLogin({ serverUrl, username });\n    if (loginRes.success && loginRes.authJSON) {\n      const wallet = await buildWalletFromPasskey(\n        loginRes.authJSON.rawId,\n        password,\n      );\n      return { success: true, wallet: wallet };\n    }\n  } else {\n    return { success: false, error: responseRegister.error };\n  }\n  return { success: false, error: \"Fail to connect\" };\n}\n\nasync function handleLogin({\n  serverUrl,\n  username,\n}: {\n  serverUrl: string;\n  username: string;\n}) {\n  const responseLogin = await login({ serverUrl, username });\n  if (responseLogin.success && responseLogin.authJSON) {\n    const authJSON = responseLogin.authJSON;\n    return { success: true, authJSON: authJSON };\n  } else {\n    return { success: false, error: responseLogin.error };\n  }\n}\n",
      "dependencies": [],
      "source": "mesh-wallet",
      "isReExportFile": false
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/browser/webauthn/auth/index.ts",
      "name": "browser.webauthn.auth.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./connect\";\nexport * from \"./login\";\nexport * from \"./register\";\n",
      "dependencies": [],
      "source": "mesh-wallet",
      "isReExportFile": false
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.login.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/browser/webauthn/auth/login.ts",
      "name": "browser.webauthn.auth.login.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [
        {
          "name": "initAuthRes",
          "type": "any",
          "value": "await fetch(`${serverUrl}/auth-init`, {",
          "isPublic": true,
          "line": 11,
          "raw": "const initAuthRes = await fetch(`${serverUrl}/auth-init`, {",
          "source": "mesh-wallet"
        },
        {
          "name": "initAuth",
          "type": "any",
          "value": "await initAuthRes.json();",
          "isPublic": true,
          "line": 22,
          "raw": "const initAuth = await initAuthRes.json();",
          "source": "mesh-wallet"
        },
        {
          "name": "optionsJSON",
          "type": "any",
          "value": "initAuth.data.optionsJSON;",
          "isPublic": true,
          "line": 31,
          "raw": "const optionsJSON = initAuth.data.optionsJSON;",
          "source": "mesh-wallet"
        },
        {
          "name": "authJSON",
          "type": "any",
          "value": "await startAuthentication({ optionsJSON });",
          "isPublic": true,
          "line": 34,
          "raw": "const authJSON = await startAuthentication({ optionsJSON });",
          "source": "mesh-wallet"
        },
        {
          "name": "verifyAuthRes",
          "type": "any",
          "value": "await fetch(`${serverUrl}/auth-verify`, {",
          "isPublic": true,
          "line": 37,
          "raw": "const verifyAuthRes = await fetch(`${serverUrl}/auth-verify`, {",
          "source": "mesh-wallet"
        },
        {
          "name": "verifyAuth",
          "type": "any",
          "value": "await verifyAuthRes.json();",
          "isPublic": true,
          "line": 46,
          "raw": "const verifyAuth = await verifyAuthRes.json();",
          "source": "mesh-wallet"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { startAuthentication } from \"@simplewebauthn/browser\";\n\nexport async function login({\n  serverUrl,\n  username,\n}: {\n  serverUrl: string;\n  username: string;\n}) {\n  // 1. Get challenge from server\n  const initAuthRes = await fetch(`${serverUrl}/auth-init`, {\n    credentials: \"include\",\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      username,\n    }),\n  });\n\n  const initAuth = await initAuthRes.json();\n  if (!initAuth.success) {\n    return {\n      success: false,\n      error: initAuth.error,\n      errorCode: initAuth.errorCode,\n    };\n  }\n\n  const optionsJSON = initAuth.data.optionsJSON;\n\n  // 2. Get passkey\n  const authJSON = await startAuthentication({ optionsJSON });\n\n  // 3. Verify passkey with DB\n  const verifyAuthRes = await fetch(`${serverUrl}/auth-verify`, {\n    credentials: \"include\",\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(authJSON),\n  });\n\n  const verifyAuth = await verifyAuthRes.json();\n\n  if (!verifyAuthRes.ok) {\n    return { success: false, error: verifyAuth.error };\n  }\n  if (verifyAuth.data.verified) {\n    return { success: true, authJSON: authJSON };\n  } else {\n    return { success: false, error: \"Failed to log in\" };\n  }\n}\n",
      "dependencies": [],
      "source": "mesh-wallet",
      "isReExportFile": false
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.register.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/browser/webauthn/auth/register.ts",
      "name": "browser.webauthn.auth.register.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [
        {
          "name": "initRegisterRes",
          "type": "any",
          "value": "await fetch(`${serverUrl}/register-init`, {",
          "isPublic": true,
          "line": 11,
          "raw": "const initRegisterRes = await fetch(`${serverUrl}/register-init`, {",
          "source": "mesh-wallet"
        },
        {
          "name": "initRegister",
          "type": "any",
          "value": "await initRegisterRes.json();",
          "isPublic": true,
          "line": 21,
          "raw": "const initRegister = await initRegisterRes.json();",
          "source": "mesh-wallet"
        },
        {
          "name": "optionsJSON",
          "type": "any",
          "value": "initRegister.data.optionsJSON;",
          "isPublic": true,
          "line": 31,
          "raw": "const optionsJSON = initRegister.data.optionsJSON;",
          "source": "mesh-wallet"
        },
        {
          "name": "registrationJSON",
          "type": "any",
          "value": "await startRegistration({ optionsJSON });",
          "isPublic": true,
          "line": 32,
          "raw": "const registrationJSON = await startRegistration({ optionsJSON });",
          "source": "mesh-wallet"
        },
        {
          "name": "verifyResponse",
          "type": "any",
          "value": "await fetch(`${serverUrl}/register-verify`, {",
          "isPublic": true,
          "line": 35,
          "raw": "const verifyResponse = await fetch(`${serverUrl}/register-verify`, {",
          "source": "mesh-wallet"
        },
        {
          "name": "verifyData",
          "type": "any",
          "value": "await verifyResponse.json();",
          "isPublic": true,
          "line": 44,
          "raw": "const verifyData = await verifyResponse.json();",
          "source": "mesh-wallet"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { startRegistration } from \"@simplewebauthn/browser\";\n\nexport async function register({\n  serverUrl,\n  username,\n}: {\n  serverUrl: string;\n  username: string;\n}) {\n  // 1. Get challenge from server\n  const initRegisterRes = await fetch(`${serverUrl}/register-init`, {\n    credentials: \"include\",\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      username,\n    }),\n  });\n  const initRegister = await initRegisterRes.json();\n  if (!initRegister.success) {\n    return {\n      success: false,\n      error: initRegister.error,\n      errorCode: initRegister.errorCode,\n    };\n  }\n\n  // 2. Create passkey\n  const optionsJSON = initRegister.data.optionsJSON;\n  const registrationJSON = await startRegistration({ optionsJSON });\n\n  // 3. Save passkey in DB\n  const verifyResponse = await fetch(`${serverUrl}/register-verify`, {\n    credentials: \"include\",\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(registrationJSON),\n  });\n\n  const verifyData = await verifyResponse.json();\n  if (!verifyResponse.ok) {\n    console.error(verifyData.error);\n    return {\n      success: false,\n      error: verifyData.error,\n      errorCode: verifyData.errorCode,\n    };\n  }\n  if (verifyData.data.verified) {\n    console.log(`Successfully registered ${username}`);\n    return { success: true };\n  } else {\n    console.error(`Failed to register`);\n    return { success: false, error: \"Failed to register\", errorCode: 1 };\n  }\n}\n",
      "dependencies": [],
      "source": "mesh-wallet",
      "isReExportFile": false
    },
    {
      "key": "mesh-wallet:browser.webauthn.cardano.build-wallet-from-passkey.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/browser/webauthn/cardano/build-wallet-from-passkey.ts",
      "name": "browser.webauthn.cardano.build-wallet-from-passkey.ts",
      "imports": [],
      "functions": [
        {
          "name": "buildKey",
          "signature": "function buildKey(entropy: Buffer, password: string) {",
          "documentation": "",
          "parameters": [
            {
              "name": "entropy",
              "type": "Buffer",
              "optional": false
            },
            {
              "name": "password",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 15,
          "raw": "function buildKey(entropy: Buffer, password: string) {\n  const bip32Key = Crypto.Bip32PrivateKey.fromBip39Entropy(entropy, password);\n\n  const bytes = base32.encode(bip32Key.bytes());\n  const bech32PrivateKey = bech32.encode(\"xprv\", bytes, 1023);\n\n  return {\n    bech32PrivateKey: bech32PrivateKey,\n  };\n}",
          "source": "mesh-wallet",
          "implementation": "function buildKey(entropy: Buffer, password: string) {\n  const bip32Key = Crypto.Bip32PrivateKey.fromBip39Entropy(entropy, password);\n\n  const bytes = base32.encode(bip32Key.bytes());\n  const bech32PrivateKey = bech32.encode(\"xprv\", bytes, 1023);\n\n  return {\n    bech32PrivateKey: bech32PrivateKey,\n  };\n}"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "entropy",
          "type": "any",
          "value": "await createEntropy(rawId, appSalt);",
          "isPublic": true,
          "line": 11,
          "raw": "const entropy = await createEntropy(rawId, appSalt);",
          "source": "mesh-wallet"
        },
        {
          "name": "bip32Key",
          "type": "any",
          "value": "Crypto.Bip32PrivateKey.fromBip39Entropy(entropy, password);",
          "isPublic": true,
          "line": 16,
          "raw": "const bip32Key = Crypto.Bip32PrivateKey.fromBip39Entropy(entropy, password);",
          "source": "mesh-wallet"
        },
        {
          "name": "bytes",
          "type": "any",
          "value": "base32.encode(bip32Key.bytes());",
          "isPublic": true,
          "line": 18,
          "raw": "const bytes = base32.encode(bip32Key.bytes());",
          "source": "mesh-wallet"
        },
        {
          "name": "bech32PrivateKey",
          "type": "any",
          "value": "bech32.encode(\"xprv\", bytes, 1023);",
          "isPublic": true,
          "line": 19,
          "raw": "const bech32PrivateKey = bech32.encode(\"xprv\", bytes, 1023);",
          "source": "mesh-wallet"
        },
        {
          "name": "rawIdBytes",
          "type": "any",
          "value": "new Uint8Array(new TextEncoder().encode(rawId));",
          "isPublic": true,
          "line": 28,
          "raw": "const rawIdBytes = new Uint8Array(new TextEncoder().encode(rawId));",
          "source": "mesh-wallet"
        },
        {
          "name": "saltBytes",
          "type": "any",
          "value": "new TextEncoder().encode(appSalt);",
          "isPublic": true,
          "line": 31,
          "raw": "const saltBytes = new TextEncoder().encode(appSalt);",
          "source": "mesh-wallet"
        },
        {
          "name": "entropyBuffer",
          "type": "any",
          "value": "new Uint8Array([...rawIdBytes, ...saltBytes]);",
          "isPublic": true,
          "line": 33,
          "raw": "const entropyBuffer = new Uint8Array([...rawIdBytes, ...saltBytes]);",
          "source": "mesh-wallet"
        },
        {
          "name": "entropy",
          "type": "any",
          "value": "await crypto.subtle.digest(\"SHA-256\", entropyBuffer);",
          "isPublic": true,
          "line": 36,
          "raw": "const entropy = await crypto.subtle.digest(\"SHA-256\", entropyBuffer);",
          "source": "mesh-wallet"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import base32 from \"base32-encoding\";\nimport { bech32 } from \"bech32\";\n\nimport { Crypto } from \"@meshsdk/core-cst\";\n\nexport async function buildWalletFromPasskey(\n  rawId: string,\n  password: string,\n  appSalt = \"appSalt\",\n) {\n  const entropy = await createEntropy(rawId, appSalt);\n  return buildKey(Buffer.from(entropy), password);\n}\n\nfunction buildKey(entropy: Buffer, password: string) {\n  const bip32Key = Crypto.Bip32PrivateKey.fromBip39Entropy(entropy, password);\n\n  const bytes = base32.encode(bip32Key.bytes());\n  const bech32PrivateKey = bech32.encode(\"xprv\", bytes, 1023);\n\n  return {\n    bech32PrivateKey: bech32PrivateKey,\n  };\n}\n\nasync function createEntropy(rawId: string, appSalt: string) {\n  // The rawId is inherently unique for each Passkey, ensuring no two users have the same derived entropy.\n  const rawIdBytes = new Uint8Array(new TextEncoder().encode(rawId));\n\n  // Combine with app-specific salt, using an app-specific salt ensures that the same rawId cannot be reused across different applications.\n  const saltBytes = new TextEncoder().encode(appSalt);\n\n  const entropyBuffer = new Uint8Array([...rawIdBytes, ...saltBytes]);\n\n  // Hash the combined data to produce 256-bit entropy\n  const entropy = await crypto.subtle.digest(\"SHA-256\", entropyBuffer);\n\n  return entropy;\n}\n",
      "dependencies": [],
      "source": "mesh-wallet",
      "isReExportFile": false
    },
    {
      "key": "mesh-wallet:browser.webauthn.common.error-codes.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/browser/webauthn/common/error-codes/index.ts",
      "name": "browser.webauthn.common.error-codes.index.ts",
      "imports": [
        {
          "module": "ERRORCODES",
          "items": [],
          "line": 1,
          "raw": "export const ERRORCODES = {",
          "source": "mesh-wallet"
        }
      ],
      "functions": [],
      "types": [],
      "constants": [
        {
          "name": "ERRORCODES",
          "type": "any",
          "value": "{",
          "isPublic": true,
          "line": 1,
          "raw": "export const ERRORCODES = {",
          "source": "mesh-wallet"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export const ERRORCODES = {\n  USEREXISTS: 1,\n};\n",
      "dependencies": [
        "ERRORCODES"
      ],
      "source": "mesh-wallet",
      "isReExportFile": false
    },
    {
      "key": "mesh-wallet:browser.webauthn.common.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/browser/webauthn/common/index.ts",
      "name": "browser.webauthn.common.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./error-codes\";\n",
      "dependencies": [],
      "source": "mesh-wallet",
      "isReExportFile": false
    },
    {
      "key": "mesh-wallet:browser.webauthn.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/browser/webauthn/index.ts",
      "name": "browser.webauthn.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./auth\";\n",
      "dependencies": [],
      "source": "mesh-wallet",
      "isReExportFile": false
    },
    {
      "key": "mesh-wallet:embedded.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/embedded/index.ts",
      "name": "embedded.index.ts",
      "imports": [
        {
          "module": "AccountType",
          "items": [],
          "line": 36,
          "raw": "export type AccountType = \"payment\" | \"stake\" | \"drep\";",
          "source": "mesh-wallet"
        },
        {
          "module": "Account",
          "items": [],
          "line": 38,
          "raw": "export type Account = {",
          "source": "mesh-wallet"
        },
        {
          "module": "EmbeddedWalletKeyType",
          "items": [],
          "line": 57,
          "raw": "export type EmbeddedWalletKeyType =",
          "source": "mesh-wallet"
        },
        {
          "module": "CreateEmbeddedWalletOptions",
          "items": [],
          "line": 76,
          "raw": "export type CreateEmbeddedWalletOptions = {",
          "source": "mesh-wallet"
        },
        {
          "module": "WalletStaticMethods",
          "items": [],
          "line": 81,
          "raw": "export class WalletStaticMethods {",
          "source": "mesh-wallet"
        },
        {
          "module": "EmbeddedWallet",
          "items": [],
          "line": 199,
          "raw": "export class EmbeddedWallet extends WalletStaticMethods {",
          "source": "mesh-wallet"
        }
      ],
      "functions": [
        {
          "name": "getAccount",
          "signature": "getAccount(accountIndex = 0, keyIndex = 0): Account {",
          "documentation": "",
          "parameters": [
            {
              "name": "accountIndex",
              "type": "any",
              "optional": false
            },
            {
              "name": "keyIndex",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "Account",
          "isPublic": true,
          "line": 239,
          "raw": "  getAccount(accountIndex = 0, keyIndex = 0): Account {\n    if (this._walletSecret == undefined)\n      throw new Error(\"[EmbeddedWallet] No keys initialized\");\n\n    const { paymentKey, stakeKey, dRepKey } = buildKeys(\n      this._walletSecret,\n      accountIndex,\n      keyIndex,\n    );\n\n    const { baseAddress, enterpriseAddress, rewardAddress } =\n      WalletStaticMethods.getAddresses(paymentKey, stakeKey, this._networkId);\n\n    let _account: Account = {\n      baseAddress: baseAddress,\n      enterpriseAddress: enterpriseAddress,\n      rewardAddress: rewardAddress,\n\n      baseAddressBech32: baseAddress.toBech32(),\n      enterpriseAddressBech32: enterpriseAddress.toBech32(),\n      rewardAddressBech32: rewardAddress.toBech32(),\n\n      paymentKey: paymentKey,\n      stakeKey: stakeKey,\n      paymentKeyHex: paymentKey.hex(),\n      stakeKeyHex: stakeKey.hex(),\n    };\n\n    if (dRepKey) {\n      const { pubDRepKey, dRepIDBech32, dRepIDHash, dRepIDCip105 } =\n        WalletStaticMethods.getDRepKey(dRepKey, this._networkId);\n      _account.drepKey = dRepKey;\n      _account.pubDRepKey = pubDRepKey;\n      _account.dRepIDBech32 = dRepIDBech32;\n      _account.dRepIDHash = dRepIDHash;\n      _account.dRepIDCip105 = dRepIDCip105;\n    }\n\n    return _account;\n  }",
          "source": "mesh-wallet",
          "implementation": "  getAccount(accountIndex = 0, keyIndex = 0): Account {\n    if (this._walletSecret == undefined)\n      throw new Error(\"[EmbeddedWallet] No keys initialized\");\n\n    const { paymentKey, stakeKey, dRepKey } = buildKeys(\n      this._walletSecret,\n      accountIndex,\n      keyIndex,\n    );\n\n    const { baseAddress, enterpriseAddress, rewardAddress } =\n      WalletStaticMethods.getAddresses(paymentKey, stakeKey, this._networkId);\n\n    let _account: Account = {\n      baseAddress: baseAddress,\n      enterpriseAddress: enterpriseAddress,\n      rewardAddress: rewardAddress,\n\n      baseAddressBech32: baseAddress.toBech32(),\n      enterpriseAddressBech32: enterpriseAddress.toBech32(),\n      rewardAddressBech32: rewardAddress.toBech32(),\n\n      paymentKey: paymentKey,\n      stakeKey: stakeKey,\n      paymentKeyHex: paymentKey.hex(),\n      stakeKeyHex: stakeKey.hex(),\n    };\n\n    if (dRepKey) {\n      const { pubDRepKey, dRepIDBech32, dRepIDHash, dRepIDCip105 } =\n        WalletStaticMethods.getDRepKey(dRepKey, this._networkId);\n      _account.drepKey = dRepKey;\n      _account.pubDRepKey = pubDRepKey;\n      _account.dRepIDBech32 = dRepIDBech32;\n      _account.dRepIDHash = dRepIDHash;\n      _account.dRepIDCip105 = dRepIDCip105;\n    }\n\n    return _account;\n  }"
        },
        {
          "name": "getNetworkId",
          "signature": "getNetworkId(): number {",
          "documentation": "  /**\n   * Get wallet network ID.\n   *\n   * @returns network ID\n   */",
          "parameters": [],
          "returnType": "number",
          "isPublic": true,
          "line": 285,
          "raw": "  /**\n   * Get wallet network ID.\n   *\n   * @returns network ID\n   */\n  getNetworkId(): number {\n    return this._networkId;\n  }",
          "source": "mesh-wallet",
          "implementation": "  getNetworkId(): number {\n    return this._networkId;\n  }"
        }
      ],
      "types": [
        {
          "name": "AccountType",
          "definition": "export type AccountType = \"payment\" | \"stake\" | \"drep\";",
          "isPublic": true,
          "line": 36,
          "raw": "export type AccountType = \"payment\" | \"stake\" | \"drep\";",
          "source": "mesh-wallet"
        },
        {
          "name": "Account",
          "definition": "export type Account = {\n  baseAddress: Address;\n  enterpriseAddress: Address;",
          "isPublic": true,
          "line": 38,
          "raw": "export type Account = {",
          "source": "mesh-wallet"
        },
        {
          "name": "EmbeddedWalletKeyType",
          "definition": "export type EmbeddedWalletKeyType =\n  | {\n      type: \"root\";\n      bech32: string;",
          "isPublic": true,
          "line": 57,
          "raw": "export type EmbeddedWalletKeyType =",
          "source": "mesh-wallet"
        },
        {
          "name": "CreateEmbeddedWalletOptions",
          "definition": "export type CreateEmbeddedWalletOptions = {\n  networkId: number;\n  key: EmbeddedWalletKeyType;",
          "isPublic": true,
          "line": 76,
          "raw": "export type CreateEmbeddedWalletOptions = {",
          "source": "mesh-wallet"
        }
      ],
      "constants": [
        {
          "name": "bech32DecodedBytes",
          "type": "any",
          "value": "BaseEncoding.bech32.decodeToBytes(_bech32).bytes;",
          "isPublic": true,
          "line": 83,
          "raw": "const bech32DecodedBytes = BaseEncoding.bech32.decodeToBytes(_bech32).bytes;",
          "source": "mesh-wallet"
        },
        {
          "name": "bip32PrivateKey",
          "type": "any",
          "value": "Bip32PrivateKey.fromBytes(bech32DecodedBytes);",
          "isPublic": true,
          "line": 84,
          "raw": "const bip32PrivateKey = Bip32PrivateKey.fromBytes(bech32DecodedBytes);",
          "source": "mesh-wallet"
        },
        {
          "name": "entropy",
          "type": "any",
          "value": "mnemonicToEntropy(words.join(\" \"));",
          "isPublic": true,
          "line": 89,
          "raw": "const entropy = mnemonicToEntropy(words.join(\" \"));",
          "source": "mesh-wallet"
        },
        {
          "name": "bip32PrivateKey",
          "type": "any",
          "value": "buildBip32PrivateKey(entropy);",
          "isPublic": true,
          "line": 90,
          "raw": "const bip32PrivateKey = buildBip32PrivateKey(entropy);",
          "source": "mesh-wallet"
        },
        {
          "name": "bip32PrivateKey",
          "type": "any",
          "value": "Bip32PrivateKey.fromBytes(bip32Bytes);",
          "isPublic": true,
          "line": 105,
          "raw": "const bip32PrivateKey = Bip32PrivateKey.fromBytes(bip32Bytes);",
          "source": "mesh-wallet"
        },
        {
          "name": "baseAddress",
          "type": "any",
          "value": "buildBaseAddress(",
          "isPublic": true,
          "line": 118,
          "raw": "const baseAddress = buildBaseAddress(",
          "source": "mesh-wallet"
        },
        {
          "name": "enterpriseAddress",
          "type": "any",
          "value": "buildEnterpriseAddress(",
          "isPublic": true,
          "line": 128,
          "raw": "const enterpriseAddress = buildEnterpriseAddress(",
          "source": "mesh-wallet"
        },
        {
          "name": "rewardAddress",
          "type": "any",
          "value": "buildRewardAddress(",
          "isPublic": true,
          "line": 135,
          "raw": "const rewardAddress = buildRewardAddress(",
          "source": "mesh-wallet"
        },
        {
          "name": "pubDRepKey",
          "type": "any",
          "value": "dRepKey.toPublic().hex().toString();",
          "isPublic": true,
          "line": 158,
          "raw": "const pubDRepKey = dRepKey.toPublic().hex().toString();",
          "source": "mesh-wallet"
        },
        {
          "name": "dRepIDBech32",
          "type": "any",
          "value": "buildDRepID(",
          "isPublic": true,
          "line": 160,
          "raw": "const dRepIDBech32 = buildDRepID(",
          "source": "mesh-wallet"
        },
        {
          "name": "dRep",
          "type": "any",
          "value": "DRep.newKeyHash(dRepKey.toPublic().hash().hex());",
          "isPublic": true,
          "line": 164,
          "raw": "const dRep = DRep.newKeyHash(dRepKey.toPublic().hash().hex());",
          "source": "mesh-wallet"
        },
        {
          "name": "dRepIDHash",
          "type": "any",
          "value": "dRep.toKeyHash()!;",
          "isPublic": true,
          "line": 165,
          "raw": "const dRepIDHash = dRep.toKeyHash()!;",
          "source": "mesh-wallet"
        },
        {
          "name": "dRepIDCip105",
          "type": "any",
          "value": "hexToBech32(\"drep\", dRepIDHash);",
          "isPublic": true,
          "line": 167,
          "raw": "const dRepIDCip105 = hexToBech32(\"drep\", dRepIDHash);",
          "source": "mesh-wallet"
        },
        {
          "name": "mnemonic",
          "type": "any",
          "value": "generateMnemonic(strength);",
          "isPublic": true,
          "line": 178,
          "raw": "const mnemonic = generateMnemonic(strength);",
          "source": "mesh-wallet"
        },
        {
          "name": "foundAddress",
          "type": "any",
          "value": "[baseAddress, enterpriseAddress, rewardAddress].find(",
          "isPublic": true,
          "line": 307,
          "raw": "const foundAddress = [baseAddress, enterpriseAddress, rewardAddress].find(",
          "source": "mesh-wallet"
        },
        {
          "name": "txHash",
          "type": "any",
          "value": "deserializeTxHash(resolveTxHash(unsignedTx));",
          "isPublic": true,
          "line": 344,
          "raw": "const txHash = deserializeTxHash(resolveTxHash(unsignedTx));",
          "source": "mesh-wallet"
        },
        {
          "name": "vKeyWitness",
          "type": "any",
          "value": "new VkeyWitness(",
          "isPublic": true,
          "line": 359,
          "raw": "const vKeyWitness = new VkeyWitness(",
          "source": "mesh-wallet"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import * as BaseEncoding from \"@scure/base\";\n\nimport {\n  bytesToHex,\n  DataSignature,\n  generateMnemonic,\n  mnemonicToEntropy,\n} from \"@meshsdk/common\";\nimport {\n  Address,\n  Bip32PrivateKey,\n  buildBaseAddress,\n  buildBip32PrivateKey,\n  buildDRepID,\n  buildEnterpriseAddress,\n  buildKeys,\n  buildRewardAddress,\n  Crypto,\n  deserializeTx,\n  deserializeTxHash,\n  DRep,\n  DRepID,\n  Ed25519KeyHashHex,\n  Ed25519PrivateKey,\n  Ed25519PublicKeyHex,\n  Hash28ByteBase16,\n  HexBlob,\n  hexToBech32,\n  resolveTxHash,\n  Serialization,\n  signData,\n  Transaction,\n  VkeyWitness,\n} from \"@meshsdk/core-cst\";\n\nexport type AccountType = \"payment\" | \"stake\" | \"drep\";\n\nexport type Account = {\n  baseAddress: Address;\n  enterpriseAddress: Address;\n  rewardAddress: Address;\n  baseAddressBech32: string;\n  enterpriseAddressBech32: string;\n  rewardAddressBech32: string;\n  paymentKey: Ed25519PrivateKey;\n  stakeKey: Ed25519PrivateKey;\n  paymentKeyHex: string;\n  stakeKeyHex: string;\n\n  drepKey?: Ed25519PrivateKey;\n  pubDRepKey?: string;\n  dRepIDBech32?: DRepID;\n  dRepIDHash?: Ed25519KeyHashHex;\n  dRepIDCip105?: string;\n};\n\nexport type EmbeddedWalletKeyType =\n  | {\n      type: \"root\";\n      bech32: string;\n    }\n  | {\n      type: \"cli\";\n      payment: string;\n      stake?: string;\n    }\n  | {\n      type: \"mnemonic\";\n      words: string[];\n    }\n  | {\n      type: \"bip32Bytes\";\n      bip32Bytes: Uint8Array;\n    };\n\nexport type CreateEmbeddedWalletOptions = {\n  networkId: number;\n  key: EmbeddedWalletKeyType;\n};\n\nexport class WalletStaticMethods {\n  static privateKeyBech32ToPrivateKeyHex(_bech32: string): string {\n    const bech32DecodedBytes = BaseEncoding.bech32.decodeToBytes(_bech32).bytes;\n    const bip32PrivateKey = Bip32PrivateKey.fromBytes(bech32DecodedBytes);\n    return bytesToHex(bip32PrivateKey.bytes());\n  }\n\n  static mnemonicToPrivateKeyHex(words: string[]): string {\n    const entropy = mnemonicToEntropy(words.join(\" \"));\n    const bip32PrivateKey = buildBip32PrivateKey(entropy);\n    return bytesToHex(bip32PrivateKey.bytes());\n  }\n\n  static signingKeyToHexes(\n    paymentKey: string,\n    stakeKey: string,\n  ): [string, string] {\n    return [\n      paymentKey.startsWith(\"5820\") ? paymentKey.slice(4) : paymentKey,\n      stakeKey.startsWith(\"5820\") ? stakeKey.slice(4) : stakeKey,\n    ];\n  }\n\n  static bip32BytesToPrivateKeyHex(bip32Bytes: Uint8Array): string {\n    const bip32PrivateKey = Bip32PrivateKey.fromBytes(bip32Bytes);\n    return bytesToHex(bip32PrivateKey.bytes());\n  }\n\n  static getAddresses(\n    paymentKey: Ed25519PrivateKey,\n    stakingKey: Ed25519PrivateKey,\n    networkId = 0,\n  ): {\n    baseAddress: Address;\n    enterpriseAddress: Address;\n    rewardAddress: Address;\n  } {\n    const baseAddress = buildBaseAddress(\n      networkId,\n      Hash28ByteBase16.fromEd25519KeyHashHex(\n        paymentKey.toPublic().hash().hex(),\n      ),\n      Hash28ByteBase16.fromEd25519KeyHashHex(\n        stakingKey.toPublic().hash().hex(),\n      ),\n    ).toAddress();\n\n    const enterpriseAddress = buildEnterpriseAddress(\n      networkId,\n      Hash28ByteBase16.fromEd25519KeyHashHex(\n        paymentKey.toPublic().hash().hex(),\n      ),\n    ).toAddress();\n\n    const rewardAddress = buildRewardAddress(\n      networkId,\n      Hash28ByteBase16.fromEd25519KeyHashHex(\n        stakingKey.toPublic().hash().hex(),\n      ),\n    ).toAddress();\n\n    return {\n      baseAddress: baseAddress,\n      enterpriseAddress: enterpriseAddress,\n      rewardAddress: rewardAddress,\n    };\n  }\n\n  static getDRepKey(\n    dRepKey: Ed25519PrivateKey,\n    networkId = 0,\n  ): {\n    pubDRepKey: string;\n    dRepIDBech32: DRepID;\n    dRepIDHash: Ed25519KeyHashHex;\n    dRepIDCip105: string;\n  } {\n    const pubDRepKey = dRepKey.toPublic().hex().toString();\n\n    const dRepIDBech32 = buildDRepID(\n      Ed25519PublicKeyHex(pubDRepKey),\n      networkId,\n    );\n    const dRep = DRep.newKeyHash(dRepKey.toPublic().hash().hex());\n    const dRepIDHash = dRep.toKeyHash()!;\n\n    const dRepIDCip105 = hexToBech32(\"drep\", dRepIDHash);\n\n    return {\n      pubDRepKey,\n      dRepIDBech32,\n      dRepIDHash,\n      dRepIDCip105,\n    };\n  }\n\n  static generateMnemonic(strength = 256): string[] {\n    const mnemonic = generateMnemonic(strength);\n    return mnemonic.split(\" \");\n  }\n\n  static addWitnessSets(txHex: string, witnesses: VkeyWitness[]): string {\n    let tx = deserializeTx(txHex);\n    let witnessSet = tx.witnessSet();\n    let witnessSetVkeys = witnessSet.vkeys();\n    let witnessSetVkeysValues: Serialization.VkeyWitness[] = witnessSetVkeys\n      ? [...witnessSetVkeys.values(), ...witnesses]\n      : witnesses;\n    witnessSet.setVkeys(\n      Serialization.CborSet.fromCore(\n        witnessSetVkeysValues.map((vkw) => vkw.toCore()),\n        VkeyWitness.fromCore,\n      ),\n    );\n    return new Transaction(tx.body(), witnessSet, tx.auxiliaryData()).toCbor();\n  }\n}\n\nexport class EmbeddedWallet extends WalletStaticMethods {\n  private readonly _walletSecret?: string | [string, string];\n  private readonly _networkId: number;\n  cryptoIsReady: boolean = false;\n\n  constructor(options: CreateEmbeddedWalletOptions) {\n    super();\n    this._networkId = options.networkId;\n\n    switch (options.key.type) {\n      case \"mnemonic\":\n        this._walletSecret = WalletStaticMethods.mnemonicToPrivateKeyHex(\n          options.key.words,\n        );\n        break;\n      case \"root\":\n        this._walletSecret =\n          WalletStaticMethods.privateKeyBech32ToPrivateKeyHex(\n            options.key.bech32,\n          );\n        break;\n      case \"cli\":\n        this._walletSecret = WalletStaticMethods.signingKeyToHexes(\n          options.key.payment,\n          options.key.stake ?? \"f0\".repeat(32),\n        );\n        break;\n      case \"bip32Bytes\":\n        this._walletSecret = WalletStaticMethods.bip32BytesToPrivateKeyHex(\n          options.key.bip32Bytes,\n        );\n        break;\n    }\n  }\n\n  async init(): Promise<void> {\n    await Crypto.ready();\n    this.cryptoIsReady = true;\n  }\n\n  getAccount(accountIndex = 0, keyIndex = 0): Account {\n    if (this._walletSecret == undefined)\n      throw new Error(\"[EmbeddedWallet] No keys initialized\");\n\n    const { paymentKey, stakeKey, dRepKey } = buildKeys(\n      this._walletSecret,\n      accountIndex,\n      keyIndex,\n    );\n\n    const { baseAddress, enterpriseAddress, rewardAddress } =\n      WalletStaticMethods.getAddresses(paymentKey, stakeKey, this._networkId);\n\n    let _account: Account = {\n      baseAddress: baseAddress,\n      enterpriseAddress: enterpriseAddress,\n      rewardAddress: rewardAddress,\n\n      baseAddressBech32: baseAddress.toBech32(),\n      enterpriseAddressBech32: enterpriseAddress.toBech32(),\n      rewardAddressBech32: rewardAddress.toBech32(),\n\n      paymentKey: paymentKey,\n      stakeKey: stakeKey,\n      paymentKeyHex: paymentKey.hex(),\n      stakeKeyHex: stakeKey.hex(),\n    };\n\n    if (dRepKey) {\n      const { pubDRepKey, dRepIDBech32, dRepIDHash, dRepIDCip105 } =\n        WalletStaticMethods.getDRepKey(dRepKey, this._networkId);\n      _account.drepKey = dRepKey;\n      _account.pubDRepKey = pubDRepKey;\n      _account.dRepIDBech32 = dRepIDBech32;\n      _account.dRepIDHash = dRepIDHash;\n      _account.dRepIDCip105 = dRepIDCip105;\n    }\n\n    return _account;\n  }\n\n  /**\n   * Get wallet network ID.\n   *\n   * @returns network ID\n   */\n  getNetworkId(): number {\n    return this._networkId;\n  }\n\n  /**\n   * This endpoint utilizes the [CIP-8 - Message Signing](https://cips.cardano.org/cips/cip8/) to sign arbitrary data, to verify the data was signed by the owner of the private key.\n   *\n   * @param address - bech32 address to sign the data with\n   * @param payload - the data to be signed\n   * @param accountIndex account index (default: 0)\n   * @returns a signature\n   */\n  signData(\n    address: string,\n    payload: string,\n    accountIndex = 0,\n    keyIndex = 0,\n  ): DataSignature {\n    try {\n      const { baseAddress, enterpriseAddress, rewardAddress, paymentKey } =\n        this.getAccount(accountIndex, keyIndex);\n\n      const foundAddress = [baseAddress, enterpriseAddress, rewardAddress].find(\n        (a) => a.toBech32() === address,\n      );\n\n      if (foundAddress === undefined)\n        throw new Error(\n          `[EmbeddedWallet] Address: ${address} doesn't belong to this account.`,\n        );\n\n      // todo tw\n      return signData(payload, {\n        address: Address.fromBech32(address),\n        key: paymentKey,\n      });\n    } catch (error) {\n      throw new Error(\n        `[EmbeddedWallet] An error occurred during signData: ${error}.`,\n      );\n    }\n  }\n\n  /**\n   * This endpoints sign the provided transaction (unsignedTx) with the private key of the owner.\n   *\n   * @param unsignedTx - a transaction in CBOR\n   * @param accountIndex account index (default: 0)\n   * @param keyIndex key index (default: 0)\n   * @param accountType - type of the account (default: payment)\n   * @returns VkeyWitness\n   */\n  signTx(\n    unsignedTx: string,\n    accountIndex = 0,\n    keyIndex = 0,\n    accountType: AccountType = \"payment\",\n  ): VkeyWitness {\n    try {\n      const txHash = deserializeTxHash(resolveTxHash(unsignedTx));\n\n      const { paymentKey, stakeKey, drepKey } = this.getAccount(\n        accountIndex,\n        keyIndex,\n      );\n\n      let key = paymentKey;\n      if (accountType === \"stake\") {\n        key = stakeKey;\n      } else if (accountType === \"drep\") {\n        if (!drepKey) throw new Error(\"DRep key not found\");\n        key = drepKey;\n      }\n\n      const vKeyWitness = new VkeyWitness(\n        key.toPublic().hex(),\n        key.sign(HexBlob(txHash)).hex(),\n      );\n\n      return vKeyWitness;\n    } catch (error) {\n      throw new Error(\n        `[EmbeddedWallet] An error occurred during signTx: ${error}.`,\n      );\n    }\n  }\n}\n",
      "dependencies": [
        "AccountType",
        "Account",
        "EmbeddedWalletKeyType",
        "CreateEmbeddedWalletOptions",
        "WalletStaticMethods",
        "EmbeddedWallet"
      ],
      "source": "mesh-wallet",
      "isReExportFile": false
    },
    {
      "key": "mesh-wallet:index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/index.ts",
      "name": "index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./app\";\nexport * from \"./browser\";\nexport * from \"./embedded\";\nexport * from \"./mesh\";\n",
      "dependencies": [],
      "source": "mesh-wallet",
      "isReExportFile": false
    },
    {
      "key": "mesh-wallet:mesh.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/mesh/index.ts",
      "name": "mesh.index.ts",
      "imports": [
        {
          "module": "CreateMeshWalletOptions",
          "items": [],
          "line": 35,
          "raw": "export type CreateMeshWalletOptions = {",
          "source": "mesh-wallet"
        },
        {
          "module": "MeshWallet",
          "items": [],
          "line": 93,
          "raw": "export class MeshWallet implements IWallet {",
          "source": "mesh-wallet"
        }
      ],
      "functions": [
        {
          "name": "getUsedAddress",
          "signature": "getUsedAddress(addressType: GetAddressType = \"payment\"): Address {",
          "documentation": "  /**\n   * Get a used address of type Address from the wallet.\n   *\n   * This is used in transaction building.\n   *\n   * @param addressType - the type of address to fetch UTXOs from (default: payment)\n   * @returns an Address object\n   */",
          "parameters": [
            {
              "name": "addressType",
              "type": "GetAddressType",
              "optional": false
            }
          ],
          "returnType": "Address",
          "isPublic": true,
          "line": 511,
          "raw": "  /**\n   * Get a used address of type Address from the wallet.\n   *\n   * This is used in transaction building.\n   *\n   * @param addressType - the type of address to fetch UTXOs from (default: payment)\n   * @returns an Address object\n   */\n  getUsedAddress(addressType: GetAddressType = \"payment\"): Address {\n    if (this.addresses.baseAddressBech32 && addressType === \"payment\") {\n      return toAddress(this.addresses.baseAddressBech32);\n    } else {\n      return toAddress(this.addresses.enterpriseAddressBech32!);\n    }\n  }",
          "source": "mesh-wallet",
          "implementation": "  getUsedAddress(addressType: GetAddressType = \"payment\"): Address {\n    if (this.addresses.baseAddressBech32 && addressType === \"payment\") {\n      return toAddress(this.addresses.baseAddressBech32);\n    } else {\n      return toAddress(this.addresses.enterpriseAddressBech32!);\n    }\n  }"
        },
        {
          "name": "getPubDRepKey",
          "signature": "getPubDRepKey(): {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 640,
          "raw": "  getPubDRepKey(): {\n    pubDRepKey: string | undefined;\n    dRepIDBech32: string | undefined;\n    dRepIDHash: string | undefined;\n    dRepIDCip105: string | undefined;\n  } {\n    return {\n      pubDRepKey: this.addresses.pubDRepKey,\n      dRepIDBech32: this.addresses.dRepIDBech32,\n      dRepIDHash: this.addresses.dRepIDHash,\n      dRepIDCip105: this.addresses.dRepIDCip105,\n    };\n  }",
          "source": "mesh-wallet",
          "implementation": "  getPubDRepKey(): {\n    pubDRepKey: string | undefined;\n    dRepIDBech32: string | undefined;\n    dRepIDHash: string | undefined;\n    dRepIDCip105: string | undefined;\n  } {\n    return {\n      pubDRepKey: this.addresses.pubDRepKey,\n      dRepIDBech32: this.addresses.dRepIDBech32,\n      dRepIDHash: this.addresses.dRepIDHash,\n      dRepIDCip105: this.addresses.dRepIDCip105,\n    };\n  }"
        }
      ],
      "types": [
        {
          "name": "CreateMeshWalletOptions",
          "definition": "export type CreateMeshWalletOptions = {\n  networkId: 0 | 1;\n  fetcher?: IFetcher;",
          "isPublic": true,
          "line": 35,
          "raw": "export type CreateMeshWalletOptions = {",
          "source": "mesh-wallet"
        }
      ],
      "constants": [
        {
          "name": "utxos",
          "type": "any",
          "value": "await this.getUnspentOutputs();",
          "isPublic": true,
          "line": 199,
          "raw": "const utxos = await this.getUnspentOutputs();",
          "source": "mesh-wallet"
        },
        {
          "name": "assets",
          "type": "any",
          "value": "new Map<string, number>();",
          "isPublic": true,
          "line": 201,
          "raw": "const assets = new Map<string, number>();",
          "source": "mesh-wallet"
        },
        {
          "name": "_utxo",
          "type": "any",
          "value": "fromTxUnspentOutput(utxo);",
          "isPublic": true,
          "line": 203,
          "raw": "const _utxo = fromTxUnspentOutput(utxo);",
          "source": "mesh-wallet"
        },
        {
          "name": "assetId",
          "type": "any",
          "value": "asset.unit;",
          "isPublic": true,
          "line": 205,
          "raw": "const assetId = asset.unit;",
          "source": "mesh-wallet"
        },
        {
          "name": "amount",
          "type": "any",
          "value": "Number(asset.quantity);",
          "isPublic": true,
          "line": 206,
          "raw": "const amount = Number(asset.quantity);",
          "source": "mesh-wallet"
        },
        {
          "name": "quantity",
          "type": "any",
          "value": "assets.get(assetId)!;",
          "isPublic": true,
          "line": 208,
          "raw": "const quantity = assets.get(assetId)!;",
          "source": "mesh-wallet"
        },
        {
          "name": "arrayAssets",
          "type": "Asset[]",
          "value": "Array.from(assets, ([unit, quantity]) => ({",
          "isPublic": true,
          "line": 216,
          "raw": "const arrayAssets: Asset[] = Array.from(assets, ([unit, quantity]) => ({",
          "source": "mesh-wallet"
        },
        {
          "name": "utxos",
          "type": "any",
          "value": "await this.getCollateralUnspentOutput(addressType);",
          "isPublic": true,
          "line": 254,
          "raw": "const utxos = await this.getCollateralUnspentOutput(addressType);",
          "source": "mesh-wallet"
        },
        {
          "name": "utxos",
          "type": "any",
          "value": "await this.getUnspentOutputs(addressType);",
          "isPublic": true,
          "line": 282,
          "raw": "const utxos = await this.getUnspentOutputs(addressType);",
          "source": "mesh-wallet"
        },
        {
          "name": "pureAdaUtxos",
          "type": "any",
          "value": "utxos.filter((utxo) => {",
          "isPublic": true,
          "line": 285,
          "raw": "const pureAdaUtxos = utxos.filter((utxo) => {",
          "source": "mesh-wallet"
        },
        {
          "name": "utxos",
          "type": "any",
          "value": "await this.getUsedUTxOs(addressType);",
          "isPublic": true,
          "line": 393,
          "raw": "const utxos = await this.getUsedUTxOs(addressType);",
          "source": "mesh-wallet"
        },
        {
          "name": "tx",
          "type": "any",
          "value": "deserializeTx(unsignedTx);",
          "isPublic": true,
          "line": 439,
          "raw": "const tx = deserializeTx(unsignedTx);",
          "source": "mesh-wallet"
        },
        {
          "name": "newSignatures",
          "type": "any",
          "value": "this._wallet.signTx(",
          "isPublic": true,
          "line": 449,
          "raw": "const newSignatures = this._wallet.signTx(",
          "source": "mesh-wallet"
        },
        {
          "name": "signedTxs",
          "type": "string[]",
          "value": "[];",
          "isPublic": true,
          "line": 476,
          "raw": "const signedTxs: string[] = [];",
          "source": "mesh-wallet"
        },
        {
          "name": "signedTx",
          "type": "any",
          "value": "await this.signTx(unsignedTx, partialSign);",
          "isPublic": true,
          "line": 479,
          "raw": "const signedTx = await this.signTx(unsignedTx, partialSign);",
          "source": "mesh-wallet"
        },
        {
          "name": "utxos",
          "type": "any",
          "value": "await this._fetcher.fetchAddressUTxOs(",
          "isPublic": true,
          "line": 536,
          "raw": "const utxos = await this._fetcher.fetchAddressUTxOs(",
          "source": "mesh-wallet"
        },
        {
          "name": "balance",
          "type": "any",
          "value": "await this.getBalance();",
          "isPublic": true,
          "line": 551,
          "raw": "const balance = await this.getBalance();",
          "source": "mesh-wallet"
        },
        {
          "name": "policyId",
          "type": "any",
          "value": "v.unit.slice(0, POLICY_ID_LENGTH);",
          "isPublic": true,
          "line": 555,
          "raw": "const policyId = v.unit.slice(0, POLICY_ID_LENGTH);",
          "source": "mesh-wallet"
        },
        {
          "name": "assetName",
          "type": "any",
          "value": "v.unit.slice(POLICY_ID_LENGTH);",
          "isPublic": true,
          "line": 556,
          "raw": "const assetName = v.unit.slice(POLICY_ID_LENGTH);",
          "source": "mesh-wallet"
        },
        {
          "name": "fingerprint",
          "type": "any",
          "value": "resolveFingerprint(policyId, assetName);",
          "isPublic": true,
          "line": 557,
          "raw": "const fingerprint = resolveFingerprint(policyId, assetName);",
          "source": "mesh-wallet"
        },
        {
          "name": "balance",
          "type": "any",
          "value": "await this.getBalance();",
          "isPublic": true,
          "line": 575,
          "raw": "const balance = await this.getBalance();",
          "source": "mesh-wallet"
        },
        {
          "name": "nativeAsset",
          "type": "any",
          "value": "balance.find((v) => v.unit === \"lovelace\");",
          "isPublic": true,
          "line": 576,
          "raw": "const nativeAsset = balance.find((v) => v.unit === \"lovelace\");",
          "source": "mesh-wallet"
        },
        {
          "name": "assets",
          "type": "any",
          "value": "await this.getAssets();",
          "isPublic": true,
          "line": 588,
          "raw": "const assets = await this.getAssets();",
          "source": "mesh-wallet"
        },
        {
          "name": "balance",
          "type": "any",
          "value": "await this.getBalance();",
          "isPublic": true,
          "line": 598,
          "raw": "const balance = await this.getBalance();",
          "source": "mesh-wallet"
        },
        {
          "name": "tx",
          "type": "any",
          "value": "new Transaction({ initiator: this });",
          "isPublic": true,
          "line": 632,
          "raw": "const tx = new Transaction({ initiator: this });",
          "source": "mesh-wallet"
        },
        {
          "name": "unsignedTx",
          "type": "any",
          "value": "await tx.build();",
          "isPublic": true,
          "line": 634,
          "raw": "const unsignedTx = await tx.build();",
          "source": "mesh-wallet"
        },
        {
          "name": "signedTx",
          "type": "any",
          "value": "await this.signTx(unsignedTx);",
          "isPublic": true,
          "line": 635,
          "raw": "const signedTx = await this.signTx(unsignedTx);",
          "source": "mesh-wallet"
        },
        {
          "name": "txHash",
          "type": "any",
          "value": "await this.submitTx(signedTx);",
          "isPublic": true,
          "line": 636,
          "raw": "const txHash = await this.submitTx(signedTx);",
          "source": "mesh-wallet"
        },
        {
          "name": "mnemonic",
          "type": "any",
          "value": "EmbeddedWallet.generateMnemonic(strength);",
          "isPublic": true,
          "line": 661,
          "raw": "const mnemonic = EmbeddedWallet.generateMnemonic(strength);",
          "source": "mesh-wallet"
        },
        {
          "name": "account",
          "type": "any",
          "value": "wallet.getAccount(this._accountIndex, this._keyIndex);",
          "isPublic": true,
          "line": 671,
          "raw": "const account = wallet.getAccount(this._accountIndex, this._keyIndex);",
          "source": "mesh-wallet"
        },
        {
          "name": "baseAddress",
          "type": "any",
          "value": "Address.fromBech32(address).asBase();",
          "isPublic": true,
          "line": 692,
          "raw": "const baseAddress = Address.fromBech32(address).asBase();",
          "source": "mesh-wallet"
        },
        {
          "name": "enterpriseAddress",
          "type": "any",
          "value": "Address.fromBech32(address).asEnterprise();",
          "isPublic": true,
          "line": 697,
          "raw": "const enterpriseAddress = Address.fromBech32(address).asEnterprise();",
          "source": "mesh-wallet"
        },
        {
          "name": "rewardAddress",
          "type": "any",
          "value": "Address.fromBech32(address).asReward();",
          "isPublic": true,
          "line": 702,
          "raw": "const rewardAddress = Address.fromBech32(address).asReward();",
          "source": "mesh-wallet"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import type {\n  Asset,\n  AssetExtended,\n  DataSignature,\n  IWallet,\n  UTxO,\n} from \"@meshsdk/common\";\nimport {\n  IFetcher,\n  ISubmitter,\n  POLICY_ID_LENGTH,\n  resolveFingerprint,\n  toUTF8,\n} from \"@meshsdk/common\";\nimport {\n  Address,\n  buildBaseAddress,\n  buildEnterpriseAddress,\n  buildRewardAddress,\n  deserializeTx,\n  DRepID,\n  Ed25519KeyHashHex,\n  fromTxUnspentOutput,\n  Hash28ByteBase16,\n  resolvePrivateKey,\n  toAddress,\n  toTxUnspentOutput,\n  TransactionUnspentOutput,\n} from \"@meshsdk/core-cst\";\nimport { Transaction } from \"@meshsdk/transaction\";\n\nimport { AccountType, EmbeddedWallet } from \"../embedded\";\nimport { GetAddressType } from \"../types\";\n\nexport type CreateMeshWalletOptions = {\n  networkId: 0 | 1;\n  fetcher?: IFetcher;\n  submitter?: ISubmitter;\n  key:\n    | {\n        type: \"root\";\n        bech32: string;\n      }\n    | {\n        type: \"cli\";\n        payment: string;\n        stake?: string;\n      }\n    | {\n        type: \"mnemonic\";\n        words: string[];\n      }\n    | {\n        type: \"bip32Bytes\";\n        bip32Bytes: Uint8Array;\n      }\n    | {\n        type: \"address\";\n        address: string;\n      };\n  accountIndex?: number;\n  keyIndex?: number;\n  accountType?: AccountType;\n};\n\n/**\n * Mesh Wallet provides a set of APIs to interact with the blockchain. This wallet is compatible with Mesh transaction builders.\n *\n * There are 4 types of keys that can be used to create a wallet:\n * - root: A private key in bech32 format, generally starts with `xprv1`\n * - cli: CLI generated keys starts with `5820`. Payment key is required, and the stake key is optional.\n * - mnemonic: A list of 24 words\n * - address: A bech32 address that can be used to create a read-only wallet, generally starts with `addr` or `addr_test1`\n *\n * ```javascript\n * import { MeshWallet, BlockfrostProvider } from '@meshsdk/core';\n *\n * const provider = new BlockfrostProvider('<BLOCKFROST_API_KEY>');\n *\n * const wallet = new MeshWallet({\n *   networkId: 0,\n *   fetcher: provider,\n *   submitter: provider,\n *   key: {\n *     type: 'mnemonic',\n *     words: [\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\"],\n *   },\n * });\n * ```\n *\n * Please call `await wallet.init()` after creating the wallet to fetch the addresses from the wallet.\n */\nexport class MeshWallet implements IWallet {\n  private readonly _keyType: string;\n  private readonly _accountType: AccountType = \"payment\";\n  private readonly _wallet: EmbeddedWallet | null;\n  private readonly _accountIndex: number = 0;\n  private readonly _keyIndex: number = 0;\n  private readonly _fetcher?: IFetcher;\n  private readonly _submitter?: ISubmitter;\n  private readonly _networkId: 0 | 1;\n  addresses: {\n    baseAddress?: Address;\n    enterpriseAddress?: Address;\n    rewardAddress?: Address;\n    baseAddressBech32?: string;\n    enterpriseAddressBech32?: string;\n    rewardAddressBech32?: string;\n    pubDRepKey?: string;\n    dRepIDBech32?: DRepID;\n    dRepIDHash?: Ed25519KeyHashHex;\n    dRepIDCip105?: string;\n  } = {};\n\n  constructor(options: CreateMeshWalletOptions) {\n    this._networkId = options.networkId;\n    this._keyType = options.key.type;\n\n    if (options.fetcher) this._fetcher = options.fetcher;\n    if (options.submitter) this._submitter = options.submitter;\n    if (options.accountIndex) this._accountIndex = options.accountIndex;\n    if (options.keyIndex) this._keyIndex = options.keyIndex;\n    if (options.accountType) this._accountType = options.accountType;\n\n    switch (options.key.type) {\n      case \"root\":\n        this._wallet = new EmbeddedWallet({\n          networkId: options.networkId,\n          key: {\n            type: \"root\",\n            bech32: options.key.bech32,\n          },\n        });\n        break;\n      case \"cli\":\n        this._wallet = new EmbeddedWallet({\n          networkId: options.networkId,\n          key: {\n            type: \"cli\",\n            payment: options.key.payment,\n            stake: options.key.stake,\n          },\n        });\n        break;\n      case \"mnemonic\":\n        this._wallet = new EmbeddedWallet({\n          networkId: options.networkId,\n          key: {\n            type: \"mnemonic\",\n            words: options.key.words,\n          },\n        });\n        break;\n      case \"bip32Bytes\":\n        this._wallet = new EmbeddedWallet({\n          networkId: options.networkId,\n          key: {\n            type: \"bip32Bytes\",\n            bip32Bytes: options.key.bip32Bytes,\n          },\n        });\n        break;\n      case \"address\":\n        this._wallet = null;\n        this.buildAddressFromBech32Address(options.key.address);\n        break;\n    }\n  }\n\n  /**\n   * Initializes the wallet. This is a required call as fetching addresses from the wallet is an async operation.\n   * @returns void\n   */\n  async init() {\n    if (this._wallet && !this._wallet.cryptoIsReady) {\n      await this._wallet.init();\n      this.getAddressesFromWallet(this._wallet);\n    }\n  }\n\n  /**\n   * Returns all derived addresses from the wallet.\n   * @returns a list of addresses\n   */\n  getAddresses() {\n    return this.addresses;\n  }\n\n  /**\n   * Returns a list of assets in the wallet. This API will return every assets in the wallet. Each asset is an object with the following properties:\n   * - A unit is provided to display asset's name on the user interface.\n   * - A quantity is provided to display asset's quantity on the user interface.\n   *\n   * @returns a list of assets and their quantities\n   */\n  async getBalance(): Promise<Asset[]> {\n    await this.init();\n\n    const utxos = await this.getUnspentOutputs();\n\n    const assets = new Map<string, number>();\n    utxos.map((utxo) => {\n      const _utxo = fromTxUnspentOutput(utxo);\n      _utxo.output.amount.map((asset) => {\n        const assetId = asset.unit;\n        const amount = Number(asset.quantity);\n        if (assets.has(assetId)) {\n          const quantity = assets.get(assetId)!;\n          assets.set(assetId, quantity + amount);\n        } else {\n          assets.set(assetId, amount);\n        }\n      });\n    });\n\n    const arrayAssets: Asset[] = Array.from(assets, ([unit, quantity]) => ({\n      unit,\n      quantity: quantity.toString(),\n    }));\n\n    return arrayAssets;\n  }\n\n  /**\n   * Returns an address owned by the wallet that should be used as a change address to return leftover assets during transaction creation back to the connected wallet.\n   *\n   * @returns an address\n   */\n  async getChangeAddress(\n    addressType: GetAddressType = \"payment\",\n  ): Promise<string> {\n    await this.init();\n\n    if (this.addresses.baseAddressBech32 && addressType === \"payment\") {\n      return this.addresses.baseAddressBech32;\n    }\n    return this.addresses.enterpriseAddressBech32!;\n  }\n\n  /**\n   * This function shall return a list of one or more UTXOs (unspent transaction outputs) controlled by the wallet that are required to reach AT LEAST the combined ADA value target specified in amount AND the best suitable to be used as collateral inputs for transactions with plutus script inputs (pure ADA-only UTXOs).\n   *\n   * If this cannot be attained, an error message with an explanation of the blocking problem shall be returned. NOTE: wallets are free to return UTXOs that add up to a greater total ADA value than requested in the amount parameter, but wallets must never return any result where UTXOs would sum up to a smaller total ADA value, instead in a case like that an error message must be returned.\n   *\n   * @param addressType - the type of address to fetch UTXOs from (default: payment)\n   * @returns a list of UTXOs\n   */\n\n  async getCollateral(\n    addressType: GetAddressType = \"payment\",\n  ): Promise<UTxO[]> {\n    await this.init();\n\n    const utxos = await this.getCollateralUnspentOutput(addressType);\n    return utxos.map((utxo, i) => {\n      return fromTxUnspentOutput(utxo);\n    });\n  }\n\n  /**\n   * Return a list of supported CIPs of the wallet.\n   *\n   * @returns a list of CIPs\n   */\n  async getExtensions(): Promise<number[]> {\n    return [];\n  }\n\n  /**\n   * Get a list of UTXOs to be used as collateral inputs for transactions with plutus script inputs.\n   *\n   * This is used in transaction building.\n   *\n   * @param addressType - the type of address to fetch UTXOs from (default: payment)\n   * @returns a list of UTXOs\n   */\n  async getCollateralUnspentOutput(\n    addressType: GetAddressType = \"payment\",\n  ): Promise<TransactionUnspentOutput[]> {\n    await this.init();\n\n    const utxos = await this.getUnspentOutputs(addressType);\n\n    // find utxos that are pure ADA-only\n    const pureAdaUtxos = utxos.filter((utxo) => {\n      return utxo.output().amount().multiasset() === undefined;\n    });\n\n    // sort utxos by their lovelace amount\n    pureAdaUtxos.sort((a, b) => {\n      return (\n        Number(a.output().amount().coin()) - Number(b.output().amount().coin())\n      );\n    });\n\n    // return the smallest utxo but not less than 5000000 lovelace\n    for (const utxo of pureAdaUtxos) {\n      if (Number(utxo.output().amount().coin()) >= 5000000) {\n        return [utxo];\n      }\n    }\n\n    return [];\n  }\n\n  /**\n   * The connected wallet account provides the account's public DRep Key, derivation as described in CIP-0105.\n   * These are used by the client to identify the user's on-chain CIP-1694 interactions, i.e. if a user has registered to be a DRep.\n   *\n   * @returns DRep object\n   */\n  async getDRep(): Promise<\n    | {\n        publicKey: string;\n        publicKeyHash: string;\n        dRepIDCip105: string;\n      }\n    | undefined\n  > {\n    await this.init();\n\n    if (\n      this.addresses.pubDRepKey &&\n      this.addresses.dRepIDHash &&\n      this.addresses.dRepIDCip105\n    )\n      return {\n        publicKey: this.addresses.pubDRepKey,\n        publicKeyHash: this.addresses.dRepIDHash,\n        dRepIDCip105: this.addresses.dRepIDCip105,\n      };\n\n    return undefined;\n  }\n  /**\n   * Returns the network ID of the currently connected account. 0 is testnet and 1 is mainnet but other networks can possibly be returned by wallets. Those other network ID values are not governed by CIP-30. This result will stay the same unless the connected account has changed.\n   *\n   * @returns network ID\n   */\n  async getNetworkId(): Promise<number> {\n    return this._networkId;\n  }\n\n  /**\n   * Returns a list of reward addresses owned by the wallet. A reward address is a stake address that is used to receive rewards from staking, generally starts from `stake` prefix.\n   *\n   * @returns a list of reward addresses\n   */\n  async getRewardAddresses(): Promise<string[]> {\n    return [this.addresses.rewardAddressBech32!];\n  }\n\n  /**\n   * Returns a list of unused addresses controlled by the wallet.\n   *\n   * @returns a list of unused addresses\n   */\n  async getUnusedAddresses(): Promise<string[]> {\n    return [await this.getChangeAddress()];\n  }\n\n  /**\n   * Returns a list of used addresses controlled by the wallet.\n   *\n   * @returns a list of used addresses\n   */\n  async getUsedAddresses(): Promise<string[]> {\n    return [await this.getChangeAddress()];\n  }\n\n  /**\n   * Get a list of UTXOs to be used for transaction building.\n   *\n   * This is used in transaction building.\n   *\n   * @param addressType - the type of address to fetch UTXOs from (default: payment)\n   * @returns a list of UTXOs\n   */\n  async getUsedUTxOs(\n    addressType: GetAddressType = \"payment\",\n  ): Promise<TransactionUnspentOutput[]> {\n    await this.init();\n    return await this.getUnspentOutputs(addressType);\n  }\n\n  /**\n   * Return a list of all UTXOs (unspent transaction outputs) controlled by the wallet.\n   *\n   * @param addressType - the type of address to fetch UTXOs from (default: payment)\n   * @returns a list of UTXOs\n   */\n  async getUtxos(addressType: GetAddressType = \"payment\"): Promise<UTxO[]> {\n    const utxos = await this.getUsedUTxOs(addressType);\n    return utxos.map((c) => fromTxUnspentOutput(c));\n  }\n\n  /**\n   * This endpoint utilizes the [CIP-8 - Message Signing](https://cips.cardano.org/cips/cip8/) to sign arbitrary data, to verify the data was signed by the owner of the private key.\n   *\n   * @param payload - the payload to sign\n   * @param address - the address to use for signing (optional)\n   * @returns a signature\n   */\n  async signData(payload: string, address?: string): Promise<DataSignature> {\n    await this.init();\n\n    if (!this._wallet) {\n      throw new Error(\n        \"[MeshWallet] Read only wallet does not support signing data.\",\n      );\n    }\n    if (address === undefined) {\n      address = await this.getChangeAddress()!;\n    }\n    return this._wallet.signData(\n      address,\n      payload,\n      this._accountIndex,\n      this._keyIndex,\n    );\n  }\n\n  /**\n   * Requests user to sign the provided transaction (tx). The wallet should ask the user for permission, and if given, try to sign the supplied body and return a signed transaction. partialSign should be true if the transaction provided requires multiple signatures.\n   *\n   * @param unsignedTx - a transaction in CBOR\n   * @param partialSign - if the transaction is partially signed (default: false)\n   * @returns a signed transaction in CBOR\n   */\n  async signTx(unsignedTx: string, partialSign = false): Promise<string> {\n    await this.init();\n\n    if (!this._wallet) {\n      throw new Error(\n        \"[MeshWallet] Read only wallet does not support signing data.\",\n      );\n    }\n\n    const tx = deserializeTx(unsignedTx);\n    if (\n      !partialSign &&\n      tx.witnessSet().vkeys() !== undefined &&\n      tx.witnessSet().vkeys()!.size() !== 0\n    )\n      throw new Error(\n        \"Signatures already exist in the transaction in a non partial sign call\",\n      );\n\n    const newSignatures = this._wallet.signTx(\n      unsignedTx,\n      this._accountIndex,\n      this._keyIndex,\n      this._accountType,\n    );\n\n    let signedTx = EmbeddedWallet.addWitnessSets(unsignedTx, [newSignatures]);\n    return signedTx;\n  }\n\n  /**\n   * Experimental feature - sign multiple transactions at once.\n   *\n   * @param unsignedTxs - array of unsigned transactions in CborHex string\n   * @param partialSign - if the transactions are signed partially\n   * @returns array of signed transactions CborHex string\n   */\n  async signTxs(unsignedTxs: string[], partialSign = false): Promise<string[]> {\n    await this.init();\n\n    if (!this._wallet) {\n      throw new Error(\n        \"[MeshWallet] Read only wallet does not support signing data.\",\n      );\n    }\n\n    const signedTxs: string[] = [];\n\n    for (const unsignedTx of unsignedTxs) {\n      const signedTx = await this.signTx(unsignedTx, partialSign);\n      signedTxs.push(signedTx);\n    }\n\n    return signedTxs;\n  }\n\n  /**\n   * Submits the signed transaction to the blockchain network.\n   *\n   * As wallets should already have this ability to submit transaction, we allow apps to request that a transaction be sent through it. If the wallet accepts the transaction and tries to send it, it shall return the transaction ID for the app to track. The wallet can return error messages or failure if there was an error in sending it.\n   *\n   * @param tx - a signed transaction in CBOR\n   * @returns a transaction hash\n   */\n  async submitTx(tx: string): Promise<string> {\n    if (!this._submitter) {\n      throw new Error(\n        \"[MeshWallet] Submitter is required to submit transactions. Please provide a submitter.\",\n      );\n    }\n    return this._submitter.submitTx(tx);\n  }\n\n  /**\n   * Get a used address of type Address from the wallet.\n   *\n   * This is used in transaction building.\n   *\n   * @param addressType - the type of address to fetch UTXOs from (default: payment)\n   * @returns an Address object\n   */\n  getUsedAddress(addressType: GetAddressType = \"payment\"): Address {\n    if (this.addresses.baseAddressBech32 && addressType === \"payment\") {\n      return toAddress(this.addresses.baseAddressBech32);\n    } else {\n      return toAddress(this.addresses.enterpriseAddressBech32!);\n    }\n  }\n\n  /**\n   * Get a list of UTXOs to be used for transaction building.\n   *\n   * This is used in transaction building.\n   *\n   * @param addressType - the type of address to fetch UTXOs from (default: payment)\n   * @returns a list of UTXOs\n   */\n  async getUnspentOutputs(\n    addressType: GetAddressType = \"payment\",\n  ): Promise<TransactionUnspentOutput[]> {\n    if (!this._fetcher) {\n      throw new Error(\n        \"[MeshWallet] Fetcher is required to fetch UTxOs. Please provide a fetcher.\",\n      );\n    }\n\n    const utxos = await this._fetcher.fetchAddressUTxOs(\n      this.addresses.baseAddressBech32 && addressType == \"payment\"\n        ? this.addresses.baseAddressBech32!\n        : this.addresses.enterpriseAddressBech32!,\n    );\n\n    return utxos.map((utxo) => toTxUnspentOutput(utxo));\n  }\n\n  /**\n   * A helper function to get the assets in the wallet.\n   *\n   * @returns a list of assets\n   */\n  async getAssets(): Promise<AssetExtended[]> {\n    const balance = await this.getBalance();\n    return balance\n      .filter((v) => v.unit !== \"lovelace\")\n      .map((v) => {\n        const policyId = v.unit.slice(0, POLICY_ID_LENGTH);\n        const assetName = v.unit.slice(POLICY_ID_LENGTH);\n        const fingerprint = resolveFingerprint(policyId, assetName);\n\n        return {\n          unit: v.unit,\n          policyId,\n          assetName: toUTF8(assetName),\n          fingerprint,\n          quantity: v.quantity,\n        };\n      });\n  }\n\n  /**\n   * A helper function to get the lovelace balance in the wallet.\n   *\n   * @returns lovelace balance\n   */\n  async getLovelace(): Promise<string> {\n    const balance = await this.getBalance();\n    const nativeAsset = balance.find((v) => v.unit === \"lovelace\");\n\n    return nativeAsset !== undefined ? nativeAsset.quantity : \"0\";\n  }\n\n  /**\n   * A helper function to get the assets of a specific policy ID in the wallet.\n   *\n   * @param policyId\n   * @returns a list of assets\n   */\n  async getPolicyIdAssets(policyId: string): Promise<AssetExtended[]> {\n    const assets = await this.getAssets();\n    return assets.filter((v) => v.policyId === policyId);\n  }\n\n  /**\n   * A helper function to get the policy IDs of all the assets in the wallet.\n   *\n   * @returns a list of policy IDs\n   */\n  async getPolicyIds(): Promise<string[]> {\n    const balance = await this.getBalance();\n    return Array.from(\n      new Set(balance.map((v) => v.unit.slice(0, POLICY_ID_LENGTH))),\n    ).filter((p) => p !== \"lovelace\");\n  }\n\n  async getRegisteredPubStakeKeys(): Promise<\n    | {\n        pubStakeKeys: string[];\n        pubStakeKeyHashes: string[];\n      }\n    | undefined\n  > {\n    console.warn(\"Not implemented yet\");\n    return undefined;\n  }\n\n  async getUnregisteredPubStakeKeys(): Promise<\n    | {\n        pubStakeKeys: string[];\n        pubStakeKeyHashes: string[];\n      }\n    | undefined\n  > {\n    console.warn(\"Not implemented yet\");\n    return undefined;\n  }\n\n  /**\n   * A helper function to create a collateral input for a transaction.\n   *\n   * @returns a transaction hash\n   */\n  async createCollateral(): Promise<string> {\n    const tx = new Transaction({ initiator: this });\n    tx.sendLovelace(await this.getChangeAddress(), \"5000000\");\n    const unsignedTx = await tx.build();\n    const signedTx = await this.signTx(unsignedTx);\n    const txHash = await this.submitTx(signedTx);\n    return txHash;\n  }\n\n  getPubDRepKey(): {\n    pubDRepKey: string | undefined;\n    dRepIDBech32: string | undefined;\n    dRepIDHash: string | undefined;\n    dRepIDCip105: string | undefined;\n  } {\n    return {\n      pubDRepKey: this.addresses.pubDRepKey,\n      dRepIDBech32: this.addresses.dRepIDBech32,\n      dRepIDHash: this.addresses.dRepIDHash,\n      dRepIDCip105: this.addresses.dRepIDCip105,\n    };\n  }\n\n  /**\n   * Generate mnemonic or private key\n   *\n   * @param privateKey return private key if true\n   * @returns a transaction hash\n   */\n  static brew(privateKey = false, strength = 256): string[] | string {\n    const mnemonic = EmbeddedWallet.generateMnemonic(strength);\n\n    if (privateKey) {\n      return resolvePrivateKey(mnemonic);\n    }\n\n    return mnemonic;\n  }\n\n  private getAddressesFromWallet(wallet: EmbeddedWallet) {\n    const account = wallet.getAccount(this._accountIndex, this._keyIndex);\n\n    this.addresses = {\n      baseAddress: account.baseAddress,\n      enterpriseAddress: account.enterpriseAddress,\n      rewardAddress: account.rewardAddress,\n      baseAddressBech32: account.baseAddressBech32,\n      enterpriseAddressBech32: account.enterpriseAddressBech32,\n      rewardAddressBech32: account.rewardAddressBech32,\n\n      pubDRepKey: account.pubDRepKey,\n      dRepIDBech32: account.dRepIDBech32,\n      dRepIDHash: account.dRepIDHash,\n      dRepIDCip105: account.dRepIDCip105,\n    };\n  }\n\n  private buildAddressFromBech32Address(address: string) {\n    let pubKeyHash = undefined;\n    let stakeKeyHash = undefined;\n\n    const baseAddress = Address.fromBech32(address).asBase();\n    if (baseAddress) {\n      pubKeyHash = baseAddress.getPaymentCredential().hash;\n      stakeKeyHash = baseAddress.getStakeCredential().hash;\n    }\n    const enterpriseAddress = Address.fromBech32(address).asEnterprise();\n    if (enterpriseAddress) {\n      pubKeyHash = enterpriseAddress.getPaymentCredential().hash;\n    }\n\n    const rewardAddress = Address.fromBech32(address).asReward();\n    if (rewardAddress) {\n      stakeKeyHash = rewardAddress.getPaymentCredential().hash;\n    }\n\n    if (pubKeyHash && stakeKeyHash) {\n      this.addresses.baseAddress = buildBaseAddress(\n        this._networkId,\n        Hash28ByteBase16.fromEd25519KeyHashHex(Ed25519KeyHashHex(pubKeyHash)),\n        Hash28ByteBase16.fromEd25519KeyHashHex(\n          Ed25519KeyHashHex(Ed25519KeyHashHex(stakeKeyHash)),\n        ),\n      ).toAddress();\n      this.addresses.baseAddressBech32 = this.addresses.baseAddress.toBech32();\n    }\n\n    if (pubKeyHash) {\n      this.addresses.enterpriseAddress = buildEnterpriseAddress(\n        this._networkId,\n        Hash28ByteBase16.fromEd25519KeyHashHex(Ed25519KeyHashHex(pubKeyHash)),\n      ).toAddress();\n      this.addresses.enterpriseAddressBech32 =\n        this.addresses.enterpriseAddress.toBech32();\n    }\n\n    if (stakeKeyHash) {\n      this.addresses.rewardAddress = buildRewardAddress(\n        this._networkId,\n        Hash28ByteBase16.fromEd25519KeyHashHex(Ed25519KeyHashHex(stakeKeyHash)),\n      ).toAddress();\n\n      this.addresses.rewardAddressBech32 =\n        this.addresses.rewardAddress.toBech32();\n    }\n  }\n}\n",
      "dependencies": [
        "CreateMeshWalletOptions",
        "MeshWallet"
      ],
      "source": "mesh-wallet",
      "isReExportFile": false
    },
    {
      "key": "mesh-wallet:types.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/types/index.ts",
      "name": "types.index.ts",
      "imports": [
        {
          "module": "Cardano",
          "items": [],
          "line": 4,
          "raw": "export type Cardano = {",
          "source": "mesh-wallet"
        },
        {
          "module": "Cip30WalletApi",
          "items": [],
          "line": 21,
          "raw": "export interface Cip30WalletApi {",
          "source": "mesh-wallet"
        },
        {
          "module": "Cip95WalletApi",
          "items": [],
          "line": 40,
          "raw": "export interface Cip95WalletApi {",
          "source": "mesh-wallet"
        },
        {
          "module": "WalletInstance",
          "items": [],
          "line": 47,
          "raw": "export type WalletInstance = Cip30WalletApi & Cip95WalletApi;",
          "source": "mesh-wallet"
        },
        {
          "module": "GetAddressType",
          "items": [],
          "line": 55,
          "raw": "export type GetAddressType = \"enterprise\" | \"payment\";",
          "source": "mesh-wallet"
        }
      ],
      "functions": [
        {
          "name": "getBalance",
          "signature": "getBalance(): Promise<string>;",
          "documentation": "",
          "parameters": [],
          "returnType": "Promise<string>;",
          "isPublic": true,
          "line": 23,
          "raw": "  getBalance(): Promise<string>;\n  getChangeAddress(): Promise<string>;\n  getExtensions(): Promise<{ cip: number }[]>;",
          "source": "mesh-wallet",
          "implementation": "  getBalance(): Promise<string>;\n  getChangeAddress(): Promise<string>;\n  getExtensions(): Promise<{ cip: number }[]>;"
        },
        {
          "name": "getChangeAddress",
          "signature": "getChangeAddress(): Promise<string>;",
          "documentation": "",
          "parameters": [],
          "returnType": "Promise<string>;",
          "isPublic": true,
          "line": 24,
          "raw": "  getChangeAddress(): Promise<string>;\n  getExtensions(): Promise<{ cip: number }[]>;",
          "source": "mesh-wallet",
          "implementation": "  getChangeAddress(): Promise<string>;\n  getExtensions(): Promise<{ cip: number }[]>;"
        },
        {
          "name": "getExtensions",
          "signature": "getExtensions(): Promise<{ cip: number }[]>;",
          "documentation": "",
          "parameters": [],
          "returnType": "Promise<",
          "isPublic": true,
          "line": 25,
          "raw": "  getExtensions(): Promise<{ cip: number }[]>;",
          "source": "mesh-wallet",
          "implementation": "  getExtensions(): Promise<{ cip: number }[]>;"
        },
        {
          "name": "getCollateral",
          "signature": "getCollateral(): Promise<string[] | undefined>;",
          "documentation": "",
          "parameters": [],
          "returnType": "Promise<string[] | undefined>;",
          "isPublic": true,
          "line": 26,
          "raw": "  getCollateral(): Promise<string[] | undefined>;\n  getNetworkId(): Promise<number>;\n  getRewardAddresses(): Promise<string[]>;\n  getUnusedAddresses(): Promise<string[]>;\n  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {",
          "source": "mesh-wallet",
          "implementation": "  getCollateral(): Promise<string[] | undefined>;\n  getNetworkId(): Promise<number>;\n  getRewardAddresses(): Promise<string[]>;\n  getUnusedAddresses(): Promise<string[]>;\n  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {"
        },
        {
          "name": "getNetworkId",
          "signature": "getNetworkId(): Promise<number>;",
          "documentation": "",
          "parameters": [],
          "returnType": "Promise<number>;",
          "isPublic": true,
          "line": 27,
          "raw": "  getNetworkId(): Promise<number>;\n  getRewardAddresses(): Promise<string[]>;\n  getUnusedAddresses(): Promise<string[]>;\n  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {",
          "source": "mesh-wallet",
          "implementation": "  getNetworkId(): Promise<number>;\n  getRewardAddresses(): Promise<string[]>;\n  getUnusedAddresses(): Promise<string[]>;\n  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {"
        },
        {
          "name": "getRewardAddresses",
          "signature": "getRewardAddresses(): Promise<string[]>;",
          "documentation": "",
          "parameters": [],
          "returnType": "Promise<string[]>;",
          "isPublic": true,
          "line": 28,
          "raw": "  getRewardAddresses(): Promise<string[]>;\n  getUnusedAddresses(): Promise<string[]>;\n  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {",
          "source": "mesh-wallet",
          "implementation": "  getRewardAddresses(): Promise<string[]>;\n  getUnusedAddresses(): Promise<string[]>;\n  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {"
        },
        {
          "name": "getUnusedAddresses",
          "signature": "getUnusedAddresses(): Promise<string[]>;",
          "documentation": "",
          "parameters": [],
          "returnType": "Promise<string[]>;",
          "isPublic": true,
          "line": 29,
          "raw": "  getUnusedAddresses(): Promise<string[]>;\n  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {",
          "source": "mesh-wallet",
          "implementation": "  getUnusedAddresses(): Promise<string[]>;\n  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {"
        },
        {
          "name": "getUsedAddresses",
          "signature": "getUsedAddresses(): Promise<string[]>;",
          "documentation": "",
          "parameters": [],
          "returnType": "Promise<string[]>;",
          "isPublic": true,
          "line": 30,
          "raw": "  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {",
          "source": "mesh-wallet",
          "implementation": "  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {"
        },
        {
          "name": "getUtxos",
          "signature": "getUtxos(): Promise<string[] | undefined>;",
          "documentation": "",
          "parameters": [],
          "returnType": "Promise<string[] | undefined>;",
          "isPublic": true,
          "line": 31,
          "raw": "  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {",
          "source": "mesh-wallet",
          "implementation": "  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {"
        },
        {
          "name": "signData",
          "signature": "signData(address: string, payload: string): Promise<DataSignature>;",
          "documentation": "",
          "parameters": [
            {
              "name": "address",
              "type": "string",
              "optional": false
            },
            {
              "name": "payload",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Promise<DataSignature>;",
          "isPublic": true,
          "line": 32,
          "raw": "  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {",
          "source": "mesh-wallet",
          "implementation": "  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {"
        },
        {
          "name": "signTx",
          "signature": "signTx(tx: string, partialSign: boolean): Promise<string>;",
          "documentation": "",
          "parameters": [
            {
              "name": "tx",
              "type": "string",
              "optional": false
            },
            {
              "name": "partialSign",
              "type": "boolean",
              "optional": false
            }
          ],
          "returnType": "Promise<string>;",
          "isPublic": true,
          "line": 33,
          "raw": "  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {",
          "source": "mesh-wallet",
          "implementation": "  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {"
        },
        {
          "name": "submitTx",
          "signature": "submitTx(tx: string): Promise<string>;",
          "documentation": "",
          "parameters": [
            {
              "name": "tx",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Promise<string>;",
          "isPublic": true,
          "line": 36,
          "raw": "  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {",
          "source": "mesh-wallet",
          "implementation": "  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {"
        },
        {
          "name": "signData",
          "signature": "signData(address: string, payload: string): Promise<DataSignature>;",
          "documentation": "",
          "parameters": [
            {
              "name": "address",
              "type": "string",
              "optional": false
            },
            {
              "name": "payload",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Promise<DataSignature>;",
          "isPublic": true,
          "line": 44,
          "raw": "  signData(address: string, payload: string): Promise<DataSignature>;\n}\n\nexport type WalletInstance = Cip30WalletApi & Cip95WalletApi;\n\ntype ExperimentalFeatures = {",
          "source": "mesh-wallet",
          "implementation": "  signData(address: string, payload: string): Promise<DataSignature>;\n}\n\nexport type WalletInstance = Cip30WalletApi & Cip95WalletApi;\n\ntype ExperimentalFeatures = {"
        },
        {
          "name": "getCollateral",
          "signature": "getCollateral(): Promise<string[] | undefined>;",
          "documentation": "",
          "parameters": [],
          "returnType": "Promise<string[] | undefined>;",
          "isPublic": true,
          "line": 50,
          "raw": "  getCollateral(): Promise<string[] | undefined>;",
          "source": "mesh-wallet",
          "implementation": "  getCollateral(): Promise<string[] | undefined>;"
        }
      ],
      "types": [
        {
          "name": "Cardano",
          "definition": "export type Cardano = {\n  [key: string]: {\n    name: string;\n    icon: string;\n    apiVersion: string;",
          "isPublic": true,
          "line": 4,
          "raw": "export type Cardano = {",
          "source": "mesh-wallet"
        },
        {
          "name": "TransactionSignatureRequest",
          "definition": "type TransactionSignatureRequest = {\n  cbor: string;\n  partialSign: boolean;",
          "isPublic": true,
          "line": 16,
          "raw": "type TransactionSignatureRequest = {",
          "source": "mesh-wallet"
        },
        {
          "name": "Cip30WalletApi",
          "definition": "export interface Cip30WalletApi {\n  experimental: ExperimentalFeatures;",
          "isPublic": true,
          "line": 21,
          "raw": "export interface Cip30WalletApi {",
          "source": "mesh-wallet"
        },
        {
          "name": "Cip95WalletApi",
          "definition": "export interface Cip95WalletApi {\n  getRegisteredPubStakeKeys: () => Promise<Ed25519PublicKeyHex[]>;\n  getUnregisteredPubStakeKeys: () => Promise<Ed25519PublicKeyHex[]>;\n  getPubDRepKey: () => Promise<Ed25519PublicKeyHex>;\n  signData(address: string, payload: string): Promise<DataSignature>;",
          "isPublic": true,
          "line": 40,
          "raw": "export interface Cip95WalletApi {",
          "source": "mesh-wallet"
        },
        {
          "name": "WalletInstance",
          "definition": "export type WalletInstance = Cip30WalletApi & Cip95WalletApi;",
          "isPublic": true,
          "line": 47,
          "raw": "export type WalletInstance = Cip30WalletApi & Cip95WalletApi;",
          "source": "mesh-wallet"
        },
        {
          "name": "ExperimentalFeatures",
          "definition": "type ExperimentalFeatures = {\n  getCollateral(): Promise<string[] | undefined>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard",
          "isPublic": true,
          "line": 49,
          "raw": "type ExperimentalFeatures = {",
          "source": "mesh-wallet"
        },
        {
          "name": "GetAddressType",
          "definition": "export type GetAddressType = \"enterprise\" | \"payment\";",
          "isPublic": true,
          "line": 55,
          "raw": "export type GetAddressType = \"enterprise\" | \"payment\";",
          "source": "mesh-wallet"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { DataSignature } from \"@meshsdk/common\";\nimport { Ed25519PublicKeyHex } from \"@meshsdk/core-cst\";\n\nexport type Cardano = {\n  [key: string]: {\n    name: string;\n    icon: string;\n    apiVersion: string;\n    enable: (extensions?: {\n      extensions: { cip: number }[];\n    }) => Promise<WalletInstance>;\n    supportedExtensions?: { cip: number }[];\n  };\n};\n\ntype TransactionSignatureRequest = {\n  cbor: string;\n  partialSign: boolean;\n};\n\nexport interface Cip30WalletApi {\n  experimental: ExperimentalFeatures;\n  getBalance(): Promise<string>;\n  getChangeAddress(): Promise<string>;\n  getExtensions(): Promise<{ cip: number }[]>;\n  getCollateral(): Promise<string[] | undefined>;\n  getNetworkId(): Promise<number>;\n  getRewardAddresses(): Promise<string[]>;\n  getUnusedAddresses(): Promise<string[]>;\n  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {\n  getRegisteredPubStakeKeys: () => Promise<Ed25519PublicKeyHex[]>;\n  getUnregisteredPubStakeKeys: () => Promise<Ed25519PublicKeyHex[]>;\n  getPubDRepKey: () => Promise<Ed25519PublicKeyHex>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n}\n\nexport type WalletInstance = Cip30WalletApi & Cip95WalletApi;\n\ntype ExperimentalFeatures = {\n  getCollateral(): Promise<string[] | undefined>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n};\n\nexport type GetAddressType = \"enterprise\" | \"payment\";\n",
      "dependencies": [
        "Cardano",
        "Cip30WalletApi",
        "Cip95WalletApi",
        "WalletInstance",
        "GetAddressType"
      ],
      "source": "mesh-wallet",
      "isReExportFile": false
    },
    {
      "key": "mesh-hydra:hydra-connection.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/hydra-connection.ts",
      "name": "hydra-connection.ts",
      "imports": [
        {
          "module": "HydraConnection",
          "items": [],
          "line": 5,
          "raw": "export class HydraConnection extends EventEmitter {",
          "source": "mesh-hydra"
        }
      ],
      "functions": [
        {
          "name": "send",
          "signature": "send(data: unknown): void {",
          "documentation": "",
          "parameters": [
            {
              "name": "data",
              "type": "unknown",
              "optional": false
            }
          ],
          "returnType": "void",
          "isPublic": true,
          "line": 59,
          "raw": "  send(data: unknown): void {\n    const sendData = () => {\n      if (this._websocket?.readyState === WebSocket.OPEN) {\n        this._websocket.send(JSON.stringify(data));\n        return true;\n      }\n      return false;\n    };\n\n    const interval = setInterval(() => {\n      if (sendData()) {\n        clearInterval(interval);\n      }\n    }, 1000);\n\n    setTimeout(() => {\n      if (!sendData()) {\n        console.error(\"Failed to send data: WebSocket connection timeout.\");\n        clearInterval(interval);\n      }\n    }, 5000);\n  }",
          "source": "mesh-hydra",
          "implementation": "  send(data: unknown): void {\n    const sendData = () => {\n      if (this._websocket?.readyState === WebSocket.OPEN) {\n        this._websocket.send(JSON.stringify(data));\n        return true;\n      }\n      return false;\n    };\n\n    const interval = setInterval(() => {\n      if (sendData()) {\n        clearInterval(interval);\n      }\n    }, 1000);\n\n    setTimeout(() => {\n      if (!sendData()) {\n        console.error(\"Failed to send data: WebSocket connection timeout.\");\n        clearInterval(interval);\n      }\n    }, 5000);\n  }"
        },
        {
          "name": "sendData",
          "signature": "const sendData = () => {",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 60,
          "raw": "    const sendData = () => {\n      if (this._websocket?.readyState === WebSocket.OPEN) {\n        this._websocket.send(JSON.stringify(data));\n        return true;\n      }\n      return false;\n    };",
          "source": "mesh-hydra",
          "implementation": "    const sendData = () => {\n      if (this._websocket?.readyState === WebSocket.OPEN) {\n        this._websocket.send(JSON.stringify(data));\n        return true;\n      }\n      return false;\n    };"
        },
        {
          "name": "setTimeout",
          "signature": "setTimeout(() => {",
          "documentation": "",
          "parameters": [
            {
              "name": "(",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 74,
          "raw": "    setTimeout(() => {\n      if (!sendData()) {\n        console.error(\"Failed to send data: WebSocket connection timeout.\");\n        clearInterval(interval);\n      }\n    }, 5000);",
          "source": "mesh-hydra",
          "implementation": "    setTimeout(() => {\n      if (!sendData()) {\n        console.error(\"Failed to send data: WebSocket connection timeout.\");\n        clearInterval(interval);\n      }\n    }, 5000);"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "_wsUrl",
          "type": "any",
          "value": "wsUrl ? wsUrl : url.replace(\"http\", \"ws\");",
          "isPublic": true,
          "line": 20,
          "raw": "const _wsUrl = wsUrl ? wsUrl : url.replace(\"http\", \"ws\");",
          "source": "mesh-hydra"
        },
        {
          "name": "_history",
          "type": "any",
          "value": "`history=${history ? \"yes\" : \"no\"}`;",
          "isPublic": true,
          "line": 21,
          "raw": "const _history = `history=${history ? \"yes\" : \"no\"}`;",
          "source": "mesh-hydra"
        },
        {
          "name": "_address",
          "type": "any",
          "value": "address ? `&address=${address}` : \"\";",
          "isPublic": true,
          "line": 22,
          "raw": "const _address = address ? `&address=${address}` : \"\";",
          "source": "mesh-hydra"
        },
        {
          "name": "message",
          "type": "any",
          "value": "JSON.parse(data.data as string);",
          "isPublic": true,
          "line": 52,
          "raw": "const message = JSON.parse(data.data as string);",
          "source": "mesh-hydra"
        },
        {
          "name": "sendData",
          "type": "any",
          "value": "() => {",
          "isPublic": true,
          "line": 60,
          "raw": "const sendData = () => {",
          "source": "mesh-hydra"
        },
        {
          "name": "interval",
          "type": "any",
          "value": "setInterval(() => {",
          "isPublic": true,
          "line": 68,
          "raw": "const interval = setInterval(() => {",
          "source": "mesh-hydra"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { EventEmitter } from \"events\";\nimport { hStatus } from \"./types/hStatus\";\nimport WebSocket, { MessageEvent } from \"isomorphic-ws\";\n\nexport class HydraConnection extends EventEmitter {\n  constructor({\n    url,\n    eventEmitter,\n    history = false,\n    address,\n    wsUrl,\n  }: {\n    url: string;\n    eventEmitter: EventEmitter;\n    history?: boolean;\n    address?: string;\n    wsUrl?: string;\n  }) {\n    super();\n    const _wsUrl = wsUrl ? wsUrl : url.replace(\"http\", \"ws\");\n    const _history = `history=${history ? \"yes\" : \"no\"}`;\n    const _address = address ? `&address=${address}` : \"\";\n    this._websocketUrl = `${_wsUrl}/?${_history}${_address}`;\n    this._eventEmitter = eventEmitter;\n  }\n\n  async connect(): Promise<void> {\n    this._websocket = new WebSocket(this._websocketUrl);\n    if (!this._websocket) {\n      throw new Error(\"invalid url, websocket failed to connect\");\n    }\n    this._status = \"CONNECTING\";\n\n    this._websocket.onopen = () => {\n      this._connected = true;\n      this._status = \"CONNECTED\";\n      console.log(\"WebSocket connected successfully\");\n    };\n\n    this._websocket.onerror = (error) => {\n      console.error(\"Hydra error:\", error);\n      this._connected = false;\n    };\n\n    this._websocket.onclose = (code) => {\n      console.error(\"Hydra websocket closed\", code.code, code.reason);\n      this._status = \"CLOSED\";\n      this._connected = false;\n    };\n\n    this._websocket.onmessage = (data: MessageEvent) => {\n      const message = JSON.parse(data.data as string);\n      console.log(\"Received message from Hydra:\", message);\n      this._eventEmitter.emit(\"onmessage\", message);\n      this.processStatus(message);\n    };\n  }\n\n  send(data: unknown): void {\n    const sendData = () => {\n      if (this._websocket?.readyState === WebSocket.OPEN) {\n        this._websocket.send(JSON.stringify(data));\n        return true;\n      }\n      return false;\n    };\n\n    const interval = setInterval(() => {\n      if (sendData()) {\n        clearInterval(interval);\n      }\n    }, 1000);\n\n    setTimeout(() => {\n      if (!sendData()) {\n        console.error(\"Failed to send data: WebSocket connection timeout.\");\n        clearInterval(interval);\n      }\n    }, 5000);\n  }\n\n  async disconnect() {\n    if (this._status === \"IDLE\") {\n      return;\n    }\n    if (this._websocket && this._websocket.readyState === WebSocket.OPEN) {\n      this._websocket.close(1007);\n    }\n    this._status = \"IDLE\";\n  }\n\n  async processStatus(message: {}) {\n    let status: hStatus | null = null;\n    if ((status = hStatus(message)) && status !== null) {\n      this._status = status;\n      this._eventEmitter.emit(\"onstatuschange\", status);\n    }\n  }\n\n  _websocket: WebSocket | undefined;\n  _status: hStatus = \"IDLE\";\n  _websocketUrl: string;\n  private readonly _eventEmitter: EventEmitter;\n  private _connected: boolean = false;\n}\n",
      "dependencies": [
        "HydraConnection"
      ],
      "source": "mesh-hydra",
      "isReExportFile": false
    },
    {
      "key": "mesh-hydra:hydra-instance.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/hydra-instance.ts",
      "name": "hydra-instance.ts",
      "imports": [
        {
          "module": "HydraInstance",
          "items": [],
          "line": 9,
          "raw": "export class HydraInstance {",
          "source": "mesh-hydra"
        }
      ],
      "functions": [
        {
          "name": "utxo",
          "signature": "const utxo = (await this.fetcher.fetchUTxOs(txHash, txIndex))[0];",
          "documentation": "",
          "parameters": [
            {
              "name": "await this.fetcher.fetchUTxOs(txHash, txIndex",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 36,
          "raw": "    const utxo = (await this.fetcher.fetchUTxOs(txHash, txIndex))[0];\n    if (!utxo) {\n      throw new Error(\"UTxO not found\");\n    }",
          "source": "mesh-hydra",
          "implementation": "    const utxo = (await this.fetcher.fetchUTxOs(txHash, txIndex))[0];\n    if (!utxo) {\n      throw new Error(\"UTxO not found\");\n    }"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "utxo",
          "type": "any",
          "value": "(await this.fetcher.fetchUTxOs(txHash, txIndex))[0];",
          "isPublic": true,
          "line": 36,
          "raw": "const utxo = (await this.fetcher.fetchUTxOs(txHash, txIndex))[0];",
          "source": "mesh-hydra"
        },
        {
          "name": "hydraUtxo",
          "type": "any",
          "value": "{",
          "isPublic": true,
          "line": 40,
          "raw": "const hydraUtxo = {",
          "source": "mesh-hydra"
        },
        {
          "name": "commit",
          "type": "any",
          "value": "await this.provider.buildCommit(",
          "isPublic": true,
          "line": 52,
          "raw": "const commit = await this.provider.buildCommit(",
          "source": "mesh-hydra"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { IFetcher, ISubmitter} from \"@meshsdk/common\";\nimport { parseDatumCbor} from \"@meshsdk/core-cst\";\nimport { HydraProvider } from \"./hydra-provider\";\nimport { hAssets } from \"./types/hAssets\";\n\n/**\n * todo: implement https://hydra.family/head-protocol/docs/tutorial/\n */\nexport class HydraInstance {\n  provider: HydraProvider;\n  fetcher: IFetcher;\n  submitter: ISubmitter;\n\n  constructor({\n    provider,\n    fetcher,\n    submitter,\n  }: {\n    provider: HydraProvider;\n    fetcher: IFetcher;\n    submitter: ISubmitter;\n  }) {\n    this.provider = provider;\n    this.fetcher = fetcher;\n    this.submitter = submitter;\n  }\n\n  /**\n   * To commit funds to the head, choose which UTxO you would like to make available on layer 2.\n   * The function returns the transaction, ready to be signed by the user.\n   * @param txHash\n   * @param txIndex\n   * @returns commitTransactionHex\n   */\n  async commitFunds(txHash: string, txIndex: number): Promise<string> {\n    const utxo = (await this.fetcher.fetchUTxOs(txHash, txIndex))[0];\n    if (!utxo) {\n      throw new Error(\"UTxO not found\");\n    }\n    const hydraUtxo = {\n      address: utxo.output.address,\n      datum: null,\n      datumhash: null, // TODO: Handle datumHash case\n      referenceScript:\n        utxo.output.scriptRef === \"\" || !utxo.output.scriptRef\n          ? null\n          : utxo.output.scriptRef,\n      value: hAssets(utxo.output.amount),\n      inlineDatum: utxo.output.plutusData ? parseDatumCbor(utxo.output.plutusData) : null,\n      inlineDatumRaw: utxo.output.plutusData ?? null,\n    };\n    const commit = await this.provider.buildCommit(\n      {\n        [txHash + \"#\" + txIndex]: hydraUtxo,\n      },\n      {\n        \"Content-Type\": \"text/plain\",\n      }\n    );\n    console.log(commit);\n    return commit.cborHex;\n  }\n\n  /**\n   * https://hydra.family/head-protocol/docs/how-to/commit-blueprint/.\n   * A Cardano transaction in the text envelope format. \n   * That is, a JSON object wrapper with some 'type' around a 'cborHex' encoded transaction.\n   * @param txHash\n   * @param txIndex\n   */\n  async commitBlueprint() {\n    return \"txhash\";\n  }\n\n  /**\n   * TO DO\n   * https://hydra.family/head-protocol/unstable/docs/how-to/incremental-commit\n   *\n   * If you don't want to commit any funds and only want to receive on layer two, you can request an empty commit transaction.:\n   * @returns\n   */\n  async incrementalCommit() {\n    return \"txHash\";\n  }\n\n  /**\n   * https://hydra.family/head-protocol/docs/how-to/incremental-decommit\n   *\n   * @returns\n   */\n  async incrementalDecommit() {\n    return \"txHash\";\n  }\n}\n",
      "dependencies": [
        "HydraInstance"
      ],
      "source": "mesh-hydra",
      "isReExportFile": false
    },
    {
      "key": "mesh-hydra:hydra-provider.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/hydra-provider.ts",
      "name": "hydra-provider.ts",
      "imports": [
        {
          "module": "HydraProvider",
          "items": [],
          "line": 59,
          "raw": "export class HydraProvider implements IFetcher, ISubmitter {",
          "source": "mesh-hydra"
        }
      ],
      "functions": [
        {
          "name": "onStatusChange",
          "signature": "onStatusChange(callback: (status: hStatus) => void) {",
          "documentation": "",
          "parameters": [
            {
              "name": "callback",
              "type": "(status: hStatus",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 523,
          "raw": "  onStatusChange(callback: (status: hStatus) => void) {\n    this._eventEmitter.on(\"onstatuschange\", callback);\n  }",
          "source": "mesh-hydra",
          "implementation": "  onStatusChange(callback: (status: hStatus) => void) {\n    this._eventEmitter.on(\"onstatuschange\", callback);\n  }"
        },
        {
          "name": "fetchAccountInfo",
          "signature": "fetchAccountInfo(address: string): Promise<AccountInfo> {",
          "documentation": "",
          "parameters": [
            {
              "name": "address",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Promise<AccountInfo>",
          "isPublic": true,
          "line": 576,
          "raw": "  fetchAccountInfo(address: string): Promise<AccountInfo> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "source": "mesh-hydra",
          "implementation": "  fetchAccountInfo(address: string): Promise<AccountInfo> {\n    throw new Error(\"Method not implemented.\");\n  }"
        },
        {
          "name": "fetchAssetMetadata",
          "signature": "fetchAssetMetadata(asset: string): Promise<AssetMetadata> {",
          "documentation": "",
          "parameters": [
            {
              "name": "asset",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Promise<AssetMetadata>",
          "isPublic": true,
          "line": 593,
          "raw": "  fetchAssetMetadata(asset: string): Promise<AssetMetadata> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "source": "mesh-hydra",
          "implementation": "  fetchAssetMetadata(asset: string): Promise<AssetMetadata> {\n    throw new Error(\"Method not implemented.\");\n  }"
        },
        {
          "name": "fetchBlockInfo",
          "signature": "fetchBlockInfo(hash: string): Promise<BlockInfo> {",
          "documentation": "",
          "parameters": [
            {
              "name": "hash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Promise<BlockInfo>",
          "isPublic": true,
          "line": 597,
          "raw": "  fetchBlockInfo(hash: string): Promise<BlockInfo> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "source": "mesh-hydra",
          "implementation": "  fetchBlockInfo(hash: string): Promise<BlockInfo> {\n    throw new Error(\"Method not implemented.\");\n  }"
        },
        {
          "name": "fetchTxInfo",
          "signature": "fetchTxInfo(hash: string): Promise<TransactionInfo> {",
          "documentation": "",
          "parameters": [
            {
              "name": "hash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Promise<TransactionInfo>",
          "isPublic": true,
          "line": 615,
          "raw": "  fetchTxInfo(hash: string): Promise<TransactionInfo> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "source": "mesh-hydra",
          "implementation": "  fetchTxInfo(hash: string): Promise<TransactionInfo> {\n    throw new Error(\"Method not implemented.\");\n  }"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "utxos",
          "type": "any",
          "value": "await this.fetchUTxOs();",
          "isPublic": true,
          "line": 111,
          "raw": "const utxos = await this.fetchUTxOs();",
          "source": "mesh-hydra"
        },
        {
          "name": "snapshotUTxOs",
          "type": "any",
          "value": "await this.subscribeSnapshotUtxo();",
          "isPublic": true,
          "line": 131,
          "raw": "const snapshotUTxOs = await this.subscribeSnapshotUtxo();",
          "source": "mesh-hydra"
        },
        {
          "name": "outputsPromises",
          "type": "Promise<UTxO>[]",
          "value": "[];",
          "isPublic": true,
          "line": 133,
          "raw": "const outputsPromises: Promise<UTxO>[] = [];",
          "source": "mesh-hydra"
        },
        {
          "name": "outputs",
          "type": "any",
          "value": "await Promise.all(outputsPromises);",
          "isPublic": true,
          "line": 139,
          "raw": "const outputs = await Promise.all(outputsPromises);",
          "source": "mesh-hydra"
        },
        {
          "name": "txId",
          "type": "any",
          "value": "await new Promise<string>((resolve) => {",
          "isPublic": true,
          "line": 155,
          "raw": "const txId = await new Promise<string>((resolve) => {",
          "source": "mesh-hydra"
        },
        {
          "name": "transaction",
          "type": "hTransaction",
          "value": "{",
          "isPublic": true,
          "line": 218,
          "raw": "const transaction: hTransaction = {",
          "source": "mesh-hydra"
        },
        {
          "name": "payload",
          "type": "any",
          "value": "{",
          "isPublic": true,
          "line": 224,
          "raw": "const payload = {",
          "source": "mesh-hydra"
        },
        {
          "name": "payload",
          "type": "any",
          "value": "{",
          "isPublic": true,
          "line": 246,
          "raw": "const payload = {",
          "source": "mesh-hydra"
        },
        {
          "name": "txHex",
          "type": "any",
          "value": "await this.post(\"/commit\", payload, headers);",
          "isPublic": true,
          "line": 296,
          "raw": "const txHex = await this.post(\"/commit\", payload, headers);",
          "source": "mesh-hydra"
        },
        {
          "name": "commits",
          "type": "any",
          "value": "await this.get(\"/commits\");",
          "isPublic": true,
          "line": 312,
          "raw": "const commits = await this.get(\"/commits\");",
          "source": "mesh-hydra"
        },
        {
          "name": "data",
          "type": "any",
          "value": "await this.get(`snapshot/utxo`);",
          "isPublic": true,
          "line": 339,
          "raw": "const data = await this.get(`snapshot/utxo`);",
          "source": "mesh-hydra"
        },
        {
          "name": "utxos",
          "type": "UTxO[]",
          "value": "[];",
          "isPublic": true,
          "line": 340,
          "raw": "const utxos: UTxO[] = [];",
          "source": "mesh-hydra"
        },
        {
          "name": "utxo",
          "type": "any",
          "value": "hUTxO.toUTxO(value as hUTxO, key);",
          "isPublic": true,
          "line": 342,
          "raw": "const utxo = hUTxO.toUTxO(value as hUTxO, key);",
          "source": "mesh-hydra"
        },
        {
          "name": "data",
          "type": "any",
          "value": "await this.get(\"protocol-parameters\");",
          "isPublic": true,
          "line": 369,
          "raw": "const data = await this.get(\"protocol-parameters\");",
          "source": "mesh-hydra"
        },
        {
          "name": "protocolParams",
          "type": "any",
          "value": "castProtocol({",
          "isPublic": true,
          "line": 371,
          "raw": "const protocolParams = castProtocol({",
          "source": "mesh-hydra"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { EventEmitter } from \"events\";\nimport axios, { AxiosInstance, RawAxiosRequestHeaders } from \"axios\";\n\nimport {\n  AccountInfo,\n  Asset,\n  AssetMetadata,\n  BlockInfo,\n  castProtocol,\n  DEFAULT_FETCHER_OPTIONS,\n  GovernanceProposalInfo,\n  IFetcher,\n  IFetcherOptions,\n  ISubmitter,\n  Protocol,\n  TransactionInfo,\n  UTxO,\n} from \"@meshsdk/common\";\n\nimport { parseHttpError } from \"./utils\";\nimport { HydraConnection } from \"./hydra-connection\";\nimport { hStatus, hTransaction, hUTxO } from \"./types\";\nimport {\n  CommandFailed,\n  Committed,\n  DecommitApproved,\n  DecommitFinalized,\n  DecommitInvalid,\n  DecommitRequested,\n  GetUTxOResponse,\n  Greetings,\n  HeadIsAborted,\n  HeadIsClosed,\n  HeadIsContested,\n  HeadIsFinalized,\n  HeadIsInitializing,\n  HeadIsOpen,\n  IgnoredHeadInitializing,\n  InvalidInput,\n  PeerConnected,\n  PeerDisconnected,\n  PeerHandshakeFailure,\n  PostTxOnChainFailed,\n  ReadyToFanout,\n  SnapshotConfirmed,\n  TxInvalid,\n  TxValid,\n} from \"./types/events\";\n\n/**\n * HydraProvider is a tool for administrating & interacting with Hydra Heads.\n *\n * Usage:\n * ```\n * import { HydraProvider } from \"@meshsdk/hydra\";\n *\n * const hydraProvider = new HydraProvider({url:'http://123.45.67.890:4001'});\n */\nexport class HydraProvider implements IFetcher, ISubmitter {\n  private _connection: HydraConnection;\n  private _status: hStatus = \"DISCONNECTED\";\n  private readonly _eventEmitter: EventEmitter;\n  private readonly _axiosInstance: AxiosInstance;\n\n  constructor({\n    url,\n    history = false,\n    address,\n    wsUrl,\n  }: {\n    url: string;\n    history?: boolean;\n    address?: string;\n    wsUrl?: string;\n  }) {\n    this._eventEmitter = new EventEmitter();\n    this._connection = new HydraConnection({\n      url: url,\n      eventEmitter: this._eventEmitter,\n      history: history,\n      address: address,\n      wsUrl: wsUrl,\n    });\n    this._axiosInstance = axios.create({\n      baseURL: url,\n    });\n  }\n\n  /**\n   * Connects to the Hydra Head. This command is a no-op when a Head is already open.\n   */\n  async connect() {\n    if (this._status !== \"DISCONNECTED\") {\n      return;\n    }\n    this._connection.connect();\n    this._status = \"CONNECTED\";\n  }\n\n  /**\n   * FETCHERS and SUBMITTERS\n   */\n\n  /**\n   * UTXOs of the address.\n   * @param address - The address to fetch UTXO\n   * @param asset - UTXOs of a given asset\n   * @returns - Array of UTxOs\n   */\n  async fetchAddressUTxOs(address: string): Promise<UTxO[]> {\n    const utxos = await this.fetchUTxOs();\n    return utxos.filter((utxo) => utxo.output.address === address);\n  }\n\n  /**\n   * Fetch the latest protocol parameters.\n   * @param epoch\n   * @returns - Protocol parameters\n   */\n  async fetchProtocolParameters(epoch = Number.NaN): Promise<Protocol> {\n    return await this.subscribeProtocolParameters();\n  }\n\n  /**\n   * Get UTxOs for a given hash.\n   * @param hash\n   * @param index\n   * @returns - Array of UTxOs\n   */\n  async fetchUTxOs(hash?: string, index?: number): Promise<UTxO[]> {\n    const snapshotUTxOs = await this.subscribeSnapshotUtxo();\n\n    const outputsPromises: Promise<UTxO>[] = [];\n    snapshotUTxOs.forEach((utxo) => {\n      if (hash === undefined || utxo.input.txHash === hash) {\n        outputsPromises.push(Promise.resolve(utxo));\n      }\n    });\n    const outputs = await Promise.all(outputsPromises);\n\n    if (index !== undefined) {\n      return outputs.filter((utxo) => utxo.input.outputIndex === index);\n    }\n\n    return outputs;\n  }\n\n  /**\n   * Submit a transaction to the Hydra node. Note, unlike other providers, Hydra does not return a transaction hash.\n   * @param tx - The transaction in CBOR hex format\n   */\n  async submitTx(tx: string): Promise<string> {\n    try {\n      await this.newTx(tx, \"Witnessed Tx ConwayEra\");\n      const txId = await new Promise<string>((resolve) => {\n        this.onMessage((message) => {\n          if (message.tag === \"TxValid\") {\n            if (message.transaction && message.transaction.cborHex === tx) {\n              resolve(message.transaction.txId!);\n            }\n          }\n          if (message.tag === \"TxInvalid\") {\n            if (message.transaction && message.transaction.cborHex === tx) {\n              throw JSON.stringify(message.validationError);\n            }\n          }\n        });\n      });\n      return txId;\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }\n\n  /**\n   * Commands sent to the Hydra node.\n   *\n   * Accepts one of the following commands:\n   * - Init: init()\n   * - Abort: abort()\n   * - NewTx: newTx()\n   * - Decommit: decommit()\n   * - Close: close()\n   * - Contest: contest()\n   * - Fanout: fanout()\n   */\n\n  /**\n   * Initializes a new Head. This command is a no-op when a Head is already open and the server will output an CommandFailed message should this happen.\n   */\n  async init() {\n    this._connection.send({ tag: \"Init\" });\n  }\n\n  /**\n   * Aborts a head before it is opened. This can only be done before all participants have committed. Once opened, the head can't be aborted anymore but it can be closed using: `Close`.\n   */\n  async abort() {\n    this._connection.send({ tag: \"Abort\" });\n  }\n\n  /**\n   * Submit a transaction through the head. Note that the transaction is only broadcast if well-formed and valid.\n   *\n   * @param cborHex The base16-encoding of the CBOR encoding of some binary data\n   * @param type Allowed values: \"Tx ConwayEra\"\"Unwitnessed Tx ConwayEra\"\"Witnessed Tx ConwayEra\"\n   * @param description\n   */\n  async newTx(\n    cborHex: string,\n    type:\n      | \"Tx ConwayEra\"\n      | \"Unwitnessed Tx ConwayEra\"\n      | \"Witnessed Tx ConwayEra\",\n    description = \"\",\n    txId?: string\n  ) {\n    const transaction: hTransaction = {\n      type: type,\n      description: description,\n      cborHex: cborHex,\n      txId: txId,\n    };\n    const payload = {\n      tag: \"NewTx\",\n      transaction: transaction,\n    };\n    this._connection.send(payload);\n  }\n\n  /**\n   * Request to decommit a UTxO from a Head by providing a decommit tx. Upon reaching consensus, this will eventually result in corresponding transaction outputs becoming available on the layer 1.\n   *\n   * @param cborHex The base16-encoding of the CBOR encoding of some binary data\n   * @param type Allowed values: \"Tx ConwayEra\"\"Unwitnessed Tx ConwayEra\"\"Witnessed Tx ConwayEra\"\n   * @param description\n   */\n  async decommit(\n    cborHex: string,\n    type:\n      | \"Tx ConwayEra\"\n      | \"Unwitnessed Tx ConwayEra\"\n      | \"Witnessed Tx ConwayEra\",\n    description: string\n  ) {\n    const payload = {\n      tag: \"Decommit\",\n      decommitTx: {\n        type: type,\n        description: description,\n        cborHex: cborHex,\n      },\n    };\n    this._connection.send(payload);\n  }\n\n  /**\n   * Terminate a head with the latest known snapshot. This effectively moves the head from the Open state to the Close state where the contestation phase begin. As a result of closing a head, no more transactions can be submitted via NewTx.\n   */\n  async close() {\n    this.onStatusChange((status) => {\n      console.log(\"close status\", status);\n      if (status === \"OPEN\") {\n        this._connection.send({ tag: \"Close\" });\n      }\n    });\n  }\n\n  /**\n   * Challenge the latest snapshot announced as a result of a head closure from another participant. Note that this necessarily contest with the latest snapshot known of your local Hydra node. Participants can only contest once.\n   */\n  async contest() {\n    this._connection.send({ tag: \"Contest\" });\n  }\n\n  /**\n   * Finalize a head after the contestation period passed. This will distribute the final (as closed and maybe contested) head state back on the layer 1.\n   */\n  async fanout() {\n    this.onStatusChange((status) => {\n      console.log(\"status last\", status);\n      if (status === \"FANOUT_POSSIBLE\") {\n        this._connection.send({ tag: \"Fanout\" });\n      }\n    });\n  }\n\n  /**\n   * OPERATIONS\n   */\n\n  /**\n   * Draft a commit transaction, which can be completed and later submitted to the L1 network.\n   */\n  async buildCommit(payload: unknown, headers: RawAxiosRequestHeaders = {}) {\n    const txHex = await this.post(\"/commit\", payload, headers);\n    return txHex;\n  }\n\n  /**\n   * Emitted by the server after drafting a commit transaction with the user provided utxos. Transaction returned to the user is in it's cbor representation encoded as Base16.\n   */\n  async subscribeCommit() {\n    // todo\n    await this.get(\"/commit\");\n  }\n\n  /**\n   * Obtain a list of pending deposit transaction ID's.\n   */\n  async buildCommits() {\n    const commits = await this.get(\"/commits\");\n    return commits;\n  }\n\n  async subscribeCommits() {\n    // todo\n    await this.get(\"/commits\");\n  }\n\n  /**\n   * Recover deposited UTxO by providing a TxId of a deposit transaction in the request path.\n   */\n  async commitsTxId(headers: RawAxiosRequestHeaders = {}) {\n    // todo\n    await this.post(\"/commits/tx-id\", {}, headers);\n  }\n\n  async subscribeCommitsTxId() {\n    // todo\n    await this.get(\"/commits/tx-id\");\n  }\n\n  /**\n   * A set of unspent transaction outputs.\n   * @returns - Array of UTxOs\n   */\n  async subscribeSnapshotUtxo(): Promise<UTxO[]> {\n    const data = await this.get(`snapshot/utxo`);\n    const utxos: UTxO[] = [];\n    for (const [key, value] of Object.entries(data)) {\n      const utxo = hUTxO.toUTxO(value as hUTxO, key);\n      utxos.push(utxo);\n    }\n    return utxos;\n  }\n\n  /**\n   * Provide decommit transaction that needs to be applicable to the Hydra's local ledger state. Specified transaction outputs will be available on layer 1 after decommit is successfully processed.\n   */\n  async publishDecommit(headers: RawAxiosRequestHeaders = {}) {\n    // todo\n    await this.post(\"/decommit\", {}, headers);\n  }\n\n  /**\n   * Emitted by the server after drafting a decommit transaction.\n   */\n  async subscribeDecommit() {\n    // todo\n    await this.get(\"/decommit\");\n  }\n\n  /**\n   * Get protocol parameters.\n   * @returns - Protocol parameters\n   */\n  async subscribeProtocolParameters(): Promise<Protocol> {\n    const data = await this.get(\"protocol-parameters\");\n\n    const protocolParams = castProtocol({\n      coinsPerUtxoSize: data.utxoCostPerByte,\n      collateralPercent: data.collateralPercentage,\n      maxBlockExMem: data.maxBlockExecutionUnits.memory,\n      maxBlockExSteps: data.maxBlockExecutionUnits.steps,\n      maxBlockHeaderSize: data.maxBlockHeaderSize,\n      maxBlockSize: data.maxBlockBodySize,\n      maxCollateralInputs: data.maxCollateralInputs,\n      maxTxExMem: data.maxTxExecutionUnits.memory,\n      maxTxExSteps: data.maxTxExecutionUnits.steps,\n      maxTxSize: data.maxTxSize,\n      maxValSize: data.maxValueSize,\n      minFeeA: data.txFeePerByte,\n      minFeeB: data.txFeeFixed,\n      minPoolCost: data.minPoolCost,\n      poolDeposit: data.stakePoolDeposit,\n      priceMem: data.executionUnitPrices.priceMemory,\n      priceStep: data.executionUnitPrices.priceSteps,\n    });\n\n    return protocolParams;\n  }\n\n  /**\n   * Cardano transaction to be submitted to the L1 network. Accepts transactions encoded as Base16 CBOR string, TextEnvelope type or JSON.\n   */\n  async publishCardanoTransaction(headers: RawAxiosRequestHeaders = {}) {\n    // todo\n    await this.post(\"/cardano-transaction\", {}, headers);\n  }\n\n  /**\n   * Successfully submitted a cardano transaction to the L1 network.\n   */\n  async subscribeCardanoTransaction() {\n    // todo\n    await this.get(\"/cardano-transaction\");\n  }\n\n  /**\n   * Events emitted by the Hydra node.\n   * @param callback - The callback function to be called when a message is received\n   */\n  onMessage(\n    callback: (\n      data:\n        | Greetings\n        | PeerConnected\n        | PeerDisconnected\n        | PeerHandshakeFailure\n        | HeadIsInitializing\n        | Committed\n        | HeadIsOpen\n        | HeadIsClosed\n        | HeadIsContested\n        | ReadyToFanout\n        | HeadIsAborted\n        | HeadIsFinalized\n        | TxValid\n        | TxInvalid\n        | SnapshotConfirmed\n        | GetUTxOResponse\n        | InvalidInput\n        | PostTxOnChainFailed\n        | CommandFailed\n        | IgnoredHeadInitializing\n        | DecommitInvalid\n        | DecommitRequested\n        | DecommitApproved\n        | DecommitFinalized\n    ) => void\n  ) {\n    this._eventEmitter.on(\"onmessage\", (message) => {\n      switch (message.tag) {\n        case \"Greetings\":\n          callback(message as Greetings);\n          break;\n        case \"PeerConnected\":\n          callback(message as PeerConnected);\n          break;\n        case \"onPeerDisconnected\":\n          callback(message as PeerDisconnected);\n          break;\n        case \"PeerHandshakeFailure\":\n          callback(message as PeerHandshakeFailure);\n          break;\n        case \"HeadIsInitializing\":\n          callback(message as HeadIsInitializing);\n          break;\n        case \"Committed\":\n          callback(message as Committed);\n          break;\n        case \"HeadIsOpen\":\n          callback(message as HeadIsOpen);\n          break;\n        case \"HeadIsClosed\":\n          callback(message as HeadIsClosed);\n          break;\n        case \"HeadIsContested\":\n          callback(message as HeadIsContested);\n          break;\n        case \"ReadyToFanout\":\n          callback(message as ReadyToFanout);\n          break;\n        case \"HeadIsAborted\":\n          callback(message as HeadIsAborted);\n          break;\n        case \"HeadIsFinalized\":\n          callback(message as HeadIsFinalized);\n          break;\n        case \"TxValid\":\n          callback(message as TxValid);\n          break;\n        case \"TxInvalid\":\n          callback(message as TxInvalid);\n          break;\n        case \"SnapshotConfirmed\":\n          callback(message as SnapshotConfirmed);\n          break;\n        case \"GetUTxOResponse\":\n          callback(message as GetUTxOResponse);\n          break;\n        case \"InvalidInput\":\n          callback(message as InvalidInput);\n          break;\n        case \"PostTxOnChainFailed\":\n          callback(message as PostTxOnChainFailed);\n          break;\n        case \"CommandFailed\":\n          callback(message as CommandFailed);\n          break;\n        case \"IgnoredHeadInitializing\":\n          callback(message as IgnoredHeadInitializing);\n          break;\n        case \"DecommitInvalid\":\n          callback(message as DecommitInvalid);\n          break;\n        case \"DecommitRequested\":\n          callback(message as DecommitRequested);\n          break;\n        case \"DecommitApproved\":\n          callback(message as DecommitApproved);\n          break;\n        case \"DecommitFinalized\":\n          callback(message as DecommitFinalized);\n          break;\n        default:\n          break;\n      }\n    });\n  }\n\n  onStatusChange(callback: (status: hStatus) => void) {\n    this._eventEmitter.on(\"onstatuschange\", callback);\n  }\n\n  /**\n   * Useful utility functions.\n   */\n\n  /**\n   * A generic method to fetch data from a URL.\n   * @param url - The URL to fetch data from\n   * @returns - The data fetched from the URL\n   */\n  async get(url: string): Promise<any> {\n    try {\n      const { data, status } = await this._axiosInstance.get(url);\n      if (status === 200 || status == 202) {\n        return data;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }\n\n  /**\n   * A generic method to post data to a URL.\n   * @param url - The URL to post data to\n   * @param payload - The data to post\n   * @returns - The response from the URL\n   */\n  async post(\n    url: string,\n    payload: unknown,\n    headers: RawAxiosRequestHeaders\n  ): Promise<any> {\n    try {\n      const { data, status } = await this._axiosInstance.post(url, payload, {\n        headers,\n      });\n      if (status === 200 || status == 202) {\n        return data;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }\n\n  /**\n   * NOT IMPLEMENTED FETCHERS\n   */\n\n  fetchAccountInfo(address: string): Promise<AccountInfo> {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  async fetchAddressTxs(\n    address: string,\n    options: IFetcherOptions = DEFAULT_FETCHER_OPTIONS\n  ): Promise<TransactionInfo[]> {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  fetchAssetAddresses(\n    asset: string\n  ): Promise<{ address: string; quantity: string }[]> {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  fetchAssetMetadata(asset: string): Promise<AssetMetadata> {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  fetchBlockInfo(hash: string): Promise<BlockInfo> {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  fetchCollectionAssets(\n    policyId: string,\n    cursor?: string | number | undefined\n  ): Promise<{ assets: Asset[]; next: string | number | null }> {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  async fetchGovernanceProposal(\n    txHash: string,\n    certIndex: number\n  ): Promise<GovernanceProposalInfo> {\n    throw new Error(\"Method not implemented\");\n  }\n\n  fetchTxInfo(hash: string): Promise<TransactionInfo> {\n    throw new Error(\"Method not implemented.\");\n  }\n}",
      "dependencies": [
        "HydraProvider"
      ],
      "source": "mesh-hydra",
      "isReExportFile": false
    },
    {
      "key": "mesh-hydra:index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/index.ts",
      "name": "index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./hydra-instance\";\nexport * from \"./hydra-provider\";\n",
      "dependencies": [],
      "source": "mesh-hydra",
      "isReExportFile": false
    },
    {
      "key": "mesh-hydra:types.events.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events.ts",
      "name": "types.events.ts",
      "imports": [
        {
          "module": "Greetings",
          "items": [],
          "line": 9,
          "raw": "export type Greetings = {",
          "source": "mesh-hydra"
        },
        {
          "module": "PeerConnected",
          "items": [],
          "line": 27,
          "raw": "export type PeerConnected = {",
          "source": "mesh-hydra"
        },
        {
          "module": "PeerDisconnected",
          "items": [],
          "line": 34,
          "raw": "export type PeerDisconnected = {",
          "source": "mesh-hydra"
        },
        {
          "module": "PeerHandshakeFailure",
          "items": [],
          "line": 41,
          "raw": "export type PeerHandshakeFailure = {",
          "source": "mesh-hydra"
        },
        {
          "module": "HeadIsInitializing",
          "items": [],
          "line": 58,
          "raw": "export type HeadIsInitializing = {",
          "source": "mesh-hydra"
        },
        {
          "module": "Committed",
          "items": [],
          "line": 66,
          "raw": "export type Committed = {",
          "source": "mesh-hydra"
        },
        {
          "module": "HeadIsOpen",
          "items": [],
          "line": 74,
          "raw": "export type HeadIsOpen = {",
          "source": "mesh-hydra"
        },
        {
          "module": "HeadIsClosed",
          "items": [],
          "line": 82,
          "raw": "export type HeadIsClosed = {",
          "source": "mesh-hydra"
        },
        {
          "module": "HeadIsContested",
          "items": [],
          "line": 91,
          "raw": "export type HeadIsContested = {",
          "source": "mesh-hydra"
        },
        {
          "module": "ReadyToFanout",
          "items": [],
          "line": 100,
          "raw": "export type ReadyToFanout = {",
          "source": "mesh-hydra"
        },
        {
          "module": "HeadIsAborted",
          "items": [],
          "line": 107,
          "raw": "export type HeadIsAborted = {",
          "source": "mesh-hydra"
        },
        {
          "module": "HeadIsFinalized",
          "items": [],
          "line": 115,
          "raw": "export type HeadIsFinalized = {",
          "source": "mesh-hydra"
        },
        {
          "module": "TxValid",
          "items": [],
          "line": 123,
          "raw": "export type TxValid = {",
          "source": "mesh-hydra"
        },
        {
          "module": "TxInvalid",
          "items": [],
          "line": 131,
          "raw": "export type TxInvalid = {",
          "source": "mesh-hydra"
        },
        {
          "module": "SnapshotConfirmed",
          "items": [],
          "line": 141,
          "raw": "export type SnapshotConfirmed = {",
          "source": "mesh-hydra"
        },
        {
          "module": "GetUTxOResponse",
          "items": [],
          "line": 149,
          "raw": "export type GetUTxOResponse = {",
          "source": "mesh-hydra"
        },
        {
          "module": "InvalidInput",
          "items": [],
          "line": 157,
          "raw": "export type InvalidInput = {",
          "source": "mesh-hydra"
        },
        {
          "module": "PostTxOnChainFailed",
          "items": [],
          "line": 165,
          "raw": "export type PostTxOnChainFailed = {",
          "source": "mesh-hydra"
        },
        {
          "module": "CommandFailed",
          "items": [],
          "line": 173,
          "raw": "export type CommandFailed = {",
          "source": "mesh-hydra"
        },
        {
          "module": "IgnoredHeadInitializing",
          "items": [],
          "line": 189,
          "raw": "export type IgnoredHeadInitializing = {",
          "source": "mesh-hydra"
        },
        {
          "module": "DecommitInvalid",
          "items": [],
          "line": 199,
          "raw": "export type DecommitInvalid = {",
          "source": "mesh-hydra"
        },
        {
          "module": "DecommitRequested",
          "items": [],
          "line": 212,
          "raw": "export type DecommitRequested = {",
          "source": "mesh-hydra"
        },
        {
          "module": "DecommitApproved",
          "items": [],
          "line": 221,
          "raw": "export type DecommitApproved = {",
          "source": "mesh-hydra"
        },
        {
          "module": "DecommitFinalized",
          "items": [],
          "line": 230,
          "raw": "export type DecommitFinalized = {",
          "source": "mesh-hydra"
        }
      ],
      "functions": [],
      "types": [
        {
          "name": "Greetings",
          "definition": "export type Greetings = {\n  tag: \"Greetings\";\n  me: {\n    vkey: string;\n  };\n  headStatus:\n    | \"Idle\"\n    | \"Initializing\"\n    | \"Open\"\n    | \"Closed\"\n    | \"FanoutPossible\"\n    | \"Final\";\n  hydraHeadId: string;\n  snapshotUtxo: hUTxOs;\n  timestamp: string;\n  hydraNodeVersion: string;\n};\n\nexport type PeerConnected = {\n  tag: \"PeerConnected\";\n  peer: string;\n  seq: number;\n  timestamp: string;\n};\n\nexport type PeerDisconnected = {\n  tag: \"PeerDisconnected\";\n  peer: string;\n  seq: number;\n  timestamp: string;\n};\n\nexport type PeerHandshakeFailure = {\n  tag: \"PeerHandshakeFailure\";\n  remoteHost:\n    | {\n        tag: \"IPv4\";\n        ipv4: string;\n      }\n    | {\n        tag: \"IPv6\";\n        ipv6: string;\n      };\n  ourVersion: number;\n  theirVersions: number[];\n  seq: number;\n  timestamp: string;\n};\n\nexport type HeadIsInitializing = {\n  tag: \"HeadIsInitializing\";\n  headId: string;\n  parties: HydraParty[];\n  seq: number;\n  timestamp: string;\n};\n\nexport type Committed = {\n  tag: \"Committed\";\n  parties: HydraParty[];\n  utxo: hUTxOs;\n  seq: number;\n  timestamp: string;\n};\n\nexport type HeadIsOpen = {\n  tag: \"HeadIsOpen\";\n  headId: string;\n  utxo: hUTxOs;\n  seq: number;\n  timestamp: string;\n};\n\nexport type HeadIsClosed = {\n  tag: \"HeadIsClosed\";\n  headId: string;\n  snapshotNumber: number;\n  contestationDeadline: string;\n  seq: number;\n  timestamp: string;\n};\n\nexport type HeadIsContested = {\n  tag: \"HeadIsContested\";\n  headId: string;\n  snapshotNumber: number;\n  contestationDeadline: string;\n  seq: number;\n  timestamp: string;\n};\n\nexport type ReadyToFanout = {\n  tag: \"ReadyToFanout\";\n  headId: string;\n  seq: number;\n  timestamp: string;\n};\n\nexport type HeadIsAborted = {\n  tag: \"HeadIsAborted\";\n  headId: string;\n  utxo: hUTxOs;\n  seq: number;\n  timestamp: string;\n};\n\nexport type HeadIsFinalized = {\n  tag: \"HeadIsFinalized\";\n  headId: string;\n  utxo: hUTxOs;\n  seq: number;\n  timestamp: string;\n};\n\nexport type TxValid = {\n  headId: string;\n  tag: \"TxValid\";\n  seq: number;\n  timestamp: string;\n  transaction: hTransaction;\n};\n\nexport type TxInvalid = {\n  tag: \"TxInvalid\";\n  headId: string;\n  utxo: hUTxOs;\n  transaction: hTransaction;\n  validationError: { reason: string };\n  seq: number;\n  timestamp: string;\n};\n\nexport type SnapshotConfirmed = {\n  tag: \"SnapshotConfirmed\";\n  headId: string;\n  snapshot: HydraSnapshot;\n  seq: number;\n  timestamp: string;\n};\n\nexport type GetUTxOResponse = {\n  tag: \"GetUTxOResponse\";\n  headId: string;\n  utxo: hUTxOs;\n  seq: number;\n  timestamp: string;\n};\n\nexport type InvalidInput = {\n  tag: \"InvalidInput\";\n  reason: string;\n  input: string;\n  seq: number;\n  timestamp: string;\n};\n\nexport type PostTxOnChainFailed = {\n  tag: \"PostTxOnChainFailed\";\n  postChainTx: PostChainTx;\n  postTxError: unknown;\n  seq: number;\n  timestamp: string;\n};\n\nexport type CommandFailed = {\n  tag: \"CommandFailed\";\n  clientInput:\n    | {\n        tag: \"Abort\";\n      }\n    | { tag: \"NewTx\"; transaction: hTransaction }\n    | { tag: \"GetUTxO\" }\n    | { tag: \"Decommit\"; decommitTx: hTransaction }\n    | { tag: \"Close\" }\n    | { tag: \"Contest\" }\n    | { tag: \"Fanout\" };\n  seq: number;\n  timestamp: string;\n};\n\nexport type IgnoredHeadInitializing = {\n  tag: \"IgnoredHeadInitializing\";\n  headId: string;\n  contestationPeriod: number;\n  parties: HydraParty[];\n  participants: string[];\n  seq: number;\n  timestamp: string;\n};\n\nexport type DecommitInvalid = {\n  tag: \"DecommitInvalid\";\n  headId: string;\n  decommitTx: hTransaction;\n  decommitInvalidReason:\n    | {\n        tag: \"DecommitTxInvalid\";\n        localUtxo: hUTxOs;\n        validationError: { reason: string };\n      }\n    | { tag: \"DecommitAlreadyInFlight\"; otherDecommitTxId: string };\n};\n\nexport type DecommitRequested = {\n  tag: \"DecommitRequested\";\n  headId: string;\n  decommitTx: hTransaction;\n  utxoToDecommit: hUTxOs;\n  seq: number;\n  timestmap: string;\n};\n\nexport type DecommitApproved = {\n  tag: \"DecommitApproved\";\n  headId: string;\n  decommitTxId: string;\n  utxoToDecommit: hUTxOs;\n  seq: number;\n  timestamp: string;\n};\n\nexport type DecommitFinalized = {\n  tag: \"DecommitFinalized\";\n  headId: string;\n  decommitTxId: string;\n  seq: number;\n  timestamp: string;\n};",
          "isPublic": true,
          "line": 9,
          "raw": "export type Greetings = {",
          "source": "mesh-hydra"
        },
        {
          "name": "PeerConnected",
          "definition": "export type PeerConnected = {\n  tag: \"PeerConnected\";\n  peer: string;",
          "isPublic": true,
          "line": 27,
          "raw": "export type PeerConnected = {",
          "source": "mesh-hydra"
        },
        {
          "name": "PeerDisconnected",
          "definition": "export type PeerDisconnected = {\n  tag: \"PeerDisconnected\";\n  peer: string;",
          "isPublic": true,
          "line": 34,
          "raw": "export type PeerDisconnected = {",
          "source": "mesh-hydra"
        },
        {
          "name": "PeerHandshakeFailure",
          "definition": "export type PeerHandshakeFailure = {\n  tag: \"PeerHandshakeFailure\";\n  remoteHost:\n    | {\n        tag: \"IPv4\";\n        ipv4: string;",
          "isPublic": true,
          "line": 41,
          "raw": "export type PeerHandshakeFailure = {",
          "source": "mesh-hydra"
        },
        {
          "name": "HeadIsInitializing",
          "definition": "export type HeadIsInitializing = {\n  tag: \"HeadIsInitializing\";\n  headId: string;",
          "isPublic": true,
          "line": 58,
          "raw": "export type HeadIsInitializing = {",
          "source": "mesh-hydra"
        },
        {
          "name": "Committed",
          "definition": "export type Committed = {\n  tag: \"Committed\";\n  parties: HydraParty[];",
          "isPublic": true,
          "line": 66,
          "raw": "export type Committed = {",
          "source": "mesh-hydra"
        },
        {
          "name": "HeadIsOpen",
          "definition": "export type HeadIsOpen = {\n  tag: \"HeadIsOpen\";\n  headId: string;",
          "isPublic": true,
          "line": 74,
          "raw": "export type HeadIsOpen = {",
          "source": "mesh-hydra"
        },
        {
          "name": "HeadIsClosed",
          "definition": "export type HeadIsClosed = {\n  tag: \"HeadIsClosed\";\n  headId: string;",
          "isPublic": true,
          "line": 82,
          "raw": "export type HeadIsClosed = {",
          "source": "mesh-hydra"
        },
        {
          "name": "HeadIsContested",
          "definition": "export type HeadIsContested = {\n  tag: \"HeadIsContested\";\n  headId: string;",
          "isPublic": true,
          "line": 91,
          "raw": "export type HeadIsContested = {",
          "source": "mesh-hydra"
        },
        {
          "name": "ReadyToFanout",
          "definition": "export type ReadyToFanout = {\n  tag: \"ReadyToFanout\";\n  headId: string;",
          "isPublic": true,
          "line": 100,
          "raw": "export type ReadyToFanout = {",
          "source": "mesh-hydra"
        },
        {
          "name": "HeadIsAborted",
          "definition": "export type HeadIsAborted = {\n  tag: \"HeadIsAborted\";\n  headId: string;",
          "isPublic": true,
          "line": 107,
          "raw": "export type HeadIsAborted = {",
          "source": "mesh-hydra"
        },
        {
          "name": "HeadIsFinalized",
          "definition": "export type HeadIsFinalized = {\n  tag: \"HeadIsFinalized\";\n  headId: string;",
          "isPublic": true,
          "line": 115,
          "raw": "export type HeadIsFinalized = {",
          "source": "mesh-hydra"
        },
        {
          "name": "TxValid",
          "definition": "export type TxValid = {\n  headId: string;\n  tag: \"TxValid\";",
          "isPublic": true,
          "line": 123,
          "raw": "export type TxValid = {",
          "source": "mesh-hydra"
        },
        {
          "name": "TxInvalid",
          "definition": "export type TxInvalid = {\n  tag: \"TxInvalid\";\n  headId: string;",
          "isPublic": true,
          "line": 131,
          "raw": "export type TxInvalid = {",
          "source": "mesh-hydra"
        },
        {
          "name": "SnapshotConfirmed",
          "definition": "export type SnapshotConfirmed = {\n  tag: \"SnapshotConfirmed\";\n  headId: string;",
          "isPublic": true,
          "line": 141,
          "raw": "export type SnapshotConfirmed = {",
          "source": "mesh-hydra"
        },
        {
          "name": "GetUTxOResponse",
          "definition": "export type GetUTxOResponse = {\n  tag: \"GetUTxOResponse\";\n  headId: string;",
          "isPublic": true,
          "line": 149,
          "raw": "export type GetUTxOResponse = {",
          "source": "mesh-hydra"
        },
        {
          "name": "InvalidInput",
          "definition": "export type InvalidInput = {\n  tag: \"InvalidInput\";\n  reason: string;",
          "isPublic": true,
          "line": 157,
          "raw": "export type InvalidInput = {",
          "source": "mesh-hydra"
        },
        {
          "name": "PostTxOnChainFailed",
          "definition": "export type PostTxOnChainFailed = {\n  tag: \"PostTxOnChainFailed\";\n  postChainTx: PostChainTx;",
          "isPublic": true,
          "line": 165,
          "raw": "export type PostTxOnChainFailed = {",
          "source": "mesh-hydra"
        },
        {
          "name": "CommandFailed",
          "definition": "export type CommandFailed = {\n  tag: \"CommandFailed\";\n  clientInput:\n    | {\n        tag: \"Abort\";\n      }",
          "isPublic": true,
          "line": 173,
          "raw": "export type CommandFailed = {",
          "source": "mesh-hydra"
        },
        {
          "name": "IgnoredHeadInitializing",
          "definition": "export type IgnoredHeadInitializing = {\n  tag: \"IgnoredHeadInitializing\";\n  headId: string;",
          "isPublic": true,
          "line": 189,
          "raw": "export type IgnoredHeadInitializing = {",
          "source": "mesh-hydra"
        },
        {
          "name": "DecommitInvalid",
          "definition": "export type DecommitInvalid = {\n  tag: \"DecommitInvalid\";\n  headId: string;",
          "isPublic": true,
          "line": 199,
          "raw": "export type DecommitInvalid = {",
          "source": "mesh-hydra"
        },
        {
          "name": "DecommitRequested",
          "definition": "export type DecommitRequested = {\n  tag: \"DecommitRequested\";\n  headId: string;",
          "isPublic": true,
          "line": 212,
          "raw": "export type DecommitRequested = {",
          "source": "mesh-hydra"
        },
        {
          "name": "DecommitApproved",
          "definition": "export type DecommitApproved = {\n  tag: \"DecommitApproved\";\n  headId: string;",
          "isPublic": true,
          "line": 221,
          "raw": "export type DecommitApproved = {",
          "source": "mesh-hydra"
        },
        {
          "name": "DecommitFinalized",
          "definition": "export type DecommitFinalized = {\n  tag: \"DecommitFinalized\";\n  headId: string;",
          "isPublic": true,
          "line": 230,
          "raw": "export type DecommitFinalized = {",
          "source": "mesh-hydra"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  HydraParty,\n  HydraSnapshot,\n  hTransaction,\n} from \"../types\";\nimport { hUTxOs } from \"./hUTxOs\";\nimport { PostChainTx } from \"./hydra-post-chain-tx\";\n\nexport type Greetings = {\n  tag: \"Greetings\";\n  me: {\n    vkey: string;\n  };\n  headStatus:\n    | \"Idle\"\n    | \"Initializing\"\n    | \"Open\"\n    | \"Closed\"\n    | \"FanoutPossible\"\n    | \"Final\";\n  hydraHeadId: string;\n  snapshotUtxo: hUTxOs;\n  timestamp: string;\n  hydraNodeVersion: string;\n};\n\nexport type PeerConnected = {\n  tag: \"PeerConnected\";\n  peer: string;\n  seq: number;\n  timestamp: string;\n};\n\nexport type PeerDisconnected = {\n  tag: \"PeerDisconnected\";\n  peer: string;\n  seq: number;\n  timestamp: string;\n};\n\nexport type PeerHandshakeFailure = {\n  tag: \"PeerHandshakeFailure\";\n  remoteHost:\n    | {\n        tag: \"IPv4\";\n        ipv4: string;\n      }\n    | {\n        tag: \"IPv6\";\n        ipv6: string;\n      };\n  ourVersion: number;\n  theirVersions: number[];\n  seq: number;\n  timestamp: string;\n};\n\nexport type HeadIsInitializing = {\n  tag: \"HeadIsInitializing\";\n  headId: string;\n  parties: HydraParty[];\n  seq: number;\n  timestamp: string;\n};\n\nexport type Committed = {\n  tag: \"Committed\";\n  parties: HydraParty[];\n  utxo: hUTxOs;\n  seq: number;\n  timestamp: string;\n};\n\nexport type HeadIsOpen = {\n  tag: \"HeadIsOpen\";\n  headId: string;\n  utxo: hUTxOs;\n  seq: number;\n  timestamp: string;\n};\n\nexport type HeadIsClosed = {\n  tag: \"HeadIsClosed\";\n  headId: string;\n  snapshotNumber: number;\n  contestationDeadline: string;\n  seq: number;\n  timestamp: string;\n};\n\nexport type HeadIsContested = {\n  tag: \"HeadIsContested\";\n  headId: string;\n  snapshotNumber: number;\n  contestationDeadline: string;\n  seq: number;\n  timestamp: string;\n};\n\nexport type ReadyToFanout = {\n  tag: \"ReadyToFanout\";\n  headId: string;\n  seq: number;\n  timestamp: string;\n};\n\nexport type HeadIsAborted = {\n  tag: \"HeadIsAborted\";\n  headId: string;\n  utxo: hUTxOs;\n  seq: number;\n  timestamp: string;\n};\n\nexport type HeadIsFinalized = {\n  tag: \"HeadIsFinalized\";\n  headId: string;\n  utxo: hUTxOs;\n  seq: number;\n  timestamp: string;\n};\n\nexport type TxValid = {\n  headId: string;\n  tag: \"TxValid\";\n  seq: number;\n  timestamp: string;\n  transaction: hTransaction;\n};\n\nexport type TxInvalid = {\n  tag: \"TxInvalid\";\n  headId: string;\n  utxo: hUTxOs;\n  transaction: hTransaction;\n  validationError: { reason: string };\n  seq: number;\n  timestamp: string;\n};\n\nexport type SnapshotConfirmed = {\n  tag: \"SnapshotConfirmed\";\n  headId: string;\n  snapshot: HydraSnapshot;\n  seq: number;\n  timestamp: string;\n};\n\nexport type GetUTxOResponse = {\n  tag: \"GetUTxOResponse\";\n  headId: string;\n  utxo: hUTxOs;\n  seq: number;\n  timestamp: string;\n};\n\nexport type InvalidInput = {\n  tag: \"InvalidInput\";\n  reason: string;\n  input: string;\n  seq: number;\n  timestamp: string;\n};\n\nexport type PostTxOnChainFailed = {\n  tag: \"PostTxOnChainFailed\";\n  postChainTx: PostChainTx;\n  postTxError: unknown;\n  seq: number;\n  timestamp: string;\n};\n\nexport type CommandFailed = {\n  tag: \"CommandFailed\";\n  clientInput:\n    | {\n        tag: \"Abort\";\n      }\n    | { tag: \"NewTx\"; transaction: hTransaction }\n    | { tag: \"GetUTxO\" }\n    | { tag: \"Decommit\"; decommitTx: hTransaction }\n    | { tag: \"Close\" }\n    | { tag: \"Contest\" }\n    | { tag: \"Fanout\" };\n  seq: number;\n  timestamp: string;\n};\n\nexport type IgnoredHeadInitializing = {\n  tag: \"IgnoredHeadInitializing\";\n  headId: string;\n  contestationPeriod: number;\n  parties: HydraParty[];\n  participants: string[];\n  seq: number;\n  timestamp: string;\n};\n\nexport type DecommitInvalid = {\n  tag: \"DecommitInvalid\";\n  headId: string;\n  decommitTx: hTransaction;\n  decommitInvalidReason:\n    | {\n        tag: \"DecommitTxInvalid\";\n        localUtxo: hUTxOs;\n        validationError: { reason: string };\n      }\n    | { tag: \"DecommitAlreadyInFlight\"; otherDecommitTxId: string };\n};\n\nexport type DecommitRequested = {\n  tag: \"DecommitRequested\";\n  headId: string;\n  decommitTx: hTransaction;\n  utxoToDecommit: hUTxOs;\n  seq: number;\n  timestmap: string;\n};\n\nexport type DecommitApproved = {\n  tag: \"DecommitApproved\";\n  headId: string;\n  decommitTxId: string;\n  utxoToDecommit: hUTxOs;\n  seq: number;\n  timestamp: string;\n};\n\nexport type DecommitFinalized = {\n  tag: \"DecommitFinalized\";\n  headId: string;\n  decommitTxId: string;\n  seq: number;\n  timestamp: string;\n};\n",
      "dependencies": [
        "Greetings",
        "PeerConnected",
        "PeerDisconnected",
        "PeerHandshakeFailure",
        "HeadIsInitializing",
        "Committed",
        "HeadIsOpen",
        "HeadIsClosed",
        "HeadIsContested",
        "ReadyToFanout",
        "HeadIsAborted",
        "HeadIsFinalized",
        "TxValid",
        "TxInvalid",
        "SnapshotConfirmed",
        "GetUTxOResponse",
        "InvalidInput",
        "PostTxOnChainFailed",
        "CommandFailed",
        "IgnoredHeadInitializing",
        "DecommitInvalid",
        "DecommitRequested",
        "DecommitApproved",
        "DecommitFinalized"
      ],
      "source": "mesh-hydra",
      "isReExportFile": false
    },
    {
      "key": "mesh-hydra:types.hAssets.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hAssets.ts",
      "name": "types.hAssets.ts",
      "imports": [
        {
          "module": "hAssets",
          "items": [],
          "line": 3,
          "raw": "export type hAssets = {",
          "source": "mesh-hydra"
        },
        {
          "module": "hAssets",
          "items": [],
          "line": 11,
          "raw": "export function hAssets(assets: Asset[]): hAssets {",
          "source": "mesh-hydra"
        }
      ],
      "functions": [
        {
          "name": "hAssets",
          "signature": "export function hAssets(assets: Asset[]): hAssets {",
          "documentation": "",
          "parameters": [
            {
              "name": "assets",
              "type": "Asset[]",
              "optional": false
            }
          ],
          "returnType": "hAssets",
          "isPublic": true,
          "line": 11,
          "raw": "export function hAssets(assets: Asset[]): hAssets {\n  return assets.reduce((p, asset) => {\n      if (asset.unit === \"\" || asset.unit === \"lovelace\") {\n        p[\"lovelace\"] += BigInt(asset.quantity);\n      } else {\n        const policyId = asset.unit.slice(0, 56);\n        const assetName = asset.unit.slice(56);\n        if (!p[policyId]) p[policyId] = {};\n        p[policyId][assetName] = (p[policyId][assetName] ?? BigInt(0)) + BigInt(asset.quantity);\n      }\n      return p;\n    }, { lovelace: BigInt(0) } as hAssets\n  );\n}",
          "source": "mesh-hydra",
          "implementation": "export function hAssets(assets: Asset[]): hAssets {\n  return assets.reduce((p, asset) => {\n      if (asset.unit === \"\" || asset.unit === \"lovelace\") {\n        p[\"lovelace\"] += BigInt(asset.quantity);\n      } else {\n        const policyId = asset.unit.slice(0, 56);\n        const assetName = asset.unit.slice(56);\n        if (!p[policyId]) p[policyId] = {};\n        p[policyId][assetName] = (p[policyId][assetName] ?? BigInt(0)) + BigInt(asset.quantity);\n      }\n      return p;\n    }, { lovelace: BigInt(0) } as hAssets\n  );\n}"
        }
      ],
      "types": [
        {
          "name": "hAssets",
          "definition": "export type hAssets = {\n  lovelace: bigint;\n} & {\n  [policyId: string]: {\n    [assetName: string]: bigint;\n  };\n};\n\nexport function hAssets(assets: Asset[]): hAssets {\n  return assets.reduce((p, asset) => {",
          "isPublic": true,
          "line": 3,
          "raw": "export type hAssets = {",
          "source": "mesh-hydra"
        }
      ],
      "constants": [
        {
          "name": "policyId",
          "type": "any",
          "value": "asset.unit.slice(0, 56);",
          "isPublic": true,
          "line": 16,
          "raw": "const policyId = asset.unit.slice(0, 56);",
          "source": "mesh-hydra"
        },
        {
          "name": "assetName",
          "type": "any",
          "value": "asset.unit.slice(56);",
          "isPublic": true,
          "line": 17,
          "raw": "const assetName = asset.unit.slice(56);",
          "source": "mesh-hydra"
        },
        {
          "name": "assets",
          "type": "Asset[]",
          "value": "[];",
          "isPublic": true,
          "line": 27,
          "raw": "const assets: Asset[] = [];",
          "source": "mesh-hydra"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { Asset } from \"@meshsdk/common\";\n\nexport type hAssets = {\n  lovelace: bigint;\n} & {\n  [policyId: string]: {\n    [assetName: string]: bigint;\n  };\n};\n\nexport function hAssets(assets: Asset[]): hAssets {\n  return assets.reduce((p, asset) => {\n      if (asset.unit === \"\" || asset.unit === \"lovelace\") {\n        p[\"lovelace\"] += BigInt(asset.quantity);\n      } else {\n        const policyId = asset.unit.slice(0, 56);\n        const assetName = asset.unit.slice(56);\n        if (!p[policyId]) p[policyId] = {};\n        p[policyId][assetName] = (p[policyId][assetName] ?? BigInt(0)) + BigInt(asset.quantity);\n      }\n      return p;\n    }, { lovelace: BigInt(0) } as hAssets\n  );\n}\n\nhAssets.toAssets = (hAssets: hAssets): Asset[] => {\n  const assets: Asset[] = [];\n  for (const policy of Object.keys(hAssets)) {\n    if (policy === \"lovelace\") {\n      assets.push({\n        unit: policy,\n        quantity: hAssets[policy].toString(),\n      });\n    } else {\n      for (const assetName of Object.keys(hAssets[policy]!)) {\n        assets.push({\n          unit: policy + assetName,\n          quantity: hAssets[policy]![assetName]!.toString(),\n        });\n      }\n    }\n  }\n  return assets;\n}\n",
      "dependencies": [
        "hAssets",
        "hAssets"
      ],
      "source": "mesh-hydra",
      "isReExportFile": false
    },
    {
      "key": "mesh-hydra:types.hReferenceScript.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hReferenceScript.ts",
      "name": "types.hReferenceScript.ts",
      "imports": [
        {
          "module": "hReferenceScript",
          "items": [],
          "line": 1,
          "raw": "export type hReferenceScript = {",
          "source": "mesh-hydra"
        }
      ],
      "functions": [],
      "types": [
        {
          "name": "hReferenceScript",
          "definition": "export type hReferenceScript = {\n  scriptLanguage: string;\n  script: {\n    cborHex: string;\n    description: string;",
          "isPublic": true,
          "line": 1,
          "raw": "export type hReferenceScript = {",
          "source": "mesh-hydra"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export type hReferenceScript = {\n  scriptLanguage: string;\n  script: {\n    cborHex: string;\n    description: string;\n    type:\n      | \"SimpleScript\"\n      | \"PlutusScriptV1\"\n      | \"PlutusScriptV2\"\n      | \"PlutusScriptV3\";\n  };\n};\n",
      "dependencies": [
        "hReferenceScript"
      ],
      "source": "mesh-hydra",
      "isReExportFile": false
    },
    {
      "key": "mesh-hydra:types.hStatus.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hStatus.ts",
      "name": "types.hStatus.ts",
      "imports": [
        {
          "module": "hStatus",
          "items": [],
          "line": 1,
          "raw": "export type hStatus = typeof status[number];",
          "source": "mesh-hydra"
        },
        {
          "module": "hStatus",
          "items": [],
          "line": 3,
          "raw": "export function hStatus(value: { headStatus?: string; tag?: string; }): hStatus | null {",
          "source": "mesh-hydra"
        }
      ],
      "functions": [
        {
          "name": "hStatus",
          "signature": "export function hStatus(value: { headStatus?: string; tag?: string; }): hStatus | null {",
          "documentation": "",
          "parameters": [
            {
              "name": "value",
              "type": "{ headStatus?: string; tag?: string; }",
              "optional": true
            }
          ],
          "returnType": "hStatus | null",
          "isPublic": true,
          "line": 3,
          "raw": "export function hStatus(value: { headStatus?: string; tag?: string; }): hStatus | null {\n  if (value.headStatus === \"Open\") return \"OPEN\";\n  \n  switch (value.tag) {\n    case \"HeadIsInitializing\":\n      return \"INITIALIZING\";\n    case \"HeadIsOpen\":\n      return \"OPEN\";\n    case \"HeadIsClosed\":\n      return \"CLOSED\";\n    case \"ReadyToFanout\":\n      return \"FANOUT_POSSIBLE\";\n    case \"HeadIsFinalized\":\n      return \"FINAL\";\n    default:\n      return null;\n  }\n}",
          "source": "mesh-hydra",
          "implementation": "export function hStatus(value: { headStatus?: string; tag?: string; }): hStatus | null {\n  if (value.headStatus === \"Open\") return \"OPEN\";\n  \n  switch (value.tag) {\n    case \"HeadIsInitializing\":\n      return \"INITIALIZING\";\n    case \"HeadIsOpen\":\n      return \"OPEN\";\n    case \"HeadIsClosed\":\n      return \"CLOSED\";\n    case \"ReadyToFanout\":\n      return \"FANOUT_POSSIBLE\";\n    case \"HeadIsFinalized\":\n      return \"FINAL\";\n    default:\n      return null;\n  }\n}"
        }
      ],
      "types": [
        {
          "name": "hStatus",
          "definition": "export type hStatus = typeof status[number];",
          "isPublic": true,
          "line": 1,
          "raw": "export type hStatus = typeof status[number];",
          "source": "mesh-hydra"
        }
      ],
      "constants": [
        {
          "name": "status",
          "type": "any",
          "value": "[",
          "isPublic": true,
          "line": 22,
          "raw": "const status = [",
          "source": "mesh-hydra"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export type hStatus = typeof status[number];\n\nexport function hStatus(value: { headStatus?: string; tag?: string; }): hStatus | null {\n  if (value.headStatus === \"Open\") return \"OPEN\";\n  \n  switch (value.tag) {\n    case \"HeadIsInitializing\":\n      return \"INITIALIZING\";\n    case \"HeadIsOpen\":\n      return \"OPEN\";\n    case \"HeadIsClosed\":\n      return \"CLOSED\";\n    case \"ReadyToFanout\":\n      return \"FANOUT_POSSIBLE\";\n    case \"HeadIsFinalized\":\n      return \"FINAL\";\n    default:\n      return null;\n  }\n}\n\nconst status = [\n  \"IDLE\",\n  \"DISCONNECTED\",\n  \"CONNECTING\",\n  \"CONNECTED\",\n  \"INITIALIZING\",\n  \"OPEN\",\n  \"CLOSED\",\n  \"FANOUT_POSSIBLE\",\n  \"FINAL\",\n] as const;\n",
      "dependencies": [
        "hStatus",
        "hStatus"
      ],
      "source": "mesh-hydra",
      "isReExportFile": false
    },
    {
      "key": "mesh-hydra:types.hTransaction.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hTransaction.ts",
      "name": "types.hTransaction.ts",
      "imports": [
        {
          "module": "hTransaction",
          "items": [],
          "line": 1,
          "raw": "export type hTransaction = {",
          "source": "mesh-hydra"
        }
      ],
      "functions": [],
      "types": [
        {
          "name": "hTransaction",
          "definition": "export type hTransaction = {\n  type: \"Tx ConwayEra\" | \"Unwitnessed Tx ConwayEra\" | \"Witnessed Tx ConwayEra\";\n  description: string;",
          "isPublic": true,
          "line": 1,
          "raw": "export type hTransaction = {",
          "source": "mesh-hydra"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export type hTransaction = {\n  type: \"Tx ConwayEra\" | \"Unwitnessed Tx ConwayEra\" | \"Witnessed Tx ConwayEra\";\n  description: string;\n  cborHex: string;\n  txId?: string;\n};\n",
      "dependencies": [
        "hTransaction"
      ],
      "source": "mesh-hydra",
      "isReExportFile": false
    },
    {
      "key": "mesh-hydra:types.hUTxOs.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hUTxOs.ts",
      "name": "types.hUTxOs.ts",
      "imports": [
        {
          "module": "hUTxOs",
          "items": [],
          "line": 5,
          "raw": "export type hUTxOs = {",
          "source": "mesh-hydra"
        },
        {
          "module": "hUTxOs",
          "items": [],
          "line": 9,
          "raw": "export function hUTxOs(utxos: UTxO[]): hUTxOs {",
          "source": "mesh-hydra"
        },
        {
          "module": "hUTxO",
          "items": [],
          "line": 15,
          "raw": "export type hUTxO = {",
          "source": "mesh-hydra"
        },
        {
          "module": "hUTxO",
          "items": [],
          "line": 25,
          "raw": "export function hUTxO(utxo: UTxO): hUTxO {",
          "source": "mesh-hydra"
        }
      ],
      "functions": [
        {
          "name": "hUTxOs",
          "signature": "export function hUTxOs(utxos: UTxO[]): hUTxOs {",
          "documentation": "",
          "parameters": [
            {
              "name": "utxos",
              "type": "UTxO[]",
              "optional": false
            }
          ],
          "returnType": "hUTxOs",
          "isPublic": true,
          "line": 9,
          "raw": "export function hUTxOs(utxos: UTxO[]): hUTxOs {\n  return Object.fromEntries(utxos.map(\n    (utxo) => [utxo.input.txHash + \"#\" + utxo.input.outputIndex, hUTxO(utxo)]\n  ));\n}",
          "source": "mesh-hydra",
          "implementation": "export function hUTxOs(utxos: UTxO[]): hUTxOs {\n  return Object.fromEntries(utxos.map(\n    (utxo) => [utxo.input.txHash + \"#\" + utxo.input.outputIndex, hUTxO(utxo)]\n  ));\n}"
        },
        {
          "name": "hUTxO",
          "signature": "export function hUTxO(utxo: UTxO): hUTxO {",
          "documentation": "",
          "parameters": [
            {
              "name": "utxo",
              "type": "UTxO",
              "optional": false
            }
          ],
          "returnType": "hUTxO",
          "isPublic": true,
          "line": 25,
          "raw": "export function hUTxO(utxo: UTxO): hUTxO {\n  return {\n    address: utxo.output.address,\n    value: hAssets(utxo.output.amount),\n    referenceScript: null,\n    inlineDatum: utxo.output.plutusData ? JSON.parse(utxo.output.plutusData) : null,\n    inlineDatumhash: utxo.output.dataHash ?? null,\n    datum: utxo.output.plutusData ?? null,\n    datumhash: utxo.output.dataHash ?? null,\n  };\n}",
          "source": "mesh-hydra",
          "implementation": "export function hUTxO(utxo: UTxO): hUTxO {\n  return {\n    address: utxo.output.address,\n    value: hAssets(utxo.output.amount),\n    referenceScript: null,\n    inlineDatum: utxo.output.plutusData ? JSON.parse(utxo.output.plutusData) : null,\n    inlineDatumhash: utxo.output.dataHash ?? null,\n    datum: utxo.output.plutusData ?? null,\n    datumhash: utxo.output.dataHash ?? null,\n  };\n}"
        }
      ],
      "types": [
        {
          "name": "hUTxOs",
          "definition": "export type hUTxOs = {\n  [txRef: string]: hUTxO;\n};\n\nexport function hUTxOs(utxos: UTxO[]): hUTxOs {",
          "isPublic": true,
          "line": 5,
          "raw": "export type hUTxOs = {",
          "source": "mesh-hydra"
        },
        {
          "name": "hUTxO",
          "definition": "export type hUTxO = {\n  address: string;\n  value: hAssets;",
          "isPublic": true,
          "line": 15,
          "raw": "export type hUTxO = {",
          "source": "mesh-hydra"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { UTxO } from \"@meshsdk/common\";\nimport { hAssets } from \"./hAssets\";\nimport { hReferenceScript } from \"./hReferenceScript\";\n\nexport type hUTxOs = {\n  [txRef: string]: hUTxO;\n};\n\nexport function hUTxOs(utxos: UTxO[]): hUTxOs {\n  return Object.fromEntries(utxos.map(\n    (utxo) => [utxo.input.txHash + \"#\" + utxo.input.outputIndex, hUTxO(utxo)]\n  ));\n}\n\nexport type hUTxO = {\n  address: string;\n  value: hAssets;\n  referenceScript: hReferenceScript | null;\n  datum: string | null;\n  datumhash: string | null;\n  inlineDatum: object | null;\n  inlineDatumhash: string | null;\n};\n\nexport function hUTxO(utxo: UTxO): hUTxO {\n  return {\n    address: utxo.output.address,\n    value: hAssets(utxo.output.amount),\n    referenceScript: null,\n    inlineDatum: utxo.output.plutusData ? JSON.parse(utxo.output.plutusData) : null,\n    inlineDatumhash: utxo.output.dataHash ?? null,\n    datum: utxo.output.plutusData ?? null,\n    datumhash: utxo.output.dataHash ?? null,\n  };\n}\n\nhUTxO.toUTxO = (hUTxO: hUTxO, txId: string): UTxO => {\n  const [txHash, txIndex] = txId.split(\"#\");\n  if (!txHash || !txIndex) {\n    throw new Error(\"Invalid txId format\");\n  }\n  return {\n    input: {\n      outputIndex: Number(txIndex),\n      txHash: txHash,\n    },\n    output: {\n      address: hUTxO.address,\n      amount: hAssets.toAssets(hUTxO.value),\n      dataHash: hUTxO.datumhash ?? undefined,\n      plutusData: hUTxO.inlineDatum?.toString(),\n      scriptHash: hUTxO.referenceScript?.toString(),\n    },\n  };\n}\n",
      "dependencies": [
        "hUTxOs",
        "hUTxOs",
        "hUTxO",
        "hUTxO"
      ],
      "source": "mesh-hydra",
      "isReExportFile": false
    },
    {
      "key": "mesh-hydra:types.hydra-post-chain-tx.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
      "name": "types.hydra-post-chain-tx.ts",
      "imports": [
        {
          "module": "PostChainTx",
          "items": [],
          "line": 4,
          "raw": "export type PostChainTx =",
          "source": "mesh-hydra"
        },
        {
          "module": "InitTx",
          "items": [],
          "line": 13,
          "raw": "export type InitTx = {",
          "source": "mesh-hydra"
        },
        {
          "module": "AbortTx",
          "items": [],
          "line": 19,
          "raw": "export type AbortTx = {",
          "source": "mesh-hydra"
        },
        {
          "module": "CollectComTx",
          "items": [],
          "line": 25,
          "raw": "export type CollectComTx = {",
          "source": "mesh-hydra"
        },
        {
          "module": "InitialSnapshot",
          "items": [],
          "line": 32,
          "raw": "export type InitialSnapshot = {",
          "source": "mesh-hydra"
        },
        {
          "module": "ConfirmedSnapshot",
          "items": [],
          "line": 38,
          "raw": "export type ConfirmedSnapshot = {",
          "source": "mesh-hydra"
        },
        {
          "module": "DecrementTx",
          "items": [],
          "line": 45,
          "raw": "export type DecrementTx = {",
          "source": "mesh-hydra"
        },
        {
          "module": "CloseTx",
          "items": [],
          "line": 52,
          "raw": "export type CloseTx = {",
          "source": "mesh-hydra"
        },
        {
          "module": "ContestTx",
          "items": [],
          "line": 60,
          "raw": "export type ContestTx = {",
          "source": "mesh-hydra"
        },
        {
          "module": "FanoutTx",
          "items": [],
          "line": 68,
          "raw": "export type FanoutTx = {",
          "source": "mesh-hydra"
        }
      ],
      "functions": [],
      "types": [
        {
          "name": "PostChainTx",
          "definition": "export type PostChainTx =\n  | InitTx\n  | AbortTx\n  | CollectComTx\n  | DecrementTx\n  | CloseTx\n  | ContestTx\n  | FanoutTx;",
          "isPublic": true,
          "line": 4,
          "raw": "export type PostChainTx =",
          "source": "mesh-hydra"
        },
        {
          "name": "InitTx",
          "definition": "export type InitTx = {\n  tag: \"InitTx\";\n  participants: string[];",
          "isPublic": true,
          "line": 13,
          "raw": "export type InitTx = {",
          "source": "mesh-hydra"
        },
        {
          "name": "AbortTx",
          "definition": "export type AbortTx = {\n  tag: \"AbortTx\";\n  utxo: { [txRef: string]: hUTxO };",
          "isPublic": true,
          "line": 19,
          "raw": "export type AbortTx = {",
          "source": "mesh-hydra"
        },
        {
          "name": "CollectComTx",
          "definition": "export type CollectComTx = {\n  tag: \"CollectComTx\";\n  utxo: { [txRef: string]: hUTxO };",
          "isPublic": true,
          "line": 25,
          "raw": "export type CollectComTx = {",
          "source": "mesh-hydra"
        },
        {
          "name": "InitialSnapshot",
          "definition": "export type InitialSnapshot = {\n  headId: string;\n  initialUtxo: { [txRef: string]: hUTxO };",
          "isPublic": true,
          "line": 32,
          "raw": "export type InitialSnapshot = {",
          "source": "mesh-hydra"
        },
        {
          "name": "ConfirmedSnapshot",
          "definition": "export type ConfirmedSnapshot = {\n  snapshot: HydraSnapshot;\n  signatures: {\n    mutliSignature: string[];\n  };\n  tag: \"ConfirmedSnapshot\";\n};\nexport type DecrementTx = {\n  tag: \"DecrementTx\";\n  headId: string;\n  headParameters: HydraHeadParameters;\n  decerementingSnapshot: InitialSnapshot | ConfirmedSnapshot;\n};\n\nexport type CloseTx = {\n  tag: \"CloseTx\";\n  headId: string;\n  headParameters: HydraHeadParameters;\n  closingSnapshot: InitialSnapshot | ConfirmedSnapshot;\n  openVersion: number;\n};\n\nexport type ContestTx = {\n  tag: \"ContestTx\";\n  headId: string;\n  headParameters: HydraHeadParameters;\n  contestingSnapshot: InitialSnapshot | ConfirmedSnapshot;\n  openVersion: number;\n};\n\nexport type FanoutTx = {\n  tag: \"FanoutTx\";\n  utxo: { [txRef: string]: hUTxO };\n  utxoToDecommit: { [txRef: string]: hUTxO };\n  headSeed: string;\n  contestationDeadline: string;\n};",
          "isPublic": true,
          "line": 38,
          "raw": "export type ConfirmedSnapshot = {",
          "source": "mesh-hydra"
        },
        {
          "name": "DecrementTx",
          "definition": "export type DecrementTx = {\n  tag: \"DecrementTx\";\n  headId: string;",
          "isPublic": true,
          "line": 45,
          "raw": "export type DecrementTx = {",
          "source": "mesh-hydra"
        },
        {
          "name": "CloseTx",
          "definition": "export type CloseTx = {\n  tag: \"CloseTx\";\n  headId: string;",
          "isPublic": true,
          "line": 52,
          "raw": "export type CloseTx = {",
          "source": "mesh-hydra"
        },
        {
          "name": "ContestTx",
          "definition": "export type ContestTx = {\n  tag: \"ContestTx\";\n  headId: string;",
          "isPublic": true,
          "line": 60,
          "raw": "export type ContestTx = {",
          "source": "mesh-hydra"
        },
        {
          "name": "FanoutTx",
          "definition": "export type FanoutTx = {\n  tag: \"FanoutTx\";\n  utxo: { [txRef: string]: hUTxO };",
          "isPublic": true,
          "line": 68,
          "raw": "export type FanoutTx = {",
          "source": "mesh-hydra"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { hUTxO } from \"./hUTxOs\";\nimport { HydraHeadParameters, HydraSnapshot } from \"./hydra\";\n\nexport type PostChainTx =\n  | InitTx\n  | AbortTx\n  | CollectComTx\n  | DecrementTx\n  | CloseTx\n  | ContestTx\n  | FanoutTx;\n\nexport type InitTx = {\n  tag: \"InitTx\";\n  participants: string[];\n  headParameters: HydraHeadParameters;\n};\n\nexport type AbortTx = {\n  tag: \"AbortTx\";\n  utxo: { [txRef: string]: hUTxO };\n  headSeed: string;\n};\n\nexport type CollectComTx = {\n  tag: \"CollectComTx\";\n  utxo: { [txRef: string]: hUTxO };\n  headId: string;\n  headParameters: HydraHeadParameters;\n};\n\nexport type InitialSnapshot = {\n  headId: string;\n  initialUtxo: { [txRef: string]: hUTxO };\n  tag: \"InitialSnapshot\";\n};\n\nexport type ConfirmedSnapshot = {\n  snapshot: HydraSnapshot;\n  signatures: {\n    mutliSignature: string[];\n  };\n  tag: \"ConfirmedSnapshot\";\n};\nexport type DecrementTx = {\n  tag: \"DecrementTx\";\n  headId: string;\n  headParameters: HydraHeadParameters;\n  decerementingSnapshot: InitialSnapshot | ConfirmedSnapshot;\n};\n\nexport type CloseTx = {\n  tag: \"CloseTx\";\n  headId: string;\n  headParameters: HydraHeadParameters;\n  closingSnapshot: InitialSnapshot | ConfirmedSnapshot;\n  openVersion: number;\n};\n\nexport type ContestTx = {\n  tag: \"ContestTx\";\n  headId: string;\n  headParameters: HydraHeadParameters;\n  contestingSnapshot: InitialSnapshot | ConfirmedSnapshot;\n  openVersion: number;\n};\n\nexport type FanoutTx = {\n  tag: \"FanoutTx\";\n  utxo: { [txRef: string]: hUTxO };\n  utxoToDecommit: { [txRef: string]: hUTxO };\n  headSeed: string;\n  contestationDeadline: string;\n};\n",
      "dependencies": [
        "PostChainTx",
        "InitTx",
        "AbortTx",
        "CollectComTx",
        "InitialSnapshot",
        "ConfirmedSnapshot",
        "DecrementTx",
        "CloseTx",
        "ContestTx",
        "FanoutTx"
      ],
      "source": "mesh-hydra",
      "isReExportFile": false
    },
    {
      "key": "mesh-hydra:types.hydra.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra.ts",
      "name": "types.hydra.ts",
      "imports": [
        {
          "module": "HydraCommitTransaction",
          "items": [],
          "line": 3,
          "raw": "export type HydraCommitTransaction = {",
          "source": "mesh-hydra"
        },
        {
          "module": "HydraHeadParameters",
          "items": [],
          "line": 10,
          "raw": "export interface HydraHeadParameters {",
          "source": "mesh-hydra"
        },
        {
          "module": "HydraParty",
          "items": [],
          "line": 15,
          "raw": "export type HydraParty = {",
          "source": "mesh-hydra"
        },
        {
          "module": "HydraSnapshot",
          "items": [],
          "line": 19,
          "raw": "export type HydraSnapshot = {",
          "source": "mesh-hydra"
        }
      ],
      "functions": [],
      "types": [
        {
          "name": "HydraCommitTransaction",
          "definition": "export type HydraCommitTransaction = {\n  cborHex: string;\n  description: string;",
          "isPublic": true,
          "line": 3,
          "raw": "export type HydraCommitTransaction = {",
          "source": "mesh-hydra"
        },
        {
          "name": "HydraHeadParameters",
          "definition": "export interface HydraHeadParameters {\n  contestationPeriod: number;",
          "isPublic": true,
          "line": 10,
          "raw": "export interface HydraHeadParameters {",
          "source": "mesh-hydra"
        },
        {
          "name": "HydraParty",
          "definition": "export type HydraParty = {\n  vkey: string;\n};\n\nexport type HydraSnapshot = {\n  headId: string;",
          "isPublic": true,
          "line": 15,
          "raw": "export type HydraParty = {",
          "source": "mesh-hydra"
        },
        {
          "name": "HydraSnapshot",
          "definition": "export type HydraSnapshot = {\n  headId: string;\n  snapshotNumber: string;",
          "isPublic": true,
          "line": 19,
          "raw": "export type HydraSnapshot = {",
          "source": "mesh-hydra"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { hUTxOs } from \"./hUTxOs\";\n\nexport type HydraCommitTransaction = {\n  cborHex: string;\n  description: string;\n  txId: string;\n  type: string;\n};\n\nexport interface HydraHeadParameters {\n  contestationPeriod: number;\n  parties: HydraParty[];\n}\n\nexport type HydraParty = {\n  vkey: string;\n};\n\nexport type HydraSnapshot = {\n  headId: string;\n  snapshotNumber: string;\n  utxo: hUTxOs;\n  confirmedTransactions: string[];\n  utxoToDecommit: hUTxOs;\n  version: number;\n};\n",
      "dependencies": [
        "HydraCommitTransaction",
        "HydraHeadParameters",
        "HydraParty",
        "HydraSnapshot"
      ],
      "source": "mesh-hydra",
      "isReExportFile": false
    },
    {
      "key": "mesh-hydra:types.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/index.ts",
      "name": "types.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./events\";\nexport * from \"./hydra\";\nexport * from \"./hAssets\";\nexport * from \"./hReferenceScript\";\nexport * from \"./hStatus\";\nexport * from \"./hTransaction\";\nexport * from \"./hUTxOs\";",
      "dependencies": [],
      "source": "mesh-hydra",
      "isReExportFile": false
    },
    {
      "key": "mesh-hydra:utils.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/utils/index.ts",
      "name": "utils.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./parse-http-error\";\n",
      "dependencies": [],
      "source": "mesh-hydra",
      "isReExportFile": false
    },
    {
      "key": "mesh-hydra:utils.parse-http-error.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/utils/parse-http-error.ts",
      "name": "utils.parse-http-error.ts",
      "imports": [
        {
          "module": "parseHttpError",
          "items": [],
          "line": 3,
          "raw": "export const parseHttpError = (error: unknown): string => {",
          "source": "mesh-hydra"
        }
      ],
      "functions": [
        {
          "name": "parseHttpError",
          "signature": "export const parseHttpError = (error: unknown): string => {",
          "documentation": "",
          "parameters": [
            {
              "name": "error",
              "type": "unknown",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 3,
          "raw": "export const parseHttpError = (error: unknown): string => {\n  if (!axios.isAxiosError(error)) {\n    return JSON.stringify(error);\n  }\n\n  if (error.response) {\n    return JSON.stringify({\n      data: error.response.data,\n      headers: error.response.headers,\n      status: error.response.status,\n    });\n  }\n\n  if (error.request && !(error.request instanceof XMLHttpRequest)) {\n    return JSON.stringify(error.request);\n  }\n\n  return JSON.stringify({ code: error.code, message: error.message });\n};",
          "source": "mesh-hydra",
          "implementation": "export const parseHttpError = (error: unknown): string => {\n  if (!axios.isAxiosError(error)) {\n    return JSON.stringify(error);\n  }\n\n  if (error.response) {\n    return JSON.stringify({\n      data: error.response.data,\n      headers: error.response.headers,\n      status: error.response.status,\n    });\n  }\n\n  if (error.request && !(error.request instanceof XMLHttpRequest)) {\n    return JSON.stringify(error.request);\n  }\n\n  return JSON.stringify({ code: error.code, message: error.message });\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "parseHttpError",
          "type": "any",
          "value": "(error: unknown): string => {",
          "isPublic": true,
          "line": 3,
          "raw": "export const parseHttpError = (error: unknown): string => {",
          "source": "mesh-hydra"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import axios from \"axios\";\n\nexport const parseHttpError = (error: unknown): string => {\n  if (!axios.isAxiosError(error)) {\n    return JSON.stringify(error);\n  }\n\n  if (error.response) {\n    return JSON.stringify({\n      data: error.response.data,\n      headers: error.response.headers,\n      status: error.response.status,\n    });\n  }\n\n  if (error.request && !(error.request instanceof XMLHttpRequest)) {\n    return JSON.stringify(error.request);\n  }\n\n  return JSON.stringify({ code: error.code, message: error.message });\n};\n",
      "dependencies": [
        "parseHttpError"
      ],
      "source": "mesh-hydra",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.certificate.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/fromObj/certificate.ts",
      "name": "core.adaptor.fromObj.certificate.ts",
      "imports": [
        {
          "module": "certificateFromObj",
          "items": [],
          "line": 12,
          "raw": "export const certificateFromObj = (obj: any): Certificate => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "baseCertFromObj",
          "items": [],
          "line": 55,
          "raw": "export const baseCertFromObj = (obj: any): CertificateType => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "poolParamsFromObj",
          "items": [],
          "line": 157,
          "raw": "export const poolParamsFromObj = (obj: any): PoolParams => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "poolMetadataFromObj",
          "items": [],
          "line": 171,
          "raw": "export const poolMetadataFromObj = (obj: any): PoolMetadata => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "relayFromObj",
          "items": [],
          "line": 178,
          "raw": "export const relayFromObj = (obj: any): Relay => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "certificateFromObj",
          "signature": "export const certificateFromObj = (obj: any): Certificate => {",
          "documentation": "",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "Certificate",
          "isPublic": true,
          "line": 12,
          "raw": "export const certificateFromObj = (obj: any): Certificate => {\n  if (\"basicCertificate\" in obj) {\n    return {\n      type: \"BasicCertificate\",\n      certType: baseCertFromObj(obj.basicCertificate),\n    };\n  } else if (\"scriptCertificate\" in obj) {\n    const certificate: Certificate = {\n      type: \"ScriptCertificate\",\n      certType: baseCertFromObj(obj.scriptCertificate.cert),\n    };\n\n    if (obj.scriptCertificate.redeemer) {\n      certificate.redeemer = redeemerFromObj(obj.scriptCertificate.redeemer);\n    }\n\n    if (obj.scriptCertificate.scriptSource) {\n      certificate.scriptSource = scriptSourceFromObj(\n        obj.scriptCertificate.scriptSource,\n      );\n    }\n\n    return certificate;\n  } else if (\"simpleScriptCertificate\" in obj) {\n    const certificate: Certificate = {\n      type: \"SimpleScriptCertificate\",\n      certType: baseCertFromObj(obj.simpleScriptCertificate.cert),\n    };\n\n    if (obj.simpleScriptCertificate.simpleScriptSource) {\n      certificate.simpleScriptSource = simpleScriptSourceFromObj(\n        obj.simpleScriptCertificate.simpleScriptSource,\n      );\n    }\n\n    return certificate;\n  }\n\n  throw new Error(\n    `certificateFromObj: Unknown certificate type in object: ${JSON.stringify(obj)}`,\n  );\n};",
          "source": "mesh-core-csl",
          "implementation": "export const certificateFromObj = (obj: any): Certificate => {\n  if (\"basicCertificate\" in obj) {\n    return {\n      type: \"BasicCertificate\",\n      certType: baseCertFromObj(obj.basicCertificate),\n    };\n  } else if (\"scriptCertificate\" in obj) {\n    const certificate: Certificate = {\n      type: \"ScriptCertificate\",\n      certType: baseCertFromObj(obj.scriptCertificate.cert),\n    };\n\n    if (obj.scriptCertificate.redeemer) {\n      certificate.redeemer = redeemerFromObj(obj.scriptCertificate.redeemer);\n    }\n\n    if (obj.scriptCertificate.scriptSource) {\n      certificate.scriptSource = scriptSourceFromObj(\n        obj.scriptCertificate.scriptSource,\n      );\n    }\n\n    return certificate;\n  } else if (\"simpleScriptCertificate\" in obj) {\n    const certificate: Certificate = {\n      type: \"SimpleScriptCertificate\",\n      certType: baseCertFromObj(obj.simpleScriptCertificate.cert),\n    };\n\n    if (obj.simpleScriptCertificate.simpleScriptSource) {\n      certificate.simpleScriptSource = simpleScriptSourceFromObj(\n        obj.simpleScriptCertificate.simpleScriptSource,\n      );\n    }\n\n    return certificate;\n  }\n\n  throw new Error(\n    `certificateFromObj: Unknown certificate type in object: ${JSON.stringify(obj)}`,\n  );\n};"
        },
        {
          "name": "baseCertFromObj",
          "signature": "export const baseCertFromObj = (obj: any): CertificateType => {",
          "documentation": "",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "CertificateType",
          "isPublic": true,
          "line": 55,
          "raw": "export const baseCertFromObj = (obj: any): CertificateType => {\n  if (\"registerPool\" in obj) {\n    return {\n      type: \"RegisterPool\",\n      poolParams: poolParamsFromObj(obj.registerPool.poolParams),\n    };\n  } else if (\"registerStake\" in obj) {\n    return {\n      type: \"RegisterStake\",\n      stakeKeyAddress: obj.registerStake.stakeKeyAddress,\n    };\n  } else if (\"delegateStake\" in obj) {\n    return {\n      type: \"DelegateStake\",\n      stakeKeyAddress: obj.delegateStake.stakeKeyAddress,\n      poolId: obj.delegateStake.poolId,\n    };\n  } else if (\"deregisterStake\" in obj) {\n    return {\n      type: \"DeregisterStake\",\n      stakeKeyAddress: obj.deregisterStake.stakeKeyAddress,\n    };\n  } else if (\"retirePool\" in obj) {\n    return {\n      type: \"RetirePool\",\n      poolId: obj.retirePool.poolId,\n      epoch: obj.retirePool.epoch,\n    };\n  } else if (\"voteDelegation\" in obj) {\n    return {\n      type: \"VoteDelegation\",\n      stakeKeyAddress: obj.voteDelegation.stakeKeyAddress,\n      drep: obj.voteDelegation.drep,\n    };\n  } else if (\"stakeAndVoteDelegation\" in obj) {\n    return {\n      type: \"StakeAndVoteDelegation\",\n      stakeKeyAddress: obj.stakeAndVoteDelegation.stakeKeyAddress,\n      poolKeyHash: obj.stakeAndVoteDelegation.poolKeyHash,\n      drep: obj.stakeAndVoteDelegation.drep,\n    };\n  } else if (\"stakeRegistrationAndDelegation\" in obj) {\n    return {\n      type: \"StakeRegistrationAndDelegation\",\n      stakeKeyAddress: obj.stakeRegistrationAndDelegation.stakeKeyAddress,\n      poolKeyHash: obj.stakeRegistrationAndDelegation.poolKeyHash,\n      coin: obj.stakeRegistrationAndDelegation.coin,\n    };\n  } else if (\"voteRegistrationAndDelegation\" in obj) {\n    return {\n      type: \"VoteRegistrationAndDelegation\",\n      stakeKeyAddress: obj.voteRegistrationAndDelegation.stakeKeyAddress,\n      drep: obj.voteRegistrationAndDelegation.drep,\n      coin: obj.voteRegistrationAndDelegation.coin,\n    };\n  } else if (\"stakeVoteRegistrationAndDelegation\" in obj) {\n    return {\n      type: \"StakeVoteRegistrationAndDelegation\",\n      stakeKeyAddress: obj.stakeVoteRegistrationAndDelegation.stakeKeyAddress,\n      poolKeyHash: obj.stakeVoteRegistrationAndDelegation.poolKeyHash,\n      drep: obj.stakeVoteRegistrationAndDelegation.drep,\n      coin: obj.stakeVoteRegistrationAndDelegation.coin,\n    };\n  } else if (\"committeeHotAuth\" in obj) {\n    return {\n      type: \"CommitteeHotAuth\",\n      committeeColdKeyAddress: obj.committeeHotAuth.committeeColdKeyAddress,\n      committeeHotKeyAddress: obj.committeeHotAuth.committeeHotKeyAddress,\n    };\n  } else if (\"committeeColdResign\" in obj) {\n    return {\n      type: \"CommitteeColdResign\",\n      committeeColdKeyAddress: obj.committeeColdResign.committeeColdKeyAddress,\n      anchor: obj.committeeColdResign.anchor || undefined,\n    };\n  } else if (\"dRepRegistration\" in obj) {\n    return {\n      type: \"DRepRegistration\",\n      drepId: obj.dRepRegistration.drepId,\n      coin: obj.dRepRegistration.coin,\n      anchor: obj.dRepRegistration.anchor || undefined,\n    };\n  } else if (\"dRepDeregistration\" in obj) {\n    return {\n      type: \"DRepDeregistration\",\n      drepId: obj.dRepDeregistration.drepId,\n      coin: obj.dRepDeregistration.coin,\n    };\n  } else if (\"dRepUpdate\" in obj) {\n    return {\n      type: \"DRepUpdate\",\n      drepId: obj.dRepUpdate.drepId,\n      anchor: obj.dRepUpdate.anchor,\n    };\n  }\n\n  throw new Error(\n    `baseCertFromObj: Unknown certificate type in object: ${JSON.stringify(obj)}`,\n  );\n};",
          "source": "mesh-core-csl",
          "implementation": "export const baseCertFromObj = (obj: any): CertificateType => {\n  if (\"registerPool\" in obj) {\n    return {\n      type: \"RegisterPool\",\n      poolParams: poolParamsFromObj(obj.registerPool.poolParams),\n    };\n  } else if (\"registerStake\" in obj) {\n    return {\n      type: \"RegisterStake\",\n      stakeKeyAddress: obj.registerStake.stakeKeyAddress,\n    };\n  } else if (\"delegateStake\" in obj) {\n    return {\n      type: \"DelegateStake\",\n      stakeKeyAddress: obj.delegateStake.stakeKeyAddress,\n      poolId: obj.delegateStake.poolId,\n    };\n  } else if (\"deregisterStake\" in obj) {\n    return {\n      type: \"DeregisterStake\",\n      stakeKeyAddress: obj.deregisterStake.stakeKeyAddress,\n    };\n  } else if (\"retirePool\" in obj) {\n    return {\n      type: \"RetirePool\",\n      poolId: obj.retirePool.poolId,\n      epoch: obj.retirePool.epoch,\n    };\n  } else if (\"voteDelegation\" in obj) {\n    return {\n      type: \"VoteDelegation\",\n      stakeKeyAddress: obj.voteDelegation.stakeKeyAddress,\n      drep: obj.voteDelegation.drep,\n    };\n  } else if (\"stakeAndVoteDelegation\" in obj) {\n    return {\n      type: \"StakeAndVoteDelegation\",\n      stakeKeyAddress: obj.stakeAndVoteDelegation.stakeKeyAddress,\n      poolKeyHash: obj.stakeAndVoteDelegation.poolKeyHash,\n      drep: obj.stakeAndVoteDelegation.drep,\n    };\n  } else if (\"stakeRegistrationAndDelegation\" in obj) {\n    return {\n      type: \"StakeRegistrationAndDelegation\",\n      stakeKeyAddress: obj.stakeRegistrationAndDelegation.stakeKeyAddress,\n      poolKeyHash: obj.stakeRegistrationAndDelegation.poolKeyHash,\n      coin: obj.stakeRegistrationAndDelegation.coin,\n    };\n  } else if (\"voteRegistrationAndDelegation\" in obj) {\n    return {\n      type: \"VoteRegistrationAndDelegation\",\n      stakeKeyAddress: obj.voteRegistrationAndDelegation.stakeKeyAddress,\n      drep: obj.voteRegistrationAndDelegation.drep,\n      coin: obj.voteRegistrationAndDelegation.coin,\n    };\n  } else if (\"stakeVoteRegistrationAndDelegation\" in obj) {\n    return {\n      type: \"StakeVoteRegistrationAndDelegation\",\n      stakeKeyAddress: obj.stakeVoteRegistrationAndDelegation.stakeKeyAddress,\n      poolKeyHash: obj.stakeVoteRegistrationAndDelegation.poolKeyHash,\n      drep: obj.stakeVoteRegistrationAndDelegation.drep,\n      coin: obj.stakeVoteRegistrationAndDelegation.coin,\n    };\n  } else if (\"committeeHotAuth\" in obj) {\n    return {\n      type: \"CommitteeHotAuth\",\n      committeeColdKeyAddress: obj.committeeHotAuth.committeeColdKeyAddress,\n      committeeHotKeyAddress: obj.committeeHotAuth.committeeHotKeyAddress,\n    };\n  } else if (\"committeeColdResign\" in obj) {\n    return {\n      type: \"CommitteeColdResign\",\n      committeeColdKeyAddress: obj.committeeColdResign.committeeColdKeyAddress,\n      anchor: obj.committeeColdResign.anchor || undefined,\n    };\n  } else if (\"dRepRegistration\" in obj) {\n    return {\n      type: \"DRepRegistration\",\n      drepId: obj.dRepRegistration.drepId,\n      coin: obj.dRepRegistration.coin,\n      anchor: obj.dRepRegistration.anchor || undefined,\n    };\n  } else if (\"dRepDeregistration\" in obj) {\n    return {\n      type: \"DRepDeregistration\",\n      drepId: obj.dRepDeregistration.drepId,\n      coin: obj.dRepDeregistration.coin,\n    };\n  } else if (\"dRepUpdate\" in obj) {\n    return {\n      type: \"DRepUpdate\",\n      drepId: obj.dRepUpdate.drepId,\n      anchor: obj.dRepUpdate.anchor,\n    };\n  }\n\n  throw new Error(\n    `baseCertFromObj: Unknown certificate type in object: ${JSON.stringify(obj)}`,\n  );\n};"
        },
        {
          "name": "poolParamsFromObj",
          "signature": "export const poolParamsFromObj = (obj: any): PoolParams => {",
          "documentation": "",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "PoolParams",
          "isPublic": true,
          "line": 157,
          "raw": "export const poolParamsFromObj = (obj: any): PoolParams => {\n  return {\n    vrfKeyHash: obj.vrfKeyHash,\n    operator: obj.operator,\n    pledge: obj.pledge,\n    cost: obj.cost,\n    margin: obj.margin,\n    relays: obj.relays.map((relay: any) => relayFromObj(relay)),\n    owners: obj.owners,\n    rewardAddress: obj.rewardAddress,\n    metadata: obj.metadata ? poolMetadataFromObj(obj.metadata) : undefined,\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const poolParamsFromObj = (obj: any): PoolParams => {\n  return {\n    vrfKeyHash: obj.vrfKeyHash,\n    operator: obj.operator,\n    pledge: obj.pledge,\n    cost: obj.cost,\n    margin: obj.margin,\n    relays: obj.relays.map((relay: any) => relayFromObj(relay)),\n    owners: obj.owners,\n    rewardAddress: obj.rewardAddress,\n    metadata: obj.metadata ? poolMetadataFromObj(obj.metadata) : undefined,\n  };\n};"
        },
        {
          "name": "poolMetadataFromObj",
          "signature": "export const poolMetadataFromObj = (obj: any): PoolMetadata => {",
          "documentation": "",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "PoolMetadata",
          "isPublic": true,
          "line": 171,
          "raw": "export const poolMetadataFromObj = (obj: any): PoolMetadata => {\n  return {\n    URL: obj.url,\n    hash: obj.metadata,\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const poolMetadataFromObj = (obj: any): PoolMetadata => {\n  return {\n    URL: obj.url,\n    hash: obj.metadata,\n  };\n};"
        },
        {
          "name": "relayFromObj",
          "signature": "export const relayFromObj = (obj: any): Relay => {",
          "documentation": "",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "Relay",
          "isPublic": true,
          "line": 178,
          "raw": "export const relayFromObj = (obj: any): Relay => {\n  if (\"singleHostAddr\" in obj) {\n    return {\n      type: \"SingleHostAddr\",\n      IPV4: obj.singleHostAddr.ipv4,\n      IPV6: obj.singleHostAddr.ipv6,\n      port: obj.singleHostAddr.port,\n    };\n  } else if (\"singleHostName\" in obj) {\n    return {\n      type: \"SingleHostName\",\n      domainName: obj.singleHostName.hostname,\n      port: obj.singleHostName.port,\n    };\n  } else if (\"multiHostName\" in obj) {\n    return {\n      type: \"MultiHostName\",\n      domainName: obj.multiHostName.dnsName,\n    };\n  }\n\n  throw new Error(\n    `relayFromObj: Unknown relay type in object: ${JSON.stringify(obj)}`,\n  );\n};",
          "source": "mesh-core-csl",
          "implementation": "export const relayFromObj = (obj: any): Relay => {\n  if (\"singleHostAddr\" in obj) {\n    return {\n      type: \"SingleHostAddr\",\n      IPV4: obj.singleHostAddr.ipv4,\n      IPV6: obj.singleHostAddr.ipv6,\n      port: obj.singleHostAddr.port,\n    };\n  } else if (\"singleHostName\" in obj) {\n    return {\n      type: \"SingleHostName\",\n      domainName: obj.singleHostName.hostname,\n      port: obj.singleHostName.port,\n    };\n  } else if (\"multiHostName\" in obj) {\n    return {\n      type: \"MultiHostName\",\n      domainName: obj.multiHostName.dnsName,\n    };\n  }\n\n  throw new Error(\n    `relayFromObj: Unknown relay type in object: ${JSON.stringify(obj)}`,\n  );\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "certificateFromObj",
          "type": "any",
          "value": "(obj: any): Certificate => {",
          "isPublic": true,
          "line": 12,
          "raw": "export const certificateFromObj = (obj: any): Certificate => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "certificate",
          "type": "Certificate",
          "value": "{",
          "isPublic": true,
          "line": 19,
          "raw": "const certificate: Certificate = {",
          "source": "mesh-core-csl"
        },
        {
          "name": "certificate",
          "type": "Certificate",
          "value": "{",
          "isPublic": true,
          "line": 36,
          "raw": "const certificate: Certificate = {",
          "source": "mesh-core-csl"
        },
        {
          "name": "baseCertFromObj",
          "type": "any",
          "value": "(obj: any): CertificateType => {",
          "isPublic": true,
          "line": 55,
          "raw": "export const baseCertFromObj = (obj: any): CertificateType => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "poolParamsFromObj",
          "type": "any",
          "value": "(obj: any): PoolParams => {",
          "isPublic": true,
          "line": 157,
          "raw": "export const poolParamsFromObj = (obj: any): PoolParams => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "poolMetadataFromObj",
          "type": "any",
          "value": "(obj: any): PoolMetadata => {",
          "isPublic": true,
          "line": 171,
          "raw": "export const poolMetadataFromObj = (obj: any): PoolMetadata => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "relayFromObj",
          "type": "any",
          "value": "(obj: any): Relay => {",
          "isPublic": true,
          "line": 178,
          "raw": "export const relayFromObj = (obj: any): Relay => {",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  Certificate,\n  CertificateType,\n  PoolMetadata,\n  PoolParams,\n  Relay,\n} from \"@meshsdk/common\";\n\nimport { redeemerFromObj } from \"./data\";\nimport { scriptSourceFromObj, simpleScriptSourceFromObj } from \"./script\";\n\nexport const certificateFromObj = (obj: any): Certificate => {\n  if (\"basicCertificate\" in obj) {\n    return {\n      type: \"BasicCertificate\",\n      certType: baseCertFromObj(obj.basicCertificate),\n    };\n  } else if (\"scriptCertificate\" in obj) {\n    const certificate: Certificate = {\n      type: \"ScriptCertificate\",\n      certType: baseCertFromObj(obj.scriptCertificate.cert),\n    };\n\n    if (obj.scriptCertificate.redeemer) {\n      certificate.redeemer = redeemerFromObj(obj.scriptCertificate.redeemer);\n    }\n\n    if (obj.scriptCertificate.scriptSource) {\n      certificate.scriptSource = scriptSourceFromObj(\n        obj.scriptCertificate.scriptSource,\n      );\n    }\n\n    return certificate;\n  } else if (\"simpleScriptCertificate\" in obj) {\n    const certificate: Certificate = {\n      type: \"SimpleScriptCertificate\",\n      certType: baseCertFromObj(obj.simpleScriptCertificate.cert),\n    };\n\n    if (obj.simpleScriptCertificate.simpleScriptSource) {\n      certificate.simpleScriptSource = simpleScriptSourceFromObj(\n        obj.simpleScriptCertificate.simpleScriptSource,\n      );\n    }\n\n    return certificate;\n  }\n\n  throw new Error(\n    `certificateFromObj: Unknown certificate type in object: ${JSON.stringify(obj)}`,\n  );\n};\n\nexport const baseCertFromObj = (obj: any): CertificateType => {\n  if (\"registerPool\" in obj) {\n    return {\n      type: \"RegisterPool\",\n      poolParams: poolParamsFromObj(obj.registerPool.poolParams),\n    };\n  } else if (\"registerStake\" in obj) {\n    return {\n      type: \"RegisterStake\",\n      stakeKeyAddress: obj.registerStake.stakeKeyAddress,\n    };\n  } else if (\"delegateStake\" in obj) {\n    return {\n      type: \"DelegateStake\",\n      stakeKeyAddress: obj.delegateStake.stakeKeyAddress,\n      poolId: obj.delegateStake.poolId,\n    };\n  } else if (\"deregisterStake\" in obj) {\n    return {\n      type: \"DeregisterStake\",\n      stakeKeyAddress: obj.deregisterStake.stakeKeyAddress,\n    };\n  } else if (\"retirePool\" in obj) {\n    return {\n      type: \"RetirePool\",\n      poolId: obj.retirePool.poolId,\n      epoch: obj.retirePool.epoch,\n    };\n  } else if (\"voteDelegation\" in obj) {\n    return {\n      type: \"VoteDelegation\",\n      stakeKeyAddress: obj.voteDelegation.stakeKeyAddress,\n      drep: obj.voteDelegation.drep,\n    };\n  } else if (\"stakeAndVoteDelegation\" in obj) {\n    return {\n      type: \"StakeAndVoteDelegation\",\n      stakeKeyAddress: obj.stakeAndVoteDelegation.stakeKeyAddress,\n      poolKeyHash: obj.stakeAndVoteDelegation.poolKeyHash,\n      drep: obj.stakeAndVoteDelegation.drep,\n    };\n  } else if (\"stakeRegistrationAndDelegation\" in obj) {\n    return {\n      type: \"StakeRegistrationAndDelegation\",\n      stakeKeyAddress: obj.stakeRegistrationAndDelegation.stakeKeyAddress,\n      poolKeyHash: obj.stakeRegistrationAndDelegation.poolKeyHash,\n      coin: obj.stakeRegistrationAndDelegation.coin,\n    };\n  } else if (\"voteRegistrationAndDelegation\" in obj) {\n    return {\n      type: \"VoteRegistrationAndDelegation\",\n      stakeKeyAddress: obj.voteRegistrationAndDelegation.stakeKeyAddress,\n      drep: obj.voteRegistrationAndDelegation.drep,\n      coin: obj.voteRegistrationAndDelegation.coin,\n    };\n  } else if (\"stakeVoteRegistrationAndDelegation\" in obj) {\n    return {\n      type: \"StakeVoteRegistrationAndDelegation\",\n      stakeKeyAddress: obj.stakeVoteRegistrationAndDelegation.stakeKeyAddress,\n      poolKeyHash: obj.stakeVoteRegistrationAndDelegation.poolKeyHash,\n      drep: obj.stakeVoteRegistrationAndDelegation.drep,\n      coin: obj.stakeVoteRegistrationAndDelegation.coin,\n    };\n  } else if (\"committeeHotAuth\" in obj) {\n    return {\n      type: \"CommitteeHotAuth\",\n      committeeColdKeyAddress: obj.committeeHotAuth.committeeColdKeyAddress,\n      committeeHotKeyAddress: obj.committeeHotAuth.committeeHotKeyAddress,\n    };\n  } else if (\"committeeColdResign\" in obj) {\n    return {\n      type: \"CommitteeColdResign\",\n      committeeColdKeyAddress: obj.committeeColdResign.committeeColdKeyAddress,\n      anchor: obj.committeeColdResign.anchor || undefined,\n    };\n  } else if (\"dRepRegistration\" in obj) {\n    return {\n      type: \"DRepRegistration\",\n      drepId: obj.dRepRegistration.drepId,\n      coin: obj.dRepRegistration.coin,\n      anchor: obj.dRepRegistration.anchor || undefined,\n    };\n  } else if (\"dRepDeregistration\" in obj) {\n    return {\n      type: \"DRepDeregistration\",\n      drepId: obj.dRepDeregistration.drepId,\n      coin: obj.dRepDeregistration.coin,\n    };\n  } else if (\"dRepUpdate\" in obj) {\n    return {\n      type: \"DRepUpdate\",\n      drepId: obj.dRepUpdate.drepId,\n      anchor: obj.dRepUpdate.anchor,\n    };\n  }\n\n  throw new Error(\n    `baseCertFromObj: Unknown certificate type in object: ${JSON.stringify(obj)}`,\n  );\n};\n\n// You'll also need a helper function to convert pool parameters\nexport const poolParamsFromObj = (obj: any): PoolParams => {\n  return {\n    vrfKeyHash: obj.vrfKeyHash,\n    operator: obj.operator,\n    pledge: obj.pledge,\n    cost: obj.cost,\n    margin: obj.margin,\n    relays: obj.relays.map((relay: any) => relayFromObj(relay)),\n    owners: obj.owners,\n    rewardAddress: obj.rewardAddress,\n    metadata: obj.metadata ? poolMetadataFromObj(obj.metadata) : undefined,\n  };\n};\n\nexport const poolMetadataFromObj = (obj: any): PoolMetadata => {\n  return {\n    URL: obj.url,\n    hash: obj.metadata,\n  };\n};\n\nexport const relayFromObj = (obj: any): Relay => {\n  if (\"singleHostAddr\" in obj) {\n    return {\n      type: \"SingleHostAddr\",\n      IPV4: obj.singleHostAddr.ipv4,\n      IPV6: obj.singleHostAddr.ipv6,\n      port: obj.singleHostAddr.port,\n    };\n  } else if (\"singleHostName\" in obj) {\n    return {\n      type: \"SingleHostName\",\n      domainName: obj.singleHostName.hostname,\n      port: obj.singleHostName.port,\n    };\n  } else if (\"multiHostName\" in obj) {\n    return {\n      type: \"MultiHostName\",\n      domainName: obj.multiHostName.dnsName,\n    };\n  }\n\n  throw new Error(\n    `relayFromObj: Unknown relay type in object: ${JSON.stringify(obj)}`,\n  );\n};\n",
      "dependencies": [
        "certificateFromObj",
        "baseCertFromObj",
        "poolParamsFromObj",
        "poolMetadataFromObj",
        "relayFromObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.data.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/fromObj/data.ts",
      "name": "core.adaptor.fromObj.data.ts",
      "imports": [
        {
          "module": "cborToBuilderData",
          "items": [],
          "line": 10,
          "raw": "export const cborToBuilderData = (cborHex: string): BuilderData => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "redeemerFromObj",
          "items": [],
          "line": 22,
          "raw": "export const redeemerFromObj = (obj: any): Redeemer => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "dataFromObj",
          "items": [],
          "line": 34,
          "raw": "export const dataFromObj = (obj: any): any => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "cborToBuilderData",
          "signature": "export const cborToBuilderData = (cborHex: string): BuilderData => {",
          "documentation": "/**\n * Convert CBOR hex string back to BuilderData\n * @param cborHex The CBOR hex string to convert\n * @returns BuilderData object\n */",
          "parameters": [
            {
              "name": "cborHex",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "BuilderData",
          "isPublic": true,
          "line": 10,
          "raw": "/**\n * Convert CBOR hex string back to BuilderData\n * @param cborHex The CBOR hex string to convert\n * @returns BuilderData object\n */\nexport const cborToBuilderData = (cborHex: string): BuilderData => {\n  return {\n    type: \"CBOR\",\n    content: cborHex,\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const cborToBuilderData = (cborHex: string): BuilderData => {\n  return {\n    type: \"CBOR\",\n    content: cborHex,\n  };\n};"
        },
        {
          "name": "redeemerFromObj",
          "signature": "export const redeemerFromObj = (obj: any): Redeemer => {",
          "documentation": "/**\n * Convert an object representation back to a Redeemer\n * @param obj The object representation of a Redeemer\n * @returns The Redeemer instance\n */",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "Redeemer",
          "isPublic": true,
          "line": 22,
          "raw": "/**\n * Convert an object representation back to a Redeemer\n * @param obj The object representation of a Redeemer\n * @returns The Redeemer instance\n */\nexport const redeemerFromObj = (obj: any): Redeemer => {\n  return {\n    data: cborToBuilderData(obj.data),\n    exUnits: obj.exUnits,\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const redeemerFromObj = (obj: any): Redeemer => {\n  return {\n    data: cborToBuilderData(obj.data),\n    exUnits: obj.exUnits,\n  };\n};"
        },
        {
          "name": "dataFromObj",
          "signature": "export const dataFromObj = (obj: any): any => {",
          "documentation": "/**\n * Convert an object representation back to Data\n * @param obj The object representation of Data\n * @returns The Data instance\n */",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 34,
          "raw": "/**\n * Convert an object representation back to Data\n * @param obj The object representation of Data\n * @returns The Data instance\n */\nexport const dataFromObj = (obj: any): any => {\n  if (obj === null) {\n    return null;\n  }\n\n  if (typeof obj === \"object\") {\n    if (Array.isArray(obj)) {\n      return obj.map((item) => dataFromObj(item));\n    } else if (\"map\" in obj) {\n      return Object.fromEntries(\n        obj.map.map((entry: any) => [\n          dataFromObj(entry.k),\n          dataFromObj(entry.v),\n        ]),\n      );\n    } else if (\"list\" in obj) {\n      return obj.list.map((item: any) => dataFromObj(item));\n    } else if (\"int\" in obj) {\n      return BigInt(obj.int);\n    } else if (\"bytes\" in obj) {\n      return obj.bytes;\n    } else if (\"constructor\" in obj) {\n      return {\n        constructor: obj.constructor,\n        fields: obj.fields.map((field: any) => dataFromObj(field)),\n      };\n    }\n  }\n\n  return obj;\n};",
          "source": "mesh-core-csl",
          "implementation": "export const dataFromObj = (obj: any): any => {\n  if (obj === null) {\n    return null;\n  }\n\n  if (typeof obj === \"object\") {\n    if (Array.isArray(obj)) {\n      return obj.map((item) => dataFromObj(item));\n    } else if (\"map\" in obj) {\n      return Object.fromEntries(\n        obj.map.map((entry: any) => [\n          dataFromObj(entry.k),\n          dataFromObj(entry.v),\n        ]),\n      );\n    } else if (\"list\" in obj) {\n      return obj.list.map((item: any) => dataFromObj(item));\n    } else if (\"int\" in obj) {\n      return BigInt(obj.int);\n    } else if (\"bytes\" in obj) {\n      return obj.bytes;\n    } else if (\"constructor\" in obj) {\n      return {\n        constructor: obj.constructor,\n        fields: obj.fields.map((field: any) => dataFromObj(field)),\n      };\n    }\n  }\n\n  return obj;\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "cborToBuilderData",
          "type": "any",
          "value": "(cborHex: string): BuilderData => {",
          "isPublic": true,
          "line": 10,
          "raw": "export const cborToBuilderData = (cborHex: string): BuilderData => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "redeemerFromObj",
          "type": "any",
          "value": "(obj: any): Redeemer => {",
          "isPublic": true,
          "line": 22,
          "raw": "export const redeemerFromObj = (obj: any): Redeemer => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "dataFromObj",
          "type": "any",
          "value": "(obj: any): any => {",
          "isPublic": true,
          "line": 34,
          "raw": "export const dataFromObj = (obj: any): any => {",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { BuilderData, Redeemer } from \"@meshsdk/common\";\n\nimport { csl } from \"../../../deser\";\n\n/**\n * Convert CBOR hex string back to BuilderData\n * @param cborHex The CBOR hex string to convert\n * @returns BuilderData object\n */\nexport const cborToBuilderData = (cborHex: string): BuilderData => {\n  return {\n    type: \"CBOR\",\n    content: cborHex,\n  };\n};\n\n/**\n * Convert an object representation back to a Redeemer\n * @param obj The object representation of a Redeemer\n * @returns The Redeemer instance\n */\nexport const redeemerFromObj = (obj: any): Redeemer => {\n  return {\n    data: cborToBuilderData(obj.data),\n    exUnits: obj.exUnits,\n  };\n};\n\n/**\n * Convert an object representation back to Data\n * @param obj The object representation of Data\n * @returns The Data instance\n */\nexport const dataFromObj = (obj: any): any => {\n  if (obj === null) {\n    return null;\n  }\n\n  if (typeof obj === \"object\") {\n    if (Array.isArray(obj)) {\n      return obj.map((item) => dataFromObj(item));\n    } else if (\"map\" in obj) {\n      return Object.fromEntries(\n        obj.map.map((entry: any) => [\n          dataFromObj(entry.k),\n          dataFromObj(entry.v),\n        ]),\n      );\n    } else if (\"list\" in obj) {\n      return obj.list.map((item: any) => dataFromObj(item));\n    } else if (\"int\" in obj) {\n      return BigInt(obj.int);\n    } else if (\"bytes\" in obj) {\n      return obj.bytes;\n    } else if (\"constructor\" in obj) {\n      return {\n        constructor: obj.constructor,\n        fields: obj.fields.map((field: any) => dataFromObj(field)),\n      };\n    }\n  }\n\n  return obj;\n};\n",
      "dependencies": [
        "cborToBuilderData",
        "redeemerFromObj",
        "dataFromObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/fromObj/index.ts",
      "name": "core.adaptor.fromObj.index.ts",
      "imports": [
        {
          "module": "txBuilderBodyFromObj",
          "items": [],
          "line": 23,
          "raw": "export const txBuilderBodyFromObj = (objJson: any): MeshTxBuilderBody => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "txBuilderBodyFromObj",
          "signature": "export const txBuilderBodyFromObj = (objJson: any): MeshTxBuilderBody => {",
          "documentation": "/**\n * Convert an object representation back to MeshTxBuilderBody\n * @param obj The object representation of the transaction body\n * @returns The MeshTxBuilderBody instance\n */",
          "parameters": [
            {
              "name": "objJson",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "MeshTxBuilderBody",
          "isPublic": true,
          "line": 23,
          "raw": "/**\n * Convert an object representation back to MeshTxBuilderBody\n * @param obj The object representation of the transaction body\n * @returns The MeshTxBuilderBody instance\n */\nexport const txBuilderBodyFromObj = (objJson: any): MeshTxBuilderBody => {\n  const txBuilderBody: MeshTxBuilderBody = emptyTxBuilderBody();\n  const obj = JSON.parse(objJson);\n\n  // Convert inputs\n  if (obj.inputs && Array.isArray(obj.inputs)) {\n    txBuilderBody.inputs = obj.inputs.map(txInFromObj);\n  }\n\n  // Convert outputs\n  if (obj.outputs && Array.isArray(obj.outputs)) {\n    txBuilderBody.outputs = obj.outputs.map(outputFromObj);\n  }\n\n  // Convert fee\n  if (obj.fee) {\n    txBuilderBody.fee = obj.fee.toString();\n  }\n\n  // Convert mint tokens\n  if (obj.mints && Array.isArray(obj.mints)) {\n    const mintItems: MintItem[] = obj.mints.map(mintItemFromObj);\n\n    const visitedPolicyId = new Set<string>();\n    const mintParams: Record<string, MintParam> = {};\n\n    mintItems.forEach((mintItem) => {\n      const mintValueItem = {\n        assetName: mintItem.assetName,\n        amount: mintItem.amount,\n      };\n      if (!visitedPolicyId.has(mintItem.policyId)) {\n        const mintParam: MintParam = {\n          type: mintItem.type,\n          policyId: mintItem.policyId,\n          mintValue: [],\n          redeemer: mintItem.redeemer,\n          scriptSource: mintItem.scriptSource,\n        };\n        mintParams[mintItem.policyId] = mintParam;\n      }\n      const mintParam = mintParams[mintItem.policyId]!;\n      mintParam.mintValue.push(mintValueItem);\n\n      visitedPolicyId.add(mintItem.policyId);\n    });\n\n    txBuilderBody.mints = Object.values(mintParams);\n  }\n\n  // Convert withdrawals\n  if (obj.withdrawals && Array.isArray(obj.withdrawals)) {\n    txBuilderBody.withdrawals = obj.withdrawals.map(withdrawalFromObj);\n  }\n\n  // Convert certificates\n  if (obj.certificates && Array.isArray(obj.certificates)) {\n    txBuilderBody.certificates = obj.certificates.map(certificateFromObj);\n  }\n\n  // Convert votes\n  if (obj.votes && Array.isArray(obj.votes)) {\n    txBuilderBody.votes = obj.votes.map(voteFromObj);\n  }\n\n  // Convert validity range\n  if (obj.validityRange) {\n    txBuilderBody.validityRange = validityRangeFromObj(obj.validityRange);\n  }\n\n  // Convert metadata\n  if (obj.metadata) {\n    txBuilderBody.metadata = metadataFromObj(obj.metadata);\n  }\n\n  // Convert required signers\n  if (obj.requiredSignatures && Array.isArray(obj.requiredSignatures)) {\n    txBuilderBody.requiredSignatures = [...obj.requiredSignatures];\n  }\n\n  // Convert reference inputs\n  if (obj.referenceInputs && Array.isArray(obj.referenceInputs)) {\n    txBuilderBody.referenceInputs = [...obj.referenceInputs];\n  }\n\n  // Convert collaterals\n  if (obj.collaterals && Array.isArray(obj.collaterals)) {\n    txBuilderBody.collaterals = obj.collaterals.map(collateralTxInFromObj);\n  }\n\n  // Convert change address\n  if (obj.changeAddress) {\n    txBuilderBody.changeAddress = obj.changeAddress;\n  }\n\n  // Convert signing keys\n  if (obj.signingKey && Array.isArray(obj.signingKey)) {\n    txBuilderBody.signingKey = [...obj.signingKey];\n  }\n\n  // Convert network\n  if (obj.network) {\n    txBuilderBody.network = networkFromObj(obj.network);\n  }\n\n  return txBuilderBody;\n};",
          "source": "mesh-core-csl",
          "implementation": "export const txBuilderBodyFromObj = (objJson: any): MeshTxBuilderBody => {\n  const txBuilderBody: MeshTxBuilderBody = emptyTxBuilderBody();\n  const obj = JSON.parse(objJson);\n\n  // Convert inputs\n  if (obj.inputs && Array.isArray(obj.inputs)) {\n    txBuilderBody.inputs = obj.inputs.map(txInFromObj);\n  }\n\n  // Convert outputs\n  if (obj.outputs && Array.isArray(obj.outputs)) {\n    txBuilderBody.outputs = obj.outputs.map(outputFromObj);\n  }\n\n  // Convert fee\n  if (obj.fee) {\n    txBuilderBody.fee = obj.fee.toString();\n  }\n\n  // Convert mint tokens\n  if (obj.mints && Array.isArray(obj.mints)) {\n    const mintItems: MintItem[] = obj.mints.map(mintItemFromObj);\n\n    const visitedPolicyId = new Set<string>();\n    const mintParams: Record<string, MintParam> = {};\n\n    mintItems.forEach((mintItem) => {\n      const mintValueItem = {\n        assetName: mintItem.assetName,\n        amount: mintItem.amount,\n      };\n      if (!visitedPolicyId.has(mintItem.policyId)) {\n        const mintParam: MintParam = {\n          type: mintItem.type,\n          policyId: mintItem.policyId,\n          mintValue: [],\n          redeemer: mintItem.redeemer,\n          scriptSource: mintItem.scriptSource,\n        };\n        mintParams[mintItem.policyId] = mintParam;\n      }\n      const mintParam = mintParams[mintItem.policyId]!;\n      mintParam.mintValue.push(mintValueItem);\n\n      visitedPolicyId.add(mintItem.policyId);\n    });\n\n    txBuilderBody.mints = Object.values(mintParams);\n  }\n\n  // Convert withdrawals\n  if (obj.withdrawals && Array.isArray(obj.withdrawals)) {\n    txBuilderBody.withdrawals = obj.withdrawals.map(withdrawalFromObj);\n  }\n\n  // Convert certificates\n  if (obj.certificates && Array.isArray(obj.certificates)) {\n    txBuilderBody.certificates = obj.certificates.map(certificateFromObj);\n  }\n\n  // Convert votes\n  if (obj.votes && Array.isArray(obj.votes)) {\n    txBuilderBody.votes = obj.votes.map(voteFromObj);\n  }\n\n  // Convert validity range\n  if (obj.validityRange) {\n    txBuilderBody.validityRange = validityRangeFromObj(obj.validityRange);\n  }\n\n  // Convert metadata\n  if (obj.metadata) {\n    txBuilderBody.metadata = metadataFromObj(obj.metadata);\n  }\n\n  // Convert required signers\n  if (obj.requiredSignatures && Array.isArray(obj.requiredSignatures)) {\n    txBuilderBody.requiredSignatures = [...obj.requiredSignatures];\n  }\n\n  // Convert reference inputs\n  if (obj.referenceInputs && Array.isArray(obj.referenceInputs)) {\n    txBuilderBody.referenceInputs = [...obj.referenceInputs];\n  }\n\n  // Convert collaterals\n  if (obj.collaterals && Array.isArray(obj.collaterals)) {\n    txBuilderBody.collaterals = obj.collaterals.map(collateralTxInFromObj);\n  }\n\n  // Convert change address\n  if (obj.changeAddress) {\n    txBuilderBody.changeAddress = obj.changeAddress;\n  }\n\n  // Convert signing keys\n  if (obj.signingKey && Array.isArray(obj.signingKey)) {\n    txBuilderBody.signingKey = [...obj.signingKey];\n  }\n\n  // Convert network\n  if (obj.network) {\n    txBuilderBody.network = networkFromObj(obj.network);\n  }\n\n  return txBuilderBody;\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "txBuilderBodyFromObj",
          "type": "any",
          "value": "(objJson: any): MeshTxBuilderBody => {",
          "isPublic": true,
          "line": 23,
          "raw": "export const txBuilderBodyFromObj = (objJson: any): MeshTxBuilderBody => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "txBuilderBody",
          "type": "MeshTxBuilderBody",
          "value": "emptyTxBuilderBody();",
          "isPublic": true,
          "line": 24,
          "raw": "const txBuilderBody: MeshTxBuilderBody = emptyTxBuilderBody();",
          "source": "mesh-core-csl"
        },
        {
          "name": "obj",
          "type": "any",
          "value": "JSON.parse(objJson);",
          "isPublic": true,
          "line": 25,
          "raw": "const obj = JSON.parse(objJson);",
          "source": "mesh-core-csl"
        },
        {
          "name": "mintItems",
          "type": "MintItem[]",
          "value": "obj.mints.map(mintItemFromObj);",
          "isPublic": true,
          "line": 44,
          "raw": "const mintItems: MintItem[] = obj.mints.map(mintItemFromObj);",
          "source": "mesh-core-csl"
        },
        {
          "name": "visitedPolicyId",
          "type": "any",
          "value": "new Set<string>();",
          "isPublic": true,
          "line": 46,
          "raw": "const visitedPolicyId = new Set<string>();",
          "source": "mesh-core-csl"
        },
        {
          "name": "mintParams",
          "type": "Record<string, MintParam>",
          "value": "{};",
          "isPublic": true,
          "line": 47,
          "raw": "const mintParams: Record<string, MintParam> = {};",
          "source": "mesh-core-csl"
        },
        {
          "name": "mintValueItem",
          "type": "any",
          "value": "{",
          "isPublic": true,
          "line": 50,
          "raw": "const mintValueItem = {",
          "source": "mesh-core-csl"
        },
        {
          "name": "mintParam",
          "type": "MintParam",
          "value": "{",
          "isPublic": true,
          "line": 55,
          "raw": "const mintParam: MintParam = {",
          "source": "mesh-core-csl"
        },
        {
          "name": "mintParam",
          "type": "any",
          "value": "mintParams[mintItem.policyId]!;",
          "isPublic": true,
          "line": 64,
          "raw": "const mintParam = mintParams[mintItem.policyId]!;",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  emptyTxBuilderBody,\n  MeshTxBuilderBody,\n  MintItem,\n  MintParam,\n  validityRangeFromObj,\n} from \"@meshsdk/common\";\n\nimport { certificateFromObj } from \"./certificate\";\nimport { metadataFromObj } from \"./metadata\";\nimport { mintItemFromObj } from \"./mint\";\nimport { networkFromObj } from \"./network\";\nimport { outputFromObj } from \"./output\";\nimport { collateralTxInFromObj, txInFromObj } from \"./txIn\";\nimport { voteFromObj } from \"./vote\";\nimport { withdrawalFromObj } from \"./withdrawal\";\n\n/**\n * Convert an object representation back to MeshTxBuilderBody\n * @param obj The object representation of the transaction body\n * @returns The MeshTxBuilderBody instance\n */\nexport const txBuilderBodyFromObj = (objJson: any): MeshTxBuilderBody => {\n  const txBuilderBody: MeshTxBuilderBody = emptyTxBuilderBody();\n  const obj = JSON.parse(objJson);\n\n  // Convert inputs\n  if (obj.inputs && Array.isArray(obj.inputs)) {\n    txBuilderBody.inputs = obj.inputs.map(txInFromObj);\n  }\n\n  // Convert outputs\n  if (obj.outputs && Array.isArray(obj.outputs)) {\n    txBuilderBody.outputs = obj.outputs.map(outputFromObj);\n  }\n\n  // Convert fee\n  if (obj.fee) {\n    txBuilderBody.fee = obj.fee.toString();\n  }\n\n  // Convert mint tokens\n  if (obj.mints && Array.isArray(obj.mints)) {\n    const mintItems: MintItem[] = obj.mints.map(mintItemFromObj);\n\n    const visitedPolicyId = new Set<string>();\n    const mintParams: Record<string, MintParam> = {};\n\n    mintItems.forEach((mintItem) => {\n      const mintValueItem = {\n        assetName: mintItem.assetName,\n        amount: mintItem.amount,\n      };\n      if (!visitedPolicyId.has(mintItem.policyId)) {\n        const mintParam: MintParam = {\n          type: mintItem.type,\n          policyId: mintItem.policyId,\n          mintValue: [],\n          redeemer: mintItem.redeemer,\n          scriptSource: mintItem.scriptSource,\n        };\n        mintParams[mintItem.policyId] = mintParam;\n      }\n      const mintParam = mintParams[mintItem.policyId]!;\n      mintParam.mintValue.push(mintValueItem);\n\n      visitedPolicyId.add(mintItem.policyId);\n    });\n\n    txBuilderBody.mints = Object.values(mintParams);\n  }\n\n  // Convert withdrawals\n  if (obj.withdrawals && Array.isArray(obj.withdrawals)) {\n    txBuilderBody.withdrawals = obj.withdrawals.map(withdrawalFromObj);\n  }\n\n  // Convert certificates\n  if (obj.certificates && Array.isArray(obj.certificates)) {\n    txBuilderBody.certificates = obj.certificates.map(certificateFromObj);\n  }\n\n  // Convert votes\n  if (obj.votes && Array.isArray(obj.votes)) {\n    txBuilderBody.votes = obj.votes.map(voteFromObj);\n  }\n\n  // Convert validity range\n  if (obj.validityRange) {\n    txBuilderBody.validityRange = validityRangeFromObj(obj.validityRange);\n  }\n\n  // Convert metadata\n  if (obj.metadata) {\n    txBuilderBody.metadata = metadataFromObj(obj.metadata);\n  }\n\n  // Convert required signers\n  if (obj.requiredSignatures && Array.isArray(obj.requiredSignatures)) {\n    txBuilderBody.requiredSignatures = [...obj.requiredSignatures];\n  }\n\n  // Convert reference inputs\n  if (obj.referenceInputs && Array.isArray(obj.referenceInputs)) {\n    txBuilderBody.referenceInputs = [...obj.referenceInputs];\n  }\n\n  // Convert collaterals\n  if (obj.collaterals && Array.isArray(obj.collaterals)) {\n    txBuilderBody.collaterals = obj.collaterals.map(collateralTxInFromObj);\n  }\n\n  // Convert change address\n  if (obj.changeAddress) {\n    txBuilderBody.changeAddress = obj.changeAddress;\n  }\n\n  // Convert signing keys\n  if (obj.signingKey && Array.isArray(obj.signingKey)) {\n    txBuilderBody.signingKey = [...obj.signingKey];\n  }\n\n  // Convert network\n  if (obj.network) {\n    txBuilderBody.network = networkFromObj(obj.network);\n  }\n\n  return txBuilderBody;\n};\n\n// Re-export all conversion functions\nexport * from \"./certificate\";\nexport * from \"./data\";\nexport * from \"./metadata\";\nexport * from \"./mint\";\nexport * from \"./network\";\nexport * from \"./output\";\nexport * from \"./script\";\nexport * from \"./txIn\";\nexport * from \"./utxo\";\nexport * from \"./vote\";\nexport * from \"./withdrawal\";\n",
      "dependencies": [
        "txBuilderBodyFromObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.metadata.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/fromObj/metadata.ts",
      "name": "core.adaptor.fromObj.metadata.ts",
      "imports": [
        {
          "module": "metadataFromObj",
          "items": [],
          "line": 12,
          "raw": "export const metadataFromObj = (metadataArray: Metadata[]): TxMetadata => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "metadataFromObj",
          "signature": "export const metadataFromObj = (metadataArray: Metadata[]): TxMetadata => {",
          "documentation": "",
          "parameters": [
            {
              "name": "metadataArray",
              "type": "Metadata[]",
              "optional": false
            }
          ],
          "returnType": "TxMetadata",
          "isPublic": true,
          "line": 12,
          "raw": "export const metadataFromObj = (metadataArray: Metadata[]): TxMetadata => {\n  const result: TxMetadata = new Map<bigint, Metadatum>();\n\n  metadataArray.forEach((metadata) => {\n    const key = BigInt(metadata.tag);\n    const value = objToMetadatum(JSONBigParser.parse(metadata.metadata));\n    result.set(key, value);\n  });\n\n  return result;\n};",
          "source": "mesh-core-csl",
          "implementation": "export const metadataFromObj = (metadataArray: Metadata[]): TxMetadata => {\n  const result: TxMetadata = new Map<bigint, Metadatum>();\n\n  metadataArray.forEach((metadata) => {\n    const key = BigInt(metadata.tag);\n    const value = objToMetadatum(JSONBigParser.parse(metadata.metadata));\n    result.set(key, value);\n  });\n\n  return result;\n};"
        },
        {
          "name": "objToMetadatum",
          "signature": "const objToMetadatum = (obj: any): Metadatum => {",
          "documentation": "",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "Metadatum",
          "isPublic": true,
          "line": 24,
          "raw": "const objToMetadatum = (obj: any): Metadatum => {\n  if (typeof obj === \"number\") {\n    return obj;\n  } else if (typeof obj === \"string\") {\n    // Check if it's a BigInt string (valid digits only), then convert to BigInt\n    if (/^\\d+$/.test(obj)) {\n      return BigInt(obj);\n    }\n    // Check if its a negative BigInt string\n    if (/^-?\\d+$/.test(obj)) {\n      return BigInt(obj);\n    }\n    return obj;\n  } else if (typeof obj === \"bigint\") {\n    return obj;\n  } else if (typeof obj === \"object\" && obj !== null) {\n    if (Array.isArray(obj)) {\n      return obj.map(objToMetadatum);\n    } else {\n      // Convert object to Map\n      const result = new Map<Metadatum, Metadatum>();\n      Object.entries(obj).forEach(([key, value]) => {\n        // Convert key back to original type\n        let convertedKey: Metadatum = objToMetadatum(key);\n        result.set(convertedKey, objToMetadatum(value));\n      });\n      return result;\n    }\n  } else {\n    throw new Error(\"objToMetadatum: Unsupported object type\");\n  }\n};",
          "source": "mesh-core-csl",
          "implementation": "const objToMetadatum = (obj: any): Metadatum => {\n  if (typeof obj === \"number\") {\n    return obj;\n  } else if (typeof obj === \"string\") {\n    // Check if it's a BigInt string (valid digits only), then convert to BigInt\n    if (/^\\d+$/.test(obj)) {\n      return BigInt(obj);\n    }\n    // Check if its a negative BigInt string\n    if (/^-?\\d+$/.test(obj)) {\n      return BigInt(obj);\n    }\n    return obj;\n  } else if (typeof obj === \"bigint\") {\n    return obj;\n  } else if (typeof obj === \"object\" && obj !== null) {\n    if (Array.isArray(obj)) {\n      return obj.map(objToMetadatum);\n    } else {\n      // Convert object to Map\n      const result = new Map<Metadatum, Metadatum>();\n      Object.entries(obj).forEach(([key, value]) => {\n        // Convert key back to original type\n        let convertedKey: Metadatum = objToMetadatum(key);\n        result.set(convertedKey, objToMetadatum(value));\n      });\n      return result;\n    }\n  } else {\n    throw new Error(\"objToMetadatum: Unsupported object type\");\n  }\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "JSONBigParser",
          "type": "any",
          "value": "JSONbig({",
          "isPublic": true,
          "line": 6,
          "raw": "const JSONBigParser = JSONbig({",
          "source": "mesh-core-csl"
        },
        {
          "name": "metadataFromObj",
          "type": "any",
          "value": "(metadataArray: Metadata[]): TxMetadata => {",
          "isPublic": true,
          "line": 12,
          "raw": "export const metadataFromObj = (metadataArray: Metadata[]): TxMetadata => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "result",
          "type": "TxMetadata",
          "value": "new Map<bigint, Metadatum>();",
          "isPublic": true,
          "line": 13,
          "raw": "const result: TxMetadata = new Map<bigint, Metadatum>();",
          "source": "mesh-core-csl"
        },
        {
          "name": "key",
          "type": "any",
          "value": "BigInt(metadata.tag);",
          "isPublic": true,
          "line": 16,
          "raw": "const key = BigInt(metadata.tag);",
          "source": "mesh-core-csl"
        },
        {
          "name": "value",
          "type": "any",
          "value": "objToMetadatum(JSONBigParser.parse(metadata.metadata));",
          "isPublic": true,
          "line": 17,
          "raw": "const value = objToMetadatum(JSONBigParser.parse(metadata.metadata));",
          "source": "mesh-core-csl"
        },
        {
          "name": "objToMetadatum",
          "type": "any",
          "value": "(obj: any): Metadatum => {",
          "isPublic": true,
          "line": 24,
          "raw": "const objToMetadatum = (obj: any): Metadatum => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "result",
          "type": "any",
          "value": "new Map<Metadatum, Metadatum>();",
          "isPublic": true,
          "line": 44,
          "raw": "const result = new Map<Metadatum, Metadatum>();",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import JSONbig from \"json-bigint\";\n\nimport { Metadata, Metadatum, TxMetadata } from \"@meshsdk/common\";\n\n// Configure JSONbig to properly handle BigInts while preserving regular strings\nconst JSONBigParser = JSONbig({\n  storeAsString: false,\n  useNativeBigInt: true,\n  alwaysParseAsBig: false,\n});\n\nexport const metadataFromObj = (metadataArray: Metadata[]): TxMetadata => {\n  const result: TxMetadata = new Map<bigint, Metadatum>();\n\n  metadataArray.forEach((metadata) => {\n    const key = BigInt(metadata.tag);\n    const value = objToMetadatum(JSONBigParser.parse(metadata.metadata));\n    result.set(key, value);\n  });\n\n  return result;\n};\n\nconst objToMetadatum = (obj: any): Metadatum => {\n  if (typeof obj === \"number\") {\n    return obj;\n  } else if (typeof obj === \"string\") {\n    // Check if it's a BigInt string (valid digits only), then convert to BigInt\n    if (/^\\d+$/.test(obj)) {\n      return BigInt(obj);\n    }\n    // Check if its a negative BigInt string\n    if (/^-?\\d+$/.test(obj)) {\n      return BigInt(obj);\n    }\n    return obj;\n  } else if (typeof obj === \"bigint\") {\n    return obj;\n  } else if (typeof obj === \"object\" && obj !== null) {\n    if (Array.isArray(obj)) {\n      return obj.map(objToMetadatum);\n    } else {\n      // Convert object to Map\n      const result = new Map<Metadatum, Metadatum>();\n      Object.entries(obj).forEach(([key, value]) => {\n        // Convert key back to original type\n        let convertedKey: Metadatum = objToMetadatum(key);\n        result.set(convertedKey, objToMetadatum(value));\n      });\n      return result;\n    }\n  } else {\n    throw new Error(\"objToMetadatum: Unsupported object type\");\n  }\n};\n",
      "dependencies": [
        "metadataFromObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.mint.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/fromObj/mint.ts",
      "name": "core.adaptor.fromObj.mint.ts",
      "imports": [
        {
          "module": "mintItemFromObj",
          "items": [],
          "line": 11,
          "raw": "export const mintItemFromObj = (obj: any): MintItem => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "plutusMintItemFromObj",
          "items": [],
          "line": 30,
          "raw": "export const plutusMintItemFromObj = (obj: any): MintItem => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "nativeMintItemFromObj",
          "items": [],
          "line": 45,
          "raw": "export const nativeMintItemFromObj = (obj: any): MintItem => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "mintParametersFromObj",
          "items": [],
          "line": 59,
          "raw": "export const mintParametersFromObj = (",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "mintItemFromObj",
          "signature": "export const mintItemFromObj = (obj: any): MintItem => {",
          "documentation": "/**\n * Convert an object representation back to a MintItem\n * @param obj The object representation of a MintItem\n * @returns The MintItem instance\n */",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "MintItem",
          "isPublic": true,
          "line": 11,
          "raw": "/**\n * Convert an object representation back to a MintItem\n * @param obj The object representation of a MintItem\n * @returns The MintItem instance\n */\nexport const mintItemFromObj = (obj: any): MintItem => {\n  if (\"scriptMint\" in obj) {\n    return plutusMintItemFromObj(obj.scriptMint);\n  }\n\n  if (\"simpleScriptMint\" in obj) {\n    return nativeMintItemFromObj(obj.simpleScriptMint);\n  }\n\n  throw new Error(\n    `mintItemFromObj: Unknown mint item format: ${JSON.stringify(obj)}`,\n  );\n};",
          "source": "mesh-core-csl",
          "implementation": "export const mintItemFromObj = (obj: any): MintItem => {\n  if (\"scriptMint\" in obj) {\n    return plutusMintItemFromObj(obj.scriptMint);\n  }\n\n  if (\"simpleScriptMint\" in obj) {\n    return nativeMintItemFromObj(obj.simpleScriptMint);\n  }\n\n  throw new Error(\n    `mintItemFromObj: Unknown mint item format: ${JSON.stringify(obj)}`,\n  );\n};"
        },
        {
          "name": "plutusMintItemFromObj",
          "signature": "export const plutusMintItemFromObj = (obj: any): MintItem => {",
          "documentation": "/**\n * Convert a Plutus mint item object representation back to a MintItem\n * @param obj The object representation of a Plutus mint item\n * @returns The MintItem instance with Plutus script\n */",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "MintItem",
          "isPublic": true,
          "line": 30,
          "raw": "/**\n * Convert a Plutus mint item object representation back to a MintItem\n * @param obj The object representation of a Plutus mint item\n * @returns The MintItem instance with Plutus script\n */\nexport const plutusMintItemFromObj = (obj: any): MintItem => {\n  const mintParams = mintParametersFromObj(obj.mint);\n  return {\n    ...mintParams,\n    type: \"Plutus\",\n    scriptSource: scriptSourceFromObj(obj.scriptSource),\n    redeemer: obj.redeemer ? redeemerFromObj(obj.redeemer) : undefined,\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const plutusMintItemFromObj = (obj: any): MintItem => {\n  const mintParams = mintParametersFromObj(obj.mint);\n  return {\n    ...mintParams,\n    type: \"Plutus\",\n    scriptSource: scriptSourceFromObj(obj.scriptSource),\n    redeemer: obj.redeemer ? redeemerFromObj(obj.redeemer) : undefined,\n  };\n};"
        },
        {
          "name": "nativeMintItemFromObj",
          "signature": "export const nativeMintItemFromObj = (obj: any): MintItem => {",
          "documentation": "/**\n * Convert a Native mint item object representation back to a MintItem\n * @param obj The object representation of a Native mint item\n * @returns The MintItem instance with Native script\n */",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "MintItem",
          "isPublic": true,
          "line": 45,
          "raw": "/**\n * Convert a Native mint item object representation back to a MintItem\n * @param obj The object representation of a Native mint item\n * @returns The MintItem instance with Native script\n */\nexport const nativeMintItemFromObj = (obj: any): MintItem => {\n  const mintParams = mintParametersFromObj(obj.mint);\n  return {\n    ...mintParams,\n    type: \"Native\",\n    scriptSource: simpleScriptSourceFromObj(obj.scriptSource),\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const nativeMintItemFromObj = (obj: any): MintItem => {\n  const mintParams = mintParametersFromObj(obj.mint);\n  return {\n    ...mintParams,\n    type: \"Native\",\n    scriptSource: simpleScriptSourceFromObj(obj.scriptSource),\n  };\n};"
        },
        {
          "name": "mintParametersFromObj",
          "signature": "export const mintParametersFromObj = (",
          "documentation": "/**\n * Convert mint parameters object representation back to MintItem parameters\n * @param obj The object representation of mint parameters\n * @returns The mint parameters\n */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 59,
          "raw": "/**\n * Convert mint parameters object representation back to MintItem parameters\n * @param obj The object representation of mint parameters\n * @returns The mint parameters\n */\nexport const mintParametersFromObj = (\n  obj: any,\n): Omit<MintItem, \"type\" | \"scriptSource\" | \"redeemer\"> => {\n  return {\n    policyId: obj.policyId,\n    assetName: obj.assetName,\n    amount: obj.amount.toString(),\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const mintParametersFromObj = (\n  obj: any,\n): Omit<MintItem, \"type\" | \"scriptSource\" | \"redeemer\"> => {\n  return {\n    policyId: obj.policyId,\n    assetName: obj.assetName,\n    amount: obj.amount.toString(),\n  };\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "mintItemFromObj",
          "type": "any",
          "value": "(obj: any): MintItem => {",
          "isPublic": true,
          "line": 11,
          "raw": "export const mintItemFromObj = (obj: any): MintItem => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "plutusMintItemFromObj",
          "type": "any",
          "value": "(obj: any): MintItem => {",
          "isPublic": true,
          "line": 30,
          "raw": "export const plutusMintItemFromObj = (obj: any): MintItem => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "mintParams",
          "type": "any",
          "value": "mintParametersFromObj(obj.mint);",
          "isPublic": true,
          "line": 31,
          "raw": "const mintParams = mintParametersFromObj(obj.mint);",
          "source": "mesh-core-csl"
        },
        {
          "name": "nativeMintItemFromObj",
          "type": "any",
          "value": "(obj: any): MintItem => {",
          "isPublic": true,
          "line": 45,
          "raw": "export const nativeMintItemFromObj = (obj: any): MintItem => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "mintParams",
          "type": "any",
          "value": "mintParametersFromObj(obj.mint);",
          "isPublic": true,
          "line": 46,
          "raw": "const mintParams = mintParametersFromObj(obj.mint);",
          "source": "mesh-core-csl"
        },
        {
          "name": "mintParametersFromObj",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 59,
          "raw": "export const mintParametersFromObj = (",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { MintItem } from \"@meshsdk/common\";\n\nimport { redeemerFromObj } from \"./data\";\nimport { scriptSourceFromObj, simpleScriptSourceFromObj } from \"./script\";\n\n/**\n * Convert an object representation back to a MintItem\n * @param obj The object representation of a MintItem\n * @returns The MintItem instance\n */\nexport const mintItemFromObj = (obj: any): MintItem => {\n  if (\"scriptMint\" in obj) {\n    return plutusMintItemFromObj(obj.scriptMint);\n  }\n\n  if (\"simpleScriptMint\" in obj) {\n    return nativeMintItemFromObj(obj.simpleScriptMint);\n  }\n\n  throw new Error(\n    `mintItemFromObj: Unknown mint item format: ${JSON.stringify(obj)}`,\n  );\n};\n\n/**\n * Convert a Plutus mint item object representation back to a MintItem\n * @param obj The object representation of a Plutus mint item\n * @returns The MintItem instance with Plutus script\n */\nexport const plutusMintItemFromObj = (obj: any): MintItem => {\n  const mintParams = mintParametersFromObj(obj.mint);\n  return {\n    ...mintParams,\n    type: \"Plutus\",\n    scriptSource: scriptSourceFromObj(obj.scriptSource),\n    redeemer: obj.redeemer ? redeemerFromObj(obj.redeemer) : undefined,\n  };\n};\n\n/**\n * Convert a Native mint item object representation back to a MintItem\n * @param obj The object representation of a Native mint item\n * @returns The MintItem instance with Native script\n */\nexport const nativeMintItemFromObj = (obj: any): MintItem => {\n  const mintParams = mintParametersFromObj(obj.mint);\n  return {\n    ...mintParams,\n    type: \"Native\",\n    scriptSource: simpleScriptSourceFromObj(obj.scriptSource),\n  };\n};\n\n/**\n * Convert mint parameters object representation back to MintItem parameters\n * @param obj The object representation of mint parameters\n * @returns The mint parameters\n */\nexport const mintParametersFromObj = (\n  obj: any,\n): Omit<MintItem, \"type\" | \"scriptSource\" | \"redeemer\"> => {\n  return {\n    policyId: obj.policyId,\n    assetName: obj.assetName,\n    amount: obj.amount.toString(),\n  };\n};\n",
      "dependencies": [
        "mintItemFromObj",
        "plutusMintItemFromObj",
        "nativeMintItemFromObj",
        "mintParametersFromObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.network.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/fromObj/network.ts",
      "name": "core.adaptor.fromObj.network.ts",
      "imports": [
        {
          "module": "networkFromObj",
          "items": [],
          "line": 3,
          "raw": "export const networkFromObj = (obj: any): Network | number[][] => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "networkFromObj",
          "signature": "export const networkFromObj = (obj: any): Network | number[][] => {",
          "documentation": "",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "Network | number[][]",
          "isPublic": true,
          "line": 3,
          "raw": "export const networkFromObj = (obj: any): Network | number[][] => {\n  // Handle numeric and object network IDs\n  if (typeof obj === \"string\") {\n    return obj as Network;\n  } else if (obj && typeof obj === \"object\" && \"custom\" in obj) {\n    return obj.custom as number[][];\n  }\n\n  throw new Error(\n    `networkFromObj: Unknown network type in object: ${JSON.stringify(obj)}`,\n  );\n};",
          "source": "mesh-core-csl",
          "implementation": "export const networkFromObj = (obj: any): Network | number[][] => {\n  // Handle numeric and object network IDs\n  if (typeof obj === \"string\") {\n    return obj as Network;\n  } else if (obj && typeof obj === \"object\" && \"custom\" in obj) {\n    return obj.custom as number[][];\n  }\n\n  throw new Error(\n    `networkFromObj: Unknown network type in object: ${JSON.stringify(obj)}`,\n  );\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "networkFromObj",
          "type": "any",
          "value": "(obj: any): Network | number[][] => {",
          "isPublic": true,
          "line": 3,
          "raw": "export const networkFromObj = (obj: any): Network | number[][] => {",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { Network } from \"@meshsdk/common\";\n\nexport const networkFromObj = (obj: any): Network | number[][] => {\n  // Handle numeric and object network IDs\n  if (typeof obj === \"string\") {\n    return obj as Network;\n  } else if (obj && typeof obj === \"object\" && \"custom\" in obj) {\n    return obj.custom as number[][];\n  }\n\n  throw new Error(\n    `networkFromObj: Unknown network type in object: ${JSON.stringify(obj)}`,\n  );\n};\n",
      "dependencies": [
        "networkFromObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.output.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/fromObj/output.ts",
      "name": "core.adaptor.fromObj.output.ts",
      "imports": [
        {
          "module": "outputFromObj",
          "items": [],
          "line": 10,
          "raw": "export const outputFromObj = (obj: any): Output => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "outputFromObj",
          "signature": "export const outputFromObj = (obj: any): Output => {",
          "documentation": "/**\n * Convert an object representation back to an Output\n * @param obj The object representation of an Output\n * @returns The Output instance\n */",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "Output",
          "isPublic": true,
          "line": 10,
          "raw": "/**\n * Convert an object representation back to an Output\n * @param obj The object representation of an Output\n * @returns The Output instance\n */\nexport const outputFromObj = (obj: any): Output => {\n  const output: Output = {\n    address: obj.address,\n    amount: obj.amount,\n  };\n\n  // Handle datum if present\n  if (obj.datum) {\n    if (\"inline\" in obj.datum) {\n      output.datum = {\n        type: \"Inline\",\n        data: cborToBuilderData(obj.datum.inline),\n      };\n    } else if (\"hash\" in obj.datum) {\n      output.datum = {\n        type: \"Hash\",\n        data: cborToBuilderData(obj.datum.hash),\n      };\n    } else if (\"embedded\" in obj.datum) {\n      output.datum = {\n        type: \"Embedded\",\n        data: cborToBuilderData(obj.datum.embedded),\n      };\n    }\n  }\n\n  // Handle reference script if present\n  if (obj.referenceScript) {\n    const scriptSource = obj.referenceScript.providedScriptSource;\n    output.referenceScript = {\n      code: scriptSource.scriptCbor,\n      version: scriptSource.languageVersion.toUpperCase(),\n    } as PlutusScript;\n  }\n\n  return output;\n};",
          "source": "mesh-core-csl",
          "implementation": "export const outputFromObj = (obj: any): Output => {\n  const output: Output = {\n    address: obj.address,\n    amount: obj.amount,\n  };\n\n  // Handle datum if present\n  if (obj.datum) {\n    if (\"inline\" in obj.datum) {\n      output.datum = {\n        type: \"Inline\",\n        data: cborToBuilderData(obj.datum.inline),\n      };\n    } else if (\"hash\" in obj.datum) {\n      output.datum = {\n        type: \"Hash\",\n        data: cborToBuilderData(obj.datum.hash),\n      };\n    } else if (\"embedded\" in obj.datum) {\n      output.datum = {\n        type: \"Embedded\",\n        data: cborToBuilderData(obj.datum.embedded),\n      };\n    }\n  }\n\n  // Handle reference script if present\n  if (obj.referenceScript) {\n    const scriptSource = obj.referenceScript.providedScriptSource;\n    output.referenceScript = {\n      code: scriptSource.scriptCbor,\n      version: scriptSource.languageVersion.toUpperCase(),\n    } as PlutusScript;\n  }\n\n  return output;\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "outputFromObj",
          "type": "any",
          "value": "(obj: any): Output => {",
          "isPublic": true,
          "line": 10,
          "raw": "export const outputFromObj = (obj: any): Output => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "output",
          "type": "Output",
          "value": "{",
          "isPublic": true,
          "line": 11,
          "raw": "const output: Output = {",
          "source": "mesh-core-csl"
        },
        {
          "name": "scriptSource",
          "type": "any",
          "value": "obj.referenceScript.providedScriptSource;",
          "isPublic": true,
          "line": 38,
          "raw": "const scriptSource = obj.referenceScript.providedScriptSource;",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { Output, PlutusScript } from \"@meshsdk/common\";\n\nimport { cborToBuilderData } from \"./data\";\n\n/**\n * Convert an object representation back to an Output\n * @param obj The object representation of an Output\n * @returns The Output instance\n */\nexport const outputFromObj = (obj: any): Output => {\n  const output: Output = {\n    address: obj.address,\n    amount: obj.amount,\n  };\n\n  // Handle datum if present\n  if (obj.datum) {\n    if (\"inline\" in obj.datum) {\n      output.datum = {\n        type: \"Inline\",\n        data: cborToBuilderData(obj.datum.inline),\n      };\n    } else if (\"hash\" in obj.datum) {\n      output.datum = {\n        type: \"Hash\",\n        data: cborToBuilderData(obj.datum.hash),\n      };\n    } else if (\"embedded\" in obj.datum) {\n      output.datum = {\n        type: \"Embedded\",\n        data: cborToBuilderData(obj.datum.embedded),\n      };\n    }\n  }\n\n  // Handle reference script if present\n  if (obj.referenceScript) {\n    const scriptSource = obj.referenceScript.providedScriptSource;\n    output.referenceScript = {\n      code: scriptSource.scriptCbor,\n      version: scriptSource.languageVersion.toUpperCase(),\n    } as PlutusScript;\n  }\n\n  return output;\n};\n",
      "dependencies": [
        "outputFromObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.script.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/fromObj/script.ts",
      "name": "core.adaptor.fromObj.script.ts",
      "imports": [
        {
          "module": "scriptSourceFromObj",
          "items": [],
          "line": 12,
          "raw": "export const scriptSourceFromObj = (obj: any): ScriptSource => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "simpleScriptSourceFromObj",
          "items": [],
          "line": 48,
          "raw": "export const simpleScriptSourceFromObj = (obj: any): SimpleScriptSourceInfo => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "scriptSourceFromObj",
          "signature": "export const scriptSourceFromObj = (obj: any): ScriptSource => {",
          "documentation": "/**\n * Convert an object representation back to a ScriptSource\n * @param obj The object representation of a ScriptSource\n * @returns The ScriptSource instance\n */",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "ScriptSource",
          "isPublic": true,
          "line": 12,
          "raw": "/**\n * Convert an object representation back to a ScriptSource\n * @param obj The object representation of a ScriptSource\n * @returns The ScriptSource instance\n */\nexport const scriptSourceFromObj = (obj: any): ScriptSource => {\n  if (\"providedScriptSource\" in obj) {\n    return {\n      type: \"Provided\",\n      script: {\n        code: obj.providedScriptSource.scriptCbor,\n        version: obj.providedScriptSource.languageVersion.toUpperCase() as\n          | \"V1\"\n          | \"V2\",\n      } as PlutusScript,\n    };\n  }\n\n  if (\"inlineScriptSource\" in obj) {\n    return {\n      type: \"Inline\",\n      txHash: obj.inlineScriptSource.refTxIn.txHash,\n      txIndex: obj.inlineScriptSource.refTxIn.txIndex,\n      scriptHash: obj.inlineScriptSource.scriptHash || undefined,\n      version: obj.inlineScriptSource.languageVersion.toUpperCase() as\n        | \"V1\"\n        | \"V2\",\n      scriptSize: obj.inlineScriptSource.scriptSize.toString(),\n    };\n  }\n\n  throw new Error(\n    `scriptSourceFromObj: Unknown script source format: ${JSON.stringify(obj)}`,\n  );\n};",
          "source": "mesh-core-csl",
          "implementation": "export const scriptSourceFromObj = (obj: any): ScriptSource => {\n  if (\"providedScriptSource\" in obj) {\n    return {\n      type: \"Provided\",\n      script: {\n        code: obj.providedScriptSource.scriptCbor,\n        version: obj.providedScriptSource.languageVersion.toUpperCase() as\n          | \"V1\"\n          | \"V2\",\n      } as PlutusScript,\n    };\n  }\n\n  if (\"inlineScriptSource\" in obj) {\n    return {\n      type: \"Inline\",\n      txHash: obj.inlineScriptSource.refTxIn.txHash,\n      txIndex: obj.inlineScriptSource.refTxIn.txIndex,\n      scriptHash: obj.inlineScriptSource.scriptHash || undefined,\n      version: obj.inlineScriptSource.languageVersion.toUpperCase() as\n        | \"V1\"\n        | \"V2\",\n      scriptSize: obj.inlineScriptSource.scriptSize.toString(),\n    };\n  }\n\n  throw new Error(\n    `scriptSourceFromObj: Unknown script source format: ${JSON.stringify(obj)}`,\n  );\n};"
        },
        {
          "name": "simpleScriptSourceFromObj",
          "signature": "export const simpleScriptSourceFromObj = (obj: any): SimpleScriptSourceInfo => {",
          "documentation": "/**\n * Convert an object representation back to a SimpleScriptSourceInfo\n * @param obj The object representation of a SimpleScriptSourceInfo\n * @returns The SimpleScriptSourceInfo instance\n */",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "SimpleScriptSourceInfo",
          "isPublic": true,
          "line": 48,
          "raw": "/**\n * Convert an object representation back to a SimpleScriptSourceInfo\n * @param obj The object representation of a SimpleScriptSourceInfo\n * @returns The SimpleScriptSourceInfo instance\n */\nexport const simpleScriptSourceFromObj = (obj: any): SimpleScriptSourceInfo => {\n  if (\"providedSimpleScriptSource\" in obj) {\n    return {\n      type: \"Provided\",\n      scriptCode: obj.providedSimpleScriptSource.scriptCbor,\n    };\n  }\n\n  if (\"inlineSimpleScriptSource\" in obj) {\n    return {\n      type: \"Inline\",\n      txHash: obj.inlineSimpleScriptSource.refTxIn.txHash,\n      txIndex: obj.inlineSimpleScriptSource.refTxIn.txIndex,\n      simpleScriptHash:\n        obj.inlineSimpleScriptSource.simpleScriptHash || undefined,\n    };\n  }\n\n  throw new Error(\n    `simpleScriptSourceFromObj: Unknown simple script source format: ${JSON.stringify(obj)}`,\n  );\n};",
          "source": "mesh-core-csl",
          "implementation": "export const simpleScriptSourceFromObj = (obj: any): SimpleScriptSourceInfo => {\n  if (\"providedSimpleScriptSource\" in obj) {\n    return {\n      type: \"Provided\",\n      scriptCode: obj.providedSimpleScriptSource.scriptCbor,\n    };\n  }\n\n  if (\"inlineSimpleScriptSource\" in obj) {\n    return {\n      type: \"Inline\",\n      txHash: obj.inlineSimpleScriptSource.refTxIn.txHash,\n      txIndex: obj.inlineSimpleScriptSource.refTxIn.txIndex,\n      simpleScriptHash:\n        obj.inlineSimpleScriptSource.simpleScriptHash || undefined,\n    };\n  }\n\n  throw new Error(\n    `simpleScriptSourceFromObj: Unknown simple script source format: ${JSON.stringify(obj)}`,\n  );\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "scriptSourceFromObj",
          "type": "any",
          "value": "(obj: any): ScriptSource => {",
          "isPublic": true,
          "line": 12,
          "raw": "export const scriptSourceFromObj = (obj: any): ScriptSource => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "simpleScriptSourceFromObj",
          "type": "any",
          "value": "(obj: any): SimpleScriptSourceInfo => {",
          "isPublic": true,
          "line": 48,
          "raw": "export const simpleScriptSourceFromObj = (obj: any): SimpleScriptSourceInfo => {",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  PlutusScript,\n  ScriptSource,\n  SimpleScriptSourceInfo,\n} from \"@meshsdk/common\";\n\n/**\n * Convert an object representation back to a ScriptSource\n * @param obj The object representation of a ScriptSource\n * @returns The ScriptSource instance\n */\nexport const scriptSourceFromObj = (obj: any): ScriptSource => {\n  if (\"providedScriptSource\" in obj) {\n    return {\n      type: \"Provided\",\n      script: {\n        code: obj.providedScriptSource.scriptCbor,\n        version: obj.providedScriptSource.languageVersion.toUpperCase() as\n          | \"V1\"\n          | \"V2\",\n      } as PlutusScript,\n    };\n  }\n\n  if (\"inlineScriptSource\" in obj) {\n    return {\n      type: \"Inline\",\n      txHash: obj.inlineScriptSource.refTxIn.txHash,\n      txIndex: obj.inlineScriptSource.refTxIn.txIndex,\n      scriptHash: obj.inlineScriptSource.scriptHash || undefined,\n      version: obj.inlineScriptSource.languageVersion.toUpperCase() as\n        | \"V1\"\n        | \"V2\",\n      scriptSize: obj.inlineScriptSource.scriptSize.toString(),\n    };\n  }\n\n  throw new Error(\n    `scriptSourceFromObj: Unknown script source format: ${JSON.stringify(obj)}`,\n  );\n};\n\n/**\n * Convert an object representation back to a SimpleScriptSourceInfo\n * @param obj The object representation of a SimpleScriptSourceInfo\n * @returns The SimpleScriptSourceInfo instance\n */\nexport const simpleScriptSourceFromObj = (obj: any): SimpleScriptSourceInfo => {\n  if (\"providedSimpleScriptSource\" in obj) {\n    return {\n      type: \"Provided\",\n      scriptCode: obj.providedSimpleScriptSource.scriptCbor,\n    };\n  }\n\n  if (\"inlineSimpleScriptSource\" in obj) {\n    return {\n      type: \"Inline\",\n      txHash: obj.inlineSimpleScriptSource.refTxIn.txHash,\n      txIndex: obj.inlineSimpleScriptSource.refTxIn.txIndex,\n      simpleScriptHash:\n        obj.inlineSimpleScriptSource.simpleScriptHash || undefined,\n    };\n  }\n\n  throw new Error(\n    `simpleScriptSourceFromObj: Unknown simple script source format: ${JSON.stringify(obj)}`,\n  );\n};\n",
      "dependencies": [
        "scriptSourceFromObj",
        "simpleScriptSourceFromObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.txIn.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/fromObj/txIn.ts",
      "name": "core.adaptor.fromObj.txIn.ts",
      "imports": [
        {
          "module": "txInFromObj",
          "items": [],
          "line": 11,
          "raw": "export const txInFromObj = (obj: any): TxIn => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "txInParameterFromObj",
          "items": [],
          "line": 40,
          "raw": "export const txInParameterFromObj = (obj: any): TxInParameter => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "scriptTxInParameterFromObj",
          "items": [],
          "line": 49,
          "raw": "export const scriptTxInParameterFromObj = (obj: any): ScriptTxInParameter => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "simpleScriptTxInParameterFromObj",
          "items": [],
          "line": 78,
          "raw": "export const simpleScriptTxInParameterFromObj = (",
          "source": "mesh-core-csl"
        },
        {
          "module": "collateralTxInFromObj",
          "items": [],
          "line": 101,
          "raw": "export const collateralTxInFromObj = (obj: any): TxIn => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "txInFromObj",
          "signature": "export const txInFromObj = (obj: any): TxIn => {",
          "documentation": "",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "TxIn",
          "isPublic": true,
          "line": 11,
          "raw": "export const txInFromObj = (obj: any): TxIn => {\n  if (\"pubKeyTxIn\" in obj) {\n    return {\n      type: \"PubKey\",\n      txIn: txInParameterFromObj(obj.pubKeyTxIn.txIn),\n    };\n  }\n\n  if (\"scriptTxIn\" in obj) {\n    return {\n      type: \"Script\",\n      txIn: txInParameterFromObj(obj.scriptTxIn.txIn),\n      scriptTxIn: scriptTxInParameterFromObj(obj.scriptTxIn.scriptTxIn),\n    };\n  }\n\n  if (\"simpleScriptTxIn\" in obj) {\n    return {\n      type: \"SimpleScript\",\n      txIn: txInParameterFromObj(obj.simpleScriptTxIn.txIn),\n      simpleScriptTxIn: simpleScriptTxInParameterFromObj(\n        obj.simpleScriptTxIn.simpleScriptTxIn,\n      ),\n    };\n  }\n\n  throw new Error(\"Invalid transaction input object format\");\n};",
          "source": "mesh-core-csl",
          "implementation": "export const txInFromObj = (obj: any): TxIn => {\n  if (\"pubKeyTxIn\" in obj) {\n    return {\n      type: \"PubKey\",\n      txIn: txInParameterFromObj(obj.pubKeyTxIn.txIn),\n    };\n  }\n\n  if (\"scriptTxIn\" in obj) {\n    return {\n      type: \"Script\",\n      txIn: txInParameterFromObj(obj.scriptTxIn.txIn),\n      scriptTxIn: scriptTxInParameterFromObj(obj.scriptTxIn.scriptTxIn),\n    };\n  }\n\n  if (\"simpleScriptTxIn\" in obj) {\n    return {\n      type: \"SimpleScript\",\n      txIn: txInParameterFromObj(obj.simpleScriptTxIn.txIn),\n      simpleScriptTxIn: simpleScriptTxInParameterFromObj(\n        obj.simpleScriptTxIn.simpleScriptTxIn,\n      ),\n    };\n  }\n\n  throw new Error(\"Invalid transaction input object format\");\n};"
        },
        {
          "name": "txInParameterFromObj",
          "signature": "export const txInParameterFromObj = (obj: any): TxInParameter => {",
          "documentation": "",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "TxInParameter",
          "isPublic": true,
          "line": 40,
          "raw": "export const txInParameterFromObj = (obj: any): TxInParameter => {\n  return {\n    txHash: obj.txHash,\n    txIndex: obj.txIndex,\n    amount: obj.amount ?? undefined,\n    address: obj.address ?? undefined,\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const txInParameterFromObj = (obj: any): TxInParameter => {\n  return {\n    txHash: obj.txHash,\n    txIndex: obj.txIndex,\n    amount: obj.amount ?? undefined,\n    address: obj.address ?? undefined,\n  };\n};"
        },
        {
          "name": "scriptTxInParameterFromObj",
          "signature": "export const scriptTxInParameterFromObj = (obj: any): ScriptTxInParameter => {",
          "documentation": "",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "ScriptTxInParameter",
          "isPublic": true,
          "line": 49,
          "raw": "export const scriptTxInParameterFromObj = (obj: any): ScriptTxInParameter => {\n  const result: ScriptTxInParameter = {};\n\n  if (obj.scriptSource) {\n    result.scriptSource = scriptSourceFromObj(obj.scriptSource);\n  }\n\n  if (obj.datumSource) {\n    if (\"providedDatumSource\" in obj.datumSource) {\n      result.datumSource = {\n        type: \"Provided\",\n        data: cborToBuilderData(obj.datumSource.providedDatumSource.data),\n      };\n    } else if (\"inlineDatumSource\" in obj.datumSource) {\n      result.datumSource = {\n        type: \"Inline\",\n        txHash: obj.datumSource.inlineDatumSource.txHash,\n        txIndex: obj.datumSource.inlineDatumSource.txIndex,\n      };\n    }\n  }\n\n  if (obj.redeemer) {\n    result.redeemer = redeemerFromObj(obj.redeemer);\n  }\n\n  return result;\n};",
          "source": "mesh-core-csl",
          "implementation": "export const scriptTxInParameterFromObj = (obj: any): ScriptTxInParameter => {\n  const result: ScriptTxInParameter = {};\n\n  if (obj.scriptSource) {\n    result.scriptSource = scriptSourceFromObj(obj.scriptSource);\n  }\n\n  if (obj.datumSource) {\n    if (\"providedDatumSource\" in obj.datumSource) {\n      result.datumSource = {\n        type: \"Provided\",\n        data: cborToBuilderData(obj.datumSource.providedDatumSource.data),\n      };\n    } else if (\"inlineDatumSource\" in obj.datumSource) {\n      result.datumSource = {\n        type: \"Inline\",\n        txHash: obj.datumSource.inlineDatumSource.txHash,\n        txIndex: obj.datumSource.inlineDatumSource.txIndex,\n      };\n    }\n  }\n\n  if (obj.redeemer) {\n    result.redeemer = redeemerFromObj(obj.redeemer);\n  }\n\n  return result;\n};"
        },
        {
          "name": "simpleScriptTxInParameterFromObj",
          "signature": "export const simpleScriptTxInParameterFromObj = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 78,
          "raw": "export const simpleScriptTxInParameterFromObj = (\n  obj: any,\n): SimpleScriptTxInParameter => {\n  const result: SimpleScriptTxInParameter = {};\n\n  if (\"inlineSimpleScriptSource\" in obj) {\n    result.scriptSource = {\n      type: \"Inline\",\n      txHash: obj.inlineSimpleScriptSource.refTxIn.txHash,\n      txIndex: obj.inlineSimpleScriptSource.refTxIn.txIndex,\n      simpleScriptHash: obj.inlineSimpleScriptSource.simpleScriptHash,\n      scriptSize: obj.inlineSimpleScriptSource.scriptSize.toString(),\n    };\n  } else if (\"providedSimpleScriptSource\" in obj) {\n    result.scriptSource = {\n      type: \"Provided\",\n      scriptCode: obj.providedSimpleScriptSource.scriptCbor,\n    };\n  }\n\n  return result;\n};",
          "source": "mesh-core-csl",
          "implementation": "export const simpleScriptTxInParameterFromObj = (\n  obj: any,\n): SimpleScriptTxInParameter => {\n  const result: SimpleScriptTxInParameter = {};\n\n  if (\"inlineSimpleScriptSource\" in obj) {\n    result.scriptSource = {\n      type: \"Inline\",\n      txHash: obj.inlineSimpleScriptSource.refTxIn.txHash,\n      txIndex: obj.inlineSimpleScriptSource.refTxIn.txIndex,\n      simpleScriptHash: obj.inlineSimpleScriptSource.simpleScriptHash,\n      scriptSize: obj.inlineSimpleScriptSource.scriptSize.toString(),\n    };\n  } else if (\"providedSimpleScriptSource\" in obj) {\n    result.scriptSource = {\n      type: \"Provided\",\n      scriptCode: obj.providedSimpleScriptSource.scriptCbor,\n    };\n  }\n\n  return result;\n};"
        },
        {
          "name": "collateralTxInFromObj",
          "signature": "export const collateralTxInFromObj = (obj: any): TxIn => {",
          "documentation": "",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "TxIn",
          "isPublic": true,
          "line": 101,
          "raw": "export const collateralTxInFromObj = (obj: any): TxIn => {\n  return {\n    type: \"PubKey\",\n    txIn: txInParameterFromObj(obj.txIn),\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const collateralTxInFromObj = (obj: any): TxIn => {\n  return {\n    type: \"PubKey\",\n    txIn: txInParameterFromObj(obj.txIn),\n  };\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "txInFromObj",
          "type": "any",
          "value": "(obj: any): TxIn => {",
          "isPublic": true,
          "line": 11,
          "raw": "export const txInFromObj = (obj: any): TxIn => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "txInParameterFromObj",
          "type": "any",
          "value": "(obj: any): TxInParameter => {",
          "isPublic": true,
          "line": 40,
          "raw": "export const txInParameterFromObj = (obj: any): TxInParameter => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "scriptTxInParameterFromObj",
          "type": "any",
          "value": "(obj: any): ScriptTxInParameter => {",
          "isPublic": true,
          "line": 49,
          "raw": "export const scriptTxInParameterFromObj = (obj: any): ScriptTxInParameter => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "result",
          "type": "ScriptTxInParameter",
          "value": "{};",
          "isPublic": true,
          "line": 50,
          "raw": "const result: ScriptTxInParameter = {};",
          "source": "mesh-core-csl"
        },
        {
          "name": "simpleScriptTxInParameterFromObj",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 78,
          "raw": "export const simpleScriptTxInParameterFromObj = (",
          "source": "mesh-core-csl"
        },
        {
          "name": "result",
          "type": "SimpleScriptTxInParameter",
          "value": "{};",
          "isPublic": true,
          "line": 81,
          "raw": "const result: SimpleScriptTxInParameter = {};",
          "source": "mesh-core-csl"
        },
        {
          "name": "collateralTxInFromObj",
          "type": "any",
          "value": "(obj: any): TxIn => {",
          "isPublic": true,
          "line": 101,
          "raw": "export const collateralTxInFromObj = (obj: any): TxIn => {",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  ScriptTxInParameter,\n  SimpleScriptTxInParameter,\n  TxIn,\n  TxInParameter,\n} from \"@meshsdk/common\";\n\nimport { cborToBuilderData, redeemerFromObj } from \"./data\";\nimport { scriptSourceFromObj } from \"./script\";\n\nexport const txInFromObj = (obj: any): TxIn => {\n  if (\"pubKeyTxIn\" in obj) {\n    return {\n      type: \"PubKey\",\n      txIn: txInParameterFromObj(obj.pubKeyTxIn.txIn),\n    };\n  }\n\n  if (\"scriptTxIn\" in obj) {\n    return {\n      type: \"Script\",\n      txIn: txInParameterFromObj(obj.scriptTxIn.txIn),\n      scriptTxIn: scriptTxInParameterFromObj(obj.scriptTxIn.scriptTxIn),\n    };\n  }\n\n  if (\"simpleScriptTxIn\" in obj) {\n    return {\n      type: \"SimpleScript\",\n      txIn: txInParameterFromObj(obj.simpleScriptTxIn.txIn),\n      simpleScriptTxIn: simpleScriptTxInParameterFromObj(\n        obj.simpleScriptTxIn.simpleScriptTxIn,\n      ),\n    };\n  }\n\n  throw new Error(\"Invalid transaction input object format\");\n};\n\nexport const txInParameterFromObj = (obj: any): TxInParameter => {\n  return {\n    txHash: obj.txHash,\n    txIndex: obj.txIndex,\n    amount: obj.amount ?? undefined,\n    address: obj.address ?? undefined,\n  };\n};\n\nexport const scriptTxInParameterFromObj = (obj: any): ScriptTxInParameter => {\n  const result: ScriptTxInParameter = {};\n\n  if (obj.scriptSource) {\n    result.scriptSource = scriptSourceFromObj(obj.scriptSource);\n  }\n\n  if (obj.datumSource) {\n    if (\"providedDatumSource\" in obj.datumSource) {\n      result.datumSource = {\n        type: \"Provided\",\n        data: cborToBuilderData(obj.datumSource.providedDatumSource.data),\n      };\n    } else if (\"inlineDatumSource\" in obj.datumSource) {\n      result.datumSource = {\n        type: \"Inline\",\n        txHash: obj.datumSource.inlineDatumSource.txHash,\n        txIndex: obj.datumSource.inlineDatumSource.txIndex,\n      };\n    }\n  }\n\n  if (obj.redeemer) {\n    result.redeemer = redeemerFromObj(obj.redeemer);\n  }\n\n  return result;\n};\n\nexport const simpleScriptTxInParameterFromObj = (\n  obj: any,\n): SimpleScriptTxInParameter => {\n  const result: SimpleScriptTxInParameter = {};\n\n  if (\"inlineSimpleScriptSource\" in obj) {\n    result.scriptSource = {\n      type: \"Inline\",\n      txHash: obj.inlineSimpleScriptSource.refTxIn.txHash,\n      txIndex: obj.inlineSimpleScriptSource.refTxIn.txIndex,\n      simpleScriptHash: obj.inlineSimpleScriptSource.simpleScriptHash,\n      scriptSize: obj.inlineSimpleScriptSource.scriptSize.toString(),\n    };\n  } else if (\"providedSimpleScriptSource\" in obj) {\n    result.scriptSource = {\n      type: \"Provided\",\n      scriptCode: obj.providedSimpleScriptSource.scriptCbor,\n    };\n  }\n\n  return result;\n};\n\nexport const collateralTxInFromObj = (obj: any): TxIn => {\n  return {\n    type: \"PubKey\",\n    txIn: txInParameterFromObj(obj.txIn),\n  };\n};\n",
      "dependencies": [
        "txInFromObj",
        "txInParameterFromObj",
        "scriptTxInParameterFromObj",
        "simpleScriptTxInParameterFromObj",
        "collateralTxInFromObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.utxo.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/fromObj/utxo.ts",
      "name": "core.adaptor.fromObj.utxo.ts",
      "imports": [
        {
          "module": "utxoFromObj",
          "items": [],
          "line": 8,
          "raw": "export const utxoFromObj = (obj: any): UTxO => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "utxoFromObj",
          "signature": "export const utxoFromObj = (obj: any): UTxO => {",
          "documentation": "/**\n * Convert an object representation back to a UTxO\n * @param obj The object representation of the UTxO\n * @returns The UTxO instance\n */",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "UTxO",
          "isPublic": true,
          "line": 8,
          "raw": "/**\n * Convert an object representation back to a UTxO\n * @param obj The object representation of the UTxO\n * @returns The UTxO instance\n */\nexport const utxoFromObj = (obj: any): UTxO => {\n  return {\n    input: {\n      outputIndex: obj.input.outputIndex,\n      txHash: obj.input.txHash,\n    },\n    output: {\n      address: obj.output.address,\n      amount: obj.output.amount,\n      dataHash: obj.output.dataHash ?? undefined,\n      plutusData: obj.output.plutusData ?? undefined,\n      scriptRef: obj.output.scriptRef ?? undefined,\n      scriptHash: obj.output.scriptHash ?? undefined,\n    },\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const utxoFromObj = (obj: any): UTxO => {\n  return {\n    input: {\n      outputIndex: obj.input.outputIndex,\n      txHash: obj.input.txHash,\n    },\n    output: {\n      address: obj.output.address,\n      amount: obj.output.amount,\n      dataHash: obj.output.dataHash ?? undefined,\n      plutusData: obj.output.plutusData ?? undefined,\n      scriptRef: obj.output.scriptRef ?? undefined,\n      scriptHash: obj.output.scriptHash ?? undefined,\n    },\n  };\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "utxoFromObj",
          "type": "any",
          "value": "(obj: any): UTxO => {",
          "isPublic": true,
          "line": 8,
          "raw": "export const utxoFromObj = (obj: any): UTxO => {",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { UTxO } from \"@meshsdk/common\";\n\n/**\n * Convert an object representation back to a UTxO\n * @param obj The object representation of the UTxO\n * @returns The UTxO instance\n */\nexport const utxoFromObj = (obj: any): UTxO => {\n  return {\n    input: {\n      outputIndex: obj.input.outputIndex,\n      txHash: obj.input.txHash,\n    },\n    output: {\n      address: obj.output.address,\n      amount: obj.output.amount,\n      dataHash: obj.output.dataHash ?? undefined,\n      plutusData: obj.output.plutusData ?? undefined,\n      scriptRef: obj.output.scriptRef ?? undefined,\n      scriptHash: obj.output.scriptHash ?? undefined,\n    },\n  };\n};\n",
      "dependencies": [
        "utxoFromObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.vote.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/fromObj/vote.ts",
      "name": "core.adaptor.fromObj.vote.ts",
      "imports": [
        {
          "module": "voteFromObj",
          "items": [],
          "line": 6,
          "raw": "export const voteFromObj = (obj: any): Vote => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "voteFromObj",
          "signature": "export const voteFromObj = (obj: any): Vote => {",
          "documentation": "",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "Vote",
          "isPublic": true,
          "line": 6,
          "raw": "export const voteFromObj = (obj: any): Vote => {\n  if (\"basicVote\" in obj) {\n    return {\n      type: \"BasicVote\",\n      vote: voteTypeFromObj(obj.basicVote),\n    };\n  } else if (\"scriptVote\" in obj) {\n    return {\n      type: \"ScriptVote\",\n      vote: voteTypeFromObj(obj.scriptVote.vote),\n      redeemer: redeemerFromObj(obj.scriptVote.redeemer),\n      scriptSource: scriptSourceFromObj(obj.scriptVote.scriptSource),\n    };\n  } else if (\"simpleScriptVote\" in obj) {\n    return {\n      type: \"SimpleScriptVote\",\n      vote: voteTypeFromObj(obj.simpleScriptVote.vote),\n      simpleScriptSource: simpleScriptSourceFromObj(\n        obj.simpleScriptVote.simpleScriptSource,\n      ),\n    };\n  }\n  throw new Error(\"Invalid vote object structure\");\n};",
          "source": "mesh-core-csl",
          "implementation": "export const voteFromObj = (obj: any): Vote => {\n  if (\"basicVote\" in obj) {\n    return {\n      type: \"BasicVote\",\n      vote: voteTypeFromObj(obj.basicVote),\n    };\n  } else if (\"scriptVote\" in obj) {\n    return {\n      type: \"ScriptVote\",\n      vote: voteTypeFromObj(obj.scriptVote.vote),\n      redeemer: redeemerFromObj(obj.scriptVote.redeemer),\n      scriptSource: scriptSourceFromObj(obj.scriptVote.scriptSource),\n    };\n  } else if (\"simpleScriptVote\" in obj) {\n    return {\n      type: \"SimpleScriptVote\",\n      vote: voteTypeFromObj(obj.simpleScriptVote.vote),\n      simpleScriptSource: simpleScriptSourceFromObj(\n        obj.simpleScriptVote.simpleScriptSource,\n      ),\n    };\n  }\n  throw new Error(\"Invalid vote object structure\");\n};"
        },
        {
          "name": "voteTypeFromObj",
          "signature": "const voteTypeFromObj = (obj: any): VoteType => {",
          "documentation": "",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "VoteType",
          "isPublic": true,
          "line": 31,
          "raw": "const voteTypeFromObj = (obj: any): VoteType => {\n  const voter = voterFromObj(obj);\n  const votingProcedure = {\n    voteKind: voteKindFromObj(obj.votingProcedure.voteKind),\n    anchor:\n      obj.votingProcedure.anchor === null\n        ? undefined\n        : (obj.votingProcedure.anchor as Anchor),\n  };\n\n  return {\n    voter,\n    votingProcedure,\n    govActionId: obj.govActionId,\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "const voteTypeFromObj = (obj: any): VoteType => {\n  const voter = voterFromObj(obj);\n  const votingProcedure = {\n    voteKind: voteKindFromObj(obj.votingProcedure.voteKind),\n    anchor:\n      obj.votingProcedure.anchor === null\n        ? undefined\n        : (obj.votingProcedure.anchor as Anchor),\n  };\n\n  return {\n    voter,\n    votingProcedure,\n    govActionId: obj.govActionId,\n  };\n};"
        },
        {
          "name": "voterFromObj",
          "signature": "const voterFromObj = (obj: any) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 48,
          "raw": "const voterFromObj = (obj: any) => {\n  if (\"constitutionalCommitteeHotCred\" in obj.voter) {\n    const cred = obj.voter.constitutionalCommitteeHotCred;\n    return {\n      type: \"ConstitutionalCommittee\" as const,\n      hotCred:\n        \"keyHash\" in cred\n          ? { type: \"KeyHash\" as const, keyHash: cred.keyHash }\n          : { type: \"ScriptHash\" as const, scriptHash: cred.scriptHash },\n    };\n  } else if (\"dRepId\" in obj.voter) {\n    return {\n      type: \"DRep\" as const,\n      drepId: obj.voter.dRepId,\n    };\n  } else if (\"stakingPoolKeyHash\" in obj.voter) {\n    return {\n      type: \"StakingPool\" as const,\n      keyHash: obj.voter.stakingPoolKeyHash,\n    };\n  }\n  throw new Error(\"Invalid voter object structure\");\n};",
          "source": "mesh-core-csl",
          "implementation": "const voterFromObj = (obj: any) => {\n  if (\"constitutionalCommitteeHotCred\" in obj.voter) {\n    const cred = obj.voter.constitutionalCommitteeHotCred;\n    return {\n      type: \"ConstitutionalCommittee\" as const,\n      hotCred:\n        \"keyHash\" in cred\n          ? { type: \"KeyHash\" as const, keyHash: cred.keyHash }\n          : { type: \"ScriptHash\" as const, scriptHash: cred.scriptHash },\n    };\n  } else if (\"dRepId\" in obj.voter) {\n    return {\n      type: \"DRep\" as const,\n      drepId: obj.voter.dRepId,\n    };\n  } else if (\"stakingPoolKeyHash\" in obj.voter) {\n    return {\n      type: \"StakingPool\" as const,\n      keyHash: obj.voter.stakingPoolKeyHash,\n    };\n  }\n  throw new Error(\"Invalid voter object structure\");\n};"
        },
        {
          "name": "voteKindFromObj",
          "signature": "const voteKindFromObj = (voteKind: string): VoteKind => {",
          "documentation": "",
          "parameters": [
            {
              "name": "voteKind",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "VoteKind",
          "isPublic": true,
          "line": 72,
          "raw": "const voteKindFromObj = (voteKind: string): VoteKind => {\n  switch (voteKind.toLowerCase()) {\n    case \"yes\":\n      return \"Yes\";\n    case \"no\":\n      return \"No\";\n    case \"abstain\":\n      return \"Abstain\";\n    default:\n      throw new Error(\"Invalid vote kind\");\n  }\n};",
          "source": "mesh-core-csl",
          "implementation": "const voteKindFromObj = (voteKind: string): VoteKind => {\n  switch (voteKind.toLowerCase()) {\n    case \"yes\":\n      return \"Yes\";\n    case \"no\":\n      return \"No\";\n    case \"abstain\":\n      return \"Abstain\";\n    default:\n      throw new Error(\"Invalid vote kind\");\n  }\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "voteFromObj",
          "type": "any",
          "value": "(obj: any): Vote => {",
          "isPublic": true,
          "line": 6,
          "raw": "export const voteFromObj = (obj: any): Vote => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "voteTypeFromObj",
          "type": "any",
          "value": "(obj: any): VoteType => {",
          "isPublic": true,
          "line": 31,
          "raw": "const voteTypeFromObj = (obj: any): VoteType => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "voter",
          "type": "any",
          "value": "voterFromObj(obj);",
          "isPublic": true,
          "line": 32,
          "raw": "const voter = voterFromObj(obj);",
          "source": "mesh-core-csl"
        },
        {
          "name": "votingProcedure",
          "type": "any",
          "value": "{",
          "isPublic": true,
          "line": 33,
          "raw": "const votingProcedure = {",
          "source": "mesh-core-csl"
        },
        {
          "name": "voterFromObj",
          "type": "any",
          "value": "(obj: any) => {",
          "isPublic": true,
          "line": 48,
          "raw": "const voterFromObj = (obj: any) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "cred",
          "type": "any",
          "value": "obj.voter.constitutionalCommitteeHotCred;",
          "isPublic": true,
          "line": 50,
          "raw": "const cred = obj.voter.constitutionalCommitteeHotCred;",
          "source": "mesh-core-csl"
        },
        {
          "name": "voteKindFromObj",
          "type": "any",
          "value": "(voteKind: string): VoteKind => {",
          "isPublic": true,
          "line": 72,
          "raw": "const voteKindFromObj = (voteKind: string): VoteKind => {",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { Anchor, Vote, VoteKind, VoteType } from \"@meshsdk/common\";\n\nimport { redeemerFromObj } from \"./data\";\nimport { scriptSourceFromObj, simpleScriptSourceFromObj } from \"./script\";\n\nexport const voteFromObj = (obj: any): Vote => {\n  if (\"basicVote\" in obj) {\n    return {\n      type: \"BasicVote\",\n      vote: voteTypeFromObj(obj.basicVote),\n    };\n  } else if (\"scriptVote\" in obj) {\n    return {\n      type: \"ScriptVote\",\n      vote: voteTypeFromObj(obj.scriptVote.vote),\n      redeemer: redeemerFromObj(obj.scriptVote.redeemer),\n      scriptSource: scriptSourceFromObj(obj.scriptVote.scriptSource),\n    };\n  } else if (\"simpleScriptVote\" in obj) {\n    return {\n      type: \"SimpleScriptVote\",\n      vote: voteTypeFromObj(obj.simpleScriptVote.vote),\n      simpleScriptSource: simpleScriptSourceFromObj(\n        obj.simpleScriptVote.simpleScriptSource,\n      ),\n    };\n  }\n  throw new Error(\"Invalid vote object structure\");\n};\n\nconst voteTypeFromObj = (obj: any): VoteType => {\n  const voter = voterFromObj(obj);\n  const votingProcedure = {\n    voteKind: voteKindFromObj(obj.votingProcedure.voteKind),\n    anchor:\n      obj.votingProcedure.anchor === null\n        ? undefined\n        : (obj.votingProcedure.anchor as Anchor),\n  };\n\n  return {\n    voter,\n    votingProcedure,\n    govActionId: obj.govActionId,\n  };\n};\n\nconst voterFromObj = (obj: any) => {\n  if (\"constitutionalCommitteeHotCred\" in obj.voter) {\n    const cred = obj.voter.constitutionalCommitteeHotCred;\n    return {\n      type: \"ConstitutionalCommittee\" as const,\n      hotCred:\n        \"keyHash\" in cred\n          ? { type: \"KeyHash\" as const, keyHash: cred.keyHash }\n          : { type: \"ScriptHash\" as const, scriptHash: cred.scriptHash },\n    };\n  } else if (\"dRepId\" in obj.voter) {\n    return {\n      type: \"DRep\" as const,\n      drepId: obj.voter.dRepId,\n    };\n  } else if (\"stakingPoolKeyHash\" in obj.voter) {\n    return {\n      type: \"StakingPool\" as const,\n      keyHash: obj.voter.stakingPoolKeyHash,\n    };\n  }\n  throw new Error(\"Invalid voter object structure\");\n};\n\nconst voteKindFromObj = (voteKind: string): VoteKind => {\n  switch (voteKind.toLowerCase()) {\n    case \"yes\":\n      return \"Yes\";\n    case \"no\":\n      return \"No\";\n    case \"abstain\":\n      return \"Abstain\";\n    default:\n      throw new Error(\"Invalid vote kind\");\n  }\n};\n",
      "dependencies": [
        "voteFromObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.withdrawal.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/fromObj/withdrawal.ts",
      "name": "core.adaptor.fromObj.withdrawal.ts",
      "imports": [
        {
          "module": "withdrawalFromObj",
          "items": [],
          "line": 6,
          "raw": "export const withdrawalFromObj = (obj: any): Withdrawal => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "withdrawalFromObj",
          "signature": "export const withdrawalFromObj = (obj: any): Withdrawal => {",
          "documentation": "",
          "parameters": [
            {
              "name": "obj",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "Withdrawal",
          "isPublic": true,
          "line": 6,
          "raw": "export const withdrawalFromObj = (obj: any): Withdrawal => {\n  if (\"pubKeyWithdrawal\" in obj) {\n    return {\n      type: \"PubKeyWithdrawal\",\n      address: obj.pubKeyWithdrawal.address,\n      coin: obj.pubKeyWithdrawal.coin.toString(),\n    };\n  } else if (\"plutusScriptWithdrawal\" in obj) {\n    return {\n      type: \"ScriptWithdrawal\",\n      address: obj.plutusScriptWithdrawal.address,\n      coin: obj.plutusScriptWithdrawal.coin.toString(),\n      scriptSource: obj.plutusScriptWithdrawal.scriptSource\n        ? scriptSourceFromObj(obj.plutusScriptWithdrawal.scriptSource)\n        : undefined,\n      redeemer: obj.plutusScriptWithdrawal.redeemer\n        ? redeemerFromObj(obj.plutusScriptWithdrawal.redeemer)\n        : undefined,\n    };\n  } else if (\"simpleScriptWithdrawal\" in obj) {\n    return {\n      type: \"SimpleScriptWithdrawal\",\n      address: obj.simpleScriptWithdrawal.address,\n      coin: obj.simpleScriptWithdrawal.coin.toString(),\n      scriptSource: obj.simpleScriptWithdrawal.scriptSource\n        ? simpleScriptSourceFromObj(obj.simpleScriptWithdrawal.scriptSource)\n        : undefined,\n    };\n  }\n\n  throw new Error(\"withdrawalFromObj: Invalid withdrawal object format\");\n};",
          "source": "mesh-core-csl",
          "implementation": "export const withdrawalFromObj = (obj: any): Withdrawal => {\n  if (\"pubKeyWithdrawal\" in obj) {\n    return {\n      type: \"PubKeyWithdrawal\",\n      address: obj.pubKeyWithdrawal.address,\n      coin: obj.pubKeyWithdrawal.coin.toString(),\n    };\n  } else if (\"plutusScriptWithdrawal\" in obj) {\n    return {\n      type: \"ScriptWithdrawal\",\n      address: obj.plutusScriptWithdrawal.address,\n      coin: obj.plutusScriptWithdrawal.coin.toString(),\n      scriptSource: obj.plutusScriptWithdrawal.scriptSource\n        ? scriptSourceFromObj(obj.plutusScriptWithdrawal.scriptSource)\n        : undefined,\n      redeemer: obj.plutusScriptWithdrawal.redeemer\n        ? redeemerFromObj(obj.plutusScriptWithdrawal.redeemer)\n        : undefined,\n    };\n  } else if (\"simpleScriptWithdrawal\" in obj) {\n    return {\n      type: \"SimpleScriptWithdrawal\",\n      address: obj.simpleScriptWithdrawal.address,\n      coin: obj.simpleScriptWithdrawal.coin.toString(),\n      scriptSource: obj.simpleScriptWithdrawal.scriptSource\n        ? simpleScriptSourceFromObj(obj.simpleScriptWithdrawal.scriptSource)\n        : undefined,\n    };\n  }\n\n  throw new Error(\"withdrawalFromObj: Invalid withdrawal object format\");\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "withdrawalFromObj",
          "type": "any",
          "value": "(obj: any): Withdrawal => {",
          "isPublic": true,
          "line": 6,
          "raw": "export const withdrawalFromObj = (obj: any): Withdrawal => {",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { Withdrawal } from \"@meshsdk/common\";\n\nimport { redeemerFromObj } from \"./data\";\nimport { scriptSourceFromObj, simpleScriptSourceFromObj } from \"./script\";\n\nexport const withdrawalFromObj = (obj: any): Withdrawal => {\n  if (\"pubKeyWithdrawal\" in obj) {\n    return {\n      type: \"PubKeyWithdrawal\",\n      address: obj.pubKeyWithdrawal.address,\n      coin: obj.pubKeyWithdrawal.coin.toString(),\n    };\n  } else if (\"plutusScriptWithdrawal\" in obj) {\n    return {\n      type: \"ScriptWithdrawal\",\n      address: obj.plutusScriptWithdrawal.address,\n      coin: obj.plutusScriptWithdrawal.coin.toString(),\n      scriptSource: obj.plutusScriptWithdrawal.scriptSource\n        ? scriptSourceFromObj(obj.plutusScriptWithdrawal.scriptSource)\n        : undefined,\n      redeemer: obj.plutusScriptWithdrawal.redeemer\n        ? redeemerFromObj(obj.plutusScriptWithdrawal.redeemer)\n        : undefined,\n    };\n  } else if (\"simpleScriptWithdrawal\" in obj) {\n    return {\n      type: \"SimpleScriptWithdrawal\",\n      address: obj.simpleScriptWithdrawal.address,\n      coin: obj.simpleScriptWithdrawal.coin.toString(),\n      scriptSource: obj.simpleScriptWithdrawal.scriptSource\n        ? simpleScriptSourceFromObj(obj.simpleScriptWithdrawal.scriptSource)\n        : undefined,\n    };\n  }\n\n  throw new Error(\"withdrawalFromObj: Invalid withdrawal object format\");\n};\n",
      "dependencies": [
        "withdrawalFromObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/index.ts",
      "name": "core.adaptor.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./toObj\";\nexport * from \"./fromObj\";\n",
      "dependencies": [],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.certificate.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/toObj/certificate.ts",
      "name": "core.adaptor.toObj.certificate.ts",
      "imports": [
        {
          "module": "certificateToObj",
          "items": [],
          "line": 12,
          "raw": "export const certificateToObj = (certificate: Certificate): object => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "baseCertToObj",
          "items": [],
          "line": 43,
          "raw": "export const baseCertToObj = (baseCert: CertificateType): object => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "poolParamsToObj",
          "items": [],
          "line": 158,
          "raw": "export const poolParamsToObj = (poolParams: PoolParams): object => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "poolMetadataToObj",
          "items": [],
          "line": 174,
          "raw": "export const poolMetadataToObj = (poolMetadata: PoolMetadata): object => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "relayToObj",
          "items": [],
          "line": 181,
          "raw": "export const relayToObj = (relay: Relay): object => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "certificateToObj",
          "signature": "export const certificateToObj = (certificate: Certificate): object => {",
          "documentation": "",
          "parameters": [
            {
              "name": "certificate",
              "type": "Certificate",
              "optional": false
            }
          ],
          "returnType": "object",
          "isPublic": true,
          "line": 12,
          "raw": "export const certificateToObj = (certificate: Certificate): object => {\r\n  const baseCert = certificate.certType;\r\n  switch (certificate.type) {\r\n    case \"BasicCertificate\":\r\n      return {\r\n        basicCertificate: baseCertToObj(baseCert),\r\n      };\r\n    case \"ScriptCertificate\":\r\n      return {\r\n        scriptCertificate: {\r\n          cert: baseCertToObj(baseCert),\r\n          redeemer: certificate.redeemer\r\n            ? redeemerToObj(certificate.redeemer)\r\n            : null,\r\n          scriptSource: certificate.scriptSource\r\n            ? scriptSourceToObj(certificate.scriptSource)\r\n            : null,\r\n        },\r\n      };\r\n    case \"SimpleScriptCertificate\":\r\n      return {\r\n        simpleScriptCertificate: {\r\n          cert: baseCertToObj(baseCert),\r\n          simpleScriptSource: certificate.simpleScriptSource\r\n            ? simpleScriptSourceToObj(certificate.simpleScriptSource)\r\n            : null,\r\n        },\r\n      };\r\n  }\r\n};\r",
          "source": "mesh-core-csl",
          "implementation": "export const certificateToObj = (certificate: Certificate): object => {\r\n  const baseCert = certificate.certType;\r\n  switch (certificate.type) {\r\n    case \"BasicCertificate\":\r\n      return {\r\n        basicCertificate: baseCertToObj(baseCert),\r\n      };\r\n    case \"ScriptCertificate\":\r\n      return {\r\n        scriptCertificate: {\r\n          cert: baseCertToObj(baseCert),\r\n          redeemer: certificate.redeemer\r\n            ? redeemerToObj(certificate.redeemer)\r\n            : null,\r\n          scriptSource: certificate.scriptSource\r\n            ? scriptSourceToObj(certificate.scriptSource)\r\n            : null,\r\n        },\r\n      };\r\n    case \"SimpleScriptCertificate\":\r\n      return {\r\n        simpleScriptCertificate: {\r\n          cert: baseCertToObj(baseCert),\r\n          simpleScriptSource: certificate.simpleScriptSource\r\n            ? simpleScriptSourceToObj(certificate.simpleScriptSource)\r\n            : null,\r\n        },\r\n      };\r\n  }\r\n};\r"
        },
        {
          "name": "baseCertToObj",
          "signature": "export const baseCertToObj = (baseCert: CertificateType): object => {",
          "documentation": "",
          "parameters": [
            {
              "name": "baseCert",
              "type": "CertificateType",
              "optional": false
            }
          ],
          "returnType": "object",
          "isPublic": true,
          "line": 43,
          "raw": "export const baseCertToObj = (baseCert: CertificateType): object => {\r\n  switch (baseCert.type) {\r\n    case \"RegisterPool\":\r\n      return {\r\n        registerPool: {\r\n          poolParams: poolParamsToObj(baseCert.poolParams),\r\n        },\r\n      };\r\n    case \"RegisterStake\":\r\n      return {\r\n        registerStake: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          coin: 2000000, // TODO: change in conway era (this should become an argument)\r\n        },\r\n      };\r\n    case \"DelegateStake\":\r\n      return {\r\n        delegateStake: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          poolId: baseCert.poolId,\r\n        },\r\n      };\r\n    case \"DeregisterStake\":\r\n      return {\r\n        deregisterStake: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n        },\r\n      };\r\n    case \"RetirePool\":\r\n      return {\r\n        retirePool: {\r\n          poolId: baseCert.poolId,\r\n          epoch: baseCert.epoch,\r\n        },\r\n      };\r\n    case \"VoteDelegation\":\r\n      return {\r\n        voteDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          drep: baseCert.drep,\r\n        },\r\n      };\r\n    case \"StakeAndVoteDelegation\":\r\n      return {\r\n        stakeAndVoteDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          poolKeyHash: baseCert.poolKeyHash,\r\n          drep: baseCert.drep,\r\n        },\r\n      };\r\n    case \"StakeRegistrationAndDelegation\":\r\n      return {\r\n        stakeRegistrationAndDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          poolKeyHash: baseCert.poolKeyHash,\r\n          coin: baseCert.coin,\r\n        },\r\n      };\r\n    case \"VoteRegistrationAndDelegation\":\r\n      return {\r\n        voteRegistrationAndDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          drep: baseCert.drep,\r\n          coin: baseCert.coin,\r\n        },\r\n      };\r\n    case \"StakeVoteRegistrationAndDelegation\":\r\n      return {\r\n        stakeVoteRegistrationAndDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          poolKeyHash: baseCert.poolKeyHash,\r\n          drep: baseCert.drep,\r\n          coin: baseCert.coin,\r\n        },\r\n      };\r\n    case \"CommitteeHotAuth\":\r\n      return {\r\n        committeeHotAuth: {\r\n          committeeColdKeyAddress: baseCert.committeeColdKeyAddress,\r\n          committeeHotKeyAddress: baseCert.committeeHotKeyAddress,\r\n        },\r\n      };\r\n    case \"CommitteeColdResign\":\r\n      return {\r\n        committeeColdResign: {\r\n          committeeColdKeyAddress: baseCert.committeeColdKeyAddress,\r\n          anchor: baseCert.anchor ?? null,\r\n        },\r\n      };\r\n\r\n    case \"DRepRegistration\":\r\n      return {\r\n        dRepRegistration: {\r\n          drepId: baseCert.drepId,\r\n          coin: baseCert.coin,\r\n          anchor: baseCert.anchor ?? null,\r\n        },\r\n      };\r\n    case \"DRepDeregistration\":\r\n      return {\r\n        dRepDeregistration: {\r\n          drepId: baseCert.drepId,\r\n          coin: baseCert.coin,\r\n        },\r\n      };\r\n    case \"DRepUpdate\":\r\n      return {\r\n        dRepUpdate: {\r\n          drepId: baseCert.drepId,\r\n          anchor: baseCert.anchor,\r\n        },\r\n      };\r\n  }\r\n};\r",
          "source": "mesh-core-csl",
          "implementation": "export const baseCertToObj = (baseCert: CertificateType): object => {\r\n  switch (baseCert.type) {\r\n    case \"RegisterPool\":\r\n      return {\r\n        registerPool: {\r\n          poolParams: poolParamsToObj(baseCert.poolParams),\r\n        },\r\n      };\r\n    case \"RegisterStake\":\r\n      return {\r\n        registerStake: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          coin: 2000000, // TODO: change in conway era (this should become an argument)\r\n        },\r\n      };\r\n    case \"DelegateStake\":\r\n      return {\r\n        delegateStake: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          poolId: baseCert.poolId,\r\n        },\r\n      };\r\n    case \"DeregisterStake\":\r\n      return {\r\n        deregisterStake: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n        },\r\n      };\r\n    case \"RetirePool\":\r\n      return {\r\n        retirePool: {\r\n          poolId: baseCert.poolId,\r\n          epoch: baseCert.epoch,\r\n        },\r\n      };\r\n    case \"VoteDelegation\":\r\n      return {\r\n        voteDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          drep: baseCert.drep,\r\n        },\r\n      };\r\n    case \"StakeAndVoteDelegation\":\r\n      return {\r\n        stakeAndVoteDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          poolKeyHash: baseCert.poolKeyHash,\r\n          drep: baseCert.drep,\r\n        },\r\n      };\r\n    case \"StakeRegistrationAndDelegation\":\r\n      return {\r\n        stakeRegistrationAndDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          poolKeyHash: baseCert.poolKeyHash,\r\n          coin: baseCert.coin,\r\n        },\r\n      };\r\n    case \"VoteRegistrationAndDelegation\":\r\n      return {\r\n        voteRegistrationAndDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          drep: baseCert.drep,\r\n          coin: baseCert.coin,\r\n        },\r\n      };\r\n    case \"StakeVoteRegistrationAndDelegation\":\r\n      return {\r\n        stakeVoteRegistrationAndDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          poolKeyHash: baseCert.poolKeyHash,\r\n          drep: baseCert.drep,\r\n          coin: baseCert.coin,\r\n        },\r\n      };\r\n    case \"CommitteeHotAuth\":\r\n      return {\r\n        committeeHotAuth: {\r\n          committeeColdKeyAddress: baseCert.committeeColdKeyAddress,\r\n          committeeHotKeyAddress: baseCert.committeeHotKeyAddress,\r\n        },\r\n      };\r\n    case \"CommitteeColdResign\":\r\n      return {\r\n        committeeColdResign: {\r\n          committeeColdKeyAddress: baseCert.committeeColdKeyAddress,\r\n          anchor: baseCert.anchor ?? null,\r\n        },\r\n      };\r\n\r\n    case \"DRepRegistration\":\r\n      return {\r\n        dRepRegistration: {\r\n          drepId: baseCert.drepId,\r\n          coin: baseCert.coin,\r\n          anchor: baseCert.anchor ?? null,\r\n        },\r\n      };\r\n    case \"DRepDeregistration\":\r\n      return {\r\n        dRepDeregistration: {\r\n          drepId: baseCert.drepId,\r\n          coin: baseCert.coin,\r\n        },\r\n      };\r\n    case \"DRepUpdate\":\r\n      return {\r\n        dRepUpdate: {\r\n          drepId: baseCert.drepId,\r\n          anchor: baseCert.anchor,\r\n        },\r\n      };\r\n  }\r\n};\r"
        },
        {
          "name": "poolParamsToObj",
          "signature": "export const poolParamsToObj = (poolParams: PoolParams): object => {",
          "documentation": "",
          "parameters": [
            {
              "name": "poolParams",
              "type": "PoolParams",
              "optional": false
            }
          ],
          "returnType": "object",
          "isPublic": true,
          "line": 158,
          "raw": "export const poolParamsToObj = (poolParams: PoolParams): object => {\r\n  return {\r\n    vrfKeyHash: poolParams.vrfKeyHash,\r\n    operator: poolParams.operator,\r\n    pledge: poolParams.pledge,\r\n    cost: poolParams.cost,\r\n    margin: poolParams.margin,\r\n    relays: poolParams.relays.map((relay) => relayToObj(relay)),\r\n    owners: poolParams.owners,\r\n    rewardAddress: poolParams.rewardAddress,\r\n    metadata: poolParams.metadata\r\n      ? poolMetadataToObj(poolParams.metadata)\r\n      : undefined,\r\n  };\r\n};\r",
          "source": "mesh-core-csl",
          "implementation": "export const poolParamsToObj = (poolParams: PoolParams): object => {\r\n  return {\r\n    vrfKeyHash: poolParams.vrfKeyHash,\r\n    operator: poolParams.operator,\r\n    pledge: poolParams.pledge,\r\n    cost: poolParams.cost,\r\n    margin: poolParams.margin,\r\n    relays: poolParams.relays.map((relay) => relayToObj(relay)),\r\n    owners: poolParams.owners,\r\n    rewardAddress: poolParams.rewardAddress,\r\n    metadata: poolParams.metadata\r\n      ? poolMetadataToObj(poolParams.metadata)\r\n      : undefined,\r\n  };\r\n};\r"
        },
        {
          "name": "poolMetadataToObj",
          "signature": "export const poolMetadataToObj = (poolMetadata: PoolMetadata): object => {",
          "documentation": "",
          "parameters": [
            {
              "name": "poolMetadata",
              "type": "PoolMetadata",
              "optional": false
            }
          ],
          "returnType": "object",
          "isPublic": true,
          "line": 174,
          "raw": "export const poolMetadataToObj = (poolMetadata: PoolMetadata): object => {\r\n  return {\r\n    url: poolMetadata.URL,\r\n    metadata: poolMetadata.hash,\r\n  };\r\n};\r",
          "source": "mesh-core-csl",
          "implementation": "export const poolMetadataToObj = (poolMetadata: PoolMetadata): object => {\r\n  return {\r\n    url: poolMetadata.URL,\r\n    metadata: poolMetadata.hash,\r\n  };\r\n};\r"
        },
        {
          "name": "relayToObj",
          "signature": "export const relayToObj = (relay: Relay): object => {",
          "documentation": "",
          "parameters": [
            {
              "name": "relay",
              "type": "Relay",
              "optional": false
            }
          ],
          "returnType": "object",
          "isPublic": true,
          "line": 181,
          "raw": "export const relayToObj = (relay: Relay): object => {\r\n  switch (relay.type) {\r\n    case \"SingleHostAddr\":\r\n      return {\r\n        singleHostAddr: {\r\n          ipv4: relay.IPV4,\r\n          ipv6: relay.IPV6,\r\n          port: relay.port,\r\n        },\r\n      };\r\n    case \"SingleHostName\":\r\n      return {\r\n        singleHostName: {\r\n          hostname: relay.domainName,\r\n          port: relay.port,\r\n        },\r\n      };\r\n    case \"MultiHostName\":\r\n      return {\r\n        multiHostName: {\r\n          dnsName: relay.domainName,\r\n        },\r\n      };\r\n  }\r\n};\r",
          "source": "mesh-core-csl",
          "implementation": "export const relayToObj = (relay: Relay): object => {\r\n  switch (relay.type) {\r\n    case \"SingleHostAddr\":\r\n      return {\r\n        singleHostAddr: {\r\n          ipv4: relay.IPV4,\r\n          ipv6: relay.IPV6,\r\n          port: relay.port,\r\n        },\r\n      };\r\n    case \"SingleHostName\":\r\n      return {\r\n        singleHostName: {\r\n          hostname: relay.domainName,\r\n          port: relay.port,\r\n        },\r\n      };\r\n    case \"MultiHostName\":\r\n      return {\r\n        multiHostName: {\r\n          dnsName: relay.domainName,\r\n        },\r\n      };\r\n  }\r\n};\r"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "certificateToObj",
          "type": "any",
          "value": "(certificate: Certificate): object => {",
          "isPublic": true,
          "line": 12,
          "raw": "export const certificateToObj = (certificate: Certificate): object => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "baseCert",
          "type": "any",
          "value": "certificate.certType;",
          "isPublic": true,
          "line": 13,
          "raw": "const baseCert = certificate.certType;",
          "source": "mesh-core-csl"
        },
        {
          "name": "baseCertToObj",
          "type": "any",
          "value": "(baseCert: CertificateType): object => {",
          "isPublic": true,
          "line": 43,
          "raw": "export const baseCertToObj = (baseCert: CertificateType): object => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "poolParamsToObj",
          "type": "any",
          "value": "(poolParams: PoolParams): object => {",
          "isPublic": true,
          "line": 158,
          "raw": "export const poolParamsToObj = (poolParams: PoolParams): object => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "poolMetadataToObj",
          "type": "any",
          "value": "(poolMetadata: PoolMetadata): object => {",
          "isPublic": true,
          "line": 174,
          "raw": "export const poolMetadataToObj = (poolMetadata: PoolMetadata): object => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "relayToObj",
          "type": "any",
          "value": "(relay: Relay): object => {",
          "isPublic": true,
          "line": 181,
          "raw": "export const relayToObj = (relay: Relay): object => {",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\r\n  Certificate,\r\n  CertificateType,\r\n  PoolMetadata,\r\n  PoolParams,\r\n  Relay,\r\n} from \"@meshsdk/common\";\r\n\r\nimport { redeemerToObj } from \"./data\";\r\nimport { scriptSourceToObj, simpleScriptSourceToObj } from \"./script\";\r\n\r\nexport const certificateToObj = (certificate: Certificate): object => {\r\n  const baseCert = certificate.certType;\r\n  switch (certificate.type) {\r\n    case \"BasicCertificate\":\r\n      return {\r\n        basicCertificate: baseCertToObj(baseCert),\r\n      };\r\n    case \"ScriptCertificate\":\r\n      return {\r\n        scriptCertificate: {\r\n          cert: baseCertToObj(baseCert),\r\n          redeemer: certificate.redeemer\r\n            ? redeemerToObj(certificate.redeemer)\r\n            : null,\r\n          scriptSource: certificate.scriptSource\r\n            ? scriptSourceToObj(certificate.scriptSource)\r\n            : null,\r\n        },\r\n      };\r\n    case \"SimpleScriptCertificate\":\r\n      return {\r\n        simpleScriptCertificate: {\r\n          cert: baseCertToObj(baseCert),\r\n          simpleScriptSource: certificate.simpleScriptSource\r\n            ? simpleScriptSourceToObj(certificate.simpleScriptSource)\r\n            : null,\r\n        },\r\n      };\r\n  }\r\n};\r\n\r\nexport const baseCertToObj = (baseCert: CertificateType): object => {\r\n  switch (baseCert.type) {\r\n    case \"RegisterPool\":\r\n      return {\r\n        registerPool: {\r\n          poolParams: poolParamsToObj(baseCert.poolParams),\r\n        },\r\n      };\r\n    case \"RegisterStake\":\r\n      return {\r\n        registerStake: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          coin: 2000000, // TODO: change in conway era (this should become an argument)\r\n        },\r\n      };\r\n    case \"DelegateStake\":\r\n      return {\r\n        delegateStake: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          poolId: baseCert.poolId,\r\n        },\r\n      };\r\n    case \"DeregisterStake\":\r\n      return {\r\n        deregisterStake: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n        },\r\n      };\r\n    case \"RetirePool\":\r\n      return {\r\n        retirePool: {\r\n          poolId: baseCert.poolId,\r\n          epoch: baseCert.epoch,\r\n        },\r\n      };\r\n    case \"VoteDelegation\":\r\n      return {\r\n        voteDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          drep: baseCert.drep,\r\n        },\r\n      };\r\n    case \"StakeAndVoteDelegation\":\r\n      return {\r\n        stakeAndVoteDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          poolKeyHash: baseCert.poolKeyHash,\r\n          drep: baseCert.drep,\r\n        },\r\n      };\r\n    case \"StakeRegistrationAndDelegation\":\r\n      return {\r\n        stakeRegistrationAndDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          poolKeyHash: baseCert.poolKeyHash,\r\n          coin: baseCert.coin,\r\n        },\r\n      };\r\n    case \"VoteRegistrationAndDelegation\":\r\n      return {\r\n        voteRegistrationAndDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          drep: baseCert.drep,\r\n          coin: baseCert.coin,\r\n        },\r\n      };\r\n    case \"StakeVoteRegistrationAndDelegation\":\r\n      return {\r\n        stakeVoteRegistrationAndDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          poolKeyHash: baseCert.poolKeyHash,\r\n          drep: baseCert.drep,\r\n          coin: baseCert.coin,\r\n        },\r\n      };\r\n    case \"CommitteeHotAuth\":\r\n      return {\r\n        committeeHotAuth: {\r\n          committeeColdKeyAddress: baseCert.committeeColdKeyAddress,\r\n          committeeHotKeyAddress: baseCert.committeeHotKeyAddress,\r\n        },\r\n      };\r\n    case \"CommitteeColdResign\":\r\n      return {\r\n        committeeColdResign: {\r\n          committeeColdKeyAddress: baseCert.committeeColdKeyAddress,\r\n          anchor: baseCert.anchor ?? null,\r\n        },\r\n      };\r\n\r\n    case \"DRepRegistration\":\r\n      return {\r\n        dRepRegistration: {\r\n          drepId: baseCert.drepId,\r\n          coin: baseCert.coin,\r\n          anchor: baseCert.anchor ?? null,\r\n        },\r\n      };\r\n    case \"DRepDeregistration\":\r\n      return {\r\n        dRepDeregistration: {\r\n          drepId: baseCert.drepId,\r\n          coin: baseCert.coin,\r\n        },\r\n      };\r\n    case \"DRepUpdate\":\r\n      return {\r\n        dRepUpdate: {\r\n          drepId: baseCert.drepId,\r\n          anchor: baseCert.anchor,\r\n        },\r\n      };\r\n  }\r\n};\r\n\r\nexport const poolParamsToObj = (poolParams: PoolParams): object => {\r\n  return {\r\n    vrfKeyHash: poolParams.vrfKeyHash,\r\n    operator: poolParams.operator,\r\n    pledge: poolParams.pledge,\r\n    cost: poolParams.cost,\r\n    margin: poolParams.margin,\r\n    relays: poolParams.relays.map((relay) => relayToObj(relay)),\r\n    owners: poolParams.owners,\r\n    rewardAddress: poolParams.rewardAddress,\r\n    metadata: poolParams.metadata\r\n      ? poolMetadataToObj(poolParams.metadata)\r\n      : undefined,\r\n  };\r\n};\r\n\r\nexport const poolMetadataToObj = (poolMetadata: PoolMetadata): object => {\r\n  return {\r\n    url: poolMetadata.URL,\r\n    metadata: poolMetadata.hash,\r\n  };\r\n};\r\n\r\nexport const relayToObj = (relay: Relay): object => {\r\n  switch (relay.type) {\r\n    case \"SingleHostAddr\":\r\n      return {\r\n        singleHostAddr: {\r\n          ipv4: relay.IPV4,\r\n          ipv6: relay.IPV6,\r\n          port: relay.port,\r\n        },\r\n      };\r\n    case \"SingleHostName\":\r\n      return {\r\n        singleHostName: {\r\n          hostname: relay.domainName,\r\n          port: relay.port,\r\n        },\r\n      };\r\n    case \"MultiHostName\":\r\n      return {\r\n        multiHostName: {\r\n          dnsName: relay.domainName,\r\n        },\r\n      };\r\n  }\r\n};\r\n",
      "dependencies": [
        "certificateToObj",
        "baseCertToObj",
        "poolParamsToObj",
        "poolMetadataToObj",
        "relayToObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.data.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/toObj/data.ts",
      "name": "core.adaptor.toObj.data.ts",
      "imports": [
        {
          "module": "builderDataToCbor",
          "items": [],
          "line": 5,
          "raw": "export const builderDataToCbor = ({ type, content }: BuilderData): string => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "redeemerToObj",
          "items": [],
          "line": 18,
          "raw": "export const redeemerToObj = (redeemer: Redeemer): object => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "builderDataToCbor",
          "signature": "export const builderDataToCbor = ({ type, content }: BuilderData): string => {",
          "documentation": "",
          "parameters": [
            {
              "name": "{ type",
              "type": "any",
              "optional": false
            },
            {
              "name": "content }: BuilderData",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 5,
          "raw": "export const builderDataToCbor = ({ type, content }: BuilderData): string => {\n  if (type === \"Mesh\") {\n    return toPlutusData(content).to_hex();\n  }\n  if (type === \"CBOR\") {\n    return csl.PlutusData.from_hex(content as string).to_hex();\n  }\n  return csl.PlutusData.from_json(\n    content as string,\n    csl.PlutusDatumSchema.DetailedSchema,\n  ).to_hex();\n};",
          "source": "mesh-core-csl",
          "implementation": "export const builderDataToCbor = ({ type, content }: BuilderData): string => {\n  if (type === \"Mesh\") {\n    return toPlutusData(content).to_hex();\n  }\n  if (type === \"CBOR\") {\n    return csl.PlutusData.from_hex(content as string).to_hex();\n  }\n  return csl.PlutusData.from_json(\n    content as string,\n    csl.PlutusDatumSchema.DetailedSchema,\n  ).to_hex();\n};"
        },
        {
          "name": "redeemerToObj",
          "signature": "export const redeemerToObj = (redeemer: Redeemer): object => {",
          "documentation": "",
          "parameters": [
            {
              "name": "redeemer",
              "type": "Redeemer",
              "optional": false
            }
          ],
          "returnType": "object",
          "isPublic": true,
          "line": 18,
          "raw": "export const redeemerToObj = (redeemer: Redeemer): object => {\n  return {\n    data: builderDataToCbor(redeemer.data),\n    exUnits: redeemer.exUnits,\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const redeemerToObj = (redeemer: Redeemer): object => {\n  return {\n    data: builderDataToCbor(redeemer.data),\n    exUnits: redeemer.exUnits,\n  };\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "builderDataToCbor",
          "type": "any",
          "value": "({ type, content }: BuilderData): string => {",
          "isPublic": true,
          "line": 5,
          "raw": "export const builderDataToCbor = ({ type, content }: BuilderData): string => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "redeemerToObj",
          "type": "any",
          "value": "(redeemer: Redeemer): object => {",
          "isPublic": true,
          "line": 18,
          "raw": "export const redeemerToObj = (redeemer: Redeemer): object => {",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { BuilderData, Redeemer } from \"@meshsdk/common\";\n\nimport { csl, toPlutusData } from \"../../../deser\";\n\nexport const builderDataToCbor = ({ type, content }: BuilderData): string => {\n  if (type === \"Mesh\") {\n    return toPlutusData(content).to_hex();\n  }\n  if (type === \"CBOR\") {\n    return csl.PlutusData.from_hex(content as string).to_hex();\n  }\n  return csl.PlutusData.from_json(\n    content as string,\n    csl.PlutusDatumSchema.DetailedSchema,\n  ).to_hex();\n};\n\nexport const redeemerToObj = (redeemer: Redeemer): object => {\n  return {\n    data: builderDataToCbor(redeemer.data),\n    exUnits: redeemer.exUnits,\n  };\n};\n",
      "dependencies": [
        "builderDataToCbor",
        "redeemerToObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/toObj/index.ts",
      "name": "core.adaptor.toObj.index.ts",
      "imports": [
        {
          "module": "meshTxBuilderBodyToObj",
          "items": [],
          "line": 16,
          "raw": "export const meshTxBuilderBodyToObj = ({",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "meshTxBuilderBodyToObj",
          "signature": "export const meshTxBuilderBodyToObj = ({",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 16,
          "raw": "export const meshTxBuilderBodyToObj = ({\n  inputs,\n  outputs,\n  collaterals,\n  requiredSignatures,\n  referenceInputs,\n  mints,\n  changeAddress,\n  metadata,\n  validityRange,\n  certificates,\n  signingKey,\n  withdrawals,\n  votes,\n  fee,\n  network,\n}: MeshTxBuilderBody) => {\n  let mintsObj: object[] = [];\n  mints.forEach((mint: MintParam) => {\n    mint.mintValue.forEach((mintValue) => {\n      mintsObj.push(\n        mintItemToObj({\n          type: mint.type,\n          policyId: mint.policyId,\n          assetName: mintValue.assetName,\n          amount: mintValue.amount,\n          scriptSource: mint.scriptSource,\n          redeemer: mint.redeemer,\n        }),\n      );\n    });\n  });\n  return {\n    inputs: inputs.map(txInToObj),\n    outputs: outputs.map(outputToObj),\n    collaterals: collaterals.map(collateralTxInToObj),\n    requiredSignatures,\n    referenceInputs: referenceInputs,\n    mints: mintsObj,\n    changeAddress,\n    metadata: txMetadataToObj(metadata),\n    validityRange: validityRangeToObj(validityRange),\n    certificates: certificates.map(certificateToObj),\n    signingKey: signingKey,\n    withdrawals: withdrawals.map(withdrawalToObj),\n    votes: votes.map(voteToObj),\n    fee,\n    network: networkToObj(network),\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const meshTxBuilderBodyToObj = ({\n  inputs,\n  outputs,\n  collaterals,\n  requiredSignatures,\n  referenceInputs,\n  mints,\n  changeAddress,\n  metadata,\n  validityRange,\n  certificates,\n  signingKey,\n  withdrawals,\n  votes,\n  fee,\n  network,\n}: MeshTxBuilderBody) => {\n  let mintsObj: object[] = [];\n  mints.forEach((mint: MintParam) => {\n    mint.mintValue.forEach((mintValue) => {\n      mintsObj.push(\n        mintItemToObj({\n          type: mint.type,\n          policyId: mint.policyId,\n          assetName: mintValue.assetName,\n          amount: mintValue.amount,\n          scriptSource: mint.scriptSource,\n          redeemer: mint.redeemer,\n        }),\n      );\n    });\n  });\n  return {\n    inputs: inputs.map(txInToObj),\n    outputs: outputs.map(outputToObj),\n    collaterals: collaterals.map(collateralTxInToObj),\n    requiredSignatures,\n    referenceInputs: referenceInputs,\n    mints: mintsObj,\n    changeAddress,\n    metadata: txMetadataToObj(metadata),\n    validityRange: validityRangeToObj(validityRange),\n    certificates: certificates.map(certificateToObj),\n    signingKey: signingKey,\n    withdrawals: withdrawals.map(withdrawalToObj),\n    votes: votes.map(voteToObj),\n    fee,\n    network: networkToObj(network),\n  };\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "meshTxBuilderBodyToObj",
          "type": "any",
          "value": "({",
          "isPublic": true,
          "line": 16,
          "raw": "export const meshTxBuilderBodyToObj = ({",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  MeshTxBuilderBody,\n  MintParam,\n  validityRangeToObj,\n} from \"@meshsdk/common\";\n\nimport { certificateToObj } from \"./certificate\";\nimport { txMetadataToObj } from \"./metadata\";\nimport { mintItemToObj } from \"./mint\";\nimport { networkToObj } from \"./network\";\nimport { outputToObj } from \"./output\";\nimport { collateralTxInToObj, txInToObj } from \"./txIn\";\nimport { voteToObj } from \"./vote\";\nimport { withdrawalToObj } from \"./withdrawal\";\n\nexport const meshTxBuilderBodyToObj = ({\n  inputs,\n  outputs,\n  collaterals,\n  requiredSignatures,\n  referenceInputs,\n  mints,\n  changeAddress,\n  metadata,\n  validityRange,\n  certificates,\n  signingKey,\n  withdrawals,\n  votes,\n  fee,\n  network,\n}: MeshTxBuilderBody) => {\n  let mintsObj: object[] = [];\n  mints.forEach((mint: MintParam) => {\n    mint.mintValue.forEach((mintValue) => {\n      mintsObj.push(\n        mintItemToObj({\n          type: mint.type,\n          policyId: mint.policyId,\n          assetName: mintValue.assetName,\n          amount: mintValue.amount,\n          scriptSource: mint.scriptSource,\n          redeemer: mint.redeemer,\n        }),\n      );\n    });\n  });\n  return {\n    inputs: inputs.map(txInToObj),\n    outputs: outputs.map(outputToObj),\n    collaterals: collaterals.map(collateralTxInToObj),\n    requiredSignatures,\n    referenceInputs: referenceInputs,\n    mints: mintsObj,\n    changeAddress,\n    metadata: txMetadataToObj(metadata),\n    validityRange: validityRangeToObj(validityRange),\n    certificates: certificates.map(certificateToObj),\n    signingKey: signingKey,\n    withdrawals: withdrawals.map(withdrawalToObj),\n    votes: votes.map(voteToObj),\n    fee,\n    network: networkToObj(network),\n  };\n};\n\nexport * from \"./certificate\";\nexport * from \"./metadata\";\nexport * from \"./data\";\nexport * from \"./network\";\nexport * from \"./mint\";\nexport * from \"./output\";\nexport * from \"./script\";\nexport * from \"./txIn\";\nexport * from \"./vote\";\nexport * from \"./utxo\";\nexport * from \"./withdrawal\";\n",
      "dependencies": [
        "meshTxBuilderBodyToObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.metadata.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/toObj/metadata.ts",
      "name": "core.adaptor.toObj.metadata.ts",
      "imports": [
        {
          "module": "txMetadataToObj",
          "items": [],
          "line": 5,
          "raw": "export const txMetadataToObj = (metadata: TxMetadata): Metadata[] => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "txMetadataToObj",
          "signature": "export const txMetadataToObj = (metadata: TxMetadata): Metadata[] => {",
          "documentation": "",
          "parameters": [
            {
              "name": "metadata",
              "type": "TxMetadata",
              "optional": false
            }
          ],
          "returnType": "Metadata[]",
          "isPublic": true,
          "line": 5,
          "raw": "export const txMetadataToObj = (metadata: TxMetadata): Metadata[] => {\n  const result: Metadata[] = [];\n  metadata.forEach((value: Metadatum, key: bigint) => {\n    result.push({\n      tag: key.toString(),\n      metadata: JSONbig.stringify(metadatumToObj(value)),\n    });\n  });\n  return result;\n};",
          "source": "mesh-core-csl",
          "implementation": "export const txMetadataToObj = (metadata: TxMetadata): Metadata[] => {\n  const result: Metadata[] = [];\n  metadata.forEach((value: Metadatum, key: bigint) => {\n    result.push({\n      tag: key.toString(),\n      metadata: JSONbig.stringify(metadatumToObj(value)),\n    });\n  });\n  return result;\n};"
        },
        {
          "name": "metadatumToObj",
          "signature": "const metadatumToObj = (metadatum: Metadatum): any => {",
          "documentation": "",
          "parameters": [
            {
              "name": "metadatum",
              "type": "Metadatum",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 16,
          "raw": "const metadatumToObj = (metadatum: Metadatum): any => {\n  if (typeof metadatum === \"number\" || typeof metadatum === \"string\") {\n    return metadatum;\n  } else if (typeof metadatum === \"bigint\") {\n    return metadatum.toString();\n  } else if (metadatum instanceof Uint8Array) {\n    return uint8ArrayToHex(metadatum);\n  } else if (metadatum instanceof Map) {\n    const result: Record<string | number, any> = {};\n    metadatum.forEach((value, key) => {\n      result[metadatumToObj(key)] = metadatumToObj(value);\n    });\n    return result;\n  } else if (Array.isArray(metadatum)) {\n    return metadatum.map(metadatumToObj);\n  } else {\n    throw new Error(\"metadatumToObj: Unsupported Metadatum type\");\n  }\n};",
          "source": "mesh-core-csl",
          "implementation": "const metadatumToObj = (metadatum: Metadatum): any => {\n  if (typeof metadatum === \"number\" || typeof metadatum === \"string\") {\n    return metadatum;\n  } else if (typeof metadatum === \"bigint\") {\n    return metadatum.toString();\n  } else if (metadatum instanceof Uint8Array) {\n    return uint8ArrayToHex(metadatum);\n  } else if (metadatum instanceof Map) {\n    const result: Record<string | number, any> = {};\n    metadatum.forEach((value, key) => {\n      result[metadatumToObj(key)] = metadatumToObj(value);\n    });\n    return result;\n  } else if (Array.isArray(metadatum)) {\n    return metadatum.map(metadatumToObj);\n  } else {\n    throw new Error(\"metadatumToObj: Unsupported Metadatum type\");\n  }\n};"
        },
        {
          "name": "uint8ArrayToHex",
          "signature": "const uint8ArrayToHex = (bytes: Uint8Array): string => {",
          "documentation": "",
          "parameters": [
            {
              "name": "bytes",
              "type": "Uint8Array",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 36,
          "raw": "const uint8ArrayToHex = (bytes: Uint8Array): string => {\n  return Array.from(bytes)\n    .map((byte) => byte.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n};",
          "source": "mesh-core-csl",
          "implementation": "const uint8ArrayToHex = (bytes: Uint8Array): string => {\n  return Array.from(bytes)\n    .map((byte) => byte.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "txMetadataToObj",
          "type": "any",
          "value": "(metadata: TxMetadata): Metadata[] => {",
          "isPublic": true,
          "line": 5,
          "raw": "export const txMetadataToObj = (metadata: TxMetadata): Metadata[] => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "result",
          "type": "Metadata[]",
          "value": "[];",
          "isPublic": true,
          "line": 6,
          "raw": "const result: Metadata[] = [];",
          "source": "mesh-core-csl"
        },
        {
          "name": "metadatumToObj",
          "type": "any",
          "value": "(metadatum: Metadatum): any => {",
          "isPublic": true,
          "line": 16,
          "raw": "const metadatumToObj = (metadatum: Metadatum): any => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "result",
          "type": "Record<string | number, any>",
          "value": "{};",
          "isPublic": true,
          "line": 24,
          "raw": "const result: Record<string | number, any> = {};",
          "source": "mesh-core-csl"
        },
        {
          "name": "uint8ArrayToHex",
          "type": "any",
          "value": "(bytes: Uint8Array): string => {",
          "isPublic": true,
          "line": 36,
          "raw": "const uint8ArrayToHex = (bytes: Uint8Array): string => {",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import JSONbig from \"json-bigint\";\n\nimport type { Metadata, Metadatum, TxMetadata } from \"@meshsdk/common\";\n\nexport const txMetadataToObj = (metadata: TxMetadata): Metadata[] => {\n  const result: Metadata[] = [];\n  metadata.forEach((value: Metadatum, key: bigint) => {\n    result.push({\n      tag: key.toString(),\n      metadata: JSONbig.stringify(metadatumToObj(value)),\n    });\n  });\n  return result;\n};\n\nconst metadatumToObj = (metadatum: Metadatum): any => {\n  if (typeof metadatum === \"number\" || typeof metadatum === \"string\") {\n    return metadatum;\n  } else if (typeof metadatum === \"bigint\") {\n    return metadatum.toString();\n  } else if (metadatum instanceof Uint8Array) {\n    return uint8ArrayToHex(metadatum);\n  } else if (metadatum instanceof Map) {\n    const result: Record<string | number, any> = {};\n    metadatum.forEach((value, key) => {\n      result[metadatumToObj(key)] = metadatumToObj(value);\n    });\n    return result;\n  } else if (Array.isArray(metadatum)) {\n    return metadatum.map(metadatumToObj);\n  } else {\n    throw new Error(\"metadatumToObj: Unsupported Metadatum type\");\n  }\n};\n\nconst uint8ArrayToHex = (bytes: Uint8Array): string => {\n  return Array.from(bytes)\n    .map((byte) => byte.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n};\n",
      "dependencies": [
        "txMetadataToObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.mint.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/toObj/mint.ts",
      "name": "core.adaptor.toObj.mint.ts",
      "imports": [
        {
          "module": "mintItemToObj",
          "items": [],
          "line": 10,
          "raw": "export const mintItemToObj = (mintItem: MintItem): object => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "plutusMintItemToObj",
          "items": [],
          "line": 25,
          "raw": "export const plutusMintItemToObj = (mintItem: Required<MintItem>): object => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "nativeMintItemToObj",
          "items": [],
          "line": 37,
          "raw": "export const nativeMintItemToObj = (",
          "source": "mesh-core-csl"
        },
        {
          "module": "mintParametersObj",
          "items": [],
          "line": 48,
          "raw": "export const mintParametersObj = (mintItem: MintItem): object => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "mintItemToObj",
          "signature": "export const mintItemToObj = (mintItem: MintItem): object => {",
          "documentation": "",
          "parameters": [
            {
              "name": "mintItem",
              "type": "MintItem",
              "optional": false
            }
          ],
          "returnType": "object",
          "isPublic": true,
          "line": 10,
          "raw": "export const mintItemToObj = (mintItem: MintItem): object => {\n  switch (mintItem.type) {\n    case \"Plutus\":\n      return {\n        scriptMint: plutusMintItemToObj(mintItem as Required<MintItem>),\n      };\n    case \"Native\":\n      return {\n        simpleScriptMint: nativeMintItemToObj(\n          mintItem as Omit<Required<MintItem>, \"redeemer\">,\n        ),\n      };\n  }\n};",
          "source": "mesh-core-csl",
          "implementation": "export const mintItemToObj = (mintItem: MintItem): object => {\n  switch (mintItem.type) {\n    case \"Plutus\":\n      return {\n        scriptMint: plutusMintItemToObj(mintItem as Required<MintItem>),\n      };\n    case \"Native\":\n      return {\n        simpleScriptMint: nativeMintItemToObj(\n          mintItem as Omit<Required<MintItem>, \"redeemer\">,\n        ),\n      };\n  }\n};"
        },
        {
          "name": "plutusMintItemToObj",
          "signature": "export const plutusMintItemToObj = (mintItem: Required<MintItem>): object => {",
          "documentation": "",
          "parameters": [
            {
              "name": "mintItem",
              "type": "Required<MintItem>",
              "optional": false
            }
          ],
          "returnType": "object",
          "isPublic": true,
          "line": 25,
          "raw": "export const plutusMintItemToObj = (mintItem: Required<MintItem>): object => {\n  let scriptSource: object = scriptSourceToObj(\n    mintItem.scriptSource as ScriptSource,\n  );\n\n  return {\n    mint: mintParametersObj(mintItem),\n    redeemer: mintItem.redeemer ? redeemerToObj(mintItem.redeemer) : null,\n    scriptSource,\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const plutusMintItemToObj = (mintItem: Required<MintItem>): object => {\n  let scriptSource: object = scriptSourceToObj(\n    mintItem.scriptSource as ScriptSource,\n  );\n\n  return {\n    mint: mintParametersObj(mintItem),\n    redeemer: mintItem.redeemer ? redeemerToObj(mintItem.redeemer) : null,\n    scriptSource,\n  };\n};"
        },
        {
          "name": "nativeMintItemToObj",
          "signature": "export const nativeMintItemToObj = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 37,
          "raw": "export const nativeMintItemToObj = (\n  mintItem: Omit<Required<MintItem>, \"redeemer\">,\n): object => {\n  return {\n    mint: mintParametersObj(mintItem),\n    scriptSource: simpleScriptSourceToObj(\n      mintItem.scriptSource as SimpleScriptSourceInfo,\n    ),\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const nativeMintItemToObj = (\n  mintItem: Omit<Required<MintItem>, \"redeemer\">,\n): object => {\n  return {\n    mint: mintParametersObj(mintItem),\n    scriptSource: simpleScriptSourceToObj(\n      mintItem.scriptSource as SimpleScriptSourceInfo,\n    ),\n  };\n};"
        },
        {
          "name": "mintParametersObj",
          "signature": "export const mintParametersObj = (mintItem: MintItem): object => {",
          "documentation": "",
          "parameters": [
            {
              "name": "mintItem",
              "type": "MintItem",
              "optional": false
            }
          ],
          "returnType": "object",
          "isPublic": true,
          "line": 48,
          "raw": "export const mintParametersObj = (mintItem: MintItem): object => {\n  return {\n    policyId: mintItem.policyId,\n    assetName: mintItem.assetName,\n    amount: BigInt(mintItem.amount),\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const mintParametersObj = (mintItem: MintItem): object => {\n  return {\n    policyId: mintItem.policyId,\n    assetName: mintItem.assetName,\n    amount: BigInt(mintItem.amount),\n  };\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "mintItemToObj",
          "type": "any",
          "value": "(mintItem: MintItem): object => {",
          "isPublic": true,
          "line": 10,
          "raw": "export const mintItemToObj = (mintItem: MintItem): object => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "plutusMintItemToObj",
          "type": "any",
          "value": "(mintItem: Required<MintItem>): object => {",
          "isPublic": true,
          "line": 25,
          "raw": "export const plutusMintItemToObj = (mintItem: Required<MintItem>): object => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "nativeMintItemToObj",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 37,
          "raw": "export const nativeMintItemToObj = (",
          "source": "mesh-core-csl"
        },
        {
          "name": "mintParametersObj",
          "type": "any",
          "value": "(mintItem: MintItem): object => {",
          "isPublic": true,
          "line": 48,
          "raw": "export const mintParametersObj = (mintItem: MintItem): object => {",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  MintItem,\n  ScriptSource,\n  SimpleScriptSourceInfo,\n} from \"@meshsdk/common\";\n\nimport { redeemerToObj } from \"./data\";\nimport { scriptSourceToObj, simpleScriptSourceToObj } from \"./script\";\n\nexport const mintItemToObj = (mintItem: MintItem): object => {\n  switch (mintItem.type) {\n    case \"Plutus\":\n      return {\n        scriptMint: plutusMintItemToObj(mintItem as Required<MintItem>),\n      };\n    case \"Native\":\n      return {\n        simpleScriptMint: nativeMintItemToObj(\n          mintItem as Omit<Required<MintItem>, \"redeemer\">,\n        ),\n      };\n  }\n};\n\nexport const plutusMintItemToObj = (mintItem: Required<MintItem>): object => {\n  let scriptSource: object = scriptSourceToObj(\n    mintItem.scriptSource as ScriptSource,\n  );\n\n  return {\n    mint: mintParametersObj(mintItem),\n    redeemer: mintItem.redeemer ? redeemerToObj(mintItem.redeemer) : null,\n    scriptSource,\n  };\n};\n\nexport const nativeMintItemToObj = (\n  mintItem: Omit<Required<MintItem>, \"redeemer\">,\n): object => {\n  return {\n    mint: mintParametersObj(mintItem),\n    scriptSource: simpleScriptSourceToObj(\n      mintItem.scriptSource as SimpleScriptSourceInfo,\n    ),\n  };\n};\n\nexport const mintParametersObj = (mintItem: MintItem): object => {\n  return {\n    policyId: mintItem.policyId,\n    assetName: mintItem.assetName,\n    amount: BigInt(mintItem.amount),\n  };\n};\n",
      "dependencies": [
        "mintItemToObj",
        "plutusMintItemToObj",
        "nativeMintItemToObj",
        "mintParametersObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.network.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/toObj/network.ts",
      "name": "core.adaptor.toObj.network.ts",
      "imports": [
        {
          "module": "networkToObj",
          "items": [],
          "line": 3,
          "raw": "export const networkToObj = (network: Network | number[][]) => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "networkToObj",
          "signature": "export const networkToObj = (network: Network | number[][]) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "network",
              "type": "Network | number[][]",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 3,
          "raw": "export const networkToObj = (network: Network | number[][]) => {\r\n  if ((typeof network) === \"string\") {\r\n    return network;\r\n  } else {\r\n    return {\r\n      custom: network,\r\n    };\r\n  }\r\n};\r",
          "source": "mesh-core-csl",
          "implementation": "export const networkToObj = (network: Network | number[][]) => {\r\n  if ((typeof network) === \"string\") {\r\n    return network;\r\n  } else {\r\n    return {\r\n      custom: network,\r\n    };\r\n  }\r\n};\r"
        },
        {
          "name": "if",
          "signature": "if ((typeof network) === \"string\") {",
          "documentation": "",
          "parameters": [
            {
              "name": "(typeof network",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 4,
          "raw": "  if ((typeof network) === \"string\") {\r\n    return network;\r\n  } else {\r\n    return {\r\n      custom: network,\r\n    };\r\n  }\r",
          "source": "mesh-core-csl",
          "implementation": "  if ((typeof network) === \"string\") {\r\n    return network;\r\n  } else {\r\n    return {\r\n      custom: network,\r\n    };\r\n  }\r"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "networkToObj",
          "type": "any",
          "value": "(network: Network | number[][]) => {",
          "isPublic": true,
          "line": 3,
          "raw": "export const networkToObj = (network: Network | number[][]) => {",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { Network } from \"@meshsdk/common\";\r\n\r\nexport const networkToObj = (network: Network | number[][]) => {\r\n  if ((typeof network) === \"string\") {\r\n    return network;\r\n  } else {\r\n    return {\r\n      custom: network,\r\n    };\r\n  }\r\n};\r\n",
      "dependencies": [
        "networkToObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.output.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/toObj/output.ts",
      "name": "core.adaptor.toObj.output.ts",
      "imports": [
        {
          "module": "outputToObj",
          "items": [],
          "line": 5,
          "raw": "export const outputToObj = (output: Output): object => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "outputToObj",
          "signature": "export const outputToObj = (output: Output): object => {",
          "documentation": "",
          "parameters": [
            {
              "name": "output",
              "type": "Output",
              "optional": false
            }
          ],
          "returnType": "object",
          "isPublic": true,
          "line": 5,
          "raw": "export const outputToObj = (output: Output): object => {\n  let datum: object | null = null;\n  if (output.datum) {\n    switch (output.datum.type) {\n      case \"Inline\":\n        datum = { inline: builderDataToCbor(output.datum.data) };\n        break;\n      case \"Hash\":\n        datum = { hash: builderDataToCbor(output.datum.data) };\n        break;\n      case \"Embedded\":\n        datum = { embedded: builderDataToCbor(output.datum.data) };\n        break;\n    }\n  }\n\n  // TODO: add native script\n  const refScript = output.referenceScript as PlutusScript;\n\n  return {\n    address: output.address,\n    amount: output.amount,\n    datum,\n    referenceScript: output.referenceScript\n      ? {\n          providedScriptSource: {\n            scriptCbor: refScript.code,\n            languageVersion: refScript.version.toLocaleLowerCase(),\n          },\n        }\n      : null,\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const outputToObj = (output: Output): object => {\n  let datum: object | null = null;\n  if (output.datum) {\n    switch (output.datum.type) {\n      case \"Inline\":\n        datum = { inline: builderDataToCbor(output.datum.data) };\n        break;\n      case \"Hash\":\n        datum = { hash: builderDataToCbor(output.datum.data) };\n        break;\n      case \"Embedded\":\n        datum = { embedded: builderDataToCbor(output.datum.data) };\n        break;\n    }\n  }\n\n  // TODO: add native script\n  const refScript = output.referenceScript as PlutusScript;\n\n  return {\n    address: output.address,\n    amount: output.amount,\n    datum,\n    referenceScript: output.referenceScript\n      ? {\n          providedScriptSource: {\n            scriptCbor: refScript.code,\n            languageVersion: refScript.version.toLocaleLowerCase(),\n          },\n        }\n      : null,\n  };\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "outputToObj",
          "type": "any",
          "value": "(output: Output): object => {",
          "isPublic": true,
          "line": 5,
          "raw": "export const outputToObj = (output: Output): object => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "refScript",
          "type": "any",
          "value": "output.referenceScript as PlutusScript;",
          "isPublic": true,
          "line": 22,
          "raw": "const refScript = output.referenceScript as PlutusScript;",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { Output, PlutusScript } from \"@meshsdk/common\";\n\nimport { builderDataToCbor } from \"./data\";\n\nexport const outputToObj = (output: Output): object => {\n  let datum: object | null = null;\n  if (output.datum) {\n    switch (output.datum.type) {\n      case \"Inline\":\n        datum = { inline: builderDataToCbor(output.datum.data) };\n        break;\n      case \"Hash\":\n        datum = { hash: builderDataToCbor(output.datum.data) };\n        break;\n      case \"Embedded\":\n        datum = { embedded: builderDataToCbor(output.datum.data) };\n        break;\n    }\n  }\n\n  // TODO: add native script\n  const refScript = output.referenceScript as PlutusScript;\n\n  return {\n    address: output.address,\n    amount: output.amount,\n    datum,\n    referenceScript: output.referenceScript\n      ? {\n          providedScriptSource: {\n            scriptCbor: refScript.code,\n            languageVersion: refScript.version.toLocaleLowerCase(),\n          },\n        }\n      : null,\n  };\n};\n",
      "dependencies": [
        "outputToObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.script.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/toObj/script.ts",
      "name": "core.adaptor.toObj.script.ts",
      "imports": [
        {
          "module": "scriptSourceToObj",
          "items": [],
          "line": 7,
          "raw": "export const scriptSourceToObj = (scriptSource: ScriptSource): object => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "simpleScriptSourceToObj",
          "items": [],
          "line": 32,
          "raw": "export const simpleScriptSourceToObj = (",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "scriptSourceToObj",
          "signature": "export const scriptSourceToObj = (scriptSource: ScriptSource): object => {",
          "documentation": "",
          "parameters": [
            {
              "name": "scriptSource",
              "type": "ScriptSource",
              "optional": false
            }
          ],
          "returnType": "object",
          "isPublic": true,
          "line": 7,
          "raw": "export const scriptSourceToObj = (scriptSource: ScriptSource): object => {\n  if (scriptSource.type === \"Provided\") {\n    return {\n      providedScriptSource: {\n        scriptCbor: scriptSource.script.code,\n        languageVersion: (\n          scriptSource.script as PlutusScript\n        ).version!.toLocaleLowerCase(),\n      },\n    };\n  }\n\n  return {\n    inlineScriptSource: {\n      refTxIn: {\n        txHash: scriptSource.txHash,\n        txIndex: scriptSource.txIndex,\n      },\n      scriptHash: scriptSource.scriptHash ?? \"\",\n      languageVersion: scriptSource.version!.toLocaleLowerCase(),\n      scriptSize: BigInt(scriptSource.scriptSize ?? \"0\"),\n    },\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const scriptSourceToObj = (scriptSource: ScriptSource): object => {\n  if (scriptSource.type === \"Provided\") {\n    return {\n      providedScriptSource: {\n        scriptCbor: scriptSource.script.code,\n        languageVersion: (\n          scriptSource.script as PlutusScript\n        ).version!.toLocaleLowerCase(),\n      },\n    };\n  }\n\n  return {\n    inlineScriptSource: {\n      refTxIn: {\n        txHash: scriptSource.txHash,\n        txIndex: scriptSource.txIndex,\n      },\n      scriptHash: scriptSource.scriptHash ?? \"\",\n      languageVersion: scriptSource.version!.toLocaleLowerCase(),\n      scriptSize: BigInt(scriptSource.scriptSize ?? \"0\"),\n    },\n  };\n};"
        },
        {
          "name": "simpleScriptSourceToObj",
          "signature": "export const simpleScriptSourceToObj = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 32,
          "raw": "export const simpleScriptSourceToObj = (\n  scriptSource: SimpleScriptSourceInfo,\n): object => {\n  if (scriptSource.type === \"Provided\") {\n    return {\n      providedSimpleScriptSource: {\n        scriptCbor: scriptSource.scriptCode,\n      },\n    };\n  }\n\n  return {\n    inlineSimpleScriptSource: {\n      refTxIn: {\n        txHash: scriptSource.txHash,\n        txIndex: scriptSource.txIndex,\n      },\n      simpleScriptHash: scriptSource.simpleScriptHash ?? \"\",\n    },\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const simpleScriptSourceToObj = (\n  scriptSource: SimpleScriptSourceInfo,\n): object => {\n  if (scriptSource.type === \"Provided\") {\n    return {\n      providedSimpleScriptSource: {\n        scriptCbor: scriptSource.scriptCode,\n      },\n    };\n  }\n\n  return {\n    inlineSimpleScriptSource: {\n      refTxIn: {\n        txHash: scriptSource.txHash,\n        txIndex: scriptSource.txIndex,\n      },\n      simpleScriptHash: scriptSource.simpleScriptHash ?? \"\",\n    },\n  };\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "scriptSourceToObj",
          "type": "any",
          "value": "(scriptSource: ScriptSource): object => {",
          "isPublic": true,
          "line": 7,
          "raw": "export const scriptSourceToObj = (scriptSource: ScriptSource): object => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "simpleScriptSourceToObj",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 32,
          "raw": "export const simpleScriptSourceToObj = (",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  PlutusScript,\n  ScriptSource,\n  SimpleScriptSourceInfo,\n} from \"@meshsdk/common\";\n\nexport const scriptSourceToObj = (scriptSource: ScriptSource): object => {\n  if (scriptSource.type === \"Provided\") {\n    return {\n      providedScriptSource: {\n        scriptCbor: scriptSource.script.code,\n        languageVersion: (\n          scriptSource.script as PlutusScript\n        ).version!.toLocaleLowerCase(),\n      },\n    };\n  }\n\n  return {\n    inlineScriptSource: {\n      refTxIn: {\n        txHash: scriptSource.txHash,\n        txIndex: scriptSource.txIndex,\n      },\n      scriptHash: scriptSource.scriptHash ?? \"\",\n      languageVersion: scriptSource.version!.toLocaleLowerCase(),\n      scriptSize: BigInt(scriptSource.scriptSize ?? \"0\"),\n    },\n  };\n};\n\nexport const simpleScriptSourceToObj = (\n  scriptSource: SimpleScriptSourceInfo,\n): object => {\n  if (scriptSource.type === \"Provided\") {\n    return {\n      providedSimpleScriptSource: {\n        scriptCbor: scriptSource.scriptCode,\n      },\n    };\n  }\n\n  return {\n    inlineSimpleScriptSource: {\n      refTxIn: {\n        txHash: scriptSource.txHash,\n        txIndex: scriptSource.txIndex,\n      },\n      simpleScriptHash: scriptSource.simpleScriptHash ?? \"\",\n    },\n  };\n};\n",
      "dependencies": [
        "scriptSourceToObj",
        "simpleScriptSourceToObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.txIn.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/toObj/txIn.ts",
      "name": "core.adaptor.toObj.txIn.ts",
      "imports": [
        {
          "module": "txInToObj",
          "items": [],
          "line": 11,
          "raw": "export const txInToObj = (txIn: TxIn): object => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "collateralTxInToObj",
          "items": [],
          "line": 40,
          "raw": "export const collateralTxInToObj = (txIn: TxIn): object => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "txInParameterToObj",
          "items": [],
          "line": 46,
          "raw": "export const txInParameterToObj = (txInParameter: TxInParameter): object => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "scriptTxInParameterToObj",
          "items": [],
          "line": 55,
          "raw": "export const scriptTxInParameterToObj = (",
          "source": "mesh-core-csl"
        },
        {
          "module": "simpleScriptTxInParameterToObj",
          "items": [],
          "line": 94,
          "raw": "export const simpleScriptTxInParameterToObj = (",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "txInToObj",
          "signature": "export const txInToObj = (txIn: TxIn): object => {",
          "documentation": "",
          "parameters": [
            {
              "name": "txIn",
              "type": "TxIn",
              "optional": false
            }
          ],
          "returnType": "object",
          "isPublic": true,
          "line": 11,
          "raw": "export const txInToObj = (txIn: TxIn): object => {\n  switch (txIn.type) {\n    case \"PubKey\":\n      return {\n        pubKeyTxIn: {\n          txIn: txInParameterToObj(txIn.txIn),\n        },\n      };\n\n    case \"Script\":\n      return {\n        scriptTxIn: {\n          txIn: txInParameterToObj(txIn.txIn),\n          scriptTxIn: scriptTxInParameterToObj(txIn.scriptTxIn),\n        },\n      };\n\n    case \"SimpleScript\":\n      return {\n        simpleScriptTxIn: {\n          txIn: txInParameterToObj(txIn.txIn),\n          simpleScriptTxIn: simpleScriptTxInParameterToObj(\n            txIn.simpleScriptTxIn,\n          ),\n        },\n      };\n  }\n};",
          "source": "mesh-core-csl",
          "implementation": "export const txInToObj = (txIn: TxIn): object => {\n  switch (txIn.type) {\n    case \"PubKey\":\n      return {\n        pubKeyTxIn: {\n          txIn: txInParameterToObj(txIn.txIn),\n        },\n      };\n\n    case \"Script\":\n      return {\n        scriptTxIn: {\n          txIn: txInParameterToObj(txIn.txIn),\n          scriptTxIn: scriptTxInParameterToObj(txIn.scriptTxIn),\n        },\n      };\n\n    case \"SimpleScript\":\n      return {\n        simpleScriptTxIn: {\n          txIn: txInParameterToObj(txIn.txIn),\n          simpleScriptTxIn: simpleScriptTxInParameterToObj(\n            txIn.simpleScriptTxIn,\n          ),\n        },\n      };\n  }\n};"
        },
        {
          "name": "collateralTxInToObj",
          "signature": "export const collateralTxInToObj = (txIn: TxIn): object => {",
          "documentation": "",
          "parameters": [
            {
              "name": "txIn",
              "type": "TxIn",
              "optional": false
            }
          ],
          "returnType": "object",
          "isPublic": true,
          "line": 40,
          "raw": "export const collateralTxInToObj = (txIn: TxIn): object => {\n  return {\n    txIn: txInParameterToObj(txIn.txIn),\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const collateralTxInToObj = (txIn: TxIn): object => {\n  return {\n    txIn: txInParameterToObj(txIn.txIn),\n  };\n};"
        },
        {
          "name": "txInParameterToObj",
          "signature": "export const txInParameterToObj = (txInParameter: TxInParameter): object => {",
          "documentation": "",
          "parameters": [
            {
              "name": "txInParameter",
              "type": "TxInParameter",
              "optional": false
            }
          ],
          "returnType": "object",
          "isPublic": true,
          "line": 46,
          "raw": "export const txInParameterToObj = (txInParameter: TxInParameter): object => {\n  return {\n    txHash: txInParameter.txHash,\n    txIndex: txInParameter.txIndex,\n    amount: txInParameter.amount ?? null,\n    address: txInParameter.address ?? null,\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const txInParameterToObj = (txInParameter: TxInParameter): object => {\n  return {\n    txHash: txInParameter.txHash,\n    txIndex: txInParameter.txIndex,\n    amount: txInParameter.amount ?? null,\n    address: txInParameter.address ?? null,\n  };\n};"
        },
        {
          "name": "scriptTxInParameterToObj",
          "signature": "export const scriptTxInParameterToObj = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 55,
          "raw": "export const scriptTxInParameterToObj = (\n  scriptTxInParameter: ScriptTxInParameter,\n): object => {\n  let scriptSource: object | null = null;\n  let datumSource: object | null = null;\n\n  if (scriptTxInParameter.scriptSource) {\n    scriptSource = scriptSourceToObj(scriptTxInParameter.scriptSource);\n  }\n\n  if (scriptTxInParameter.datumSource) {\n    switch (scriptTxInParameter.datumSource.type) {\n      case \"Provided\":\n        datumSource = {\n          providedDatumSource: {\n            data: builderDataToCbor(scriptTxInParameter.datumSource.data),\n          },\n        };\n        break;\n      case \"Inline\":\n        datumSource = {\n          inlineDatumSource: {\n            txHash: scriptTxInParameter.datumSource.txHash,\n            txIndex: scriptTxInParameter.datumSource.txIndex,\n          },\n        };\n        break;\n    }\n  }\n\n  return {\n    scriptSource,\n    datumSource,\n    redeemer: scriptTxInParameter.redeemer\n      ? redeemerToObj(scriptTxInParameter.redeemer)\n      : null,\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const scriptTxInParameterToObj = (\n  scriptTxInParameter: ScriptTxInParameter,\n): object => {\n  let scriptSource: object | null = null;\n  let datumSource: object | null = null;\n\n  if (scriptTxInParameter.scriptSource) {\n    scriptSource = scriptSourceToObj(scriptTxInParameter.scriptSource);\n  }\n\n  if (scriptTxInParameter.datumSource) {\n    switch (scriptTxInParameter.datumSource.type) {\n      case \"Provided\":\n        datumSource = {\n          providedDatumSource: {\n            data: builderDataToCbor(scriptTxInParameter.datumSource.data),\n          },\n        };\n        break;\n      case \"Inline\":\n        datumSource = {\n          inlineDatumSource: {\n            txHash: scriptTxInParameter.datumSource.txHash,\n            txIndex: scriptTxInParameter.datumSource.txIndex,\n          },\n        };\n        break;\n    }\n  }\n\n  return {\n    scriptSource,\n    datumSource,\n    redeemer: scriptTxInParameter.redeemer\n      ? redeemerToObj(scriptTxInParameter.redeemer)\n      : null,\n  };\n};"
        },
        {
          "name": "simpleScriptTxInParameterToObj",
          "signature": "export const simpleScriptTxInParameterToObj = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 94,
          "raw": "export const simpleScriptTxInParameterToObj = (\n  simpleScriptTxInParameter: SimpleScriptTxInParameter,\n) => {\n  if (simpleScriptTxInParameter.scriptSource) {\n    let scriptSource: object | null = null;\n\n    switch (simpleScriptTxInParameter.scriptSource.type) {\n      case \"Inline\":\n        scriptSource = {\n          inlineSimpleScriptSource: {\n            refTxIn: {\n              txHash: simpleScriptTxInParameter.scriptSource.txHash,\n              txIndex: simpleScriptTxInParameter.scriptSource.txIndex,\n            },\n            simpleScriptHash:\n              simpleScriptTxInParameter.scriptSource.simpleScriptHash ?? \"\",\n            scriptSize: BigInt(\n              simpleScriptTxInParameter.scriptSource.scriptSize ?? \"0\",\n            ),\n          },\n        };\n        break;\n      case \"Provided\":\n        scriptSource = {\n          providedSimpleScriptSource: {\n            scriptCbor: simpleScriptTxInParameter.scriptSource.scriptCode,\n          },\n        };\n        break;\n    }\n    return scriptSource;\n  }\n};",
          "source": "mesh-core-csl",
          "implementation": "export const simpleScriptTxInParameterToObj = (\n  simpleScriptTxInParameter: SimpleScriptTxInParameter,\n) => {\n  if (simpleScriptTxInParameter.scriptSource) {\n    let scriptSource: object | null = null;\n\n    switch (simpleScriptTxInParameter.scriptSource.type) {\n      case \"Inline\":\n        scriptSource = {\n          inlineSimpleScriptSource: {\n            refTxIn: {\n              txHash: simpleScriptTxInParameter.scriptSource.txHash,\n              txIndex: simpleScriptTxInParameter.scriptSource.txIndex,\n            },\n            simpleScriptHash:\n              simpleScriptTxInParameter.scriptSource.simpleScriptHash ?? \"\",\n            scriptSize: BigInt(\n              simpleScriptTxInParameter.scriptSource.scriptSize ?? \"0\",\n            ),\n          },\n        };\n        break;\n      case \"Provided\":\n        scriptSource = {\n          providedSimpleScriptSource: {\n            scriptCbor: simpleScriptTxInParameter.scriptSource.scriptCode,\n          },\n        };\n        break;\n    }\n    return scriptSource;\n  }\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "txInToObj",
          "type": "any",
          "value": "(txIn: TxIn): object => {",
          "isPublic": true,
          "line": 11,
          "raw": "export const txInToObj = (txIn: TxIn): object => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "collateralTxInToObj",
          "type": "any",
          "value": "(txIn: TxIn): object => {",
          "isPublic": true,
          "line": 40,
          "raw": "export const collateralTxInToObj = (txIn: TxIn): object => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "txInParameterToObj",
          "type": "any",
          "value": "(txInParameter: TxInParameter): object => {",
          "isPublic": true,
          "line": 46,
          "raw": "export const txInParameterToObj = (txInParameter: TxInParameter): object => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "scriptTxInParameterToObj",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 55,
          "raw": "export const scriptTxInParameterToObj = (",
          "source": "mesh-core-csl"
        },
        {
          "name": "simpleScriptTxInParameterToObj",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 94,
          "raw": "export const simpleScriptTxInParameterToObj = (",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  ScriptTxInParameter,\n  SimpleScriptTxInParameter,\n  TxIn,\n  TxInParameter,\n} from \"@meshsdk/common\";\n\nimport { builderDataToCbor, redeemerToObj } from \"./data\";\nimport { scriptSourceToObj } from \"./script\";\n\nexport const txInToObj = (txIn: TxIn): object => {\n  switch (txIn.type) {\n    case \"PubKey\":\n      return {\n        pubKeyTxIn: {\n          txIn: txInParameterToObj(txIn.txIn),\n        },\n      };\n\n    case \"Script\":\n      return {\n        scriptTxIn: {\n          txIn: txInParameterToObj(txIn.txIn),\n          scriptTxIn: scriptTxInParameterToObj(txIn.scriptTxIn),\n        },\n      };\n\n    case \"SimpleScript\":\n      return {\n        simpleScriptTxIn: {\n          txIn: txInParameterToObj(txIn.txIn),\n          simpleScriptTxIn: simpleScriptTxInParameterToObj(\n            txIn.simpleScriptTxIn,\n          ),\n        },\n      };\n  }\n};\n\nexport const collateralTxInToObj = (txIn: TxIn): object => {\n  return {\n    txIn: txInParameterToObj(txIn.txIn),\n  };\n};\n\nexport const txInParameterToObj = (txInParameter: TxInParameter): object => {\n  return {\n    txHash: txInParameter.txHash,\n    txIndex: txInParameter.txIndex,\n    amount: txInParameter.amount ?? null,\n    address: txInParameter.address ?? null,\n  };\n};\n\nexport const scriptTxInParameterToObj = (\n  scriptTxInParameter: ScriptTxInParameter,\n): object => {\n  let scriptSource: object | null = null;\n  let datumSource: object | null = null;\n\n  if (scriptTxInParameter.scriptSource) {\n    scriptSource = scriptSourceToObj(scriptTxInParameter.scriptSource);\n  }\n\n  if (scriptTxInParameter.datumSource) {\n    switch (scriptTxInParameter.datumSource.type) {\n      case \"Provided\":\n        datumSource = {\n          providedDatumSource: {\n            data: builderDataToCbor(scriptTxInParameter.datumSource.data),\n          },\n        };\n        break;\n      case \"Inline\":\n        datumSource = {\n          inlineDatumSource: {\n            txHash: scriptTxInParameter.datumSource.txHash,\n            txIndex: scriptTxInParameter.datumSource.txIndex,\n          },\n        };\n        break;\n    }\n  }\n\n  return {\n    scriptSource,\n    datumSource,\n    redeemer: scriptTxInParameter.redeemer\n      ? redeemerToObj(scriptTxInParameter.redeemer)\n      : null,\n  };\n};\n\nexport const simpleScriptTxInParameterToObj = (\n  simpleScriptTxInParameter: SimpleScriptTxInParameter,\n) => {\n  if (simpleScriptTxInParameter.scriptSource) {\n    let scriptSource: object | null = null;\n\n    switch (simpleScriptTxInParameter.scriptSource.type) {\n      case \"Inline\":\n        scriptSource = {\n          inlineSimpleScriptSource: {\n            refTxIn: {\n              txHash: simpleScriptTxInParameter.scriptSource.txHash,\n              txIndex: simpleScriptTxInParameter.scriptSource.txIndex,\n            },\n            simpleScriptHash:\n              simpleScriptTxInParameter.scriptSource.simpleScriptHash ?? \"\",\n            scriptSize: BigInt(\n              simpleScriptTxInParameter.scriptSource.scriptSize ?? \"0\",\n            ),\n          },\n        };\n        break;\n      case \"Provided\":\n        scriptSource = {\n          providedSimpleScriptSource: {\n            scriptCbor: simpleScriptTxInParameter.scriptSource.scriptCode,\n          },\n        };\n        break;\n    }\n    return scriptSource;\n  }\n};\n",
      "dependencies": [
        "txInToObj",
        "collateralTxInToObj",
        "txInParameterToObj",
        "scriptTxInParameterToObj",
        "simpleScriptTxInParameterToObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.utxo.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/toObj/utxo.ts",
      "name": "core.adaptor.toObj.utxo.ts",
      "imports": [
        {
          "module": "utxoToObj",
          "items": [],
          "line": 3,
          "raw": "export const utxoToObj = ({",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "utxoToObj",
          "signature": "export const utxoToObj = ({",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 3,
          "raw": "export const utxoToObj = ({\n  input: { outputIndex, txHash },\n  output: { address, amount, dataHash, plutusData, scriptRef, scriptHash },\n}: UTxO): object => {\n  return {\n    input: {\n      outputIndex,\n      txHash,\n    },\n    output: {\n      address,\n      amount,\n      dataHash: dataHash ?? null,\n      plutusData: plutusData ?? null,\n      scriptRef: scriptRef ?? null,\n      scriptHash: scriptHash ?? null,\n    },\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const utxoToObj = ({\n  input: { outputIndex, txHash },\n  output: { address, amount, dataHash, plutusData, scriptRef, scriptHash },\n}: UTxO): object => {\n  return {\n    input: {\n      outputIndex,\n      txHash,\n    },\n    output: {\n      address,\n      amount,\n      dataHash: dataHash ?? null,\n      plutusData: plutusData ?? null,\n      scriptRef: scriptRef ?? null,\n      scriptHash: scriptHash ?? null,\n    },\n  };\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "utxoToObj",
          "type": "any",
          "value": "({",
          "isPublic": true,
          "line": 3,
          "raw": "export const utxoToObj = ({",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { UTxO } from \"@meshsdk/common\";\n\nexport const utxoToObj = ({\n  input: { outputIndex, txHash },\n  output: { address, amount, dataHash, plutusData, scriptRef, scriptHash },\n}: UTxO): object => {\n  return {\n    input: {\n      outputIndex,\n      txHash,\n    },\n    output: {\n      address,\n      amount,\n      dataHash: dataHash ?? null,\n      plutusData: plutusData ?? null,\n      scriptRef: scriptRef ?? null,\n      scriptHash: scriptHash ?? null,\n    },\n  };\n};\n",
      "dependencies": [
        "utxoToObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.vote.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/toObj/vote.ts",
      "name": "core.adaptor.toObj.vote.ts",
      "imports": [
        {
          "module": "voteToObj",
          "items": [],
          "line": 6,
          "raw": "export const voteToObj = (vote: Vote): object => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "voteToObj",
          "signature": "export const voteToObj = (vote: Vote): object => {",
          "documentation": "",
          "parameters": [
            {
              "name": "vote",
              "type": "Vote",
              "optional": false
            }
          ],
          "returnType": "object",
          "isPublic": true,
          "line": 6,
          "raw": "export const voteToObj = (vote: Vote): object => {\r\n  if (vote.type === \"BasicVote\") {\r\n    return {\r\n      basicVote: voteTypeToObj(vote.vote),\r\n    };\r\n  } else if (vote.type === \"ScriptVote\") {\r\n    if (!vote.scriptSource) {\r\n      throw new Error(\"voteToObj: missing scriptSource in plutusScriptVote.\");\r\n    }\r\n    if (!vote.redeemer) {\r\n      throw new Error(\"voteToObj: missing redeemer in plutusScriptVote.\");\r\n    }\r\n\r\n    return {\r\n      scriptVote: {\r\n        vote: voteTypeToObj(vote.vote),\r\n        redeemer: redeemerToObj(vote.redeemer),\r\n        scriptSource: scriptSourceToObj(vote.scriptSource),\r\n      },\r\n    };\r\n  } else {\r\n    if (!vote.simpleScriptSource) {\r\n      throw new Error(\"voteToObj: missing script source in simpleScriptVote\");\r\n    }\r\n\r\n    return {\r\n      simpleScriptVote: {\r\n        vote: voteTypeToObj(vote.vote),\r\n        simpleScriptSource: simpleScriptSourceToObj(vote.simpleScriptSource),\r\n      },\r\n    };\r\n  }\r\n};\r",
          "source": "mesh-core-csl",
          "implementation": "export const voteToObj = (vote: Vote): object => {\r\n  if (vote.type === \"BasicVote\") {\r\n    return {\r\n      basicVote: voteTypeToObj(vote.vote),\r\n    };\r\n  } else if (vote.type === \"ScriptVote\") {\r\n    if (!vote.scriptSource) {\r\n      throw new Error(\"voteToObj: missing scriptSource in plutusScriptVote.\");\r\n    }\r\n    if (!vote.redeemer) {\r\n      throw new Error(\"voteToObj: missing redeemer in plutusScriptVote.\");\r\n    }\r\n\r\n    return {\r\n      scriptVote: {\r\n        vote: voteTypeToObj(vote.vote),\r\n        redeemer: redeemerToObj(vote.redeemer),\r\n        scriptSource: scriptSourceToObj(vote.scriptSource),\r\n      },\r\n    };\r\n  } else {\r\n    if (!vote.simpleScriptSource) {\r\n      throw new Error(\"voteToObj: missing script source in simpleScriptVote\");\r\n    }\r\n\r\n    return {\r\n      simpleScriptVote: {\r\n        vote: voteTypeToObj(vote.vote),\r\n        simpleScriptSource: simpleScriptSourceToObj(vote.simpleScriptSource),\r\n      },\r\n    };\r\n  }\r\n};\r"
        },
        {
          "name": "voteTypeToObj",
          "signature": "const voteTypeToObj = (voteType: VoteType) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "voteType",
              "type": "VoteType",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 40,
          "raw": "const voteTypeToObj = (voteType: VoteType) => {\r\n  let voter = {};\r\n\r\n  switch (voteType.voter.type) {\r\n    case \"ConstitutionalCommittee\": {\r\n      let ccCred = {};\r\n      switch (voteType.voter.hotCred.type) {\r\n        case \"ScriptHash\": {\r\n          ccCred = {\r\n            scriptHash: voteType.voter.hotCred.scriptHash,\r\n          };\r\n          break;\r\n        }\r\n        case \"KeyHash\": {\r\n          ccCred = {\r\n            keyHash: voteType.voter.hotCred.keyHash,\r\n          };\r\n          break;\r\n        }\r\n      }\r\n      voter = {\r\n        constitutionalCommitteeHotCred: ccCred,\r\n      };\r\n      break;\r\n    }\r\n    case \"DRep\": {\r\n      voter = {\r\n        dRepId: voteType.voter.drepId,\r\n      };\r\n      break;\r\n    }\r\n    case \"StakingPool\": {\r\n      voter = {\r\n        stakingPoolKeyHash: voteType.voter.keyHash,\r\n      };\r\n      break;\r\n    }\r\n  }\r\n\r\n  let votingProcedure = {};\r\n  switch (voteType.votingProcedure.voteKind) {\r\n    case \"Yes\": {\r\n      votingProcedure = {\r\n        voteKind: \"yes\",\r\n        anchor: voteType.votingProcedure.anchor ?? null,\r\n      };\r\n      break;\r\n    }\r\n    case \"No\": {\r\n      votingProcedure = {\r\n        voteKind: \"no\",\r\n        anchor: voteType.votingProcedure.anchor ?? null,\r\n      };\r\n      break;\r\n    }\r\n    case \"Abstain\": {\r\n      votingProcedure = {\r\n        voteKind: \"abstain\",\r\n        anchor: voteType.votingProcedure.anchor ?? null,\r\n      };\r\n      break;\r\n    }\r\n  }\r\n\r\n  return {\r\n    voter,\r\n    votingProcedure,\r\n    govActionId: voteType.govActionId,\r\n  };\r\n};\r",
          "source": "mesh-core-csl",
          "implementation": "const voteTypeToObj = (voteType: VoteType) => {\r\n  let voter = {};\r\n\r\n  switch (voteType.voter.type) {\r\n    case \"ConstitutionalCommittee\": {\r\n      let ccCred = {};\r\n      switch (voteType.voter.hotCred.type) {\r\n        case \"ScriptHash\": {\r\n          ccCred = {\r\n            scriptHash: voteType.voter.hotCred.scriptHash,\r\n          };\r\n          break;\r\n        }\r\n        case \"KeyHash\": {\r\n          ccCred = {\r\n            keyHash: voteType.voter.hotCred.keyHash,\r\n          };\r\n          break;\r\n        }\r\n      }\r\n      voter = {\r\n        constitutionalCommitteeHotCred: ccCred,\r\n      };\r\n      break;\r\n    }\r\n    case \"DRep\": {\r\n      voter = {\r\n        dRepId: voteType.voter.drepId,\r\n      };\r\n      break;\r\n    }\r\n    case \"StakingPool\": {\r\n      voter = {\r\n        stakingPoolKeyHash: voteType.voter.keyHash,\r\n      };\r\n      break;\r\n    }\r\n  }\r\n\r\n  let votingProcedure = {};\r\n  switch (voteType.votingProcedure.voteKind) {\r\n    case \"Yes\": {\r\n      votingProcedure = {\r\n        voteKind: \"yes\",\r\n        anchor: voteType.votingProcedure.anchor ?? null,\r\n      };\r\n      break;\r\n    }\r\n    case \"No\": {\r\n      votingProcedure = {\r\n        voteKind: \"no\",\r\n        anchor: voteType.votingProcedure.anchor ?? null,\r\n      };\r\n      break;\r\n    }\r\n    case \"Abstain\": {\r\n      votingProcedure = {\r\n        voteKind: \"abstain\",\r\n        anchor: voteType.votingProcedure.anchor ?? null,\r\n      };\r\n      break;\r\n    }\r\n  }\r\n\r\n  return {\r\n    voter,\r\n    votingProcedure,\r\n    govActionId: voteType.govActionId,\r\n  };\r\n};\r"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "voteToObj",
          "type": "any",
          "value": "(vote: Vote): object => {",
          "isPublic": true,
          "line": 6,
          "raw": "export const voteToObj = (vote: Vote): object => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "voteTypeToObj",
          "type": "any",
          "value": "(voteType: VoteType) => {",
          "isPublic": true,
          "line": 40,
          "raw": "const voteTypeToObj = (voteType: VoteType) => {",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { Vote, VoteType } from \"@meshsdk/common\";\r\n\r\nimport { redeemerToObj } from \"./data\";\r\nimport { scriptSourceToObj, simpleScriptSourceToObj } from \"./script\";\r\n\r\nexport const voteToObj = (vote: Vote): object => {\r\n  if (vote.type === \"BasicVote\") {\r\n    return {\r\n      basicVote: voteTypeToObj(vote.vote),\r\n    };\r\n  } else if (vote.type === \"ScriptVote\") {\r\n    if (!vote.scriptSource) {\r\n      throw new Error(\"voteToObj: missing scriptSource in plutusScriptVote.\");\r\n    }\r\n    if (!vote.redeemer) {\r\n      throw new Error(\"voteToObj: missing redeemer in plutusScriptVote.\");\r\n    }\r\n\r\n    return {\r\n      scriptVote: {\r\n        vote: voteTypeToObj(vote.vote),\r\n        redeemer: redeemerToObj(vote.redeemer),\r\n        scriptSource: scriptSourceToObj(vote.scriptSource),\r\n      },\r\n    };\r\n  } else {\r\n    if (!vote.simpleScriptSource) {\r\n      throw new Error(\"voteToObj: missing script source in simpleScriptVote\");\r\n    }\r\n\r\n    return {\r\n      simpleScriptVote: {\r\n        vote: voteTypeToObj(vote.vote),\r\n        simpleScriptSource: simpleScriptSourceToObj(vote.simpleScriptSource),\r\n      },\r\n    };\r\n  }\r\n};\r\n\r\nconst voteTypeToObj = (voteType: VoteType) => {\r\n  let voter = {};\r\n\r\n  switch (voteType.voter.type) {\r\n    case \"ConstitutionalCommittee\": {\r\n      let ccCred = {};\r\n      switch (voteType.voter.hotCred.type) {\r\n        case \"ScriptHash\": {\r\n          ccCred = {\r\n            scriptHash: voteType.voter.hotCred.scriptHash,\r\n          };\r\n          break;\r\n        }\r\n        case \"KeyHash\": {\r\n          ccCred = {\r\n            keyHash: voteType.voter.hotCred.keyHash,\r\n          };\r\n          break;\r\n        }\r\n      }\r\n      voter = {\r\n        constitutionalCommitteeHotCred: ccCred,\r\n      };\r\n      break;\r\n    }\r\n    case \"DRep\": {\r\n      voter = {\r\n        dRepId: voteType.voter.drepId,\r\n      };\r\n      break;\r\n    }\r\n    case \"StakingPool\": {\r\n      voter = {\r\n        stakingPoolKeyHash: voteType.voter.keyHash,\r\n      };\r\n      break;\r\n    }\r\n  }\r\n\r\n  let votingProcedure = {};\r\n  switch (voteType.votingProcedure.voteKind) {\r\n    case \"Yes\": {\r\n      votingProcedure = {\r\n        voteKind: \"yes\",\r\n        anchor: voteType.votingProcedure.anchor ?? null,\r\n      };\r\n      break;\r\n    }\r\n    case \"No\": {\r\n      votingProcedure = {\r\n        voteKind: \"no\",\r\n        anchor: voteType.votingProcedure.anchor ?? null,\r\n      };\r\n      break;\r\n    }\r\n    case \"Abstain\": {\r\n      votingProcedure = {\r\n        voteKind: \"abstain\",\r\n        anchor: voteType.votingProcedure.anchor ?? null,\r\n      };\r\n      break;\r\n    }\r\n  }\r\n\r\n  return {\r\n    voter,\r\n    votingProcedure,\r\n    govActionId: voteType.govActionId,\r\n  };\r\n};\r\n",
      "dependencies": [
        "voteToObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.withdrawal.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/adaptor/toObj/withdrawal.ts",
      "name": "core.adaptor.toObj.withdrawal.ts",
      "imports": [
        {
          "module": "withdrawalToObj",
          "items": [],
          "line": 6,
          "raw": "export const withdrawalToObj = (withdrawal: Withdrawal): object => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "withdrawalToObj",
          "signature": "export const withdrawalToObj = (withdrawal: Withdrawal): object => {",
          "documentation": "",
          "parameters": [
            {
              "name": "withdrawal",
              "type": "Withdrawal",
              "optional": false
            }
          ],
          "returnType": "object",
          "isPublic": true,
          "line": 6,
          "raw": "export const withdrawalToObj = (withdrawal: Withdrawal): object => {\n  if (withdrawal.type === \"PubKeyWithdrawal\") {\n    return {\n      pubKeyWithdrawal: {\n        address: withdrawal.address,\n        coin: BigInt(withdrawal.coin),\n      },\n    };\n  } else if (withdrawal.type === \"ScriptWithdrawal\") {\n    if (!withdrawal.scriptSource) {\n      throw new Error(\n        \"withdrawalToObj: missing scriptSource in plutusScriptWithdrawal.\",\n      );\n    }\n    if (!withdrawal.redeemer) {\n      throw new Error(\n        \"withdrawalToObj: missing redeemer in plutusScriptWithdrawal.\",\n      );\n    }\n\n    return {\n      plutusScriptWithdrawal: {\n        address: withdrawal.address,\n        coin: BigInt(withdrawal.coin),\n        scriptSource: scriptSourceToObj(withdrawal.scriptSource),\n        redeemer: redeemerToObj(withdrawal.redeemer),\n      },\n    };\n  } else {\n    if (!withdrawal.scriptSource) {\n      throw new Error(\n        \"withdrawalToObj: missing script source in simpleScriptWithdrawal\",\n      );\n    }\n\n    return {\n      simpleScriptWithdrawal: {\n        address: withdrawal.address,\n        coin: BigInt(withdrawal.coin),\n        scriptSource: simpleScriptSourceToObj(withdrawal.scriptSource),\n      },\n    };\n  }\n};",
          "source": "mesh-core-csl",
          "implementation": "export const withdrawalToObj = (withdrawal: Withdrawal): object => {\n  if (withdrawal.type === \"PubKeyWithdrawal\") {\n    return {\n      pubKeyWithdrawal: {\n        address: withdrawal.address,\n        coin: BigInt(withdrawal.coin),\n      },\n    };\n  } else if (withdrawal.type === \"ScriptWithdrawal\") {\n    if (!withdrawal.scriptSource) {\n      throw new Error(\n        \"withdrawalToObj: missing scriptSource in plutusScriptWithdrawal.\",\n      );\n    }\n    if (!withdrawal.redeemer) {\n      throw new Error(\n        \"withdrawalToObj: missing redeemer in plutusScriptWithdrawal.\",\n      );\n    }\n\n    return {\n      plutusScriptWithdrawal: {\n        address: withdrawal.address,\n        coin: BigInt(withdrawal.coin),\n        scriptSource: scriptSourceToObj(withdrawal.scriptSource),\n        redeemer: redeemerToObj(withdrawal.redeemer),\n      },\n    };\n  } else {\n    if (!withdrawal.scriptSource) {\n      throw new Error(\n        \"withdrawalToObj: missing script source in simpleScriptWithdrawal\",\n      );\n    }\n\n    return {\n      simpleScriptWithdrawal: {\n        address: withdrawal.address,\n        coin: BigInt(withdrawal.coin),\n        scriptSource: simpleScriptSourceToObj(withdrawal.scriptSource),\n      },\n    };\n  }\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "withdrawalToObj",
          "type": "any",
          "value": "(withdrawal: Withdrawal): object => {",
          "isPublic": true,
          "line": 6,
          "raw": "export const withdrawalToObj = (withdrawal: Withdrawal): object => {",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { Withdrawal } from \"@meshsdk/common\";\n\nimport { redeemerToObj } from \"./data\";\nimport { scriptSourceToObj, simpleScriptSourceToObj } from \"./script\";\n\nexport const withdrawalToObj = (withdrawal: Withdrawal): object => {\n  if (withdrawal.type === \"PubKeyWithdrawal\") {\n    return {\n      pubKeyWithdrawal: {\n        address: withdrawal.address,\n        coin: BigInt(withdrawal.coin),\n      },\n    };\n  } else if (withdrawal.type === \"ScriptWithdrawal\") {\n    if (!withdrawal.scriptSource) {\n      throw new Error(\n        \"withdrawalToObj: missing scriptSource in plutusScriptWithdrawal.\",\n      );\n    }\n    if (!withdrawal.redeemer) {\n      throw new Error(\n        \"withdrawalToObj: missing redeemer in plutusScriptWithdrawal.\",\n      );\n    }\n\n    return {\n      plutusScriptWithdrawal: {\n        address: withdrawal.address,\n        coin: BigInt(withdrawal.coin),\n        scriptSource: scriptSourceToObj(withdrawal.scriptSource),\n        redeemer: redeemerToObj(withdrawal.redeemer),\n      },\n    };\n  } else {\n    if (!withdrawal.scriptSource) {\n      throw new Error(\n        \"withdrawalToObj: missing script source in simpleScriptWithdrawal\",\n      );\n    }\n\n    return {\n      simpleScriptWithdrawal: {\n        address: withdrawal.address,\n        coin: BigInt(withdrawal.coin),\n        scriptSource: simpleScriptSourceToObj(withdrawal.scriptSource),\n      },\n    };\n  }\n};\n",
      "dependencies": [
        "withdrawalToObj"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/index.ts",
      "name": "core.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./serializer\";\nexport * from \"./adaptor\";\n",
      "dependencies": [],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:core.serializer.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/core/serializer.ts",
      "name": "core.serializer.ts",
      "imports": [
        {
          "module": "CSLSerializer",
          "items": [],
          "line": 60,
          "raw": "export class CSLSerializer implements IMeshTxSerializer {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "addSigningKeys",
          "signature": "addSigningKeys(txHex: string, signingKeys: string[]): string {",
          "documentation": "",
          "parameters": [
            {
              "name": "txHex",
              "type": "string",
              "optional": false
            },
            {
              "name": "signingKeys",
              "type": "string[]",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 88,
          "raw": "  addSigningKeys(txHex: string, signingKeys: string[]): string {\n    if (signingKeys.length > 0) {\n      return signTransaction(txHex, signingKeys);\n    }\n    return txHex;\n  }",
          "source": "mesh-core-csl",
          "implementation": "  addSigningKeys(txHex: string, signingKeys: string[]): string {\n    if (signingKeys.length > 0) {\n      return signTransaction(txHex, signingKeys);\n    }\n    return txHex;\n  }"
        },
        {
          "name": "serializeData",
          "signature": "serializeData(data: BuilderData): string {",
          "documentation": "",
          "parameters": [
            {
              "name": "data",
              "type": "BuilderData",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 95,
          "raw": "  serializeData(data: BuilderData): string {\n    return builderDataToCbor(data);\n  }",
          "source": "mesh-core-csl",
          "implementation": "  serializeData(data: BuilderData): string {\n    return builderDataToCbor(data);\n  }"
        },
        {
          "name": "serializePoolId",
          "signature": "serializePoolId(hash: string): string {",
          "documentation": "",
          "parameters": [
            {
              "name": "hash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 106,
          "raw": "  serializePoolId(hash: string): string {\n    return serializePoolId(hash);\n  }",
          "source": "mesh-core-csl",
          "implementation": "  serializePoolId(hash: string): string {\n    return serializePoolId(hash);\n  }"
        },
        {
          "name": "serializeOutput",
          "signature": "serializeOutput(output: Output): string {",
          "documentation": "",
          "parameters": [
            {
              "name": "output",
              "type": "Output",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 192,
          "raw": "  serializeOutput(output: Output): string {\n    let cslOutputBuilder = csl.TransactionOutputBuilder.new().with_address(\n      csl.Address.from_bech32(output.address),\n    );\n    if (output.datum?.type === \"Hash\") {\n      cslOutputBuilder.with_data_hash(\n        csl.hash_plutus_data(castDataToPlutusData(output.datum.data)),\n      );\n    } else if (output.datum?.type === \"Inline\") {\n      cslOutputBuilder.with_plutus_data(\n        castDataToPlutusData(output.datum.data),\n      );\n    } else if (output.datum?.type === \"Embedded\") {\n      throw new Error(\"Embedded datum not supported\");\n    }\n    if (output.referenceScript) {\n      switch (output.referenceScript.version) {\n        case \"V1\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v1(),\n              ),\n            ),\n          );\n          break;\n        }\n        case \"V2\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v2(),\n              ),\n            ),\n          );\n          break;\n        }\n        case \"V3\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v3(),\n              ),\n            ),\n          );\n          break;\n        }\n        default: {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_native_script(\n              csl.NativeScript.from_hex(output.referenceScript.code),\n            ),\n          );\n          break;\n        }\n      }\n    }\n\n    return cslOutputBuilder\n      .next()\n      .with_value(toCslValue(output.amount))\n      .build()\n      .to_hex();\n  }",
          "source": "mesh-core-csl",
          "implementation": "  serializeOutput(output: Output): string {\n    let cslOutputBuilder = csl.TransactionOutputBuilder.new().with_address(\n      csl.Address.from_bech32(output.address),\n    );\n    if (output.datum?.type === \"Hash\") {\n      cslOutputBuilder.with_data_hash(\n        csl.hash_plutus_data(castDataToPlutusData(output.datum.data)),\n      );\n    } else if (output.datum?.type === \"Inline\") {\n      cslOutputBuilder.with_plutus_data(\n        castDataToPlutusData(output.datum.data),\n      );\n    } else if (output.datum?.type === \"Embedded\") {\n      throw new Error(\"Embedded datum not supported\");\n    }\n    if (output.referenceScript) {\n      switch (output.referenceScript.version) {\n        case \"V1\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v1(),\n              ),\n            ),\n          );\n          break;\n        }\n        case \"V2\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v2(),\n              ),\n            ),\n          );\n          break;\n        }\n        case \"V3\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v3(),\n              ),\n            ),\n          );\n          break;\n        }\n        default: {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_native_script(\n              csl.NativeScript.from_hex(output.referenceScript.code),\n            ),\n          );\n          break;\n        }\n      }\n    }\n\n    return cslOutputBuilder\n      .next()\n      .with_value(toCslValue(output.amount))\n      .build()\n      .to_hex();\n  }"
        },
        {
          "name": "serializeValue",
          "signature": "serializeValue(value: Asset[]): string {",
          "documentation": "",
          "parameters": [
            {
              "name": "value",
              "type": "Asset[]",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 308,
          "raw": "  serializeValue(value: Asset[]): string {\n    return toCslValue(value).to_hex();\n  }",
          "source": "mesh-core-csl",
          "implementation": "  serializeValue(value: Asset[]): string {\n    return toCslValue(value).to_hex();\n  }"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "VKEY_PUBKEY_SIZE_BYTES",
          "type": "any",
          "value": "32;",
          "isPublic": true,
          "line": 56,
          "raw": "const VKEY_PUBKEY_SIZE_BYTES = 32;",
          "source": "mesh-core-csl"
        },
        {
          "name": "VKEY_SIGNATURE_SIZE_BYTES",
          "type": "any",
          "value": "64;",
          "isPublic": true,
          "line": 57,
          "raw": "const VKEY_SIGNATURE_SIZE_BYTES = 64;",
          "source": "mesh-core-csl"
        },
        {
          "name": "CHAIN_CODE_SIZE_BYTES",
          "type": "any",
          "value": "32;",
          "isPublic": true,
          "line": 58,
          "raw": "const CHAIN_CODE_SIZE_BYTES = 32;",
          "source": "mesh-core-csl"
        },
        {
          "name": "txBodyJson",
          "type": "any",
          "value": "JSONbig.stringify(meshTxBuilderBodyToObj(txBody));",
          "isPublic": true,
          "line": 78,
          "raw": "const txBodyJson = JSONbig.stringify(meshTxBuilderBodyToObj(txBody));",
          "source": "mesh-core-csl"
        },
        {
          "name": "params",
          "type": "any",
          "value": "JSONbig.stringify(protocolParams || this.protocolParams);",
          "isPublic": true,
          "line": 79,
          "raw": "const params = JSONbig.stringify(protocolParams || this.protocolParams);",
          "source": "mesh-core-csl"
        },
        {
          "name": "txBuildResult",
          "type": "any",
          "value": "csl.js_serialize_tx_body(txBodyJson, params);",
          "isPublic": true,
          "line": 81,
          "raw": "const txBuildResult = csl.js_serialize_tx_body(txBodyJson, params);",
          "source": "mesh-core-csl"
        },
        {
          "name": "nativeScript",
          "type": "any",
          "value": "toNativeScript(script);",
          "isPublic": true,
          "line": 130,
          "raw": "const nativeScript = toNativeScript(script);",
          "source": "mesh-core-csl"
        },
        {
          "name": "scriptCbor",
          "type": "any",
          "value": "nativeScript.to_hex();",
          "isPublic": true,
          "line": 131,
          "raw": "const scriptCbor = nativeScript.to_hex();",
          "source": "mesh-core-csl"
        },
        {
          "name": "scriptHash",
          "type": "any",
          "value": "nativeScript.hash().to_hex();",
          "isPublic": true,
          "line": 132,
          "raw": "const scriptHash = nativeScript.hash().to_hex();",
          "source": "mesh-core-csl"
        },
        {
          "name": "scriptHash",
          "type": "any",
          "value": "deserializePlutusScript(script.code, script.version)",
          "isPublic": true,
          "line": 141,
          "raw": "const scriptHash = deserializePlutusScript(script.code, script.version)",
          "source": "mesh-core-csl"
        },
        {
          "name": "txHex",
          "type": "any",
          "value": "this.serializeTxBody(txBuilderBody, protocolParams);",
          "isPublic": true,
          "line": 264,
          "raw": "const txHex = this.serializeTxBody(txBuilderBody, protocolParams);",
          "source": "mesh-core-csl"
        },
        {
          "name": "cslTx",
          "type": "any",
          "value": "csl.Transaction.from_hex(txHex);",
          "isPublic": true,
          "line": 265,
          "raw": "const cslTx = csl.Transaction.from_hex(txHex);",
          "source": "mesh-core-csl"
        },
        {
          "name": "mockWitnessSet",
          "type": "any",
          "value": "cslTx.witness_set();",
          "isPublic": true,
          "line": 266,
          "raw": "const mockWitnessSet = cslTx.witness_set();",
          "source": "mesh-core-csl"
        },
        {
          "name": "mockVkeyWitnesses",
          "type": "any",
          "value": "mockWitnessSet.vkeys() ?? csl.Vkeywitnesses.new();",
          "isPublic": true,
          "line": 267,
          "raw": "const mockVkeyWitnesses = mockWitnessSet.vkeys() ?? csl.Vkeywitnesses.new();",
          "source": "mesh-core-csl"
        },
        {
          "name": "numberInHex",
          "type": "any",
          "value": "this.numberToIntegerHex(i);",
          "isPublic": true,
          "line": 271,
          "raw": "const numberInHex = this.numberToIntegerHex(i);",
          "source": "mesh-core-csl"
        },
        {
          "name": "mockVkey",
          "type": "any",
          "value": "csl.Vkey.new(",
          "isPublic": true,
          "line": 272,
          "raw": "const mockVkey = csl.Vkey.new(",
          "source": "mesh-core-csl"
        },
        {
          "name": "mockSignature",
          "type": "any",
          "value": "csl.Ed25519Signature.from_hex(",
          "isPublic": true,
          "line": 276,
          "raw": "const mockSignature = csl.Ed25519Signature.from_hex(",
          "source": "mesh-core-csl"
        },
        {
          "name": "address",
          "type": "any",
          "value": "csl.ByronAddress.from_base58(bootstrapWitness);",
          "isPublic": true,
          "line": 283,
          "raw": "const address = csl.ByronAddress.from_base58(bootstrapWitness);",
          "source": "mesh-core-csl"
        },
        {
          "name": "numberInHex",
          "type": "any",
          "value": "this.numberToIntegerHex(i);",
          "isPublic": true,
          "line": 284,
          "raw": "const numberInHex = this.numberToIntegerHex(i);",
          "source": "mesh-core-csl"
        },
        {
          "name": "pubKeyHex",
          "type": "any",
          "value": "this.mockPubkey(numberInHex);",
          "isPublic": true,
          "line": 285,
          "raw": "const pubKeyHex = this.mockPubkey(numberInHex);",
          "source": "mesh-core-csl"
        },
        {
          "name": "mockVkey",
          "type": "any",
          "value": "csl.Vkey.new(csl.PublicKey.from_hex(pubKeyHex));",
          "isPublic": true,
          "line": 286,
          "raw": "const mockVkey = csl.Vkey.new(csl.PublicKey.from_hex(pubKeyHex));",
          "source": "mesh-core-csl"
        },
        {
          "name": "signature",
          "type": "any",
          "value": "this.mockSignature(numberInHex);",
          "isPublic": true,
          "line": 287,
          "raw": "const signature = this.mockSignature(numberInHex);",
          "source": "mesh-core-csl"
        },
        {
          "name": "chainCode",
          "type": "any",
          "value": "this.mockChainCode(numberInHex);",
          "isPublic": true,
          "line": 288,
          "raw": "const chainCode = this.mockChainCode(numberInHex);",
          "source": "mesh-core-csl"
        },
        {
          "name": "parser",
          "type": "any",
          "value": "new CSLParser(txHex, resolvedUtxos);",
          "isPublic": true,
          "line": 317,
          "raw": "const parser = new CSLParser(txHex, resolvedUtxos);",
          "source": "mesh-core-csl"
        },
        {
          "name": "txBuilderBody",
          "type": "any",
          "value": "{ ...this.parserTxBody };",
          "isPublic": true,
          "line": 327,
          "raw": "const txBuilderBody = { ...this.parserTxBody };",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "/* eslint-disable default-case */\n/* eslint-disable class-methods-use-this */\n/* eslint-disable radix */\nimport { js_parse_tx_body } from \"@sidan-lab/whisky-js-nodejs\";\nimport JSONbig from \"json-bigint\";\n\nimport {\n  Asset,\n  BuilderData,\n  DEFAULT_PROTOCOL_PARAMETERS,\n  DeserializedAddress,\n  DeserializedScript,\n  emptyTxBuilderBody,\n  IDeserializer,\n  IMeshTxSerializer,\n  IResolver,\n  ITxParser,\n  MeshTxBuilderBody,\n  NativeScript,\n  Output,\n  PlutusDataType,\n  PlutusScript,\n  Protocol,\n  TxInput,\n  TxTester,\n  UTxO,\n} from \"@meshsdk/common\";\n\nimport {\n  castDataToPlutusData,\n  csl,\n  deserializePlutusScript,\n  resolveDataHash,\n  resolveEd25519KeyHash,\n  resolvePrivateKey,\n  resolveRewardAddress,\n  resolveScriptRef,\n  serializePoolId,\n  toCslValue,\n  toNativeScript,\n} from \"../deser\";\nimport { CSLParser } from \"../parser\";\nimport {\n  calculateTxHash,\n  deserializeBech32Address,\n  getRequiredInputs,\n  keyHashToRewardAddress,\n  rewardAddressToKeyHash,\n  scriptHashToRewardAddress,\n  serialzeAddress,\n  signTransaction,\n} from \"../utils\";\nimport { meshTxBuilderBodyToObj, txBuilderBodyFromObj } from \"./adaptor\";\nimport { builderDataToCbor } from \"./adaptor/toObj/data\";\n\nconst VKEY_PUBKEY_SIZE_BYTES = 32;\nconst VKEY_SIGNATURE_SIZE_BYTES = 64;\nconst CHAIN_CODE_SIZE_BYTES = 32;\n\nexport class CSLSerializer implements IMeshTxSerializer {\n  /**\n   * Set to true to enable verbose logging for the txBodyJson prior going into build\n   */\n  protocolParams: Protocol;\n\n  meshTxBuilderBody: MeshTxBuilderBody = emptyTxBuilderBody();\n\n  parserTxBody: MeshTxBuilderBody = emptyTxBuilderBody();\n\n  constructor(protocolParams?: Protocol) {\n    this.protocolParams = protocolParams || DEFAULT_PROTOCOL_PARAMETERS;\n  }\n\n  serializeTxBody(\n    txBody: MeshTxBuilderBody,\n    protocolParams?: Protocol,\n  ): string {\n    const txBodyJson = JSONbig.stringify(meshTxBuilderBodyToObj(txBody));\n    const params = JSONbig.stringify(protocolParams || this.protocolParams);\n\n    const txBuildResult = csl.js_serialize_tx_body(txBodyJson, params);\n    if (txBuildResult.get_status() !== \"success\") {\n      throw new Error(`txBuildResult error: ${txBuildResult.get_error()}`);\n    }\n    return txBuildResult.get_data();\n  }\n\n  addSigningKeys(txHex: string, signingKeys: string[]): string {\n    if (signingKeys.length > 0) {\n      return signTransaction(txHex, signingKeys);\n    }\n    return txHex;\n  }\n\n  serializeData(data: BuilderData): string {\n    return builderDataToCbor(data);\n  }\n\n  serializeAddress(\n    address: Partial<DeserializedAddress>,\n    networkId?: number,\n  ): string {\n    return serialzeAddress(address, networkId);\n  }\n\n  serializePoolId(hash: string): string {\n    return serializePoolId(hash);\n  }\n\n  serializeRewardAddress(\n    stakeKeyHash: string,\n    isScriptHash?: boolean,\n    network_id?: 0 | 1,\n  ): string {\n    return isScriptHash\n      ? scriptHashToRewardAddress(stakeKeyHash, network_id)\n      : keyHashToRewardAddress(stakeKeyHash, network_id);\n  }\n\n  deserializer: IDeserializer = {\n    key: {\n      deserializeAddress: function (bech32: string): DeserializedAddress {\n        return deserializeBech32Address(bech32);\n      },\n    },\n    script: {\n      deserializeNativeScript: function (\n        script: NativeScript,\n      ): DeserializedScript {\n        const nativeScript = toNativeScript(script);\n        const scriptCbor = nativeScript.to_hex();\n        const scriptHash = nativeScript.hash().to_hex();\n        return {\n          scriptHash,\n          scriptCbor,\n        };\n      },\n      deserializePlutusScript: function (\n        script: PlutusScript,\n      ): DeserializedScript {\n        const scriptHash = deserializePlutusScript(script.code, script.version)\n          .hash()\n          .to_hex();\n        return { scriptHash, scriptCbor: script.code };\n      },\n    },\n    cert: {\n      deserializePoolId: function (poolId: string): string {\n        return resolveEd25519KeyHash(poolId);\n      },\n    },\n  };\n\n  resolver: IResolver = {\n    keys: {\n      resolveStakeKeyHash: function (bech32: string): string {\n        return (\n          rewardAddressToKeyHash(bech32) ||\n          deserializeBech32Address(bech32).stakeCredentialHash\n        );\n      },\n      resolvePrivateKey: function (words: string[]): string {\n        return resolvePrivateKey(words);\n      },\n      resolveRewardAddress: function (bech32: string): string {\n        return resolveRewardAddress(bech32);\n      },\n      resolveEd25519KeyHash: function (bech32: string): string {\n        return resolveEd25519KeyHash(bech32);\n      },\n    },\n    tx: {\n      resolveTxHash: function (txHex: string): string {\n        return calculateTxHash(txHex);\n      },\n    },\n    data: {\n      resolveDataHash: function (\n        rawData: BuilderData[\"content\"],\n        type: PlutusDataType = \"Mesh\",\n      ): string {\n        return resolveDataHash(rawData, type);\n      },\n    },\n    script: {\n      resolveScriptRef: function (script: PlutusScript | NativeScript): string {\n        return resolveScriptRef(script);\n      },\n    },\n  };\n\n  serializeOutput(output: Output): string {\n    let cslOutputBuilder = csl.TransactionOutputBuilder.new().with_address(\n      csl.Address.from_bech32(output.address),\n    );\n    if (output.datum?.type === \"Hash\") {\n      cslOutputBuilder.with_data_hash(\n        csl.hash_plutus_data(castDataToPlutusData(output.datum.data)),\n      );\n    } else if (output.datum?.type === \"Inline\") {\n      cslOutputBuilder.with_plutus_data(\n        castDataToPlutusData(output.datum.data),\n      );\n    } else if (output.datum?.type === \"Embedded\") {\n      throw new Error(\"Embedded datum not supported\");\n    }\n    if (output.referenceScript) {\n      switch (output.referenceScript.version) {\n        case \"V1\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v1(),\n              ),\n            ),\n          );\n          break;\n        }\n        case \"V2\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v2(),\n              ),\n            ),\n          );\n          break;\n        }\n        case \"V3\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v3(),\n              ),\n            ),\n          );\n          break;\n        }\n        default: {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_native_script(\n              csl.NativeScript.from_hex(output.referenceScript.code),\n            ),\n          );\n          break;\n        }\n      }\n    }\n\n    return cslOutputBuilder\n      .next()\n      .with_value(toCslValue(output.amount))\n      .build()\n      .to_hex();\n  }\n\n  serializeTxBodyWithMockSignatures(\n    txBuilderBody: MeshTxBuilderBody,\n    protocolParams: Protocol,\n  ): string {\n    const txHex = this.serializeTxBody(txBuilderBody, protocolParams);\n    const cslTx = csl.Transaction.from_hex(txHex);\n    const mockWitnessSet = cslTx.witness_set();\n    const mockVkeyWitnesses = mockWitnessSet.vkeys() ?? csl.Vkeywitnesses.new();\n    const mockBootstrapWitnesses =\n      mockWitnessSet.bootstraps() ?? csl.BootstrapWitnesses.new();\n    for (let i = 0; i < txBuilderBody.expectedNumberKeyWitnesses; i++) {\n      const numberInHex = this.numberToIntegerHex(i);\n      const mockVkey = csl.Vkey.new(\n        csl.PublicKey.from_hex(this.mockPubkey(numberInHex)),\n      );\n\n      const mockSignature = csl.Ed25519Signature.from_hex(\n        this.mockSignature(numberInHex),\n      );\n      mockVkeyWitnesses.add(csl.Vkeywitness.new(mockVkey, mockSignature));\n    }\n    this.meshTxBuilderBody.expectedByronAddressWitnesses.forEach(\n      (bootstrapWitness, i) => {\n        const address = csl.ByronAddress.from_base58(bootstrapWitness);\n        const numberInHex = this.numberToIntegerHex(i);\n        const pubKeyHex = this.mockPubkey(numberInHex);\n        const mockVkey = csl.Vkey.new(csl.PublicKey.from_hex(pubKeyHex));\n        const signature = this.mockSignature(numberInHex);\n        const chainCode = this.mockChainCode(numberInHex);\n        mockBootstrapWitnesses.add(\n          csl.BootstrapWitness.new(\n            mockVkey,\n            csl.Ed25519Signature.from_hex(signature),\n            Buffer.from(chainCode, \"hex\"),\n            address.attributes(),\n          ),\n        );\n      },\n    );\n    mockWitnessSet.set_vkeys(mockVkeyWitnesses);\n    mockWitnessSet.set_bootstraps(mockBootstrapWitnesses);\n    return csl.Transaction.new(\n      cslTx.body(),\n      mockWitnessSet,\n      cslTx.auxiliary_data(),\n    ).to_hex();\n  }\n\n  serializeValue(value: Asset[]): string {\n    return toCslValue(value).to_hex();\n  }\n\n  parser: ITxParser = {\n    getRequiredInputs: function (txHex: string): TxInput[] {\n      return getRequiredInputs(txHex);\n    },\n    parse: (txHex: string, resolvedUtxos: UTxO[] = []) => {\n      const parser = new CSLParser(txHex, resolvedUtxos);\n      this.parserTxBody = parser.txBuilderBody;\n    },\n    toTester: () => {\n      return new TxTester(this.parserTxBody);\n    },\n    getBuilderBody: () => {\n      return this.parserTxBody;\n    },\n    getBuilderBodyWithoutChange: () => {\n      const txBuilderBody = { ...this.parserTxBody };\n      txBuilderBody.outputs = txBuilderBody.outputs.slice(0, -1);\n      return txBuilderBody;\n    },\n  };\n\n  private mockPubkey(numberInHex: string): string {\n    return \"0\"\n      .repeat(VKEY_PUBKEY_SIZE_BYTES * 2 - numberInHex.length)\n      .concat(numberInHex);\n  }\n\n  private mockSignature(numberInHex: string): string {\n    return \"0\"\n      .repeat(VKEY_SIGNATURE_SIZE_BYTES * 2 - numberInHex.length)\n      .concat(numberInHex);\n  }\n\n  private mockChainCode = (numberInHex: string): string => {\n    return \"0\"\n      .repeat(CHAIN_CODE_SIZE_BYTES * 2 - numberInHex.length)\n      .concat(numberInHex);\n  };\n\n  private numberToIntegerHex = (number: number): string => {\n    return BigInt(number).toString(16);\n  };\n}\n",
      "dependencies": [
        "CSLSerializer"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:deser.constants.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/deser/constants.ts",
      "name": "deser.constants.ts",
      "imports": [
        {
          "module": "LANGUAGE_VERSIONS",
          "items": [],
          "line": 3,
          "raw": "export const LANGUAGE_VERSIONS = {",
          "source": "mesh-core-csl"
        },
        {
          "module": "REDEEMER_TAGS",
          "items": [],
          "line": 9,
          "raw": "export const REDEEMER_TAGS = {",
          "source": "mesh-core-csl"
        },
        {
          "module": "POLICY_ID_LENGTH",
          "items": [],
          "line": 16,
          "raw": "export const POLICY_ID_LENGTH = 56;",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [],
      "types": [],
      "constants": [
        {
          "name": "LANGUAGE_VERSIONS",
          "type": "any",
          "value": "{",
          "isPublic": true,
          "line": 3,
          "raw": "export const LANGUAGE_VERSIONS = {",
          "source": "mesh-core-csl"
        },
        {
          "name": "REDEEMER_TAGS",
          "type": "any",
          "value": "{",
          "isPublic": true,
          "line": 9,
          "raw": "export const REDEEMER_TAGS = {",
          "source": "mesh-core-csl"
        },
        {
          "name": "POLICY_ID_LENGTH",
          "type": "any",
          "value": "56;",
          "isPublic": true,
          "line": 16,
          "raw": "export const POLICY_ID_LENGTH = 56;",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { csl } from \"./csl\";\n\nexport const LANGUAGE_VERSIONS = {\n  V1: csl.Language.new_plutus_v1(),\n  V2: csl.Language.new_plutus_v2(),\n  V3: csl.Language.new_plutus_v3(),\n};\n\nexport const REDEEMER_TAGS = {\n  CERT: csl.RedeemerTag.new_cert(),\n  MINT: csl.RedeemerTag.new_mint(),\n  REWARD: csl.RedeemerTag.new_reward(),\n  SPEND: csl.RedeemerTag.new_spend(),\n};\n\nexport const POLICY_ID_LENGTH = 56;\n",
      "dependencies": [
        "LANGUAGE_VERSIONS",
        "REDEEMER_TAGS",
        "POLICY_ID_LENGTH"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:deser.converter.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/deser/converter.ts",
      "name": "deser.converter.ts",
      "imports": [
        {
          "module": "toAddress",
          "items": [],
          "line": 23,
          "raw": "export const toAddress = (bech32: string) => csl.Address.from_bech32(bech32);",
          "source": "mesh-core-csl"
        },
        {
          "module": "toBaseAddress",
          "items": [],
          "line": 25,
          "raw": "export const toBaseAddress = (bech32: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "module": "toEnterpriseAddress",
          "items": [],
          "line": 28,
          "raw": "export const toEnterpriseAddress = (bech32: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "module": "toRewardAddress",
          "items": [],
          "line": 31,
          "raw": "export const toRewardAddress = (bech32: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "module": "fromBytes",
          "items": [],
          "line": 36,
          "raw": "export const fromBytes = (bytes: Uint8Array) =>",
          "source": "mesh-core-csl"
        },
        {
          "module": "toBytes",
          "items": [],
          "line": 39,
          "raw": "export const toBytes = (hex: string): Uint8Array => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "fromUTF8",
          "items": [],
          "line": 48,
          "raw": "export const fromUTF8 = (utf8: string) => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "toUTF8",
          "items": [],
          "line": 54,
          "raw": "export const toUTF8 = (hex: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "module": "fromLovelace",
          "items": [],
          "line": 59,
          "raw": "export const fromLovelace = (lovelace: number) => lovelace / 1_000_000;",
          "source": "mesh-core-csl"
        },
        {
          "module": "toLovelace",
          "items": [],
          "line": 61,
          "raw": "export const toLovelace = (ada: number) => ada * 1_000_000;",
          "source": "mesh-core-csl"
        },
        {
          "module": "toScriptRef",
          "items": [],
          "line": 148,
          "raw": "export const toScriptRef = (script: PlutusScript | NativeScript) => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "toPlutusData",
          "items": [],
          "line": 160,
          "raw": "export const toPlutusData = (data: Data): csl.PlutusData => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "castRawDataToJsonString",
          "items": [],
          "line": 200,
          "raw": "export const castRawDataToJsonString = (rawData: object | string) => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "castDataToPlutusData",
          "items": [],
          "line": 207,
          "raw": "export const castDataToPlutusData = ({",
          "source": "mesh-core-csl"
        },
        {
          "module": "toNativeScript",
          "items": [],
          "line": 223,
          "raw": "export const toNativeScript = (script: NativeScript) => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "toCslValue",
          "items": [],
          "line": 262,
          "raw": "export const toCslValue = (assets: Asset[]): csl.Value => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "toAddress",
          "signature": "export const toAddress = (bech32: string) => csl.Address.from_bech32(bech32);",
          "documentation": "",
          "parameters": [
            {
              "name": "bech32",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 23,
          "raw": "export const toAddress = (bech32: string) => csl.Address.from_bech32(bech32);\n\nexport const toBaseAddress = (bech32: string) =>\n  csl.BaseAddress.from_address(toAddress(bech32));\n\nexport const toEnterpriseAddress = (bech32: string) =>\n  csl.EnterpriseAddress.from_address(toAddress(bech32));\n\nexport const toRewardAddress = (bech32: string) =>\n  csl.RewardAddress.from_address(toAddress(bech32));\n\n/* -----------------[ Bytes ]----------------- */\n\nexport const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};",
          "source": "mesh-core-csl",
          "implementation": "export const toAddress = (bech32: string) => csl.Address.from_bech32(bech32);\n\nexport const toBaseAddress = (bech32: string) =>\n  csl.BaseAddress.from_address(toAddress(bech32));\n\nexport const toEnterpriseAddress = (bech32: string) =>\n  csl.EnterpriseAddress.from_address(toAddress(bech32));\n\nexport const toRewardAddress = (bech32: string) =>\n  csl.RewardAddress.from_address(toAddress(bech32));\n\n/* -----------------[ Bytes ]----------------- */\n\nexport const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};"
        },
        {
          "name": "toBaseAddress",
          "signature": "export const toBaseAddress = (bech32: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "bech32",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 25,
          "raw": "export const toBaseAddress = (bech32: string) =>\n  csl.BaseAddress.from_address(toAddress(bech32));\n\nexport const toEnterpriseAddress = (bech32: string) =>\n  csl.EnterpriseAddress.from_address(toAddress(bech32));\n\nexport const toRewardAddress = (bech32: string) =>\n  csl.RewardAddress.from_address(toAddress(bech32));\n\n/* -----------------[ Bytes ]----------------- */\n\nexport const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};",
          "source": "mesh-core-csl",
          "implementation": "export const toBaseAddress = (bech32: string) =>\n  csl.BaseAddress.from_address(toAddress(bech32));\n\nexport const toEnterpriseAddress = (bech32: string) =>\n  csl.EnterpriseAddress.from_address(toAddress(bech32));\n\nexport const toRewardAddress = (bech32: string) =>\n  csl.RewardAddress.from_address(toAddress(bech32));\n\n/* -----------------[ Bytes ]----------------- */\n\nexport const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};"
        },
        {
          "name": "toEnterpriseAddress",
          "signature": "export const toEnterpriseAddress = (bech32: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "bech32",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 28,
          "raw": "export const toEnterpriseAddress = (bech32: string) =>\n  csl.EnterpriseAddress.from_address(toAddress(bech32));\n\nexport const toRewardAddress = (bech32: string) =>\n  csl.RewardAddress.from_address(toAddress(bech32));\n\n/* -----------------[ Bytes ]----------------- */\n\nexport const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};",
          "source": "mesh-core-csl",
          "implementation": "export const toEnterpriseAddress = (bech32: string) =>\n  csl.EnterpriseAddress.from_address(toAddress(bech32));\n\nexport const toRewardAddress = (bech32: string) =>\n  csl.RewardAddress.from_address(toAddress(bech32));\n\n/* -----------------[ Bytes ]----------------- */\n\nexport const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};"
        },
        {
          "name": "toRewardAddress",
          "signature": "export const toRewardAddress = (bech32: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "bech32",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 31,
          "raw": "export const toRewardAddress = (bech32: string) =>\n  csl.RewardAddress.from_address(toAddress(bech32));\n\n/* -----------------[ Bytes ]----------------- */\n\nexport const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};",
          "source": "mesh-core-csl",
          "implementation": "export const toRewardAddress = (bech32: string) =>\n  csl.RewardAddress.from_address(toAddress(bech32));\n\n/* -----------------[ Bytes ]----------------- */\n\nexport const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};"
        },
        {
          "name": "fromBytes",
          "signature": "export const fromBytes = (bytes: Uint8Array) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "bytes",
              "type": "Uint8Array",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 36,
          "raw": "export const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};",
          "source": "mesh-core-csl",
          "implementation": "export const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};"
        },
        {
          "name": "toBytes",
          "signature": "export const toBytes = (hex: string): Uint8Array => {",
          "documentation": "",
          "parameters": [
            {
              "name": "hex",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Uint8Array",
          "isPublic": true,
          "line": 39,
          "raw": "export const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};",
          "source": "mesh-core-csl",
          "implementation": "export const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};"
        },
        {
          "name": "fromUTF8",
          "signature": "export const fromUTF8 = (utf8: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "utf8",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 48,
          "raw": "export const fromUTF8 = (utf8: string) => {\n  if (utf8.length % 2 === 0 && /^[0-9A-F]*$/i.test(utf8)) return utf8;\n\n  return fromBytes(Buffer.from(utf8, \"utf-8\"));\n};",
          "source": "mesh-core-csl",
          "implementation": "export const fromUTF8 = (utf8: string) => {\n  if (utf8.length % 2 === 0 && /^[0-9A-F]*$/i.test(utf8)) return utf8;\n\n  return fromBytes(Buffer.from(utf8, \"utf-8\"));\n};"
        },
        {
          "name": "toUTF8",
          "signature": "export const toUTF8 = (hex: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "hex",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 54,
          "raw": "export const toUTF8 = (hex: string) =>\n  Buffer.from(hex, \"hex\").toString(\"utf-8\");\n\n/* -----------------[ Lovelace ]----------------- */\n\nexport const fromLovelace = (lovelace: number) => lovelace / 1_000_000;\n\nexport const toLovelace = (ada: number) => ada * 1_000_000;\n\n// /* -----------------[ NativeScript ]----------------- */\n\n// export const fromNativeScript = (script: csl.NativeScript) => {\n//   const fromNativeScripts = (scripts: csl.NativeScripts) => {\n//     const nativeScripts = new Array<NativeScript>();\n\n//     for (let index = 0; index < scripts.len(); index += 1) {\n//       nativeScripts.push(fromNativeScript(scripts.get(index)));\n//     }\n\n//     return nativeScripts;\n//   };\n\n//   switch (script.kind()) {\n//     case csl.NativeScriptKind.ScriptAll: {\n//       const scriptAll = script.as_script_all()!;\n//       return <NativeScript>{\n//         type: \"all\",\n//         scripts: fromNativeScripts(scriptAll.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptAny: {\n//       const scriptAny = script.as_script_any()!;\n//       return <NativeScript>{\n//         type: \"any\",\n//         scripts: fromNativeScripts(scriptAny.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptNOfK: {\n//       const scriptNOfK = script.as_script_n_of_k()!;\n//       return <NativeScript>{\n//         type: \"atLeast\",\n//         required: scriptNOfK.n(),\n//         scripts: fromNativeScripts(scriptNOfK.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockStart: {\n//       const timelockStart = script.as_timelock_start()!;\n//       return <NativeScript>{\n//         type: \"after\",\n//         slot: timelockStart.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockExpiry: {\n//       const timelockExpiry = script.as_timelock_expiry()!;\n//       return <NativeScript>{\n//         type: \"before\",\n//         slot: timelockExpiry.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptPubkey: {\n//       const scriptPubkey = script.as_script_pubkey()!;\n//       return <NativeScript>{\n//         type: \"sig\",\n//         keyHash: scriptPubkey.addr_keyhash().to_hex(),\n//       };\n//     }\n//     default:\n//       throw new Error(`Script Kind: ${script.kind()}, is not supported`);\n//   }\n// };",
          "source": "mesh-core-csl",
          "implementation": "export const toUTF8 = (hex: string) =>\n  Buffer.from(hex, \"hex\").toString(\"utf-8\");\n\n/* -----------------[ Lovelace ]----------------- */\n\nexport const fromLovelace = (lovelace: number) => lovelace / 1_000_000;\n\nexport const toLovelace = (ada: number) => ada * 1_000_000;\n\n// /* -----------------[ NativeScript ]----------------- */\n\n// export const fromNativeScript = (script: csl.NativeScript) => {\n//   const fromNativeScripts = (scripts: csl.NativeScripts) => {\n//     const nativeScripts = new Array<NativeScript>();\n\n//     for (let index = 0; index < scripts.len(); index += 1) {\n//       nativeScripts.push(fromNativeScript(scripts.get(index)));\n//     }\n\n//     return nativeScripts;\n//   };\n\n//   switch (script.kind()) {\n//     case csl.NativeScriptKind.ScriptAll: {\n//       const scriptAll = script.as_script_all()!;\n//       return <NativeScript>{\n//         type: \"all\",\n//         scripts: fromNativeScripts(scriptAll.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptAny: {\n//       const scriptAny = script.as_script_any()!;\n//       return <NativeScript>{\n//         type: \"any\",\n//         scripts: fromNativeScripts(scriptAny.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptNOfK: {\n//       const scriptNOfK = script.as_script_n_of_k()!;\n//       return <NativeScript>{\n//         type: \"atLeast\",\n//         required: scriptNOfK.n(),\n//         scripts: fromNativeScripts(scriptNOfK.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockStart: {\n//       const timelockStart = script.as_timelock_start()!;\n//       return <NativeScript>{\n//         type: \"after\",\n//         slot: timelockStart.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockExpiry: {\n//       const timelockExpiry = script.as_timelock_expiry()!;\n//       return <NativeScript>{\n//         type: \"before\",\n//         slot: timelockExpiry.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptPubkey: {\n//       const scriptPubkey = script.as_script_pubkey()!;\n//       return <NativeScript>{\n//         type: \"sig\",\n//         keyHash: scriptPubkey.addr_keyhash().to_hex(),\n//       };\n//     }\n//     default:\n//       throw new Error(`Script Kind: ${script.kind()}, is not supported`);\n//   }\n// };"
        },
        {
          "name": "fromLovelace",
          "signature": "export const fromLovelace = (lovelace: number) => lovelace / 1_000_000;",
          "documentation": "",
          "parameters": [
            {
              "name": "lovelace",
              "type": "number",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 59,
          "raw": "export const fromLovelace = (lovelace: number) => lovelace / 1_000_000;\n\nexport const toLovelace = (ada: number) => ada * 1_000_000;\n\n// /* -----------------[ NativeScript ]----------------- */\n\n// export const fromNativeScript = (script: csl.NativeScript) => {\n//   const fromNativeScripts = (scripts: csl.NativeScripts) => {\n//     const nativeScripts = new Array<NativeScript>();\n\n//     for (let index = 0; index < scripts.len(); index += 1) {\n//       nativeScripts.push(fromNativeScript(scripts.get(index)));\n//     }\n\n//     return nativeScripts;\n//   };\n\n//   switch (script.kind()) {\n//     case csl.NativeScriptKind.ScriptAll: {\n//       const scriptAll = script.as_script_all()!;\n//       return <NativeScript>{\n//         type: \"all\",\n//         scripts: fromNativeScripts(scriptAll.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptAny: {\n//       const scriptAny = script.as_script_any()!;\n//       return <NativeScript>{\n//         type: \"any\",\n//         scripts: fromNativeScripts(scriptAny.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptNOfK: {\n//       const scriptNOfK = script.as_script_n_of_k()!;\n//       return <NativeScript>{\n//         type: \"atLeast\",\n//         required: scriptNOfK.n(),\n//         scripts: fromNativeScripts(scriptNOfK.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockStart: {\n//       const timelockStart = script.as_timelock_start()!;\n//       return <NativeScript>{\n//         type: \"after\",\n//         slot: timelockStart.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockExpiry: {\n//       const timelockExpiry = script.as_timelock_expiry()!;\n//       return <NativeScript>{\n//         type: \"before\",\n//         slot: timelockExpiry.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptPubkey: {\n//       const scriptPubkey = script.as_script_pubkey()!;\n//       return <NativeScript>{\n//         type: \"sig\",\n//         keyHash: scriptPubkey.addr_keyhash().to_hex(),\n//       };\n//     }\n//     default:\n//       throw new Error(`Script Kind: ${script.kind()}, is not supported`);\n//   }\n// };",
          "source": "mesh-core-csl",
          "implementation": "export const fromLovelace = (lovelace: number) => lovelace / 1_000_000;\n\nexport const toLovelace = (ada: number) => ada * 1_000_000;\n\n// /* -----------------[ NativeScript ]----------------- */\n\n// export const fromNativeScript = (script: csl.NativeScript) => {\n//   const fromNativeScripts = (scripts: csl.NativeScripts) => {\n//     const nativeScripts = new Array<NativeScript>();\n\n//     for (let index = 0; index < scripts.len(); index += 1) {\n//       nativeScripts.push(fromNativeScript(scripts.get(index)));\n//     }\n\n//     return nativeScripts;\n//   };\n\n//   switch (script.kind()) {\n//     case csl.NativeScriptKind.ScriptAll: {\n//       const scriptAll = script.as_script_all()!;\n//       return <NativeScript>{\n//         type: \"all\",\n//         scripts: fromNativeScripts(scriptAll.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptAny: {\n//       const scriptAny = script.as_script_any()!;\n//       return <NativeScript>{\n//         type: \"any\",\n//         scripts: fromNativeScripts(scriptAny.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptNOfK: {\n//       const scriptNOfK = script.as_script_n_of_k()!;\n//       return <NativeScript>{\n//         type: \"atLeast\",\n//         required: scriptNOfK.n(),\n//         scripts: fromNativeScripts(scriptNOfK.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockStart: {\n//       const timelockStart = script.as_timelock_start()!;\n//       return <NativeScript>{\n//         type: \"after\",\n//         slot: timelockStart.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockExpiry: {\n//       const timelockExpiry = script.as_timelock_expiry()!;\n//       return <NativeScript>{\n//         type: \"before\",\n//         slot: timelockExpiry.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptPubkey: {\n//       const scriptPubkey = script.as_script_pubkey()!;\n//       return <NativeScript>{\n//         type: \"sig\",\n//         keyHash: scriptPubkey.addr_keyhash().to_hex(),\n//       };\n//     }\n//     default:\n//       throw new Error(`Script Kind: ${script.kind()}, is not supported`);\n//   }\n// };"
        },
        {
          "name": "toLovelace",
          "signature": "export const toLovelace = (ada: number) => ada * 1_000_000;",
          "documentation": "",
          "parameters": [
            {
              "name": "ada",
              "type": "number",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 61,
          "raw": "export const toLovelace = (ada: number) => ada * 1_000_000;\n\n// /* -----------------[ NativeScript ]----------------- */\n\n// export const fromNativeScript = (script: csl.NativeScript) => {\n//   const fromNativeScripts = (scripts: csl.NativeScripts) => {\n//     const nativeScripts = new Array<NativeScript>();\n\n//     for (let index = 0; index < scripts.len(); index += 1) {\n//       nativeScripts.push(fromNativeScript(scripts.get(index)));\n//     }\n\n//     return nativeScripts;\n//   };\n\n//   switch (script.kind()) {\n//     case csl.NativeScriptKind.ScriptAll: {\n//       const scriptAll = script.as_script_all()!;\n//       return <NativeScript>{\n//         type: \"all\",\n//         scripts: fromNativeScripts(scriptAll.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptAny: {\n//       const scriptAny = script.as_script_any()!;\n//       return <NativeScript>{\n//         type: \"any\",\n//         scripts: fromNativeScripts(scriptAny.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptNOfK: {\n//       const scriptNOfK = script.as_script_n_of_k()!;\n//       return <NativeScript>{\n//         type: \"atLeast\",\n//         required: scriptNOfK.n(),\n//         scripts: fromNativeScripts(scriptNOfK.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockStart: {\n//       const timelockStart = script.as_timelock_start()!;\n//       return <NativeScript>{\n//         type: \"after\",\n//         slot: timelockStart.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockExpiry: {\n//       const timelockExpiry = script.as_timelock_expiry()!;\n//       return <NativeScript>{\n//         type: \"before\",\n//         slot: timelockExpiry.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptPubkey: {\n//       const scriptPubkey = script.as_script_pubkey()!;\n//       return <NativeScript>{\n//         type: \"sig\",\n//         keyHash: scriptPubkey.addr_keyhash().to_hex(),\n//       };\n//     }\n//     default:\n//       throw new Error(`Script Kind: ${script.kind()}, is not supported`);\n//   }\n// };",
          "source": "mesh-core-csl",
          "implementation": "export const toLovelace = (ada: number) => ada * 1_000_000;\n\n// /* -----------------[ NativeScript ]----------------- */\n\n// export const fromNativeScript = (script: csl.NativeScript) => {\n//   const fromNativeScripts = (scripts: csl.NativeScripts) => {\n//     const nativeScripts = new Array<NativeScript>();\n\n//     for (let index = 0; index < scripts.len(); index += 1) {\n//       nativeScripts.push(fromNativeScript(scripts.get(index)));\n//     }\n\n//     return nativeScripts;\n//   };\n\n//   switch (script.kind()) {\n//     case csl.NativeScriptKind.ScriptAll: {\n//       const scriptAll = script.as_script_all()!;\n//       return <NativeScript>{\n//         type: \"all\",\n//         scripts: fromNativeScripts(scriptAll.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptAny: {\n//       const scriptAny = script.as_script_any()!;\n//       return <NativeScript>{\n//         type: \"any\",\n//         scripts: fromNativeScripts(scriptAny.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptNOfK: {\n//       const scriptNOfK = script.as_script_n_of_k()!;\n//       return <NativeScript>{\n//         type: \"atLeast\",\n//         required: scriptNOfK.n(),\n//         scripts: fromNativeScripts(scriptNOfK.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockStart: {\n//       const timelockStart = script.as_timelock_start()!;\n//       return <NativeScript>{\n//         type: \"after\",\n//         slot: timelockStart.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockExpiry: {\n//       const timelockExpiry = script.as_timelock_expiry()!;\n//       return <NativeScript>{\n//         type: \"before\",\n//         slot: timelockExpiry.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptPubkey: {\n//       const scriptPubkey = script.as_script_pubkey()!;\n//       return <NativeScript>{\n//         type: \"sig\",\n//         keyHash: scriptPubkey.addr_keyhash().to_hex(),\n//       };\n//     }\n//     default:\n//       throw new Error(`Script Kind: ${script.kind()}, is not supported`);\n//   }\n// };"
        },
        {
          "name": "toScriptRef",
          "signature": "export const toScriptRef = (script: PlutusScript | NativeScript) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "script",
              "type": "PlutusScript | NativeScript",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 148,
          "raw": "export const toScriptRef = (script: PlutusScript | NativeScript) => {\n  if (\"code\" in script) {\n    const plutusScript = deserializePlutusScript(script.code, script.version);\n\n    return csl.ScriptRef.new_plutus_script(plutusScript);\n  }\n\n  return csl.ScriptRef.new_native_script(toNativeScript(script));\n};",
          "source": "mesh-core-csl",
          "implementation": "export const toScriptRef = (script: PlutusScript | NativeScript) => {\n  if (\"code\" in script) {\n    const plutusScript = deserializePlutusScript(script.code, script.version);\n\n    return csl.ScriptRef.new_plutus_script(plutusScript);\n  }\n\n  return csl.ScriptRef.new_native_script(toNativeScript(script));\n};"
        },
        {
          "name": "toPlutusData",
          "signature": "export const toPlutusData = (data: Data): csl.PlutusData => {",
          "documentation": "",
          "parameters": [
            {
              "name": "data",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "csl.PlutusData",
          "isPublic": true,
          "line": 160,
          "raw": "export const toPlutusData = (data: Data): csl.PlutusData => {\n  const toPlutusList = (dataArray: Data[]) => {\n    const plutusList = csl.PlutusList.new();\n    dataArray.forEach((element) => {\n      plutusList.add(toPlutusData(element));\n    });\n\n    return plutusList;\n  };\n\n  switch (typeof data) {\n    case \"string\":\n      return csl.PlutusData.new_bytes(toBytes(data));\n    case \"number\":\n      return csl.PlutusData.new_integer(csl.BigInt.from_str(data.toString()));\n    case \"bigint\":\n      return csl.PlutusData.new_integer(csl.BigInt.from_str(data.toString()));\n    case \"object\":\n      if (data instanceof Array) {\n        const plutusList = toPlutusList(data);\n        return csl.PlutusData.new_list(plutusList);\n      }\n      if (data instanceof Map) {\n        const plutusMap = csl.PlutusMap.new();\n        data.forEach((value, key) => {\n          const plutusMapValue = csl.PlutusMapValues.new();\n          plutusMapValue.add(toPlutusData(value));\n          plutusMap.insert(toPlutusData(key), plutusMapValue);\n        });\n        return csl.PlutusData.new_map(plutusMap);\n      }\n      return csl.PlutusData.new_constr_plutus_data(\n        csl.ConstrPlutusData.new(\n          csl.BigNum.from_str(data.alternative.toString()),\n          toPlutusList(data.fields),\n        ),\n      );\n  }\n};",
          "source": "mesh-core-csl",
          "implementation": "export const toPlutusData = (data: Data): csl.PlutusData => {\n  const toPlutusList = (dataArray: Data[]) => {\n    const plutusList = csl.PlutusList.new();\n    dataArray.forEach((element) => {\n      plutusList.add(toPlutusData(element));\n    });\n\n    return plutusList;\n  };\n\n  switch (typeof data) {\n    case \"string\":\n      return csl.PlutusData.new_bytes(toBytes(data));\n    case \"number\":\n      return csl.PlutusData.new_integer(csl.BigInt.from_str(data.toString()));\n    case \"bigint\":\n      return csl.PlutusData.new_integer(csl.BigInt.from_str(data.toString()));\n    case \"object\":\n      if (data instanceof Array) {\n        const plutusList = toPlutusList(data);\n        return csl.PlutusData.new_list(plutusList);\n      }\n      if (data instanceof Map) {\n        const plutusMap = csl.PlutusMap.new();\n        data.forEach((value, key) => {\n          const plutusMapValue = csl.PlutusMapValues.new();\n          plutusMapValue.add(toPlutusData(value));\n          plutusMap.insert(toPlutusData(key), plutusMapValue);\n        });\n        return csl.PlutusData.new_map(plutusMap);\n      }\n      return csl.PlutusData.new_constr_plutus_data(\n        csl.ConstrPlutusData.new(\n          csl.BigNum.from_str(data.alternative.toString()),\n          toPlutusList(data.fields),\n        ),\n      );\n  }\n};"
        },
        {
          "name": "toPlutusList",
          "signature": "const toPlutusList = (dataArray: Data[]) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "dataArray",
              "type": "Data[]",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 161,
          "raw": "  const toPlutusList = (dataArray: Data[]) => {\n    const plutusList = csl.PlutusList.new();\n    dataArray.forEach((element) => {\n      plutusList.add(toPlutusData(element));\n    });\n\n    return plutusList;\n  };",
          "source": "mesh-core-csl",
          "implementation": "  const toPlutusList = (dataArray: Data[]) => {\n    const plutusList = csl.PlutusList.new();\n    dataArray.forEach((element) => {\n      plutusList.add(toPlutusData(element));\n    });\n\n    return plutusList;\n  };"
        },
        {
          "name": "castRawDataToJsonString",
          "signature": "export const castRawDataToJsonString = (rawData: object | string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "rawData",
              "type": "object | string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 200,
          "raw": "export const castRawDataToJsonString = (rawData: object | string) => {\n  if (typeof rawData === \"object\") {\n    return JSONbig.stringify(rawData);\n  }\n  return rawData as string;\n};",
          "source": "mesh-core-csl",
          "implementation": "export const castRawDataToJsonString = (rawData: object | string) => {\n  if (typeof rawData === \"object\") {\n    return JSONbig.stringify(rawData);\n  }\n  return rawData as string;\n};"
        },
        {
          "name": "castDataToPlutusData",
          "signature": "export const castDataToPlutusData = ({",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 207,
          "raw": "export const castDataToPlutusData = ({\n  type,\n  content,\n}: BuilderData): csl.PlutusData => {\n  if (type === \"Mesh\") {\n    return toPlutusData(content);\n  }\n  if (type === \"CBOR\") {\n    return csl.PlutusData.from_hex(content as string);\n  }\n  return csl.PlutusData.from_json(\n    castRawDataToJsonString(content),\n    csl.PlutusDatumSchema.DetailedSchema,\n  );\n};",
          "source": "mesh-core-csl",
          "implementation": "export const castDataToPlutusData = ({\n  type,\n  content,\n}: BuilderData): csl.PlutusData => {\n  if (type === \"Mesh\") {\n    return toPlutusData(content);\n  }\n  if (type === \"CBOR\") {\n    return csl.PlutusData.from_hex(content as string);\n  }\n  return csl.PlutusData.from_json(\n    castRawDataToJsonString(content),\n    csl.PlutusDatumSchema.DetailedSchema,\n  );\n};"
        },
        {
          "name": "toNativeScript",
          "signature": "export const toNativeScript = (script: NativeScript) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "script",
              "type": "NativeScript",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 223,
          "raw": "export const toNativeScript = (script: NativeScript) => {\n  const toNativeScripts = (scripts: NativeScript[]) => {\n    const nativeScripts = csl.NativeScripts.new();\n\n    scripts.forEach((script) => {\n      nativeScripts.add(toNativeScript(script));\n    });\n\n    return nativeScripts;\n  };\n\n  switch (script.type) {\n    case \"all\":\n      return csl.NativeScript.new_script_all(\n        csl.ScriptAll.new(toNativeScripts(script.scripts)),\n      );\n    case \"any\":\n      return csl.NativeScript.new_script_any(\n        csl.ScriptAny.new(toNativeScripts(script.scripts)),\n      );\n    case \"atLeast\":\n      return csl.NativeScript.new_script_n_of_k(\n        csl.ScriptNOfK.new(script.required, toNativeScripts(script.scripts)),\n      );\n    case \"after\":\n      return csl.NativeScript.new_timelock_start(\n        csl.TimelockStart.new_timelockstart(csl.BigNum.from_str(script.slot)),\n      );\n    case \"before\":\n      return csl.NativeScript.new_timelock_expiry(\n        csl.TimelockExpiry.new_timelockexpiry(csl.BigNum.from_str(script.slot)),\n      );\n    case \"sig\":\n      return csl.NativeScript.new_script_pubkey(\n        csl.ScriptPubkey.new(deserializeEd25519KeyHash(script.keyHash)),\n      );\n  }\n};",
          "source": "mesh-core-csl",
          "implementation": "export const toNativeScript = (script: NativeScript) => {\n  const toNativeScripts = (scripts: NativeScript[]) => {\n    const nativeScripts = csl.NativeScripts.new();\n\n    scripts.forEach((script) => {\n      nativeScripts.add(toNativeScript(script));\n    });\n\n    return nativeScripts;\n  };\n\n  switch (script.type) {\n    case \"all\":\n      return csl.NativeScript.new_script_all(\n        csl.ScriptAll.new(toNativeScripts(script.scripts)),\n      );\n    case \"any\":\n      return csl.NativeScript.new_script_any(\n        csl.ScriptAny.new(toNativeScripts(script.scripts)),\n      );\n    case \"atLeast\":\n      return csl.NativeScript.new_script_n_of_k(\n        csl.ScriptNOfK.new(script.required, toNativeScripts(script.scripts)),\n      );\n    case \"after\":\n      return csl.NativeScript.new_timelock_start(\n        csl.TimelockStart.new_timelockstart(csl.BigNum.from_str(script.slot)),\n      );\n    case \"before\":\n      return csl.NativeScript.new_timelock_expiry(\n        csl.TimelockExpiry.new_timelockexpiry(csl.BigNum.from_str(script.slot)),\n      );\n    case \"sig\":\n      return csl.NativeScript.new_script_pubkey(\n        csl.ScriptPubkey.new(deserializeEd25519KeyHash(script.keyHash)),\n      );\n  }\n};"
        },
        {
          "name": "toNativeScripts",
          "signature": "const toNativeScripts = (scripts: NativeScript[]) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "scripts",
              "type": "NativeScript[]",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 224,
          "raw": "  const toNativeScripts = (scripts: NativeScript[]) => {\n    const nativeScripts = csl.NativeScripts.new();\n\n    scripts.forEach((script) => {\n      nativeScripts.add(toNativeScript(script));\n    });\n\n    return nativeScripts;\n  };",
          "source": "mesh-core-csl",
          "implementation": "  const toNativeScripts = (scripts: NativeScript[]) => {\n    const nativeScripts = csl.NativeScripts.new();\n\n    scripts.forEach((script) => {\n      nativeScripts.add(toNativeScript(script));\n    });\n\n    return nativeScripts;\n  };"
        },
        {
          "name": "toCslValue",
          "signature": "export const toCslValue = (assets: Asset[]): csl.Value => {",
          "documentation": "",
          "parameters": [
            {
              "name": "assets",
              "type": "Asset[]",
              "optional": false
            }
          ],
          "returnType": "csl.Value",
          "isPublic": true,
          "line": 262,
          "raw": "export const toCslValue = (assets: Asset[]): csl.Value => {\n  let cslValue: csl.Value | undefined = undefined;\n  let multiAsset: csl.MultiAsset = csl.MultiAsset.new();\n  for (const asset of assets) {\n    if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n      cslValue = csl.Value.new(csl.BigNum.from_str(asset.quantity));\n    } else {\n      const policyId = csl.ScriptHash.from_hex(asset.unit.slice(0, 56));\n      const assetName = csl.AssetName.new(\n        Buffer.from(asset.unit.slice(56), \"hex\"),\n      );\n      const quantity = csl.BigNum.from_str(asset.quantity);\n      multiAsset.set_asset(policyId, assetName, quantity);\n    }\n  }\n  if (cslValue !== undefined) {\n    cslValue.set_multiasset(multiAsset);\n  } else {\n    cslValue = csl.Value.new(csl.BigNum.from_str(\"0\"));\n    cslValue.set_multiasset(multiAsset);\n  }\n  return cslValue;\n};",
          "source": "mesh-core-csl",
          "implementation": "export const toCslValue = (assets: Asset[]): csl.Value => {\n  let cslValue: csl.Value | undefined = undefined;\n  let multiAsset: csl.MultiAsset = csl.MultiAsset.new();\n  for (const asset of assets) {\n    if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n      cslValue = csl.Value.new(csl.BigNum.from_str(asset.quantity));\n    } else {\n      const policyId = csl.ScriptHash.from_hex(asset.unit.slice(0, 56));\n      const assetName = csl.AssetName.new(\n        Buffer.from(asset.unit.slice(56), \"hex\"),\n      );\n      const quantity = csl.BigNum.from_str(asset.quantity);\n      multiAsset.set_asset(policyId, assetName, quantity);\n    }\n  }\n  if (cslValue !== undefined) {\n    cslValue.set_multiasset(multiAsset);\n  } else {\n    cslValue = csl.Value.new(csl.BigNum.from_str(\"0\"));\n    cslValue.set_multiasset(multiAsset);\n  }\n  return cslValue;\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "toAddress",
          "type": "any",
          "value": "(bech32: string) => csl.Address.from_bech32(bech32);",
          "isPublic": true,
          "line": 23,
          "raw": "export const toAddress = (bech32: string) => csl.Address.from_bech32(bech32);",
          "source": "mesh-core-csl"
        },
        {
          "name": "toBaseAddress",
          "type": "any",
          "value": "(bech32: string) =>",
          "isPublic": true,
          "line": 25,
          "raw": "export const toBaseAddress = (bech32: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "name": "toEnterpriseAddress",
          "type": "any",
          "value": "(bech32: string) =>",
          "isPublic": true,
          "line": 28,
          "raw": "export const toEnterpriseAddress = (bech32: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "name": "toRewardAddress",
          "type": "any",
          "value": "(bech32: string) =>",
          "isPublic": true,
          "line": 31,
          "raw": "export const toRewardAddress = (bech32: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "name": "fromBytes",
          "type": "any",
          "value": "(bytes: Uint8Array) =>",
          "isPublic": true,
          "line": 36,
          "raw": "export const fromBytes = (bytes: Uint8Array) =>",
          "source": "mesh-core-csl"
        },
        {
          "name": "toBytes",
          "type": "any",
          "value": "(hex: string): Uint8Array => {",
          "isPublic": true,
          "line": 39,
          "raw": "export const toBytes = (hex: string): Uint8Array => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "fromUTF8",
          "type": "any",
          "value": "(utf8: string) => {",
          "isPublic": true,
          "line": 48,
          "raw": "export const fromUTF8 = (utf8: string) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "toUTF8",
          "type": "any",
          "value": "(hex: string) =>",
          "isPublic": true,
          "line": 54,
          "raw": "export const toUTF8 = (hex: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "name": "fromLovelace",
          "type": "any",
          "value": "(lovelace: number) => lovelace / 1_000_000;",
          "isPublic": true,
          "line": 59,
          "raw": "export const fromLovelace = (lovelace: number) => lovelace / 1_000_000;",
          "source": "mesh-core-csl"
        },
        {
          "name": "toLovelace",
          "type": "any",
          "value": "(ada: number) => ada * 1_000_000;",
          "isPublic": true,
          "line": 61,
          "raw": "export const toLovelace = (ada: number) => ada * 1_000_000;",
          "source": "mesh-core-csl"
        },
        {
          "name": "toScriptRef",
          "type": "any",
          "value": "(script: PlutusScript | NativeScript) => {",
          "isPublic": true,
          "line": 148,
          "raw": "export const toScriptRef = (script: PlutusScript | NativeScript) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "plutusScript",
          "type": "any",
          "value": "deserializePlutusScript(script.code, script.version);",
          "isPublic": true,
          "line": 150,
          "raw": "const plutusScript = deserializePlutusScript(script.code, script.version);",
          "source": "mesh-core-csl"
        },
        {
          "name": "toPlutusData",
          "type": "any",
          "value": "(data: Data): csl.PlutusData => {",
          "isPublic": true,
          "line": 160,
          "raw": "export const toPlutusData = (data: Data): csl.PlutusData => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "toPlutusList",
          "type": "any",
          "value": "(dataArray: Data[]) => {",
          "isPublic": true,
          "line": 161,
          "raw": "const toPlutusList = (dataArray: Data[]) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "plutusList",
          "type": "any",
          "value": "csl.PlutusList.new();",
          "isPublic": true,
          "line": 162,
          "raw": "const plutusList = csl.PlutusList.new();",
          "source": "mesh-core-csl"
        },
        {
          "name": "plutusList",
          "type": "any",
          "value": "toPlutusList(data);",
          "isPublic": true,
          "line": 179,
          "raw": "const plutusList = toPlutusList(data);",
          "source": "mesh-core-csl"
        },
        {
          "name": "plutusMap",
          "type": "any",
          "value": "csl.PlutusMap.new();",
          "isPublic": true,
          "line": 183,
          "raw": "const plutusMap = csl.PlutusMap.new();",
          "source": "mesh-core-csl"
        },
        {
          "name": "plutusMapValue",
          "type": "any",
          "value": "csl.PlutusMapValues.new();",
          "isPublic": true,
          "line": 185,
          "raw": "const plutusMapValue = csl.PlutusMapValues.new();",
          "source": "mesh-core-csl"
        },
        {
          "name": "castRawDataToJsonString",
          "type": "any",
          "value": "(rawData: object | string) => {",
          "isPublic": true,
          "line": 200,
          "raw": "export const castRawDataToJsonString = (rawData: object | string) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "castDataToPlutusData",
          "type": "any",
          "value": "({",
          "isPublic": true,
          "line": 207,
          "raw": "export const castDataToPlutusData = ({",
          "source": "mesh-core-csl"
        },
        {
          "name": "toNativeScript",
          "type": "any",
          "value": "(script: NativeScript) => {",
          "isPublic": true,
          "line": 223,
          "raw": "export const toNativeScript = (script: NativeScript) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "toNativeScripts",
          "type": "any",
          "value": "(scripts: NativeScript[]) => {",
          "isPublic": true,
          "line": 224,
          "raw": "const toNativeScripts = (scripts: NativeScript[]) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "nativeScripts",
          "type": "any",
          "value": "csl.NativeScripts.new();",
          "isPublic": true,
          "line": 225,
          "raw": "const nativeScripts = csl.NativeScripts.new();",
          "source": "mesh-core-csl"
        },
        {
          "name": "toCslValue",
          "type": "any",
          "value": "(assets: Asset[]): csl.Value => {",
          "isPublic": true,
          "line": 262,
          "raw": "export const toCslValue = (assets: Asset[]): csl.Value => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "policyId",
          "type": "any",
          "value": "csl.ScriptHash.from_hex(asset.unit.slice(0, 56));",
          "isPublic": true,
          "line": 269,
          "raw": "const policyId = csl.ScriptHash.from_hex(asset.unit.slice(0, 56));",
          "source": "mesh-core-csl"
        },
        {
          "name": "assetName",
          "type": "any",
          "value": "csl.AssetName.new(",
          "isPublic": true,
          "line": 270,
          "raw": "const assetName = csl.AssetName.new(",
          "source": "mesh-core-csl"
        },
        {
          "name": "quantity",
          "type": "any",
          "value": "csl.BigNum.from_str(asset.quantity);",
          "isPublic": true,
          "line": 273,
          "raw": "const quantity = csl.BigNum.from_str(asset.quantity);",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "/* eslint-disable consistent-return */\n/* eslint-disable default-case */\nimport JSONbig from \"json-bigint\";\n\nimport type {\n  Asset,\n  BuilderData,\n  Data,\n  NativeScript,\n  PlutusScript,\n} from \"@meshsdk/common\";\n\n// import { LANGUAGE_VERSIONS } from \".\";\nimport { csl } from \"./csl\";\nimport {\n  deserializeEd25519KeyHash,\n  deserializePlutusScript,\n  // deserializePlutusScript,\n} from \"./deserializer\";\n\n/* -----------------[ Address ]----------------- */\n\nexport const toAddress = (bech32: string) => csl.Address.from_bech32(bech32);\n\nexport const toBaseAddress = (bech32: string) =>\n  csl.BaseAddress.from_address(toAddress(bech32));\n\nexport const toEnterpriseAddress = (bech32: string) =>\n  csl.EnterpriseAddress.from_address(toAddress(bech32));\n\nexport const toRewardAddress = (bech32: string) =>\n  csl.RewardAddress.from_address(toAddress(bech32));\n\n/* -----------------[ Bytes ]----------------- */\n\nexport const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};\n\n/* -----------------[ UTF-8 ]----------------- */\n\nexport const fromUTF8 = (utf8: string) => {\n  if (utf8.length % 2 === 0 && /^[0-9A-F]*$/i.test(utf8)) return utf8;\n\n  return fromBytes(Buffer.from(utf8, \"utf-8\"));\n};\n\nexport const toUTF8 = (hex: string) =>\n  Buffer.from(hex, \"hex\").toString(\"utf-8\");\n\n/* -----------------[ Lovelace ]----------------- */\n\nexport const fromLovelace = (lovelace: number) => lovelace / 1_000_000;\n\nexport const toLovelace = (ada: number) => ada * 1_000_000;\n\n// /* -----------------[ NativeScript ]----------------- */\n\n// export const fromNativeScript = (script: csl.NativeScript) => {\n//   const fromNativeScripts = (scripts: csl.NativeScripts) => {\n//     const nativeScripts = new Array<NativeScript>();\n\n//     for (let index = 0; index < scripts.len(); index += 1) {\n//       nativeScripts.push(fromNativeScript(scripts.get(index)));\n//     }\n\n//     return nativeScripts;\n//   };\n\n//   switch (script.kind()) {\n//     case csl.NativeScriptKind.ScriptAll: {\n//       const scriptAll = script.as_script_all()!;\n//       return <NativeScript>{\n//         type: \"all\",\n//         scripts: fromNativeScripts(scriptAll.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptAny: {\n//       const scriptAny = script.as_script_any()!;\n//       return <NativeScript>{\n//         type: \"any\",\n//         scripts: fromNativeScripts(scriptAny.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptNOfK: {\n//       const scriptNOfK = script.as_script_n_of_k()!;\n//       return <NativeScript>{\n//         type: \"atLeast\",\n//         required: scriptNOfK.n(),\n//         scripts: fromNativeScripts(scriptNOfK.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockStart: {\n//       const timelockStart = script.as_timelock_start()!;\n//       return <NativeScript>{\n//         type: \"after\",\n//         slot: timelockStart.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockExpiry: {\n//       const timelockExpiry = script.as_timelock_expiry()!;\n//       return <NativeScript>{\n//         type: \"before\",\n//         slot: timelockExpiry.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptPubkey: {\n//       const scriptPubkey = script.as_script_pubkey()!;\n//       return <NativeScript>{\n//         type: \"sig\",\n//         keyHash: scriptPubkey.addr_keyhash().to_hex(),\n//       };\n//     }\n//     default:\n//       throw new Error(`Script Kind: ${script.kind()}, is not supported`);\n//   }\n// };\n\n// /* -----------------[ Scripts ]----------------- */\n// export const fromScriptRef = (\n//   scriptRef: string,\n// ): PlutusScript | NativeScript | undefined => {\n//   const script = csl.ScriptRef.from_hex(scriptRef);\n//   if (script.is_plutus_script()) {\n//     const plutusScript = script.plutus_script()!;\n\n//     return <PlutusScript>{\n//       code: plutusScript.to_hex(),\n//       version: Object.keys(LANGUAGE_VERSIONS).find(\n//         (key) =>\n//           LANGUAGE_VERSIONS[key as LanguageVersion].to_hex() ===\n//           plutusScript.language_version().to_hex(),\n//       ),\n//     };\n//   }\n\n//   const nativeScript = script.native_script()!;\n\n//   return fromNativeScript(nativeScript);\n// };\n\nexport const toScriptRef = (script: PlutusScript | NativeScript) => {\n  if (\"code\" in script) {\n    const plutusScript = deserializePlutusScript(script.code, script.version);\n\n    return csl.ScriptRef.new_plutus_script(plutusScript);\n  }\n\n  return csl.ScriptRef.new_native_script(toNativeScript(script));\n};\n\n/* -----------------[ PlutusData ]----------------- */\n\nexport const toPlutusData = (data: Data): csl.PlutusData => {\n  const toPlutusList = (dataArray: Data[]) => {\n    const plutusList = csl.PlutusList.new();\n    dataArray.forEach((element) => {\n      plutusList.add(toPlutusData(element));\n    });\n\n    return plutusList;\n  };\n\n  switch (typeof data) {\n    case \"string\":\n      return csl.PlutusData.new_bytes(toBytes(data));\n    case \"number\":\n      return csl.PlutusData.new_integer(csl.BigInt.from_str(data.toString()));\n    case \"bigint\":\n      return csl.PlutusData.new_integer(csl.BigInt.from_str(data.toString()));\n    case \"object\":\n      if (data instanceof Array) {\n        const plutusList = toPlutusList(data);\n        return csl.PlutusData.new_list(plutusList);\n      }\n      if (data instanceof Map) {\n        const plutusMap = csl.PlutusMap.new();\n        data.forEach((value, key) => {\n          const plutusMapValue = csl.PlutusMapValues.new();\n          plutusMapValue.add(toPlutusData(value));\n          plutusMap.insert(toPlutusData(key), plutusMapValue);\n        });\n        return csl.PlutusData.new_map(plutusMap);\n      }\n      return csl.PlutusData.new_constr_plutus_data(\n        csl.ConstrPlutusData.new(\n          csl.BigNum.from_str(data.alternative.toString()),\n          toPlutusList(data.fields),\n        ),\n      );\n  }\n};\n\nexport const castRawDataToJsonString = (rawData: object | string) => {\n  if (typeof rawData === \"object\") {\n    return JSONbig.stringify(rawData);\n  }\n  return rawData as string;\n};\n\nexport const castDataToPlutusData = ({\n  type,\n  content,\n}: BuilderData): csl.PlutusData => {\n  if (type === \"Mesh\") {\n    return toPlutusData(content);\n  }\n  if (type === \"CBOR\") {\n    return csl.PlutusData.from_hex(content as string);\n  }\n  return csl.PlutusData.from_json(\n    castRawDataToJsonString(content),\n    csl.PlutusDatumSchema.DetailedSchema,\n  );\n};\n\nexport const toNativeScript = (script: NativeScript) => {\n  const toNativeScripts = (scripts: NativeScript[]) => {\n    const nativeScripts = csl.NativeScripts.new();\n\n    scripts.forEach((script) => {\n      nativeScripts.add(toNativeScript(script));\n    });\n\n    return nativeScripts;\n  };\n\n  switch (script.type) {\n    case \"all\":\n      return csl.NativeScript.new_script_all(\n        csl.ScriptAll.new(toNativeScripts(script.scripts)),\n      );\n    case \"any\":\n      return csl.NativeScript.new_script_any(\n        csl.ScriptAny.new(toNativeScripts(script.scripts)),\n      );\n    case \"atLeast\":\n      return csl.NativeScript.new_script_n_of_k(\n        csl.ScriptNOfK.new(script.required, toNativeScripts(script.scripts)),\n      );\n    case \"after\":\n      return csl.NativeScript.new_timelock_start(\n        csl.TimelockStart.new_timelockstart(csl.BigNum.from_str(script.slot)),\n      );\n    case \"before\":\n      return csl.NativeScript.new_timelock_expiry(\n        csl.TimelockExpiry.new_timelockexpiry(csl.BigNum.from_str(script.slot)),\n      );\n    case \"sig\":\n      return csl.NativeScript.new_script_pubkey(\n        csl.ScriptPubkey.new(deserializeEd25519KeyHash(script.keyHash)),\n      );\n  }\n};\n\nexport const toCslValue = (assets: Asset[]): csl.Value => {\n  let cslValue: csl.Value | undefined = undefined;\n  let multiAsset: csl.MultiAsset = csl.MultiAsset.new();\n  for (const asset of assets) {\n    if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n      cslValue = csl.Value.new(csl.BigNum.from_str(asset.quantity));\n    } else {\n      const policyId = csl.ScriptHash.from_hex(asset.unit.slice(0, 56));\n      const assetName = csl.AssetName.new(\n        Buffer.from(asset.unit.slice(56), \"hex\"),\n      );\n      const quantity = csl.BigNum.from_str(asset.quantity);\n      multiAsset.set_asset(policyId, assetName, quantity);\n    }\n  }\n  if (cslValue !== undefined) {\n    cslValue.set_multiasset(multiAsset);\n  } else {\n    cslValue = csl.Value.new(csl.BigNum.from_str(\"0\"));\n    cslValue.set_multiasset(multiAsset);\n  }\n  return cslValue;\n};\n",
      "dependencies": [
        "toAddress",
        "toBaseAddress",
        "toEnterpriseAddress",
        "toRewardAddress",
        "fromBytes",
        "toBytes",
        "fromUTF8",
        "toUTF8",
        "fromLovelace",
        "toLovelace",
        "toScriptRef",
        "toPlutusData",
        "castRawDataToJsonString",
        "castDataToPlutusData",
        "toNativeScript",
        "toCslValue"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:deser.csl.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/deser/csl.ts",
      "name": "deser.csl.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * as csl from \"@sidan-lab/whisky-js-nodejs\";\n",
      "dependencies": [],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/deser/deserializer.ts",
      "name": "deser.deserializer.ts",
      "imports": [
        {
          "module": "deserializeAddress",
          "items": [],
          "line": 8,
          "raw": "export const deserializeAddress = (address: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "module": "deserializeBip32PrivateKey",
          "items": [],
          "line": 11,
          "raw": "export const deserializeBip32PrivateKey = (bip32PrivateKey: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "module": "deserializeDataHash",
          "items": [],
          "line": 14,
          "raw": "export const deserializeDataHash = (dataHash: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "module": "deserializeEd25519KeyHash",
          "items": [],
          "line": 17,
          "raw": "export const deserializeEd25519KeyHash = (ed25519KeyHash: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "module": "deserializeEd25519Signature",
          "items": [],
          "line": 20,
          "raw": "export const deserializeEd25519Signature = (ed25519Signature: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "module": "deserializeNativeScript",
          "items": [],
          "line": 23,
          "raw": "export const deserializeNativeScript = (nativeScript: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "module": "deserializePublicKey",
          "items": [],
          "line": 26,
          "raw": "export const deserializePublicKey = (publicKey: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "module": "deserializePlutusData",
          "items": [],
          "line": 29,
          "raw": "export const deserializePlutusData = (plutusData: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "module": "deserializePlutusScript",
          "items": [],
          "line": 32,
          "raw": "export const deserializePlutusScript = (",
          "source": "mesh-core-csl"
        },
        {
          "module": "deserializeScriptRef",
          "items": [],
          "line": 41,
          "raw": "export const deserializeScriptRef = (scriptRef: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "module": "deserializeScriptHash",
          "items": [],
          "line": 44,
          "raw": "export const deserializeScriptHash = (scriptHash: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "module": "deserializeTx",
          "items": [],
          "line": 47,
          "raw": "export const deserializeTx = (tx: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "module": "deserializeTxBody",
          "items": [],
          "line": 50,
          "raw": "export const deserializeTxBody = (txBody: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "module": "deserializeTxHash",
          "items": [],
          "line": 53,
          "raw": "export const deserializeTxHash = (txHash: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "module": "deserializeTxUnspentOutput",
          "items": [],
          "line": 56,
          "raw": "export const deserializeTxUnspentOutput = (txUnspentOutput: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "module": "deserializeTxWitnessSet",
          "items": [],
          "line": 59,
          "raw": "export const deserializeTxWitnessSet = (txWitnessSet: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "module": "deserializeValue",
          "items": [],
          "line": 62,
          "raw": "export const deserializeValue = (value: string) =>",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "deserializeAddress",
          "signature": "export const deserializeAddress = (address: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "address",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 8,
          "raw": "export const deserializeAddress = (address: string) =>",
          "source": "mesh-core-csl",
          "implementation": "export const deserializeAddress = (address: string) =>"
        },
        {
          "name": "deserializeBip32PrivateKey",
          "signature": "export const deserializeBip32PrivateKey = (bip32PrivateKey: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "bip32PrivateKey",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 11,
          "raw": "export const deserializeBip32PrivateKey = (bip32PrivateKey: string) =>",
          "source": "mesh-core-csl",
          "implementation": "export const deserializeBip32PrivateKey = (bip32PrivateKey: string) =>"
        },
        {
          "name": "deserializeDataHash",
          "signature": "export const deserializeDataHash = (dataHash: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "dataHash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 14,
          "raw": "export const deserializeDataHash = (dataHash: string) =>",
          "source": "mesh-core-csl",
          "implementation": "export const deserializeDataHash = (dataHash: string) =>"
        },
        {
          "name": "deserializeEd25519KeyHash",
          "signature": "export const deserializeEd25519KeyHash = (ed25519KeyHash: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "ed25519KeyHash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 17,
          "raw": "export const deserializeEd25519KeyHash = (ed25519KeyHash: string) =>",
          "source": "mesh-core-csl",
          "implementation": "export const deserializeEd25519KeyHash = (ed25519KeyHash: string) =>"
        },
        {
          "name": "deserializeEd25519Signature",
          "signature": "export const deserializeEd25519Signature = (ed25519Signature: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "ed25519Signature",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 20,
          "raw": "export const deserializeEd25519Signature = (ed25519Signature: string) =>",
          "source": "mesh-core-csl",
          "implementation": "export const deserializeEd25519Signature = (ed25519Signature: string) =>"
        },
        {
          "name": "deserializeNativeScript",
          "signature": "export const deserializeNativeScript = (nativeScript: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "nativeScript",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 23,
          "raw": "export const deserializeNativeScript = (nativeScript: string) =>",
          "source": "mesh-core-csl",
          "implementation": "export const deserializeNativeScript = (nativeScript: string) =>"
        },
        {
          "name": "deserializePublicKey",
          "signature": "export const deserializePublicKey = (publicKey: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "publicKey",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 26,
          "raw": "export const deserializePublicKey = (publicKey: string) =>",
          "source": "mesh-core-csl",
          "implementation": "export const deserializePublicKey = (publicKey: string) =>"
        },
        {
          "name": "deserializePlutusData",
          "signature": "export const deserializePlutusData = (plutusData: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "plutusData",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 29,
          "raw": "export const deserializePlutusData = (plutusData: string) =>",
          "source": "mesh-core-csl",
          "implementation": "export const deserializePlutusData = (plutusData: string) =>"
        },
        {
          "name": "deserializePlutusScript",
          "signature": "export const deserializePlutusScript = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 32,
          "raw": "export const deserializePlutusScript = (",
          "source": "mesh-core-csl",
          "implementation": "export const deserializePlutusScript = ("
        },
        {
          "name": "deserializeScriptRef",
          "signature": "export const deserializeScriptRef = (scriptRef: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "scriptRef",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 41,
          "raw": "export const deserializeScriptRef = (scriptRef: string) =>",
          "source": "mesh-core-csl",
          "implementation": "export const deserializeScriptRef = (scriptRef: string) =>"
        },
        {
          "name": "deserializeScriptHash",
          "signature": "export const deserializeScriptHash = (scriptHash: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "scriptHash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 44,
          "raw": "export const deserializeScriptHash = (scriptHash: string) =>",
          "source": "mesh-core-csl",
          "implementation": "export const deserializeScriptHash = (scriptHash: string) =>"
        },
        {
          "name": "deserializeTx",
          "signature": "export const deserializeTx = (tx: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "tx",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 47,
          "raw": "export const deserializeTx = (tx: string) =>",
          "source": "mesh-core-csl",
          "implementation": "export const deserializeTx = (tx: string) =>"
        },
        {
          "name": "deserializeTxBody",
          "signature": "export const deserializeTxBody = (txBody: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "txBody",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 50,
          "raw": "export const deserializeTxBody = (txBody: string) =>",
          "source": "mesh-core-csl",
          "implementation": "export const deserializeTxBody = (txBody: string) =>"
        },
        {
          "name": "deserializeTxHash",
          "signature": "export const deserializeTxHash = (txHash: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "txHash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 53,
          "raw": "export const deserializeTxHash = (txHash: string) =>",
          "source": "mesh-core-csl",
          "implementation": "export const deserializeTxHash = (txHash: string) =>"
        },
        {
          "name": "deserializeTxUnspentOutput",
          "signature": "export const deserializeTxUnspentOutput = (txUnspentOutput: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "txUnspentOutput",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 56,
          "raw": "export const deserializeTxUnspentOutput = (txUnspentOutput: string) =>",
          "source": "mesh-core-csl",
          "implementation": "export const deserializeTxUnspentOutput = (txUnspentOutput: string) =>"
        },
        {
          "name": "deserializeTxWitnessSet",
          "signature": "export const deserializeTxWitnessSet = (txWitnessSet: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "txWitnessSet",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 59,
          "raw": "export const deserializeTxWitnessSet = (txWitnessSet: string) =>",
          "source": "mesh-core-csl",
          "implementation": "export const deserializeTxWitnessSet = (txWitnessSet: string) =>"
        },
        {
          "name": "deserializeValue",
          "signature": "export const deserializeValue = (value: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "value",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 62,
          "raw": "export const deserializeValue = (value: string) =>",
          "source": "mesh-core-csl",
          "implementation": "export const deserializeValue = (value: string) =>"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "deserializeAddress",
          "type": "any",
          "value": "(address: string) =>",
          "isPublic": true,
          "line": 8,
          "raw": "export const deserializeAddress = (address: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "name": "deserializeBip32PrivateKey",
          "type": "any",
          "value": "(bip32PrivateKey: string) =>",
          "isPublic": true,
          "line": 11,
          "raw": "export const deserializeBip32PrivateKey = (bip32PrivateKey: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "name": "deserializeDataHash",
          "type": "any",
          "value": "(dataHash: string) =>",
          "isPublic": true,
          "line": 14,
          "raw": "export const deserializeDataHash = (dataHash: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "name": "deserializeEd25519KeyHash",
          "type": "any",
          "value": "(ed25519KeyHash: string) =>",
          "isPublic": true,
          "line": 17,
          "raw": "export const deserializeEd25519KeyHash = (ed25519KeyHash: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "name": "deserializeEd25519Signature",
          "type": "any",
          "value": "(ed25519Signature: string) =>",
          "isPublic": true,
          "line": 20,
          "raw": "export const deserializeEd25519Signature = (ed25519Signature: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "name": "deserializeNativeScript",
          "type": "any",
          "value": "(nativeScript: string) =>",
          "isPublic": true,
          "line": 23,
          "raw": "export const deserializeNativeScript = (nativeScript: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "name": "deserializePublicKey",
          "type": "any",
          "value": "(publicKey: string) =>",
          "isPublic": true,
          "line": 26,
          "raw": "export const deserializePublicKey = (publicKey: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "name": "deserializePlutusData",
          "type": "any",
          "value": "(plutusData: string) =>",
          "isPublic": true,
          "line": 29,
          "raw": "export const deserializePlutusData = (plutusData: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "name": "deserializePlutusScript",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 32,
          "raw": "export const deserializePlutusScript = (",
          "source": "mesh-core-csl"
        },
        {
          "name": "deserializeScriptRef",
          "type": "any",
          "value": "(scriptRef: string) =>",
          "isPublic": true,
          "line": 41,
          "raw": "export const deserializeScriptRef = (scriptRef: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "name": "deserializeScriptHash",
          "type": "any",
          "value": "(scriptHash: string) =>",
          "isPublic": true,
          "line": 44,
          "raw": "export const deserializeScriptHash = (scriptHash: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "name": "deserializeTx",
          "type": "any",
          "value": "(tx: string) =>",
          "isPublic": true,
          "line": 47,
          "raw": "export const deserializeTx = (tx: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "name": "deserializeTxBody",
          "type": "any",
          "value": "(txBody: string) =>",
          "isPublic": true,
          "line": 50,
          "raw": "export const deserializeTxBody = (txBody: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "name": "deserializeTxHash",
          "type": "any",
          "value": "(txHash: string) =>",
          "isPublic": true,
          "line": 53,
          "raw": "export const deserializeTxHash = (txHash: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "name": "deserializeTxUnspentOutput",
          "type": "any",
          "value": "(txUnspentOutput: string) =>",
          "isPublic": true,
          "line": 56,
          "raw": "export const deserializeTxUnspentOutput = (txUnspentOutput: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "name": "deserializeTxWitnessSet",
          "type": "any",
          "value": "(txWitnessSet: string) =>",
          "isPublic": true,
          "line": 59,
          "raw": "export const deserializeTxWitnessSet = (txWitnessSet: string) =>",
          "source": "mesh-core-csl"
        },
        {
          "name": "deserializeValue",
          "type": "any",
          "value": "(value: string) =>",
          "isPublic": true,
          "line": 62,
          "raw": "export const deserializeValue = (value: string) =>",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "/* eslint-disable import/no-cycle */\nimport { LanguageVersion } from \"@meshsdk/common\";\n\nimport { LANGUAGE_VERSIONS } from \"./constants\";\nimport { toBytes } from \"./converter\";\nimport { csl } from \"./csl\";\n\nexport const deserializeAddress = (address: string) =>\n  csl.Address.from_bytes(toBytes(address));\n\nexport const deserializeBip32PrivateKey = (bip32PrivateKey: string) =>\n  csl.Bip32PrivateKey.from_bytes(toBytes(bip32PrivateKey));\n\nexport const deserializeDataHash = (dataHash: string) =>\n  csl.DataHash.from_bytes(toBytes(dataHash));\n\nexport const deserializeEd25519KeyHash = (ed25519KeyHash: string) =>\n  csl.Ed25519KeyHash.from_bytes(toBytes(ed25519KeyHash));\n\nexport const deserializeEd25519Signature = (ed25519Signature: string) =>\n  csl.Ed25519Signature.from_bytes(toBytes(ed25519Signature));\n\nexport const deserializeNativeScript = (nativeScript: string) =>\n  csl.NativeScript.from_bytes(toBytes(nativeScript));\n\nexport const deserializePublicKey = (publicKey: string) =>\n  csl.PublicKey.from_bytes(toBytes(publicKey));\n\nexport const deserializePlutusData = (plutusData: string) =>\n  csl.PlutusData.from_bytes(toBytes(plutusData));\n\nexport const deserializePlutusScript = (\n  plutusScript: string,\n  version: LanguageVersion,\n) =>\n  csl.PlutusScript.from_hex_with_version(\n    plutusScript,\n    LANGUAGE_VERSIONS[version],\n  );\n\nexport const deserializeScriptRef = (scriptRef: string) =>\n  csl.ScriptRef.from_bytes(toBytes(scriptRef));\n\nexport const deserializeScriptHash = (scriptHash: string) =>\n  csl.ScriptHash.from_bytes(toBytes(scriptHash));\n\nexport const deserializeTx = (tx: string) =>\n  csl.Transaction.from_bytes(toBytes(tx));\n\nexport const deserializeTxBody = (txBody: string) =>\n  csl.TransactionBody.from_bytes(toBytes(txBody));\n\nexport const deserializeTxHash = (txHash: string) =>\n  csl.TransactionHash.from_bytes(toBytes(txHash));\n\nexport const deserializeTxUnspentOutput = (txUnspentOutput: string) =>\n  csl.TransactionUnspentOutput.from_bytes(toBytes(txUnspentOutput));\n\nexport const deserializeTxWitnessSet = (txWitnessSet: string) =>\n  csl.TransactionWitnessSet.from_bytes(toBytes(txWitnessSet));\n\nexport const deserializeValue = (value: string) =>\n  csl.Value.from_bytes(toBytes(value));\n",
      "dependencies": [
        "deserializeAddress",
        "deserializeBip32PrivateKey",
        "deserializeDataHash",
        "deserializeEd25519KeyHash",
        "deserializeEd25519Signature",
        "deserializeNativeScript",
        "deserializePublicKey",
        "deserializePlutusData",
        "deserializePlutusScript",
        "deserializeScriptRef",
        "deserializeScriptHash",
        "deserializeTx",
        "deserializeTxBody",
        "deserializeTxHash",
        "deserializeTxUnspentOutput",
        "deserializeTxWitnessSet",
        "deserializeValue"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:deser.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/deser/index.ts",
      "name": "deser.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./deserializer\";\nexport * from \"./converter\";\nexport * from \"./csl\";\nexport * from \"./constants\";\nexport * from \"./resolver\";\n",
      "dependencies": [],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/deser/resolver.ts",
      "name": "deser.resolver.ts",
      "imports": [
        {
          "module": "resolveStakeKeyHash",
          "items": [],
          "line": 22,
          "raw": "export const resolveStakeKeyHash = (bech32: string) => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "resolvePrivateKey",
          "items": [],
          "line": 37,
          "raw": "export const resolvePrivateKey = (words: string[]) => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "resolveNativeScriptAddress",
          "items": [],
          "line": 57,
          "raw": "export const resolveNativeScriptAddress = (",
          "source": "mesh-core-csl"
        },
        {
          "module": "resolvePlutusScriptAddress",
          "items": [],
          "line": 71,
          "raw": "export const resolvePlutusScriptAddress = (",
          "source": "mesh-core-csl"
        },
        {
          "module": "resolveNativeScriptHash",
          "items": [],
          "line": 85,
          "raw": "export const resolveNativeScriptHash = (script: NativeScript) => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "resolveScriptHashDRepId",
          "items": [],
          "line": 89,
          "raw": "export const resolveScriptHashDRepId = (scriptHash: string) => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "resolveRewardAddress",
          "items": [],
          "line": 95,
          "raw": "export const resolveRewardAddress = (bech32: string) => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "resolveDataHash",
          "items": [],
          "line": 122,
          "raw": "export const resolveDataHash = (",
          "source": "mesh-core-csl"
        },
        {
          "module": "resolveNativeScriptHex",
          "items": [],
          "line": 134,
          "raw": "export const resolveNativeScriptHex = (script: NativeScript) => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "serializePoolId",
          "items": [],
          "line": 138,
          "raw": "export const serializePoolId = (hash: string) => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "resolveScriptRef",
          "items": [],
          "line": 142,
          "raw": "export const resolveScriptRef = (script: PlutusScript | NativeScript) => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "resolveEd25519KeyHash",
          "items": [],
          "line": 146,
          "raw": "export const resolveEd25519KeyHash = (bech32: string) => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "resolveStakeKeyHash",
          "signature": "export const resolveStakeKeyHash = (bech32: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "bech32",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 22,
          "raw": "export const resolveStakeKeyHash = (bech32: string) => {\n  try {\n    const stakeKeyHash = [\n      toBaseAddress(bech32)?.stake_cred().to_keyhash(),\n      toRewardAddress(bech32)?.payment_cred().to_keyhash(),\n    ].find((kh) => kh !== undefined);\n\n    if (stakeKeyHash !== undefined) return stakeKeyHash.to_hex();\n\n    throw new Error(`Couldn't resolve stake key hash from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveStakeKeyHash: ${error}.`);\n  }\n};",
          "source": "mesh-core-csl",
          "implementation": "export const resolveStakeKeyHash = (bech32: string) => {\n  try {\n    const stakeKeyHash = [\n      toBaseAddress(bech32)?.stake_cred().to_keyhash(),\n      toRewardAddress(bech32)?.payment_cred().to_keyhash(),\n    ].find((kh) => kh !== undefined);\n\n    if (stakeKeyHash !== undefined) return stakeKeyHash.to_hex();\n\n    throw new Error(`Couldn't resolve stake key hash from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveStakeKeyHash: ${error}.`);\n  }\n};"
        },
        {
          "name": "resolvePrivateKey",
          "signature": "export const resolvePrivateKey = (words: string[]) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "words",
              "type": "string[]",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 37,
          "raw": "export const resolvePrivateKey = (words: string[]) => {\n  const buildBip32PrivateKey = (\n    entropy: string,\n    password = \"\",\n  ): csl.Bip32PrivateKey => {\n    return csl.Bip32PrivateKey.from_bip39_entropy(\n      toBytes(entropy),\n      toBytes(fromUTF8(password)),\n    );\n  };\n\n  const entropy = mnemonicToEntropy(words.join(\" \"));\n  const bip32PrivateKey = buildBip32PrivateKey(entropy);\n  const bech32PrivateKey = bip32PrivateKey.to_bech32();\n\n  bip32PrivateKey.free();\n\n  return bech32PrivateKey;\n};",
          "source": "mesh-core-csl",
          "implementation": "export const resolvePrivateKey = (words: string[]) => {\n  const buildBip32PrivateKey = (\n    entropy: string,\n    password = \"\",\n  ): csl.Bip32PrivateKey => {\n    return csl.Bip32PrivateKey.from_bip39_entropy(\n      toBytes(entropy),\n      toBytes(fromUTF8(password)),\n    );\n  };\n\n  const entropy = mnemonicToEntropy(words.join(\" \"));\n  const bip32PrivateKey = buildBip32PrivateKey(entropy);\n  const bech32PrivateKey = bip32PrivateKey.to_bech32();\n\n  bip32PrivateKey.free();\n\n  return bech32PrivateKey;\n};"
        },
        {
          "name": "buildBip32PrivateKey",
          "signature": "const buildBip32PrivateKey = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 38,
          "raw": "  const buildBip32PrivateKey = (\n    entropy: string,\n    password = \"\",\n  ): csl.Bip32PrivateKey => {\n    return csl.Bip32PrivateKey.from_bip39_entropy(\n      toBytes(entropy),\n      toBytes(fromUTF8(password)),\n    );\n  };",
          "source": "mesh-core-csl",
          "implementation": "  const buildBip32PrivateKey = (\n    entropy: string,\n    password = \"\",\n  ): csl.Bip32PrivateKey => {\n    return csl.Bip32PrivateKey.from_bip39_entropy(\n      toBytes(entropy),\n      toBytes(fromUTF8(password)),\n    );\n  };"
        },
        {
          "name": "resolveNativeScriptAddress",
          "signature": "export const resolveNativeScriptAddress = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 57,
          "raw": "export const resolveNativeScriptAddress = (\n  script: NativeScript,\n  networkId = 0,\n) => {\n  const nativeScript = toNativeScript(script);\n\n  const enterpriseAddress = csl.EnterpriseAddress.new(\n    networkId,\n    csl.Credential.from_scripthash(nativeScript.hash()),\n  );\n\n  return enterpriseAddress.to_address().to_bech32();\n};",
          "source": "mesh-core-csl",
          "implementation": "export const resolveNativeScriptAddress = (\n  script: NativeScript,\n  networkId = 0,\n) => {\n  const nativeScript = toNativeScript(script);\n\n  const enterpriseAddress = csl.EnterpriseAddress.new(\n    networkId,\n    csl.Credential.from_scripthash(nativeScript.hash()),\n  );\n\n  return enterpriseAddress.to_address().to_bech32();\n};"
        },
        {
          "name": "resolvePlutusScriptAddress",
          "signature": "export const resolvePlutusScriptAddress = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 71,
          "raw": "export const resolvePlutusScriptAddress = (\n  script: PlutusScript,\n  networkId = 0,\n) => {\n  const plutusScript = deserializePlutusScript(script.code, script.version);\n\n  const enterpriseAddress = csl.EnterpriseAddress.new(\n    networkId,\n    csl.Credential.from_scripthash(plutusScript.hash()),\n  );\n\n  return enterpriseAddress.to_address().to_bech32();\n};",
          "source": "mesh-core-csl",
          "implementation": "export const resolvePlutusScriptAddress = (\n  script: PlutusScript,\n  networkId = 0,\n) => {\n  const plutusScript = deserializePlutusScript(script.code, script.version);\n\n  const enterpriseAddress = csl.EnterpriseAddress.new(\n    networkId,\n    csl.Credential.from_scripthash(plutusScript.hash()),\n  );\n\n  return enterpriseAddress.to_address().to_bech32();\n};"
        },
        {
          "name": "resolveNativeScriptHash",
          "signature": "export const resolveNativeScriptHash = (script: NativeScript) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "script",
              "type": "NativeScript",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 85,
          "raw": "export const resolveNativeScriptHash = (script: NativeScript) => {\n  return toNativeScript(script).hash().to_hex();\n};",
          "source": "mesh-core-csl",
          "implementation": "export const resolveNativeScriptHash = (script: NativeScript) => {\n  return toNativeScript(script).hash().to_hex();\n};"
        },
        {
          "name": "resolveScriptHashDRepId",
          "signature": "export const resolveScriptHashDRepId = (scriptHash: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "scriptHash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 89,
          "raw": "export const resolveScriptHashDRepId = (scriptHash: string) => {\n  return csl.DRep.new_script_hash(\n    csl.ScriptHash.from_hex(scriptHash),\n  ).to_bech32(true);\n};",
          "source": "mesh-core-csl",
          "implementation": "export const resolveScriptHashDRepId = (scriptHash: string) => {\n  return csl.DRep.new_script_hash(\n    csl.ScriptHash.from_hex(scriptHash),\n  ).to_bech32(true);\n};"
        },
        {
          "name": "resolveRewardAddress",
          "signature": "export const resolveRewardAddress = (bech32: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "bech32",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 95,
          "raw": "export const resolveRewardAddress = (bech32: string) => {\n  const buildRewardAddress = (\n    networkId: number,\n    stakeKeyHash: csl.Ed25519KeyHash,\n  ): csl.RewardAddress => {\n    return csl.RewardAddress.new(\n      networkId,\n      csl.Credential.from_keyhash(stakeKeyHash),\n    );\n  };\n\n  try {\n    const address = toAddress(bech32);\n    const baseAddress = toBaseAddress(bech32);\n    const stakeKeyHash = baseAddress?.stake_cred().to_keyhash();\n\n    if (stakeKeyHash !== undefined)\n      return buildRewardAddress(address.network_id(), stakeKeyHash)\n        .to_address()\n        .to_bech32();\n\n    throw new Error(`Couldn't resolve reward address from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveRewardAddress: ${error}.`);\n  }\n};",
          "source": "mesh-core-csl",
          "implementation": "export const resolveRewardAddress = (bech32: string) => {\n  const buildRewardAddress = (\n    networkId: number,\n    stakeKeyHash: csl.Ed25519KeyHash,\n  ): csl.RewardAddress => {\n    return csl.RewardAddress.new(\n      networkId,\n      csl.Credential.from_keyhash(stakeKeyHash),\n    );\n  };\n\n  try {\n    const address = toAddress(bech32);\n    const baseAddress = toBaseAddress(bech32);\n    const stakeKeyHash = baseAddress?.stake_cred().to_keyhash();\n\n    if (stakeKeyHash !== undefined)\n      return buildRewardAddress(address.network_id(), stakeKeyHash)\n        .to_address()\n        .to_bech32();\n\n    throw new Error(`Couldn't resolve reward address from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveRewardAddress: ${error}.`);\n  }\n};"
        },
        {
          "name": "buildRewardAddress",
          "signature": "const buildRewardAddress = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 96,
          "raw": "  const buildRewardAddress = (\n    networkId: number,\n    stakeKeyHash: csl.Ed25519KeyHash,\n  ): csl.RewardAddress => {\n    return csl.RewardAddress.new(\n      networkId,\n      csl.Credential.from_keyhash(stakeKeyHash),\n    );\n  };",
          "source": "mesh-core-csl",
          "implementation": "  const buildRewardAddress = (\n    networkId: number,\n    stakeKeyHash: csl.Ed25519KeyHash,\n  ): csl.RewardAddress => {\n    return csl.RewardAddress.new(\n      networkId,\n      csl.Credential.from_keyhash(stakeKeyHash),\n    );\n  };"
        },
        {
          "name": "resolveDataHash",
          "signature": "export const resolveDataHash = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 122,
          "raw": "export const resolveDataHash = (\n  rawData: BuilderData[\"content\"],\n  type: PlutusDataType = \"Mesh\",\n) => {\n  const plutusData = castDataToPlutusData({\n    content: rawData,\n    type,\n  } as BuilderData);\n  const dataHash = csl.hash_plutus_data(plutusData);\n  return dataHash.to_hex();\n};",
          "source": "mesh-core-csl",
          "implementation": "export const resolveDataHash = (\n  rawData: BuilderData[\"content\"],\n  type: PlutusDataType = \"Mesh\",\n) => {\n  const plutusData = castDataToPlutusData({\n    content: rawData,\n    type,\n  } as BuilderData);\n  const dataHash = csl.hash_plutus_data(plutusData);\n  return dataHash.to_hex();\n};"
        },
        {
          "name": "resolveNativeScriptHex",
          "signature": "export const resolveNativeScriptHex = (script: NativeScript) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "script",
              "type": "NativeScript",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 134,
          "raw": "export const resolveNativeScriptHex = (script: NativeScript) => {\n  return toNativeScript(script).to_hex();\n};",
          "source": "mesh-core-csl",
          "implementation": "export const resolveNativeScriptHex = (script: NativeScript) => {\n  return toNativeScript(script).to_hex();\n};"
        },
        {
          "name": "serializePoolId",
          "signature": "export const serializePoolId = (hash: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "hash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 138,
          "raw": "export const serializePoolId = (hash: string) => {\n  return csl.Ed25519KeyHash.from_hex(hash).to_bech32(\"pool1\");\n};",
          "source": "mesh-core-csl",
          "implementation": "export const serializePoolId = (hash: string) => {\n  return csl.Ed25519KeyHash.from_hex(hash).to_bech32(\"pool1\");\n};"
        },
        {
          "name": "resolveScriptRef",
          "signature": "export const resolveScriptRef = (script: PlutusScript | NativeScript) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "script",
              "type": "PlutusScript | NativeScript",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 142,
          "raw": "export const resolveScriptRef = (script: PlutusScript | NativeScript) => {\n  return toScriptRef(script).to_hex();\n};",
          "source": "mesh-core-csl",
          "implementation": "export const resolveScriptRef = (script: PlutusScript | NativeScript) => {\n  return toScriptRef(script).to_hex();\n};"
        },
        {
          "name": "resolveEd25519KeyHash",
          "signature": "export const resolveEd25519KeyHash = (bech32: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "bech32",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 146,
          "raw": "export const resolveEd25519KeyHash = (bech32: string) => {\n  return csl.Ed25519KeyHash.from_bech32(bech32).to_hex();\n};",
          "source": "mesh-core-csl",
          "implementation": "export const resolveEd25519KeyHash = (bech32: string) => {\n  return csl.Ed25519KeyHash.from_bech32(bech32).to_hex();\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "resolveStakeKeyHash",
          "type": "any",
          "value": "(bech32: string) => {",
          "isPublic": true,
          "line": 22,
          "raw": "export const resolveStakeKeyHash = (bech32: string) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "stakeKeyHash",
          "type": "any",
          "value": "[",
          "isPublic": true,
          "line": 24,
          "raw": "const stakeKeyHash = [",
          "source": "mesh-core-csl"
        },
        {
          "name": "resolvePrivateKey",
          "type": "any",
          "value": "(words: string[]) => {",
          "isPublic": true,
          "line": 37,
          "raw": "export const resolvePrivateKey = (words: string[]) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "buildBip32PrivateKey",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 38,
          "raw": "const buildBip32PrivateKey = (",
          "source": "mesh-core-csl"
        },
        {
          "name": "entropy",
          "type": "any",
          "value": "mnemonicToEntropy(words.join(\" \"));",
          "isPublic": true,
          "line": 48,
          "raw": "const entropy = mnemonicToEntropy(words.join(\" \"));",
          "source": "mesh-core-csl"
        },
        {
          "name": "bip32PrivateKey",
          "type": "any",
          "value": "buildBip32PrivateKey(entropy);",
          "isPublic": true,
          "line": 49,
          "raw": "const bip32PrivateKey = buildBip32PrivateKey(entropy);",
          "source": "mesh-core-csl"
        },
        {
          "name": "bech32PrivateKey",
          "type": "any",
          "value": "bip32PrivateKey.to_bech32();",
          "isPublic": true,
          "line": 50,
          "raw": "const bech32PrivateKey = bip32PrivateKey.to_bech32();",
          "source": "mesh-core-csl"
        },
        {
          "name": "resolveNativeScriptAddress",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 57,
          "raw": "export const resolveNativeScriptAddress = (",
          "source": "mesh-core-csl"
        },
        {
          "name": "nativeScript",
          "type": "any",
          "value": "toNativeScript(script);",
          "isPublic": true,
          "line": 61,
          "raw": "const nativeScript = toNativeScript(script);",
          "source": "mesh-core-csl"
        },
        {
          "name": "enterpriseAddress",
          "type": "any",
          "value": "csl.EnterpriseAddress.new(",
          "isPublic": true,
          "line": 63,
          "raw": "const enterpriseAddress = csl.EnterpriseAddress.new(",
          "source": "mesh-core-csl"
        },
        {
          "name": "resolvePlutusScriptAddress",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 71,
          "raw": "export const resolvePlutusScriptAddress = (",
          "source": "mesh-core-csl"
        },
        {
          "name": "plutusScript",
          "type": "any",
          "value": "deserializePlutusScript(script.code, script.version);",
          "isPublic": true,
          "line": 75,
          "raw": "const plutusScript = deserializePlutusScript(script.code, script.version);",
          "source": "mesh-core-csl"
        },
        {
          "name": "enterpriseAddress",
          "type": "any",
          "value": "csl.EnterpriseAddress.new(",
          "isPublic": true,
          "line": 77,
          "raw": "const enterpriseAddress = csl.EnterpriseAddress.new(",
          "source": "mesh-core-csl"
        },
        {
          "name": "resolveNativeScriptHash",
          "type": "any",
          "value": "(script: NativeScript) => {",
          "isPublic": true,
          "line": 85,
          "raw": "export const resolveNativeScriptHash = (script: NativeScript) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "resolveScriptHashDRepId",
          "type": "any",
          "value": "(scriptHash: string) => {",
          "isPublic": true,
          "line": 89,
          "raw": "export const resolveScriptHashDRepId = (scriptHash: string) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "resolveRewardAddress",
          "type": "any",
          "value": "(bech32: string) => {",
          "isPublic": true,
          "line": 95,
          "raw": "export const resolveRewardAddress = (bech32: string) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "buildRewardAddress",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 96,
          "raw": "const buildRewardAddress = (",
          "source": "mesh-core-csl"
        },
        {
          "name": "address",
          "type": "any",
          "value": "toAddress(bech32);",
          "isPublic": true,
          "line": 107,
          "raw": "const address = toAddress(bech32);",
          "source": "mesh-core-csl"
        },
        {
          "name": "baseAddress",
          "type": "any",
          "value": "toBaseAddress(bech32);",
          "isPublic": true,
          "line": 108,
          "raw": "const baseAddress = toBaseAddress(bech32);",
          "source": "mesh-core-csl"
        },
        {
          "name": "stakeKeyHash",
          "type": "any",
          "value": "baseAddress?.stake_cred().to_keyhash();",
          "isPublic": true,
          "line": 109,
          "raw": "const stakeKeyHash = baseAddress?.stake_cred().to_keyhash();",
          "source": "mesh-core-csl"
        },
        {
          "name": "resolveDataHash",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 122,
          "raw": "export const resolveDataHash = (",
          "source": "mesh-core-csl"
        },
        {
          "name": "plutusData",
          "type": "any",
          "value": "castDataToPlutusData({",
          "isPublic": true,
          "line": 126,
          "raw": "const plutusData = castDataToPlutusData({",
          "source": "mesh-core-csl"
        },
        {
          "name": "dataHash",
          "type": "any",
          "value": "csl.hash_plutus_data(plutusData);",
          "isPublic": true,
          "line": 130,
          "raw": "const dataHash = csl.hash_plutus_data(plutusData);",
          "source": "mesh-core-csl"
        },
        {
          "name": "resolveNativeScriptHex",
          "type": "any",
          "value": "(script: NativeScript) => {",
          "isPublic": true,
          "line": 134,
          "raw": "export const resolveNativeScriptHex = (script: NativeScript) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "serializePoolId",
          "type": "any",
          "value": "(hash: string) => {",
          "isPublic": true,
          "line": 138,
          "raw": "export const serializePoolId = (hash: string) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "resolveScriptRef",
          "type": "any",
          "value": "(script: PlutusScript | NativeScript) => {",
          "isPublic": true,
          "line": 142,
          "raw": "export const resolveScriptRef = (script: PlutusScript | NativeScript) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "resolveEd25519KeyHash",
          "type": "any",
          "value": "(bech32: string) => {",
          "isPublic": true,
          "line": 146,
          "raw": "export const resolveEd25519KeyHash = (bech32: string) => {",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  BuilderData,\n  mnemonicToEntropy,\n  NativeScript,\n  PlutusDataType,\n  PlutusScript,\n} from \"@meshsdk/common\";\n\nimport {\n  castDataToPlutusData,\n  deserializePlutusScript,\n  fromUTF8,\n  toAddress,\n  toBaseAddress,\n  toBytes,\n  toNativeScript,\n  toRewardAddress,\n  toScriptRef,\n} from \".\";\nimport { csl } from \"./csl\";\n\nexport const resolveStakeKeyHash = (bech32: string) => {\n  try {\n    const stakeKeyHash = [\n      toBaseAddress(bech32)?.stake_cred().to_keyhash(),\n      toRewardAddress(bech32)?.payment_cred().to_keyhash(),\n    ].find((kh) => kh !== undefined);\n\n    if (stakeKeyHash !== undefined) return stakeKeyHash.to_hex();\n\n    throw new Error(`Couldn't resolve stake key hash from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveStakeKeyHash: ${error}.`);\n  }\n};\n\nexport const resolvePrivateKey = (words: string[]) => {\n  const buildBip32PrivateKey = (\n    entropy: string,\n    password = \"\",\n  ): csl.Bip32PrivateKey => {\n    return csl.Bip32PrivateKey.from_bip39_entropy(\n      toBytes(entropy),\n      toBytes(fromUTF8(password)),\n    );\n  };\n\n  const entropy = mnemonicToEntropy(words.join(\" \"));\n  const bip32PrivateKey = buildBip32PrivateKey(entropy);\n  const bech32PrivateKey = bip32PrivateKey.to_bech32();\n\n  bip32PrivateKey.free();\n\n  return bech32PrivateKey;\n};\n\nexport const resolveNativeScriptAddress = (\n  script: NativeScript,\n  networkId = 0,\n) => {\n  const nativeScript = toNativeScript(script);\n\n  const enterpriseAddress = csl.EnterpriseAddress.new(\n    networkId,\n    csl.Credential.from_scripthash(nativeScript.hash()),\n  );\n\n  return enterpriseAddress.to_address().to_bech32();\n};\n\nexport const resolvePlutusScriptAddress = (\n  script: PlutusScript,\n  networkId = 0,\n) => {\n  const plutusScript = deserializePlutusScript(script.code, script.version);\n\n  const enterpriseAddress = csl.EnterpriseAddress.new(\n    networkId,\n    csl.Credential.from_scripthash(plutusScript.hash()),\n  );\n\n  return enterpriseAddress.to_address().to_bech32();\n};\n\nexport const resolveNativeScriptHash = (script: NativeScript) => {\n  return toNativeScript(script).hash().to_hex();\n};\n\nexport const resolveScriptHashDRepId = (scriptHash: string) => {\n  return csl.DRep.new_script_hash(\n    csl.ScriptHash.from_hex(scriptHash),\n  ).to_bech32(true);\n};\n\nexport const resolveRewardAddress = (bech32: string) => {\n  const buildRewardAddress = (\n    networkId: number,\n    stakeKeyHash: csl.Ed25519KeyHash,\n  ): csl.RewardAddress => {\n    return csl.RewardAddress.new(\n      networkId,\n      csl.Credential.from_keyhash(stakeKeyHash),\n    );\n  };\n\n  try {\n    const address = toAddress(bech32);\n    const baseAddress = toBaseAddress(bech32);\n    const stakeKeyHash = baseAddress?.stake_cred().to_keyhash();\n\n    if (stakeKeyHash !== undefined)\n      return buildRewardAddress(address.network_id(), stakeKeyHash)\n        .to_address()\n        .to_bech32();\n\n    throw new Error(`Couldn't resolve reward address from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveRewardAddress: ${error}.`);\n  }\n};\n\nexport const resolveDataHash = (\n  rawData: BuilderData[\"content\"],\n  type: PlutusDataType = \"Mesh\",\n) => {\n  const plutusData = castDataToPlutusData({\n    content: rawData,\n    type,\n  } as BuilderData);\n  const dataHash = csl.hash_plutus_data(plutusData);\n  return dataHash.to_hex();\n};\n\nexport const resolveNativeScriptHex = (script: NativeScript) => {\n  return toNativeScript(script).to_hex();\n};\n\nexport const serializePoolId = (hash: string) => {\n  return csl.Ed25519KeyHash.from_hex(hash).to_bech32(\"pool1\");\n};\n\nexport const resolveScriptRef = (script: PlutusScript | NativeScript) => {\n  return toScriptRef(script).to_hex();\n};\n\nexport const resolveEd25519KeyHash = (bech32: string) => {\n  return csl.Ed25519KeyHash.from_bech32(bech32).to_hex();\n};\n",
      "dependencies": [
        "resolveStakeKeyHash",
        "resolvePrivateKey",
        "resolveNativeScriptAddress",
        "resolvePlutusScriptAddress",
        "resolveNativeScriptHash",
        "resolveScriptHashDRepId",
        "resolveRewardAddress",
        "resolveDataHash",
        "resolveNativeScriptHex",
        "serializePoolId",
        "resolveScriptRef",
        "resolveEd25519KeyHash"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/index.ts",
      "name": "index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./utils\";\nexport * from \"./core\";\nexport * from \"./deser\";\nexport * from \"./offline-providers\";\n",
      "dependencies": [],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:offline-providers.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/offline-providers/index.ts",
      "name": "offline-providers.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./offline-evaluator\"\n",
      "dependencies": [],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:offline-providers.offline-evaluator.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/offline-providers/offline-evaluator.ts",
      "name": "offline-providers.offline-evaluator.ts",
      "imports": [
        {
          "module": "OfflineEvaluator",
          "items": [],
          "line": 69,
          "raw": "export class OfflineEvaluator implements IEvaluator {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [],
      "types": [],
      "constants": [
        {
          "name": "foundUtxos",
          "type": "any",
          "value": "new Set<string>();",
          "isPublic": true,
          "line": 116,
          "raw": "const foundUtxos = new Set<string>();",
          "source": "mesh-core-csl"
        },
        {
          "name": "outputs",
          "type": "any",
          "value": "getTransactionOutputs(tx);",
          "isPublic": true,
          "line": 122,
          "raw": "const outputs = getTransactionOutputs(tx);",
          "source": "mesh-core-csl"
        },
        {
          "name": "inputsToResolve",
          "type": "any",
          "value": "getTransactionInputs(tx).filter(",
          "isPublic": true,
          "line": 127,
          "raw": "const inputsToResolve = getTransactionInputs(tx).filter(",
          "source": "mesh-core-csl"
        },
        {
          "name": "txHashesSet",
          "type": "any",
          "value": "new Set(inputsToResolve.map((input) => input.txHash));",
          "isPublic": true,
          "line": 130,
          "raw": "const txHashesSet = new Set(inputsToResolve.map((input) => input.txHash));",
          "source": "mesh-core-csl"
        },
        {
          "name": "utxos",
          "type": "any",
          "value": "await this.fetcher.fetchUTxOs(txHash);",
          "isPublic": true,
          "line": 132,
          "raw": "const utxos = await this.fetcher.fetchUTxOs(txHash);",
          "source": "mesh-core-csl"
        },
        {
          "name": "missing",
          "type": "any",
          "value": "inputsToResolve.filter(",
          "isPublic": true,
          "line": 147,
          "raw": "const missing = inputsToResolve.filter(",
          "source": "mesh-core-csl"
        },
        {
          "name": "missingList",
          "type": "any",
          "value": "missing",
          "isPublic": true,
          "line": 151,
          "raw": "const missingList = missing",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  Action,\n  IEvaluator,\n  IFetcher,\n  Network,\n  SLOT_CONFIG_NETWORK,\n  SlotConfig,\n  UTxO,\n} from \"@meshsdk/common\";\n\nimport {\n  evaluateTransaction,\n  getTransactionInputs,\n  getTransactionOutputs,\n} from \"../utils\";\n\n/**\n * OfflineEvaluator implements the IEvaluator interface to provide offline evaluation of Plutus scripts.\n * This class evaluates Plutus scripts contained in Cardano transactions without requiring network connectivity,\n * determining their execution costs in terms of memory and CPU steps.\n *\n * Each script evaluation returns an Action object (excluding the redeemer data) that contains:\n * - tag: The type of script being executed (CERT | MINT | REWARD | SPEND | VOTE | PROPOSE)\n * - index: Execution index of the script within the transaction\n * - budget: Execution costs including:\n *   - mem: Memory units required\n *   - steps: CPU steps required\n *\n * Example usage:\n * ```typescript\n * import { OfflineEvaluator, OfflineFetcher } from '@meshsdk/core';\n *\n * // Create fetcher and evaluator instances\n * const fetcher = new OfflineFetcher();\n * const evaluator = new OfflineEvaluator(fetcher, 'preprod');\n *\n * // Add required UTXOs that the transaction references\n * fetcher.addUTxOs([\n *   {\n *     input: {\n *       txHash: \"1234...\",\n *       outputIndex: 0\n *     },\n *     output: {\n *       address: \"addr1...\",\n *       amount: [{ unit: \"lovelace\", quantity: \"1000000\" }],\n *       scriptHash: \"abcd...\" // If this is a script UTXO\n *     }\n *   }\n * ]);\n *\n * // Evaluate Plutus scripts in a transaction\n * try {\n *   const actions = await evaluator.evaluateTx(transactionCbor);\n *   // Example result for a minting script:\n *   // [{\n *   //   index: 0,\n *   //   tag: \"MINT\",\n *   //   budget: {\n *   //     mem: 508703,    // Memory units used\n *   //     steps: 164980381 // CPU steps used\n *   //   }\n *   // }]\n * } catch (error) {\n *   console.error('Plutus script evaluation failed:', error);\n * }\n * ```\n */\nexport class OfflineEvaluator implements IEvaluator {\n  private readonly fetcher: IFetcher;\n  private readonly network: Network;\n  public slotConfig: Omit<Omit<SlotConfig, \"startEpoch\">, \"epochLength\">;\n\n  /**\n   * Creates a new instance of OfflineEvaluator.\n   * @param fetcher - An implementation of IFetcher to resolve transaction UTXOs\n   * @param network - The network to evaluate scripts for\n   * @param slotConfig - Slot configuration for the network (optional, defaults to network-specific values)\n   */\n  constructor(\n    fetcher: IFetcher,\n    network: Network,\n    slotConfig?: Omit<Omit<SlotConfig, \"startEpoch\">, \"epochLength\">,\n  ) {\n    this.fetcher = fetcher;\n    this.network = network;\n    this.slotConfig = slotConfig ?? {\n      slotLength: SLOT_CONFIG_NETWORK[network].slotLength,\n      zeroSlot: SLOT_CONFIG_NETWORK[network].zeroSlot,\n      zeroTime: SLOT_CONFIG_NETWORK[network].zeroTime,\n    };\n  }\n\n  /**\n   * Evaluates Plutus scripts in a transaction by resolving its input UTXOs and calculating execution costs.\n   *\n   * The method performs these steps:\n   * 1. Extracts input references from the transaction\n   * 2. Resolves the corresponding UTXOs using the fetcher\n   * 3. Verifies all required UTXOs are available\n   * 4. Evaluates each Plutus script to determine its memory and CPU costs\n   *\n   * @param tx - Transaction in CBOR hex format\n   * @returns Promise resolving to array of script evaluation results, each containing:\n   *   - tag: Type of script (CERT | MINT | REWARD | SPEND | VOTE | PROPOSE)\n   *   - index: Script execution index\n   *   - budget: Memory units and CPU steps required\n   * @throws Error if any required UTXOs cannot be resolved or if script evaluation fails\n   */\n  async evaluateTx(\n    tx: string,\n    additionalUtxos: UTxO[],\n    additionalTxs: string[],\n  ): Promise<Omit<Action, \"data\">[]> {\n    // Track which utxos is resolved\n    const foundUtxos = new Set<string>();\n\n    for (const utxo of additionalUtxos) {\n      foundUtxos.add(`${utxo.input.txHash}:${utxo.input.outputIndex}`);\n    }\n    for (const tx of additionalTxs) {\n      const outputs = getTransactionOutputs(tx);\n      for (const output of outputs) {\n        foundUtxos.add(`${output.input.txHash}:${output.input.outputIndex}`);\n      }\n    }\n    const inputsToResolve = getTransactionInputs(tx).filter(\n      (input) => !foundUtxos.has(`${input.txHash}:${input.outputIndex}`),\n    );\n    const txHashesSet = new Set(inputsToResolve.map((input) => input.txHash));\n    for (const txHash of txHashesSet) {\n      const utxos = await this.fetcher.fetchUTxOs(txHash);\n      for (const utxo of utxos) {\n        if (utxo)\n          if (\n            inputsToResolve.find(\n              (input) =>\n                input.txHash === txHash &&\n                input.outputIndex === utxo.input.outputIndex,\n            )\n          ) {\n            additionalUtxos.push(utxo);\n            foundUtxos.add(`${utxo.input.txHash}:${utxo.input.outputIndex}`);\n          }\n      }\n    }\n    const missing = inputsToResolve.filter(\n      (input) => !foundUtxos.has(`${input.txHash}:${input.outputIndex}`),\n    );\n    if (missing.length > 0) {\n      const missingList = missing\n        .map((m) => `${m.txHash}:${m.outputIndex}`)\n        .join(\", \");\n      throw new Error(\n        `Can't resolve these UTXOs to execute plutus scripts: ${missingList}`,\n      );\n    }\n    return evaluateTransaction(\n      tx,\n      additionalUtxos,\n      additionalTxs,\n      this.network,\n      this.slotConfig,\n    );\n  }\n}\n",
      "dependencies": [
        "OfflineEvaluator"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:parser.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/parser/index.ts",
      "name": "parser.index.ts",
      "imports": [
        {
          "module": "CSLParser",
          "items": [],
          "line": 8,
          "raw": "export class CSLParser {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [],
      "types": [],
      "constants": [
        {
          "name": "jsUtxos",
          "type": "any",
          "value": "JsVecString.new();",
          "isPublic": true,
          "line": 18,
          "raw": "const jsUtxos = JsVecString.new();",
          "source": "mesh-core-csl"
        },
        {
          "name": "wasmResult",
          "type": "any",
          "value": "js_parse_tx_body(txHex, jsUtxos);",
          "isPublic": true,
          "line": 23,
          "raw": "const wasmResult = js_parse_tx_body(txHex, jsUtxos);",
          "source": "mesh-core-csl"
        },
        {
          "name": "txBodyJson",
          "type": "any",
          "value": "wasmResult.get_data();",
          "isPublic": true,
          "line": 27,
          "raw": "const txBodyJson = wasmResult.get_data();",
          "source": "mesh-core-csl"
        },
        {
          "name": "txBodyObj",
          "type": "any",
          "value": "txBuilderBodyFromObj(txBodyJson);",
          "isPublic": true,
          "line": 30,
          "raw": "const txBodyObj = txBuilderBodyFromObj(txBodyJson);",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { js_parse_tx_body, JsVecString } from \"@sidan-lab/whisky-js-nodejs\";\n\nimport { emptyTxBuilderBody, MeshTxBuilderBody, UTxO } from \"@meshsdk/common\";\n\nimport { txBuilderBodyFromObj } from \"../core\";\nimport { calculateTxHash } from \"../utils\";\n\nexport class CSLParser {\n  resolvedUtxos: UTxO[];\n  txBuilderBody: MeshTxBuilderBody = emptyTxBuilderBody();\n  txHex: string = \"\";\n  txHash: string = \"\";\n\n  constructor(txHex: string, resolvedUtxos: UTxO[] = []) {\n    this.txHex = txHex;\n    this.txHash = calculateTxHash(txHex);\n    this.resolvedUtxos = resolvedUtxos;\n    const jsUtxos = JsVecString.new();\n    for (const utxo of resolvedUtxos) {\n      jsUtxos.add(JSON.stringify(utxo));\n    }\n\n    const wasmResult = js_parse_tx_body(txHex, jsUtxos);\n    if (wasmResult.get_status() !== \"success\") {\n      throw new Error(`CSLParser parse error: ${wasmResult.get_error()}`);\n    }\n    const txBodyJson = wasmResult.get_data();\n    console.log(\"txBodyJson\", txBodyJson);\n\n    const txBodyObj = txBuilderBodyFromObj(txBodyJson);\n    console.log(\"txBodyObj\", txBodyObj);\n\n    this.txBuilderBody = txBuilderBodyFromObj(txBodyJson);\n  }\n}\n",
      "dependencies": [
        "CSLParser"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:utils.address.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/utils/address.ts",
      "name": "utils.address.ts",
      "imports": [
        {
          "module": "serialzeAddress",
          "items": [],
          "line": 12,
          "raw": "export const serialzeAddress = (",
          "source": "mesh-core-csl"
        },
        {
          "module": "addrBech32ToPlutusDataHex",
          "items": [],
          "line": 43,
          "raw": "export const addrBech32ToPlutusDataHex = (bech32: string): string => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "addrBech32ToPlutusDataObj",
          "items": [],
          "line": 50,
          "raw": "export const addrBech32ToPlutusDataObj = <T>(bech32: string): T => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "serializeAddressObj",
          "items": [],
          "line": 57,
          "raw": "export const serializeAddressObj = (",
          "source": "mesh-core-csl"
        },
        {
          "module": "serializePlutusAddressToBech32",
          "items": [],
          "line": 68,
          "raw": "export const serializePlutusAddressToBech32 = (",
          "source": "mesh-core-csl"
        },
        {
          "module": "deserializeBech32Address",
          "items": [],
          "line": 79,
          "raw": "export const deserializeBech32Address = (",
          "source": "mesh-core-csl"
        },
        {
          "module": "scriptHashToBech32",
          "items": [],
          "line": 91,
          "raw": "export const scriptHashToBech32 = (",
          "source": "mesh-core-csl"
        },
        {
          "module": "v2ScriptToBech32",
          "items": [],
          "line": 104,
          "raw": "export const v2ScriptToBech32 = (",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "serialzeAddress",
          "signature": "export const serialzeAddress = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 12,
          "raw": "export const serialzeAddress = (\n  deserializedAddress: Partial<DeserializedAddress>,\n  networkId = 0,\n) => {\n  const {\n    pubKeyHash,\n    scriptHash,\n    stakeCredentialHash,\n    stakeScriptCredentialHash,\n  } = deserializedAddress;\n\n  const isPaymentScript = !pubKeyHash;\n  const isStakeScript = !stakeCredentialHash;\n\n  const paymentHash = isPaymentScript ? scriptHash : pubKeyHash;\n\n  const stakeHash = isStakeScript\n    ? stakeScriptCredentialHash\n    : stakeCredentialHash;\n\n  if (!paymentHash)\n    throw new Error(\n      \"Error: serializeAddress: Address must contain a payment part\",\n    );\n\n  const addressObj = isPaymentScript\n    ? scriptAddress(paymentHash, stakeHash, isStakeScript)\n    : pubKeyAddress(paymentHash, stakeHash, isStakeScript);\n  return serializeAddressObj(addressObj, networkId);\n};",
          "source": "mesh-core-csl",
          "implementation": "export const serialzeAddress = (\n  deserializedAddress: Partial<DeserializedAddress>,\n  networkId = 0,\n) => {\n  const {\n    pubKeyHash,\n    scriptHash,\n    stakeCredentialHash,\n    stakeScriptCredentialHash,\n  } = deserializedAddress;\n\n  const isPaymentScript = !pubKeyHash;\n  const isStakeScript = !stakeCredentialHash;\n\n  const paymentHash = isPaymentScript ? scriptHash : pubKeyHash;\n\n  const stakeHash = isStakeScript\n    ? stakeScriptCredentialHash\n    : stakeCredentialHash;\n\n  if (!paymentHash)\n    throw new Error(\n      \"Error: serializeAddress: Address must contain a payment part\",\n    );\n\n  const addressObj = isPaymentScript\n    ? scriptAddress(paymentHash, stakeHash, isStakeScript)\n    : pubKeyAddress(paymentHash, stakeHash, isStakeScript);\n  return serializeAddressObj(addressObj, networkId);\n};"
        },
        {
          "name": "addrBech32ToPlutusDataHex",
          "signature": "export const addrBech32ToPlutusDataHex = (bech32: string): string => {",
          "documentation": "",
          "parameters": [
            {
              "name": "bech32",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 43,
          "raw": "export const addrBech32ToPlutusDataHex = (bech32: string): string => {\n  const hexAddress = csl.Address.from_bech32(bech32).to_hex();\n  const cslAddress = csl.Address.from_hex(hexAddress);\n  const hex = csl.PlutusData.from_address(cslAddress).to_hex();\n  return hex;\n};",
          "source": "mesh-core-csl",
          "implementation": "export const addrBech32ToPlutusDataHex = (bech32: string): string => {\n  const hexAddress = csl.Address.from_bech32(bech32).to_hex();\n  const cslAddress = csl.Address.from_hex(hexAddress);\n  const hex = csl.PlutusData.from_address(cslAddress).to_hex();\n  return hex;\n};"
        },
        {
          "name": "serializeAddressObj",
          "signature": "export const serializeAddressObj = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 57,
          "raw": "export const serializeAddressObj = (\n  plutusDataAddressObject: PubKeyAddress | ScriptAddress,\n  networkId = 0,\n) => {\n  const bech32Addr = csl.parse_plutus_address_obj_to_bech32(\n    JSON.stringify(plutusDataAddressObject),\n    networkId,\n  );\n  return bech32Addr;\n};",
          "source": "mesh-core-csl",
          "implementation": "export const serializeAddressObj = (\n  plutusDataAddressObject: PubKeyAddress | ScriptAddress,\n  networkId = 0,\n) => {\n  const bech32Addr = csl.parse_plutus_address_obj_to_bech32(\n    JSON.stringify(plutusDataAddressObject),\n    networkId,\n  );\n  return bech32Addr;\n};"
        },
        {
          "name": "serializePlutusAddressToBech32",
          "signature": "export const serializePlutusAddressToBech32 = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 68,
          "raw": "export const serializePlutusAddressToBech32 = (\n  plutusHex: string,\n  networkId = 0,\n) => {\n  const cslPlutusDataAddress = csl.PlutusData.from_hex(plutusHex);\n  const plutusDataAddressObject = JSON.parse(\n    cslPlutusDataAddress.to_json(csl.PlutusDatumSchema.DetailedSchema),\n  );\n  return serializeAddressObj(plutusDataAddressObject, networkId);\n};",
          "source": "mesh-core-csl",
          "implementation": "export const serializePlutusAddressToBech32 = (\n  plutusHex: string,\n  networkId = 0,\n) => {\n  const cslPlutusDataAddress = csl.PlutusData.from_hex(plutusHex);\n  const plutusDataAddressObject = JSON.parse(\n    cslPlutusDataAddress.to_json(csl.PlutusDatumSchema.DetailedSchema),\n  );\n  return serializeAddressObj(plutusDataAddressObject, networkId);\n};"
        },
        {
          "name": "deserializeBech32Address",
          "signature": "export const deserializeBech32Address = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 79,
          "raw": "export const deserializeBech32Address = (\n  bech32Addr: string,\n): DeserializedAddress => {\n  const deserializedAddress = csl.deserialize_bech32_address(bech32Addr);\n  return {\n    pubKeyHash: deserializedAddress.get_pub_key_hash(),\n    scriptHash: deserializedAddress.get_script_hash(),\n    stakeCredentialHash: deserializedAddress.get_stake_key_hash(),\n    stakeScriptCredentialHash: deserializedAddress.get_stake_key_script_hash(),\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "export const deserializeBech32Address = (\n  bech32Addr: string,\n): DeserializedAddress => {\n  const deserializedAddress = csl.deserialize_bech32_address(bech32Addr);\n  return {\n    pubKeyHash: deserializedAddress.get_pub_key_hash(),\n    scriptHash: deserializedAddress.get_script_hash(),\n    stakeCredentialHash: deserializedAddress.get_stake_key_hash(),\n    stakeScriptCredentialHash: deserializedAddress.get_stake_key_script_hash(),\n  };\n};"
        },
        {
          "name": "scriptHashToBech32",
          "signature": "export const scriptHashToBech32 = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 91,
          "raw": "export const scriptHashToBech32 = (",
          "source": "mesh-core-csl",
          "implementation": "export const scriptHashToBech32 = ("
        },
        {
          "name": "v2ScriptToBech32",
          "signature": "export const v2ScriptToBech32 = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 104,
          "raw": "export const v2ScriptToBech32 = (",
          "source": "mesh-core-csl",
          "implementation": "export const v2ScriptToBech32 = ("
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "serialzeAddress",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 12,
          "raw": "export const serialzeAddress = (",
          "source": "mesh-core-csl"
        },
        {
          "name": "isPaymentScript",
          "type": "any",
          "value": "!pubKeyHash;",
          "isPublic": true,
          "line": 23,
          "raw": "const isPaymentScript = !pubKeyHash;",
          "source": "mesh-core-csl"
        },
        {
          "name": "isStakeScript",
          "type": "any",
          "value": "!stakeCredentialHash;",
          "isPublic": true,
          "line": 24,
          "raw": "const isStakeScript = !stakeCredentialHash;",
          "source": "mesh-core-csl"
        },
        {
          "name": "paymentHash",
          "type": "any",
          "value": "isPaymentScript ? scriptHash : pubKeyHash;",
          "isPublic": true,
          "line": 26,
          "raw": "const paymentHash = isPaymentScript ? scriptHash : pubKeyHash;",
          "source": "mesh-core-csl"
        },
        {
          "name": "stakeHash",
          "type": "any",
          "value": "isStakeScript",
          "isPublic": true,
          "line": 28,
          "raw": "const stakeHash = isStakeScript",
          "source": "mesh-core-csl"
        },
        {
          "name": "addressObj",
          "type": "any",
          "value": "isPaymentScript",
          "isPublic": true,
          "line": 37,
          "raw": "const addressObj = isPaymentScript",
          "source": "mesh-core-csl"
        },
        {
          "name": "addrBech32ToPlutusDataHex",
          "type": "any",
          "value": "(bech32: string): string => {",
          "isPublic": true,
          "line": 43,
          "raw": "export const addrBech32ToPlutusDataHex = (bech32: string): string => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "hexAddress",
          "type": "any",
          "value": "csl.Address.from_bech32(bech32).to_hex();",
          "isPublic": true,
          "line": 44,
          "raw": "const hexAddress = csl.Address.from_bech32(bech32).to_hex();",
          "source": "mesh-core-csl"
        },
        {
          "name": "cslAddress",
          "type": "any",
          "value": "csl.Address.from_hex(hexAddress);",
          "isPublic": true,
          "line": 45,
          "raw": "const cslAddress = csl.Address.from_hex(hexAddress);",
          "source": "mesh-core-csl"
        },
        {
          "name": "hex",
          "type": "any",
          "value": "csl.PlutusData.from_address(cslAddress).to_hex();",
          "isPublic": true,
          "line": 46,
          "raw": "const hex = csl.PlutusData.from_address(cslAddress).to_hex();",
          "source": "mesh-core-csl"
        },
        {
          "name": "addrBech32ToPlutusDataObj",
          "type": "any",
          "value": "<T>(bech32: string): T => {",
          "isPublic": true,
          "line": 50,
          "raw": "export const addrBech32ToPlutusDataObj = <T>(bech32: string): T => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "hexAddress",
          "type": "any",
          "value": "csl.Address.from_bech32(bech32).to_hex();",
          "isPublic": true,
          "line": 51,
          "raw": "const hexAddress = csl.Address.from_bech32(bech32).to_hex();",
          "source": "mesh-core-csl"
        },
        {
          "name": "cslAddress",
          "type": "any",
          "value": "csl.Address.from_hex(hexAddress);",
          "isPublic": true,
          "line": 52,
          "raw": "const cslAddress = csl.Address.from_hex(hexAddress);",
          "source": "mesh-core-csl"
        },
        {
          "name": "json",
          "type": "any",
          "value": "JSON.parse(csl.PlutusData.from_address(cslAddress).to_json(1));",
          "isPublic": true,
          "line": 53,
          "raw": "const json = JSON.parse(csl.PlutusData.from_address(cslAddress).to_json(1));",
          "source": "mesh-core-csl"
        },
        {
          "name": "serializeAddressObj",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 57,
          "raw": "export const serializeAddressObj = (",
          "source": "mesh-core-csl"
        },
        {
          "name": "bech32Addr",
          "type": "any",
          "value": "csl.parse_plutus_address_obj_to_bech32(",
          "isPublic": true,
          "line": 61,
          "raw": "const bech32Addr = csl.parse_plutus_address_obj_to_bech32(",
          "source": "mesh-core-csl"
        },
        {
          "name": "serializePlutusAddressToBech32",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 68,
          "raw": "export const serializePlutusAddressToBech32 = (",
          "source": "mesh-core-csl"
        },
        {
          "name": "cslPlutusDataAddress",
          "type": "any",
          "value": "csl.PlutusData.from_hex(plutusHex);",
          "isPublic": true,
          "line": 72,
          "raw": "const cslPlutusDataAddress = csl.PlutusData.from_hex(plutusHex);",
          "source": "mesh-core-csl"
        },
        {
          "name": "plutusDataAddressObject",
          "type": "any",
          "value": "JSON.parse(",
          "isPublic": true,
          "line": 73,
          "raw": "const plutusDataAddressObject = JSON.parse(",
          "source": "mesh-core-csl"
        },
        {
          "name": "deserializeBech32Address",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 79,
          "raw": "export const deserializeBech32Address = (",
          "source": "mesh-core-csl"
        },
        {
          "name": "deserializedAddress",
          "type": "any",
          "value": "csl.deserialize_bech32_address(bech32Addr);",
          "isPublic": true,
          "line": 82,
          "raw": "const deserializedAddress = csl.deserialize_bech32_address(bech32Addr);",
          "source": "mesh-core-csl"
        },
        {
          "name": "scriptHashToBech32",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 91,
          "raw": "export const scriptHashToBech32 = (",
          "source": "mesh-core-csl"
        },
        {
          "name": "v2ScriptToBech32",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 104,
          "raw": "export const v2ScriptToBech32 = (",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  DeserializedAddress,\n  pubKeyAddress,\n  PubKeyAddress,\n  scriptAddress,\n  ScriptAddress,\n} from \"@meshsdk/common\";\n\nimport { csl } from \"../deser\";\nimport { getV2ScriptHash } from \"./scripts\";\n\nexport const serialzeAddress = (\n  deserializedAddress: Partial<DeserializedAddress>,\n  networkId = 0,\n) => {\n  const {\n    pubKeyHash,\n    scriptHash,\n    stakeCredentialHash,\n    stakeScriptCredentialHash,\n  } = deserializedAddress;\n\n  const isPaymentScript = !pubKeyHash;\n  const isStakeScript = !stakeCredentialHash;\n\n  const paymentHash = isPaymentScript ? scriptHash : pubKeyHash;\n\n  const stakeHash = isStakeScript\n    ? stakeScriptCredentialHash\n    : stakeCredentialHash;\n\n  if (!paymentHash)\n    throw new Error(\n      \"Error: serializeAddress: Address must contain a payment part\",\n    );\n\n  const addressObj = isPaymentScript\n    ? scriptAddress(paymentHash, stakeHash, isStakeScript)\n    : pubKeyAddress(paymentHash, stakeHash, isStakeScript);\n  return serializeAddressObj(addressObj, networkId);\n};\n\nexport const addrBech32ToPlutusDataHex = (bech32: string): string => {\n  const hexAddress = csl.Address.from_bech32(bech32).to_hex();\n  const cslAddress = csl.Address.from_hex(hexAddress);\n  const hex = csl.PlutusData.from_address(cslAddress).to_hex();\n  return hex;\n};\n\nexport const addrBech32ToPlutusDataObj = <T>(bech32: string): T => {\n  const hexAddress = csl.Address.from_bech32(bech32).to_hex();\n  const cslAddress = csl.Address.from_hex(hexAddress);\n  const json = JSON.parse(csl.PlutusData.from_address(cslAddress).to_json(1));\n  return json;\n};\n\nexport const serializeAddressObj = (\n  plutusDataAddressObject: PubKeyAddress | ScriptAddress,\n  networkId = 0,\n) => {\n  const bech32Addr = csl.parse_plutus_address_obj_to_bech32(\n    JSON.stringify(plutusDataAddressObject),\n    networkId,\n  );\n  return bech32Addr;\n};\n\nexport const serializePlutusAddressToBech32 = (\n  plutusHex: string,\n  networkId = 0,\n) => {\n  const cslPlutusDataAddress = csl.PlutusData.from_hex(plutusHex);\n  const plutusDataAddressObject = JSON.parse(\n    cslPlutusDataAddress.to_json(csl.PlutusDatumSchema.DetailedSchema),\n  );\n  return serializeAddressObj(plutusDataAddressObject, networkId);\n};\n\nexport const deserializeBech32Address = (\n  bech32Addr: string,\n): DeserializedAddress => {\n  const deserializedAddress = csl.deserialize_bech32_address(bech32Addr);\n  return {\n    pubKeyHash: deserializedAddress.get_pub_key_hash(),\n    scriptHash: deserializedAddress.get_script_hash(),\n    stakeCredentialHash: deserializedAddress.get_stake_key_hash(),\n    stakeScriptCredentialHash: deserializedAddress.get_stake_key_script_hash(),\n  };\n};\n\nexport const scriptHashToBech32 = (\n  scriptHash: string,\n  stakeCredentialHash?: string,\n  networkId = 0,\n  isScriptStakeCredentialHash = false,\n) =>\n  csl.wasm_script_to_address(\n    networkId,\n    scriptHash,\n    stakeCredentialHash,\n    isScriptStakeCredentialHash,\n  );\n\nexport const v2ScriptToBech32 = (\n  scriptCbor: string,\n  stakeCredential?: string,\n  networkId = 0,\n  isScriptStakeCredential = false,\n) =>\n  scriptHashToBech32(\n    getV2ScriptHash(scriptCbor),\n    stakeCredential,\n    networkId,\n    isScriptStakeCredential,\n  );\n",
      "dependencies": [
        "serialzeAddress",
        "addrBech32ToPlutusDataHex",
        "addrBech32ToPlutusDataObj",
        "serializeAddressObj",
        "serializePlutusAddressToBech32",
        "deserializeBech32Address",
        "scriptHashToBech32",
        "v2ScriptToBech32"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:utils.aiken.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/utils/aiken.ts",
      "name": "utils.aiken.ts",
      "imports": [
        {
          "module": "applyParamsToScript",
          "items": [],
          "line": 13,
          "raw": "export const applyParamsToScript = (",
          "source": "mesh-core-csl"
        },
        {
          "module": "applyCborEncoding",
          "items": [],
          "line": 56,
          "raw": "export const applyCborEncoding = (rawScript: string): string => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "applyParamsToScript",
          "signature": "export const applyParamsToScript = (",
          "documentation": "/**\n * Apply parameters to a given script blueprint.\n *\n * @param rawScript - The raw script CborHex from blueprint.\n * @param params - The parameters to apply, in an array.\n * @param type - The type of the parameters, default to be Mesh's Data type. It could also be in JSON and raw CBOR.\n * @returns The double-cbor encoded script CborHex with the parameters applied.\n */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 13,
          "raw": "/**\n * Apply parameters to a given script blueprint.\n *\n * @param rawScript - The raw script CborHex from blueprint.\n * @param params - The parameters to apply, in an array.\n * @param type - The type of the parameters, default to be Mesh's Data type. It could also be in JSON and raw CBOR.\n * @returns The double-cbor encoded script CborHex with the parameters applied.\n */\nexport const applyParamsToScript = (\n  rawScript: string,\n  params: object[] | Data[],\n  type: PlutusDataType = \"Mesh\",\n): string => {\n  const cslParams = csl.JsVecString.new();\n  let paramType = \"cbor\";\n\n  switch (type) {\n    case \"JSON\":\n      paramType = \"json\";\n      params.forEach((param) => {\n        if (typeof param === \"object\") {\n          cslParams.add(JSON.stringify(param));\n        } else if (typeof param === \"string\") {\n          cslParams.add(param);\n        }\n      });\n      break;\n\n    case \"Mesh\":\n      params.forEach((param) => {\n        const paramCbor = toPlutusData(param as Data);\n        cslParams.add(paramCbor.to_hex());\n      });\n      break;\n\n    default:\n      params.forEach((param) => {\n        cslParams.add(param as string);\n      });\n      break;\n  }\n\n  return csl.js_apply_params_to_script(rawScript, cslParams, paramType);\n};",
          "source": "mesh-core-csl",
          "implementation": "export const applyParamsToScript = (\n  rawScript: string,\n  params: object[] | Data[],\n  type: PlutusDataType = \"Mesh\",\n): string => {\n  const cslParams = csl.JsVecString.new();\n  let paramType = \"cbor\";\n\n  switch (type) {\n    case \"JSON\":\n      paramType = \"json\";\n      params.forEach((param) => {\n        if (typeof param === \"object\") {\n          cslParams.add(JSON.stringify(param));\n        } else if (typeof param === \"string\") {\n          cslParams.add(param);\n        }\n      });\n      break;\n\n    case \"Mesh\":\n      params.forEach((param) => {\n        const paramCbor = toPlutusData(param as Data);\n        cslParams.add(paramCbor.to_hex());\n      });\n      break;\n\n    default:\n      params.forEach((param) => {\n        cslParams.add(param as string);\n      });\n      break;\n  }\n\n  return csl.js_apply_params_to_script(rawScript, cslParams, paramType);\n};"
        },
        {
          "name": "applyCborEncoding",
          "signature": "export const applyCborEncoding = (rawScript: string): string => {",
          "documentation": "/**\n * Apply Cbor encoding.\n *\n * @param rawScript - The raw script CborHex from blueprint.\n * @returns The double-cbor encoded script CborHex.\n */",
          "parameters": [
            {
              "name": "rawScript",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 56,
          "raw": "/**\n * Apply Cbor encoding.\n *\n * @param rawScript - The raw script CborHex from blueprint.\n * @returns The double-cbor encoded script CborHex.\n */\nexport const applyCborEncoding = (rawScript: string): string => {\n  return csl.js_apply_params_to_script(\n    rawScript,\n    csl.JsVecString.new(),\n    \"cbor\",\n  );\n};",
          "source": "mesh-core-csl",
          "implementation": "export const applyCborEncoding = (rawScript: string): string => {\n  return csl.js_apply_params_to_script(\n    rawScript,\n    csl.JsVecString.new(),\n    \"cbor\",\n  );\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "applyParamsToScript",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 13,
          "raw": "export const applyParamsToScript = (",
          "source": "mesh-core-csl"
        },
        {
          "name": "cslParams",
          "type": "any",
          "value": "csl.JsVecString.new();",
          "isPublic": true,
          "line": 18,
          "raw": "const cslParams = csl.JsVecString.new();",
          "source": "mesh-core-csl"
        },
        {
          "name": "paramCbor",
          "type": "any",
          "value": "toPlutusData(param as Data);",
          "isPublic": true,
          "line": 35,
          "raw": "const paramCbor = toPlutusData(param as Data);",
          "source": "mesh-core-csl"
        },
        {
          "name": "applyCborEncoding",
          "type": "any",
          "value": "(rawScript: string): string => {",
          "isPublic": true,
          "line": 56,
          "raw": "export const applyCborEncoding = (rawScript: string): string => {",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { Data, PlutusDataType } from \"@meshsdk/common\";\n\nimport { csl, toPlutusData } from \"../deser\";\n\n/**\n * Apply parameters to a given script blueprint.\n *\n * @param rawScript - The raw script CborHex from blueprint.\n * @param params - The parameters to apply, in an array.\n * @param type - The type of the parameters, default to be Mesh's Data type. It could also be in JSON and raw CBOR.\n * @returns The double-cbor encoded script CborHex with the parameters applied.\n */\nexport const applyParamsToScript = (\n  rawScript: string,\n  params: object[] | Data[],\n  type: PlutusDataType = \"Mesh\",\n): string => {\n  const cslParams = csl.JsVecString.new();\n  let paramType = \"cbor\";\n\n  switch (type) {\n    case \"JSON\":\n      paramType = \"json\";\n      params.forEach((param) => {\n        if (typeof param === \"object\") {\n          cslParams.add(JSON.stringify(param));\n        } else if (typeof param === \"string\") {\n          cslParams.add(param);\n        }\n      });\n      break;\n\n    case \"Mesh\":\n      params.forEach((param) => {\n        const paramCbor = toPlutusData(param as Data);\n        cslParams.add(paramCbor.to_hex());\n      });\n      break;\n\n    default:\n      params.forEach((param) => {\n        cslParams.add(param as string);\n      });\n      break;\n  }\n\n  return csl.js_apply_params_to_script(rawScript, cslParams, paramType);\n};\n\n/**\n * Apply Cbor encoding.\n *\n * @param rawScript - The raw script CborHex from blueprint.\n * @returns The double-cbor encoded script CborHex.\n */\nexport const applyCborEncoding = (rawScript: string): string => {\n  return csl.js_apply_params_to_script(\n    rawScript,\n    csl.JsVecString.new(),\n    \"cbor\",\n  );\n};\n",
      "dependencies": [
        "applyParamsToScript",
        "applyCborEncoding"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:utils.credentials.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/utils/credentials.ts",
      "name": "utils.credentials.ts",
      "imports": [
        {
          "module": "skeyToPubKeyHash",
          "items": [],
          "line": 3,
          "raw": "export const skeyToPubKeyHash = (skeyHex: string): string => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "skeyToPubKeyHash",
          "signature": "export const skeyToPubKeyHash = (skeyHex: string): string => {",
          "documentation": "",
          "parameters": [
            {
              "name": "skeyHex",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 3,
          "raw": "export const skeyToPubKeyHash = (skeyHex: string): string => {\n  const isHexUnclean = skeyHex.slice(0, 4) === \"5820\" && skeyHex.length === 68;\n  const cleanHex = isHexUnclean ? skeyHex.slice(4) : skeyHex;\n  return csl.PrivateKey.from_hex(cleanHex).to_public().hash().to_hex();\n};",
          "source": "mesh-core-csl",
          "implementation": "export const skeyToPubKeyHash = (skeyHex: string): string => {\n  const isHexUnclean = skeyHex.slice(0, 4) === \"5820\" && skeyHex.length === 68;\n  const cleanHex = isHexUnclean ? skeyHex.slice(4) : skeyHex;\n  return csl.PrivateKey.from_hex(cleanHex).to_public().hash().to_hex();\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "skeyToPubKeyHash",
          "type": "any",
          "value": "(skeyHex: string): string => {",
          "isPublic": true,
          "line": 3,
          "raw": "export const skeyToPubKeyHash = (skeyHex: string): string => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "isHexUnclean",
          "type": "any",
          "value": "skeyHex.slice(0, 4) === \"5820\" && skeyHex.length === 68;",
          "isPublic": true,
          "line": 4,
          "raw": "const isHexUnclean = skeyHex.slice(0, 4) === \"5820\" && skeyHex.length === 68;",
          "source": "mesh-core-csl"
        },
        {
          "name": "cleanHex",
          "type": "any",
          "value": "isHexUnclean ? skeyHex.slice(4) : skeyHex;",
          "isPublic": true,
          "line": 5,
          "raw": "const cleanHex = isHexUnclean ? skeyHex.slice(4) : skeyHex;",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { csl } from \"../deser\";\n\nexport const skeyToPubKeyHash = (skeyHex: string): string => {\n  const isHexUnclean = skeyHex.slice(0, 4) === \"5820\" && skeyHex.length === 68;\n  const cleanHex = isHexUnclean ? skeyHex.slice(4) : skeyHex;\n  return csl.PrivateKey.from_hex(cleanHex).to_public().hash().to_hex();\n};\n",
      "dependencies": [
        "skeyToPubKeyHash"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:utils.datum.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/utils/datum.ts",
      "name": "utils.datum.ts",
      "imports": [
        {
          "module": "parseInlineDatum",
          "items": [],
          "line": 4,
          "raw": "export const parseInlineDatum = <T extends { inline_datum?: string }, X>(",
          "source": "mesh-core-csl"
        },
        {
          "module": "parseDatumCbor",
          "items": [],
          "line": 13,
          "raw": "export const parseDatumCbor = <T = any>(datumCbor: string): T => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [],
      "types": [],
      "constants": [
        {
          "name": "parseInlineDatum",
          "type": "any",
          "value": "<T extends { inline_datum?: string }, X>(",
          "isPublic": true,
          "line": 4,
          "raw": "export const parseInlineDatum = <T extends { inline_datum?: string }, X>(",
          "source": "mesh-core-csl"
        },
        {
          "name": "datumCbor",
          "type": "string",
          "value": "utxo.inline_datum || \"\";",
          "isPublic": true,
          "line": 7,
          "raw": "const datumCbor: string = utxo.inline_datum || \"\";",
          "source": "mesh-core-csl"
        },
        {
          "name": "parsedDatum",
          "type": "any",
          "value": "csl.PlutusData.from_hex(datumCbor);",
          "isPublic": true,
          "line": 8,
          "raw": "const parsedDatum = csl.PlutusData.from_hex(datumCbor);",
          "source": "mesh-core-csl"
        },
        {
          "name": "datum",
          "type": "X",
          "value": "JSON.parse(parsedDatum.to_json(1));",
          "isPublic": true,
          "line": 9,
          "raw": "const datum: X = JSON.parse(parsedDatum.to_json(1));",
          "source": "mesh-core-csl"
        },
        {
          "name": "parseDatumCbor",
          "type": "any",
          "value": "<T = any>(datumCbor: string): T => {",
          "isPublic": true,
          "line": 13,
          "raw": "export const parseDatumCbor = <T = any>(datumCbor: string): T => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "parsedDatum",
          "type": "any",
          "value": "csl.PlutusData.from_hex(datumCbor);",
          "isPublic": true,
          "line": 14,
          "raw": "const parsedDatum = csl.PlutusData.from_hex(datumCbor);",
          "source": "mesh-core-csl"
        },
        {
          "name": "datum",
          "type": "T",
          "value": "JSON.parse(parsedDatum.to_json(1));",
          "isPublic": true,
          "line": 15,
          "raw": "const datum: T = JSON.parse(parsedDatum.to_json(1));",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { csl } from \"../deser\";\n\nexport const parseInlineDatum = <T extends { inline_datum?: string }, X>(\n  utxo: T,\n): X => {\n  const datumCbor: string = utxo.inline_datum || \"\";\n  const parsedDatum = csl.PlutusData.from_hex(datumCbor);\n  const datum: X = JSON.parse(parsedDatum.to_json(1));\n  return datum as X;\n};\n\nexport const parseDatumCbor = <T = any>(datumCbor: string): T => {\n  const parsedDatum = csl.PlutusData.from_hex(datumCbor);\n  const datum: T = JSON.parse(parsedDatum.to_json(1));\n  return datum as T;\n};\n",
      "dependencies": [
        "parseInlineDatum",
        "parseDatumCbor"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:utils.drep.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/utils/drep.ts",
      "name": "utils.drep.ts",
      "imports": [
        {
          "module": "getDRepIds",
          "items": [],
          "line": 5,
          "raw": "export const getDRepIds = (",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "getDRepIds",
          "signature": "export const getDRepIds = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 5,
          "raw": "export const getDRepIds = (\n  dRepId: string,\n): {\n  cip105: string;\n  cip129: string;\n} => {\n  const cslDrep = csl.DRep.from_bech32(dRepId);\n  let result = {\n    cip105: cslDrep.to_bech32(false),\n    cip129: cslDrep.to_bech32(true),\n  };\n  return result;\n};",
          "source": "mesh-core-csl",
          "implementation": "export const getDRepIds = (\n  dRepId: string,\n): {\n  cip105: string;\n  cip129: string;\n} => {\n  const cslDrep = csl.DRep.from_bech32(dRepId);\n  let result = {\n    cip105: cslDrep.to_bech32(false),\n    cip129: cslDrep.to_bech32(true),\n  };\n  return result;\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "getDRepIds",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 5,
          "raw": "export const getDRepIds = (",
          "source": "mesh-core-csl"
        },
        {
          "name": "cslDrep",
          "type": "any",
          "value": "csl.DRep.from_bech32(dRepId);",
          "isPublic": true,
          "line": 11,
          "raw": "const cslDrep = csl.DRep.from_bech32(dRepId);",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { bech32 } from \"bech32\";\n\nimport { csl } from \"../deser\";\n\nexport const getDRepIds = (\n  dRepId: string,\n): {\n  cip105: string;\n  cip129: string;\n} => {\n  const cslDrep = csl.DRep.from_bech32(dRepId);\n  let result = {\n    cip105: cslDrep.to_bech32(false),\n    cip129: cslDrep.to_bech32(true),\n  };\n  return result;\n};\n",
      "dependencies": [
        "getDRepIds"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:utils.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/utils/index.ts",
      "name": "utils.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./address\";\nexport * from \"./datum\";\nexport * from \"./scripts\";\nexport * from \"./credentials\";\nexport * from \"./staking\";\nexport * from \"./transaction\";\nexport * from \"./aiken\";\nexport * from \"./drep\";\nexport * from \"./transaction-parser\";\n",
      "dependencies": [],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:utils.scripts.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/utils/scripts.ts",
      "name": "utils.scripts.ts",
      "imports": [
        {
          "module": "getV2ScriptHash",
          "items": [],
          "line": 3,
          "raw": "export const getV2ScriptHash = (script: string): string =>",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "getV2ScriptHash",
          "signature": "export const getV2ScriptHash = (script: string): string =>",
          "documentation": "",
          "parameters": [
            {
              "name": "script",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 3,
          "raw": "export const getV2ScriptHash = (script: string): string =>",
          "source": "mesh-core-csl",
          "implementation": "export const getV2ScriptHash = (script: string): string =>"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "getV2ScriptHash",
          "type": "any",
          "value": "(script: string): string =>",
          "isPublic": true,
          "line": 3,
          "raw": "export const getV2ScriptHash = (script: string): string =>",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { csl } from \"../deser\";\n\nexport const getV2ScriptHash = (script: string): string =>\n  csl.get_v2_script_hash(script);\n",
      "dependencies": [
        "getV2ScriptHash"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:utils.staking.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/utils/staking.ts",
      "name": "utils.staking.ts",
      "imports": [
        {
          "module": "poolIdHexToBech32",
          "items": [],
          "line": 3,
          "raw": "export const poolIdHexToBech32 = (poolIdHash: string) => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "poolIdBech32ToHex",
          "items": [],
          "line": 8,
          "raw": "export const poolIdBech32ToHex = (poolIdBech32: string) => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "baseAddressToStakeAddress",
          "items": [],
          "line": 13,
          "raw": "export const baseAddressToStakeAddress = (",
          "source": "mesh-core-csl"
        },
        {
          "module": "rewardAddressToKeyHash",
          "items": [],
          "line": 33,
          "raw": "export const rewardAddressToKeyHash = (rewardBech32: string) => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "scriptHashToRewardAddress",
          "items": [],
          "line": 37,
          "raw": "export const scriptHashToRewardAddress = (",
          "source": "mesh-core-csl"
        },
        {
          "module": "keyHashToRewardAddress",
          "items": [],
          "line": 53,
          "raw": "export const keyHashToRewardAddress = (keyHashHex: string, network = 1) => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "poolIdHexToBech32",
          "signature": "export const poolIdHexToBech32 = (poolIdHash: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "poolIdHash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 3,
          "raw": "export const poolIdHexToBech32 = (poolIdHash: string) => {\n  const cslPoolIdHash = csl.Ed25519KeyHash.from_hex(poolIdHash);\n  return cslPoolIdHash.to_bech32(\"pool\");\n};",
          "source": "mesh-core-csl",
          "implementation": "export const poolIdHexToBech32 = (poolIdHash: string) => {\n  const cslPoolIdHash = csl.Ed25519KeyHash.from_hex(poolIdHash);\n  return cslPoolIdHash.to_bech32(\"pool\");\n};"
        },
        {
          "name": "poolIdBech32ToHex",
          "signature": "export const poolIdBech32ToHex = (poolIdBech32: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "poolIdBech32",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 8,
          "raw": "export const poolIdBech32ToHex = (poolIdBech32: string) => {\n  const cslPoolIdHash = csl.Ed25519KeyHash.from_bech32(poolIdBech32);\n  return Buffer.from(cslPoolIdHash.to_bytes()).toString(\"hex\");\n};",
          "source": "mesh-core-csl",
          "implementation": "export const poolIdBech32ToHex = (poolIdBech32: string) => {\n  const cslPoolIdHash = csl.Ed25519KeyHash.from_bech32(poolIdBech32);\n  return Buffer.from(cslPoolIdHash.to_bytes()).toString(\"hex\");\n};"
        },
        {
          "name": "baseAddressToStakeAddress",
          "signature": "export const baseAddressToStakeAddress = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 13,
          "raw": "export const baseAddressToStakeAddress = (\n  baseAddressBech32: string,\n  network = 1,\n) => {\n  const networkId =\n    network === 1\n      ? csl.NetworkId.mainnet().kind()\n      : csl.NetworkId.testnet().kind();\n  const stakeCred = csl.BaseAddress.from_address(\n    csl.Address.from_bech32(baseAddressBech32),\n  )?.stake_cred();\n  if (stakeCred) {\n    const stakeAddress = csl.RewardAddress.new(networkId, stakeCred)\n      .to_address()\n      .to_bech32();\n    return stakeAddress;\n  }\n  return \"\";\n};",
          "source": "mesh-core-csl",
          "implementation": "export const baseAddressToStakeAddress = (\n  baseAddressBech32: string,\n  network = 1,\n) => {\n  const networkId =\n    network === 1\n      ? csl.NetworkId.mainnet().kind()\n      : csl.NetworkId.testnet().kind();\n  const stakeCred = csl.BaseAddress.from_address(\n    csl.Address.from_bech32(baseAddressBech32),\n  )?.stake_cred();\n  if (stakeCred) {\n    const stakeAddress = csl.RewardAddress.new(networkId, stakeCred)\n      .to_address()\n      .to_bech32();\n    return stakeAddress;\n  }\n  return \"\";\n};"
        },
        {
          "name": "rewardAddressToKeyHash",
          "signature": "export const rewardAddressToKeyHash = (rewardBech32: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "rewardBech32",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 33,
          "raw": "export const rewardAddressToKeyHash = (rewardBech32: string) => {\n  return toRewardAddress(rewardBech32)?.payment_cred().to_keyhash()?.to_hex();\n};",
          "source": "mesh-core-csl",
          "implementation": "export const rewardAddressToKeyHash = (rewardBech32: string) => {\n  return toRewardAddress(rewardBech32)?.payment_cred().to_keyhash()?.to_hex();\n};"
        },
        {
          "name": "scriptHashToRewardAddress",
          "signature": "export const scriptHashToRewardAddress = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 37,
          "raw": "export const scriptHashToRewardAddress = (\n  scriptHashHex: string,\n  network = 1,\n) => {\n  const networkId =\n    network === 1\n      ? csl.NetworkId.mainnet().kind()\n      : csl.NetworkId.testnet().kind();\n  const scriptHash = csl.ScriptHash.from_hex(scriptHashHex);\n  const credential = csl.Credential.from_scripthash(scriptHash);\n  const rewardAddress = csl.RewardAddress.new(networkId, credential)\n    .to_address()\n    .to_bech32();\n  return rewardAddress;\n};",
          "source": "mesh-core-csl",
          "implementation": "export const scriptHashToRewardAddress = (\n  scriptHashHex: string,\n  network = 1,\n) => {\n  const networkId =\n    network === 1\n      ? csl.NetworkId.mainnet().kind()\n      : csl.NetworkId.testnet().kind();\n  const scriptHash = csl.ScriptHash.from_hex(scriptHashHex);\n  const credential = csl.Credential.from_scripthash(scriptHash);\n  const rewardAddress = csl.RewardAddress.new(networkId, credential)\n    .to_address()\n    .to_bech32();\n  return rewardAddress;\n};"
        },
        {
          "name": "keyHashToRewardAddress",
          "signature": "export const keyHashToRewardAddress = (keyHashHex: string, network = 1) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "keyHashHex",
              "type": "string",
              "optional": false
            },
            {
              "name": "network",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 53,
          "raw": "export const keyHashToRewardAddress = (keyHashHex: string, network = 1) => {\n  const networkId =\n    network === 1\n      ? csl.NetworkId.mainnet().kind()\n      : csl.NetworkId.testnet().kind();\n  const keyHash = csl.Ed25519KeyHash.from_hex(keyHashHex);\n  const credential = csl.Credential.from_scripthash(keyHash);\n  const rewardAddress = csl.RewardAddress.new(networkId, credential)\n    .to_address()\n    .to_bech32();\n  return rewardAddress;\n};",
          "source": "mesh-core-csl",
          "implementation": "export const keyHashToRewardAddress = (keyHashHex: string, network = 1) => {\n  const networkId =\n    network === 1\n      ? csl.NetworkId.mainnet().kind()\n      : csl.NetworkId.testnet().kind();\n  const keyHash = csl.Ed25519KeyHash.from_hex(keyHashHex);\n  const credential = csl.Credential.from_scripthash(keyHash);\n  const rewardAddress = csl.RewardAddress.new(networkId, credential)\n    .to_address()\n    .to_bech32();\n  return rewardAddress;\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "poolIdHexToBech32",
          "type": "any",
          "value": "(poolIdHash: string) => {",
          "isPublic": true,
          "line": 3,
          "raw": "export const poolIdHexToBech32 = (poolIdHash: string) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "cslPoolIdHash",
          "type": "any",
          "value": "csl.Ed25519KeyHash.from_hex(poolIdHash);",
          "isPublic": true,
          "line": 4,
          "raw": "const cslPoolIdHash = csl.Ed25519KeyHash.from_hex(poolIdHash);",
          "source": "mesh-core-csl"
        },
        {
          "name": "poolIdBech32ToHex",
          "type": "any",
          "value": "(poolIdBech32: string) => {",
          "isPublic": true,
          "line": 8,
          "raw": "export const poolIdBech32ToHex = (poolIdBech32: string) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "cslPoolIdHash",
          "type": "any",
          "value": "csl.Ed25519KeyHash.from_bech32(poolIdBech32);",
          "isPublic": true,
          "line": 9,
          "raw": "const cslPoolIdHash = csl.Ed25519KeyHash.from_bech32(poolIdBech32);",
          "source": "mesh-core-csl"
        },
        {
          "name": "baseAddressToStakeAddress",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 13,
          "raw": "export const baseAddressToStakeAddress = (",
          "source": "mesh-core-csl"
        },
        {
          "name": "stakeCred",
          "type": "any",
          "value": "csl.BaseAddress.from_address(",
          "isPublic": true,
          "line": 21,
          "raw": "const stakeCred = csl.BaseAddress.from_address(",
          "source": "mesh-core-csl"
        },
        {
          "name": "stakeAddress",
          "type": "any",
          "value": "csl.RewardAddress.new(networkId, stakeCred)",
          "isPublic": true,
          "line": 25,
          "raw": "const stakeAddress = csl.RewardAddress.new(networkId, stakeCred)",
          "source": "mesh-core-csl"
        },
        {
          "name": "rewardAddressToKeyHash",
          "type": "any",
          "value": "(rewardBech32: string) => {",
          "isPublic": true,
          "line": 33,
          "raw": "export const rewardAddressToKeyHash = (rewardBech32: string) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "scriptHashToRewardAddress",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 37,
          "raw": "export const scriptHashToRewardAddress = (",
          "source": "mesh-core-csl"
        },
        {
          "name": "scriptHash",
          "type": "any",
          "value": "csl.ScriptHash.from_hex(scriptHashHex);",
          "isPublic": true,
          "line": 45,
          "raw": "const scriptHash = csl.ScriptHash.from_hex(scriptHashHex);",
          "source": "mesh-core-csl"
        },
        {
          "name": "credential",
          "type": "any",
          "value": "csl.Credential.from_scripthash(scriptHash);",
          "isPublic": true,
          "line": 46,
          "raw": "const credential = csl.Credential.from_scripthash(scriptHash);",
          "source": "mesh-core-csl"
        },
        {
          "name": "rewardAddress",
          "type": "any",
          "value": "csl.RewardAddress.new(networkId, credential)",
          "isPublic": true,
          "line": 47,
          "raw": "const rewardAddress = csl.RewardAddress.new(networkId, credential)",
          "source": "mesh-core-csl"
        },
        {
          "name": "keyHashToRewardAddress",
          "type": "any",
          "value": "(keyHashHex: string, network = 1) => {",
          "isPublic": true,
          "line": 53,
          "raw": "export const keyHashToRewardAddress = (keyHashHex: string, network = 1) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "keyHash",
          "type": "any",
          "value": "csl.Ed25519KeyHash.from_hex(keyHashHex);",
          "isPublic": true,
          "line": 58,
          "raw": "const keyHash = csl.Ed25519KeyHash.from_hex(keyHashHex);",
          "source": "mesh-core-csl"
        },
        {
          "name": "credential",
          "type": "any",
          "value": "csl.Credential.from_scripthash(keyHash);",
          "isPublic": true,
          "line": 59,
          "raw": "const credential = csl.Credential.from_scripthash(keyHash);",
          "source": "mesh-core-csl"
        },
        {
          "name": "rewardAddress",
          "type": "any",
          "value": "csl.RewardAddress.new(networkId, credential)",
          "isPublic": true,
          "line": 60,
          "raw": "const rewardAddress = csl.RewardAddress.new(networkId, credential)",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { csl, toRewardAddress } from \"../deser\";\n\nexport const poolIdHexToBech32 = (poolIdHash: string) => {\n  const cslPoolIdHash = csl.Ed25519KeyHash.from_hex(poolIdHash);\n  return cslPoolIdHash.to_bech32(\"pool\");\n};\n\nexport const poolIdBech32ToHex = (poolIdBech32: string) => {\n  const cslPoolIdHash = csl.Ed25519KeyHash.from_bech32(poolIdBech32);\n  return Buffer.from(cslPoolIdHash.to_bytes()).toString(\"hex\");\n};\n\nexport const baseAddressToStakeAddress = (\n  baseAddressBech32: string,\n  network = 1,\n) => {\n  const networkId =\n    network === 1\n      ? csl.NetworkId.mainnet().kind()\n      : csl.NetworkId.testnet().kind();\n  const stakeCred = csl.BaseAddress.from_address(\n    csl.Address.from_bech32(baseAddressBech32),\n  )?.stake_cred();\n  if (stakeCred) {\n    const stakeAddress = csl.RewardAddress.new(networkId, stakeCred)\n      .to_address()\n      .to_bech32();\n    return stakeAddress;\n  }\n  return \"\";\n};\n\nexport const rewardAddressToKeyHash = (rewardBech32: string) => {\n  return toRewardAddress(rewardBech32)?.payment_cred().to_keyhash()?.to_hex();\n};\n\nexport const scriptHashToRewardAddress = (\n  scriptHashHex: string,\n  network = 1,\n) => {\n  const networkId =\n    network === 1\n      ? csl.NetworkId.mainnet().kind()\n      : csl.NetworkId.testnet().kind();\n  const scriptHash = csl.ScriptHash.from_hex(scriptHashHex);\n  const credential = csl.Credential.from_scripthash(scriptHash);\n  const rewardAddress = csl.RewardAddress.new(networkId, credential)\n    .to_address()\n    .to_bech32();\n  return rewardAddress;\n};\n\nexport const keyHashToRewardAddress = (keyHashHex: string, network = 1) => {\n  const networkId =\n    network === 1\n      ? csl.NetworkId.mainnet().kind()\n      : csl.NetworkId.testnet().kind();\n  const keyHash = csl.Ed25519KeyHash.from_hex(keyHashHex);\n  const credential = csl.Credential.from_scripthash(keyHash);\n  const rewardAddress = csl.RewardAddress.new(networkId, credential)\n    .to_address()\n    .to_bech32();\n  return rewardAddress;\n};\n",
      "dependencies": [
        "poolIdHexToBech32",
        "poolIdBech32ToHex",
        "baseAddressToStakeAddress",
        "rewardAddressToKeyHash",
        "scriptHashToRewardAddress",
        "keyHashToRewardAddress"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:utils.transaction-parser.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/utils/transaction-parser.ts",
      "name": "utils.transaction-parser.ts",
      "imports": [
        {
          "module": "getRequiredInputs",
          "items": [],
          "line": 5,
          "raw": "export const getRequiredInputs = (transactionHex: string): TxInput[] => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "getRequiredInputs",
          "signature": "export const getRequiredInputs = (transactionHex: string): TxInput[] => {",
          "documentation": "",
          "parameters": [
            {
              "name": "transactionHex",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "TxInput[]",
          "isPublic": true,
          "line": 5,
          "raw": "export const getRequiredInputs = (transactionHex: string): TxInput[] => {\n  const result = js_get_required_inputs_to_resolve(transactionHex);\n  if (result.get_status() !== \"success\") {\n    throw new Error(`Failed to get required inputs: ${result.get_error()}`);\n  }\n  const utxosStr: string[] = JSON.parse(result.get_data());\n\n  return utxosStr.map((utxoStr) => {\n    const parts = utxoStr.split(\"#\");\n    if (parts.length !== 2) {\n      throw new Error(`Invalid UTxO format: ${utxoStr}`);\n    }\n    const [txHash, outputIndex] = parts;\n    if (!txHash || !outputIndex) {\n      throw new Error(\n        `Invalid UTxO format: ${utxoStr}. Expected format is txHash#outputIndex`,\n      );\n    }\n    return {\n      txHash: txHash,\n      outputIndex: parseInt(outputIndex),\n    };\n  });\n};",
          "source": "mesh-core-csl",
          "implementation": "export const getRequiredInputs = (transactionHex: string): TxInput[] => {\n  const result = js_get_required_inputs_to_resolve(transactionHex);\n  if (result.get_status() !== \"success\") {\n    throw new Error(`Failed to get required inputs: ${result.get_error()}`);\n  }\n  const utxosStr: string[] = JSON.parse(result.get_data());\n\n  return utxosStr.map((utxoStr) => {\n    const parts = utxoStr.split(\"#\");\n    if (parts.length !== 2) {\n      throw new Error(`Invalid UTxO format: ${utxoStr}`);\n    }\n    const [txHash, outputIndex] = parts;\n    if (!txHash || !outputIndex) {\n      throw new Error(\n        `Invalid UTxO format: ${utxoStr}. Expected format is txHash#outputIndex`,\n      );\n    }\n    return {\n      txHash: txHash,\n      outputIndex: parseInt(outputIndex),\n    };\n  });\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "getRequiredInputs",
          "type": "any",
          "value": "(transactionHex: string): TxInput[] => {",
          "isPublic": true,
          "line": 5,
          "raw": "export const getRequiredInputs = (transactionHex: string): TxInput[] => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "result",
          "type": "any",
          "value": "js_get_required_inputs_to_resolve(transactionHex);",
          "isPublic": true,
          "line": 6,
          "raw": "const result = js_get_required_inputs_to_resolve(transactionHex);",
          "source": "mesh-core-csl"
        },
        {
          "name": "utxosStr",
          "type": "string[]",
          "value": "JSON.parse(result.get_data());",
          "isPublic": true,
          "line": 10,
          "raw": "const utxosStr: string[] = JSON.parse(result.get_data());",
          "source": "mesh-core-csl"
        },
        {
          "name": "parts",
          "type": "any",
          "value": "utxoStr.split(\"#\");",
          "isPublic": true,
          "line": 13,
          "raw": "const parts = utxoStr.split(\"#\");",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { js_get_required_inputs_to_resolve } from \"@sidan-lab/whisky-js-nodejs\";\n\nimport { TxInput } from \"@meshsdk/common\";\n\nexport const getRequiredInputs = (transactionHex: string): TxInput[] => {\n  const result = js_get_required_inputs_to_resolve(transactionHex);\n  if (result.get_status() !== \"success\") {\n    throw new Error(`Failed to get required inputs: ${result.get_error()}`);\n  }\n  const utxosStr: string[] = JSON.parse(result.get_data());\n\n  return utxosStr.map((utxoStr) => {\n    const parts = utxoStr.split(\"#\");\n    if (parts.length !== 2) {\n      throw new Error(`Invalid UTxO format: ${utxoStr}`);\n    }\n    const [txHash, outputIndex] = parts;\n    if (!txHash || !outputIndex) {\n      throw new Error(\n        `Invalid UTxO format: ${utxoStr}. Expected format is txHash#outputIndex`,\n      );\n    }\n    return {\n      txHash: txHash,\n      outputIndex: parseInt(outputIndex),\n    };\n  });\n};\n",
      "dependencies": [
        "getRequiredInputs"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/utils/transaction.ts",
      "name": "utils.transaction.ts",
      "imports": [
        {
          "module": "calculateTxHash",
          "items": [],
          "line": 56,
          "raw": "export const calculateTxHash = (txHex: string) => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "signTransaction",
          "items": [],
          "line": 61,
          "raw": "export const signTransaction = (txHex: string, signingKeys: string[]) => {",
          "source": "mesh-core-csl"
        },
        {
          "module": "evaluateTransaction",
          "items": [],
          "line": 70,
          "raw": "export const evaluateTransaction = (",
          "source": "mesh-core-csl"
        },
        {
          "module": "getTransactionInputs",
          "items": [],
          "line": 146,
          "raw": "export const getTransactionInputs = (",
          "source": "mesh-core-csl"
        },
        {
          "module": "getTransactionOutputs",
          "items": [],
          "line": 187,
          "raw": "export const getTransactionOutputs = (txHex: string): UTxO[] => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "isSuccessAction",
          "signature": "function isSuccessAction(",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 41,
          "raw": "function isSuccessAction(\n  action: ActionWasm,\n): action is { success: SuccessAction } {\n  return (action as { success: SuccessAction }).success !== undefined;\n}",
          "source": "mesh-core-csl",
          "implementation": "function isSuccessAction(\n  action: ActionWasm,\n): action is { success: SuccessAction } {\n  return (action as { success: SuccessAction }).success !== undefined;\n}"
        },
        {
          "name": "isErrorAction",
          "signature": "function isErrorAction(action: ActionWasm): action is { error: ErrorAction } {",
          "documentation": "",
          "parameters": [
            {
              "name": "action",
              "type": "ActionWasm",
              "optional": false
            }
          ],
          "returnType": "action is",
          "isPublic": true,
          "line": 47,
          "raw": "function isErrorAction(action: ActionWasm): action is { error: ErrorAction } {\n  return (action as { error: ErrorAction }).error !== undefined;\n}",
          "source": "mesh-core-csl",
          "implementation": "function isErrorAction(action: ActionWasm): action is { error: ErrorAction } {\n  return (action as { error: ErrorAction }).error !== undefined;\n}"
        },
        {
          "name": "calculateTxHash",
          "signature": "export const calculateTxHash = (txHex: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "txHex",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 56,
          "raw": "export const calculateTxHash = (txHex: string) => {\n  const result = csl.js_calculate_tx_hash(txHex);\n  return parseWasmResult(result);\n};",
          "source": "mesh-core-csl",
          "implementation": "export const calculateTxHash = (txHex: string) => {\n  const result = csl.js_calculate_tx_hash(txHex);\n  return parseWasmResult(result);\n};"
        },
        {
          "name": "signTransaction",
          "signature": "export const signTransaction = (txHex: string, signingKeys: string[]) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "txHex",
              "type": "string",
              "optional": false
            },
            {
              "name": "signingKeys",
              "type": "string[]",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 61,
          "raw": "export const signTransaction = (txHex: string, signingKeys: string[]) => {\n  const cslSigningKeys = csl.JsVecString.new();\n  signingKeys.forEach((key) => {\n    cslSigningKeys.add(key);\n  });\n  const result = csl.js_sign_transaction(txHex, cslSigningKeys);\n  return parseWasmResult(result);\n};",
          "source": "mesh-core-csl",
          "implementation": "export const signTransaction = (txHex: string, signingKeys: string[]) => {\n  const cslSigningKeys = csl.JsVecString.new();\n  signingKeys.forEach((key) => {\n    cslSigningKeys.add(key);\n  });\n  const result = csl.js_sign_transaction(txHex, cslSigningKeys);\n  return parseWasmResult(result);\n};"
        },
        {
          "name": "evaluateTransaction",
          "signature": "export const evaluateTransaction = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 70,
          "raw": "export const evaluateTransaction = (\n  txHex: string,\n  resolvedUtxos: UTxO[],\n  chainedTxs: string[],\n  network: Network,\n  slotConfig: Omit<Omit<SlotConfig, \"startEpoch\">, \"epochLength\">,\n): Omit<Action, \"data\">[] => {\n  const additionalTxs = csl.JsVecString.new();\n  for (const tx of chainedTxs) {\n    additionalTxs.add(tx);\n  }\n  const mappedUtxos = csl.JsVecString.new();\n  for (const utxo of resolvedUtxos) {\n    mappedUtxos.add(JSON.stringify(utxo));\n  }\n  const result = csl.js_evaluate_tx_scripts(\n    txHex,\n    mappedUtxos,\n    additionalTxs,\n    network,\n    JSON.stringify(slotConfig),\n  );\n  const unwrappedResult = parseWasmResult(result);\n\n  const actions = JSON.parse(unwrappedResult) as ActionWasm[];\n  let parsedSuccessActions: SuccessAction[] = [];\n  let parsedErrorActions: ErrorAction[] = [];\n  actions.map((action) => {\n    if (isSuccessAction(action)) {\n      parsedSuccessActions.push(action.success);\n    } else if (isErrorAction(action)) {\n      parsedErrorActions.push(action.error);\n    } else {\n      throw new Error(\"Invalid action type found\");\n    }\n  });\n  if (parsedErrorActions.length > 0) {\n    throw new Error(JSON.stringify(parsedErrorActions));\n  }\n  return parsedSuccessActions.map(mapAction);\n};",
          "source": "mesh-core-csl",
          "implementation": "export const evaluateTransaction = (\n  txHex: string,\n  resolvedUtxos: UTxO[],\n  chainedTxs: string[],\n  network: Network,\n  slotConfig: Omit<Omit<SlotConfig, \"startEpoch\">, \"epochLength\">,\n): Omit<Action, \"data\">[] => {\n  const additionalTxs = csl.JsVecString.new();\n  for (const tx of chainedTxs) {\n    additionalTxs.add(tx);\n  }\n  const mappedUtxos = csl.JsVecString.new();\n  for (const utxo of resolvedUtxos) {\n    mappedUtxos.add(JSON.stringify(utxo));\n  }\n  const result = csl.js_evaluate_tx_scripts(\n    txHex,\n    mappedUtxos,\n    additionalTxs,\n    network,\n    JSON.stringify(slotConfig),\n  );\n  const unwrappedResult = parseWasmResult(result);\n\n  const actions = JSON.parse(unwrappedResult) as ActionWasm[];\n  let parsedSuccessActions: SuccessAction[] = [];\n  let parsedErrorActions: ErrorAction[] = [];\n  actions.map((action) => {\n    if (isSuccessAction(action)) {\n      parsedSuccessActions.push(action.success);\n    } else if (isErrorAction(action)) {\n      parsedErrorActions.push(action.error);\n    } else {\n      throw new Error(\"Invalid action type found\");\n    }\n  });\n  if (parsedErrorActions.length > 0) {\n    throw new Error(JSON.stringify(parsedErrorActions));\n  }\n  return parsedSuccessActions.map(mapAction);\n};"
        },
        {
          "name": "mapAction",
          "signature": "const mapAction = (action: SuccessAction): Omit<Action, \"data\"> => {",
          "documentation": "",
          "parameters": [
            {
              "name": "action",
              "type": "SuccessAction",
              "optional": false
            }
          ],
          "returnType": "Omit<Action, \"data\">",
          "isPublic": true,
          "line": 112,
          "raw": "const mapAction = (action: SuccessAction): Omit<Action, \"data\"> => {\n  return {\n    index: action.index,\n    budget: mapBudget(action.budget),\n    tag: mapRedeemerTag(action.tag),\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "const mapAction = (action: SuccessAction): Omit<Action, \"data\"> => {\n  return {\n    index: action.index,\n    budget: mapBudget(action.budget),\n    tag: mapRedeemerTag(action.tag),\n  };\n};"
        },
        {
          "name": "mapBudget",
          "signature": "const mapBudget = (budget: BudgetWasm): Budget => {",
          "documentation": "",
          "parameters": [
            {
              "name": "budget",
              "type": "BudgetWasm",
              "optional": false
            }
          ],
          "returnType": "Budget",
          "isPublic": true,
          "line": 120,
          "raw": "const mapBudget = (budget: BudgetWasm): Budget => {\n  return {\n    mem: budget.mem,\n    steps: budget.steps,\n  };\n};",
          "source": "mesh-core-csl",
          "implementation": "const mapBudget = (budget: BudgetWasm): Budget => {\n  return {\n    mem: budget.mem,\n    steps: budget.steps,\n  };\n};"
        },
        {
          "name": "mapRedeemerTag",
          "signature": "const mapRedeemerTag = (tag: RedeemerTagWasm): RedeemerTagType => {",
          "documentation": "",
          "parameters": [
            {
              "name": "tag",
              "type": "RedeemerTagWasm",
              "optional": false
            }
          ],
          "returnType": "RedeemerTagType",
          "isPublic": true,
          "line": 127,
          "raw": "const mapRedeemerTag = (tag: RedeemerTagWasm): RedeemerTagType => {\n  switch (tag) {\n    case \"cert\":\n      return \"CERT\";\n    case \"mint\":\n      return \"MINT\";\n    case \"reward\":\n      return \"REWARD\";\n    case \"spend\":\n      return \"SPEND\";\n    case \"vote\":\n      return \"VOTE\";\n    case \"propose\":\n      return \"PROPOSE\";\n    default:\n      throw new Error(`Unknown RedeemerTag: ${tag}`);\n  }\n};",
          "source": "mesh-core-csl",
          "implementation": "const mapRedeemerTag = (tag: RedeemerTagWasm): RedeemerTagType => {\n  switch (tag) {\n    case \"cert\":\n      return \"CERT\";\n    case \"mint\":\n      return \"MINT\";\n    case \"reward\":\n      return \"REWARD\";\n    case \"spend\":\n      return \"SPEND\";\n    case \"vote\":\n      return \"VOTE\";\n    case \"propose\":\n      return \"PROPOSE\";\n    default:\n      throw new Error(`Unknown RedeemerTag: ${tag}`);\n  }\n};"
        },
        {
          "name": "getTransactionInputs",
          "signature": "export const getTransactionInputs = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 146,
          "raw": "export const getTransactionInputs = (\n  txHex: string,\n): {\n  txHash: string;\n  outputIndex: number;\n}[] => {\n  const inputs = [];\n  const deserializedTx = deserializeTx(txHex);\n  const body = deserializedTx.body();\n  const cslInputs = body.inputs();\n  for (let i = 0; i < cslInputs.len(); i++) {\n    const input = cslInputs.get(i);\n    inputs.push({\n      txHash: input.transaction_id().to_hex(),\n      outputIndex: input.index(),\n    });\n  }\n  const cslCollaterals = body.collateral();\n  if (cslCollaterals) {\n    for (let i = 0; i < cslCollaterals.len(); i++) {\n      const collateral = cslCollaterals.get(i);\n      inputs.push({\n        txHash: collateral.transaction_id().to_hex(),\n        outputIndex: collateral.index(),\n      });\n    }\n  }\n  const cslRefInputs = body.reference_inputs();\n  if (cslRefInputs) {\n    for (let i = 0; i < cslRefInputs.len(); i++) {\n      const refInput = cslRefInputs.get(i);\n      inputs.push({\n        txHash: refInput.transaction_id().to_hex(),\n        outputIndex: refInput.index(),\n      });\n    }\n  }\n\n  return inputs;\n};",
          "source": "mesh-core-csl",
          "implementation": "export const getTransactionInputs = (\n  txHex: string,\n): {\n  txHash: string;\n  outputIndex: number;\n}[] => {\n  const inputs = [];\n  const deserializedTx = deserializeTx(txHex);\n  const body = deserializedTx.body();\n  const cslInputs = body.inputs();\n  for (let i = 0; i < cslInputs.len(); i++) {\n    const input = cslInputs.get(i);\n    inputs.push({\n      txHash: input.transaction_id().to_hex(),\n      outputIndex: input.index(),\n    });\n  }\n  const cslCollaterals = body.collateral();\n  if (cslCollaterals) {\n    for (let i = 0; i < cslCollaterals.len(); i++) {\n      const collateral = cslCollaterals.get(i);\n      inputs.push({\n        txHash: collateral.transaction_id().to_hex(),\n        outputIndex: collateral.index(),\n      });\n    }\n  }\n  const cslRefInputs = body.reference_inputs();\n  if (cslRefInputs) {\n    for (let i = 0; i < cslRefInputs.len(); i++) {\n      const refInput = cslRefInputs.get(i);\n      inputs.push({\n        txHash: refInput.transaction_id().to_hex(),\n        outputIndex: refInput.index(),\n      });\n    }\n  }\n\n  return inputs;\n};"
        },
        {
          "name": "getTransactionOutputs",
          "signature": "export const getTransactionOutputs = (txHex: string): UTxO[] => {",
          "documentation": "",
          "parameters": [
            {
              "name": "txHex",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "UTxO[]",
          "isPublic": true,
          "line": 187,
          "raw": "export const getTransactionOutputs = (txHex: string): UTxO[] => {\n  const outputs = js_get_tx_outs_utxo(txHex).get_data();\n  const utxos: UTxO[] = JSON.parse(outputs);\n  return utxos;\n};",
          "source": "mesh-core-csl",
          "implementation": "export const getTransactionOutputs = (txHex: string): UTxO[] => {\n  const outputs = js_get_tx_outs_utxo(txHex).get_data();\n  const utxos: UTxO[] = JSON.parse(outputs);\n  return utxos;\n};"
        }
      ],
      "types": [
        {
          "name": "RedeemerTagWasm",
          "definition": "type RedeemerTagWasm =\n  | \"cert\"\n  | \"mint\"\n  | \"reward\"\n  | \"spend\"\n  | \"vote\"\n  | \"propose\";",
          "isPublic": true,
          "line": 15,
          "raw": "type RedeemerTagWasm =",
          "source": "mesh-core-csl"
        },
        {
          "name": "ActionWasm",
          "definition": "type ActionWasm =\n  | {\n      success: SuccessAction;\n    }",
          "isPublic": true,
          "line": 22,
          "raw": "type ActionWasm =",
          "source": "mesh-core-csl"
        },
        {
          "name": "SuccessAction",
          "definition": "type SuccessAction = {\n  index: number;\n  budget: BudgetWasm;",
          "isPublic": true,
          "line": 29,
          "raw": "type SuccessAction = {",
          "source": "mesh-core-csl"
        },
        {
          "name": "ErrorAction",
          "definition": "type ErrorAction = {\n  index: number;\n  budget: BudgetWasm;",
          "isPublic": true,
          "line": 34,
          "raw": "type ErrorAction = {",
          "source": "mesh-core-csl"
        },
        {
          "name": "BudgetWasm",
          "definition": "type BudgetWasm = {\n  mem: number;\n  steps: number;",
          "isPublic": true,
          "line": 51,
          "raw": "type BudgetWasm = {",
          "source": "mesh-core-csl"
        }
      ],
      "constants": [
        {
          "name": "calculateTxHash",
          "type": "any",
          "value": "(txHex: string) => {",
          "isPublic": true,
          "line": 56,
          "raw": "export const calculateTxHash = (txHex: string) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "result",
          "type": "any",
          "value": "csl.js_calculate_tx_hash(txHex);",
          "isPublic": true,
          "line": 57,
          "raw": "const result = csl.js_calculate_tx_hash(txHex);",
          "source": "mesh-core-csl"
        },
        {
          "name": "signTransaction",
          "type": "any",
          "value": "(txHex: string, signingKeys: string[]) => {",
          "isPublic": true,
          "line": 61,
          "raw": "export const signTransaction = (txHex: string, signingKeys: string[]) => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "cslSigningKeys",
          "type": "any",
          "value": "csl.JsVecString.new();",
          "isPublic": true,
          "line": 62,
          "raw": "const cslSigningKeys = csl.JsVecString.new();",
          "source": "mesh-core-csl"
        },
        {
          "name": "result",
          "type": "any",
          "value": "csl.js_sign_transaction(txHex, cslSigningKeys);",
          "isPublic": true,
          "line": 66,
          "raw": "const result = csl.js_sign_transaction(txHex, cslSigningKeys);",
          "source": "mesh-core-csl"
        },
        {
          "name": "evaluateTransaction",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 70,
          "raw": "export const evaluateTransaction = (",
          "source": "mesh-core-csl"
        },
        {
          "name": "additionalTxs",
          "type": "any",
          "value": "csl.JsVecString.new();",
          "isPublic": true,
          "line": 77,
          "raw": "const additionalTxs = csl.JsVecString.new();",
          "source": "mesh-core-csl"
        },
        {
          "name": "mappedUtxos",
          "type": "any",
          "value": "csl.JsVecString.new();",
          "isPublic": true,
          "line": 81,
          "raw": "const mappedUtxos = csl.JsVecString.new();",
          "source": "mesh-core-csl"
        },
        {
          "name": "result",
          "type": "any",
          "value": "csl.js_evaluate_tx_scripts(",
          "isPublic": true,
          "line": 85,
          "raw": "const result = csl.js_evaluate_tx_scripts(",
          "source": "mesh-core-csl"
        },
        {
          "name": "unwrappedResult",
          "type": "any",
          "value": "parseWasmResult(result);",
          "isPublic": true,
          "line": 92,
          "raw": "const unwrappedResult = parseWasmResult(result);",
          "source": "mesh-core-csl"
        },
        {
          "name": "actions",
          "type": "any",
          "value": "JSON.parse(unwrappedResult) as ActionWasm[];",
          "isPublic": true,
          "line": 94,
          "raw": "const actions = JSON.parse(unwrappedResult) as ActionWasm[];",
          "source": "mesh-core-csl"
        },
        {
          "name": "mapAction",
          "type": "any",
          "value": "(action: SuccessAction): Omit<Action, \"data\"> => {",
          "isPublic": true,
          "line": 112,
          "raw": "const mapAction = (action: SuccessAction): Omit<Action, \"data\"> => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "mapBudget",
          "type": "any",
          "value": "(budget: BudgetWasm): Budget => {",
          "isPublic": true,
          "line": 120,
          "raw": "const mapBudget = (budget: BudgetWasm): Budget => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "mapRedeemerTag",
          "type": "any",
          "value": "(tag: RedeemerTagWasm): RedeemerTagType => {",
          "isPublic": true,
          "line": 127,
          "raw": "const mapRedeemerTag = (tag: RedeemerTagWasm): RedeemerTagType => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "getTransactionInputs",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 146,
          "raw": "export const getTransactionInputs = (",
          "source": "mesh-core-csl"
        },
        {
          "name": "inputs",
          "type": "any",
          "value": "[];",
          "isPublic": true,
          "line": 152,
          "raw": "const inputs = [];",
          "source": "mesh-core-csl"
        },
        {
          "name": "deserializedTx",
          "type": "any",
          "value": "deserializeTx(txHex);",
          "isPublic": true,
          "line": 153,
          "raw": "const deserializedTx = deserializeTx(txHex);",
          "source": "mesh-core-csl"
        },
        {
          "name": "body",
          "type": "any",
          "value": "deserializedTx.body();",
          "isPublic": true,
          "line": 154,
          "raw": "const body = deserializedTx.body();",
          "source": "mesh-core-csl"
        },
        {
          "name": "cslInputs",
          "type": "any",
          "value": "body.inputs();",
          "isPublic": true,
          "line": 155,
          "raw": "const cslInputs = body.inputs();",
          "source": "mesh-core-csl"
        },
        {
          "name": "input",
          "type": "any",
          "value": "cslInputs.get(i);",
          "isPublic": true,
          "line": 157,
          "raw": "const input = cslInputs.get(i);",
          "source": "mesh-core-csl"
        },
        {
          "name": "cslCollaterals",
          "type": "any",
          "value": "body.collateral();",
          "isPublic": true,
          "line": 163,
          "raw": "const cslCollaterals = body.collateral();",
          "source": "mesh-core-csl"
        },
        {
          "name": "collateral",
          "type": "any",
          "value": "cslCollaterals.get(i);",
          "isPublic": true,
          "line": 166,
          "raw": "const collateral = cslCollaterals.get(i);",
          "source": "mesh-core-csl"
        },
        {
          "name": "cslRefInputs",
          "type": "any",
          "value": "body.reference_inputs();",
          "isPublic": true,
          "line": 173,
          "raw": "const cslRefInputs = body.reference_inputs();",
          "source": "mesh-core-csl"
        },
        {
          "name": "refInput",
          "type": "any",
          "value": "cslRefInputs.get(i);",
          "isPublic": true,
          "line": 176,
          "raw": "const refInput = cslRefInputs.get(i);",
          "source": "mesh-core-csl"
        },
        {
          "name": "getTransactionOutputs",
          "type": "any",
          "value": "(txHex: string): UTxO[] => {",
          "isPublic": true,
          "line": 187,
          "raw": "export const getTransactionOutputs = (txHex: string): UTxO[] => {",
          "source": "mesh-core-csl"
        },
        {
          "name": "outputs",
          "type": "any",
          "value": "js_get_tx_outs_utxo(txHex).get_data();",
          "isPublic": true,
          "line": 188,
          "raw": "const outputs = js_get_tx_outs_utxo(txHex).get_data();",
          "source": "mesh-core-csl"
        },
        {
          "name": "utxos",
          "type": "UTxO[]",
          "value": "JSON.parse(outputs);",
          "isPublic": true,
          "line": 189,
          "raw": "const utxos: UTxO[] = JSON.parse(outputs);",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { js_get_tx_outs_utxo } from \"@sidan-lab/whisky-js-nodejs\";\n\nimport {\n  Action,\n  Budget,\n  Network,\n  RedeemerTagType,\n  SlotConfig,\n  UTxO,\n} from \"@meshsdk/common\";\n\nimport { csl, deserializeTx } from \"../deser\";\nimport { parseWasmResult } from \"../wasm\";\n\ntype RedeemerTagWasm =\n  | \"cert\"\n  | \"mint\"\n  | \"reward\"\n  | \"spend\"\n  | \"vote\"\n  | \"propose\";\ntype ActionWasm =\n  | {\n      success: SuccessAction;\n    }\n  | {\n      error: ErrorAction;\n    };\ntype SuccessAction = {\n  index: number;\n  budget: BudgetWasm;\n  tag: RedeemerTagWasm;\n};\ntype ErrorAction = {\n  index: number;\n  budget: BudgetWasm;\n  tag: RedeemerTagWasm;\n  errorMessage: string;\n  logs: string[];\n};\nfunction isSuccessAction(\n  action: ActionWasm,\n): action is { success: SuccessAction } {\n  return (action as { success: SuccessAction }).success !== undefined;\n}\n\nfunction isErrorAction(action: ActionWasm): action is { error: ErrorAction } {\n  return (action as { error: ErrorAction }).error !== undefined;\n}\n\ntype BudgetWasm = {\n  mem: number;\n  steps: number;\n};\n\nexport const calculateTxHash = (txHex: string) => {\n  const result = csl.js_calculate_tx_hash(txHex);\n  return parseWasmResult(result);\n};\n\nexport const signTransaction = (txHex: string, signingKeys: string[]) => {\n  const cslSigningKeys = csl.JsVecString.new();\n  signingKeys.forEach((key) => {\n    cslSigningKeys.add(key);\n  });\n  const result = csl.js_sign_transaction(txHex, cslSigningKeys);\n  return parseWasmResult(result);\n};\n\nexport const evaluateTransaction = (\n  txHex: string,\n  resolvedUtxos: UTxO[],\n  chainedTxs: string[],\n  network: Network,\n  slotConfig: Omit<Omit<SlotConfig, \"startEpoch\">, \"epochLength\">,\n): Omit<Action, \"data\">[] => {\n  const additionalTxs = csl.JsVecString.new();\n  for (const tx of chainedTxs) {\n    additionalTxs.add(tx);\n  }\n  const mappedUtxos = csl.JsVecString.new();\n  for (const utxo of resolvedUtxos) {\n    mappedUtxos.add(JSON.stringify(utxo));\n  }\n  const result = csl.js_evaluate_tx_scripts(\n    txHex,\n    mappedUtxos,\n    additionalTxs,\n    network,\n    JSON.stringify(slotConfig),\n  );\n  const unwrappedResult = parseWasmResult(result);\n\n  const actions = JSON.parse(unwrappedResult) as ActionWasm[];\n  let parsedSuccessActions: SuccessAction[] = [];\n  let parsedErrorActions: ErrorAction[] = [];\n  actions.map((action) => {\n    if (isSuccessAction(action)) {\n      parsedSuccessActions.push(action.success);\n    } else if (isErrorAction(action)) {\n      parsedErrorActions.push(action.error);\n    } else {\n      throw new Error(\"Invalid action type found\");\n    }\n  });\n  if (parsedErrorActions.length > 0) {\n    throw new Error(JSON.stringify(parsedErrorActions));\n  }\n  return parsedSuccessActions.map(mapAction);\n};\n\nconst mapAction = (action: SuccessAction): Omit<Action, \"data\"> => {\n  return {\n    index: action.index,\n    budget: mapBudget(action.budget),\n    tag: mapRedeemerTag(action.tag),\n  };\n};\n\nconst mapBudget = (budget: BudgetWasm): Budget => {\n  return {\n    mem: budget.mem,\n    steps: budget.steps,\n  };\n};\n\nconst mapRedeemerTag = (tag: RedeemerTagWasm): RedeemerTagType => {\n  switch (tag) {\n    case \"cert\":\n      return \"CERT\";\n    case \"mint\":\n      return \"MINT\";\n    case \"reward\":\n      return \"REWARD\";\n    case \"spend\":\n      return \"SPEND\";\n    case \"vote\":\n      return \"VOTE\";\n    case \"propose\":\n      return \"PROPOSE\";\n    default:\n      throw new Error(`Unknown RedeemerTag: ${tag}`);\n  }\n};\n\nexport const getTransactionInputs = (\n  txHex: string,\n): {\n  txHash: string;\n  outputIndex: number;\n}[] => {\n  const inputs = [];\n  const deserializedTx = deserializeTx(txHex);\n  const body = deserializedTx.body();\n  const cslInputs = body.inputs();\n  for (let i = 0; i < cslInputs.len(); i++) {\n    const input = cslInputs.get(i);\n    inputs.push({\n      txHash: input.transaction_id().to_hex(),\n      outputIndex: input.index(),\n    });\n  }\n  const cslCollaterals = body.collateral();\n  if (cslCollaterals) {\n    for (let i = 0; i < cslCollaterals.len(); i++) {\n      const collateral = cslCollaterals.get(i);\n      inputs.push({\n        txHash: collateral.transaction_id().to_hex(),\n        outputIndex: collateral.index(),\n      });\n    }\n  }\n  const cslRefInputs = body.reference_inputs();\n  if (cslRefInputs) {\n    for (let i = 0; i < cslRefInputs.len(); i++) {\n      const refInput = cslRefInputs.get(i);\n      inputs.push({\n        txHash: refInput.transaction_id().to_hex(),\n        outputIndex: refInput.index(),\n      });\n    }\n  }\n\n  return inputs;\n};\n\nexport const getTransactionOutputs = (txHex: string): UTxO[] => {\n  const outputs = js_get_tx_outs_utxo(txHex).get_data();\n  const utxos: UTxO[] = JSON.parse(outputs);\n  return utxos;\n};\n",
      "dependencies": [
        "calculateTxHash",
        "signTransaction",
        "evaluateTransaction",
        "getTransactionInputs",
        "getTransactionOutputs"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-csl:wasm.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-csl/src/wasm.ts",
      "name": "wasm.ts",
      "imports": [
        {
          "module": "parseWasmResult",
          "items": [],
          "line": 3,
          "raw": "export const parseWasmResult = (result: csl.WasmResult): string => {",
          "source": "mesh-core-csl"
        }
      ],
      "functions": [
        {
          "name": "parseWasmResult",
          "signature": "export const parseWasmResult = (result: csl.WasmResult): string => {",
          "documentation": "",
          "parameters": [
            {
              "name": "result",
              "type": "csl.WasmResult",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 3,
          "raw": "export const parseWasmResult = (result: csl.WasmResult): string => {\n  if (result.get_status() !== \"success\") {\n    throw new Error(result.get_error());\n  }\n  return result.get_data();\n};",
          "source": "mesh-core-csl",
          "implementation": "export const parseWasmResult = (result: csl.WasmResult): string => {\n  if (result.get_status() !== \"success\") {\n    throw new Error(result.get_error());\n  }\n  return result.get_data();\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "parseWasmResult",
          "type": "any",
          "value": "(result: csl.WasmResult): string => {",
          "isPublic": true,
          "line": 3,
          "raw": "export const parseWasmResult = (result: csl.WasmResult): string => {",
          "source": "mesh-core-csl"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { csl } from \"./deser/csl\";\n\nexport const parseWasmResult = (result: csl.WasmResult): string => {\n  if (result.get_status() !== \"success\") {\n    throw new Error(result.get_error());\n  }\n  return result.get_data();\n};\n",
      "dependencies": [
        "parseWasmResult"
      ],
      "source": "mesh-core-csl",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/index.ts",
      "name": "index.ts",
      "imports": [
        {
          "module": "Cardano",
          "items": [],
          "line": 14,
          "raw": "export { Cardano, Serialization };",
          "source": "mesh-core-cst"
        },
        {
          "module": "Serialization",
          "items": [],
          "line": 14,
          "raw": "export { Cardano, Serialization };",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { Cardano, Serialization } from \"@cardano-sdk/core\";\n\nexport * from \"./types\";\nexport * from \"./message-signing\";\nexport * from \"./resolvers\";\nexport * from \"./serializer\";\nexport * from \"./utils\";\nexport * from \"./plutus-tools\";\n\nexport * as CardanoSDKUtil from \"@cardano-sdk/util\";\nexport * as Crypto from \"@cardano-sdk/crypto\";\nexport * as CardanoSDK from \"@cardano-sdk/core\";\n\nexport { Cardano, Serialization };\n",
      "dependencies": [
        "Cardano",
        "Serialization"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:message-signing.check-signature.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/message-signing/check-signature.ts",
      "name": "message-signing.check-signature.ts",
      "imports": [
        {
          "module": "checkSignature",
          "items": [],
          "line": 24,
          "raw": "export const checkSignature = async (",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "if",
          "signature": "if (builder.getPayload() === null) {",
          "documentation": "",
          "parameters": [
            {
              "name": "builder.getPayload(",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 106,
          "raw": "  if (builder.getPayload() === null) {\n    return false;\n  }",
          "source": "mesh-core-cst",
          "implementation": "  if (builder.getPayload() === null) {\n    return false;\n  }"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "checkSignature",
          "type": "any",
          "value": "async (",
          "isPublic": true,
          "line": 24,
          "raw": "export const checkSignature = async (",
          "source": "mesh-core-cst"
        },
        {
          "name": "builder",
          "type": "any",
          "value": "CoseSign1.fromCbor(signature);",
          "isPublic": true,
          "line": 30,
          "raw": "const builder = CoseSign1.fromCbor(signature);",
          "source": "mesh-core-cst"
        },
        {
          "name": "publicKeyBuffer",
          "type": "any",
          "value": "getPublicKeyFromCoseKey(key);",
          "isPublic": true,
          "line": 31,
          "raw": "const publicKeyBuffer = getPublicKeyFromCoseKey(key);",
          "source": "mesh-core-cst"
        },
        {
          "name": "paymentAddress",
          "type": "any",
          "value": "BaseAddress.fromAddress(Address.fromBech32(address));",
          "isPublic": true,
          "line": 35,
          "raw": "const paymentAddress = BaseAddress.fromAddress(Address.fromBech32(address));",
          "source": "mesh-core-cst"
        },
        {
          "name": "coseSign1PublicKey",
          "type": "any",
          "value": "Ed25519PublicKey.fromBytes(publicKeyBuffer);",
          "isPublic": true,
          "line": 36,
          "raw": "const coseSign1PublicKey = Ed25519PublicKey.fromBytes(publicKeyBuffer);",
          "source": "mesh-core-cst"
        },
        {
          "name": "credential",
          "type": "CredentialCore",
          "value": "{",
          "isPublic": true,
          "line": 38,
          "raw": "const credential: CredentialCore = {",
          "source": "mesh-core-cst"
        },
        {
          "name": "stakeCredential",
          "type": "any",
          "value": "paymentAddress?.getStakeCredential();",
          "isPublic": true,
          "line": 50,
          "raw": "const stakeCredential = paymentAddress?.getStakeCredential();",
          "source": "mesh-core-cst"
        },
        {
          "name": "paymentAddressBech32",
          "type": "any",
          "value": "BaseAddress.fromCredentials(",
          "isPublic": true,
          "line": 52,
          "raw": "const paymentAddressBech32 = BaseAddress.fromCredentials(",
          "source": "mesh-core-cst"
        },
        {
          "name": "extractedRewardAddress",
          "type": "any",
          "value": "RewardAddress.fromCredentials(",
          "isPublic": true,
          "line": 61,
          "raw": "const extractedRewardAddress = RewardAddress.fromCredentials(",
          "source": "mesh-core-cst"
        },
        {
          "name": "rewardAddress",
          "type": "any",
          "value": "RewardAddress.fromCredentials(",
          "isPublic": true,
          "line": 68,
          "raw": "const rewardAddress = RewardAddress.fromCredentials(",
          "source": "mesh-core-cst"
        },
        {
          "name": "enterpriseAddress",
          "type": "any",
          "value": "EnterpriseAddress.fromCredentials(",
          "isPublic": true,
          "line": 80,
          "raw": "const enterpriseAddress = EnterpriseAddress.fromCredentials(",
          "source": "mesh-core-cst"
        },
        {
          "name": "rewardAddress",
          "type": "any",
          "value": "RewardAddress.fromCredentials(network, credential)",
          "isPublic": true,
          "line": 94,
          "raw": "const rewardAddress = RewardAddress.fromCredentials(network, credential)",
          "source": "mesh-core-cst"
        },
        {
          "name": "hexData",
          "type": "any",
          "value": "isHexString(data) ? data : stringToHex(data);",
          "isPublic": true,
          "line": 109,
          "raw": "const hexData = isHexString(data) ? data : stringToHex(data);",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { ready } from \"@cardano-sdk/crypto\";\n\nimport { DataSignature, isHexString, stringToHex } from \"@meshsdk/common\";\n\nimport {\n  Address,\n  BaseAddress,\n  CredentialCore,\n  Ed25519PublicKey,\n  EnterpriseAddress,\n  Hash28ByteBase16,\n  NetworkId,\n  RewardAddress,\n} from \"../types\";\nimport { CoseSign1, getPublicKeyFromCoseKey } from \"./cose-sign1\";\n\n/**\n * Check the signature of a given data string\n * @param data The data string to verify the signature against\n * @param {key, signature} The signature obtained by `signData`\n * @param address Optional Bech32 string of a stake, stake_test1, addr, or addr_test1 address. If provided, this function will validate the signer's address against this value.\n * @returns boolean\n */\nexport const checkSignature = async (\n  data: string,\n  { key, signature }: DataSignature,\n  address?: string,\n): Promise<boolean> => {\n  await ready();\n  const builder = CoseSign1.fromCbor(signature);\n  const publicKeyBuffer = getPublicKeyFromCoseKey(key);\n\n  if (address) {\n    let network = NetworkId.Mainnet;\n    const paymentAddress = BaseAddress.fromAddress(Address.fromBech32(address));\n    const coseSign1PublicKey = Ed25519PublicKey.fromBytes(publicKeyBuffer);\n\n    const credential: CredentialCore = {\n      hash: Hash28ByteBase16.fromEd25519KeyHashHex(\n        coseSign1PublicKey.hash().hex(),\n      ),\n      type: 0,\n    };\n\n    if (address.startsWith(\"addr\")) {\n      if (address.startsWith(\"addr_test1\")) {\n        network = NetworkId.Testnet;\n      }\n\n      const stakeCredential = paymentAddress?.getStakeCredential();\n      if (stakeCredential) {\n        const paymentAddressBech32 = BaseAddress.fromCredentials(\n          network,\n          credential,\n          stakeCredential,\n        )\n          .toAddress()\n          .toBech32();\n\n        if (address !== paymentAddressBech32) {\n          const extractedRewardAddress = RewardAddress.fromCredentials(\n            network,\n            stakeCredential,\n          )\n            .toAddress()\n            .toBech32();\n\n          const rewardAddress = RewardAddress.fromCredentials(\n            network,\n            credential,\n          )\n            .toAddress()\n            .toBech32();\n\n          if (rewardAddress !== extractedRewardAddress) {\n            return false;\n          }\n        }\n      } else {\n        const enterpriseAddress = EnterpriseAddress.fromCredentials(\n          network,\n          credential,\n        )\n          .toAddress()\n          .toBech32();\n        if (enterpriseAddress !== address) {\n          return false;\n        }\n      }\n    } else if (address.startsWith(\"stake\")) {\n      if (address.startsWith(\"stake_test1\")) {\n        network = NetworkId.Testnet;\n      }\n      const rewardAddress = RewardAddress.fromCredentials(network, credential)\n        .toAddress()\n        .toBech32();\n\n      if (rewardAddress !== address) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  if (builder.getPayload() === null) {\n    return false;\n  }\n  const hexData = isHexString(data) ? data : stringToHex(data);\n  if (Buffer.from(hexData, \"hex\").compare(builder.getPayload()!) !== 0) {\n    return false;\n  }\n\n  return builder.verifySignature({\n    publicKeyBuffer,\n  });\n};\n",
      "dependencies": [
        "checkSignature"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/message-signing/cose-sign1.ts",
      "name": "message-signing.cose-sign1.ts",
      "imports": [
        {
          "module": "CoseSign1",
          "items": [],
          "line": 246,
          "raw": "export { CoseSign1, getPublicKeyFromCoseKey, getCoseKeyFromPublicKey };",
          "source": "mesh-core-cst"
        },
        {
          "module": "getPublicKeyFromCoseKey",
          "items": [],
          "line": 246,
          "raw": "export { CoseSign1, getPublicKeyFromCoseKey, getCoseKeyFromPublicKey };",
          "source": "mesh-core-cst"
        },
        {
          "module": "getCoseKeyFromPublicKey",
          "items": [],
          "line": 246,
          "raw": "export { CoseSign1, getPublicKeyFromCoseKey, getCoseKeyFromPublicKey };",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "buildMessage",
          "signature": "buildMessage(signature: Buffer): Buffer {",
          "documentation": "",
          "parameters": [
            {
              "name": "signature",
              "type": "Buffer",
              "optional": false
            }
          ],
          "returnType": "Buffer",
          "isPublic": true,
          "line": 114,
          "raw": "  buildMessage(signature: Buffer): Buffer {\n    this.signature = new CborBytes(signature);\n\n    let protectedSerialized = new CborBytes(Buffer.alloc(0));\n    if (this.protectedMap.map.length !== 0) {\n      protectedSerialized = new CborBytes(\n        Cbor.encode(this.protectedMap).toBuffer(),\n      );\n    }\n\n    if (!this.payload) throw Error(\"Invalid payload\");\n\n    const coseSign1 = new CborArray([\n      protectedSerialized,\n      this.unProtectedMap,\n      this.payload,\n      this.signature,\n    ]);\n\n    return Buffer.from(Cbor.encode(coseSign1).toBuffer());\n  }",
          "source": "mesh-core-cst",
          "implementation": "  buildMessage(signature: Buffer): Buffer {\n    this.signature = new CborBytes(signature);\n\n    let protectedSerialized = new CborBytes(Buffer.alloc(0));\n    if (this.protectedMap.map.length !== 0) {\n      protectedSerialized = new CborBytes(\n        Cbor.encode(this.protectedMap).toBuffer(),\n      );\n    }\n\n    if (!this.payload) throw Error(\"Invalid payload\");\n\n    const coseSign1 = new CborArray([\n      protectedSerialized,\n      this.unProtectedMap,\n      this.payload,\n      this.signature,\n    ]);\n\n    return Buffer.from(Cbor.encode(coseSign1).toBuffer());\n  }"
        },
        {
          "name": "getAddress",
          "signature": "getAddress(): Buffer {",
          "documentation": "",
          "parameters": [],
          "returnType": "Buffer",
          "isPublic": true,
          "line": 190,
          "raw": "  getAddress(): Buffer {\n    const address = this.protectedMap.map.find((value) => {\n      return (\n        JSONBig.stringify(value.k) ===\n        JSONBig.stringify(new CborText(\"address\"))\n      );\n    });\n    if (!address) throw Error(\"Address not found\");\n    return Buffer.from((address.v as CborBytes).bytes);\n  }",
          "source": "mesh-core-cst",
          "implementation": "  getAddress(): Buffer {\n    const address = this.protectedMap.map.find((value) => {\n      return (\n        JSONBig.stringify(value.k) ===\n        JSONBig.stringify(new CborText(\"address\"))\n      );\n    });\n    if (!address) throw Error(\"Address not found\");\n    return Buffer.from((address.v as CborBytes).bytes);\n  }"
        },
        {
          "name": "getPublicKey",
          "signature": "getPublicKey(): Buffer {",
          "documentation": "",
          "parameters": [],
          "returnType": "Buffer",
          "isPublic": true,
          "line": 201,
          "raw": "  getPublicKey(): Buffer {\n    const publicKey = this.protectedMap.map.find((value) => {\n      return JSONBig.stringify(value.k) === JSONBig.stringify(new CborUInt(4));\n    });\n    if (!publicKey) throw Error(\"Public key not found\");\n    return Buffer.from((publicKey.v as CborBytes).bytes);\n  }",
          "source": "mesh-core-cst",
          "implementation": "  getPublicKey(): Buffer {\n    const publicKey = this.protectedMap.map.find((value) => {\n      return JSONBig.stringify(value.k) === JSONBig.stringify(new CborUInt(4));\n    });\n    if (!publicKey) throw Error(\"Public key not found\");\n    return Buffer.from((publicKey.v as CborBytes).bytes);\n  }"
        },
        {
          "name": "getSignature",
          "signature": "getSignature(): Buffer | undefined {",
          "documentation": "",
          "parameters": [],
          "returnType": "Buffer | undefined",
          "isPublic": true,
          "line": 209,
          "raw": "  getSignature(): Buffer | undefined {\n    return this.signature ? Buffer.from(this.signature.bytes) : this.signature;\n  }",
          "source": "mesh-core-cst",
          "implementation": "  getSignature(): Buffer | undefined {\n    return this.signature ? Buffer.from(this.signature.bytes) : this.signature;\n  }"
        },
        {
          "name": "getPayload",
          "signature": "getPayload(): Buffer | null {",
          "documentation": "",
          "parameters": [],
          "returnType": "Buffer | null",
          "isPublic": true,
          "line": 213,
          "raw": "  getPayload(): Buffer | null {\n    return this.payload ? Buffer.from(this.payload.bytes) : this.payload;\n  }",
          "source": "mesh-core-cst",
          "implementation": "  getPayload(): Buffer | null {\n    return this.payload ? Buffer.from(this.payload.bytes) : this.payload;\n  }"
        },
        {
          "name": "getPublicKeyFromCoseKey",
          "signature": "const getPublicKeyFromCoseKey = (cbor: string): Buffer => {",
          "documentation": "",
          "parameters": [
            {
              "name": "cbor",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Buffer",
          "isPublic": true,
          "line": 218,
          "raw": "const getPublicKeyFromCoseKey = (cbor: string): Buffer => {\n  const decodedCoseKey = Cbor.parse(cbor) as CborMap;\n  const publicKeyEntry = decodedCoseKey.map.find((value) => {\n    return (\n      JSONBig.stringify(value.k) ===\n      JSONBig.stringify(new CborNegInt(BigInt(-2)))\n    );\n  });\n\n  if (publicKeyEntry) {\n    return Buffer.from((publicKeyEntry.v as CborBytes).bytes);\n  }\n\n  throw Error(\"Public key not found\");\n};",
          "source": "mesh-core-cst",
          "implementation": "const getPublicKeyFromCoseKey = (cbor: string): Buffer => {\n  const decodedCoseKey = Cbor.parse(cbor) as CborMap;\n  const publicKeyEntry = decodedCoseKey.map.find((value) => {\n    return (\n      JSONBig.stringify(value.k) ===\n      JSONBig.stringify(new CborNegInt(BigInt(-2)))\n    );\n  });\n\n  if (publicKeyEntry) {\n    return Buffer.from((publicKeyEntry.v as CborBytes).bytes);\n  }\n\n  throw Error(\"Public key not found\");\n};"
        },
        {
          "name": "getCoseKeyFromPublicKey",
          "signature": "const getCoseKeyFromPublicKey = (cbor: string): Buffer => {",
          "documentation": "",
          "parameters": [
            {
              "name": "cbor",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Buffer",
          "isPublic": true,
          "line": 234,
          "raw": "const getCoseKeyFromPublicKey = (cbor: string): Buffer => {\n  const coseKeyMap: CborMapEntry[] = [];\n  coseKeyMap.push({ k: new CborUInt(1), v: new CborUInt(1) });\n  coseKeyMap.push({ k: new CborUInt(3), v: new CborNegInt(-8) });\n  coseKeyMap.push({ k: new CborUInt(6), v: new CborNegInt(-2) });\n  coseKeyMap.push({\n    k: new CborNegInt(-2),\n    v: new CborBytes(Buffer.from(cbor, \"hex\")),\n  });\n  return Buffer.from(Cbor.encode(new CborMap(coseKeyMap)).toBuffer());\n};",
          "source": "mesh-core-cst",
          "implementation": "const getCoseKeyFromPublicKey = (cbor: string): Buffer => {\n  const coseKeyMap: CborMapEntry[] = [];\n  coseKeyMap.push({ k: new CborUInt(1), v: new CborUInt(1) });\n  coseKeyMap.push({ k: new CborUInt(3), v: new CborNegInt(-8) });\n  coseKeyMap.push({ k: new CborUInt(6), v: new CborNegInt(-2) });\n  coseKeyMap.push({\n    k: new CborNegInt(-2),\n    v: new CborBytes(Buffer.from(cbor, \"hex\")),\n  });\n  return Buffer.from(Cbor.encode(new CborMap(coseKeyMap)).toBuffer());\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "decoded",
          "type": "any",
          "value": "Cbor.parse(cbor) as CborArray;",
          "isPublic": true,
          "line": 59,
          "raw": "const decoded = Cbor.parse(cbor) as CborArray;",
          "source": "mesh-core-cst"
        },
        {
          "name": "protectedSerialized",
          "type": "any",
          "value": "decoded.array[0] as CborBytes;",
          "isPublic": true,
          "line": 66,
          "raw": "const protectedSerialized = decoded.array[0] as CborBytes;",
          "source": "mesh-core-cst"
        },
        {
          "name": "payload",
          "type": "any",
          "value": "decoded.array[2] as CborBytes;",
          "isPublic": true,
          "line": 80,
          "raw": "const payload = decoded.array[2] as CborBytes;",
          "source": "mesh-core-cst"
        },
        {
          "name": "signature",
          "type": "any",
          "value": "decoded.array[3] as CborBytes;",
          "isPublic": true,
          "line": 83,
          "raw": "const signature = decoded.array[3] as CborBytes;",
          "source": "mesh-core-cst"
        },
        {
          "name": "structure",
          "type": "any",
          "value": "new CborArray([",
          "isPublic": true,
          "line": 104,
          "raw": "const structure = new CborArray([",
          "source": "mesh-core-cst"
        },
        {
          "name": "coseSign1",
          "type": "any",
          "value": "new CborArray([",
          "isPublic": true,
          "line": 126,
          "raw": "const coseSign1 = new CborArray([",
          "source": "mesh-core-cst"
        },
        {
          "name": "publicKey",
          "type": "any",
          "value": "new Ed25519PublicKey(publicKeyBuffer);",
          "isPublic": true,
          "line": 150,
          "raw": "const publicKey = new Ed25519PublicKey(publicKeyBuffer);",
          "source": "mesh-core-cst"
        },
        {
          "name": "hashedIndex",
          "type": "any",
          "value": "this.unProtectedMap.map.findIndex((value) => {",
          "isPublic": true,
          "line": 164,
          "raw": "const hashedIndex = this.unProtectedMap.map.findIndex((value) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "hashed",
          "type": "any",
          "value": "this.unProtectedMap.map[hashedIndex];",
          "isPublic": true,
          "line": 170,
          "raw": "const hashed = this.unProtectedMap.map[hashedIndex];",
          "source": "mesh-core-cst"
        },
        {
          "name": "hash",
          "type": "any",
          "value": "blake2b(this.payload.bytes, undefined, 24);",
          "isPublic": true,
          "line": 186,
          "raw": "const hash = blake2b(this.payload.bytes, undefined, 24);",
          "source": "mesh-core-cst"
        },
        {
          "name": "address",
          "type": "any",
          "value": "this.protectedMap.map.find((value) => {",
          "isPublic": true,
          "line": 191,
          "raw": "const address = this.protectedMap.map.find((value) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "publicKey",
          "type": "any",
          "value": "this.protectedMap.map.find((value) => {",
          "isPublic": true,
          "line": 202,
          "raw": "const publicKey = this.protectedMap.map.find((value) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "getPublicKeyFromCoseKey",
          "type": "any",
          "value": "(cbor: string): Buffer => {",
          "isPublic": true,
          "line": 218,
          "raw": "const getPublicKeyFromCoseKey = (cbor: string): Buffer => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "decodedCoseKey",
          "type": "any",
          "value": "Cbor.parse(cbor) as CborMap;",
          "isPublic": true,
          "line": 219,
          "raw": "const decodedCoseKey = Cbor.parse(cbor) as CborMap;",
          "source": "mesh-core-cst"
        },
        {
          "name": "publicKeyEntry",
          "type": "any",
          "value": "decodedCoseKey.map.find((value) => {",
          "isPublic": true,
          "line": 220,
          "raw": "const publicKeyEntry = decodedCoseKey.map.find((value) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "getCoseKeyFromPublicKey",
          "type": "any",
          "value": "(cbor: string): Buffer => {",
          "isPublic": true,
          "line": 234,
          "raw": "const getCoseKeyFromPublicKey = (cbor: string): Buffer => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "coseKeyMap",
          "type": "CborMapEntry[]",
          "value": "[];",
          "isPublic": true,
          "line": 235,
          "raw": "const coseKeyMap: CborMapEntry[] = [];",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { Buffer } from \"buffer\";\nimport {\n  Cbor,\n  CborArray,\n  CborBytes,\n  CborMap,\n  CborMapEntry,\n  CborNegInt,\n  CborSimple,\n  CborText,\n  CborUInt,\n  isRawCborArray,\n  isRawCborMap,\n  RawCborArray,\n  RawCborMap,\n} from \"@harmoniclabs/cbor\";\nimport { blake2b } from \"blakejs\";\nimport JSONBig from \"json-bigint\";\n\nimport { Ed25519PublicKey, Ed25519Signature, HexBlob } from \"../types\";\n\nclass CoseSign1 {\n  private protectedMap: CborMap;\n\n  private unProtectedMap: CborMap;\n\n  private payload: CborBytes | null;\n\n  private signature: CborBytes | undefined;\n\n  constructor(payload: {\n    protectedMap: CborMap;\n    unProtectedMap: CborMap;\n    payload: CborBytes | null;\n    signature?: CborBytes;\n  }) {\n    this.protectedMap = payload.protectedMap;\n    this.unProtectedMap = payload.unProtectedMap;\n    this.payload = payload.payload;\n\n    if (\n      !this.unProtectedMap.map.find((value) => {\n        return (\n          JSONBig.stringify(value.k) ===\n          JSONBig.stringify(new CborText(\"hashed\"))\n        );\n      })\n    ) {\n      this.unProtectedMap.map.push({\n        k: new CborText(\"hashed\"),\n        v: new CborSimple(false),\n      });\n    }\n\n    this.signature = payload.signature;\n  }\n\n  static fromCbor(cbor: string) {\n    const decoded = Cbor.parse(cbor) as CborArray;\n    if (!isRawCborArray(decoded.toRawObj() as RawCborArray))\n      throw Error(\"Invalid CBOR\");\n    if (decoded.array.length !== 4) throw Error(\"Invalid COSE_SIGN1\");\n\n    let protectedMap: CborMap;\n    // Decode and Set ProtectedMap\n    const protectedSerialized = decoded.array[0] as CborBytes;\n    try {\n      protectedMap = Cbor.parse(protectedSerialized.bytes) as CborMap;\n      if (!isRawCborMap(protectedMap.toRawObj() as RawCborMap)) {\n        throw Error();\n      }\n    } catch (error) {\n      throw Error(\"Invalid protected\");\n    }\n    // Set UnProtectedMap\n    let unProtectedMap = decoded.array[1] as CborMap;\n    if (!isRawCborMap(unProtectedMap.toRawObj() as RawCborMap))\n      throw Error(\"Invalid unprotected\");\n    // Set Payload\n    const payload = decoded.array[2] as CborBytes;\n\n    // Set Signature\n    const signature = decoded.array[3] as CborBytes;\n\n    return new CoseSign1({\n      protectedMap,\n      unProtectedMap,\n      payload,\n      signature,\n    });\n  }\n\n  createSigStructure(externalAad = Buffer.alloc(0)): Buffer {\n    let protectedSerialized = new CborBytes(Buffer.alloc(0));\n\n    if (this.protectedMap.map.length !== 0) {\n      protectedSerialized = new CborBytes(\n        Cbor.encode(this.protectedMap).toBuffer(),\n      );\n    }\n\n    if (!this.payload) throw Error(\"Invalid payload\");\n\n    const structure = new CborArray([\n      new CborText(\"Signature1\"),\n      protectedSerialized,\n      new CborBytes(externalAad),\n      this.payload,\n    ]);\n\n    return Buffer.from(Cbor.encode(structure).toBuffer());\n  }\n\n  buildMessage(signature: Buffer): Buffer {\n    this.signature = new CborBytes(signature);\n\n    let protectedSerialized = new CborBytes(Buffer.alloc(0));\n    if (this.protectedMap.map.length !== 0) {\n      protectedSerialized = new CborBytes(\n        Cbor.encode(this.protectedMap).toBuffer(),\n      );\n    }\n\n    if (!this.payload) throw Error(\"Invalid payload\");\n\n    const coseSign1 = new CborArray([\n      protectedSerialized,\n      this.unProtectedMap,\n      this.payload,\n      this.signature,\n    ]);\n\n    return Buffer.from(Cbor.encode(coseSign1).toBuffer());\n  }\n\n  verifySignature({\n    externalAad = Buffer.alloc(0),\n    publicKeyBuffer,\n  }: {\n    externalAad?: Buffer;\n    publicKeyBuffer?: Buffer;\n  } = {}): boolean {\n    if (!publicKeyBuffer) {\n      publicKeyBuffer = this.getPublicKey();\n    }\n\n    if (!publicKeyBuffer) throw Error(\"Public key not found\");\n    if (!this.signature) throw Error(\"Signature not found\");\n\n    const publicKey = new Ed25519PublicKey(publicKeyBuffer);\n\n    return publicKey.verify(\n      new Ed25519Signature(this.signature.bytes),\n      HexBlob(\n        Buffer.from(this.createSigStructure(externalAad)).toString(\"hex\"),\n      ),\n    );\n  }\n\n  hashPayload() {\n    if (!this.unProtectedMap) throw Error(\"Invalid unprotected map\");\n    if (!this.payload) throw Error(\"Invalid payload\");\n\n    const hashedIndex = this.unProtectedMap.map.findIndex((value) => {\n      return (\n        JSONBig.stringify(value.k) === JSONBig.stringify(new CborText(\"hashed\"))\n      );\n    });\n\n    const hashed = this.unProtectedMap.map[hashedIndex];\n    if (\n      hashed &&\n      JSONBig.stringify(hashed.v) === JSONBig.stringify(new CborSimple(true))\n    )\n      throw Error(\"Payload already hashed\");\n    if (\n      hashed &&\n      (JSONBig.stringify(hashed.v) ===\n        JSONBig.stringify(new CborSimple(true))) !=\n        false\n    )\n      throw Error(\"Invalid unprotected map\");\n\n    this.unProtectedMap.map.splice(hashedIndex, 1);\n\n    const hash = blake2b(this.payload.bytes, undefined, 24);\n    this.payload = new CborBytes(hash);\n  }\n\n  getAddress(): Buffer {\n    const address = this.protectedMap.map.find((value) => {\n      return (\n        JSONBig.stringify(value.k) ===\n        JSONBig.stringify(new CborText(\"address\"))\n      );\n    });\n    if (!address) throw Error(\"Address not found\");\n    return Buffer.from((address.v as CborBytes).bytes);\n  }\n\n  getPublicKey(): Buffer {\n    const publicKey = this.protectedMap.map.find((value) => {\n      return JSONBig.stringify(value.k) === JSONBig.stringify(new CborUInt(4));\n    });\n    if (!publicKey) throw Error(\"Public key not found\");\n    return Buffer.from((publicKey.v as CborBytes).bytes);\n  }\n\n  getSignature(): Buffer | undefined {\n    return this.signature ? Buffer.from(this.signature.bytes) : this.signature;\n  }\n\n  getPayload(): Buffer | null {\n    return this.payload ? Buffer.from(this.payload.bytes) : this.payload;\n  }\n}\n\nconst getPublicKeyFromCoseKey = (cbor: string): Buffer => {\n  const decodedCoseKey = Cbor.parse(cbor) as CborMap;\n  const publicKeyEntry = decodedCoseKey.map.find((value) => {\n    return (\n      JSONBig.stringify(value.k) ===\n      JSONBig.stringify(new CborNegInt(BigInt(-2)))\n    );\n  });\n\n  if (publicKeyEntry) {\n    return Buffer.from((publicKeyEntry.v as CborBytes).bytes);\n  }\n\n  throw Error(\"Public key not found\");\n};\n\nconst getCoseKeyFromPublicKey = (cbor: string): Buffer => {\n  const coseKeyMap: CborMapEntry[] = [];\n  coseKeyMap.push({ k: new CborUInt(1), v: new CborUInt(1) });\n  coseKeyMap.push({ k: new CborUInt(3), v: new CborNegInt(-8) });\n  coseKeyMap.push({ k: new CborUInt(6), v: new CborNegInt(-2) });\n  coseKeyMap.push({\n    k: new CborNegInt(-2),\n    v: new CborBytes(Buffer.from(cbor, \"hex\")),\n  });\n  return Buffer.from(Cbor.encode(new CborMap(coseKeyMap)).toBuffer());\n};\n\nexport { CoseSign1, getPublicKeyFromCoseKey, getCoseKeyFromPublicKey };\n",
      "dependencies": [
        "CoseSign1",
        "getPublicKeyFromCoseKey",
        "getCoseKeyFromPublicKey"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:message-signing.generate-nonce.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/message-signing/generate-nonce.ts",
      "name": "message-signing.generate-nonce.ts",
      "imports": [
        {
          "module": "generateNonce",
          "items": [],
          "line": 11,
          "raw": "export const generateNonce = (label = \"\", length = 32) => {",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "generateNonce",
          "signature": "export const generateNonce = (label = \"\", length = 32) => {",
          "documentation": "/**\n * Generate a nonce string\n * @param label The label to prepend to the nonce\n * @param length The length of the nonce\n * @returns The generated nonce in hex format\n */",
          "parameters": [
            {
              "name": "label",
              "type": "any",
              "optional": false
            },
            {
              "name": "length",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 11,
          "raw": "/**\n * Generate a nonce string\n * @param label The label to prepend to the nonce\n * @param length The length of the nonce\n * @returns The generated nonce in hex format\n */\nexport const generateNonce = (label = \"\", length = 32) => {\n  if (length <= 0 || length > 2048) {\n    throw new Error(\"Length must be bewteen 1 and 2048\");\n  }\n  const randomString = customAlphabet(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n  );\n  const payload = randomString(length);\n  return stringToHex(`${label}${payload}`);\n};",
          "source": "mesh-core-cst",
          "implementation": "export const generateNonce = (label = \"\", length = 32) => {\n  if (length <= 0 || length > 2048) {\n    throw new Error(\"Length must be bewteen 1 and 2048\");\n  }\n  const randomString = customAlphabet(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n  );\n  const payload = randomString(length);\n  return stringToHex(`${label}${payload}`);\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "generateNonce",
          "type": "any",
          "value": "(label = \"\", length = 32) => {",
          "isPublic": true,
          "line": 11,
          "raw": "export const generateNonce = (label = \"\", length = 32) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "randomString",
          "type": "any",
          "value": "customAlphabet(",
          "isPublic": true,
          "line": 15,
          "raw": "const randomString = customAlphabet(",
          "source": "mesh-core-cst"
        },
        {
          "name": "payload",
          "type": "any",
          "value": "randomString(length);",
          "isPublic": true,
          "line": 18,
          "raw": "const payload = randomString(length);",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { customAlphabet } from \"nanoid\";\n\nimport { stringToHex } from \"@meshsdk/common\";\n\n/**\n * Generate a nonce string\n * @param label The label to prepend to the nonce\n * @param length The length of the nonce\n * @returns The generated nonce in hex format\n */\nexport const generateNonce = (label = \"\", length = 32) => {\n  if (length <= 0 || length > 2048) {\n    throw new Error(\"Length must be bewteen 1 and 2048\");\n  }\n  const randomString = customAlphabet(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n  );\n  const payload = randomString(length);\n  return stringToHex(`${label}${payload}`);\n};\n",
      "dependencies": [
        "generateNonce"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:message-signing.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/message-signing/index.ts",
      "name": "message-signing.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./check-signature\";\nexport * from \"./cose-sign1\";\nexport * from \"./generate-nonce\";\nexport * from \"./sign-data\";\n",
      "dependencies": [],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:message-signing.sign-data.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/message-signing/sign-data.ts",
      "name": "message-signing.sign-data.ts",
      "imports": [
        {
          "module": "signData",
          "items": [],
          "line": 23,
          "raw": "export const signData = (data: string, signer: Signer): DataSignature => {",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "signData",
          "signature": "export const signData = (data: string, signer: Signer): DataSignature => {",
          "documentation": "/**\n * Sign the data string using the provided signer\n * @param data The data string to sign\n * @param signer The signer object containing the key and address\n * @returns DataSignature for verification\n */",
          "parameters": [
            {
              "name": "data",
              "type": "string",
              "optional": false
            },
            {
              "name": "signer",
              "type": "Signer",
              "optional": false
            }
          ],
          "returnType": "DataSignature",
          "isPublic": true,
          "line": 23,
          "raw": "/**\n * Sign the data string using the provided signer\n * @param data The data string to sign\n * @param signer The signer object containing the key and address\n * @returns DataSignature for verification\n */\nexport const signData = (data: string, signer: Signer): DataSignature => {\n  const hexData = isHexString(data) ? data : stringToHex(data);\n  const payload = Buffer.from(hexData, \"hex\");\n  const publicKey = Buffer.from(signer.key.toPublic().bytes());\n\n  const protectedMap: CborMapEntry[] = [];\n  // Set protected headers as per CIP08\n  // Set Algorthm used by Cardano keys\n  protectedMap.push({ k: new CborUInt(1), v: new CborNegInt(-8) });\n  // Set PublicKey\n  protectedMap.push({ k: new CborUInt(4), v: new CborBytes(publicKey) });\n  // Set Address\n  protectedMap.push({\n    k: new CborText(\"address\"),\n    v: new CborBytes(Buffer.from(signer.address.toBytes(), \"hex\")),\n  });\n\n  const coseSign1Builder = new CoseSign1({\n    protectedMap: new CborMap(protectedMap),\n    unProtectedMap: new CborMap([]),\n    payload: new CborBytes(payload),\n  });\n\n  const signature = signer.key.sign(\n    HexBlob(Buffer.from(coseSign1Builder.createSigStructure()).toString(\"hex\")),\n  );\n\n  const coseSignature = coseSign1Builder\n    .buildMessage(Buffer.from(signature.bytes()))\n    .toString(\"hex\");\n\n  return {\n    key: getCoseKeyFromPublicKey(publicKey.toString(\"hex\")).toString(\"hex\"),\n    signature: coseSignature,\n  };\n};",
          "source": "mesh-core-cst",
          "implementation": "export const signData = (data: string, signer: Signer): DataSignature => {\n  const hexData = isHexString(data) ? data : stringToHex(data);\n  const payload = Buffer.from(hexData, \"hex\");\n  const publicKey = Buffer.from(signer.key.toPublic().bytes());\n\n  const protectedMap: CborMapEntry[] = [];\n  // Set protected headers as per CIP08\n  // Set Algorthm used by Cardano keys\n  protectedMap.push({ k: new CborUInt(1), v: new CborNegInt(-8) });\n  // Set PublicKey\n  protectedMap.push({ k: new CborUInt(4), v: new CborBytes(publicKey) });\n  // Set Address\n  protectedMap.push({\n    k: new CborText(\"address\"),\n    v: new CborBytes(Buffer.from(signer.address.toBytes(), \"hex\")),\n  });\n\n  const coseSign1Builder = new CoseSign1({\n    protectedMap: new CborMap(protectedMap),\n    unProtectedMap: new CborMap([]),\n    payload: new CborBytes(payload),\n  });\n\n  const signature = signer.key.sign(\n    HexBlob(Buffer.from(coseSign1Builder.createSigStructure()).toString(\"hex\")),\n  );\n\n  const coseSignature = coseSign1Builder\n    .buildMessage(Buffer.from(signature.bytes()))\n    .toString(\"hex\");\n\n  return {\n    key: getCoseKeyFromPublicKey(publicKey.toString(\"hex\")).toString(\"hex\"),\n    signature: coseSignature,\n  };\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "signData",
          "type": "any",
          "value": "(data: string, signer: Signer): DataSignature => {",
          "isPublic": true,
          "line": 23,
          "raw": "export const signData = (data: string, signer: Signer): DataSignature => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "hexData",
          "type": "any",
          "value": "isHexString(data) ? data : stringToHex(data);",
          "isPublic": true,
          "line": 24,
          "raw": "const hexData = isHexString(data) ? data : stringToHex(data);",
          "source": "mesh-core-cst"
        },
        {
          "name": "payload",
          "type": "any",
          "value": "Buffer.from(hexData, \"hex\");",
          "isPublic": true,
          "line": 25,
          "raw": "const payload = Buffer.from(hexData, \"hex\");",
          "source": "mesh-core-cst"
        },
        {
          "name": "publicKey",
          "type": "any",
          "value": "Buffer.from(signer.key.toPublic().bytes());",
          "isPublic": true,
          "line": 26,
          "raw": "const publicKey = Buffer.from(signer.key.toPublic().bytes());",
          "source": "mesh-core-cst"
        },
        {
          "name": "protectedMap",
          "type": "CborMapEntry[]",
          "value": "[];",
          "isPublic": true,
          "line": 28,
          "raw": "const protectedMap: CborMapEntry[] = [];",
          "source": "mesh-core-cst"
        },
        {
          "name": "coseSign1Builder",
          "type": "any",
          "value": "new CoseSign1({",
          "isPublic": true,
          "line": 40,
          "raw": "const coseSign1Builder = new CoseSign1({",
          "source": "mesh-core-cst"
        },
        {
          "name": "signature",
          "type": "any",
          "value": "signer.key.sign(",
          "isPublic": true,
          "line": 46,
          "raw": "const signature = signer.key.sign(",
          "source": "mesh-core-cst"
        },
        {
          "name": "coseSignature",
          "type": "any",
          "value": "coseSign1Builder",
          "isPublic": true,
          "line": 50,
          "raw": "const coseSignature = coseSign1Builder",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  CborBytes,\n  CborMap,\n  CborMapEntry,\n  CborNegInt,\n  CborText,\n  CborUInt,\n} from \"@harmoniclabs/cbor\";\n\nimport { DataSignature, stringToHex, isHexString} from \"@meshsdk/common\";\n\nimport { HexBlob, Signer } from \"../types\";\nimport { CoseSign1, getCoseKeyFromPublicKey } from \"./cose-sign1\";\n\n\n\n/**\n * Sign the data string using the provided signer\n * @param data The data string to sign\n * @param signer The signer object containing the key and address\n * @returns DataSignature for verification\n */\nexport const signData = (data: string, signer: Signer): DataSignature => {\n  const hexData = isHexString(data) ? data : stringToHex(data);\n  const payload = Buffer.from(hexData, \"hex\");\n  const publicKey = Buffer.from(signer.key.toPublic().bytes());\n\n  const protectedMap: CborMapEntry[] = [];\n  // Set protected headers as per CIP08\n  // Set Algorthm used by Cardano keys\n  protectedMap.push({ k: new CborUInt(1), v: new CborNegInt(-8) });\n  // Set PublicKey\n  protectedMap.push({ k: new CborUInt(4), v: new CborBytes(publicKey) });\n  // Set Address\n  protectedMap.push({\n    k: new CborText(\"address\"),\n    v: new CborBytes(Buffer.from(signer.address.toBytes(), \"hex\")),\n  });\n\n  const coseSign1Builder = new CoseSign1({\n    protectedMap: new CborMap(protectedMap),\n    unProtectedMap: new CborMap([]),\n    payload: new CborBytes(payload),\n  });\n\n  const signature = signer.key.sign(\n    HexBlob(Buffer.from(coseSign1Builder.createSigStructure()).toString(\"hex\")),\n  );\n\n  const coseSignature = coseSign1Builder\n    .buildMessage(Buffer.from(signature.bytes()))\n    .toString(\"hex\");\n\n  return {\n    key: getCoseKeyFromPublicKey(publicKey.toString(\"hex\")).toString(\"hex\"),\n    signature: coseSignature,\n  };\n};\n",
      "dependencies": [
        "signData"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/plutus-tools/index.ts",
      "name": "plutus-tools.index.ts",
      "imports": [
        {
          "module": "OutputEncoding",
          "items": [],
          "line": 59,
          "raw": "export type OutputEncoding =",
          "source": "mesh-core-cst"
        },
        {
          "module": "normalizePlutusScript",
          "items": [],
          "line": 121,
          "raw": "export const normalizePlutusScript = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "applyEncoding",
          "items": [],
          "line": 174,
          "raw": "export const applyEncoding = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "applyParamsToScript",
          "items": [],
          "line": 190,
          "raw": "export const applyParamsToScript = (",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "applyArgsToPlutusScript",
          "signature": "const applyArgsToPlutusScript = (",
          "documentation": "/**\n * Applies arguments to a Plutus script, effectively parameterizing the script with provided data.\n *\n * @param {Uint8Array[]} args - An array of arguments to be applied to the script, each as a Uint8Array.\n * @param {Uint8Array} program - The original Plutus script as a Uint8Array.\n * @param {OutputEncoding} outputEncoding - The desired encoding for the output.\n * @returns {Uint8Array} The modified Plutus script with applied arguments.\n *\n * @description\n * This function performs the following steps:\n * 1. Extracts the pure Plutus bytes from the input program.\n * 2. Parses the UPLC (Untyped Plutus Core) from the pure Plutus bytes.\n * 3. Decodes the provided arguments from CBOR format.\n * 4. Iterates through the decoded arguments, applying each as a term to the program body.\n * 5. Creates a new UPLC program with the modified body.\n * 6. Encodes the new program and applies the specified output encoding.\n *\n * @note\n * - This function modifies the structure of the Plutus script by applying arguments, which can change its behavior when executed.\n * - The function assumes that the input arguments are in a compatible format (CBOR-encoded) and that the program is a valid Plutus script.\n */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 85,
          "raw": "/**\n * Applies arguments to a Plutus script, effectively parameterizing the script with provided data.\n *\n * @param {Uint8Array[]} args - An array of arguments to be applied to the script, each as a Uint8Array.\n * @param {Uint8Array} program - The original Plutus script as a Uint8Array.\n * @param {OutputEncoding} outputEncoding - The desired encoding for the output.\n * @returns {Uint8Array} The modified Plutus script with applied arguments.\n *\n * @description\n * This function performs the following steps:\n * 1. Extracts the pure Plutus bytes from the input program.\n * 2. Parses the UPLC (Untyped Plutus Core) from the pure Plutus bytes.\n * 3. Decodes the provided arguments from CBOR format.\n * 4. Iterates through the decoded arguments, applying each as a term to the program body.\n * 5. Creates a new UPLC program with the modified body.\n * 6. Encodes the new program and applies the specified output encoding.\n *\n * @note\n * - This function modifies the structure of the Plutus script by applying arguments, which can change its behavior when executed.\n * - The function assumes that the input arguments are in a compatible format (CBOR-encoded) and that the program is a valid Plutus script.\n */\nconst applyArgsToPlutusScript = (\n  args: Uint8Array[],\n  program: Uint8Array,\n  outputEncoding: OutputEncoding,\n): Uint8Array => {\n  const purePlutusBytes = getPurePlutusBytes(program);\n  const parsedProgram = parseUPLC(purePlutusBytes, \"flat\");\n  const decodedArgs = args.map((arg) => dataFromCbor(arg));\n  let body = parsedProgram.body;\n\n  for (const plutusData of decodedArgs) {\n    const argTerm = UPLCConst.data(plutusData);\n    body = new Application(body, argTerm);\n  }\n\n  const encodedProgram = new UPLCProgram(parsedProgram.version, body);\n  const newPlutusScriptBytes = encodeUPLC(encodedProgram).toBuffer().buffer;\n  return applyEncoding(newPlutusScriptBytes, outputEncoding);\n};",
          "source": "mesh-core-cst",
          "implementation": "const applyArgsToPlutusScript = (\n  args: Uint8Array[],\n  program: Uint8Array,\n  outputEncoding: OutputEncoding,\n): Uint8Array => {\n  const purePlutusBytes = getPurePlutusBytes(program);\n  const parsedProgram = parseUPLC(purePlutusBytes, \"flat\");\n  const decodedArgs = args.map((arg) => dataFromCbor(arg));\n  let body = parsedProgram.body;\n\n  for (const plutusData of decodedArgs) {\n    const argTerm = UPLCConst.data(plutusData);\n    body = new Application(body, argTerm);\n  }\n\n  const encodedProgram = new UPLCProgram(parsedProgram.version, body);\n  const newPlutusScriptBytes = encodeUPLC(encodedProgram).toBuffer().buffer;\n  return applyEncoding(newPlutusScriptBytes, outputEncoding);\n};"
        },
        {
          "name": "normalizePlutusScript",
          "signature": "export const normalizePlutusScript = (",
          "documentation": "/**\n * Normalizes a Plutus script by extracting its pure Plutus bytes and applying a specified encoding.\n *\n * @param {Uint8Array} plutusScript - The Plutus script to be normalized as a Uint8Array.\n * @param {OutputEncoding} encoding - The desired encoding for the output.\n * @returns {Uint8Array} The normalized Plutus script.\n *\n * @description\n * This function performs the following steps:\n * 1. Extracts the pure Plutus bytes in hex from the input script.\n * 2. Applies the specified encoding to the pure Plutus bytes.\n *\n * @note\n * - This function is useful for standardizing the format of Plutus scripts, ensuring they are in a consistent state for further processing or comparison.\n * - The normalization process does not modify the logical content of the script, only its representation.\n */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 121,
          "raw": "/**\n * Normalizes a Plutus script by extracting its pure Plutus bytes and applying a specified encoding.\n *\n * @param {Uint8Array} plutusScript - The Plutus script to be normalized as a Uint8Array.\n * @param {OutputEncoding} encoding - The desired encoding for the output.\n * @returns {Uint8Array} The normalized Plutus script.\n *\n * @description\n * This function performs the following steps:\n * 1. Extracts the pure Plutus bytes in hex from the input script.\n * 2. Applies the specified encoding to the pure Plutus bytes.\n *\n * @note\n * - This function is useful for standardizing the format of Plutus scripts, ensuring they are in a consistent state for further processing or comparison.\n * - The normalization process does not modify the logical content of the script, only its representation.\n */\nexport const normalizePlutusScript = (\n  plutusScript: string,\n  encoding: OutputEncoding,\n): string => {\n  const bytes = Buffer.from(plutusScript, \"hex\");\n  const purePlutusBytes = getPurePlutusBytes(bytes);\n  const normalizedBytes = applyEncoding(purePlutusBytes, encoding);\n  return Buffer.from(normalizedBytes).toString(\"hex\");\n};",
          "source": "mesh-core-cst",
          "implementation": "export const normalizePlutusScript = (\n  plutusScript: string,\n  encoding: OutputEncoding,\n): string => {\n  const bytes = Buffer.from(plutusScript, \"hex\");\n  const purePlutusBytes = getPurePlutusBytes(bytes);\n  const normalizedBytes = applyEncoding(purePlutusBytes, encoding);\n  return Buffer.from(normalizedBytes).toString(\"hex\");\n};"
        },
        {
          "name": "hasSupportedPlutusVersion",
          "signature": "const hasSupportedPlutusVersion = (plutusScript: Uint8Array): boolean => {",
          "documentation": "",
          "parameters": [
            {
              "name": "plutusScript",
              "type": "Uint8Array",
              "optional": false
            }
          ],
          "returnType": "boolean",
          "isPublic": true,
          "line": 131,
          "raw": "const hasSupportedPlutusVersion = (plutusScript: Uint8Array): boolean => {\n  if (plutusScript.length < 3) {\n    return false;\n  }\n  const version = [plutusScript[0], plutusScript[1], plutusScript[2]];\n  return supportedPlutusCoreVersions.some((supportedVersion) => {\n    return (\n      supportedVersion.version[0] === version[0] &&\n      supportedVersion.version[1] === version[1] &&\n      supportedVersion.version[2] === version[2]\n    );\n  });\n};",
          "source": "mesh-core-cst",
          "implementation": "const hasSupportedPlutusVersion = (plutusScript: Uint8Array): boolean => {\n  if (plutusScript.length < 3) {\n    return false;\n  }\n  const version = [plutusScript[0], plutusScript[1], plutusScript[2]];\n  return supportedPlutusCoreVersions.some((supportedVersion) => {\n    return (\n      supportedVersion.version[0] === version[0] &&\n      supportedVersion.version[1] === version[1] &&\n      supportedVersion.version[2] === version[2]\n    );\n  });\n};"
        },
        {
          "name": "getPurePlutusBytes",
          "signature": "const getPurePlutusBytes = (plutusScript: Uint8Array): Uint8Array => {",
          "documentation": "",
          "parameters": [
            {
              "name": "plutusScript",
              "type": "Uint8Array",
              "optional": false
            }
          ],
          "returnType": "Uint8Array",
          "isPublic": true,
          "line": 145,
          "raw": "const getPurePlutusBytes = (plutusScript: Uint8Array): Uint8Array => {\n  let unwrappedScript = plutusScript;\n  let length = 0;\n  try {\n    while (unwrappedScript.length >= 3 && length != unwrappedScript.length) {\n      length = unwrappedScript.length;\n      if (hasSupportedPlutusVersion(unwrappedScript)) {\n        return unwrappedScript;\n      }\n      const cbor = Cbor.parse(unwrappedScript);\n      if (cbor instanceof CborBytes) {\n        unwrappedScript = cbor.bytes;\n      } else {\n        break;\n      }\n    }\n  } catch (error) {\n    console.error(\"Error parsing Plutus script:\", error);\n  }\n  if (hasSupportedPlutusVersion(unwrappedScript)) {\n    return unwrappedScript;\n  }\n  throw new Error(\"Unsupported Plutus version or invalid Plutus script bytes\");\n};",
          "source": "mesh-core-cst",
          "implementation": "const getPurePlutusBytes = (plutusScript: Uint8Array): Uint8Array => {\n  let unwrappedScript = plutusScript;\n  let length = 0;\n  try {\n    while (unwrappedScript.length >= 3 && length != unwrappedScript.length) {\n      length = unwrappedScript.length;\n      if (hasSupportedPlutusVersion(unwrappedScript)) {\n        return unwrappedScript;\n      }\n      const cbor = Cbor.parse(unwrappedScript);\n      if (cbor instanceof CborBytes) {\n        unwrappedScript = cbor.bytes;\n      } else {\n        break;\n      }\n    }\n  } catch (error) {\n    console.error(\"Error parsing Plutus script:\", error);\n  }\n  if (hasSupportedPlutusVersion(unwrappedScript)) {\n    return unwrappedScript;\n  }\n  throw new Error(\"Unsupported Plutus version or invalid Plutus script bytes\");\n};"
        },
        {
          "name": "applyCborEncoding",
          "signature": "const applyCborEncoding = (plutusScript: Uint8Array): Uint8Array => {",
          "documentation": "",
          "parameters": [
            {
              "name": "plutusScript",
              "type": "Uint8Array",
              "optional": false
            }
          ],
          "returnType": "Uint8Array",
          "isPublic": true,
          "line": 170,
          "raw": "const applyCborEncoding = (plutusScript: Uint8Array): Uint8Array => {\n  return Cbor.encode(new CborBytes(plutusScript)).toBuffer();\n};",
          "source": "mesh-core-cst",
          "implementation": "const applyCborEncoding = (plutusScript: Uint8Array): Uint8Array => {\n  return Cbor.encode(new CborBytes(plutusScript)).toBuffer();\n};"
        },
        {
          "name": "applyEncoding",
          "signature": "export const applyEncoding = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 174,
          "raw": "export const applyEncoding = (\n  plutusScript: Uint8Array,\n  outputEncoding: OutputEncoding,\n): Uint8Array => {\n  switch (outputEncoding) {\n    case \"SingleCBOR\":\n      return applyCborEncoding(plutusScript);\n    case \"DoubleCBOR\":\n      return applyCborEncoding(applyCborEncoding(plutusScript));\n    case \"PurePlutusScriptBytes\":\n      return plutusScript;\n    default:\n      return applyCborEncoding(plutusScript);\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const applyEncoding = (\n  plutusScript: Uint8Array,\n  outputEncoding: OutputEncoding,\n): Uint8Array => {\n  switch (outputEncoding) {\n    case \"SingleCBOR\":\n      return applyCborEncoding(plutusScript);\n    case \"DoubleCBOR\":\n      return applyCborEncoding(applyCborEncoding(plutusScript));\n    case \"PurePlutusScriptBytes\":\n      return plutusScript;\n    default:\n      return applyCborEncoding(plutusScript);\n  }\n};"
        },
        {
          "name": "applyParamsToScript",
          "signature": "export const applyParamsToScript = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 190,
          "raw": "export const applyParamsToScript = (\n  rawScript: string,\n  params: object[] | Data[],\n  type: PlutusDataType = \"Mesh\",\n): string => {\n  let plutusParams: PlutusData[] = [];\n  switch (type) {\n    case \"JSON\":\n      params.forEach((param) => {\n        plutusParams.push(\n          fromBuilderToPlutusData({\n            type: \"JSON\",\n            content: param as string,\n          }),\n        );\n      });\n      break;\n    case \"CBOR\":\n      params.forEach((param) => {\n        plutusParams.push(\n          fromBuilderToPlutusData({\n            type: \"CBOR\",\n            content: param as string,\n          }),\n        );\n      });\n      break;\n    case \"Mesh\":\n      params.forEach((param) => {\n        plutusParams.push(\n          fromBuilderToPlutusData({\n            type: \"Mesh\",\n            content: param as Data,\n          }),\n        );\n      });\n      break;\n  }\n\n  const byteParams = plutusParams.map((param) => {\n    return Buffer.from(param.toCbor(), \"hex\");\n  });\n\n  const scriptHex = Buffer.from(\n    applyArgsToPlutusScript(\n      byteParams,\n      Buffer.from(rawScript, \"hex\"),\n      \"DoubleCBOR\",\n    ),\n  ).toString(\"hex\");\n\n  return scriptHex;\n};",
          "source": "mesh-core-cst",
          "implementation": "export const applyParamsToScript = (\n  rawScript: string,\n  params: object[] | Data[],\n  type: PlutusDataType = \"Mesh\",\n): string => {\n  let plutusParams: PlutusData[] = [];\n  switch (type) {\n    case \"JSON\":\n      params.forEach((param) => {\n        plutusParams.push(\n          fromBuilderToPlutusData({\n            type: \"JSON\",\n            content: param as string,\n          }),\n        );\n      });\n      break;\n    case \"CBOR\":\n      params.forEach((param) => {\n        plutusParams.push(\n          fromBuilderToPlutusData({\n            type: \"CBOR\",\n            content: param as string,\n          }),\n        );\n      });\n      break;\n    case \"Mesh\":\n      params.forEach((param) => {\n        plutusParams.push(\n          fromBuilderToPlutusData({\n            type: \"Mesh\",\n            content: param as Data,\n          }),\n        );\n      });\n      break;\n  }\n\n  const byteParams = plutusParams.map((param) => {\n    return Buffer.from(param.toCbor(), \"hex\");\n  });\n\n  const scriptHex = Buffer.from(\n    applyArgsToPlutusScript(\n      byteParams,\n      Buffer.from(rawScript, \"hex\"),\n      \"DoubleCBOR\",\n    ),\n  ).toString(\"hex\");\n\n  return scriptHex;\n};"
        }
      ],
      "types": [
        {
          "name": "OutputEncoding",
          "definition": "export type OutputEncoding =\n  | \"SingleCBOR\"\n  | \"DoubleCBOR\"\n  | \"PurePlutusScriptBytes\";",
          "isPublic": true,
          "line": 59,
          "raw": "export type OutputEncoding =",
          "source": "mesh-core-cst"
        }
      ],
      "constants": [
        {
          "name": "supportedPlutusCoreVersions",
          "type": "any",
          "value": "[",
          "isPublic": true,
          "line": 48,
          "raw": "const supportedPlutusCoreVersions = [",
          "source": "mesh-core-cst"
        },
        {
          "name": "applyArgsToPlutusScript",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 85,
          "raw": "const applyArgsToPlutusScript = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "purePlutusBytes",
          "type": "any",
          "value": "getPurePlutusBytes(program);",
          "isPublic": true,
          "line": 90,
          "raw": "const purePlutusBytes = getPurePlutusBytes(program);",
          "source": "mesh-core-cst"
        },
        {
          "name": "parsedProgram",
          "type": "any",
          "value": "parseUPLC(purePlutusBytes, \"flat\");",
          "isPublic": true,
          "line": 91,
          "raw": "const parsedProgram = parseUPLC(purePlutusBytes, \"flat\");",
          "source": "mesh-core-cst"
        },
        {
          "name": "decodedArgs",
          "type": "any",
          "value": "args.map((arg) => dataFromCbor(arg));",
          "isPublic": true,
          "line": 92,
          "raw": "const decodedArgs = args.map((arg) => dataFromCbor(arg));",
          "source": "mesh-core-cst"
        },
        {
          "name": "argTerm",
          "type": "any",
          "value": "UPLCConst.data(plutusData);",
          "isPublic": true,
          "line": 96,
          "raw": "const argTerm = UPLCConst.data(plutusData);",
          "source": "mesh-core-cst"
        },
        {
          "name": "encodedProgram",
          "type": "any",
          "value": "new UPLCProgram(parsedProgram.version, body);",
          "isPublic": true,
          "line": 100,
          "raw": "const encodedProgram = new UPLCProgram(parsedProgram.version, body);",
          "source": "mesh-core-cst"
        },
        {
          "name": "newPlutusScriptBytes",
          "type": "any",
          "value": "encodeUPLC(encodedProgram).toBuffer().buffer;",
          "isPublic": true,
          "line": 101,
          "raw": "const newPlutusScriptBytes = encodeUPLC(encodedProgram).toBuffer().buffer;",
          "source": "mesh-core-cst"
        },
        {
          "name": "normalizePlutusScript",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 121,
          "raw": "export const normalizePlutusScript = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "bytes",
          "type": "any",
          "value": "Buffer.from(plutusScript, \"hex\");",
          "isPublic": true,
          "line": 125,
          "raw": "const bytes = Buffer.from(plutusScript, \"hex\");",
          "source": "mesh-core-cst"
        },
        {
          "name": "purePlutusBytes",
          "type": "any",
          "value": "getPurePlutusBytes(bytes);",
          "isPublic": true,
          "line": 126,
          "raw": "const purePlutusBytes = getPurePlutusBytes(bytes);",
          "source": "mesh-core-cst"
        },
        {
          "name": "normalizedBytes",
          "type": "any",
          "value": "applyEncoding(purePlutusBytes, encoding);",
          "isPublic": true,
          "line": 127,
          "raw": "const normalizedBytes = applyEncoding(purePlutusBytes, encoding);",
          "source": "mesh-core-cst"
        },
        {
          "name": "hasSupportedPlutusVersion",
          "type": "any",
          "value": "(plutusScript: Uint8Array): boolean => {",
          "isPublic": true,
          "line": 131,
          "raw": "const hasSupportedPlutusVersion = (plutusScript: Uint8Array): boolean => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "version",
          "type": "any",
          "value": "[plutusScript[0], plutusScript[1], plutusScript[2]];",
          "isPublic": true,
          "line": 135,
          "raw": "const version = [plutusScript[0], plutusScript[1], plutusScript[2]];",
          "source": "mesh-core-cst"
        },
        {
          "name": "getPurePlutusBytes",
          "type": "any",
          "value": "(plutusScript: Uint8Array): Uint8Array => {",
          "isPublic": true,
          "line": 145,
          "raw": "const getPurePlutusBytes = (plutusScript: Uint8Array): Uint8Array => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "cbor",
          "type": "any",
          "value": "Cbor.parse(unwrappedScript);",
          "isPublic": true,
          "line": 154,
          "raw": "const cbor = Cbor.parse(unwrappedScript);",
          "source": "mesh-core-cst"
        },
        {
          "name": "applyCborEncoding",
          "type": "any",
          "value": "(plutusScript: Uint8Array): Uint8Array => {",
          "isPublic": true,
          "line": 170,
          "raw": "const applyCborEncoding = (plutusScript: Uint8Array): Uint8Array => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "applyEncoding",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 174,
          "raw": "export const applyEncoding = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "applyParamsToScript",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 190,
          "raw": "export const applyParamsToScript = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "byteParams",
          "type": "any",
          "value": "plutusParams.map((param) => {",
          "isPublic": true,
          "line": 229,
          "raw": "const byteParams = plutusParams.map((param) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "scriptHex",
          "type": "any",
          "value": "Buffer.from(",
          "isPublic": true,
          "line": 233,
          "raw": "const scriptHex = Buffer.from(",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "/*\nThis file is part of meshjs.dev.\n\nThis source code is licensed under the MIT license found in the\nLICENSE file in the root directory of this source tree. See the\nApache-2.0 License for more details.\n*/\n\n/**\n * MIT License\n *\n * Copyright (c) 2024 Evgenii Lisitskii\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Cbor, CborBytes } from \"@harmoniclabs/cbor\";\nimport { dataFromCbor } from \"@harmoniclabs/plutus-data\";\nimport {\n  Application,\n  encodeUPLC,\n  parseUPLC,\n  UPLCConst,\n  UPLCProgram,\n} from \"@harmoniclabs/uplc\";\n\nimport { Data, PlutusDataType } from \"@meshsdk/common\";\n\nimport { PlutusData } from \"../types\";\nimport { fromBuilderToPlutusData } from \"../utils\";\n\nconst supportedPlutusCoreVersions = [\n  {\n    version: [1, 0, 0],\n    language: \"Plutus V1\",\n  },\n  {\n    version: [1, 1, 0],\n    language: \"Plutus V3\",\n  },\n];\n\nexport type OutputEncoding =\n  | \"SingleCBOR\"\n  | \"DoubleCBOR\"\n  | \"PurePlutusScriptBytes\";\n\n/**\n * Applies arguments to a Plutus script, effectively parameterizing the script with provided data.\n *\n * @param {Uint8Array[]} args - An array of arguments to be applied to the script, each as a Uint8Array.\n * @param {Uint8Array} program - The original Plutus script as a Uint8Array.\n * @param {OutputEncoding} outputEncoding - The desired encoding for the output.\n * @returns {Uint8Array} The modified Plutus script with applied arguments.\n *\n * @description\n * This function performs the following steps:\n * 1. Extracts the pure Plutus bytes from the input program.\n * 2. Parses the UPLC (Untyped Plutus Core) from the pure Plutus bytes.\n * 3. Decodes the provided arguments from CBOR format.\n * 4. Iterates through the decoded arguments, applying each as a term to the program body.\n * 5. Creates a new UPLC program with the modified body.\n * 6. Encodes the new program and applies the specified output encoding.\n *\n * @note\n * - This function modifies the structure of the Plutus script by applying arguments, which can change its behavior when executed.\n * - The function assumes that the input arguments are in a compatible format (CBOR-encoded) and that the program is a valid Plutus script.\n */\nconst applyArgsToPlutusScript = (\n  args: Uint8Array[],\n  program: Uint8Array,\n  outputEncoding: OutputEncoding,\n): Uint8Array => {\n  const purePlutusBytes = getPurePlutusBytes(program);\n  const parsedProgram = parseUPLC(purePlutusBytes, \"flat\");\n  const decodedArgs = args.map((arg) => dataFromCbor(arg));\n  let body = parsedProgram.body;\n\n  for (const plutusData of decodedArgs) {\n    const argTerm = UPLCConst.data(plutusData);\n    body = new Application(body, argTerm);\n  }\n\n  const encodedProgram = new UPLCProgram(parsedProgram.version, body);\n  const newPlutusScriptBytes = encodeUPLC(encodedProgram).toBuffer().buffer;\n  return applyEncoding(newPlutusScriptBytes, outputEncoding);\n};\n\n/**\n * Normalizes a Plutus script by extracting its pure Plutus bytes and applying a specified encoding.\n *\n * @param {Uint8Array} plutusScript - The Plutus script to be normalized as a Uint8Array.\n * @param {OutputEncoding} encoding - The desired encoding for the output.\n * @returns {Uint8Array} The normalized Plutus script.\n *\n * @description\n * This function performs the following steps:\n * 1. Extracts the pure Plutus bytes in hex from the input script.\n * 2. Applies the specified encoding to the pure Plutus bytes.\n *\n * @note\n * - This function is useful for standardizing the format of Plutus scripts, ensuring they are in a consistent state for further processing or comparison.\n * - The normalization process does not modify the logical content of the script, only its representation.\n */\nexport const normalizePlutusScript = (\n  plutusScript: string,\n  encoding: OutputEncoding,\n): string => {\n  const bytes = Buffer.from(plutusScript, \"hex\");\n  const purePlutusBytes = getPurePlutusBytes(bytes);\n  const normalizedBytes = applyEncoding(purePlutusBytes, encoding);\n  return Buffer.from(normalizedBytes).toString(\"hex\");\n};\n\nconst hasSupportedPlutusVersion = (plutusScript: Uint8Array): boolean => {\n  if (plutusScript.length < 3) {\n    return false;\n  }\n  const version = [plutusScript[0], plutusScript[1], plutusScript[2]];\n  return supportedPlutusCoreVersions.some((supportedVersion) => {\n    return (\n      supportedVersion.version[0] === version[0] &&\n      supportedVersion.version[1] === version[1] &&\n      supportedVersion.version[2] === version[2]\n    );\n  });\n};\n\nconst getPurePlutusBytes = (plutusScript: Uint8Array): Uint8Array => {\n  let unwrappedScript = plutusScript;\n  let length = 0;\n  try {\n    while (unwrappedScript.length >= 3 && length != unwrappedScript.length) {\n      length = unwrappedScript.length;\n      if (hasSupportedPlutusVersion(unwrappedScript)) {\n        return unwrappedScript;\n      }\n      const cbor = Cbor.parse(unwrappedScript);\n      if (cbor instanceof CborBytes) {\n        unwrappedScript = cbor.bytes;\n      } else {\n        break;\n      }\n    }\n  } catch (error) {\n    console.error(\"Error parsing Plutus script:\", error);\n  }\n  if (hasSupportedPlutusVersion(unwrappedScript)) {\n    return unwrappedScript;\n  }\n  throw new Error(\"Unsupported Plutus version or invalid Plutus script bytes\");\n};\n\nconst applyCborEncoding = (plutusScript: Uint8Array): Uint8Array => {\n  return Cbor.encode(new CborBytes(plutusScript)).toBuffer();\n};\n\nexport const applyEncoding = (\n  plutusScript: Uint8Array,\n  outputEncoding: OutputEncoding,\n): Uint8Array => {\n  switch (outputEncoding) {\n    case \"SingleCBOR\":\n      return applyCborEncoding(plutusScript);\n    case \"DoubleCBOR\":\n      return applyCborEncoding(applyCborEncoding(plutusScript));\n    case \"PurePlutusScriptBytes\":\n      return plutusScript;\n    default:\n      return applyCborEncoding(plutusScript);\n  }\n};\n\nexport const applyParamsToScript = (\n  rawScript: string,\n  params: object[] | Data[],\n  type: PlutusDataType = \"Mesh\",\n): string => {\n  let plutusParams: PlutusData[] = [];\n  switch (type) {\n    case \"JSON\":\n      params.forEach((param) => {\n        plutusParams.push(\n          fromBuilderToPlutusData({\n            type: \"JSON\",\n            content: param as string,\n          }),\n        );\n      });\n      break;\n    case \"CBOR\":\n      params.forEach((param) => {\n        plutusParams.push(\n          fromBuilderToPlutusData({\n            type: \"CBOR\",\n            content: param as string,\n          }),\n        );\n      });\n      break;\n    case \"Mesh\":\n      params.forEach((param) => {\n        plutusParams.push(\n          fromBuilderToPlutusData({\n            type: \"Mesh\",\n            content: param as Data,\n          }),\n        );\n      });\n      break;\n  }\n\n  const byteParams = plutusParams.map((param) => {\n    return Buffer.from(param.toCbor(), \"hex\");\n  });\n\n  const scriptHex = Buffer.from(\n    applyArgsToPlutusScript(\n      byteParams,\n      Buffer.from(rawScript, \"hex\"),\n      \"DoubleCBOR\",\n    ),\n  ).toString(\"hex\");\n\n  return scriptHex;\n};\n",
      "dependencies": [
        "OutputEncoding",
        "normalizePlutusScript",
        "applyEncoding",
        "applyParamsToScript"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/resolvers/index.ts",
      "name": "resolvers.index.ts",
      "imports": [
        {
          "module": "resolveDataHash",
          "items": [],
          "line": 47,
          "raw": "export const resolveDataHash = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "resolveNativeScriptAddress",
          "items": [],
          "line": 58,
          "raw": "export const resolveNativeScriptAddress = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "resolveNativeScriptHash",
          "items": [],
          "line": 72,
          "raw": "export const resolveNativeScriptHash = (script: NativeScript) => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "resolvePaymentKeyHash",
          "items": [],
          "line": 76,
          "raw": "export const resolvePaymentKeyHash = (bech32: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "resolvePlutusScriptAddress",
          "items": [],
          "line": 95,
          "raw": "export const resolvePlutusScriptAddress = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "resolvePlutusScriptHash",
          "items": [],
          "line": 109,
          "raw": "export const resolvePlutusScriptHash = (bech32: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "resolvePoolId",
          "items": [],
          "line": 122,
          "raw": "export const resolvePoolId = (hash: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "resolvePrivateKey",
          "items": [],
          "line": 126,
          "raw": "export const resolvePrivateKey = (words: string[]) => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "resolveScriptRef",
          "items": [],
          "line": 145,
          "raw": "export const resolveScriptRef = (script: PlutusScript | NativeScript) => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "resolveRewardAddress",
          "items": [],
          "line": 149,
          "raw": "export const resolveRewardAddress = (bech32: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "resolveStakeKeyHash",
          "items": [],
          "line": 167,
          "raw": "export const resolveStakeKeyHash = (bech32: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "resolveTxHash",
          "items": [],
          "line": 182,
          "raw": "export const resolveTxHash = (txHex: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "resolveScriptHashDRepId",
          "items": [],
          "line": 190,
          "raw": "export const resolveScriptHashDRepId = (scriptHash: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "resolveEd25519KeyHash",
          "items": [],
          "line": 197,
          "raw": "export const resolveEd25519KeyHash = (bech32: string) => {",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "resolveDataHash",
          "signature": "export const resolveDataHash = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 47,
          "raw": "export const resolveDataHash = (\n  rawData: BuilderData[\"content\"],\n  type: PlutusDataType = \"Mesh\",\n) => {\n  const plutusData = fromBuilderToPlutusData({\n    content: rawData,\n    type,\n  } as BuilderData);\n  return plutusData.hash().toString();\n};",
          "source": "mesh-core-cst",
          "implementation": "export const resolveDataHash = (\n  rawData: BuilderData[\"content\"],\n  type: PlutusDataType = \"Mesh\",\n) => {\n  const plutusData = fromBuilderToPlutusData({\n    content: rawData,\n    type,\n  } as BuilderData);\n  return plutusData.hash().toString();\n};"
        },
        {
          "name": "resolveNativeScriptAddress",
          "signature": "export const resolveNativeScriptAddress = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 58,
          "raw": "export const resolveNativeScriptAddress = (\n  script: NativeScript,\n  networkId = 0,\n) => {\n  const nativeScript = toNativeScript(script);\n\n  const enterpriseAddress = EnterpriseAddress.fromCredentials(networkId, {\n    hash: nativeScript.hash(),\n    type: Cardano.CredentialType.ScriptHash,\n  });\n\n  return enterpriseAddress.toAddress().toBech32().toString();\n};",
          "source": "mesh-core-cst",
          "implementation": "export const resolveNativeScriptAddress = (\n  script: NativeScript,\n  networkId = 0,\n) => {\n  const nativeScript = toNativeScript(script);\n\n  const enterpriseAddress = EnterpriseAddress.fromCredentials(networkId, {\n    hash: nativeScript.hash(),\n    type: Cardano.CredentialType.ScriptHash,\n  });\n\n  return enterpriseAddress.toAddress().toBech32().toString();\n};"
        },
        {
          "name": "resolveNativeScriptHash",
          "signature": "export const resolveNativeScriptHash = (script: NativeScript) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "script",
              "type": "NativeScript",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 72,
          "raw": "export const resolveNativeScriptHash = (script: NativeScript) => {\n  return toNativeScript(script).hash().toString();\n};",
          "source": "mesh-core-cst",
          "implementation": "export const resolveNativeScriptHash = (script: NativeScript) => {\n  return toNativeScript(script).hash().toString();\n};"
        },
        {
          "name": "resolvePaymentKeyHash",
          "signature": "export const resolvePaymentKeyHash = (bech32: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "bech32",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 76,
          "raw": "export const resolvePaymentKeyHash = (bech32: string) => {\n  try {\n    const paymentKeyHash = [\n      toBaseAddress(bech32)?.getPaymentCredential().hash,\n      toEnterpriseAddress(bech32)?.getPaymentCredential().hash,\n    ].find((kh) => kh !== undefined);\n\n    if (paymentKeyHash !== undefined) return paymentKeyHash.toString();\n\n    throw new Error(\n      `Couldn't resolve payment key hash from address: ${bech32}`,\n    );\n  } catch (error) {\n    throw new Error(\n      `An error occurred during resolvePaymentKeyHash: ${error}.`,\n    );\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const resolvePaymentKeyHash = (bech32: string) => {\n  try {\n    const paymentKeyHash = [\n      toBaseAddress(bech32)?.getPaymentCredential().hash,\n      toEnterpriseAddress(bech32)?.getPaymentCredential().hash,\n    ].find((kh) => kh !== undefined);\n\n    if (paymentKeyHash !== undefined) return paymentKeyHash.toString();\n\n    throw new Error(\n      `Couldn't resolve payment key hash from address: ${bech32}`,\n    );\n  } catch (error) {\n    throw new Error(\n      `An error occurred during resolvePaymentKeyHash: ${error}.`,\n    );\n  }\n};"
        },
        {
          "name": "resolvePlutusScriptAddress",
          "signature": "export const resolvePlutusScriptAddress = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 95,
          "raw": "export const resolvePlutusScriptAddress = (\n  script: PlutusScript,\n  networkId = 0,\n) => {\n  const plutusScript = deserializePlutusScript(script.code, script.version);\n\n  const enterpriseAddress = EnterpriseAddress.fromCredentials(networkId, {\n    hash: plutusScript.hash(),\n    type: Cardano.CredentialType.ScriptHash,\n  });\n\n  return enterpriseAddress.toAddress().toBech32().toString();\n};",
          "source": "mesh-core-cst",
          "implementation": "export const resolvePlutusScriptAddress = (\n  script: PlutusScript,\n  networkId = 0,\n) => {\n  const plutusScript = deserializePlutusScript(script.code, script.version);\n\n  const enterpriseAddress = EnterpriseAddress.fromCredentials(networkId, {\n    hash: plutusScript.hash(),\n    type: Cardano.CredentialType.ScriptHash,\n  });\n\n  return enterpriseAddress.toAddress().toBech32().toString();\n};"
        },
        {
          "name": "resolvePlutusScriptHash",
          "signature": "export const resolvePlutusScriptHash = (bech32: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "bech32",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 109,
          "raw": "export const resolvePlutusScriptHash = (bech32: string) => {\n  try {\n    const enterpriseAddress = toEnterpriseAddress(bech32);\n    const scriptHash = enterpriseAddress?.getPaymentCredential().hash;\n\n    if (scriptHash !== undefined) return scriptHash.toString();\n\n    throw new Error(`Couldn't resolve script hash from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveScriptHash: ${error}.`);\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const resolvePlutusScriptHash = (bech32: string) => {\n  try {\n    const enterpriseAddress = toEnterpriseAddress(bech32);\n    const scriptHash = enterpriseAddress?.getPaymentCredential().hash;\n\n    if (scriptHash !== undefined) return scriptHash.toString();\n\n    throw new Error(`Couldn't resolve script hash from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveScriptHash: ${error}.`);\n  }\n};"
        },
        {
          "name": "resolvePoolId",
          "signature": "export const resolvePoolId = (hash: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "hash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 122,
          "raw": "export const resolvePoolId = (hash: string) => {\n  return PoolId.fromKeyHash(Ed25519KeyHashHex(hash)).toString();\n};",
          "source": "mesh-core-cst",
          "implementation": "export const resolvePoolId = (hash: string) => {\n  return PoolId.fromKeyHash(Ed25519KeyHashHex(hash)).toString();\n};"
        },
        {
          "name": "resolvePrivateKey",
          "signature": "export const resolvePrivateKey = (words: string[]) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "words",
              "type": "string[]",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 126,
          "raw": "export const resolvePrivateKey = (words: string[]) => {\n  const buildBip32PrivateKey = (\n    entropy: string,\n    password = \"\",\n  ): Bip32PrivateKey => {\n    return Bip32PrivateKey.fromBip39Entropy(\n      Buffer.from(toBytes(entropy)),\n      fromUTF8(password),\n    );\n  };\n\n  const entropy = mnemonicToEntropy(words.join(\" \"));\n  const bip32PrivateKey = buildBip32PrivateKey(entropy);\n  const bytes = base32.encode(bip32PrivateKey.bytes());\n  const bech32PrivateKey = bech32.encode(\"xprv\", bytes, 1023);\n\n  return bech32PrivateKey;\n};",
          "source": "mesh-core-cst",
          "implementation": "export const resolvePrivateKey = (words: string[]) => {\n  const buildBip32PrivateKey = (\n    entropy: string,\n    password = \"\",\n  ): Bip32PrivateKey => {\n    return Bip32PrivateKey.fromBip39Entropy(\n      Buffer.from(toBytes(entropy)),\n      fromUTF8(password),\n    );\n  };\n\n  const entropy = mnemonicToEntropy(words.join(\" \"));\n  const bip32PrivateKey = buildBip32PrivateKey(entropy);\n  const bytes = base32.encode(bip32PrivateKey.bytes());\n  const bech32PrivateKey = bech32.encode(\"xprv\", bytes, 1023);\n\n  return bech32PrivateKey;\n};"
        },
        {
          "name": "buildBip32PrivateKey",
          "signature": "const buildBip32PrivateKey = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 127,
          "raw": "  const buildBip32PrivateKey = (\n    entropy: string,\n    password = \"\",\n  ): Bip32PrivateKey => {\n    return Bip32PrivateKey.fromBip39Entropy(\n      Buffer.from(toBytes(entropy)),\n      fromUTF8(password),\n    );\n  };",
          "source": "mesh-core-cst",
          "implementation": "  const buildBip32PrivateKey = (\n    entropy: string,\n    password = \"\",\n  ): Bip32PrivateKey => {\n    return Bip32PrivateKey.fromBip39Entropy(\n      Buffer.from(toBytes(entropy)),\n      fromUTF8(password),\n    );\n  };"
        },
        {
          "name": "resolveScriptRef",
          "signature": "export const resolveScriptRef = (script: PlutusScript | NativeScript) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "script",
              "type": "PlutusScript | NativeScript",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 145,
          "raw": "export const resolveScriptRef = (script: PlutusScript | NativeScript) => {\n  return toScriptRef(script).toCbor().toString();\n};",
          "source": "mesh-core-cst",
          "implementation": "export const resolveScriptRef = (script: PlutusScript | NativeScript) => {\n  return toScriptRef(script).toCbor().toString();\n};"
        },
        {
          "name": "resolveRewardAddress",
          "signature": "export const resolveRewardAddress = (bech32: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "bech32",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 149,
          "raw": "export const resolveRewardAddress = (bech32: string) => {\n  try {\n    const address = toAddress(bech32);\n    const baseAddress = toBaseAddress(bech32);\n    const stakeKeyHash = baseAddress?.getStakeCredential().hash;\n\n    if (stakeKeyHash !== undefined)\n      return buildRewardAddress(address.getNetworkId(), stakeKeyHash)\n        .toAddress()\n        .toBech32()\n        .toString();\n\n    throw new Error(`Couldn't resolve reward address from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveRewardAddress: ${error}.`);\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const resolveRewardAddress = (bech32: string) => {\n  try {\n    const address = toAddress(bech32);\n    const baseAddress = toBaseAddress(bech32);\n    const stakeKeyHash = baseAddress?.getStakeCredential().hash;\n\n    if (stakeKeyHash !== undefined)\n      return buildRewardAddress(address.getNetworkId(), stakeKeyHash)\n        .toAddress()\n        .toBech32()\n        .toString();\n\n    throw new Error(`Couldn't resolve reward address from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveRewardAddress: ${error}.`);\n  }\n};"
        },
        {
          "name": "resolveStakeKeyHash",
          "signature": "export const resolveStakeKeyHash = (bech32: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "bech32",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 167,
          "raw": "export const resolveStakeKeyHash = (bech32: string) => {\n  try {\n    const stakeKeyHash = [\n      toBaseAddress(bech32)?.getStakeCredential().hash,\n      toRewardAddress(bech32)?.getPaymentCredential().hash,\n    ].find((kh) => kh !== undefined);\n\n    if (stakeKeyHash !== undefined) return stakeKeyHash.toString();\n\n    throw new Error(`Couldn't resolve stake key hash from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveStakeKeyHash: ${error}.`);\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const resolveStakeKeyHash = (bech32: string) => {\n  try {\n    const stakeKeyHash = [\n      toBaseAddress(bech32)?.getStakeCredential().hash,\n      toRewardAddress(bech32)?.getPaymentCredential().hash,\n    ].find((kh) => kh !== undefined);\n\n    if (stakeKeyHash !== undefined) return stakeKeyHash.toString();\n\n    throw new Error(`Couldn't resolve stake key hash from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveStakeKeyHash: ${error}.`);\n  }\n};"
        },
        {
          "name": "resolveTxHash",
          "signature": "export const resolveTxHash = (txHex: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "txHex",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 182,
          "raw": "export const resolveTxHash = (txHex: string) => {\n  const txBody = deserializeTx(txHex).body();\n  const hash = blake2b(blake2b.BYTES)\n    .update(hexToBytes(txBody.toCbor()))\n    .digest();\n  return Cardano.TransactionId.fromHexBlob(HexBlob.fromBytes(hash)).toString();\n};",
          "source": "mesh-core-cst",
          "implementation": "export const resolveTxHash = (txHex: string) => {\n  const txBody = deserializeTx(txHex).body();\n  const hash = blake2b(blake2b.BYTES)\n    .update(hexToBytes(txBody.toCbor()))\n    .digest();\n  return Cardano.TransactionId.fromHexBlob(HexBlob.fromBytes(hash)).toString();\n};"
        },
        {
          "name": "resolveScriptHashDRepId",
          "signature": "export const resolveScriptHashDRepId = (scriptHash: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "scriptHash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 190,
          "raw": "export const resolveScriptHashDRepId = (scriptHash: string) => {\n  return DRepID.cip129FromCredential({\n    type: Cardano.CredentialType.ScriptHash,\n    hash: Hash28ByteBase16(scriptHash),\n  }).toString();\n};",
          "source": "mesh-core-cst",
          "implementation": "export const resolveScriptHashDRepId = (scriptHash: string) => {\n  return DRepID.cip129FromCredential({\n    type: Cardano.CredentialType.ScriptHash,\n    hash: Hash28ByteBase16(scriptHash),\n  }).toString();\n};"
        },
        {
          "name": "resolveEd25519KeyHash",
          "signature": "export const resolveEd25519KeyHash = (bech32: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "bech32",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 197,
          "raw": "export const resolveEd25519KeyHash = (bech32: string) => {\n  try {\n    const keyHash = [\n      toBaseAddress(bech32)?.getPaymentCredential().hash,\n      toEnterpriseAddress(bech32)?.getPaymentCredential().hash,\n    ].find((kh) => kh !== undefined);\n\n    if (keyHash !== undefined) return keyHash.toString();\n\n    throw new Error(`Couldn't resolve key hash from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(\n      `An error occurred during resolveEd25519KeyHash: ${error}.`,\n    );\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const resolveEd25519KeyHash = (bech32: string) => {\n  try {\n    const keyHash = [\n      toBaseAddress(bech32)?.getPaymentCredential().hash,\n      toEnterpriseAddress(bech32)?.getPaymentCredential().hash,\n    ].find((kh) => kh !== undefined);\n\n    if (keyHash !== undefined) return keyHash.toString();\n\n    throw new Error(`Couldn't resolve key hash from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(\n      `An error occurred during resolveEd25519KeyHash: ${error}.`,\n    );\n  }\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "resolveDataHash",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 47,
          "raw": "export const resolveDataHash = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusData",
          "type": "any",
          "value": "fromBuilderToPlutusData({",
          "isPublic": true,
          "line": 51,
          "raw": "const plutusData = fromBuilderToPlutusData({",
          "source": "mesh-core-cst"
        },
        {
          "name": "resolveNativeScriptAddress",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 58,
          "raw": "export const resolveNativeScriptAddress = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "nativeScript",
          "type": "any",
          "value": "toNativeScript(script);",
          "isPublic": true,
          "line": 62,
          "raw": "const nativeScript = toNativeScript(script);",
          "source": "mesh-core-cst"
        },
        {
          "name": "enterpriseAddress",
          "type": "any",
          "value": "EnterpriseAddress.fromCredentials(networkId, {",
          "isPublic": true,
          "line": 64,
          "raw": "const enterpriseAddress = EnterpriseAddress.fromCredentials(networkId, {",
          "source": "mesh-core-cst"
        },
        {
          "name": "resolveNativeScriptHash",
          "type": "any",
          "value": "(script: NativeScript) => {",
          "isPublic": true,
          "line": 72,
          "raw": "export const resolveNativeScriptHash = (script: NativeScript) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "resolvePaymentKeyHash",
          "type": "any",
          "value": "(bech32: string) => {",
          "isPublic": true,
          "line": 76,
          "raw": "export const resolvePaymentKeyHash = (bech32: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "paymentKeyHash",
          "type": "any",
          "value": "[",
          "isPublic": true,
          "line": 78,
          "raw": "const paymentKeyHash = [",
          "source": "mesh-core-cst"
        },
        {
          "name": "resolvePlutusScriptAddress",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 95,
          "raw": "export const resolvePlutusScriptAddress = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusScript",
          "type": "any",
          "value": "deserializePlutusScript(script.code, script.version);",
          "isPublic": true,
          "line": 99,
          "raw": "const plutusScript = deserializePlutusScript(script.code, script.version);",
          "source": "mesh-core-cst"
        },
        {
          "name": "enterpriseAddress",
          "type": "any",
          "value": "EnterpriseAddress.fromCredentials(networkId, {",
          "isPublic": true,
          "line": 101,
          "raw": "const enterpriseAddress = EnterpriseAddress.fromCredentials(networkId, {",
          "source": "mesh-core-cst"
        },
        {
          "name": "resolvePlutusScriptHash",
          "type": "any",
          "value": "(bech32: string) => {",
          "isPublic": true,
          "line": 109,
          "raw": "export const resolvePlutusScriptHash = (bech32: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "enterpriseAddress",
          "type": "any",
          "value": "toEnterpriseAddress(bech32);",
          "isPublic": true,
          "line": 111,
          "raw": "const enterpriseAddress = toEnterpriseAddress(bech32);",
          "source": "mesh-core-cst"
        },
        {
          "name": "scriptHash",
          "type": "any",
          "value": "enterpriseAddress?.getPaymentCredential().hash;",
          "isPublic": true,
          "line": 112,
          "raw": "const scriptHash = enterpriseAddress?.getPaymentCredential().hash;",
          "source": "mesh-core-cst"
        },
        {
          "name": "resolvePoolId",
          "type": "any",
          "value": "(hash: string) => {",
          "isPublic": true,
          "line": 122,
          "raw": "export const resolvePoolId = (hash: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "resolvePrivateKey",
          "type": "any",
          "value": "(words: string[]) => {",
          "isPublic": true,
          "line": 126,
          "raw": "export const resolvePrivateKey = (words: string[]) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "buildBip32PrivateKey",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 127,
          "raw": "const buildBip32PrivateKey = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "entropy",
          "type": "any",
          "value": "mnemonicToEntropy(words.join(\" \"));",
          "isPublic": true,
          "line": 137,
          "raw": "const entropy = mnemonicToEntropy(words.join(\" \"));",
          "source": "mesh-core-cst"
        },
        {
          "name": "bip32PrivateKey",
          "type": "any",
          "value": "buildBip32PrivateKey(entropy);",
          "isPublic": true,
          "line": 138,
          "raw": "const bip32PrivateKey = buildBip32PrivateKey(entropy);",
          "source": "mesh-core-cst"
        },
        {
          "name": "bytes",
          "type": "any",
          "value": "base32.encode(bip32PrivateKey.bytes());",
          "isPublic": true,
          "line": 139,
          "raw": "const bytes = base32.encode(bip32PrivateKey.bytes());",
          "source": "mesh-core-cst"
        },
        {
          "name": "bech32PrivateKey",
          "type": "any",
          "value": "bech32.encode(\"xprv\", bytes, 1023);",
          "isPublic": true,
          "line": 140,
          "raw": "const bech32PrivateKey = bech32.encode(\"xprv\", bytes, 1023);",
          "source": "mesh-core-cst"
        },
        {
          "name": "resolveScriptRef",
          "type": "any",
          "value": "(script: PlutusScript | NativeScript) => {",
          "isPublic": true,
          "line": 145,
          "raw": "export const resolveScriptRef = (script: PlutusScript | NativeScript) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "resolveRewardAddress",
          "type": "any",
          "value": "(bech32: string) => {",
          "isPublic": true,
          "line": 149,
          "raw": "export const resolveRewardAddress = (bech32: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "address",
          "type": "any",
          "value": "toAddress(bech32);",
          "isPublic": true,
          "line": 151,
          "raw": "const address = toAddress(bech32);",
          "source": "mesh-core-cst"
        },
        {
          "name": "baseAddress",
          "type": "any",
          "value": "toBaseAddress(bech32);",
          "isPublic": true,
          "line": 152,
          "raw": "const baseAddress = toBaseAddress(bech32);",
          "source": "mesh-core-cst"
        },
        {
          "name": "stakeKeyHash",
          "type": "any",
          "value": "baseAddress?.getStakeCredential().hash;",
          "isPublic": true,
          "line": 153,
          "raw": "const stakeKeyHash = baseAddress?.getStakeCredential().hash;",
          "source": "mesh-core-cst"
        },
        {
          "name": "resolveStakeKeyHash",
          "type": "any",
          "value": "(bech32: string) => {",
          "isPublic": true,
          "line": 167,
          "raw": "export const resolveStakeKeyHash = (bech32: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "stakeKeyHash",
          "type": "any",
          "value": "[",
          "isPublic": true,
          "line": 169,
          "raw": "const stakeKeyHash = [",
          "source": "mesh-core-cst"
        },
        {
          "name": "resolveTxHash",
          "type": "any",
          "value": "(txHex: string) => {",
          "isPublic": true,
          "line": 182,
          "raw": "export const resolveTxHash = (txHex: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "txBody",
          "type": "any",
          "value": "deserializeTx(txHex).body();",
          "isPublic": true,
          "line": 183,
          "raw": "const txBody = deserializeTx(txHex).body();",
          "source": "mesh-core-cst"
        },
        {
          "name": "hash",
          "type": "any",
          "value": "blake2b(blake2b.BYTES)",
          "isPublic": true,
          "line": 184,
          "raw": "const hash = blake2b(blake2b.BYTES)",
          "source": "mesh-core-cst"
        },
        {
          "name": "resolveScriptHashDRepId",
          "type": "any",
          "value": "(scriptHash: string) => {",
          "isPublic": true,
          "line": 190,
          "raw": "export const resolveScriptHashDRepId = (scriptHash: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "resolveEd25519KeyHash",
          "type": "any",
          "value": "(bech32: string) => {",
          "isPublic": true,
          "line": 197,
          "raw": "export const resolveEd25519KeyHash = (bech32: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "keyHash",
          "type": "any",
          "value": "[",
          "isPublic": true,
          "line": 199,
          "raw": "const keyHash = [",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "/*\nThis file is part of meshjs.dev.\n\nThis source code is licensed under the MIT license found in the\nLICENSE file in the root directory of this source tree. See the\nApache-2.0 License for more details.\n*/\n\nimport { Cardano } from \"@cardano-sdk/core\";\nimport { blake2b } from \"@cardano-sdk/crypto\";\nimport { HexBlob } from \"@cardano-sdk/util\";\nimport base32 from \"base32-encoding\";\nimport { bech32 } from \"bech32\";\n\nimport {\n  BuilderData,\n  fromUTF8,\n  mnemonicToEntropy,\n  NativeScript,\n  PlutusDataType,\n  PlutusScript,\n  toBytes,\n} from \"@meshsdk/common\";\n\nimport {\n  Bip32PrivateKey,\n  DRepID,\n  Ed25519KeyHashHex,\n  EnterpriseAddress,\n  Hash28ByteBase16,\n  PoolId,\n} from \"../types\";\nimport {\n  deserializePlutusScript,\n  deserializeTx,\n  fromBuilderToPlutusData,\n  toAddress,\n  toBaseAddress,\n  toEnterpriseAddress,\n  toNativeScript,\n  toRewardAddress,\n  toScriptRef,\n} from \"../utils\";\nimport { buildRewardAddress } from \"../utils/builder\";\nimport { hexToBytes } from \"../utils/encoding\";\n\nexport const resolveDataHash = (\n  rawData: BuilderData[\"content\"],\n  type: PlutusDataType = \"Mesh\",\n) => {\n  const plutusData = fromBuilderToPlutusData({\n    content: rawData,\n    type,\n  } as BuilderData);\n  return plutusData.hash().toString();\n};\n\nexport const resolveNativeScriptAddress = (\n  script: NativeScript,\n  networkId = 0,\n) => {\n  const nativeScript = toNativeScript(script);\n\n  const enterpriseAddress = EnterpriseAddress.fromCredentials(networkId, {\n    hash: nativeScript.hash(),\n    type: Cardano.CredentialType.ScriptHash,\n  });\n\n  return enterpriseAddress.toAddress().toBech32().toString();\n};\n\nexport const resolveNativeScriptHash = (script: NativeScript) => {\n  return toNativeScript(script).hash().toString();\n};\n\nexport const resolvePaymentKeyHash = (bech32: string) => {\n  try {\n    const paymentKeyHash = [\n      toBaseAddress(bech32)?.getPaymentCredential().hash,\n      toEnterpriseAddress(bech32)?.getPaymentCredential().hash,\n    ].find((kh) => kh !== undefined);\n\n    if (paymentKeyHash !== undefined) return paymentKeyHash.toString();\n\n    throw new Error(\n      `Couldn't resolve payment key hash from address: ${bech32}`,\n    );\n  } catch (error) {\n    throw new Error(\n      `An error occurred during resolvePaymentKeyHash: ${error}.`,\n    );\n  }\n};\n\nexport const resolvePlutusScriptAddress = (\n  script: PlutusScript,\n  networkId = 0,\n) => {\n  const plutusScript = deserializePlutusScript(script.code, script.version);\n\n  const enterpriseAddress = EnterpriseAddress.fromCredentials(networkId, {\n    hash: plutusScript.hash(),\n    type: Cardano.CredentialType.ScriptHash,\n  });\n\n  return enterpriseAddress.toAddress().toBech32().toString();\n};\n\nexport const resolvePlutusScriptHash = (bech32: string) => {\n  try {\n    const enterpriseAddress = toEnterpriseAddress(bech32);\n    const scriptHash = enterpriseAddress?.getPaymentCredential().hash;\n\n    if (scriptHash !== undefined) return scriptHash.toString();\n\n    throw new Error(`Couldn't resolve script hash from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveScriptHash: ${error}.`);\n  }\n};\n\nexport const resolvePoolId = (hash: string) => {\n  return PoolId.fromKeyHash(Ed25519KeyHashHex(hash)).toString();\n};\n\nexport const resolvePrivateKey = (words: string[]) => {\n  const buildBip32PrivateKey = (\n    entropy: string,\n    password = \"\",\n  ): Bip32PrivateKey => {\n    return Bip32PrivateKey.fromBip39Entropy(\n      Buffer.from(toBytes(entropy)),\n      fromUTF8(password),\n    );\n  };\n\n  const entropy = mnemonicToEntropy(words.join(\" \"));\n  const bip32PrivateKey = buildBip32PrivateKey(entropy);\n  const bytes = base32.encode(bip32PrivateKey.bytes());\n  const bech32PrivateKey = bech32.encode(\"xprv\", bytes, 1023);\n\n  return bech32PrivateKey;\n};\n\nexport const resolveScriptRef = (script: PlutusScript | NativeScript) => {\n  return toScriptRef(script).toCbor().toString();\n};\n\nexport const resolveRewardAddress = (bech32: string) => {\n  try {\n    const address = toAddress(bech32);\n    const baseAddress = toBaseAddress(bech32);\n    const stakeKeyHash = baseAddress?.getStakeCredential().hash;\n\n    if (stakeKeyHash !== undefined)\n      return buildRewardAddress(address.getNetworkId(), stakeKeyHash)\n        .toAddress()\n        .toBech32()\n        .toString();\n\n    throw new Error(`Couldn't resolve reward address from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveRewardAddress: ${error}.`);\n  }\n};\n\nexport const resolveStakeKeyHash = (bech32: string) => {\n  try {\n    const stakeKeyHash = [\n      toBaseAddress(bech32)?.getStakeCredential().hash,\n      toRewardAddress(bech32)?.getPaymentCredential().hash,\n    ].find((kh) => kh !== undefined);\n\n    if (stakeKeyHash !== undefined) return stakeKeyHash.toString();\n\n    throw new Error(`Couldn't resolve stake key hash from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveStakeKeyHash: ${error}.`);\n  }\n};\n\nexport const resolveTxHash = (txHex: string) => {\n  const txBody = deserializeTx(txHex).body();\n  const hash = blake2b(blake2b.BYTES)\n    .update(hexToBytes(txBody.toCbor()))\n    .digest();\n  return Cardano.TransactionId.fromHexBlob(HexBlob.fromBytes(hash)).toString();\n};\n\nexport const resolveScriptHashDRepId = (scriptHash: string) => {\n  return DRepID.cip129FromCredential({\n    type: Cardano.CredentialType.ScriptHash,\n    hash: Hash28ByteBase16(scriptHash),\n  }).toString();\n};\n\nexport const resolveEd25519KeyHash = (bech32: string) => {\n  try {\n    const keyHash = [\n      toBaseAddress(bech32)?.getPaymentCredential().hash,\n      toEnterpriseAddress(bech32)?.getPaymentCredential().hash,\n    ].find((kh) => kh !== undefined);\n\n    if (keyHash !== undefined) return keyHash.toString();\n\n    throw new Error(`Couldn't resolve key hash from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(\n      `An error occurred during resolveEd25519KeyHash: ${error}.`,\n    );\n  }\n};\n",
      "dependencies": [
        "resolveDataHash",
        "resolveNativeScriptAddress",
        "resolveNativeScriptHash",
        "resolvePaymentKeyHash",
        "resolvePlutusScriptAddress",
        "resolvePlutusScriptHash",
        "resolvePoolId",
        "resolvePrivateKey",
        "resolveScriptRef",
        "resolveRewardAddress",
        "resolveStakeKeyHash",
        "resolveTxHash",
        "resolveScriptHashDRepId",
        "resolveEd25519KeyHash"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:serializer.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/serializer/index.ts",
      "name": "serializer.index.ts",
      "imports": [
        {
          "module": "CardanoSDKSerializer",
          "items": [],
          "line": 136,
          "raw": "export class CardanoSDKSerializer implements IMeshTxSerializer {",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "serializePoolId",
          "signature": "serializePoolId(hash: string): string {",
          "documentation": "",
          "parameters": [
            {
              "name": "hash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 156,
          "raw": "  serializePoolId(hash: string): string {\n    return PoolId.fromKeyHash(Ed25519KeyHashHex(hash)).toString();\n  }",
          "source": "mesh-core-cst",
          "implementation": "  serializePoolId(hash: string): string {\n    return PoolId.fromKeyHash(Ed25519KeyHashHex(hash)).toString();\n  }"
        },
        {
          "name": "serializeData",
          "signature": "serializeData(data: BuilderData): string {",
          "documentation": "",
          "parameters": [
            {
              "name": "data",
              "type": "BuilderData",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 237,
          "raw": "  serializeData(data: BuilderData): string {\n    const plutusData = fromBuilderToPlutusData(data);\n    return plutusData.toCbor().toString();\n  }",
          "source": "mesh-core-cst",
          "implementation": "  serializeData(data: BuilderData): string {\n    const plutusData = fromBuilderToPlutusData(data);\n    return plutusData.toCbor().toString();\n  }"
        },
        {
          "name": "buildBip32PrivateKey",
          "signature": "const buildBip32PrivateKey = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 323,
          "raw": "        const buildBip32PrivateKey = (\n          entropy: string,\n          password = \"\",\n        ): Bip32PrivateKey => {\n          return Bip32PrivateKey.fromBip39Entropy(\n            Buffer.from(toBytes(entropy)),\n            fromUTF8(password),\n          );\n        };",
          "source": "mesh-core-cst",
          "implementation": "        const buildBip32PrivateKey = (\n          entropy: string,\n          password = \"\",\n        ): Bip32PrivateKey => {\n          return Bip32PrivateKey.fromBip39Entropy(\n            Buffer.from(toBytes(entropy)),\n            fromUTF8(password),\n          );\n        };"
        },
        {
          "name": "if",
          "signature": "if (keyHex.length === 68 && keyHex.substring(0, 4) === \"5820\") {",
          "documentation": "",
          "parameters": [
            {
              "name": "keyHex.length === 68 && keyHex.substring(0, 4",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 464,
          "raw": "        if (keyHex.length === 68 && keyHex.substring(0, 4) === \"5820\") {\n          keyHex = keyHex.substring(4);\n        }",
          "source": "mesh-core-cst",
          "implementation": "        if (keyHex.length === 68 && keyHex.substring(0, 4) === \"5820\") {\n          keyHex = keyHex.substring(4);\n        }"
        },
        {
          "name": "serializeValue",
          "signature": "serializeValue(value: Asset[]): string {",
          "documentation": "",
          "parameters": [
            {
              "name": "value",
              "type": "Asset[]",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 487,
          "raw": "  serializeValue(value: Asset[]): string {\n    return toValue(value).toCbor();\n  }",
          "source": "mesh-core-cst",
          "implementation": "  serializeValue(value: Asset[]): string {\n    return toValue(value).toCbor();\n  }"
        },
        {
          "name": "serializeOutput",
          "signature": "serializeOutput(output: Output): string {",
          "documentation": "",
          "parameters": [
            {
              "name": "output",
              "type": "Output",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 491,
          "raw": "  serializeOutput(output: Output): string {\n    let cardanoOutput = new TransactionOutput(\n      toCardanoAddress(output.address),\n      toValue(output.amount),\n    );\n    if (output.datum?.type === \"Hash\") {\n      cardanoOutput.setDatum(\n        Datum.newDataHash(fromBuilderToPlutusData(output.datum.data).hash()),\n      );\n    } else if (output.datum?.type === \"Inline\") {\n      cardanoOutput.setDatum(\n        Datum.newInlineData(fromBuilderToPlutusData(output.datum.data)),\n      );\n    } else if (output.datum?.type === \"Embedded\") {\n      throw new Error(\"Embedded datum not supported\");\n    }\n    if (output.referenceScript) {\n      switch (output.referenceScript.version) {\n        case \"V1\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV1Script(\n              PlutusV1Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        case \"V2\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV2Script(\n              PlutusV2Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        case \"V3\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV3Script(\n              PlutusV3Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        default: {\n          cardanoOutput.setScriptRef(\n            Script.newNativeScript(\n              NativeScript.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n      }\n    }\n    return cardanoOutput.toCbor();\n  }",
          "source": "mesh-core-cst",
          "implementation": "  serializeOutput(output: Output): string {\n    let cardanoOutput = new TransactionOutput(\n      toCardanoAddress(output.address),\n      toValue(output.amount),\n    );\n    if (output.datum?.type === \"Hash\") {\n      cardanoOutput.setDatum(\n        Datum.newDataHash(fromBuilderToPlutusData(output.datum.data).hash()),\n      );\n    } else if (output.datum?.type === \"Inline\") {\n      cardanoOutput.setDatum(\n        Datum.newInlineData(fromBuilderToPlutusData(output.datum.data)),\n      );\n    } else if (output.datum?.type === \"Embedded\") {\n      throw new Error(\"Embedded datum not supported\");\n    }\n    if (output.referenceScript) {\n      switch (output.referenceScript.version) {\n        case \"V1\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV1Script(\n              PlutusV1Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        case \"V2\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV2Script(\n              PlutusV2Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        case \"V3\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV3Script(\n              PlutusV3Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        default: {\n          cardanoOutput.setScriptRef(\n            Script.newNativeScript(\n              NativeScript.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n      }\n    }\n    return cardanoOutput.toCbor();\n  }"
        },
        {
          "name": "coreSerializeTx",
          "signature": "coreSerializeTx(txBuilderBody: MeshTxBuilderBody): string {",
          "documentation": "",
          "parameters": [
            {
              "name": "txBuilderBody",
              "type": "MeshTxBuilderBody",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 709,
          "raw": "  coreSerializeTx(txBuilderBody: MeshTxBuilderBody): string {\n    const bodyCore = this.coreSerializeTxBody(txBuilderBody);\n    if (txBuilderBody.fee !== undefined) {\n      this.txBody.setFee(BigInt(txBuilderBody.fee));\n    }\n    this.buildWitnessSet();\n    return new Transaction(\n      bodyCore,\n      this.txWitnessSet,\n      this.txAuxilliaryData,\n    ).toCbor();\n  }",
          "source": "mesh-core-cst",
          "implementation": "  coreSerializeTx(txBuilderBody: MeshTxBuilderBody): string {\n    const bodyCore = this.coreSerializeTxBody(txBuilderBody);\n    if (txBuilderBody.fee !== undefined) {\n      this.txBody.setFee(BigInt(txBuilderBody.fee));\n    }\n    this.buildWitnessSet();\n    return new Transaction(\n      bodyCore,\n      this.txWitnessSet,\n      this.txAuxilliaryData,\n    ).toCbor();\n  }"
        },
        {
          "name": "coreSerializeTxWithMockSignatures",
          "signature": "coreSerializeTxWithMockSignatures(txBuilderBody: MeshTxBuilderBody): string {",
          "documentation": "",
          "parameters": [
            {
              "name": "txBuilderBody",
              "type": "MeshTxBuilderBody",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 722,
          "raw": "  coreSerializeTxWithMockSignatures(txBuilderBody: MeshTxBuilderBody): string {\n    const bodyCore = this.coreSerializeTxBody(txBuilderBody);\n    const mockWitSet = this.createMockedWitnessSet(\n      txBuilderBody.expectedNumberKeyWitnesses,\n      txBuilderBody.expectedByronAddressWitnesses,\n    );\n    return new Transaction(\n      bodyCore,\n      mockWitSet,\n      this.txAuxilliaryData,\n    ).toCbor();\n  }",
          "source": "mesh-core-cst",
          "implementation": "  coreSerializeTxWithMockSignatures(txBuilderBody: MeshTxBuilderBody): string {\n    const bodyCore = this.coreSerializeTxBody(txBuilderBody);\n    const mockWitSet = this.createMockedWitnessSet(\n      txBuilderBody.expectedNumberKeyWitnesses,\n      txBuilderBody.expectedByronAddressWitnesses,\n    );\n    return new Transaction(\n      bodyCore,\n      mockWitSet,\n      this.txAuxilliaryData,\n    ).toCbor();\n  }"
        },
        {
          "name": "if",
          "signature": "if (asset.toString() == mintAssetId) {",
          "documentation": "",
          "parameters": [
            {
              "name": "asset.toString(",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1057,
          "raw": "        if (asset.toString() == mintAssetId) {\n          throw new Error(\"The same asset is already in the mint field\");\n        }",
          "source": "mesh-core-cst",
          "implementation": "        if (asset.toString() == mintAssetId) {\n          throw new Error(\"The same asset is already in the mint field\");\n        }"
        },
        {
          "name": "if",
          "signature": "if (refInput.toCbor() === inputs[i]!.toCbor()) {",
          "documentation": "",
          "parameters": [
            {
              "name": "refInput.toCbor(",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1515,
          "raw": "          if (refInput.toCbor() === inputs[i]!.toCbor()) {\n            found = true;\n          }",
          "source": "mesh-core-cst",
          "implementation": "          if (refInput.toCbor() === inputs[i]!.toCbor()) {\n            found = true;\n          }"
        },
        {
          "name": "throwErrorWithOrigin",
          "signature": "const throwErrorWithOrigin = (origin: string, error: any) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "origin",
              "type": "string",
              "optional": false
            },
            {
              "name": "error",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 1819,
          "raw": "const throwErrorWithOrigin = (origin: string, error: any) => {\n  if (error instanceof Error) {\n    throw new Error(`${origin}: ${error.message}`);\n  } else if (typeof error === \"string\") {\n    throw new Error(`${origin}: ${error}`);\n  } else if (typeof error === \"object\") {\n    throw new Error(`${origin}: ${JSON.stringify(error)}`);\n  } else {\n    throw new Error(`${origin}: ${String(error)}`);\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "const throwErrorWithOrigin = (origin: string, error: any) => {\n  if (error instanceof Error) {\n    throw new Error(`${origin}: ${error.message}`);\n  } else if (typeof error === \"string\") {\n    throw new Error(`${origin}: ${error}`);\n  } else if (typeof error === \"object\") {\n    throw new Error(`${origin}: ${JSON.stringify(error)}`);\n  } else {\n    throw new Error(`${origin}: ${String(error)}`);\n  }\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "VKEY_PUBKEY_SIZE_BYTES",
          "type": "any",
          "value": "32;",
          "isPublic": true,
          "line": 132,
          "raw": "const VKEY_PUBKEY_SIZE_BYTES = 32;",
          "source": "mesh-core-cst"
        },
        {
          "name": "VKEY_SIGNATURE_SIZE_BYTES",
          "type": "any",
          "value": "64;",
          "isPublic": true,
          "line": 133,
          "raw": "const VKEY_SIGNATURE_SIZE_BYTES = 64;",
          "source": "mesh-core-cst"
        },
        {
          "name": "CHAIN_CODE_SIZE_BYTES",
          "type": "any",
          "value": "32;",
          "isPublic": true,
          "line": 134,
          "raw": "const CHAIN_CODE_SIZE_BYTES = 32;",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusData",
          "type": "any",
          "value": "fromBuilderToPlutusData(data);",
          "isPublic": true,
          "line": 238,
          "raw": "const plutusData = fromBuilderToPlutusData(data);",
          "source": "mesh-core-cst"
        },
        {
          "name": "address",
          "type": "any",
          "value": "Address.fromBech32(bech32);",
          "isPublic": true,
          "line": 245,
          "raw": "const address = Address.fromBech32(bech32);",
          "source": "mesh-core-cst"
        },
        {
          "name": "addressProps",
          "type": "any",
          "value": "address.getProps();",
          "isPublic": true,
          "line": 246,
          "raw": "const addressProps = address.getProps();",
          "source": "mesh-core-cst"
        },
        {
          "name": "cardanoNativeScript",
          "type": "any",
          "value": "toNativeScript(script);",
          "isPublic": true,
          "line": 272,
          "raw": "const cardanoNativeScript = toNativeScript(script);",
          "source": "mesh-core-cst"
        },
        {
          "name": "cardanoPoolId",
          "type": "PoolId",
          "value": "PoolId(poolId);",
          "isPublic": true,
          "line": 307,
          "raw": "const cardanoPoolId: PoolId = PoolId(poolId);",
          "source": "mesh-core-cst"
        },
        {
          "name": "cardanoAddress",
          "type": "any",
          "value": "toAddress(bech32);",
          "isPublic": true,
          "line": 316,
          "raw": "const cardanoAddress = toAddress(bech32);",
          "source": "mesh-core-cst"
        },
        {
          "name": "buildBip32PrivateKey",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 323,
          "raw": "const buildBip32PrivateKey = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "entropy",
          "type": "any",
          "value": "mnemonicToEntropy(words.join(\" \"));",
          "isPublic": true,
          "line": 333,
          "raw": "const entropy = mnemonicToEntropy(words.join(\" \"));",
          "source": "mesh-core-cst"
        },
        {
          "name": "bip32PrivateKey",
          "type": "any",
          "value": "buildBip32PrivateKey(entropy);",
          "isPublic": true,
          "line": 334,
          "raw": "const bip32PrivateKey = buildBip32PrivateKey(entropy);",
          "source": "mesh-core-cst"
        },
        {
          "name": "bytes",
          "type": "any",
          "value": "base32.encode(bip32PrivateKey.bytes());",
          "isPublic": true,
          "line": 335,
          "raw": "const bytes = base32.encode(bip32PrivateKey.bytes());",
          "source": "mesh-core-cst"
        },
        {
          "name": "bech32PrivateKey",
          "type": "any",
          "value": "bech32.encode(\"xprv\", bytes, 1023);",
          "isPublic": true,
          "line": 336,
          "raw": "const bech32PrivateKey = bech32.encode(\"xprv\", bytes, 1023);",
          "source": "mesh-core-cst"
        },
        {
          "name": "cardanoAddress",
          "type": "any",
          "value": "toAddress(bech32);",
          "isPublic": true,
          "line": 341,
          "raw": "const cardanoAddress = toAddress(bech32);",
          "source": "mesh-core-cst"
        },
        {
          "name": "addressProps",
          "type": "any",
          "value": "cardanoAddress.getProps();",
          "isPublic": true,
          "line": 342,
          "raw": "const addressProps = cardanoAddress.getProps();",
          "source": "mesh-core-cst"
        },
        {
          "name": "cardanoAddress",
          "type": "any",
          "value": "toAddress(bech32);",
          "isPublic": true,
          "line": 356,
          "raw": "const cardanoAddress = toAddress(bech32);",
          "source": "mesh-core-cst"
        },
        {
          "name": "addressProps",
          "type": "any",
          "value": "cardanoAddress.getProps();",
          "isPublic": true,
          "line": 357,
          "raw": "const addressProps = cardanoAddress.getProps();",
          "source": "mesh-core-cst"
        },
        {
          "name": "nativeScript",
          "type": "any",
          "value": "toNativeScript(script);",
          "isPublic": true,
          "line": 414,
          "raw": "const nativeScript = toNativeScript(script);",
          "source": "mesh-core-cst"
        },
        {
          "name": "serializerCore",
          "type": "any",
          "value": "new CardanoSDKSerializerCore(",
          "isPublic": true,
          "line": 440,
          "raw": "const serializerCore = new CardanoSDKSerializerCore(",
          "source": "mesh-core-cst"
        },
        {
          "name": "serializerCore",
          "type": "any",
          "value": "new CardanoSDKSerializerCore(protocolParams);",
          "isPublic": true,
          "line": 451,
          "raw": "const serializerCore = new CardanoSDKSerializerCore(protocolParams);",
          "source": "mesh-core-cst"
        },
        {
          "name": "cardanoSigner",
          "type": "any",
          "value": "buildEd25519PrivateKeyFromSecretKey(keyHex);",
          "isPublic": true,
          "line": 467,
          "raw": "const cardanoSigner = buildEd25519PrivateKeyFromSecretKey(keyHex);",
          "source": "mesh-core-cst"
        },
        {
          "name": "signature",
          "type": "any",
          "value": "cardanoSigner.sign(HexBlob(cardanoTx.getId()));",
          "isPublic": true,
          "line": 468,
          "raw": "const signature = cardanoSigner.sign(HexBlob(cardanoTx.getId()));",
          "source": "mesh-core-cst"
        },
        {
          "name": "uniqueRefInputs",
          "type": "any",
          "value": "this.removeBodyInputRefInputOverlap(",
          "isPublic": true,
          "line": 618,
          "raw": "const uniqueRefInputs = this.removeBodyInputRefInputOverlap(",
          "source": "mesh-core-cst"
        },
        {
          "name": "bodyCore",
          "type": "any",
          "value": "this.coreSerializeTxBody(txBuilderBody);",
          "isPublic": true,
          "line": 710,
          "raw": "const bodyCore = this.coreSerializeTxBody(txBuilderBody);",
          "source": "mesh-core-cst"
        },
        {
          "name": "bodyCore",
          "type": "any",
          "value": "this.coreSerializeTxBody(txBuilderBody);",
          "isPublic": true,
          "line": 723,
          "raw": "const bodyCore = this.coreSerializeTxBody(txBuilderBody);",
          "source": "mesh-core-cst"
        },
        {
          "name": "mockWitSet",
          "type": "any",
          "value": "this.createMockedWitnessSet(",
          "isPublic": true,
          "line": 724,
          "raw": "const mockWitSet = this.createMockedWitnessSet(",
          "source": "mesh-core-cst"
        },
        {
          "name": "currentTxIn",
          "type": "any",
          "value": "inputs[i];",
          "isPublic": true,
          "line": 792,
          "raw": "const currentTxIn = inputs[i];",
          "source": "mesh-core-cst"
        },
        {
          "name": "inputs",
          "type": "any",
          "value": "this.txBody.inputs();",
          "isPublic": true,
          "line": 821,
          "raw": "const inputs = this.txBody.inputs();",
          "source": "mesh-core-cst"
        },
        {
          "name": "txInputsList",
          "type": "TransactionInput[]",
          "value": "[...inputs.values()];",
          "isPublic": true,
          "line": 822,
          "raw": "const txInputsList: TransactionInput[] = [...inputs.values()];",
          "source": "mesh-core-cst"
        },
        {
          "name": "cardanoTxOut",
          "type": "any",
          "value": "new TransactionOutput(",
          "isPublic": true,
          "line": 834,
          "raw": "const cardanoTxOut = new TransactionOutput(",
          "source": "mesh-core-cst"
        },
        {
          "name": "currentOutputs",
          "type": "any",
          "value": "this.txBody.outputs();",
          "isPublic": true,
          "line": 929,
          "raw": "const currentOutputs = this.txBody.outputs();",
          "source": "mesh-core-cst"
        },
        {
          "name": "currentWitnessDatumValues",
          "type": "any",
          "value": "[...currentWitnessDatum.values()];",
          "isPublic": true,
          "line": 954,
          "raw": "const currentWitnessDatumValues = [...currentWitnessDatum.values()];",
          "source": "mesh-core-cst"
        },
        {
          "name": "newRedeemer",
          "type": "any",
          "value": "new Redeemer(",
          "isPublic": true,
          "line": 1037,
          "raw": "const newRedeemer = new Redeemer(",
          "source": "mesh-core-cst"
        },
        {
          "name": "currentMint",
          "type": "TokenMap",
          "value": "this.txBody.mint() ?? new Map();",
          "isPublic": true,
          "line": 1051,
          "raw": "const currentMint: TokenMap = this.txBody.mint() ?? new Map();",
          "source": "mesh-core-cst"
        },
        {
          "name": "mintAssetId",
          "type": "any",
          "value": "`${mint.policyId}${assetValue.assetName}`;",
          "isPublic": true,
          "line": 1054,
          "raw": "const mintAssetId = `${mint.policyId}${assetValue.assetName}`;",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusScriptSource",
          "type": "any",
          "value": "mint.scriptSource as ScriptSource;",
          "isPublic": true,
          "line": 1093,
          "raw": "const plutusScriptSource = mint.scriptSource as ScriptSource;",
          "source": "mesh-core-cst"
        },
        {
          "name": "currentRedeemer",
          "type": "any",
          "value": "new Redeemer(",
          "isPublic": true,
          "line": 1103,
          "raw": "const currentRedeemer = new Redeemer(",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusScriptSource",
          "type": "any",
          "value": "cert.scriptSource as ScriptSource;",
          "isPublic": true,
          "line": 1171,
          "raw": "const plutusScriptSource = cert.scriptSource as ScriptSource;",
          "source": "mesh-core-cst"
        },
        {
          "name": "address",
          "type": "any",
          "value": "toCardanoAddress(withdrawal.address);",
          "isPublic": true,
          "line": 1215,
          "raw": "const address = toCardanoAddress(withdrawal.address);",
          "source": "mesh-core-cst"
        },
        {
          "name": "rewardAddress",
          "type": "any",
          "value": "address.asReward();",
          "isPublic": true,
          "line": 1216,
          "raw": "const rewardAddress = address.asReward();",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusScriptSource",
          "type": "any",
          "value": "withdrawal.scriptSource as ScriptSource;",
          "isPublic": true,
          "line": 1252,
          "raw": "const plutusScriptSource = withdrawal.scriptSource as ScriptSource;",
          "source": "mesh-core-cst"
        },
        {
          "name": "collateralInputsList",
          "type": "TransactionInput[]",
          "value": "[",
          "isPublic": true,
          "line": 1306,
          "raw": "const collateralInputsList: TransactionInput[] = [",
          "source": "mesh-core-cst"
        },
        {
          "name": "cardanoTxOut",
          "type": "any",
          "value": "new TransactionOutput(",
          "isPublic": true,
          "line": 1321,
          "raw": "const cardanoTxOut = new TransactionOutput(",
          "source": "mesh-core-cst"
        },
        {
          "name": "collateralReturn",
          "type": "any",
          "value": "new TransactionOutput(",
          "isPublic": true,
          "line": 1343,
          "raw": "const collateralReturn = new TransactionOutput(",
          "source": "mesh-core-cst"
        },
        {
          "name": "clonedWitnessSet",
          "type": "any",
          "value": "TransactionWitnessSet.fromCbor(",
          "isPublic": true,
          "line": 1393,
          "raw": "const clonedWitnessSet = TransactionWitnessSet.fromCbor(",
          "source": "mesh-core-cst"
        },
        {
          "name": "bootstrapWitnesses",
          "type": "any",
          "value": "this.mockBootstrapWitnesses(",
          "isPublic": true,
          "line": 1396,
          "raw": "const bootstrapWitnesses = this.mockBootstrapWitnesses(",
          "source": "mesh-core-cst"
        },
        {
          "name": "vkeyWitnesses",
          "type": "any",
          "value": "this.mockVkeyWitnesses(requiredSignaturesCount);",
          "isPublic": true,
          "line": 1399,
          "raw": "const vkeyWitnesses = this.mockVkeyWitnesses(requiredSignaturesCount);",
          "source": "mesh-core-cst"
        },
        {
          "name": "bootstrapsSet",
          "type": "any",
          "value": "CborSet.fromCore([], BootstrapWitness.fromCore);",
          "isPublic": true,
          "line": 1401,
          "raw": "const bootstrapsSet = CborSet.fromCore([], BootstrapWitness.fromCore);",
          "source": "mesh-core-cst"
        },
        {
          "name": "vkeysSet",
          "type": "any",
          "value": "CborSet.fromCore([], VkeyWitness.fromCore);",
          "isPublic": true,
          "line": 1405,
          "raw": "const vkeysSet = CborSet.fromCore([], VkeyWitness.fromCore);",
          "source": "mesh-core-cst"
        },
        {
          "name": "script",
          "type": "any",
          "value": "Script.fromCbor(HexBlob(scriptHex));",
          "isPublic": true,
          "line": 1431,
          "raw": "const script = Script.fromCbor(HexBlob(scriptHex));",
          "source": "mesh-core-cst"
        },
        {
          "name": "redeemers",
          "type": "any",
          "value": "this.txWitnessSet.redeemers() ?? Redeemers.fromCore([]);",
          "isPublic": true,
          "line": 1490,
          "raw": "const redeemers = this.txWitnessSet.redeemers() ?? Redeemers.fromCore([]);",
          "source": "mesh-core-cst"
        },
        {
          "name": "inputs",
          "type": "any",
          "value": "this.txBody.inputs()?.values();",
          "isPublic": true,
          "line": 1509,
          "raw": "const inputs = this.txBody.inputs()?.values();",
          "source": "mesh-core-cst"
        },
        {
          "name": "currentRefInputValues",
          "type": "any",
          "value": "this.txBody.referenceInputs()!.values();",
          "isPublic": true,
          "line": 1511,
          "raw": "const currentRefInputValues = this.txBody.referenceInputs()!.values();",
          "source": "mesh-core-cst"
        },
        {
          "name": "vote",
          "type": "any",
          "value": "votes[i];",
          "isPublic": true,
          "line": 1634,
          "raw": "const vote = votes[i];",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusScriptSource",
          "type": "any",
          "value": "vote.scriptSource as ScriptSource;",
          "isPublic": true,
          "line": 1668,
          "raw": "const plutusScriptSource = vote.scriptSource as ScriptSource;",
          "source": "mesh-core-cst"
        },
        {
          "name": "numberInHex",
          "type": "any",
          "value": "this.numberToIntegerHex(i);",
          "isPublic": true,
          "line": 1729,
          "raw": "const numberInHex = this.numberToIntegerHex(i);",
          "source": "mesh-core-cst"
        },
        {
          "name": "pubKeyHex",
          "type": "any",
          "value": "this.mockPubkey(numberInHex);",
          "isPublic": true,
          "line": 1730,
          "raw": "const pubKeyHex = this.mockPubkey(numberInHex);",
          "source": "mesh-core-cst"
        },
        {
          "name": "signature",
          "type": "any",
          "value": "this.mockSignature(numberInHex);",
          "isPublic": true,
          "line": 1731,
          "raw": "const signature = this.mockSignature(numberInHex);",
          "source": "mesh-core-cst"
        },
        {
          "name": "address",
          "type": "any",
          "value": "Address.fromBytes(<HexBlob>byronAddresses[i]).asByron();",
          "isPublic": true,
          "line": 1769,
          "raw": "const address = Address.fromBytes(<HexBlob>byronAddresses[i]).asByron();",
          "source": "mesh-core-cst"
        },
        {
          "name": "numberInHex",
          "type": "any",
          "value": "this.numberToIntegerHex(i);",
          "isPublic": true,
          "line": 1773,
          "raw": "const numberInHex = this.numberToIntegerHex(i);",
          "source": "mesh-core-cst"
        },
        {
          "name": "pubKeyHex",
          "type": "any",
          "value": "this.mockPubkey(numberInHex);",
          "isPublic": true,
          "line": 1774,
          "raw": "const pubKeyHex = this.mockPubkey(numberInHex);",
          "source": "mesh-core-cst"
        },
        {
          "name": "signature",
          "type": "any",
          "value": "this.mockSignature(numberInHex);",
          "isPublic": true,
          "line": 1775,
          "raw": "const signature = this.mockSignature(numberInHex);",
          "source": "mesh-core-cst"
        },
        {
          "name": "chainCode",
          "type": "any",
          "value": "this.mockChainCode(numberInHex);",
          "isPublic": true,
          "line": 1776,
          "raw": "const chainCode = this.mockChainCode(numberInHex);",
          "source": "mesh-core-cst"
        },
        {
          "name": "attributes",
          "type": "any",
          "value": "address.getAttributes();",
          "isPublic": true,
          "line": 1777,
          "raw": "const attributes = address.getAttributes();",
          "source": "mesh-core-cst"
        },
        {
          "name": "writer",
          "type": "any",
          "value": "new CborWriter();",
          "isPublic": true,
          "line": 1791,
          "raw": "const writer = new CborWriter();",
          "source": "mesh-core-cst"
        },
        {
          "name": "encodedPathCbor",
          "type": "any",
          "value": "new CborWriter()",
          "isPublic": true,
          "line": 1803,
          "raw": "const encodedPathCbor = new CborWriter()",
          "source": "mesh-core-cst"
        },
        {
          "name": "encodedMagicCbor",
          "type": "any",
          "value": "new CborWriter()",
          "isPublic": true,
          "line": 1810,
          "raw": "const encodedMagicCbor = new CborWriter()",
          "source": "mesh-core-cst"
        },
        {
          "name": "throwErrorWithOrigin",
          "type": "any",
          "value": "(origin: string, error: any) => {",
          "isPublic": true,
          "line": 1819,
          "raw": "const throwErrorWithOrigin = (origin: string, error: any) => {",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "/*\nThis file is part of meshjs.dev.\n\nThis source code is licensed under the MIT license found in the\nLICENSE file in the root directory of this source tree. See the\nApache-2.0 License for more details.\n*/\n\nimport { Buffer } from \"buffer\";\nimport { Serialization, setInConwayEra } from \"@cardano-sdk/core\";\nimport { HexBlob } from \"@cardano-sdk/util\";\nimport {\n  Cbor,\n  CborArray,\n  CborBytes,\n  CborString,\n  CborTag,\n  CborUInt,\n} from \"@harmoniclabs/cbor\";\nimport base32 from \"base32-encoding\";\nimport { bech32 } from \"bech32\";\n\nimport {\n  Asset,\n  BasicVote,\n  BuilderData,\n  Certificate,\n  NativeScript as CommonNativeScript,\n  DEFAULT_PROTOCOL_PARAMETERS,\n  DEFAULT_V1_COST_MODEL_LIST,\n  DEFAULT_V2_COST_MODEL_LIST,\n  DEFAULT_V3_COST_MODEL_LIST,\n  DeserializedAddress,\n  DeserializedScript,\n  fromUTF8,\n  IDeserializer,\n  IMeshTxSerializer,\n  IResolver,\n  ITxParser,\n  MeshTxBuilderBody,\n  MintParam,\n  mnemonicToEntropy,\n  Output,\n  PlutusDataType,\n  PlutusScript,\n  Protocol,\n  PubKeyTxIn,\n  RefTxIn,\n  RequiredWith,\n  ScriptSource,\n  ScriptTxIn,\n  ScriptVote,\n  SimpleScriptSourceInfo,\n  SimpleScriptTxIn,\n  SimpleScriptVote,\n  toBytes,\n  TxIn,\n  TxInput,\n  TxMetadata,\n  UTxO,\n  ValidityRange,\n  Vote,\n  Withdrawal,\n} from \"@meshsdk/common\";\n\nimport { resolveDataHash } from \"..\";\nimport {\n  Address,\n  AddressType,\n  AssetId,\n  AssetName,\n  AuxiliaryData,\n  AuxilliaryData,\n  Bip32PrivateKey,\n  BootstrapWitness,\n  ByronAttributes,\n  CborSet,\n  CborWriter,\n  computeAuxiliaryDataHash,\n  CredentialCore,\n  CredentialType,\n  Datum,\n  DatumHash,\n  Ed25519KeyHashHex,\n  Ed25519PublicKeyHex,\n  Ed25519SignatureHex,\n  ExUnits,\n  Hash28ByteBase16,\n  NativeScript,\n  PlutusData,\n  PlutusLanguageVersion,\n  PlutusV1Script,\n  PlutusV2Script,\n  PlutusV3Script,\n  PolicyId,\n  PoolId,\n  Redeemer,\n  Redeemers,\n  RedeemerTag,\n  RewardAccount,\n  RewardAddress,\n  Script,\n  Slot,\n  TokenMap,\n  Transaction,\n  TransactionBody,\n  TransactionId,\n  TransactionInput,\n  TransactionOutput,\n  TransactionWitnessSet,\n  Value,\n  VkeyWitness,\n} from \"../types\";\nimport {\n  buildEd25519PrivateKeyFromSecretKey,\n  fromBuilderToPlutusData,\n  mergeValue,\n  toAddress,\n  toCardanoAddress,\n  toNativeScript,\n  toValue,\n} from \"../utils\";\nimport { toCardanoCert } from \"../utils/certificate\";\nimport { toCardanoMetadataMap } from \"../utils/metadata\";\nimport { hashScriptData } from \"../utils/script-data-hash\";\nimport {\n  toCardanoGovernanceActionId,\n  toCardanoVoter,\n  toCardanoVotingProcedure,\n} from \"../utils/vote\";\n\nconst VKEY_PUBKEY_SIZE_BYTES = 32;\nconst VKEY_SIGNATURE_SIZE_BYTES = 64;\nconst CHAIN_CODE_SIZE_BYTES = 32;\n\nexport class CardanoSDKSerializer implements IMeshTxSerializer {\n  protocolParams: Protocol;\n\n  constructor(protocolParams?: Protocol) {\n    setInConwayEra(true);\n    this.protocolParams = protocolParams || DEFAULT_PROTOCOL_PARAMETERS;\n  }\n  serializeRewardAddress(\n    stakeKeyHash: string,\n    isScriptHash?: boolean,\n    network_id?: 0 | 1,\n  ): string {\n    return RewardAddress.fromCredentials(network_id ?? 0, {\n      type: isScriptHash ? CredentialType.ScriptHash : CredentialType.KeyHash,\n      hash: Hash28ByteBase16(stakeKeyHash),\n    })\n      .toAddress()\n      .toBech32();\n  }\n\n  serializePoolId(hash: string): string {\n    return PoolId.fromKeyHash(Ed25519KeyHashHex(hash)).toString();\n  }\n\n  serializeAddress(\n    address: Partial<DeserializedAddress>,\n    networkId?: 0 | 1,\n  ): string {\n    let paymentCred: CredentialCore | undefined = undefined;\n\n    let stakeCred: CredentialCore | undefined;\n\n    if (address.pubKeyHash && address.pubKeyHash !== \"\") {\n      paymentCred = {\n        type: CredentialType.KeyHash,\n        hash: Hash28ByteBase16(address.pubKeyHash),\n      };\n    } else if (address.scriptHash && address.scriptHash !== \"\") {\n      paymentCred = {\n        type: CredentialType.ScriptHash,\n        hash: Hash28ByteBase16(address.scriptHash),\n      };\n    }\n\n    if (address.stakeCredentialHash && address.stakeCredentialHash !== \"\") {\n      stakeCred = {\n        type: CredentialType.KeyHash,\n        hash: Hash28ByteBase16(address.stakeCredentialHash),\n      };\n    } else if (address.stakeScriptCredentialHash) {\n      stakeCred = {\n        type: CredentialType.ScriptHash,\n        hash: Hash28ByteBase16(address.stakeScriptCredentialHash),\n      };\n    }\n\n    let type: AddressType = AddressType.BasePaymentKeyStakeKey;\n    if (paymentCred && stakeCred) {\n      if (\n        paymentCred.type === CredentialType.KeyHash &&\n        stakeCred.type === CredentialType.KeyHash\n      ) {\n        type = AddressType.BasePaymentKeyStakeKey;\n      } else if (\n        paymentCred.type === CredentialType.KeyHash &&\n        stakeCred.type === CredentialType.ScriptHash\n      ) {\n        type = AddressType.BasePaymentKeyStakeScript;\n      } else if (\n        paymentCred.type === CredentialType.ScriptHash &&\n        stakeCred.type === CredentialType.KeyHash\n      ) {\n        type = AddressType.BasePaymentScriptStakeKey;\n      } else if (\n        paymentCred.type === CredentialType.ScriptHash &&\n        stakeCred.type === CredentialType.ScriptHash\n      ) {\n        type = AddressType.BasePaymentScriptStakeScript;\n      }\n    } else if (paymentCred) {\n      if (paymentCred.type === CredentialType.KeyHash) {\n        type = AddressType.EnterpriseKey;\n      } else if (paymentCred.type === CredentialType.ScriptHash) {\n        type = AddressType.EnterpriseScript;\n      }\n    } else if (stakeCred) {\n      if (stakeCred.type === CredentialType.KeyHash) {\n        type = AddressType.RewardKey;\n      } else if (stakeCred.type === CredentialType.ScriptHash) {\n        type = AddressType.RewardScript;\n      }\n    }\n\n    return new Address({\n      type,\n      networkId: networkId ?? 0,\n      paymentPart: paymentCred,\n      delegationPart: stakeCred,\n    }).toBech32();\n  }\n\n  serializeData(data: BuilderData): string {\n    const plutusData = fromBuilderToPlutusData(data);\n    return plutusData.toCbor().toString();\n  }\n\n  deserializer: IDeserializer = {\n    key: {\n      deserializeAddress: function (bech32: string): DeserializedAddress {\n        const address = Address.fromBech32(bech32);\n        const addressProps = address.getProps();\n\n        return {\n          pubKeyHash:\n            addressProps.paymentPart?.type === CredentialType.KeyHash\n              ? (addressProps.paymentPart?.hash ?? \"\")\n              : \"\",\n          scriptHash:\n            addressProps.paymentPart?.type === CredentialType.ScriptHash\n              ? (addressProps.paymentPart?.hash ?? \"\")\n              : \"\",\n          stakeCredentialHash:\n            addressProps.delegationPart?.type === CredentialType.KeyHash\n              ? (addressProps.paymentPart?.hash ?? \"\")\n              : \"\",\n          stakeScriptCredentialHash:\n            addressProps.delegationPart?.type === CredentialType.ScriptHash\n              ? (addressProps.paymentPart?.hash ?? \"\")\n              : \"\",\n        };\n      },\n    },\n    script: {\n      deserializeNativeScript: function (\n        script: CommonNativeScript,\n      ): DeserializedScript {\n        const cardanoNativeScript = toNativeScript(script);\n        return {\n          scriptHash: cardanoNativeScript.hash().toString(),\n          scriptCbor: cardanoNativeScript.toCbor().toString(),\n        };\n      },\n      deserializePlutusScript: function (\n        script: PlutusScript,\n      ): DeserializedScript {\n        let cardanoPlutusScript:\n          | PlutusV1Script\n          | PlutusV2Script\n          | PlutusV3Script;\n        switch (script.version) {\n          case \"V1\": {\n            cardanoPlutusScript = new PlutusV1Script(HexBlob(script.code));\n            break;\n          }\n          case \"V2\": {\n            cardanoPlutusScript = new PlutusV2Script(HexBlob(script.code));\n            break;\n          }\n          case \"V3\": {\n            cardanoPlutusScript = new PlutusV3Script(HexBlob(script.code));\n            break;\n          }\n        }\n        return {\n          scriptHash: cardanoPlutusScript.hash().toString(),\n          scriptCbor: cardanoPlutusScript.toCbor().toString(),\n        };\n      },\n    },\n    cert: {\n      deserializePoolId: function (poolId: string): string {\n        const cardanoPoolId: PoolId = PoolId(poolId);\n        return PoolId.toKeyHash(cardanoPoolId).toString();\n      },\n    },\n  };\n\n  resolver: IResolver = {\n    keys: {\n      resolveStakeKeyHash: function (bech32: string): string {\n        const cardanoAddress = toAddress(bech32);\n        return cardanoAddress.asReward()?.getPaymentCredential().type ===\n          CredentialType.KeyHash\n          ? cardanoAddress.asReward()!.getPaymentCredential().hash\n          : \"\";\n      },\n      resolvePrivateKey: function (words: string[]): string {\n        const buildBip32PrivateKey = (\n          entropy: string,\n          password = \"\",\n        ): Bip32PrivateKey => {\n          return Bip32PrivateKey.fromBip39Entropy(\n            Buffer.from(toBytes(entropy)),\n            fromUTF8(password),\n          );\n        };\n\n        const entropy = mnemonicToEntropy(words.join(\" \"));\n        const bip32PrivateKey = buildBip32PrivateKey(entropy);\n        const bytes = base32.encode(bip32PrivateKey.bytes());\n        const bech32PrivateKey = bech32.encode(\"xprv\", bytes, 1023);\n\n        return bech32PrivateKey;\n      },\n      resolveRewardAddress: function (bech32: string): string {\n        const cardanoAddress = toAddress(bech32);\n        const addressProps = cardanoAddress.getProps();\n        if (!addressProps.delegationPart) {\n          return \"\";\n        }\n        return (\n          RewardAddress.fromCredentials(\n            cardanoAddress.getNetworkId(),\n            addressProps.delegationPart,\n          )\n            .toAddress()\n            .toBech32() ?? \"\"\n        );\n      },\n      resolveEd25519KeyHash: function (bech32: string): string {\n        const cardanoAddress = toAddress(bech32);\n        const addressProps = cardanoAddress.getProps();\n        if (!addressProps.paymentPart) {\n          return \"\";\n        }\n        return addressProps.paymentPart.hash.toString();\n      },\n    },\n    tx: {\n      resolveTxHash: function (txHex: string): string {\n        return Transaction.fromCbor(Serialization.TxCBOR(txHex)).getId();\n      },\n    },\n    data: {\n      resolveDataHash: function (\n        rawData: BuilderData[\"content\"],\n        type: PlutusDataType = \"Mesh\",\n      ): string {\n        return resolveDataHash(rawData, type);\n      },\n    },\n    script: {\n      resolveScriptRef: function (\n        script: CommonNativeScript | PlutusScript,\n      ): string {\n        if (\"code\" in script) {\n          let versionByte;\n          switch (script.version) {\n            case \"V1\": {\n              versionByte = 1;\n              break;\n            }\n            case \"V2\": {\n              versionByte = 2;\n              break;\n            }\n            case \"V3\": {\n              versionByte = 3;\n              break;\n            }\n          }\n          let taggedScript: CborTag = new CborTag(\n            24,\n            Cbor.parse(\n              CborString.fromCborObj(\n                new CborBytes(\n                  Cbor.encode(\n                    new CborArray([\n                      new CborUInt(versionByte),\n                      new CborString(script.code).toCborObj(),\n                    ]),\n                  ).toBuffer(),\n                ),\n              ),\n            ),\n          );\n          return Cbor.encode(taggedScript).toString();\n        } else {\n          const nativeScript = toNativeScript(script);\n          let taggedScript: CborTag = new CborTag(\n            24,\n            Cbor.parse(\n              CborString.fromCborObj(\n                new CborBytes(\n                  Cbor.encode(\n                    new CborArray([\n                      new CborUInt(0),\n                      new CborString(nativeScript.toCbor()).toCborObj(),\n                    ]),\n                  ).toBuffer(),\n                ),\n              ),\n            ),\n          );\n          return Cbor.encode(taggedScript).toString();\n        }\n      },\n    },\n  };\n\n  serializeTxBody = (\n    txBuilderBody: MeshTxBuilderBody,\n    protocolParams?: Protocol,\n  ): string => {\n    const serializerCore = new CardanoSDKSerializerCore(\n      protocolParams ?? this.protocolParams,\n    );\n\n    return serializerCore.coreSerializeTx(txBuilderBody);\n  };\n\n  serializeTxBodyWithMockSignatures(\n    txBuilderBody: MeshTxBuilderBody,\n    protocolParams: Protocol,\n  ): string {\n    const serializerCore = new CardanoSDKSerializerCore(protocolParams);\n    return serializerCore.coreSerializeTxWithMockSignatures(txBuilderBody);\n  }\n\n  addSigningKeys = (txHex: string, signingKeys: string[]): string => {\n    let cardanoTx = Transaction.fromCbor(Serialization.TxCBOR(txHex));\n    let currentWitnessSet = cardanoTx.witnessSet();\n    let currentWitnessSetVkeys = currentWitnessSet.vkeys();\n    let currentWitnessSetVkeysValues: Serialization.VkeyWitness[] =\n      currentWitnessSetVkeys ? [...currentWitnessSetVkeys.values()] : [];\n    for (let i = 0; i < signingKeys.length; i++) {\n      let keyHex = signingKeys[i];\n      if (keyHex) {\n        if (keyHex.length === 68 && keyHex.substring(0, 4) === \"5820\") {\n          keyHex = keyHex.substring(4);\n        }\n        const cardanoSigner = buildEd25519PrivateKeyFromSecretKey(keyHex);\n        const signature = cardanoSigner.sign(HexBlob(cardanoTx.getId()));\n        currentWitnessSetVkeysValues.push(\n          new VkeyWitness(\n            Ed25519PublicKeyHex(cardanoSigner.toPublic().hex()),\n            Ed25519SignatureHex(signature.hex()),\n          ),\n        );\n      }\n    }\n    currentWitnessSet.setVkeys(\n      Serialization.CborSet.fromCore(\n        currentWitnessSetVkeysValues.map((vkw) => vkw.toCore()),\n        VkeyWitness.fromCore,\n      ),\n    );\n    cardanoTx.setWitnessSet(currentWitnessSet);\n    return cardanoTx.toCbor();\n  };\n\n  serializeValue(value: Asset[]): string {\n    return toValue(value).toCbor();\n  }\n\n  serializeOutput(output: Output): string {\n    let cardanoOutput = new TransactionOutput(\n      toCardanoAddress(output.address),\n      toValue(output.amount),\n    );\n    if (output.datum?.type === \"Hash\") {\n      cardanoOutput.setDatum(\n        Datum.newDataHash(fromBuilderToPlutusData(output.datum.data).hash()),\n      );\n    } else if (output.datum?.type === \"Inline\") {\n      cardanoOutput.setDatum(\n        Datum.newInlineData(fromBuilderToPlutusData(output.datum.data)),\n      );\n    } else if (output.datum?.type === \"Embedded\") {\n      throw new Error(\"Embedded datum not supported\");\n    }\n    if (output.referenceScript) {\n      switch (output.referenceScript.version) {\n        case \"V1\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV1Script(\n              PlutusV1Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        case \"V2\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV2Script(\n              PlutusV2Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        case \"V3\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV3Script(\n              PlutusV3Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        default: {\n          cardanoOutput.setScriptRef(\n            Script.newNativeScript(\n              NativeScript.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n      }\n    }\n    return cardanoOutput.toCbor();\n  }\n\n  parser: ITxParser = {\n    getRequiredInputs: function (txHex: string): TxInput[] {\n      throw new Error(\"Function not implemented.\");\n    },\n    parse: function (txHex: string, resolvedUtxos?: UTxO[]): void {\n      throw new Error(\"Method not implemented.\");\n    },\n    toTester: function (): any {\n      throw new Error(\"Method not implemented.\");\n    },\n    getBuilderBody: function (): MeshTxBuilderBody {\n      throw new Error(\"Method not implemented.\");\n    },\n    getBuilderBodyWithoutChange: function (): MeshTxBuilderBody {\n      throw new Error(\"Method not implemented.\");\n    },\n  };\n}\n\nclass CardanoSDKSerializerCore {\n  public txBody: TransactionBody;\n  public txWitnessSet: TransactionWitnessSet;\n  public txAuxilliaryData: AuxiliaryData;\n\n  private utxoContext: Map<TransactionInput, TransactionOutput> = new Map<\n    TransactionInput,\n    TransactionOutput\n  >();\n\n  private mintRedeemers: Map<String, Redeemer> = new Map<String, Redeemer>();\n\n  private scriptsProvided: Set<string> = new Set<string>();\n  private datumsProvided: Set<PlutusData> = new Set<PlutusData>();\n  private usedLanguages: Record<PlutusLanguageVersion, boolean> = {\n    [0]: false,\n    [1]: false,\n    [2]: false,\n  };\n  private protocolParams: Protocol;\n  private refScriptSize: number;\n\n  constructor(protocolParams?: Protocol) {\n    this.protocolParams = protocolParams || DEFAULT_PROTOCOL_PARAMETERS;\n    this.txBody = new TransactionBody(\n      Serialization.CborSet.fromCore([], TransactionInput.fromCore),\n      [],\n      BigInt(0),\n      undefined,\n    );\n    this.refScriptSize = 0;\n    this.txWitnessSet = new TransactionWitnessSet();\n    this.txAuxilliaryData = new AuxilliaryData();\n  }\n\n  coreSerializeTxBody = (txBuilderBody: MeshTxBuilderBody): TransactionBody => {\n    const {\n      inputs,\n      outputs,\n      collaterals,\n      requiredSignatures,\n      referenceInputs,\n      mints,\n      metadata,\n      validityRange,\n      certificates,\n      withdrawals,\n      votes,\n      totalCollateral,\n      collateralReturnAddress,\n      changeAddress,\n    } = txBuilderBody;\n\n    const uniqueRefInputs = this.removeBodyInputRefInputOverlap(\n      inputs,\n      referenceInputs,\n    );\n    try {\n      this.addAllInputs(inputs);\n    } catch (e) {\n      throwErrorWithOrigin(\"Error serializing inputs\", e);\n    }\n    try {\n      this.setFee(txBuilderBody.fee ?? \"0\");\n    } catch (e) {\n      throwErrorWithOrigin(\"Error serializing fee\", e);\n    }\n    try {\n      this.sanitizeOutputs(outputs);\n    } catch (e) {\n      throwErrorWithOrigin(\"Error calculating min utxo values for outputs\", e);\n    }\n    try {\n      this.addAllOutputs(outputs);\n    } catch (e) {\n      throwErrorWithOrigin(\"Error serializing outputs\", e);\n    }\n    try {\n      this.addAllMints(mints);\n    } catch (e) {\n      throwErrorWithOrigin(\"Error serializing mints\", e);\n    }\n    try {\n      this.addAllCerts(certificates);\n    } catch (e) {\n      throwErrorWithOrigin(\"Error serializing certificates\", e);\n    }\n    try {\n      this.addAllWithdrawals(withdrawals);\n    } catch (e) {\n      throwErrorWithOrigin(\"Error serializing withdrawals\", e);\n    }\n    try {\n      this.addAllVotes(votes);\n    } catch (e) {\n      throwErrorWithOrigin(\"Error serializing votes\", e);\n    }\n    try {\n      this.addAllCollateralInputs(collaterals);\n    } catch (e) {\n      throwErrorWithOrigin(\"Error serializing collateral inputs\", e);\n    }\n    if (totalCollateral) {\n      try {\n        this.txBody.setTotalCollateral(BigInt(totalCollateral));\n        this.addCollateralReturn(\n          totalCollateral,\n          collaterals,\n          collateralReturnAddress ?? changeAddress,\n        );\n      } catch (e) {\n        throwErrorWithOrigin(\n          \"Error serializing total collateral and collateral return\",\n          e,\n        );\n      }\n    }\n    try {\n      this.addAllReferenceInputs(uniqueRefInputs);\n    } catch (e) {\n      throwErrorWithOrigin(\"Error serializing reference inputs\", e);\n    }\n    this.removeInputRefInputOverlap();\n    try {\n      this.setValidityInterval(validityRange);\n    } catch (e) {\n      throwErrorWithOrigin(\"Error serializing validity interval\", e);\n    }\n    try {\n      this.addAllRequiredSignatures(requiredSignatures);\n    } catch (e) {\n      throwErrorWithOrigin(\"Error serializing required signatures\", e);\n    }\n    if (metadata.size > 0) {\n      try {\n        this.addMetadata(metadata);\n      } catch (e) {\n        throwErrorWithOrigin(\"Error serializing metadata\", e);\n      }\n    }\n\n    return this.txBody;\n  };\n\n  coreSerializeTx(txBuilderBody: MeshTxBuilderBody): string {\n    const bodyCore = this.coreSerializeTxBody(txBuilderBody);\n    if (txBuilderBody.fee !== undefined) {\n      this.txBody.setFee(BigInt(txBuilderBody.fee));\n    }\n    this.buildWitnessSet();\n    return new Transaction(\n      bodyCore,\n      this.txWitnessSet,\n      this.txAuxilliaryData,\n    ).toCbor();\n  }\n\n  coreSerializeTxWithMockSignatures(txBuilderBody: MeshTxBuilderBody): string {\n    const bodyCore = this.coreSerializeTxBody(txBuilderBody);\n    const mockWitSet = this.createMockedWitnessSet(\n      txBuilderBody.expectedNumberKeyWitnesses,\n      txBuilderBody.expectedByronAddressWitnesses,\n    );\n    return new Transaction(\n      bodyCore,\n      mockWitSet,\n      this.txAuxilliaryData,\n    ).toCbor();\n  }\n\n  private sanitizeOutputs = (outputs: Output[]): void => {\n    for (let i = 0; i < outputs.length; i++) {\n      let currentOutput = outputs[i];\n      let lovelaceFound = false;\n      for (let j = 0; j < currentOutput!.amount.length; j++) {\n        let outputAmount = currentOutput!.amount[j];\n        if (outputAmount?.unit == \"\" || outputAmount?.unit == \"lovelace\") {\n          lovelaceFound = true;\n          if (outputAmount?.quantity == \"0\" || outputAmount?.quantity == \"\") {\n            // If lovelace quantity is not set, we will first set a dummy amount to calculate\n            // the size of output, which we can then use to calculate the real minAdaAmount\n            outputAmount.unit = \"lovelace\";\n            outputAmount.quantity = \"10000000\";\n\n            let dummyCardanoOutput: TransactionOutput = this.toCardanoOutput(\n              currentOutput!,\n            );\n            let minUtxoValue =\n              (160 + dummyCardanoOutput.toCbor().length / 2 + 1) *\n              this.protocolParams.coinsPerUtxoSize;\n            outputAmount.quantity = minUtxoValue.toString();\n          }\n        }\n      }\n      if (!lovelaceFound) {\n        let currentAmount = {\n          unit: \"lovelace\",\n          quantity: \"10000000\",\n        };\n        currentOutput!.amount.push(currentAmount);\n        let dummyCardanoOutput: TransactionOutput = this.toCardanoOutput(\n          currentOutput!,\n        );\n        let minUtxoValue =\n          (160 + dummyCardanoOutput.toCbor().length / 2 + 1) *\n          this.protocolParams.coinsPerUtxoSize;\n        currentAmount.quantity = minUtxoValue.toString();\n        if (!lovelaceFound) {\n          let currentAmount = {\n            unit: \"lovelace\",\n            quantity: \"10000000\",\n          };\n          currentOutput!.amount.push(currentAmount);\n          let dummyCardanoOutput: TransactionOutput = this.toCardanoOutput(\n            currentOutput!,\n          );\n          let minUtxoValue =\n            (160 + dummyCardanoOutput.toCbor().length / 2 + 1) *\n            this.protocolParams.coinsPerUtxoSize;\n          currentAmount.quantity = minUtxoValue.toString();\n        }\n      }\n    }\n  };\n\n  private addAllInputs = (inputs: TxIn[]) => {\n    for (let i = 0; i < inputs.length; i += 1) {\n      const currentTxIn = inputs[i];\n      if (!currentTxIn) continue;\n      switch (currentTxIn.type) {\n        case \"PubKey\":\n          this.addTxIn(currentTxIn as RequiredWith<PubKeyTxIn, \"txIn\">);\n          break;\n        case \"Script\":\n          this.addScriptTxIn(\n            currentTxIn as RequiredWith<ScriptTxIn, \"txIn\" | \"scriptTxIn\">,\n            i,\n          );\n          break;\n        case \"SimpleScript\":\n          this.addSimpleScriptTxIn(\n            currentTxIn as RequiredWith<\n              SimpleScriptTxIn,\n              \"txIn\" | \"simpleScriptTxIn\"\n            >,\n          );\n      }\n    }\n  };\n\n  private addTxIn = (currentTxIn: RequiredWith<PubKeyTxIn, \"txIn\">) => {\n    // First build Cardano tx in and add it to tx body\n    let cardanoTxIn = new TransactionInput(\n      TransactionId(currentTxIn.txIn.txHash),\n      BigInt(currentTxIn.txIn.txIndex),\n    );\n    const inputs = this.txBody.inputs();\n    const txInputsList: TransactionInput[] = [...inputs.values()];\n    if (\n      txInputsList.find((input) => {\n        input.index() == cardanoTxIn.index() &&\n          input.transactionId == cardanoTxIn.transactionId;\n      })\n    ) {\n      throw new Error(\"Duplicate input added to tx body\");\n    }\n    txInputsList.push(cardanoTxIn);\n    inputs.setValues(txInputsList);\n    // We save the output to a mapping so that we can calculate change\n    const cardanoTxOut = new TransactionOutput(\n      toCardanoAddress(currentTxIn.txIn.address),\n      toValue(currentTxIn.txIn.amount),\n    );\n    this.utxoContext.set(cardanoTxIn, cardanoTxOut);\n    this.txBody.setInputs(inputs);\n\n    // Add script size if ref script in input\n    if (currentTxIn.txIn.scriptSize) {\n      this.refScriptSize += currentTxIn.txIn.scriptSize;\n    }\n  };\n\n  private addScriptTxIn = (\n    currentTxIn: RequiredWith<ScriptTxIn, \"txIn\" | \"scriptTxIn\">,\n    index: number,\n  ) => {\n    // we can add the input in first, and handle the script info after\n    this.addTxIn({\n      type: \"PubKey\",\n      txIn: currentTxIn.txIn,\n    });\n    if (!currentTxIn.scriptTxIn.scriptSource) {\n      throw new Error(\"A script input had no script source\");\n    }\n    if (!currentTxIn.scriptTxIn.datumSource) {\n      throw new Error(\"A script input had no datum source\");\n    }\n    if (!currentTxIn.scriptTxIn.redeemer) {\n      throw new Error(\"A script input had no redeemer\");\n    }\n    // Handle script info based on whether it's inlined or provided\n    if (currentTxIn.scriptTxIn.scriptSource.type === \"Provided\") {\n      this.addProvidedPlutusScript(currentTxIn.scriptTxIn.scriptSource.script);\n    } else if (currentTxIn.scriptTxIn.scriptSource.type === \"Inline\") {\n      this.addScriptRef(currentTxIn.scriptTxIn.scriptSource);\n    }\n    if (currentTxIn.scriptTxIn.datumSource.type === \"Provided\") {\n      this.datumsProvided.add(\n        fromBuilderToPlutusData(currentTxIn.scriptTxIn.datumSource.data),\n      );\n    } else if (currentTxIn.scriptTxIn.datumSource.type === \"Inline\") {\n      this.addReferenceInput({\n        txHash: currentTxIn.txIn.txHash,\n        txIndex: currentTxIn.txIn.txIndex,\n      });\n    }\n    let exUnits = currentTxIn.scriptTxIn.redeemer.exUnits;\n\n    // Add redeemers to witness set\n    let redeemers = this.txWitnessSet.redeemers() ?? Redeemers.fromCore([]);\n    let redeemersList = [...redeemers.values()];\n    redeemersList.push(\n      new Redeemer(\n        RedeemerTag.Spend,\n        BigInt(index),\n        fromBuilderToPlutusData(currentTxIn.scriptTxIn.redeemer.data),\n        new ExUnits(BigInt(exUnits.mem), BigInt(exUnits.steps)),\n      ),\n    );\n    redeemers.setValues(redeemersList);\n    this.txWitnessSet.setRedeemers(redeemers);\n  };\n\n  private addSimpleScriptTxIn = (\n    currentTxIn: RequiredWith<SimpleScriptTxIn, \"txIn\" | \"simpleScriptTxIn\">,\n  ) => {\n    // we can add the input in first, and handle the script info after\n    this.addTxIn({\n      type: \"PubKey\",\n      txIn: currentTxIn.txIn,\n    });\n    if (!currentTxIn.simpleScriptTxIn.scriptSource) {\n      throw new Error(\"A native script input had no script source\");\n    }\n    if (currentTxIn.simpleScriptTxIn.scriptSource.type === \"Provided\") {\n      this.scriptsProvided.add(\n        Script.newNativeScript(\n          NativeScript.fromCbor(\n            HexBlob(currentTxIn.simpleScriptTxIn.scriptSource.scriptCode),\n          ),\n        ).toCbor(),\n      );\n    } else if (currentTxIn.simpleScriptTxIn.scriptSource.type === \"Inline\") {\n      this.addSimpleScriptRef(currentTxIn.simpleScriptTxIn.scriptSource);\n    }\n  };\n\n  private addAllOutputs = (outputs: Output[]) => {\n    for (let i = 0; i < outputs.length; i++) {\n      this.addOutput(outputs[i]!);\n    }\n  };\n\n  private addOutput = (output: Output) => {\n    const currentOutputs = this.txBody.outputs();\n    currentOutputs.push(this.toCardanoOutput(output));\n    this.txBody.setOutputs(currentOutputs);\n  };\n\n  private toCardanoOutput = (output: Output): TransactionOutput => {\n    let cardanoOutput = new TransactionOutput(\n      toCardanoAddress(output.address),\n      toValue(output.amount),\n    );\n    if (output.datum?.type === \"Hash\") {\n      cardanoOutput.setDatum(\n        Datum.newDataHash(\n          DatumHash(fromBuilderToPlutusData(output.datum.data).hash()),\n        ),\n      );\n    } else if (output.datum?.type === \"Inline\") {\n      cardanoOutput.setDatum(\n        Datum.newInlineData(fromBuilderToPlutusData(output.datum.data)),\n      );\n    } else if (output.datum?.type === \"Embedded\") {\n      // Embedded datums get added to witness set\n      const currentWitnessDatum =\n        this.txWitnessSet.plutusData() ??\n        Serialization.CborSet.fromCore([], Serialization.PlutusData.fromCore);\n      const currentWitnessDatumValues = [...currentWitnessDatum.values()];\n      currentWitnessDatumValues.push(\n        fromBuilderToPlutusData(output.datum.data),\n      );\n      currentWitnessDatum.setValues(currentWitnessDatumValues);\n      this.txWitnessSet.setPlutusData(currentWitnessDatum);\n    }\n    if (output.referenceScript) {\n      switch (output.referenceScript.version) {\n        case \"V1\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV1Script(\n              PlutusV1Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        case \"V2\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV2Script(\n              PlutusV2Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        case \"V3\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV3Script(\n              PlutusV3Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n      }\n    }\n    return cardanoOutput;\n  };\n\n  private addAllReferenceInputs = (refInputs: RefTxIn[]) => {\n    for (let i = 0; i < refInputs.length; i++) {\n      this.addReferenceInput(refInputs[i]!);\n    }\n  };\n\n  private addReferenceInput = (refInput: RefTxIn) => {\n    let referenceInputs =\n      this.txBody.referenceInputs() ??\n      Serialization.CborSet.fromCore([], TransactionInput.fromCore);\n\n    let referenceInputsList = [...referenceInputs.values()];\n\n    if (\n      referenceInputsList.some(\n        (input) =>\n          input.transactionId().toString() === refInput.txHash &&\n          input.index().toString() === refInput.txIndex.toString(),\n      )\n    )\n      return;\n\n    referenceInputsList.push(\n      new TransactionInput(\n        TransactionId(refInput.txHash),\n        BigInt(refInput.txIndex),\n      ),\n    );\n    referenceInputs.setValues(referenceInputsList);\n\n    if (refInput.scriptSize) {\n      this.refScriptSize += refInput.scriptSize;\n    }\n\n    this.txBody.setReferenceInputs(referenceInputs);\n  };\n\n  private addAllMints = (mints: MintParam[]) => {\n    for (let i = 0; i < mints.length; i++) {\n      this.addMint(mints[i]!);\n    }\n    let redeemers = this.txWitnessSet.redeemers() ?? Redeemers.fromCore([]);\n    let redeemersList = [...redeemers.values()];\n    let i = 0;\n    this.mintRedeemers.forEach((redeemer) => {\n      const newRedeemer = new Redeemer(\n        redeemer.tag(),\n        BigInt(i),\n        redeemer.data(),\n        redeemer.exUnits(),\n      );\n      redeemersList.push(newRedeemer);\n      redeemers.setValues(redeemersList);\n      i++;\n    });\n    this.txWitnessSet.setRedeemers(redeemers);\n  };\n\n  private addMint = (mint: MintParam) => {\n    const currentMint: TokenMap = this.txBody.mint() ?? new Map();\n\n    for (const assetValue of mint.mintValue) {\n      const mintAssetId = `${mint.policyId}${assetValue.assetName}`;\n\n      for (const asset of currentMint.keys()) {\n        if (asset.toString() == mintAssetId) {\n          throw new Error(\"The same asset is already in the mint field\");\n        }\n      }\n\n      currentMint.set(\n        AssetId.fromParts(\n          PolicyId(mint.policyId),\n          AssetName(assetValue.assetName),\n        ),\n        BigInt(assetValue.amount),\n      );\n    }\n    this.txBody.setMint(currentMint);\n\n    if (mint.type === \"Native\") {\n      if (!mint.scriptSource)\n        throw new Error(\"Script source not provided for native script mint\");\n      const nativeScriptSource: SimpleScriptSourceInfo =\n        mint.scriptSource as SimpleScriptSourceInfo;\n      if (!nativeScriptSource)\n        throw new Error(\n          \"A script source for a native script was not a native script somehow\",\n        );\n      if (nativeScriptSource.type === \"Provided\") {\n        this.scriptsProvided.add(\n          Script.newNativeScript(\n            NativeScript.fromCbor(HexBlob(nativeScriptSource.scriptCode)),\n          ).toCbor(),\n        );\n      } else if (nativeScriptSource.type === \"Inline\") {\n        this.addSimpleScriptRef(nativeScriptSource);\n      }\n    } else if (mint.type === \"Plutus\") {\n      if (!mint.scriptSource)\n        throw new Error(\"Script source not provided for plutus script mint\");\n      const plutusScriptSource = mint.scriptSource as ScriptSource;\n      if (!plutusScriptSource) {\n        throw new Error(\n          \"A script source for a plutus mint was not plutus script somehow\",\n        );\n      }\n      if (!mint.redeemer) {\n        throw new Error(\"A redeemer was not provided for a plutus mint\");\n      }\n      // Add mint redeemer to mapping\n      const currentRedeemer = new Redeemer(\n        RedeemerTag.Mint,\n        BigInt(0),\n        fromBuilderToPlutusData(mint.redeemer.data),\n        new ExUnits(\n          BigInt(mint.redeemer.exUnits.mem),\n          BigInt(mint.redeemer.exUnits.steps),\n        ),\n      );\n      if (this.mintRedeemers.has(mint.policyId)) {\n        if (\n          this.mintRedeemers.get(mint.policyId)?.toCbor() !==\n          currentRedeemer.toCbor()\n        ) {\n          throw new Error(\n            \"The same minting policy must have the same redeemer\",\n          );\n        }\n      } else {\n        this.mintRedeemers.set(mint.policyId, currentRedeemer);\n      }\n\n      if (plutusScriptSource.type === \"Provided\") {\n        this.addProvidedPlutusScript(plutusScriptSource.script);\n      } else if (plutusScriptSource.type === \"Inline\") {\n        this.addScriptRef(plutusScriptSource);\n      }\n    }\n  };\n\n  private addAllCerts = (certs: Certificate[]) => {\n    for (let i = 0; i < certs.length; i++) {\n      this.addCert(certs[i]!, i);\n    }\n  };\n\n  private addCert = (cert: Certificate, index: number) => {\n    const currentCerts =\n      this.txBody.certs() ??\n      Serialization.CborSet.fromCore([], Serialization.Certificate.fromCore);\n    let currentCertsValues = [...currentCerts.values()];\n    currentCertsValues.push(toCardanoCert(cert.certType));\n    currentCerts.setValues(currentCertsValues);\n    this.txBody.setCerts(currentCerts);\n\n    if (cert.type === \"SimpleScriptCertificate\") {\n      if (!cert.simpleScriptSource)\n        throw new Error(\"Script source not provided for native script cert\");\n      const nativeScriptSource: SimpleScriptSourceInfo =\n        cert.simpleScriptSource as SimpleScriptSourceInfo;\n      if (!nativeScriptSource)\n        throw new Error(\n          \"A script source for a native script was not a native script somehow\",\n        );\n      if (nativeScriptSource.type === \"Provided\") {\n        this.scriptsProvided.add(\n          Script.newNativeScript(\n            NativeScript.fromCbor(HexBlob(nativeScriptSource.scriptCode)),\n          ).toCbor(),\n        );\n      } else if (nativeScriptSource.type === \"Inline\") {\n        this.addSimpleScriptRef(nativeScriptSource);\n      }\n    } else if (cert.type === \"ScriptCertificate\") {\n      if (!cert.scriptSource)\n        throw new Error(\n          \"Script source not provided for plutus script certificate\",\n        );\n      const plutusScriptSource = cert.scriptSource as ScriptSource;\n      if (!plutusScriptSource) {\n        throw new Error(\n          \"A script source for a plutus certificate was not plutus script somehow\",\n        );\n      }\n      if (!cert.redeemer) {\n        throw new Error(\"A redeemer was not provided for a plutus certificate\");\n      }\n\n      // Add cert redeemer to witness set\n      let redeemers = this.txWitnessSet.redeemers() ?? Redeemers.fromCore([]);\n      let redeemersList = [...redeemers.values()];\n      redeemersList.push(\n        new Redeemer(\n          RedeemerTag.Cert,\n          BigInt(index),\n          fromBuilderToPlutusData(cert.redeemer.data),\n          new ExUnits(\n            BigInt(cert.redeemer.exUnits.mem),\n            BigInt(cert.redeemer.exUnits.steps),\n          ),\n        ),\n      );\n      redeemers.setValues(redeemersList);\n      this.txWitnessSet.setRedeemers(redeemers);\n\n      if (plutusScriptSource.type === \"Provided\") {\n        this.addProvidedPlutusScript(plutusScriptSource.script);\n      } else if (plutusScriptSource.type === \"Inline\") {\n        this.addScriptRef(plutusScriptSource);\n      }\n    }\n  };\n\n  private addAllWithdrawals = (withdrawals: Withdrawal[]) => {\n    for (let i = 0; i < withdrawals.length; i++) {\n      this.addWithdrawal(withdrawals[i]!, i);\n    }\n  };\n\n  private addWithdrawal = (withdrawal: Withdrawal, index: number) => {\n    const currentWithdrawals =\n      this.txBody.withdrawals() ?? new Map<RewardAccount, bigint>();\n    const address = toCardanoAddress(withdrawal.address);\n    const rewardAddress = address.asReward();\n    if (!rewardAddress) {\n      throw new Error(\"Failed to parse reward address for withdrawal\");\n    }\n    currentWithdrawals.set(\n      RewardAccount.fromCredential(\n        rewardAddress.getPaymentCredential(),\n        address.getNetworkId(),\n      ),\n      BigInt(withdrawal.coin),\n    );\n    this.txBody.setWithdrawals(currentWithdrawals);\n\n    if (withdrawal.type === \"SimpleScriptWithdrawal\") {\n      if (!withdrawal.scriptSource)\n        throw new Error(\"Script source not provided for native script cert\");\n      const nativeScriptSource: SimpleScriptSourceInfo =\n        withdrawal.scriptSource as SimpleScriptSourceInfo;\n      if (!nativeScriptSource)\n        throw new Error(\n          \"A script source for a native script was not a native script somehow\",\n        );\n      if (nativeScriptSource.type === \"Provided\") {\n        this.scriptsProvided.add(\n          Script.newNativeScript(\n            NativeScript.fromCbor(HexBlob(nativeScriptSource.scriptCode)),\n          ).toCbor(),\n        );\n      } else if (nativeScriptSource.type === \"Inline\") {\n        this.addSimpleScriptRef(nativeScriptSource);\n      }\n    } else if (withdrawal.type === \"ScriptWithdrawal\") {\n      if (!withdrawal.scriptSource)\n        throw new Error(\n          \"Script source not provided for plutus script certificate\",\n        );\n      const plutusScriptSource = withdrawal.scriptSource as ScriptSource;\n      if (!plutusScriptSource) {\n        throw new Error(\n          \"A script source for a plutus certificate was not plutus script somehow\",\n        );\n      }\n      if (!withdrawal.redeemer) {\n        throw new Error(\"A redeemer was not provided for a plutus certificate\");\n      }\n\n      // Add withdraw redeemer to witness set\n      let redeemers = this.txWitnessSet.redeemers() ?? Redeemers.fromCore([]);\n      let redeemersList = [...redeemers.values()];\n      redeemersList.push(\n        new Redeemer(\n          RedeemerTag.Reward,\n          BigInt(index),\n          fromBuilderToPlutusData(withdrawal.redeemer.data),\n          new ExUnits(\n            BigInt(withdrawal.redeemer.exUnits.mem),\n            BigInt(withdrawal.redeemer.exUnits.steps),\n          ),\n        ),\n      );\n      redeemers.setValues(redeemersList);\n      this.txWitnessSet.setRedeemers(redeemers);\n\n      if (plutusScriptSource.type === \"Provided\") {\n        this.addProvidedPlutusScript(plutusScriptSource.script);\n      } else if (plutusScriptSource.type === \"Inline\") {\n        this.addScriptRef(plutusScriptSource);\n      }\n    }\n  };\n\n  private addAllCollateralInputs = (collaterals: PubKeyTxIn[]) => {\n    for (let i = 0; i < collaterals.length; i++) {\n      this.addCollateralInput(\n        collaterals[i] as RequiredWith<PubKeyTxIn, \"txIn\">,\n      );\n    }\n  };\n\n  private addCollateralInput = (\n    collateral: RequiredWith<PubKeyTxIn, \"txIn\">,\n  ) => {\n    // First build Cardano tx in and add it to tx body\n    let cardanoTxIn = new TransactionInput(\n      TransactionId(collateral.txIn.txHash),\n      BigInt(collateral.txIn.txIndex),\n    );\n    const collateralInputs =\n      this.txBody.collateral() ??\n      Serialization.CborSet.fromCore([], TransactionInput.fromCore);\n    const collateralInputsList: TransactionInput[] = [\n      ...collateralInputs.values(),\n    ];\n    if (\n      collateralInputsList.find((input) => {\n        input.index() == cardanoTxIn.index() &&\n          input.transactionId == cardanoTxIn.transactionId;\n      })\n    ) {\n      throw new Error(\"Duplicate input added to tx body\");\n    }\n    collateralInputsList.push(cardanoTxIn);\n    collateralInputs.setValues(collateralInputsList);\n    // We save the output to a mapping so that we can calculate collateral return later\n    // TODO: set collateral return\n    const cardanoTxOut = new TransactionOutput(\n      toCardanoAddress(collateral.txIn.address),\n      toValue(collateral.txIn.amount),\n    );\n    this.utxoContext.set(cardanoTxIn, cardanoTxOut);\n    this.txBody.setCollateral(collateralInputs);\n  };\n\n  private addCollateralReturn = (\n    totalCollateral: string,\n    collaterals: PubKeyTxIn[],\n    collateralReturnAddress: string,\n  ) => {\n    let collateralReturnValue = Value.fromCore({\n      coins: -BigInt(totalCollateral),\n    });\n    for (const collateral of collaterals) {\n      collateralReturnValue = mergeValue(\n        collateralReturnValue,\n        toValue(collateral.txIn.amount!),\n      );\n    }\n    const collateralReturn = new TransactionOutput(\n      toCardanoAddress(collateralReturnAddress),\n      collateralReturnValue,\n    );\n    this.txBody.setCollateralReturn(collateralReturn);\n  };\n\n  private setValidityInterval = (validity: ValidityRange) => {\n    if (validity.invalidBefore) {\n      this.txBody.setValidityStartInterval(Slot(validity.invalidBefore));\n    }\n    if (validity.invalidHereafter) {\n      this.txBody.setTtl(Slot(validity.invalidHereafter));\n    }\n  };\n\n  private setFee = (fee: string) => {\n    this.txBody.setFee(BigInt(fee));\n  };\n\n  private addAllRequiredSignatures = (requiredSignatures: string[]) => {\n    const requiredSigners: Serialization.CborSet<\n      Ed25519KeyHashHex,\n      Serialization.Hash<Ed25519KeyHashHex>\n    > = this.txBody.requiredSigners() ??\n    Serialization.CborSet.fromCore([], Serialization.Hash.fromCore);\n\n    let requiredSignerValues = [...requiredSigners.values()];\n    for (const requiredSigner of requiredSignatures) {\n      requiredSignerValues.push(\n        Serialization.Hash.fromCore(Ed25519KeyHashHex(requiredSigner)),\n      );\n    }\n    requiredSigners.setValues(requiredSignerValues);\n    this.txBody.setRequiredSigners(requiredSigners);\n  };\n\n  private addMetadata = (metadata: TxMetadata) => {\n    this.txAuxilliaryData.setMetadata(\n      new Serialization.GeneralTransactionMetadata(\n        toCardanoMetadataMap(metadata),\n      ),\n    );\n  };\n\n  private createMockedWitnessSet = (\n    requiredSignaturesCount: number,\n    requiredByronSignatures: string[],\n  ): TransactionWitnessSet => {\n    this.buildWitnessSet();\n    const clonedWitnessSet = TransactionWitnessSet.fromCbor(\n      this.txWitnessSet.toCbor(),\n    );\n    const bootstrapWitnesses = this.mockBootstrapWitnesses(\n      requiredByronSignatures,\n    );\n    const vkeyWitnesses = this.mockVkeyWitnesses(requiredSignaturesCount);\n\n    const bootstrapsSet = CborSet.fromCore([], BootstrapWitness.fromCore);\n    bootstrapsSet.setValues(bootstrapWitnesses);\n    clonedWitnessSet.setBootstraps(bootstrapsSet);\n\n    const vkeysSet = CborSet.fromCore([], VkeyWitness.fromCore);\n    vkeysSet.setValues(vkeyWitnesses);\n    clonedWitnessSet.setVkeys(vkeysSet);\n\n    return clonedWitnessSet;\n  };\n\n  private buildWitnessSet = () => {\n    // Add provided scripts to tx witness set\n    let nativeScripts =\n      this.txWitnessSet.nativeScripts() ??\n      Serialization.CborSet.fromCore([], NativeScript.fromCore);\n\n    let v1Scripts =\n      this.txWitnessSet.plutusV1Scripts() ??\n      Serialization.CborSet.fromCore([], PlutusV1Script.fromCore);\n\n    let v2Scripts =\n      this.txWitnessSet.plutusV2Scripts() ??\n      Serialization.CborSet.fromCore([], PlutusV2Script.fromCore);\n\n    let v3Scripts =\n      this.txWitnessSet.plutusV3Scripts() ??\n      Serialization.CborSet.fromCore([], PlutusV3Script.fromCore);\n\n    this.scriptsProvided.forEach((scriptHex) => {\n      const script = Script.fromCbor(HexBlob(scriptHex));\n      if (script.asNative() !== undefined) {\n        let nativeScriptsList = [...nativeScripts.values()];\n        nativeScriptsList.push(script.asNative()!);\n        nativeScripts.setValues(nativeScriptsList);\n      } else if (script.asPlutusV1() !== undefined) {\n        let v1ScriptsList = [...v1Scripts.values()];\n        v1ScriptsList.push(script.asPlutusV1()!);\n        v1Scripts.setValues(v1ScriptsList);\n      } else if (script.asPlutusV2() !== undefined) {\n        let v2ScriptsList = [...v2Scripts.values()];\n        v2ScriptsList.push(script.asPlutusV2()!);\n        v2Scripts.setValues(v2ScriptsList);\n      } else if (script.asPlutusV3() !== undefined) {\n        let v3ScriptsList = [...v3Scripts.values()];\n        v3ScriptsList.push(script.asPlutusV3()!);\n        v3Scripts.setValues(v3ScriptsList);\n      }\n\n      this.txWitnessSet.setNativeScripts(nativeScripts);\n      this.txWitnessSet.setPlutusV1Scripts(v1Scripts);\n      this.txWitnessSet.setPlutusV2Scripts(v2Scripts);\n      this.txWitnessSet.setPlutusV3Scripts(v3Scripts);\n    });\n\n    // Add provided datums to tx witness set\n    let datums =\n      this.txWitnessSet.plutusData() ??\n      Serialization.CborSet.fromCore([], PlutusData.fromCore);\n\n    let datumsList = [...datums.values()];\n    this.datumsProvided.forEach((datum) => {\n      datumsList.push(datum);\n    });\n    datums.setValues(datumsList);\n    this.txWitnessSet.setPlutusData(datums);\n\n    // After building tx witness set, we must hash it with the cost models\n    // and put the hash in the tx body\n    let costModelV1 = Serialization.CostModel.newPlutusV1(\n      DEFAULT_V1_COST_MODEL_LIST,\n    );\n    let costModelV2 = Serialization.CostModel.newPlutusV2(\n      DEFAULT_V2_COST_MODEL_LIST,\n    );\n    let costModelV3 = Serialization.CostModel.newPlutusV3(\n      DEFAULT_V3_COST_MODEL_LIST,\n    );\n    let costModels = new Serialization.Costmdls();\n\n    if (this.usedLanguages[PlutusLanguageVersion.V1]) {\n      costModels.insert(costModelV1);\n    }\n    if (this.usedLanguages[PlutusLanguageVersion.V2]) {\n      costModels.insert(costModelV2);\n    }\n    if (this.usedLanguages[PlutusLanguageVersion.V3]) {\n      costModels.insert(costModelV3);\n    }\n    const redeemers = this.txWitnessSet.redeemers() ?? Redeemers.fromCore([]);\n    let scriptDataHash = hashScriptData(\n      costModels,\n      redeemers,\n      datums.size() > 0 ? datums : undefined,\n    );\n    if (scriptDataHash) {\n      this.txBody.setScriptDataHash(scriptDataHash);\n    }\n    let auxiliaryDataHash = computeAuxiliaryDataHash(\n      this.txAuxilliaryData.toCore(),\n    );\n    if (auxiliaryDataHash) {\n      this.txBody.setAuxiliaryDataHash(auxiliaryDataHash);\n    }\n  };\n\n  private removeInputRefInputOverlap = () => {\n    let refInputsValues: TransactionInput[] = [];\n    const inputs = this.txBody.inputs()?.values();\n    if (this.txBody.referenceInputs()) {\n      const currentRefInputValues = this.txBody.referenceInputs()!.values();\n      currentRefInputValues.forEach((refInput) => {\n        let found = false;\n        for (let i = 0; i < inputs.length; i++) {\n          if (refInput.toCbor() === inputs[i]!.toCbor()) {\n            found = true;\n          }\n        }\n        if (!found) {\n          refInputsValues.push(refInput);\n        }\n      });\n      this.txBody.setReferenceInputs(\n        Serialization.CborSet.fromCore(\n          refInputsValues.map((input) => input.toCore()),\n          TransactionInput.fromCore,\n        ),\n      );\n    }\n  };\n\n  private removeBodyInputRefInputOverlap = (\n    inputs: TxIn[],\n    refInputs: RefTxIn[],\n  ) => {\n    let finalRefInputs = [];\n    for (let i = 0; i < refInputs.length; i++) {\n      let refInput = refInputs[i]!;\n      if (\n        !inputs.some(\n          (input) =>\n            input.txIn.txHash === refInput.txHash &&\n            input.txIn.txIndex === refInput.txIndex,\n        )\n      ) {\n        finalRefInputs.push(refInput);\n      }\n    }\n    return finalRefInputs;\n  };\n\n  private addScriptRef = (scriptSource: ScriptSource): void => {\n    if (scriptSource.type !== \"Inline\") {\n      return;\n    }\n    if (!scriptSource.scriptSize) {\n      throw new Error(\n        \"A reference script was used without providing its size, this must be provided as fee calculations are based on it\",\n      );\n    }\n    this.addReferenceInput({\n      txHash: scriptSource.txHash,\n      txIndex: scriptSource.txIndex,\n      scriptSize: Number(scriptSource.scriptSize),\n    });\n    switch (scriptSource.version) {\n      case \"V1\": {\n        this.usedLanguages[PlutusLanguageVersion.V1] = true;\n        break;\n      }\n      case \"V2\": {\n        this.usedLanguages[PlutusLanguageVersion.V2] = true;\n        break;\n      }\n      case \"V3\": {\n        this.usedLanguages[PlutusLanguageVersion.V3] = true;\n        break;\n      }\n    }\n  };\n\n  private addSimpleScriptRef = (\n    simpleScriptSource: SimpleScriptSourceInfo,\n  ): void => {\n    if (simpleScriptSource.type !== \"Inline\") {\n      return;\n    }\n    if (!simpleScriptSource.scriptSize) {\n      throw new Error(\n        \"A reference script was used without providing its size, this must be provided as fee calculations are based on it\",\n      );\n    }\n    this.addReferenceInput({\n      txHash: simpleScriptSource.txHash,\n      txIndex: simpleScriptSource.txIndex,\n      scriptSize: Number(simpleScriptSource.scriptSize),\n    });\n  };\n\n  private addProvidedPlutusScript = (script: PlutusScript) => {\n    switch (script.version) {\n      case \"V1\": {\n        this.scriptsProvided.add(\n          Script.newPlutusV1Script(\n            PlutusV1Script.fromCbor(HexBlob(script.code)),\n          ).toCbor(),\n        );\n        this.usedLanguages[PlutusLanguageVersion.V1] = true;\n        break;\n      }\n      case \"V2\": {\n        this.scriptsProvided.add(\n          Script.newPlutusV2Script(\n            PlutusV2Script.fromCbor(HexBlob(script.code)),\n          ).toCbor(),\n        );\n        this.usedLanguages[PlutusLanguageVersion.V2] = true;\n        break;\n      }\n      case \"V3\": {\n        this.scriptsProvided.add(\n          Script.newPlutusV3Script(\n            PlutusV3Script.fromCbor(HexBlob(script.code)),\n          ).toCbor(),\n        );\n        this.usedLanguages[PlutusLanguageVersion.V3] = true;\n        break;\n      }\n    }\n  };\n\n  private addAllVotes = (votes: Vote[]) => {\n    for (let i = 0; i < votes.length; i++) {\n      const vote = votes[i];\n      switch (vote!.type) {\n        case \"BasicVote\": {\n          this.addBasicVote(vote as BasicVote);\n          break;\n        }\n        case \"ScriptVote\": {\n          this.addScriptVote(vote as ScriptVote, i);\n          break;\n        }\n        case \"SimpleScriptVote\": {\n          this.addSimpleScriptVote(vote as SimpleScriptVote);\n          break;\n        }\n      }\n    }\n  };\n\n  private addBasicVote = (basicVote: BasicVote) => {\n    const votes: Serialization.VotingProcedures =\n      this.txBody.votingProcedures() ??\n      Serialization.VotingProcedures.fromCore([]);\n\n    votes.insert(\n      toCardanoVoter(basicVote.vote.voter),\n      toCardanoGovernanceActionId(basicVote.vote.govActionId),\n      toCardanoVotingProcedure(basicVote.vote.votingProcedure),\n    );\n    this.txBody.setVotingProcedures(votes);\n  };\n\n  private addScriptVote = (vote: ScriptVote, index: number) => {\n    if (!vote.scriptSource)\n      throw new Error(\"Script source not provided for plutus script vote\");\n    const plutusScriptSource = vote.scriptSource as ScriptSource;\n    if (!plutusScriptSource) {\n      throw new Error(\n        \"A script source for a plutus certificate was not plutus script somehow\",\n      );\n    }\n    if (!vote.redeemer) {\n      throw new Error(\"A redeemer was not provided for a plutus vote\");\n    }\n\n    // Add withdraw redeemer to witness set\n    let redeemers = this.txWitnessSet.redeemers() ?? Redeemers.fromCore([]);\n    let redeemersList = [...redeemers.values()];\n    redeemersList.push(\n      new Redeemer(\n        RedeemerTag.Voting,\n        BigInt(index),\n        fromBuilderToPlutusData(vote.redeemer.data),\n        new ExUnits(\n          BigInt(vote.redeemer.exUnits.mem),\n          BigInt(vote.redeemer.exUnits.steps),\n        ),\n      ),\n    );\n    redeemers.setValues(redeemersList);\n    this.txWitnessSet.setRedeemers(redeemers);\n\n    if (plutusScriptSource.type === \"Provided\") {\n      this.addProvidedPlutusScript(plutusScriptSource.script);\n    } else if (plutusScriptSource.type === \"Inline\") {\n      this.addScriptRef(plutusScriptSource);\n    }\n    this.addBasicVote({ type: \"BasicVote\", vote: vote.vote });\n  };\n\n  private addSimpleScriptVote = (vote: SimpleScriptVote) => {\n    if (!vote.simpleScriptSource)\n      throw new Error(\"Script source not provided for native script vote\");\n    const nativeScriptSource: SimpleScriptSourceInfo =\n      vote.simpleScriptSource as SimpleScriptSourceInfo;\n    if (!nativeScriptSource)\n      throw new Error(\n        \"A script source for a native script was not a native script somehow\",\n      );\n    if (nativeScriptSource.type === \"Provided\") {\n      this.scriptsProvided.add(\n        Script.newNativeScript(\n          NativeScript.fromCbor(HexBlob(nativeScriptSource.scriptCode)),\n        ).toCbor(),\n      );\n    } else if (nativeScriptSource.type === \"Inline\") {\n      this.addSimpleScriptRef(nativeScriptSource);\n    }\n    this.addBasicVote({ type: \"BasicVote\", vote: vote.vote });\n  };\n\n  private mockVkeyWitnesses = (\n    numberOfRequiredWitnesses: number,\n  ): VkeyWitness[] => {\n    let vkeyWitnesses: VkeyWitness[] = [];\n    for (let i = 0; i < numberOfRequiredWitnesses; i++) {\n      const numberInHex = this.numberToIntegerHex(i);\n      const pubKeyHex = this.mockPubkey(numberInHex);\n      const signature = this.mockSignature(numberInHex);\n      vkeyWitnesses.push(\n        new VkeyWitness(\n          Ed25519PublicKeyHex(pubKeyHex),\n          Ed25519SignatureHex(signature),\n        ),\n      );\n    }\n    return vkeyWitnesses;\n  };\n\n  private mockPubkey(numberInHex: string): string {\n    return \"0\"\n      .repeat(VKEY_PUBKEY_SIZE_BYTES * 2 - numberInHex.length)\n      .concat(numberInHex);\n  }\n\n  private mockSignature(numberInHex: string): string {\n    return \"0\"\n      .repeat(VKEY_SIGNATURE_SIZE_BYTES * 2 - numberInHex.length)\n      .concat(numberInHex);\n  }\n\n  private mockChainCode = (numberInHex: string): string => {\n    return \"0\"\n      .repeat(CHAIN_CODE_SIZE_BYTES * 2 - numberInHex.length)\n      .concat(numberInHex);\n  };\n\n  private numberToIntegerHex = (number: number): string => {\n    return BigInt(number).toString(16);\n  };\n\n  private mockBootstrapWitnesses = (\n    byronAddresses: string[],\n  ): BootstrapWitness[] => {\n    let bootstrapWitnesses: BootstrapWitness[] = [];\n    for (let i = 0; i < byronAddresses.length; i++) {\n      const address = Address.fromBytes(<HexBlob>byronAddresses[i]).asByron();\n      if (!address) {\n        throw new Error(`Failed to parse byron address: ${byronAddresses[i]}`);\n      }\n      const numberInHex = this.numberToIntegerHex(i);\n      const pubKeyHex = this.mockPubkey(numberInHex);\n      const signature = this.mockSignature(numberInHex);\n      const chainCode = this.mockChainCode(numberInHex);\n      const attributes = address.getAttributes();\n      bootstrapWitnesses.push(\n        new BootstrapWitness(\n          Ed25519PublicKeyHex(pubKeyHex),\n          Ed25519SignatureHex(signature),\n          HexBlob(chainCode),\n          this.serializeByronAttributes(attributes),\n        ),\n      );\n    }\n    return bootstrapWitnesses;\n  };\n\n  private serializeByronAttributes = (attributes: ByronAttributes): HexBlob => {\n    const writer = new CborWriter();\n    let mapSize = 0;\n    if (attributes.magic) {\n      mapSize++;\n    }\n    if (attributes.derivationPath) {\n      mapSize++;\n    }\n\n    writer.writeStartMap(mapSize);\n    if (attributes.derivationPath) {\n      writer.writeInt(1);\n      const encodedPathCbor = new CborWriter()\n        .writeByteString(Buffer.from(attributes.derivationPath, \"hex\"))\n        .encode();\n      writer.writeByteString(encodedPathCbor);\n    }\n    if (attributes.magic) {\n      writer.writeInt(2);\n      const encodedMagicCbor = new CborWriter()\n        .writeInt(attributes.magic)\n        .encode();\n      writer.writeByteString(encodedMagicCbor);\n    }\n    return writer.encodeAsHex();\n  };\n}\n\nconst throwErrorWithOrigin = (origin: string, error: any) => {\n  if (error instanceof Error) {\n    throw new Error(`${origin}: ${error.message}`);\n  } else if (typeof error === \"string\") {\n    throw new Error(`${origin}: ${error}`);\n  } else if (typeof error === \"object\") {\n    throw new Error(`${origin}: ${JSON.stringify(error)}`);\n  } else {\n    throw new Error(`${origin}: ${String(error)}`);\n  }\n};\n",
      "dependencies": [
        "CardanoSDKSerializer"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "name": "types.cardano-sdk.ts",
      "imports": [
        {
          "module": "Slot",
          "items": [],
          "line": 6,
          "raw": "export const Slot = Cardano.Slot;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Slot",
          "items": [],
          "line": 7,
          "raw": "export type Slot = Cardano.Slot;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Value",
          "items": [],
          "line": 9,
          "raw": "export const Value = Serialization.Value;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Value",
          "items": [],
          "line": 10,
          "raw": "export type Value = Serialization.Value;",
          "source": "mesh-core-cst"
        },
        {
          "module": "TokenMap",
          "items": [],
          "line": 12,
          "raw": "export type TokenMap = Cardano.TokenMap;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Transaction",
          "items": [],
          "line": 14,
          "raw": "export const Transaction = Serialization.Transaction;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Transaction",
          "items": [],
          "line": 15,
          "raw": "export type Transaction = Serialization.Transaction;",
          "source": "mesh-core-cst"
        },
        {
          "module": "TransactionId",
          "items": [],
          "line": 17,
          "raw": "export const TransactionId = (value: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "TransactionId",
          "items": [],
          "line": 20,
          "raw": "export type TransactionId = Cardano.TransactionId;",
          "source": "mesh-core-cst"
        },
        {
          "module": "TransactionBody",
          "items": [],
          "line": 22,
          "raw": "export const TransactionBody = Serialization.TransactionBody;",
          "source": "mesh-core-cst"
        },
        {
          "module": "TransactionBody",
          "items": [],
          "line": 23,
          "raw": "export type TransactionBody = Serialization.TransactionBody;",
          "source": "mesh-core-cst"
        },
        {
          "module": "TransactionWitnessSet",
          "items": [],
          "line": 25,
          "raw": "export const TransactionWitnessSet = Serialization.TransactionWitnessSet;",
          "source": "mesh-core-cst"
        },
        {
          "module": "TransactionWitnessSet",
          "items": [],
          "line": 26,
          "raw": "export type TransactionWitnessSet = Serialization.TransactionWitnessSet;",
          "source": "mesh-core-cst"
        },
        {
          "module": "AuxilliaryData",
          "items": [],
          "line": 28,
          "raw": "export const AuxilliaryData = Serialization.AuxiliaryData;",
          "source": "mesh-core-cst"
        },
        {
          "module": "AuxiliaryData",
          "items": [],
          "line": 29,
          "raw": "export type AuxiliaryData = Serialization.AuxiliaryData;",
          "source": "mesh-core-cst"
        },
        {
          "module": "TransactionMetadatum",
          "items": [],
          "line": 31,
          "raw": "export const TransactionMetadatum = Serialization.TransactionMetadatum;",
          "source": "mesh-core-cst"
        },
        {
          "module": "TransactionMetadatum",
          "items": [],
          "line": 32,
          "raw": "export type TransactionMetadatum = Serialization.TransactionMetadatum;",
          "source": "mesh-core-cst"
        },
        {
          "module": "MetadatumMap",
          "items": [],
          "line": 34,
          "raw": "export const MetadatumMap = Serialization.MetadatumMap;",
          "source": "mesh-core-cst"
        },
        {
          "module": "MetadatumMap",
          "items": [],
          "line": 35,
          "raw": "export type MetadatumMap = Serialization.MetadatumMap;",
          "source": "mesh-core-cst"
        },
        {
          "module": "MetadatumList",
          "items": [],
          "line": 37,
          "raw": "export const MetadatumList = Serialization.MetadatumList;",
          "source": "mesh-core-cst"
        },
        {
          "module": "MetadatumList",
          "items": [],
          "line": 38,
          "raw": "export type MetadatumList = Serialization.MetadatumList;",
          "source": "mesh-core-cst"
        },
        {
          "module": "TransactionUnspentOutput",
          "items": [],
          "line": 40,
          "raw": "export const TransactionUnspentOutput = Serialization.TransactionUnspentOutput;",
          "source": "mesh-core-cst"
        },
        {
          "module": "TransactionUnspentOutput",
          "items": [],
          "line": 41,
          "raw": "export type TransactionUnspentOutput = Serialization.TransactionUnspentOutput;",
          "source": "mesh-core-cst"
        },
        {
          "module": "TransactionInput",
          "items": [],
          "line": 43,
          "raw": "export const TransactionInput = Serialization.TransactionInput;",
          "source": "mesh-core-cst"
        },
        {
          "module": "TransactionInput",
          "items": [],
          "line": 44,
          "raw": "export type TransactionInput = Serialization.TransactionInput;",
          "source": "mesh-core-cst"
        },
        {
          "module": "TransactionOutput",
          "items": [],
          "line": 46,
          "raw": "export const TransactionOutput = Serialization.TransactionOutput;",
          "source": "mesh-core-cst"
        },
        {
          "module": "TransactionOutput",
          "items": [],
          "line": 47,
          "raw": "export type TransactionOutput = Serialization.TransactionOutput;",
          "source": "mesh-core-cst"
        },
        {
          "module": "TransactionInputSet",
          "items": [],
          "line": 49,
          "raw": "export type TransactionInputSet = Serialization.CborSet<",
          "source": "mesh-core-cst"
        },
        {
          "module": "TransactionWitnessPlutusData",
          "items": [],
          "line": 54,
          "raw": "export type TransactionWitnessPlutusData = Set<PlutusData>;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PlutusData",
          "items": [],
          "line": 56,
          "raw": "export const PlutusData = Serialization.PlutusData;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PlutusData",
          "items": [],
          "line": 57,
          "raw": "export type PlutusData = Serialization.PlutusData;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PlutusList",
          "items": [],
          "line": 59,
          "raw": "export const PlutusList = Serialization.PlutusList;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PlutusList",
          "items": [],
          "line": 60,
          "raw": "export type PlutusList = Serialization.PlutusList;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PlutusMap",
          "items": [],
          "line": 62,
          "raw": "export const PlutusMap = Serialization.PlutusMap;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PlutusMap",
          "items": [],
          "line": 63,
          "raw": "export type PlutusMap = Serialization.PlutusMap;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Redeemers",
          "items": [],
          "line": 65,
          "raw": "export const Redeemers = Serialization.Redeemers;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Redeemers",
          "items": [],
          "line": 66,
          "raw": "export type Redeemers = Serialization.Redeemers;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Redeemer",
          "items": [],
          "line": 68,
          "raw": "export const Redeemer = Serialization.Redeemer;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Redeemer",
          "items": [],
          "line": 69,
          "raw": "export type Redeemer = Serialization.Redeemer;",
          "source": "mesh-core-cst"
        },
        {
          "module": "RedeemerPurpose",
          "items": [],
          "line": 71,
          "raw": "export const RedeemerPurpose = Cardano.RedeemerPurpose;",
          "source": "mesh-core-cst"
        },
        {
          "module": "RedeemerPurpose",
          "items": [],
          "line": 72,
          "raw": "export type RedeemerPurpose = Cardano.RedeemerPurpose;",
          "source": "mesh-core-cst"
        },
        {
          "module": "RedeemerTag",
          "items": [],
          "line": 74,
          "raw": "export const RedeemerTag = Serialization.RedeemerTag;",
          "source": "mesh-core-cst"
        },
        {
          "module": "RedeemerTag",
          "items": [],
          "line": 75,
          "raw": "export type RedeemerTag = Serialization.RedeemerTag;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Script",
          "items": [],
          "line": 77,
          "raw": "export const Script = Serialization.Script;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Script",
          "items": [],
          "line": 78,
          "raw": "export type Script = Serialization.Script;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PolicyId",
          "items": [],
          "line": 80,
          "raw": "export const PolicyId = Cardano.PolicyId;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PolicyId",
          "items": [],
          "line": 81,
          "raw": "export type PolicyId = Cardano.PolicyId;",
          "source": "mesh-core-cst"
        },
        {
          "module": "AssetName",
          "items": [],
          "line": 83,
          "raw": "export const AssetName = Cardano.AssetName;",
          "source": "mesh-core-cst"
        },
        {
          "module": "AssetName",
          "items": [],
          "line": 84,
          "raw": "export type AssetName = Cardano.AssetName;",
          "source": "mesh-core-cst"
        },
        {
          "module": "AssetId",
          "items": [],
          "line": 86,
          "raw": "export const AssetId = Cardano.AssetId;",
          "source": "mesh-core-cst"
        },
        {
          "module": "AssetId",
          "items": [],
          "line": 87,
          "raw": "export type AssetId = Cardano.AssetId;",
          "source": "mesh-core-cst"
        },
        {
          "module": "ScriptHash",
          "items": [],
          "line": 89,
          "raw": "export const ScriptHash = Crypto.Hash28ByteBase16;",
          "source": "mesh-core-cst"
        },
        {
          "module": "ScriptHash",
          "items": [],
          "line": 90,
          "raw": "export type ScriptHash = Crypto.Hash28ByteBase16;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Address",
          "items": [],
          "line": 92,
          "raw": "export const Address = Cardano.Address;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Address",
          "items": [],
          "line": 93,
          "raw": "export type Address = Cardano.Address;",
          "source": "mesh-core-cst"
        },
        {
          "module": "RewardAddress",
          "items": [],
          "line": 95,
          "raw": "export const RewardAddress = Cardano.RewardAddress;",
          "source": "mesh-core-cst"
        },
        {
          "module": "RewardAddress",
          "items": [],
          "line": 96,
          "raw": "export type RewardAddress = Cardano.RewardAddress;",
          "source": "mesh-core-cst"
        },
        {
          "module": "AddressType",
          "items": [],
          "line": 98,
          "raw": "export const AddressType = Cardano.AddressType;",
          "source": "mesh-core-cst"
        },
        {
          "module": "AddressType",
          "items": [],
          "line": 99,
          "raw": "export type AddressType = Cardano.AddressType;",
          "source": "mesh-core-cst"
        },
        {
          "module": "BaseAddress",
          "items": [],
          "line": 101,
          "raw": "export const BaseAddress = Cardano.BaseAddress;",
          "source": "mesh-core-cst"
        },
        {
          "module": "BaseAddress",
          "items": [],
          "line": 102,
          "raw": "export type BaseAddress = Cardano.BaseAddress;",
          "source": "mesh-core-cst"
        },
        {
          "module": "EnterpriseAddress",
          "items": [],
          "line": 104,
          "raw": "export const EnterpriseAddress = Cardano.EnterpriseAddress;",
          "source": "mesh-core-cst"
        },
        {
          "module": "EnterpriseAddress",
          "items": [],
          "line": 105,
          "raw": "export type EnterpriseAddress = Cardano.EnterpriseAddress;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PaymentAddress",
          "items": [],
          "line": 107,
          "raw": "export const PaymentAddress = Cardano.PaymentAddress;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PaymentAddress",
          "items": [],
          "line": 108,
          "raw": "export type PaymentAddress = Cardano.PaymentAddress;",
          "source": "mesh-core-cst"
        },
        {
          "module": "AssetFingerprint",
          "items": [],
          "line": 110,
          "raw": "export const AssetFingerprint = Cardano.AssetFingerprint;",
          "source": "mesh-core-cst"
        },
        {
          "module": "AssetFingerprint",
          "items": [],
          "line": 111,
          "raw": "export type AssetFingerprint = Cardano.AssetFingerprint;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Credential",
          "items": [],
          "line": 113,
          "raw": "export const Credential = Serialization.Credential;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Credential",
          "items": [],
          "line": 114,
          "raw": "export type Credential = Serialization.Credential;",
          "source": "mesh-core-cst"
        },
        {
          "module": "CredentialCore",
          "items": [],
          "line": 116,
          "raw": "export type CredentialCore = Cardano.Credential;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Ed25519PublicKeyHex",
          "items": [],
          "line": 118,
          "raw": "export const Ed25519PublicKeyHex = Crypto.Ed25519PublicKeyHex;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Ed25519PublicKeyHex",
          "items": [],
          "line": 119,
          "raw": "export type Ed25519PublicKeyHex = Crypto.Ed25519PublicKeyHex;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Ed25519PrivateNormalKeyHex",
          "items": [],
          "line": 121,
          "raw": "export type Ed25519PrivateNormalKeyHex = OpaqueString<\"Ed25519PrivateKeyHex\">;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Ed25519PrivateNormalKeyHex",
          "items": [],
          "line": 122,
          "raw": "export const Ed25519PrivateNormalKeyHex = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "Ed25519PrivateExtendedKeyHex",
          "items": [],
          "line": 126,
          "raw": "export type Ed25519PrivateExtendedKeyHex = OpaqueString<\"Ed25519PrivateKeyHex\">;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Ed25519PrivateExtendedKeyHex",
          "items": [],
          "line": 127,
          "raw": "export const Ed25519PrivateExtendedKeyHex = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "Ed25519KeyHash",
          "items": [],
          "line": 131,
          "raw": "export const Ed25519KeyHash = Crypto.Ed25519KeyHash;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Ed25519KeyHash",
          "items": [],
          "line": 132,
          "raw": "export type Ed25519KeyHash = Crypto.Ed25519KeyHash;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Ed25519KeyHashHex",
          "items": [],
          "line": 134,
          "raw": "export const Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Ed25519KeyHashHex",
          "items": [],
          "line": 135,
          "raw": "export type Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Hash28ByteBase16",
          "items": [],
          "line": 137,
          "raw": "export const Hash28ByteBase16 = Crypto.Hash28ByteBase16;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Hash28ByteBase16",
          "items": [],
          "line": 138,
          "raw": "export type Hash28ByteBase16 = Crypto.Hash28ByteBase16;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Hash32ByteBase16",
          "items": [],
          "line": 140,
          "raw": "export const Hash32ByteBase16 = (value: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "Hash32ByteBase16",
          "items": [],
          "line": 143,
          "raw": "export type Hash32ByteBase16 = Crypto.Hash32ByteBase16;",
          "source": "mesh-core-cst"
        },
        {
          "module": "CredentialType",
          "items": [],
          "line": 145,
          "raw": "export const CredentialType = Cardano.CredentialType;",
          "source": "mesh-core-cst"
        },
        {
          "module": "CredentialType",
          "items": [],
          "line": 146,
          "raw": "export type CredentialType = Cardano.CredentialType;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Certificate",
          "items": [],
          "line": 148,
          "raw": "export const Certificate = Serialization.Certificate;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Certificate",
          "items": [],
          "line": 149,
          "raw": "export type Certificate = Serialization.Certificate;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PoolId",
          "items": [],
          "line": 151,
          "raw": "export const PoolId = Cardano.PoolId;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PoolId",
          "items": [],
          "line": 152,
          "raw": "export type PoolId = Cardano.PoolId;",
          "source": "mesh-core-cst"
        },
        {
          "module": "StakeRegistration",
          "items": [],
          "line": 154,
          "raw": "export const StakeRegistration = Serialization.StakeRegistration;",
          "source": "mesh-core-cst"
        },
        {
          "module": "StakeRegistration",
          "items": [],
          "line": 155,
          "raw": "export type StakeRegistration = Serialization.StakeRegistration;",
          "source": "mesh-core-cst"
        },
        {
          "module": "StakeDelegation",
          "items": [],
          "line": 157,
          "raw": "export const StakeDelegation = Serialization.StakeDelegation;",
          "source": "mesh-core-cst"
        },
        {
          "module": "StakeDelegation",
          "items": [],
          "line": 158,
          "raw": "export type StakeDelegation = Serialization.StakeDelegation;",
          "source": "mesh-core-cst"
        },
        {
          "module": "StakeDelegationCertificate",
          "items": [],
          "line": 160,
          "raw": "export type StakeDelegationCertificate = Cardano.StakeDelegationCertificate;",
          "source": "mesh-core-cst"
        },
        {
          "module": "CertificateType",
          "items": [],
          "line": 162,
          "raw": "export const CertificateType = Cardano.CertificateType;",
          "source": "mesh-core-cst"
        },
        {
          "module": "CertificateType",
          "items": [],
          "line": 163,
          "raw": "export type CertificateType = Cardano.CertificateType;",
          "source": "mesh-core-cst"
        },
        {
          "module": "VkeyWitness",
          "items": [],
          "line": 165,
          "raw": "export const VkeyWitness = Serialization.VkeyWitness;",
          "source": "mesh-core-cst"
        },
        {
          "module": "VkeyWitness",
          "items": [],
          "line": 166,
          "raw": "export type VkeyWitness = Serialization.VkeyWitness;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Ed25519SignatureHex",
          "items": [],
          "line": 168,
          "raw": "export const Ed25519SignatureHex = Crypto.Ed25519SignatureHex;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Ed25519SignatureHex",
          "items": [],
          "line": 169,
          "raw": "export type Ed25519SignatureHex = Crypto.Ed25519SignatureHex;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Ed25519PublicKey",
          "items": [],
          "line": 171,
          "raw": "export const Ed25519PublicKey = Crypto.Ed25519PublicKey;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Ed25519PublicKey",
          "items": [],
          "line": 172,
          "raw": "export type Ed25519PublicKey = Crypto.Ed25519PublicKey;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Ed25519Signature",
          "items": [],
          "line": 174,
          "raw": "export const Ed25519Signature = Crypto.Ed25519Signature;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Ed25519Signature",
          "items": [],
          "line": 175,
          "raw": "export type Ed25519Signature = Crypto.Ed25519Signature;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Bip32PrivateKey",
          "items": [],
          "line": 177,
          "raw": "export const Bip32PrivateKey = Crypto.Bip32PrivateKey;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Bip32PrivateKey",
          "items": [],
          "line": 178,
          "raw": "export type Bip32PrivateKey = Crypto.Bip32PrivateKey;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Bip32PrivateKeyHex",
          "items": [],
          "line": 180,
          "raw": "export const Bip32PrivateKeyHex = Crypto.Bip32PrivateKeyHex;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Bip32PrivateKeyHex",
          "items": [],
          "line": 181,
          "raw": "export type Bip32PrivateKeyHex = Crypto.Bip32PrivateKeyHex;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Bip32PublicKey",
          "items": [],
          "line": 183,
          "raw": "export const Bip32PublicKey = Crypto.Bip32PublicKey;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Bip32PublicKey",
          "items": [],
          "line": 184,
          "raw": "export type Bip32PublicKey = Crypto.Bip32PublicKey;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Bip32PublicKeyHex",
          "items": [],
          "line": 186,
          "raw": "export const Bip32PublicKeyHex = Crypto.Bip32PublicKeyHex;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Bip32PublicKeyHex",
          "items": [],
          "line": 187,
          "raw": "export type Bip32PublicKeyHex = Crypto.Bip32PublicKeyHex;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PlutusLanguageVersion",
          "items": [],
          "line": 189,
          "raw": "export const PlutusLanguageVersion = Cardano.PlutusLanguageVersion;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PlutusLanguageVersion",
          "items": [],
          "line": 190,
          "raw": "export type PlutusLanguageVersion = Cardano.PlutusLanguageVersion;",
          "source": "mesh-core-cst"
        },
        {
          "module": "NativeScript",
          "items": [],
          "line": 192,
          "raw": "export const NativeScript = Serialization.NativeScript;",
          "source": "mesh-core-cst"
        },
        {
          "module": "NativeScript",
          "items": [],
          "line": 193,
          "raw": "export type NativeScript = Serialization.NativeScript;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PlutusV1Script",
          "items": [],
          "line": 195,
          "raw": "export const PlutusV1Script = Serialization.PlutusV1Script;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PlutusV1Script",
          "items": [],
          "line": 196,
          "raw": "export type PlutusV1Script = Serialization.PlutusV1Script;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PlutusV2Script",
          "items": [],
          "line": 198,
          "raw": "export const PlutusV2Script = Serialization.PlutusV2Script;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PlutusV2Script",
          "items": [],
          "line": 199,
          "raw": "export type PlutusV2Script = Serialization.PlutusV2Script;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PlutusV3Script",
          "items": [],
          "line": 201,
          "raw": "export const PlutusV3Script = Serialization.PlutusV3Script;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PlutusV3Script",
          "items": [],
          "line": 202,
          "raw": "export type PlutusV3Script = Serialization.PlutusV3Script;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PlutusDataKind",
          "items": [],
          "line": 204,
          "raw": "export const PlutusDataKind = Serialization.PlutusDataKind;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PlutusDataKind",
          "items": [],
          "line": 205,
          "raw": "export type PlutusDataKind = Serialization.PlutusDataKind;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PointerAddress",
          "items": [],
          "line": 207,
          "raw": "export const PointerAddress = Cardano.PointerAddress;",
          "source": "mesh-core-cst"
        },
        {
          "module": "PointerAddress",
          "items": [],
          "line": 208,
          "raw": "export type PointerAddress = Cardano.PointerAddress;",
          "source": "mesh-core-cst"
        },
        {
          "module": "CertIndex",
          "items": [],
          "line": 210,
          "raw": "export const CertIndex = Cardano.CertIndex;",
          "source": "mesh-core-cst"
        },
        {
          "module": "CertIndex",
          "items": [],
          "line": 211,
          "raw": "export type CertIndex = Cardano.CertIndex;",
          "source": "mesh-core-cst"
        },
        {
          "module": "TxIndex",
          "items": [],
          "line": 213,
          "raw": "export const TxIndex = Cardano.TxIndex;",
          "source": "mesh-core-cst"
        },
        {
          "module": "TxIndex",
          "items": [],
          "line": 214,
          "raw": "export type TxIndex = Cardano.TxIndex;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Costmdls",
          "items": [],
          "line": 216,
          "raw": "export const Costmdls = Serialization.Costmdls;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Costmdls",
          "items": [],
          "line": 217,
          "raw": "export type Costmdls = Serialization.Costmdls;",
          "source": "mesh-core-cst"
        },
        {
          "module": "CostModel",
          "items": [],
          "line": 219,
          "raw": "export const CostModel = Serialization.CostModel;",
          "source": "mesh-core-cst"
        },
        {
          "module": "CostModel",
          "items": [],
          "line": 220,
          "raw": "export type CostModel = Serialization.CostModel;",
          "source": "mesh-core-cst"
        },
        {
          "module": "CborWriter",
          "items": [],
          "line": 222,
          "raw": "export const CborWriter = Serialization.CborWriter;",
          "source": "mesh-core-cst"
        },
        {
          "module": "CborWriter",
          "items": [],
          "line": 223,
          "raw": "export type CborWriter = Serialization.CborWriter;",
          "source": "mesh-core-cst"
        },
        {
          "module": "ConstrPlutusData",
          "items": [],
          "line": 225,
          "raw": "export const ConstrPlutusData = Serialization.ConstrPlutusData;",
          "source": "mesh-core-cst"
        },
        {
          "module": "ConstrPlutusData",
          "items": [],
          "line": 226,
          "raw": "export type ConstrPlutusData = Serialization.ConstrPlutusData;",
          "source": "mesh-core-cst"
        },
        {
          "module": "RewardAccount",
          "items": [],
          "line": 228,
          "raw": "export const RewardAccount = Cardano.RewardAccount;",
          "source": "mesh-core-cst"
        },
        {
          "module": "RewardAccount",
          "items": [],
          "line": 229,
          "raw": "export type RewardAccount = Cardano.RewardAccount;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Hash",
          "items": [],
          "line": 231,
          "raw": "export const Hash = Serialization.Hash;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Hash",
          "items": [],
          "line": 232,
          "raw": "export type Hash<T extends string> = Serialization.Hash<T>;",
          "source": "mesh-core-cst"
        },
        {
          "module": "DatumHash",
          "items": [],
          "line": 234,
          "raw": "export const DatumHash = (value: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "DatumHash",
          "items": [],
          "line": 237,
          "raw": "export type DatumHash = Crypto.Hash32ByteBase16;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Datum",
          "items": [],
          "line": 239,
          "raw": "export const Datum = Serialization.Datum;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Datum",
          "items": [],
          "line": 240,
          "raw": "export type Datum = PlutusData | DatumHash;",
          "source": "mesh-core-cst"
        },
        {
          "module": "CostModels",
          "items": [],
          "line": 242,
          "raw": "export type CostModels = Cardano.CostModels;",
          "source": "mesh-core-cst"
        },
        {
          "module": "ExUnits",
          "items": [],
          "line": 244,
          "raw": "export type ExUnits = Serialization.ExUnits;",
          "source": "mesh-core-cst"
        },
        {
          "module": "ExUnits",
          "items": [],
          "line": 245,
          "raw": "export const ExUnits = Serialization.ExUnits;",
          "source": "mesh-core-cst"
        },
        {
          "module": "NetworkId",
          "items": [],
          "line": 247,
          "raw": "export const NetworkId = Cardano.NetworkId;",
          "source": "mesh-core-cst"
        },
        {
          "module": "NetworkId",
          "items": [],
          "line": 248,
          "raw": "export type NetworkId = Cardano.ChainId[\"networkId\"];",
          "source": "mesh-core-cst"
        },
        {
          "module": "DatumKind",
          "items": [],
          "line": 250,
          "raw": "export const DatumKind = Serialization.DatumKind;",
          "source": "mesh-core-cst"
        },
        {
          "module": "CborSet",
          "items": [],
          "line": 252,
          "raw": "export const CborSet = Serialization.CborSet;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Witness",
          "items": [],
          "line": 254,
          "raw": "export type Witness = Cardano.Witness;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Signatures",
          "items": [],
          "line": 255,
          "raw": "export type Signatures = Cardano.Signatures;",
          "source": "mesh-core-cst"
        },
        {
          "module": "RequireAllOf",
          "items": [],
          "line": 257,
          "raw": "export type RequireAllOf = Cardano.NativeScriptKind.RequireAllOf;",
          "source": "mesh-core-cst"
        },
        {
          "module": "RequireAllOf",
          "items": [],
          "line": 258,
          "raw": "export const RequireAllOf = Cardano.NativeScriptKind.RequireAllOf;",
          "source": "mesh-core-cst"
        },
        {
          "module": "RequireAnyOf",
          "items": [],
          "line": 260,
          "raw": "export type RequireAnyOf = Cardano.NativeScriptKind.RequireAnyOf;",
          "source": "mesh-core-cst"
        },
        {
          "module": "RequireAnyOf",
          "items": [],
          "line": 261,
          "raw": "export const RequireAnyOf = Cardano.NativeScriptKind.RequireAnyOf;",
          "source": "mesh-core-cst"
        },
        {
          "module": "RequireNOf",
          "items": [],
          "line": 263,
          "raw": "export type RequireNOf = Cardano.NativeScriptKind.RequireNOf;",
          "source": "mesh-core-cst"
        },
        {
          "module": "RequireNOf",
          "items": [],
          "line": 264,
          "raw": "export const RequireNOf = Cardano.NativeScriptKind.RequireNOf;",
          "source": "mesh-core-cst"
        },
        {
          "module": "RequireSignature",
          "items": [],
          "line": 266,
          "raw": "export type RequireSignature = Cardano.NativeScriptKind.RequireSignature;",
          "source": "mesh-core-cst"
        },
        {
          "module": "RequireSignature",
          "items": [],
          "line": 267,
          "raw": "export const RequireSignature = Cardano.NativeScriptKind.RequireSignature;",
          "source": "mesh-core-cst"
        },
        {
          "module": "RequireTimeAfter",
          "items": [],
          "line": 269,
          "raw": "export type RequireTimeAfter = Cardano.NativeScriptKind.RequireTimeAfter;",
          "source": "mesh-core-cst"
        },
        {
          "module": "RequireTimeAfter",
          "items": [],
          "line": 270,
          "raw": "export const RequireTimeAfter = Cardano.NativeScriptKind.RequireTimeAfter;",
          "source": "mesh-core-cst"
        },
        {
          "module": "RequireTimeBefore",
          "items": [],
          "line": 272,
          "raw": "export type RequireTimeBefore = Cardano.NativeScriptKind.RequireTimeBefore;",
          "source": "mesh-core-cst"
        },
        {
          "module": "RequireTimeBefore",
          "items": [],
          "line": 273,
          "raw": "export const RequireTimeBefore = Cardano.NativeScriptKind.RequireTimeBefore;",
          "source": "mesh-core-cst"
        },
        {
          "module": "VrfVkBech32",
          "items": [],
          "line": 275,
          "raw": "export type VrfVkBech32 = Cardano.VrfVkBech32;",
          "source": "mesh-core-cst"
        },
        {
          "module": "VrfVkBech32",
          "items": [],
          "line": 276,
          "raw": "export const VrfVkBech32 = Cardano.VrfVkBech32;",
          "source": "mesh-core-cst"
        },
        {
          "module": "ScriptPubkey",
          "items": [],
          "line": 278,
          "raw": "export type ScriptPubkey = Serialization.ScriptPubkey;",
          "source": "mesh-core-cst"
        },
        {
          "module": "ScriptPubkey",
          "items": [],
          "line": 279,
          "raw": "export const ScriptPubkey = Serialization.ScriptPubkey;",
          "source": "mesh-core-cst"
        },
        {
          "module": "DRepID",
          "items": [],
          "line": 281,
          "raw": "export type DRepID = Cardano.DRepID;",
          "source": "mesh-core-cst"
        },
        {
          "module": "DRepID",
          "items": [],
          "line": 282,
          "raw": "export const DRepID = Cardano.DRepID;",
          "source": "mesh-core-cst"
        },
        {
          "module": "DRep",
          "items": [],
          "line": 284,
          "raw": "export type DRep = Serialization.DRep;",
          "source": "mesh-core-cst"
        },
        {
          "module": "DRep",
          "items": [],
          "line": 285,
          "raw": "export const DRep = Serialization.DRep;",
          "source": "mesh-core-cst"
        },
        {
          "module": "StakeCredentialStatus",
          "items": [],
          "line": 287,
          "raw": "export type StakeCredentialStatus = Cardano.StakeCredentialStatus;",
          "source": "mesh-core-cst"
        },
        {
          "module": "StakeCredentialStatus",
          "items": [],
          "line": 288,
          "raw": "export const StakeCredentialStatus = Cardano.StakeCredentialStatus;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Metadatum",
          "items": [],
          "line": 290,
          "raw": "export type Metadatum = Cardano.Metadatum;",
          "source": "mesh-core-cst"
        },
        {
          "module": "HexBlob",
          "items": [],
          "line": 292,
          "raw": "export type HexBlob = CardanoHexBlob;",
          "source": "mesh-core-cst"
        },
        {
          "module": "HexBlob",
          "items": [],
          "line": 293,
          "raw": "export const HexBlob = CardanoHexBlob;",
          "source": "mesh-core-cst"
        },
        {
          "module": "TxCBOR",
          "items": [],
          "line": 295,
          "raw": "export type TxCBOR = Serialization.TxCBOR;",
          "source": "mesh-core-cst"
        },
        {
          "module": "TxCBOR",
          "items": [],
          "line": 296,
          "raw": "export const TxCBOR = Serialization.TxCBOR;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Ed25519PrivateKey",
          "items": [],
          "line": 298,
          "raw": "export type Ed25519PrivateKey = Crypto.Ed25519PrivateKey;",
          "source": "mesh-core-cst"
        },
        {
          "module": "Ed25519PrivateKey",
          "items": [],
          "line": 299,
          "raw": "export const Ed25519PrivateKey = Crypto.Ed25519PrivateKey;",
          "source": "mesh-core-cst"
        },
        {
          "module": "computeAuxiliaryDataHash",
          "items": [],
          "line": 301,
          "raw": "export const computeAuxiliaryDataHash = Cardano.computeAuxiliaryDataHash;",
          "source": "mesh-core-cst"
        },
        {
          "module": "blake2b",
          "items": [],
          "line": 302,
          "raw": "export const blake2b = Crypto.blake2b;",
          "source": "mesh-core-cst"
        },
        {
          "module": "BootstrapWitness",
          "items": [],
          "line": 304,
          "raw": "export type BootstrapWitness = Serialization.BootstrapWitness;",
          "source": "mesh-core-cst"
        },
        {
          "module": "BootstrapWitness",
          "items": [],
          "line": 305,
          "raw": "export const BootstrapWitness = Serialization.BootstrapWitness;",
          "source": "mesh-core-cst"
        },
        {
          "module": "ByronAttributes",
          "items": [],
          "line": 307,
          "raw": "export type ByronAttributes = Cardano.ByronAttributes;",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "TransactionId",
          "signature": "export const TransactionId = (value: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "value",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 17,
          "raw": "export const TransactionId = (value: string) => {\n  return Cardano.TransactionId(value);\n};",
          "source": "mesh-core-cst",
          "implementation": "export const TransactionId = (value: string) => {\n  return Cardano.TransactionId(value);\n};"
        },
        {
          "name": "Ed25519PrivateNormalKeyHex",
          "signature": "export const Ed25519PrivateNormalKeyHex = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 122,
          "raw": "export const Ed25519PrivateNormalKeyHex = (\n  value: string,\n): Ed25519PrivateNormalKeyHex => typedHex(value, 64);\n\nexport type Ed25519PrivateExtendedKeyHex = OpaqueString<\"Ed25519PrivateKeyHex\">;\nexport const Ed25519PrivateExtendedKeyHex = (\n  value: string,\n): Ed25519PrivateExtendedKeyHex => typedHex(value, 128);\n\nexport const Ed25519KeyHash = Crypto.Ed25519KeyHash;\nexport type Ed25519KeyHash = Crypto.Ed25519KeyHash;\n\nexport const Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;\nexport type Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;\n\nexport const Hash28ByteBase16 = Crypto.Hash28ByteBase16;\nexport type Hash28ByteBase16 = Crypto.Hash28ByteBase16;\n\nexport const Hash32ByteBase16 = (value: string) => {\n  return Crypto.Hash32ByteBase16(value);\n};",
          "source": "mesh-core-cst",
          "implementation": "export const Ed25519PrivateNormalKeyHex = (\n  value: string,\n): Ed25519PrivateNormalKeyHex => typedHex(value, 64);\n\nexport type Ed25519PrivateExtendedKeyHex = OpaqueString<\"Ed25519PrivateKeyHex\">;\nexport const Ed25519PrivateExtendedKeyHex = (\n  value: string,\n): Ed25519PrivateExtendedKeyHex => typedHex(value, 128);\n\nexport const Ed25519KeyHash = Crypto.Ed25519KeyHash;\nexport type Ed25519KeyHash = Crypto.Ed25519KeyHash;\n\nexport const Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;\nexport type Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;\n\nexport const Hash28ByteBase16 = Crypto.Hash28ByteBase16;\nexport type Hash28ByteBase16 = Crypto.Hash28ByteBase16;\n\nexport const Hash32ByteBase16 = (value: string) => {\n  return Crypto.Hash32ByteBase16(value);\n};"
        },
        {
          "name": "Ed25519PrivateExtendedKeyHex",
          "signature": "export const Ed25519PrivateExtendedKeyHex = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 127,
          "raw": "export const Ed25519PrivateExtendedKeyHex = (\n  value: string,\n): Ed25519PrivateExtendedKeyHex => typedHex(value, 128);\n\nexport const Ed25519KeyHash = Crypto.Ed25519KeyHash;\nexport type Ed25519KeyHash = Crypto.Ed25519KeyHash;\n\nexport const Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;\nexport type Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;\n\nexport const Hash28ByteBase16 = Crypto.Hash28ByteBase16;\nexport type Hash28ByteBase16 = Crypto.Hash28ByteBase16;\n\nexport const Hash32ByteBase16 = (value: string) => {\n  return Crypto.Hash32ByteBase16(value);\n};",
          "source": "mesh-core-cst",
          "implementation": "export const Ed25519PrivateExtendedKeyHex = (\n  value: string,\n): Ed25519PrivateExtendedKeyHex => typedHex(value, 128);\n\nexport const Ed25519KeyHash = Crypto.Ed25519KeyHash;\nexport type Ed25519KeyHash = Crypto.Ed25519KeyHash;\n\nexport const Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;\nexport type Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;\n\nexport const Hash28ByteBase16 = Crypto.Hash28ByteBase16;\nexport type Hash28ByteBase16 = Crypto.Hash28ByteBase16;\n\nexport const Hash32ByteBase16 = (value: string) => {\n  return Crypto.Hash32ByteBase16(value);\n};"
        },
        {
          "name": "Hash32ByteBase16",
          "signature": "export const Hash32ByteBase16 = (value: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "value",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 140,
          "raw": "export const Hash32ByteBase16 = (value: string) => {\n  return Crypto.Hash32ByteBase16(value);\n};",
          "source": "mesh-core-cst",
          "implementation": "export const Hash32ByteBase16 = (value: string) => {\n  return Crypto.Hash32ByteBase16(value);\n};"
        },
        {
          "name": "DatumHash",
          "signature": "export const DatumHash = (value: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "value",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 234,
          "raw": "export const DatumHash = (value: string) => {\n  return Crypto.Hash32ByteBase16(value);\n};",
          "source": "mesh-core-cst",
          "implementation": "export const DatumHash = (value: string) => {\n  return Crypto.Hash32ByteBase16(value);\n};"
        }
      ],
      "types": [
        {
          "name": "Slot",
          "definition": "export type Slot = Cardano.Slot;",
          "isPublic": true,
          "line": 7,
          "raw": "export type Slot = Cardano.Slot;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Value",
          "definition": "export type Value = Serialization.Value;",
          "isPublic": true,
          "line": 10,
          "raw": "export type Value = Serialization.Value;",
          "source": "mesh-core-cst"
        },
        {
          "name": "TokenMap",
          "definition": "export type TokenMap = Cardano.TokenMap;",
          "isPublic": true,
          "line": 12,
          "raw": "export type TokenMap = Cardano.TokenMap;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Transaction",
          "definition": "export type Transaction = Serialization.Transaction;",
          "isPublic": true,
          "line": 15,
          "raw": "export type Transaction = Serialization.Transaction;",
          "source": "mesh-core-cst"
        },
        {
          "name": "TransactionId",
          "definition": "export type TransactionId = Cardano.TransactionId;",
          "isPublic": true,
          "line": 20,
          "raw": "export type TransactionId = Cardano.TransactionId;",
          "source": "mesh-core-cst"
        },
        {
          "name": "TransactionBody",
          "definition": "export type TransactionBody = Serialization.TransactionBody;",
          "isPublic": true,
          "line": 23,
          "raw": "export type TransactionBody = Serialization.TransactionBody;",
          "source": "mesh-core-cst"
        },
        {
          "name": "TransactionWitnessSet",
          "definition": "export type TransactionWitnessSet = Serialization.TransactionWitnessSet;",
          "isPublic": true,
          "line": 26,
          "raw": "export type TransactionWitnessSet = Serialization.TransactionWitnessSet;",
          "source": "mesh-core-cst"
        },
        {
          "name": "AuxiliaryData",
          "definition": "export type AuxiliaryData = Serialization.AuxiliaryData;",
          "isPublic": true,
          "line": 29,
          "raw": "export type AuxiliaryData = Serialization.AuxiliaryData;",
          "source": "mesh-core-cst"
        },
        {
          "name": "TransactionMetadatum",
          "definition": "export type TransactionMetadatum = Serialization.TransactionMetadatum;",
          "isPublic": true,
          "line": 32,
          "raw": "export type TransactionMetadatum = Serialization.TransactionMetadatum;",
          "source": "mesh-core-cst"
        },
        {
          "name": "MetadatumMap",
          "definition": "export type MetadatumMap = Serialization.MetadatumMap;",
          "isPublic": true,
          "line": 35,
          "raw": "export type MetadatumMap = Serialization.MetadatumMap;",
          "source": "mesh-core-cst"
        },
        {
          "name": "MetadatumList",
          "definition": "export type MetadatumList = Serialization.MetadatumList;",
          "isPublic": true,
          "line": 38,
          "raw": "export type MetadatumList = Serialization.MetadatumList;",
          "source": "mesh-core-cst"
        },
        {
          "name": "TransactionUnspentOutput",
          "definition": "export type TransactionUnspentOutput = Serialization.TransactionUnspentOutput;",
          "isPublic": true,
          "line": 41,
          "raw": "export type TransactionUnspentOutput = Serialization.TransactionUnspentOutput;",
          "source": "mesh-core-cst"
        },
        {
          "name": "TransactionInput",
          "definition": "export type TransactionInput = Serialization.TransactionInput;",
          "isPublic": true,
          "line": 44,
          "raw": "export type TransactionInput = Serialization.TransactionInput;",
          "source": "mesh-core-cst"
        },
        {
          "name": "TransactionOutput",
          "definition": "export type TransactionOutput = Serialization.TransactionOutput;",
          "isPublic": true,
          "line": 47,
          "raw": "export type TransactionOutput = Serialization.TransactionOutput;",
          "source": "mesh-core-cst"
        },
        {
          "name": "TransactionInputSet",
          "definition": "export type TransactionInputSet = Serialization.CborSet<\n  ReturnType<TransactionInput[\"toCore\"]>,\n  TransactionInput\n>;",
          "isPublic": true,
          "line": 49,
          "raw": "export type TransactionInputSet = Serialization.CborSet<",
          "source": "mesh-core-cst"
        },
        {
          "name": "TransactionWitnessPlutusData",
          "definition": "export type TransactionWitnessPlutusData = Set<PlutusData>;",
          "isPublic": true,
          "line": 54,
          "raw": "export type TransactionWitnessPlutusData = Set<PlutusData>;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PlutusData",
          "definition": "export type PlutusData = Serialization.PlutusData;",
          "isPublic": true,
          "line": 57,
          "raw": "export type PlutusData = Serialization.PlutusData;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PlutusList",
          "definition": "export type PlutusList = Serialization.PlutusList;",
          "isPublic": true,
          "line": 60,
          "raw": "export type PlutusList = Serialization.PlutusList;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PlutusMap",
          "definition": "export type PlutusMap = Serialization.PlutusMap;",
          "isPublic": true,
          "line": 63,
          "raw": "export type PlutusMap = Serialization.PlutusMap;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Redeemers",
          "definition": "export type Redeemers = Serialization.Redeemers;",
          "isPublic": true,
          "line": 66,
          "raw": "export type Redeemers = Serialization.Redeemers;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Redeemer",
          "definition": "export type Redeemer = Serialization.Redeemer;",
          "isPublic": true,
          "line": 69,
          "raw": "export type Redeemer = Serialization.Redeemer;",
          "source": "mesh-core-cst"
        },
        {
          "name": "RedeemerPurpose",
          "definition": "export type RedeemerPurpose = Cardano.RedeemerPurpose;",
          "isPublic": true,
          "line": 72,
          "raw": "export type RedeemerPurpose = Cardano.RedeemerPurpose;",
          "source": "mesh-core-cst"
        },
        {
          "name": "RedeemerTag",
          "definition": "export type RedeemerTag = Serialization.RedeemerTag;",
          "isPublic": true,
          "line": 75,
          "raw": "export type RedeemerTag = Serialization.RedeemerTag;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Script",
          "definition": "export type Script = Serialization.Script;",
          "isPublic": true,
          "line": 78,
          "raw": "export type Script = Serialization.Script;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PolicyId",
          "definition": "export type PolicyId = Cardano.PolicyId;",
          "isPublic": true,
          "line": 81,
          "raw": "export type PolicyId = Cardano.PolicyId;",
          "source": "mesh-core-cst"
        },
        {
          "name": "AssetName",
          "definition": "export type AssetName = Cardano.AssetName;",
          "isPublic": true,
          "line": 84,
          "raw": "export type AssetName = Cardano.AssetName;",
          "source": "mesh-core-cst"
        },
        {
          "name": "AssetId",
          "definition": "export type AssetId = Cardano.AssetId;",
          "isPublic": true,
          "line": 87,
          "raw": "export type AssetId = Cardano.AssetId;",
          "source": "mesh-core-cst"
        },
        {
          "name": "ScriptHash",
          "definition": "export type ScriptHash = Crypto.Hash28ByteBase16;",
          "isPublic": true,
          "line": 90,
          "raw": "export type ScriptHash = Crypto.Hash28ByteBase16;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Address",
          "definition": "export type Address = Cardano.Address;",
          "isPublic": true,
          "line": 93,
          "raw": "export type Address = Cardano.Address;",
          "source": "mesh-core-cst"
        },
        {
          "name": "RewardAddress",
          "definition": "export type RewardAddress = Cardano.RewardAddress;",
          "isPublic": true,
          "line": 96,
          "raw": "export type RewardAddress = Cardano.RewardAddress;",
          "source": "mesh-core-cst"
        },
        {
          "name": "AddressType",
          "definition": "export type AddressType = Cardano.AddressType;",
          "isPublic": true,
          "line": 99,
          "raw": "export type AddressType = Cardano.AddressType;",
          "source": "mesh-core-cst"
        },
        {
          "name": "BaseAddress",
          "definition": "export type BaseAddress = Cardano.BaseAddress;",
          "isPublic": true,
          "line": 102,
          "raw": "export type BaseAddress = Cardano.BaseAddress;",
          "source": "mesh-core-cst"
        },
        {
          "name": "EnterpriseAddress",
          "definition": "export type EnterpriseAddress = Cardano.EnterpriseAddress;",
          "isPublic": true,
          "line": 105,
          "raw": "export type EnterpriseAddress = Cardano.EnterpriseAddress;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PaymentAddress",
          "definition": "export type PaymentAddress = Cardano.PaymentAddress;",
          "isPublic": true,
          "line": 108,
          "raw": "export type PaymentAddress = Cardano.PaymentAddress;",
          "source": "mesh-core-cst"
        },
        {
          "name": "AssetFingerprint",
          "definition": "export type AssetFingerprint = Cardano.AssetFingerprint;",
          "isPublic": true,
          "line": 111,
          "raw": "export type AssetFingerprint = Cardano.AssetFingerprint;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Credential",
          "definition": "export type Credential = Serialization.Credential;",
          "isPublic": true,
          "line": 114,
          "raw": "export type Credential = Serialization.Credential;",
          "source": "mesh-core-cst"
        },
        {
          "name": "CredentialCore",
          "definition": "export type CredentialCore = Cardano.Credential;",
          "isPublic": true,
          "line": 116,
          "raw": "export type CredentialCore = Cardano.Credential;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Ed25519PublicKeyHex",
          "definition": "export type Ed25519PublicKeyHex = Crypto.Ed25519PublicKeyHex;",
          "isPublic": true,
          "line": 119,
          "raw": "export type Ed25519PublicKeyHex = Crypto.Ed25519PublicKeyHex;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Ed25519PrivateNormalKeyHex",
          "definition": "export type Ed25519PrivateNormalKeyHex = OpaqueString<\"Ed25519PrivateKeyHex\">;",
          "isPublic": true,
          "line": 121,
          "raw": "export type Ed25519PrivateNormalKeyHex = OpaqueString<\"Ed25519PrivateKeyHex\">;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Ed25519PrivateExtendedKeyHex",
          "definition": "export type Ed25519PrivateExtendedKeyHex = OpaqueString<\"Ed25519PrivateKeyHex\">;",
          "isPublic": true,
          "line": 126,
          "raw": "export type Ed25519PrivateExtendedKeyHex = OpaqueString<\"Ed25519PrivateKeyHex\">;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Ed25519KeyHash",
          "definition": "export type Ed25519KeyHash = Crypto.Ed25519KeyHash;",
          "isPublic": true,
          "line": 132,
          "raw": "export type Ed25519KeyHash = Crypto.Ed25519KeyHash;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Ed25519KeyHashHex",
          "definition": "export type Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;",
          "isPublic": true,
          "line": 135,
          "raw": "export type Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Hash28ByteBase16",
          "definition": "export type Hash28ByteBase16 = Crypto.Hash28ByteBase16;",
          "isPublic": true,
          "line": 138,
          "raw": "export type Hash28ByteBase16 = Crypto.Hash28ByteBase16;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Hash32ByteBase16",
          "definition": "export type Hash32ByteBase16 = Crypto.Hash32ByteBase16;",
          "isPublic": true,
          "line": 143,
          "raw": "export type Hash32ByteBase16 = Crypto.Hash32ByteBase16;",
          "source": "mesh-core-cst"
        },
        {
          "name": "CredentialType",
          "definition": "export type CredentialType = Cardano.CredentialType;",
          "isPublic": true,
          "line": 146,
          "raw": "export type CredentialType = Cardano.CredentialType;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Certificate",
          "definition": "export type Certificate = Serialization.Certificate;",
          "isPublic": true,
          "line": 149,
          "raw": "export type Certificate = Serialization.Certificate;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PoolId",
          "definition": "export type PoolId = Cardano.PoolId;",
          "isPublic": true,
          "line": 152,
          "raw": "export type PoolId = Cardano.PoolId;",
          "source": "mesh-core-cst"
        },
        {
          "name": "StakeRegistration",
          "definition": "export type StakeRegistration = Serialization.StakeRegistration;",
          "isPublic": true,
          "line": 155,
          "raw": "export type StakeRegistration = Serialization.StakeRegistration;",
          "source": "mesh-core-cst"
        },
        {
          "name": "StakeDelegation",
          "definition": "export type StakeDelegation = Serialization.StakeDelegation;",
          "isPublic": true,
          "line": 158,
          "raw": "export type StakeDelegation = Serialization.StakeDelegation;",
          "source": "mesh-core-cst"
        },
        {
          "name": "StakeDelegationCertificate",
          "definition": "export type StakeDelegationCertificate = Cardano.StakeDelegationCertificate;",
          "isPublic": true,
          "line": 160,
          "raw": "export type StakeDelegationCertificate = Cardano.StakeDelegationCertificate;",
          "source": "mesh-core-cst"
        },
        {
          "name": "CertificateType",
          "definition": "export type CertificateType = Cardano.CertificateType;",
          "isPublic": true,
          "line": 163,
          "raw": "export type CertificateType = Cardano.CertificateType;",
          "source": "mesh-core-cst"
        },
        {
          "name": "VkeyWitness",
          "definition": "export type VkeyWitness = Serialization.VkeyWitness;",
          "isPublic": true,
          "line": 166,
          "raw": "export type VkeyWitness = Serialization.VkeyWitness;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Ed25519SignatureHex",
          "definition": "export type Ed25519SignatureHex = Crypto.Ed25519SignatureHex;",
          "isPublic": true,
          "line": 169,
          "raw": "export type Ed25519SignatureHex = Crypto.Ed25519SignatureHex;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Ed25519PublicKey",
          "definition": "export type Ed25519PublicKey = Crypto.Ed25519PublicKey;",
          "isPublic": true,
          "line": 172,
          "raw": "export type Ed25519PublicKey = Crypto.Ed25519PublicKey;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Ed25519Signature",
          "definition": "export type Ed25519Signature = Crypto.Ed25519Signature;",
          "isPublic": true,
          "line": 175,
          "raw": "export type Ed25519Signature = Crypto.Ed25519Signature;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Bip32PrivateKey",
          "definition": "export type Bip32PrivateKey = Crypto.Bip32PrivateKey;",
          "isPublic": true,
          "line": 178,
          "raw": "export type Bip32PrivateKey = Crypto.Bip32PrivateKey;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Bip32PrivateKeyHex",
          "definition": "export type Bip32PrivateKeyHex = Crypto.Bip32PrivateKeyHex;",
          "isPublic": true,
          "line": 181,
          "raw": "export type Bip32PrivateKeyHex = Crypto.Bip32PrivateKeyHex;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Bip32PublicKey",
          "definition": "export type Bip32PublicKey = Crypto.Bip32PublicKey;",
          "isPublic": true,
          "line": 184,
          "raw": "export type Bip32PublicKey = Crypto.Bip32PublicKey;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Bip32PublicKeyHex",
          "definition": "export type Bip32PublicKeyHex = Crypto.Bip32PublicKeyHex;",
          "isPublic": true,
          "line": 187,
          "raw": "export type Bip32PublicKeyHex = Crypto.Bip32PublicKeyHex;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PlutusLanguageVersion",
          "definition": "export type PlutusLanguageVersion = Cardano.PlutusLanguageVersion;",
          "isPublic": true,
          "line": 190,
          "raw": "export type PlutusLanguageVersion = Cardano.PlutusLanguageVersion;",
          "source": "mesh-core-cst"
        },
        {
          "name": "NativeScript",
          "definition": "export type NativeScript = Serialization.NativeScript;",
          "isPublic": true,
          "line": 193,
          "raw": "export type NativeScript = Serialization.NativeScript;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PlutusV1Script",
          "definition": "export type PlutusV1Script = Serialization.PlutusV1Script;",
          "isPublic": true,
          "line": 196,
          "raw": "export type PlutusV1Script = Serialization.PlutusV1Script;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PlutusV2Script",
          "definition": "export type PlutusV2Script = Serialization.PlutusV2Script;",
          "isPublic": true,
          "line": 199,
          "raw": "export type PlutusV2Script = Serialization.PlutusV2Script;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PlutusV3Script",
          "definition": "export type PlutusV3Script = Serialization.PlutusV3Script;",
          "isPublic": true,
          "line": 202,
          "raw": "export type PlutusV3Script = Serialization.PlutusV3Script;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PlutusDataKind",
          "definition": "export type PlutusDataKind = Serialization.PlutusDataKind;",
          "isPublic": true,
          "line": 205,
          "raw": "export type PlutusDataKind = Serialization.PlutusDataKind;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PointerAddress",
          "definition": "export type PointerAddress = Cardano.PointerAddress;",
          "isPublic": true,
          "line": 208,
          "raw": "export type PointerAddress = Cardano.PointerAddress;",
          "source": "mesh-core-cst"
        },
        {
          "name": "CertIndex",
          "definition": "export type CertIndex = Cardano.CertIndex;",
          "isPublic": true,
          "line": 211,
          "raw": "export type CertIndex = Cardano.CertIndex;",
          "source": "mesh-core-cst"
        },
        {
          "name": "TxIndex",
          "definition": "export type TxIndex = Cardano.TxIndex;",
          "isPublic": true,
          "line": 214,
          "raw": "export type TxIndex = Cardano.TxIndex;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Costmdls",
          "definition": "export type Costmdls = Serialization.Costmdls;",
          "isPublic": true,
          "line": 217,
          "raw": "export type Costmdls = Serialization.Costmdls;",
          "source": "mesh-core-cst"
        },
        {
          "name": "CostModel",
          "definition": "export type CostModel = Serialization.CostModel;",
          "isPublic": true,
          "line": 220,
          "raw": "export type CostModel = Serialization.CostModel;",
          "source": "mesh-core-cst"
        },
        {
          "name": "CborWriter",
          "definition": "export type CborWriter = Serialization.CborWriter;",
          "isPublic": true,
          "line": 223,
          "raw": "export type CborWriter = Serialization.CborWriter;",
          "source": "mesh-core-cst"
        },
        {
          "name": "ConstrPlutusData",
          "definition": "export type ConstrPlutusData = Serialization.ConstrPlutusData;",
          "isPublic": true,
          "line": 226,
          "raw": "export type ConstrPlutusData = Serialization.ConstrPlutusData;",
          "source": "mesh-core-cst"
        },
        {
          "name": "RewardAccount",
          "definition": "export type RewardAccount = Cardano.RewardAccount;",
          "isPublic": true,
          "line": 229,
          "raw": "export type RewardAccount = Cardano.RewardAccount;",
          "source": "mesh-core-cst"
        },
        {
          "name": "DatumHash",
          "definition": "export type DatumHash = Crypto.Hash32ByteBase16;",
          "isPublic": true,
          "line": 237,
          "raw": "export type DatumHash = Crypto.Hash32ByteBase16;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Datum",
          "definition": "export type Datum = PlutusData | DatumHash;",
          "isPublic": true,
          "line": 240,
          "raw": "export type Datum = PlutusData | DatumHash;",
          "source": "mesh-core-cst"
        },
        {
          "name": "CostModels",
          "definition": "export type CostModels = Cardano.CostModels;",
          "isPublic": true,
          "line": 242,
          "raw": "export type CostModels = Cardano.CostModels;",
          "source": "mesh-core-cst"
        },
        {
          "name": "ExUnits",
          "definition": "export type ExUnits = Serialization.ExUnits;",
          "isPublic": true,
          "line": 244,
          "raw": "export type ExUnits = Serialization.ExUnits;",
          "source": "mesh-core-cst"
        },
        {
          "name": "NetworkId",
          "definition": "export type NetworkId = Cardano.ChainId[\"networkId\"];",
          "isPublic": true,
          "line": 248,
          "raw": "export type NetworkId = Cardano.ChainId[\"networkId\"];",
          "source": "mesh-core-cst"
        },
        {
          "name": "Witness",
          "definition": "export type Witness = Cardano.Witness;",
          "isPublic": true,
          "line": 254,
          "raw": "export type Witness = Cardano.Witness;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Signatures",
          "definition": "export type Signatures = Cardano.Signatures;",
          "isPublic": true,
          "line": 255,
          "raw": "export type Signatures = Cardano.Signatures;",
          "source": "mesh-core-cst"
        },
        {
          "name": "RequireAllOf",
          "definition": "export type RequireAllOf = Cardano.NativeScriptKind.RequireAllOf;",
          "isPublic": true,
          "line": 257,
          "raw": "export type RequireAllOf = Cardano.NativeScriptKind.RequireAllOf;",
          "source": "mesh-core-cst"
        },
        {
          "name": "RequireAnyOf",
          "definition": "export type RequireAnyOf = Cardano.NativeScriptKind.RequireAnyOf;",
          "isPublic": true,
          "line": 260,
          "raw": "export type RequireAnyOf = Cardano.NativeScriptKind.RequireAnyOf;",
          "source": "mesh-core-cst"
        },
        {
          "name": "RequireNOf",
          "definition": "export type RequireNOf = Cardano.NativeScriptKind.RequireNOf;",
          "isPublic": true,
          "line": 263,
          "raw": "export type RequireNOf = Cardano.NativeScriptKind.RequireNOf;",
          "source": "mesh-core-cst"
        },
        {
          "name": "RequireSignature",
          "definition": "export type RequireSignature = Cardano.NativeScriptKind.RequireSignature;",
          "isPublic": true,
          "line": 266,
          "raw": "export type RequireSignature = Cardano.NativeScriptKind.RequireSignature;",
          "source": "mesh-core-cst"
        },
        {
          "name": "RequireTimeAfter",
          "definition": "export type RequireTimeAfter = Cardano.NativeScriptKind.RequireTimeAfter;",
          "isPublic": true,
          "line": 269,
          "raw": "export type RequireTimeAfter = Cardano.NativeScriptKind.RequireTimeAfter;",
          "source": "mesh-core-cst"
        },
        {
          "name": "RequireTimeBefore",
          "definition": "export type RequireTimeBefore = Cardano.NativeScriptKind.RequireTimeBefore;",
          "isPublic": true,
          "line": 272,
          "raw": "export type RequireTimeBefore = Cardano.NativeScriptKind.RequireTimeBefore;",
          "source": "mesh-core-cst"
        },
        {
          "name": "VrfVkBech32",
          "definition": "export type VrfVkBech32 = Cardano.VrfVkBech32;",
          "isPublic": true,
          "line": 275,
          "raw": "export type VrfVkBech32 = Cardano.VrfVkBech32;",
          "source": "mesh-core-cst"
        },
        {
          "name": "ScriptPubkey",
          "definition": "export type ScriptPubkey = Serialization.ScriptPubkey;",
          "isPublic": true,
          "line": 278,
          "raw": "export type ScriptPubkey = Serialization.ScriptPubkey;",
          "source": "mesh-core-cst"
        },
        {
          "name": "DRepID",
          "definition": "export type DRepID = Cardano.DRepID;",
          "isPublic": true,
          "line": 281,
          "raw": "export type DRepID = Cardano.DRepID;",
          "source": "mesh-core-cst"
        },
        {
          "name": "DRep",
          "definition": "export type DRep = Serialization.DRep;",
          "isPublic": true,
          "line": 284,
          "raw": "export type DRep = Serialization.DRep;",
          "source": "mesh-core-cst"
        },
        {
          "name": "StakeCredentialStatus",
          "definition": "export type StakeCredentialStatus = Cardano.StakeCredentialStatus;",
          "isPublic": true,
          "line": 287,
          "raw": "export type StakeCredentialStatus = Cardano.StakeCredentialStatus;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Metadatum",
          "definition": "export type Metadatum = Cardano.Metadatum;",
          "isPublic": true,
          "line": 290,
          "raw": "export type Metadatum = Cardano.Metadatum;",
          "source": "mesh-core-cst"
        },
        {
          "name": "HexBlob",
          "definition": "export type HexBlob = CardanoHexBlob;",
          "isPublic": true,
          "line": 292,
          "raw": "export type HexBlob = CardanoHexBlob;",
          "source": "mesh-core-cst"
        },
        {
          "name": "TxCBOR",
          "definition": "export type TxCBOR = Serialization.TxCBOR;",
          "isPublic": true,
          "line": 295,
          "raw": "export type TxCBOR = Serialization.TxCBOR;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Ed25519PrivateKey",
          "definition": "export type Ed25519PrivateKey = Crypto.Ed25519PrivateKey;",
          "isPublic": true,
          "line": 298,
          "raw": "export type Ed25519PrivateKey = Crypto.Ed25519PrivateKey;",
          "source": "mesh-core-cst"
        },
        {
          "name": "BootstrapWitness",
          "definition": "export type BootstrapWitness = Serialization.BootstrapWitness;",
          "isPublic": true,
          "line": 304,
          "raw": "export type BootstrapWitness = Serialization.BootstrapWitness;",
          "source": "mesh-core-cst"
        },
        {
          "name": "ByronAttributes",
          "definition": "export type ByronAttributes = Cardano.ByronAttributes;",
          "isPublic": true,
          "line": 307,
          "raw": "export type ByronAttributes = Cardano.ByronAttributes;",
          "source": "mesh-core-cst"
        }
      ],
      "constants": [
        {
          "name": "Slot",
          "type": "any",
          "value": "Cardano.Slot;",
          "isPublic": true,
          "line": 6,
          "raw": "export const Slot = Cardano.Slot;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Value",
          "type": "any",
          "value": "Serialization.Value;",
          "isPublic": true,
          "line": 9,
          "raw": "export const Value = Serialization.Value;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Transaction",
          "type": "any",
          "value": "Serialization.Transaction;",
          "isPublic": true,
          "line": 14,
          "raw": "export const Transaction = Serialization.Transaction;",
          "source": "mesh-core-cst"
        },
        {
          "name": "TransactionId",
          "type": "any",
          "value": "(value: string) => {",
          "isPublic": true,
          "line": 17,
          "raw": "export const TransactionId = (value: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "TransactionBody",
          "type": "any",
          "value": "Serialization.TransactionBody;",
          "isPublic": true,
          "line": 22,
          "raw": "export const TransactionBody = Serialization.TransactionBody;",
          "source": "mesh-core-cst"
        },
        {
          "name": "TransactionWitnessSet",
          "type": "any",
          "value": "Serialization.TransactionWitnessSet;",
          "isPublic": true,
          "line": 25,
          "raw": "export const TransactionWitnessSet = Serialization.TransactionWitnessSet;",
          "source": "mesh-core-cst"
        },
        {
          "name": "AuxilliaryData",
          "type": "any",
          "value": "Serialization.AuxiliaryData;",
          "isPublic": true,
          "line": 28,
          "raw": "export const AuxilliaryData = Serialization.AuxiliaryData;",
          "source": "mesh-core-cst"
        },
        {
          "name": "TransactionMetadatum",
          "type": "any",
          "value": "Serialization.TransactionMetadatum;",
          "isPublic": true,
          "line": 31,
          "raw": "export const TransactionMetadatum = Serialization.TransactionMetadatum;",
          "source": "mesh-core-cst"
        },
        {
          "name": "MetadatumMap",
          "type": "any",
          "value": "Serialization.MetadatumMap;",
          "isPublic": true,
          "line": 34,
          "raw": "export const MetadatumMap = Serialization.MetadatumMap;",
          "source": "mesh-core-cst"
        },
        {
          "name": "MetadatumList",
          "type": "any",
          "value": "Serialization.MetadatumList;",
          "isPublic": true,
          "line": 37,
          "raw": "export const MetadatumList = Serialization.MetadatumList;",
          "source": "mesh-core-cst"
        },
        {
          "name": "TransactionUnspentOutput",
          "type": "any",
          "value": "Serialization.TransactionUnspentOutput;",
          "isPublic": true,
          "line": 40,
          "raw": "export const TransactionUnspentOutput = Serialization.TransactionUnspentOutput;",
          "source": "mesh-core-cst"
        },
        {
          "name": "TransactionInput",
          "type": "any",
          "value": "Serialization.TransactionInput;",
          "isPublic": true,
          "line": 43,
          "raw": "export const TransactionInput = Serialization.TransactionInput;",
          "source": "mesh-core-cst"
        },
        {
          "name": "TransactionOutput",
          "type": "any",
          "value": "Serialization.TransactionOutput;",
          "isPublic": true,
          "line": 46,
          "raw": "export const TransactionOutput = Serialization.TransactionOutput;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PlutusData",
          "type": "any",
          "value": "Serialization.PlutusData;",
          "isPublic": true,
          "line": 56,
          "raw": "export const PlutusData = Serialization.PlutusData;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PlutusList",
          "type": "any",
          "value": "Serialization.PlutusList;",
          "isPublic": true,
          "line": 59,
          "raw": "export const PlutusList = Serialization.PlutusList;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PlutusMap",
          "type": "any",
          "value": "Serialization.PlutusMap;",
          "isPublic": true,
          "line": 62,
          "raw": "export const PlutusMap = Serialization.PlutusMap;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Redeemers",
          "type": "any",
          "value": "Serialization.Redeemers;",
          "isPublic": true,
          "line": 65,
          "raw": "export const Redeemers = Serialization.Redeemers;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Redeemer",
          "type": "any",
          "value": "Serialization.Redeemer;",
          "isPublic": true,
          "line": 68,
          "raw": "export const Redeemer = Serialization.Redeemer;",
          "source": "mesh-core-cst"
        },
        {
          "name": "RedeemerPurpose",
          "type": "any",
          "value": "Cardano.RedeemerPurpose;",
          "isPublic": true,
          "line": 71,
          "raw": "export const RedeemerPurpose = Cardano.RedeemerPurpose;",
          "source": "mesh-core-cst"
        },
        {
          "name": "RedeemerTag",
          "type": "any",
          "value": "Serialization.RedeemerTag;",
          "isPublic": true,
          "line": 74,
          "raw": "export const RedeemerTag = Serialization.RedeemerTag;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Script",
          "type": "any",
          "value": "Serialization.Script;",
          "isPublic": true,
          "line": 77,
          "raw": "export const Script = Serialization.Script;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PolicyId",
          "type": "any",
          "value": "Cardano.PolicyId;",
          "isPublic": true,
          "line": 80,
          "raw": "export const PolicyId = Cardano.PolicyId;",
          "source": "mesh-core-cst"
        },
        {
          "name": "AssetName",
          "type": "any",
          "value": "Cardano.AssetName;",
          "isPublic": true,
          "line": 83,
          "raw": "export const AssetName = Cardano.AssetName;",
          "source": "mesh-core-cst"
        },
        {
          "name": "AssetId",
          "type": "any",
          "value": "Cardano.AssetId;",
          "isPublic": true,
          "line": 86,
          "raw": "export const AssetId = Cardano.AssetId;",
          "source": "mesh-core-cst"
        },
        {
          "name": "ScriptHash",
          "type": "any",
          "value": "Crypto.Hash28ByteBase16;",
          "isPublic": true,
          "line": 89,
          "raw": "export const ScriptHash = Crypto.Hash28ByteBase16;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Address",
          "type": "any",
          "value": "Cardano.Address;",
          "isPublic": true,
          "line": 92,
          "raw": "export const Address = Cardano.Address;",
          "source": "mesh-core-cst"
        },
        {
          "name": "RewardAddress",
          "type": "any",
          "value": "Cardano.RewardAddress;",
          "isPublic": true,
          "line": 95,
          "raw": "export const RewardAddress = Cardano.RewardAddress;",
          "source": "mesh-core-cst"
        },
        {
          "name": "AddressType",
          "type": "any",
          "value": "Cardano.AddressType;",
          "isPublic": true,
          "line": 98,
          "raw": "export const AddressType = Cardano.AddressType;",
          "source": "mesh-core-cst"
        },
        {
          "name": "BaseAddress",
          "type": "any",
          "value": "Cardano.BaseAddress;",
          "isPublic": true,
          "line": 101,
          "raw": "export const BaseAddress = Cardano.BaseAddress;",
          "source": "mesh-core-cst"
        },
        {
          "name": "EnterpriseAddress",
          "type": "any",
          "value": "Cardano.EnterpriseAddress;",
          "isPublic": true,
          "line": 104,
          "raw": "export const EnterpriseAddress = Cardano.EnterpriseAddress;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PaymentAddress",
          "type": "any",
          "value": "Cardano.PaymentAddress;",
          "isPublic": true,
          "line": 107,
          "raw": "export const PaymentAddress = Cardano.PaymentAddress;",
          "source": "mesh-core-cst"
        },
        {
          "name": "AssetFingerprint",
          "type": "any",
          "value": "Cardano.AssetFingerprint;",
          "isPublic": true,
          "line": 110,
          "raw": "export const AssetFingerprint = Cardano.AssetFingerprint;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Credential",
          "type": "any",
          "value": "Serialization.Credential;",
          "isPublic": true,
          "line": 113,
          "raw": "export const Credential = Serialization.Credential;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Ed25519PublicKeyHex",
          "type": "any",
          "value": "Crypto.Ed25519PublicKeyHex;",
          "isPublic": true,
          "line": 118,
          "raw": "export const Ed25519PublicKeyHex = Crypto.Ed25519PublicKeyHex;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Ed25519PrivateNormalKeyHex",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 122,
          "raw": "export const Ed25519PrivateNormalKeyHex = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "Ed25519PrivateExtendedKeyHex",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 127,
          "raw": "export const Ed25519PrivateExtendedKeyHex = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "Ed25519KeyHash",
          "type": "any",
          "value": "Crypto.Ed25519KeyHash;",
          "isPublic": true,
          "line": 131,
          "raw": "export const Ed25519KeyHash = Crypto.Ed25519KeyHash;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Ed25519KeyHashHex",
          "type": "any",
          "value": "Crypto.Ed25519KeyHashHex;",
          "isPublic": true,
          "line": 134,
          "raw": "export const Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Hash28ByteBase16",
          "type": "any",
          "value": "Crypto.Hash28ByteBase16;",
          "isPublic": true,
          "line": 137,
          "raw": "export const Hash28ByteBase16 = Crypto.Hash28ByteBase16;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Hash32ByteBase16",
          "type": "any",
          "value": "(value: string) => {",
          "isPublic": true,
          "line": 140,
          "raw": "export const Hash32ByteBase16 = (value: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "CredentialType",
          "type": "any",
          "value": "Cardano.CredentialType;",
          "isPublic": true,
          "line": 145,
          "raw": "export const CredentialType = Cardano.CredentialType;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Certificate",
          "type": "any",
          "value": "Serialization.Certificate;",
          "isPublic": true,
          "line": 148,
          "raw": "export const Certificate = Serialization.Certificate;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PoolId",
          "type": "any",
          "value": "Cardano.PoolId;",
          "isPublic": true,
          "line": 151,
          "raw": "export const PoolId = Cardano.PoolId;",
          "source": "mesh-core-cst"
        },
        {
          "name": "StakeRegistration",
          "type": "any",
          "value": "Serialization.StakeRegistration;",
          "isPublic": true,
          "line": 154,
          "raw": "export const StakeRegistration = Serialization.StakeRegistration;",
          "source": "mesh-core-cst"
        },
        {
          "name": "StakeDelegation",
          "type": "any",
          "value": "Serialization.StakeDelegation;",
          "isPublic": true,
          "line": 157,
          "raw": "export const StakeDelegation = Serialization.StakeDelegation;",
          "source": "mesh-core-cst"
        },
        {
          "name": "CertificateType",
          "type": "any",
          "value": "Cardano.CertificateType;",
          "isPublic": true,
          "line": 162,
          "raw": "export const CertificateType = Cardano.CertificateType;",
          "source": "mesh-core-cst"
        },
        {
          "name": "VkeyWitness",
          "type": "any",
          "value": "Serialization.VkeyWitness;",
          "isPublic": true,
          "line": 165,
          "raw": "export const VkeyWitness = Serialization.VkeyWitness;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Ed25519SignatureHex",
          "type": "any",
          "value": "Crypto.Ed25519SignatureHex;",
          "isPublic": true,
          "line": 168,
          "raw": "export const Ed25519SignatureHex = Crypto.Ed25519SignatureHex;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Ed25519PublicKey",
          "type": "any",
          "value": "Crypto.Ed25519PublicKey;",
          "isPublic": true,
          "line": 171,
          "raw": "export const Ed25519PublicKey = Crypto.Ed25519PublicKey;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Ed25519Signature",
          "type": "any",
          "value": "Crypto.Ed25519Signature;",
          "isPublic": true,
          "line": 174,
          "raw": "export const Ed25519Signature = Crypto.Ed25519Signature;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Bip32PrivateKey",
          "type": "any",
          "value": "Crypto.Bip32PrivateKey;",
          "isPublic": true,
          "line": 177,
          "raw": "export const Bip32PrivateKey = Crypto.Bip32PrivateKey;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Bip32PrivateKeyHex",
          "type": "any",
          "value": "Crypto.Bip32PrivateKeyHex;",
          "isPublic": true,
          "line": 180,
          "raw": "export const Bip32PrivateKeyHex = Crypto.Bip32PrivateKeyHex;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Bip32PublicKey",
          "type": "any",
          "value": "Crypto.Bip32PublicKey;",
          "isPublic": true,
          "line": 183,
          "raw": "export const Bip32PublicKey = Crypto.Bip32PublicKey;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Bip32PublicKeyHex",
          "type": "any",
          "value": "Crypto.Bip32PublicKeyHex;",
          "isPublic": true,
          "line": 186,
          "raw": "export const Bip32PublicKeyHex = Crypto.Bip32PublicKeyHex;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PlutusLanguageVersion",
          "type": "any",
          "value": "Cardano.PlutusLanguageVersion;",
          "isPublic": true,
          "line": 189,
          "raw": "export const PlutusLanguageVersion = Cardano.PlutusLanguageVersion;",
          "source": "mesh-core-cst"
        },
        {
          "name": "NativeScript",
          "type": "any",
          "value": "Serialization.NativeScript;",
          "isPublic": true,
          "line": 192,
          "raw": "export const NativeScript = Serialization.NativeScript;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PlutusV1Script",
          "type": "any",
          "value": "Serialization.PlutusV1Script;",
          "isPublic": true,
          "line": 195,
          "raw": "export const PlutusV1Script = Serialization.PlutusV1Script;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PlutusV2Script",
          "type": "any",
          "value": "Serialization.PlutusV2Script;",
          "isPublic": true,
          "line": 198,
          "raw": "export const PlutusV2Script = Serialization.PlutusV2Script;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PlutusV3Script",
          "type": "any",
          "value": "Serialization.PlutusV3Script;",
          "isPublic": true,
          "line": 201,
          "raw": "export const PlutusV3Script = Serialization.PlutusV3Script;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PlutusDataKind",
          "type": "any",
          "value": "Serialization.PlutusDataKind;",
          "isPublic": true,
          "line": 204,
          "raw": "export const PlutusDataKind = Serialization.PlutusDataKind;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PointerAddress",
          "type": "any",
          "value": "Cardano.PointerAddress;",
          "isPublic": true,
          "line": 207,
          "raw": "export const PointerAddress = Cardano.PointerAddress;",
          "source": "mesh-core-cst"
        },
        {
          "name": "CertIndex",
          "type": "any",
          "value": "Cardano.CertIndex;",
          "isPublic": true,
          "line": 210,
          "raw": "export const CertIndex = Cardano.CertIndex;",
          "source": "mesh-core-cst"
        },
        {
          "name": "TxIndex",
          "type": "any",
          "value": "Cardano.TxIndex;",
          "isPublic": true,
          "line": 213,
          "raw": "export const TxIndex = Cardano.TxIndex;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Costmdls",
          "type": "any",
          "value": "Serialization.Costmdls;",
          "isPublic": true,
          "line": 216,
          "raw": "export const Costmdls = Serialization.Costmdls;",
          "source": "mesh-core-cst"
        },
        {
          "name": "CostModel",
          "type": "any",
          "value": "Serialization.CostModel;",
          "isPublic": true,
          "line": 219,
          "raw": "export const CostModel = Serialization.CostModel;",
          "source": "mesh-core-cst"
        },
        {
          "name": "CborWriter",
          "type": "any",
          "value": "Serialization.CborWriter;",
          "isPublic": true,
          "line": 222,
          "raw": "export const CborWriter = Serialization.CborWriter;",
          "source": "mesh-core-cst"
        },
        {
          "name": "ConstrPlutusData",
          "type": "any",
          "value": "Serialization.ConstrPlutusData;",
          "isPublic": true,
          "line": 225,
          "raw": "export const ConstrPlutusData = Serialization.ConstrPlutusData;",
          "source": "mesh-core-cst"
        },
        {
          "name": "RewardAccount",
          "type": "any",
          "value": "Cardano.RewardAccount;",
          "isPublic": true,
          "line": 228,
          "raw": "export const RewardAccount = Cardano.RewardAccount;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Hash",
          "type": "any",
          "value": "Serialization.Hash;",
          "isPublic": true,
          "line": 231,
          "raw": "export const Hash = Serialization.Hash;",
          "source": "mesh-core-cst"
        },
        {
          "name": "DatumHash",
          "type": "any",
          "value": "(value: string) => {",
          "isPublic": true,
          "line": 234,
          "raw": "export const DatumHash = (value: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "Datum",
          "type": "any",
          "value": "Serialization.Datum;",
          "isPublic": true,
          "line": 239,
          "raw": "export const Datum = Serialization.Datum;",
          "source": "mesh-core-cst"
        },
        {
          "name": "ExUnits",
          "type": "any",
          "value": "Serialization.ExUnits;",
          "isPublic": true,
          "line": 245,
          "raw": "export const ExUnits = Serialization.ExUnits;",
          "source": "mesh-core-cst"
        },
        {
          "name": "NetworkId",
          "type": "any",
          "value": "Cardano.NetworkId;",
          "isPublic": true,
          "line": 247,
          "raw": "export const NetworkId = Cardano.NetworkId;",
          "source": "mesh-core-cst"
        },
        {
          "name": "DatumKind",
          "type": "any",
          "value": "Serialization.DatumKind;",
          "isPublic": true,
          "line": 250,
          "raw": "export const DatumKind = Serialization.DatumKind;",
          "source": "mesh-core-cst"
        },
        {
          "name": "CborSet",
          "type": "any",
          "value": "Serialization.CborSet;",
          "isPublic": true,
          "line": 252,
          "raw": "export const CborSet = Serialization.CborSet;",
          "source": "mesh-core-cst"
        },
        {
          "name": "RequireAllOf",
          "type": "any",
          "value": "Cardano.NativeScriptKind.RequireAllOf;",
          "isPublic": true,
          "line": 258,
          "raw": "export const RequireAllOf = Cardano.NativeScriptKind.RequireAllOf;",
          "source": "mesh-core-cst"
        },
        {
          "name": "RequireAnyOf",
          "type": "any",
          "value": "Cardano.NativeScriptKind.RequireAnyOf;",
          "isPublic": true,
          "line": 261,
          "raw": "export const RequireAnyOf = Cardano.NativeScriptKind.RequireAnyOf;",
          "source": "mesh-core-cst"
        },
        {
          "name": "RequireNOf",
          "type": "any",
          "value": "Cardano.NativeScriptKind.RequireNOf;",
          "isPublic": true,
          "line": 264,
          "raw": "export const RequireNOf = Cardano.NativeScriptKind.RequireNOf;",
          "source": "mesh-core-cst"
        },
        {
          "name": "RequireSignature",
          "type": "any",
          "value": "Cardano.NativeScriptKind.RequireSignature;",
          "isPublic": true,
          "line": 267,
          "raw": "export const RequireSignature = Cardano.NativeScriptKind.RequireSignature;",
          "source": "mesh-core-cst"
        },
        {
          "name": "RequireTimeAfter",
          "type": "any",
          "value": "Cardano.NativeScriptKind.RequireTimeAfter;",
          "isPublic": true,
          "line": 270,
          "raw": "export const RequireTimeAfter = Cardano.NativeScriptKind.RequireTimeAfter;",
          "source": "mesh-core-cst"
        },
        {
          "name": "RequireTimeBefore",
          "type": "any",
          "value": "Cardano.NativeScriptKind.RequireTimeBefore;",
          "isPublic": true,
          "line": 273,
          "raw": "export const RequireTimeBefore = Cardano.NativeScriptKind.RequireTimeBefore;",
          "source": "mesh-core-cst"
        },
        {
          "name": "VrfVkBech32",
          "type": "any",
          "value": "Cardano.VrfVkBech32;",
          "isPublic": true,
          "line": 276,
          "raw": "export const VrfVkBech32 = Cardano.VrfVkBech32;",
          "source": "mesh-core-cst"
        },
        {
          "name": "ScriptPubkey",
          "type": "any",
          "value": "Serialization.ScriptPubkey;",
          "isPublic": true,
          "line": 279,
          "raw": "export const ScriptPubkey = Serialization.ScriptPubkey;",
          "source": "mesh-core-cst"
        },
        {
          "name": "DRepID",
          "type": "any",
          "value": "Cardano.DRepID;",
          "isPublic": true,
          "line": 282,
          "raw": "export const DRepID = Cardano.DRepID;",
          "source": "mesh-core-cst"
        },
        {
          "name": "DRep",
          "type": "any",
          "value": "Serialization.DRep;",
          "isPublic": true,
          "line": 285,
          "raw": "export const DRep = Serialization.DRep;",
          "source": "mesh-core-cst"
        },
        {
          "name": "StakeCredentialStatus",
          "type": "any",
          "value": "Cardano.StakeCredentialStatus;",
          "isPublic": true,
          "line": 288,
          "raw": "export const StakeCredentialStatus = Cardano.StakeCredentialStatus;",
          "source": "mesh-core-cst"
        },
        {
          "name": "HexBlob",
          "type": "any",
          "value": "CardanoHexBlob;",
          "isPublic": true,
          "line": 293,
          "raw": "export const HexBlob = CardanoHexBlob;",
          "source": "mesh-core-cst"
        },
        {
          "name": "TxCBOR",
          "type": "any",
          "value": "Serialization.TxCBOR;",
          "isPublic": true,
          "line": 296,
          "raw": "export const TxCBOR = Serialization.TxCBOR;",
          "source": "mesh-core-cst"
        },
        {
          "name": "Ed25519PrivateKey",
          "type": "any",
          "value": "Crypto.Ed25519PrivateKey;",
          "isPublic": true,
          "line": 299,
          "raw": "export const Ed25519PrivateKey = Crypto.Ed25519PrivateKey;",
          "source": "mesh-core-cst"
        },
        {
          "name": "computeAuxiliaryDataHash",
          "type": "any",
          "value": "Cardano.computeAuxiliaryDataHash;",
          "isPublic": true,
          "line": 301,
          "raw": "export const computeAuxiliaryDataHash = Cardano.computeAuxiliaryDataHash;",
          "source": "mesh-core-cst"
        },
        {
          "name": "blake2b",
          "type": "any",
          "value": "Crypto.blake2b;",
          "isPublic": true,
          "line": 302,
          "raw": "export const blake2b = Crypto.blake2b;",
          "source": "mesh-core-cst"
        },
        {
          "name": "BootstrapWitness",
          "type": "any",
          "value": "Serialization.BootstrapWitness;",
          "isPublic": true,
          "line": 305,
          "raw": "export const BootstrapWitness = Serialization.BootstrapWitness;",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import type { OpaqueString } from \"@cardano-sdk/util\";\nimport { Cardano, Serialization } from \"@cardano-sdk/core\";\nimport * as Crypto from \"@cardano-sdk/crypto\";\nimport { HexBlob as CardanoHexBlob, typedHex } from \"@cardano-sdk/util\";\n\nexport const Slot = Cardano.Slot;\nexport type Slot = Cardano.Slot;\n\nexport const Value = Serialization.Value;\nexport type Value = Serialization.Value;\n\nexport type TokenMap = Cardano.TokenMap;\n\nexport const Transaction = Serialization.Transaction;\nexport type Transaction = Serialization.Transaction;\n\nexport const TransactionId = (value: string) => {\n  return Cardano.TransactionId(value);\n};\nexport type TransactionId = Cardano.TransactionId;\n\nexport const TransactionBody = Serialization.TransactionBody;\nexport type TransactionBody = Serialization.TransactionBody;\n\nexport const TransactionWitnessSet = Serialization.TransactionWitnessSet;\nexport type TransactionWitnessSet = Serialization.TransactionWitnessSet;\n\nexport const AuxilliaryData = Serialization.AuxiliaryData;\nexport type AuxiliaryData = Serialization.AuxiliaryData;\n\nexport const TransactionMetadatum = Serialization.TransactionMetadatum;\nexport type TransactionMetadatum = Serialization.TransactionMetadatum;\n\nexport const MetadatumMap = Serialization.MetadatumMap;\nexport type MetadatumMap = Serialization.MetadatumMap;\n\nexport const MetadatumList = Serialization.MetadatumList;\nexport type MetadatumList = Serialization.MetadatumList;\n\nexport const TransactionUnspentOutput = Serialization.TransactionUnspentOutput;\nexport type TransactionUnspentOutput = Serialization.TransactionUnspentOutput;\n\nexport const TransactionInput = Serialization.TransactionInput;\nexport type TransactionInput = Serialization.TransactionInput;\n\nexport const TransactionOutput = Serialization.TransactionOutput;\nexport type TransactionOutput = Serialization.TransactionOutput;\n\nexport type TransactionInputSet = Serialization.CborSet<\n  ReturnType<TransactionInput[\"toCore\"]>,\n  TransactionInput\n>;\n\nexport type TransactionWitnessPlutusData = Set<PlutusData>;\n\nexport const PlutusData = Serialization.PlutusData;\nexport type PlutusData = Serialization.PlutusData;\n\nexport const PlutusList = Serialization.PlutusList;\nexport type PlutusList = Serialization.PlutusList;\n\nexport const PlutusMap = Serialization.PlutusMap;\nexport type PlutusMap = Serialization.PlutusMap;\n\nexport const Redeemers = Serialization.Redeemers;\nexport type Redeemers = Serialization.Redeemers;\n\nexport const Redeemer = Serialization.Redeemer;\nexport type Redeemer = Serialization.Redeemer;\n\nexport const RedeemerPurpose = Cardano.RedeemerPurpose;\nexport type RedeemerPurpose = Cardano.RedeemerPurpose;\n\nexport const RedeemerTag = Serialization.RedeemerTag;\nexport type RedeemerTag = Serialization.RedeemerTag;\n\nexport const Script = Serialization.Script;\nexport type Script = Serialization.Script;\n\nexport const PolicyId = Cardano.PolicyId;\nexport type PolicyId = Cardano.PolicyId;\n\nexport const AssetName = Cardano.AssetName;\nexport type AssetName = Cardano.AssetName;\n\nexport const AssetId = Cardano.AssetId;\nexport type AssetId = Cardano.AssetId;\n\nexport const ScriptHash = Crypto.Hash28ByteBase16;\nexport type ScriptHash = Crypto.Hash28ByteBase16;\n\nexport const Address = Cardano.Address;\nexport type Address = Cardano.Address;\n\nexport const RewardAddress = Cardano.RewardAddress;\nexport type RewardAddress = Cardano.RewardAddress;\n\nexport const AddressType = Cardano.AddressType;\nexport type AddressType = Cardano.AddressType;\n\nexport const BaseAddress = Cardano.BaseAddress;\nexport type BaseAddress = Cardano.BaseAddress;\n\nexport const EnterpriseAddress = Cardano.EnterpriseAddress;\nexport type EnterpriseAddress = Cardano.EnterpriseAddress;\n\nexport const PaymentAddress = Cardano.PaymentAddress;\nexport type PaymentAddress = Cardano.PaymentAddress;\n\nexport const AssetFingerprint = Cardano.AssetFingerprint;\nexport type AssetFingerprint = Cardano.AssetFingerprint;\n\nexport const Credential = Serialization.Credential;\nexport type Credential = Serialization.Credential;\n\nexport type CredentialCore = Cardano.Credential;\n\nexport const Ed25519PublicKeyHex = Crypto.Ed25519PublicKeyHex;\nexport type Ed25519PublicKeyHex = Crypto.Ed25519PublicKeyHex;\n\nexport type Ed25519PrivateNormalKeyHex = OpaqueString<\"Ed25519PrivateKeyHex\">;\nexport const Ed25519PrivateNormalKeyHex = (\n  value: string,\n): Ed25519PrivateNormalKeyHex => typedHex(value, 64);\n\nexport type Ed25519PrivateExtendedKeyHex = OpaqueString<\"Ed25519PrivateKeyHex\">;\nexport const Ed25519PrivateExtendedKeyHex = (\n  value: string,\n): Ed25519PrivateExtendedKeyHex => typedHex(value, 128);\n\nexport const Ed25519KeyHash = Crypto.Ed25519KeyHash;\nexport type Ed25519KeyHash = Crypto.Ed25519KeyHash;\n\nexport const Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;\nexport type Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;\n\nexport const Hash28ByteBase16 = Crypto.Hash28ByteBase16;\nexport type Hash28ByteBase16 = Crypto.Hash28ByteBase16;\n\nexport const Hash32ByteBase16 = (value: string) => {\n  return Crypto.Hash32ByteBase16(value);\n};\nexport type Hash32ByteBase16 = Crypto.Hash32ByteBase16;\n\nexport const CredentialType = Cardano.CredentialType;\nexport type CredentialType = Cardano.CredentialType;\n\nexport const Certificate = Serialization.Certificate;\nexport type Certificate = Serialization.Certificate;\n\nexport const PoolId = Cardano.PoolId;\nexport type PoolId = Cardano.PoolId;\n\nexport const StakeRegistration = Serialization.StakeRegistration;\nexport type StakeRegistration = Serialization.StakeRegistration;\n\nexport const StakeDelegation = Serialization.StakeDelegation;\nexport type StakeDelegation = Serialization.StakeDelegation;\n\nexport type StakeDelegationCertificate = Cardano.StakeDelegationCertificate;\n\nexport const CertificateType = Cardano.CertificateType;\nexport type CertificateType = Cardano.CertificateType;\n\nexport const VkeyWitness = Serialization.VkeyWitness;\nexport type VkeyWitness = Serialization.VkeyWitness;\n\nexport const Ed25519SignatureHex = Crypto.Ed25519SignatureHex;\nexport type Ed25519SignatureHex = Crypto.Ed25519SignatureHex;\n\nexport const Ed25519PublicKey = Crypto.Ed25519PublicKey;\nexport type Ed25519PublicKey = Crypto.Ed25519PublicKey;\n\nexport const Ed25519Signature = Crypto.Ed25519Signature;\nexport type Ed25519Signature = Crypto.Ed25519Signature;\n\nexport const Bip32PrivateKey = Crypto.Bip32PrivateKey;\nexport type Bip32PrivateKey = Crypto.Bip32PrivateKey;\n\nexport const Bip32PrivateKeyHex = Crypto.Bip32PrivateKeyHex;\nexport type Bip32PrivateKeyHex = Crypto.Bip32PrivateKeyHex;\n\nexport const Bip32PublicKey = Crypto.Bip32PublicKey;\nexport type Bip32PublicKey = Crypto.Bip32PublicKey;\n\nexport const Bip32PublicKeyHex = Crypto.Bip32PublicKeyHex;\nexport type Bip32PublicKeyHex = Crypto.Bip32PublicKeyHex;\n\nexport const PlutusLanguageVersion = Cardano.PlutusLanguageVersion;\nexport type PlutusLanguageVersion = Cardano.PlutusLanguageVersion;\n\nexport const NativeScript = Serialization.NativeScript;\nexport type NativeScript = Serialization.NativeScript;\n\nexport const PlutusV1Script = Serialization.PlutusV1Script;\nexport type PlutusV1Script = Serialization.PlutusV1Script;\n\nexport const PlutusV2Script = Serialization.PlutusV2Script;\nexport type PlutusV2Script = Serialization.PlutusV2Script;\n\nexport const PlutusV3Script = Serialization.PlutusV3Script;\nexport type PlutusV3Script = Serialization.PlutusV3Script;\n\nexport const PlutusDataKind = Serialization.PlutusDataKind;\nexport type PlutusDataKind = Serialization.PlutusDataKind;\n\nexport const PointerAddress = Cardano.PointerAddress;\nexport type PointerAddress = Cardano.PointerAddress;\n\nexport const CertIndex = Cardano.CertIndex;\nexport type CertIndex = Cardano.CertIndex;\n\nexport const TxIndex = Cardano.TxIndex;\nexport type TxIndex = Cardano.TxIndex;\n\nexport const Costmdls = Serialization.Costmdls;\nexport type Costmdls = Serialization.Costmdls;\n\nexport const CostModel = Serialization.CostModel;\nexport type CostModel = Serialization.CostModel;\n\nexport const CborWriter = Serialization.CborWriter;\nexport type CborWriter = Serialization.CborWriter;\n\nexport const ConstrPlutusData = Serialization.ConstrPlutusData;\nexport type ConstrPlutusData = Serialization.ConstrPlutusData;\n\nexport const RewardAccount = Cardano.RewardAccount;\nexport type RewardAccount = Cardano.RewardAccount;\n\nexport const Hash = Serialization.Hash;\nexport type Hash<T extends string> = Serialization.Hash<T>;\n\nexport const DatumHash = (value: string) => {\n  return Crypto.Hash32ByteBase16(value);\n};\nexport type DatumHash = Crypto.Hash32ByteBase16;\n\nexport const Datum = Serialization.Datum;\nexport type Datum = PlutusData | DatumHash;\n\nexport type CostModels = Cardano.CostModels;\n\nexport type ExUnits = Serialization.ExUnits;\nexport const ExUnits = Serialization.ExUnits;\n\nexport const NetworkId = Cardano.NetworkId;\nexport type NetworkId = Cardano.ChainId[\"networkId\"];\n\nexport const DatumKind = Serialization.DatumKind;\n\nexport const CborSet = Serialization.CborSet;\n\nexport type Witness = Cardano.Witness;\nexport type Signatures = Cardano.Signatures;\n\nexport type RequireAllOf = Cardano.NativeScriptKind.RequireAllOf;\nexport const RequireAllOf = Cardano.NativeScriptKind.RequireAllOf;\n\nexport type RequireAnyOf = Cardano.NativeScriptKind.RequireAnyOf;\nexport const RequireAnyOf = Cardano.NativeScriptKind.RequireAnyOf;\n\nexport type RequireNOf = Cardano.NativeScriptKind.RequireNOf;\nexport const RequireNOf = Cardano.NativeScriptKind.RequireNOf;\n\nexport type RequireSignature = Cardano.NativeScriptKind.RequireSignature;\nexport const RequireSignature = Cardano.NativeScriptKind.RequireSignature;\n\nexport type RequireTimeAfter = Cardano.NativeScriptKind.RequireTimeAfter;\nexport const RequireTimeAfter = Cardano.NativeScriptKind.RequireTimeAfter;\n\nexport type RequireTimeBefore = Cardano.NativeScriptKind.RequireTimeBefore;\nexport const RequireTimeBefore = Cardano.NativeScriptKind.RequireTimeBefore;\n\nexport type VrfVkBech32 = Cardano.VrfVkBech32;\nexport const VrfVkBech32 = Cardano.VrfVkBech32;\n\nexport type ScriptPubkey = Serialization.ScriptPubkey;\nexport const ScriptPubkey = Serialization.ScriptPubkey;\n\nexport type DRepID = Cardano.DRepID;\nexport const DRepID = Cardano.DRepID;\n\nexport type DRep = Serialization.DRep;\nexport const DRep = Serialization.DRep;\n\nexport type StakeCredentialStatus = Cardano.StakeCredentialStatus;\nexport const StakeCredentialStatus = Cardano.StakeCredentialStatus;\n\nexport type Metadatum = Cardano.Metadatum;\n\nexport type HexBlob = CardanoHexBlob;\nexport const HexBlob = CardanoHexBlob;\n\nexport type TxCBOR = Serialization.TxCBOR;\nexport const TxCBOR = Serialization.TxCBOR;\n\nexport type Ed25519PrivateKey = Crypto.Ed25519PrivateKey;\nexport const Ed25519PrivateKey = Crypto.Ed25519PrivateKey;\n\nexport const computeAuxiliaryDataHash = Cardano.computeAuxiliaryDataHash;\nexport const blake2b = Crypto.blake2b;\n\nexport type BootstrapWitness = Serialization.BootstrapWitness;\nexport const BootstrapWitness = Serialization.BootstrapWitness;\n\nexport type ByronAttributes = Cardano.ByronAttributes;\n",
      "dependencies": [
        "Slot",
        "Slot",
        "Value",
        "Value",
        "TokenMap",
        "Transaction",
        "Transaction",
        "TransactionId",
        "TransactionId",
        "TransactionBody",
        "TransactionBody",
        "TransactionWitnessSet",
        "TransactionWitnessSet",
        "AuxilliaryData",
        "AuxiliaryData",
        "TransactionMetadatum",
        "TransactionMetadatum",
        "MetadatumMap",
        "MetadatumMap",
        "MetadatumList",
        "MetadatumList",
        "TransactionUnspentOutput",
        "TransactionUnspentOutput",
        "TransactionInput",
        "TransactionInput",
        "TransactionOutput",
        "TransactionOutput",
        "TransactionInputSet",
        "TransactionWitnessPlutusData",
        "PlutusData",
        "PlutusData",
        "PlutusList",
        "PlutusList",
        "PlutusMap",
        "PlutusMap",
        "Redeemers",
        "Redeemers",
        "Redeemer",
        "Redeemer",
        "RedeemerPurpose",
        "RedeemerPurpose",
        "RedeemerTag",
        "RedeemerTag",
        "Script",
        "Script",
        "PolicyId",
        "PolicyId",
        "AssetName",
        "AssetName",
        "AssetId",
        "AssetId",
        "ScriptHash",
        "ScriptHash",
        "Address",
        "Address",
        "RewardAddress",
        "RewardAddress",
        "AddressType",
        "AddressType",
        "BaseAddress",
        "BaseAddress",
        "EnterpriseAddress",
        "EnterpriseAddress",
        "PaymentAddress",
        "PaymentAddress",
        "AssetFingerprint",
        "AssetFingerprint",
        "Credential",
        "Credential",
        "CredentialCore",
        "Ed25519PublicKeyHex",
        "Ed25519PublicKeyHex",
        "Ed25519PrivateNormalKeyHex",
        "Ed25519PrivateNormalKeyHex",
        "Ed25519PrivateExtendedKeyHex",
        "Ed25519PrivateExtendedKeyHex",
        "Ed25519KeyHash",
        "Ed25519KeyHash",
        "Ed25519KeyHashHex",
        "Ed25519KeyHashHex",
        "Hash28ByteBase16",
        "Hash28ByteBase16",
        "Hash32ByteBase16",
        "Hash32ByteBase16",
        "CredentialType",
        "CredentialType",
        "Certificate",
        "Certificate",
        "PoolId",
        "PoolId",
        "StakeRegistration",
        "StakeRegistration",
        "StakeDelegation",
        "StakeDelegation",
        "StakeDelegationCertificate",
        "CertificateType",
        "CertificateType",
        "VkeyWitness",
        "VkeyWitness",
        "Ed25519SignatureHex",
        "Ed25519SignatureHex",
        "Ed25519PublicKey",
        "Ed25519PublicKey",
        "Ed25519Signature",
        "Ed25519Signature",
        "Bip32PrivateKey",
        "Bip32PrivateKey",
        "Bip32PrivateKeyHex",
        "Bip32PrivateKeyHex",
        "Bip32PublicKey",
        "Bip32PublicKey",
        "Bip32PublicKeyHex",
        "Bip32PublicKeyHex",
        "PlutusLanguageVersion",
        "PlutusLanguageVersion",
        "NativeScript",
        "NativeScript",
        "PlutusV1Script",
        "PlutusV1Script",
        "PlutusV2Script",
        "PlutusV2Script",
        "PlutusV3Script",
        "PlutusV3Script",
        "PlutusDataKind",
        "PlutusDataKind",
        "PointerAddress",
        "PointerAddress",
        "CertIndex",
        "CertIndex",
        "TxIndex",
        "TxIndex",
        "Costmdls",
        "Costmdls",
        "CostModel",
        "CostModel",
        "CborWriter",
        "CborWriter",
        "ConstrPlutusData",
        "ConstrPlutusData",
        "RewardAccount",
        "RewardAccount",
        "Hash",
        "Hash",
        "DatumHash",
        "DatumHash",
        "Datum",
        "Datum",
        "CostModels",
        "ExUnits",
        "ExUnits",
        "NetworkId",
        "NetworkId",
        "DatumKind",
        "CborSet",
        "Witness",
        "Signatures",
        "RequireAllOf",
        "RequireAllOf",
        "RequireAnyOf",
        "RequireAnyOf",
        "RequireNOf",
        "RequireNOf",
        "RequireSignature",
        "RequireSignature",
        "RequireTimeAfter",
        "RequireTimeAfter",
        "RequireTimeBefore",
        "RequireTimeBefore",
        "VrfVkBech32",
        "VrfVkBech32",
        "ScriptPubkey",
        "ScriptPubkey",
        "DRepID",
        "DRepID",
        "DRep",
        "DRep",
        "StakeCredentialStatus",
        "StakeCredentialStatus",
        "Metadatum",
        "HexBlob",
        "HexBlob",
        "TxCBOR",
        "TxCBOR",
        "Ed25519PrivateKey",
        "Ed25519PrivateKey",
        "computeAuxiliaryDataHash",
        "blake2b",
        "BootstrapWitness",
        "BootstrapWitness",
        "ByronAttributes"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:types.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/types/index.ts",
      "name": "types.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./cardano-sdk\";\nexport * from \"./signer\";\n",
      "dependencies": [],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:types.signer.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/types/signer.ts",
      "name": "types.signer.ts",
      "imports": [
        {
          "module": "Signer",
          "items": [],
          "line": 4,
          "raw": "export type Signer = {",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [],
      "types": [
        {
          "name": "Signer",
          "definition": "export type Signer = {\n  address: Address;\n  key: Ed25519PrivateKey;",
          "isPublic": true,
          "line": 4,
          "raw": "export type Signer = {",
          "source": "mesh-core-cst"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { Address } from \".\";\nimport { Ed25519PrivateKey } from \"./\";\n\nexport type Signer = {\n  address: Address;\n  key: Ed25519PrivateKey;\n};\n",
      "dependencies": [
        "Signer"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:utils.address.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/utils/address.ts",
      "name": "utils.address.ts",
      "imports": [
        {
          "module": "serialzeAddress",
          "items": [],
          "line": 28,
          "raw": "export const serialzeAddress = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "addrBech32ToPlutusDataHex",
          "items": [],
          "line": 136,
          "raw": "export const addrBech32ToPlutusDataHex = (bech32: string): string => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "addrBech32ToPlutusDataObj",
          "items": [],
          "line": 140,
          "raw": "export const addrBech32ToPlutusDataObj = <T>(bech32: string): T => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "serializeAddressObj",
          "items": [],
          "line": 329,
          "raw": "export const serializeAddressObj = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "serializePlutusAddressToBech32",
          "items": [],
          "line": 337,
          "raw": "export const serializePlutusAddressToBech32 = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "deserializeBech32Address",
          "items": [],
          "line": 345,
          "raw": "export const deserializeBech32Address = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "deserializeAddress",
          "items": [],
          "line": 369,
          "raw": "export const deserializeAddress = (address: string): Address => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "scriptHashToBech32",
          "items": [],
          "line": 375,
          "raw": "export const scriptHashToBech32 = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "v2ScriptToBech32",
          "items": [],
          "line": 406,
          "raw": "export const v2ScriptToBech32 = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "scriptHashToRewardAddress",
          "items": [],
          "line": 419,
          "raw": "export const scriptHashToRewardAddress = (hash: string, networkId = 0) => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "keyHashToRewardAddress",
          "items": [],
          "line": 429,
          "raw": "export const keyHashToRewardAddress = (hash: string, networkId = 0) => {",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "serialzeAddress",
          "signature": "export const serialzeAddress = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 28,
          "raw": "export const serialzeAddress = (\n  deserializedAddress: Partial<DeserializedAddress>,\n  networkId = 0,\n) => {\n  const {\n    pubKeyHash,\n    scriptHash,\n    stakeCredentialHash,\n    stakeScriptCredentialHash,\n  } = deserializedAddress;\n\n  const isPaymentScript = !pubKeyHash;\n  const isStakeScript = !stakeCredentialHash;\n\n  const paymentHash = isPaymentScript ? scriptHash : pubKeyHash;\n\n  const stakeHash = isStakeScript\n    ? stakeScriptCredentialHash\n    : stakeCredentialHash;\n\n  if (!paymentHash)\n    throw new Error(\n      \"Error: serializeAddress: Address must contain a payment part\",\n    );\n\n  const addressObj = isPaymentScript\n    ? scriptAddress(paymentHash, stakeHash, isStakeScript)\n    : pubKeyAddress(paymentHash, stakeHash, isStakeScript);\n  return serializeAddressObj(addressObj, networkId);\n};",
          "source": "mesh-core-cst",
          "implementation": "export const serialzeAddress = (\n  deserializedAddress: Partial<DeserializedAddress>,\n  networkId = 0,\n) => {\n  const {\n    pubKeyHash,\n    scriptHash,\n    stakeCredentialHash,\n    stakeScriptCredentialHash,\n  } = deserializedAddress;\n\n  const isPaymentScript = !pubKeyHash;\n  const isStakeScript = !stakeCredentialHash;\n\n  const paymentHash = isPaymentScript ? scriptHash : pubKeyHash;\n\n  const stakeHash = isStakeScript\n    ? stakeScriptCredentialHash\n    : stakeCredentialHash;\n\n  if (!paymentHash)\n    throw new Error(\n      \"Error: serializeAddress: Address must contain a payment part\",\n    );\n\n  const addressObj = isPaymentScript\n    ? scriptAddress(paymentHash, stakeHash, isStakeScript)\n    : pubKeyAddress(paymentHash, stakeHash, isStakeScript);\n  return serializeAddressObj(addressObj, networkId);\n};"
        },
        {
          "name": "addrBech32ToPlutusData",
          "signature": "const addrBech32ToPlutusData = (bech32: string): PlutusData => {",
          "documentation": "",
          "parameters": [
            {
              "name": "bech32",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "PlutusData",
          "isPublic": true,
          "line": 59,
          "raw": "const addrBech32ToPlutusData = (bech32: string): PlutusData => {\n  const cardanoAddress = Address.fromBech32(bech32);\n  const cardanoAddressProps = cardanoAddress.getProps();\n  const paymentPartList = new PlutusList();\n  if (!cardanoAddressProps.paymentPart) {\n    throw new Error(\n      \"Error: addrBech32ToPlutusDataHex: Address must contain a payment part\",\n    );\n  }\n  paymentPartList.add(\n    PlutusData.newBytes(\n      Buffer.from(cardanoAddressProps.paymentPart.hash, \"hex\"),\n    ),\n  );\n  const paymentPart = PlutusData.newConstrPlutusData(\n    new ConstrPlutusData(\n      BigInt(cardanoAddressProps.paymentPart.type),\n      paymentPartList,\n    ),\n  );\n  const delegationPartList = new PlutusList();\n  let delegationPart;\n  if (cardanoAddressProps.delegationPart) {\n    delegationPartList.add(\n      PlutusData.newBytes(\n        Buffer.from(cardanoAddressProps.delegationPart.hash, \"hex\"),\n      ),\n    );\n\n    // Inline(StakeCredential)\n    const inlineDelegationPart = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(0), delegationPartList),\n    );\n\n    // Some(Inline(StakeCredential))\n    const someList = new PlutusList();\n    someList.add(inlineDelegationPart);\n    delegationPart = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(0), someList),\n    );\n  } else if (cardanoAddressProps.pointer) {\n    // Pointer\n    const pointerList = new PlutusList();\n    pointerList.add(\n      PlutusData.newInteger(BigInt(cardanoAddressProps.pointer.slot)),\n    );\n    pointerList.add(\n      PlutusData.newInteger(BigInt(cardanoAddressProps.pointer.txIndex)),\n    );\n    pointerList.add(\n      PlutusData.newInteger(BigInt(cardanoAddressProps.pointer.certIndex)),\n    );\n    const pointer = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(1), pointerList),\n    );\n\n    // Some(Pointer)\n    const someList = new PlutusList();\n    someList.add(pointer);\n    delegationPart = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(0), someList),\n    );\n  } else {\n    delegationPart = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(1), new PlutusList()),\n    );\n  }\n\n  const addressList = new PlutusList();\n  addressList.add(paymentPart);\n  addressList.add(delegationPart);\n\n  return PlutusData.newConstrPlutusData(\n    new ConstrPlutusData(BigInt(0), addressList),\n  );\n};",
          "source": "mesh-core-cst",
          "implementation": "const addrBech32ToPlutusData = (bech32: string): PlutusData => {\n  const cardanoAddress = Address.fromBech32(bech32);\n  const cardanoAddressProps = cardanoAddress.getProps();\n  const paymentPartList = new PlutusList();\n  if (!cardanoAddressProps.paymentPart) {\n    throw new Error(\n      \"Error: addrBech32ToPlutusDataHex: Address must contain a payment part\",\n    );\n  }\n  paymentPartList.add(\n    PlutusData.newBytes(\n      Buffer.from(cardanoAddressProps.paymentPart.hash, \"hex\"),\n    ),\n  );\n  const paymentPart = PlutusData.newConstrPlutusData(\n    new ConstrPlutusData(\n      BigInt(cardanoAddressProps.paymentPart.type),\n      paymentPartList,\n    ),\n  );\n  const delegationPartList = new PlutusList();\n  let delegationPart;\n  if (cardanoAddressProps.delegationPart) {\n    delegationPartList.add(\n      PlutusData.newBytes(\n        Buffer.from(cardanoAddressProps.delegationPart.hash, \"hex\"),\n      ),\n    );\n\n    // Inline(StakeCredential)\n    const inlineDelegationPart = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(0), delegationPartList),\n    );\n\n    // Some(Inline(StakeCredential))\n    const someList = new PlutusList();\n    someList.add(inlineDelegationPart);\n    delegationPart = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(0), someList),\n    );\n  } else if (cardanoAddressProps.pointer) {\n    // Pointer\n    const pointerList = new PlutusList();\n    pointerList.add(\n      PlutusData.newInteger(BigInt(cardanoAddressProps.pointer.slot)),\n    );\n    pointerList.add(\n      PlutusData.newInteger(BigInt(cardanoAddressProps.pointer.txIndex)),\n    );\n    pointerList.add(\n      PlutusData.newInteger(BigInt(cardanoAddressProps.pointer.certIndex)),\n    );\n    const pointer = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(1), pointerList),\n    );\n\n    // Some(Pointer)\n    const someList = new PlutusList();\n    someList.add(pointer);\n    delegationPart = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(0), someList),\n    );\n  } else {\n    delegationPart = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(1), new PlutusList()),\n    );\n  }\n\n  const addressList = new PlutusList();\n  addressList.add(paymentPart);\n  addressList.add(delegationPart);\n\n  return PlutusData.newConstrPlutusData(\n    new ConstrPlutusData(BigInt(0), addressList),\n  );\n};"
        },
        {
          "name": "addrBech32ToPlutusDataHex",
          "signature": "export const addrBech32ToPlutusDataHex = (bech32: string): string => {",
          "documentation": "",
          "parameters": [
            {
              "name": "bech32",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 136,
          "raw": "export const addrBech32ToPlutusDataHex = (bech32: string): string => {\n  return addrBech32ToPlutusData(bech32).toCbor();\n};",
          "source": "mesh-core-cst",
          "implementation": "export const addrBech32ToPlutusDataHex = (bech32: string): string => {\n  return addrBech32ToPlutusData(bech32).toCbor();\n};"
        },
        {
          "name": "plutusDataToAddrBech32",
          "signature": "const plutusDataToAddrBech32 = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 144,
          "raw": "const plutusDataToAddrBech32 = (\n  plutusData: PlutusData,\n  networkId = 0,\n): string => {\n  const constrPlutusData = plutusData.asConstrPlutusData();\n  if (!constrPlutusData || constrPlutusData.getAlternative() !== BigInt(0)) {\n    throw new Error(\n      \"Error: serializeAddressObj: Address must contain a constructor 0\",\n    );\n  }\n\n  const plutusDataList = constrPlutusData.getData();\n  if (plutusDataList.getLength() !== 2) {\n    throw new Error(\"Error: serializeAddressObj: Address must contain 2 parts\");\n  }\n\n  const paymentData = plutusDataList.get(0);\n  const paymentConstrData = paymentData.asConstrPlutusData();\n  if (!paymentConstrData) {\n    throw new Error(\n      \"Error: serializeAddressObj: Payment part must be a constructor\",\n    );\n  }\n\n  const paymentConstrDataList = paymentConstrData.getData();\n  if (paymentConstrDataList.getLength() !== 1) {\n    throw new Error(\n      \"Error: serializeAddressObj: Payment part must contain 1 element\",\n    );\n  }\n\n  const paymentBytes = paymentConstrDataList.get(0).asBoundedBytes();\n  if (!paymentBytes) {\n    throw new Error(\n      \"Error: serializeAddressObj: Payment inner part must be bytes\",\n    );\n  }\n\n  if (\n    paymentConstrData.getAlternative() !== BigInt(0) &&\n    paymentConstrData.getAlternative() !== BigInt(1)\n  ) {\n    throw new Error(\n      \"Error: serializeAddressObj: Payment part must be alternative 0 or 1\",\n    );\n  }\n  const cardanoPaymentCredential = {\n    hash: Hash28ByteBase16(Buffer.from(paymentBytes).toString(\"hex\")),\n    type: Number(paymentConstrData.getAlternative()),\n  };\n\n  const delegationData = plutusDataList.get(1);\n  // Option<Referenced<Credential>>\n  const delegationConstrData = delegationData.asConstrPlutusData();\n  if (!delegationConstrData) {\n    throw new Error(\n      \"Error: serializeAddressObj: Delegation part must be a constructor\",\n    );\n  }\n\n  if (delegationConstrData.getAlternative() === BigInt(1)) {\n    return EnterpriseAddress.fromCredentials(\n      networkId,\n      cardanoPaymentCredential,\n    )\n      .toAddress()\n      .toBech32()\n      .toString();\n  } else if (delegationConstrData.getAlternative() === BigInt(0)) {\n    const delegationDataList = delegationConstrData.getData();\n    if (delegationDataList.getLength() !== 1) {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation part must contain 1 element\",\n      );\n    }\n\n    const delegationDataInner = delegationDataList.get(0);\n    // Referenced<Credential>\n    const delegationDataInnerConstrData =\n      delegationDataInner.asConstrPlutusData();\n    if (!delegationDataInnerConstrData) {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation inner part must be a constructor\",\n      );\n    }\n\n    if (delegationDataInnerConstrData.getAlternative() === BigInt(0)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 1 element\",\n        );\n      }\n      // Credential\n      const delegationCredential = delegationDataInnerList\n        .get(0)\n        .asConstrPlutusData();\n      if (!delegationCredential) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must be a constructor\",\n        );\n      }\n\n      const delegationBytesList = delegationCredential.getData();\n      if (delegationBytesList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must contain 1 element\",\n        );\n      }\n\n      const delegationBytes = delegationBytesList.get(0).asBoundedBytes();\n      if (!delegationBytes) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must be of type bytes\",\n        );\n      }\n\n      const cardanoStakeCredential = {\n        hash: Hash28ByteBase16(Buffer.from(delegationBytes).toString(\"hex\")),\n        type: Number(delegationCredential.getAlternative()),\n      };\n\n      return BaseAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoStakeCredential,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else if (delegationDataInnerConstrData.getAlternative() === BigInt(1)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 3) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 3 elements\",\n        );\n      }\n\n      const slot = delegationDataInnerList.get(0).asInteger();\n      if (!slot) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part slot must be integer\",\n        );\n      }\n\n      const txIndex = delegationDataInnerList.get(1).asInteger();\n      if (!txIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part txIndex must be integer\",\n        );\n      }\n\n      const certIndex = delegationDataInnerList.get(2).asInteger();\n      if (!certIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part certIndex must be integer\",\n        );\n      }\n\n      const cardanoPointer = {\n        slot: slot,\n        txIndex: TxIndex(Number(txIndex)),\n        certIndex: CertIndex(Number(certIndex)),\n      };\n\n      return PointerAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoPointer,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation inner part must be alternative 0 or 1\",\n      );\n    }\n  } else {\n    throw new Error(\n      \"Error: serializeAddressObj: Delegation part must be alternative 0 or 1\",\n    );\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "const plutusDataToAddrBech32 = (\n  plutusData: PlutusData,\n  networkId = 0,\n): string => {\n  const constrPlutusData = plutusData.asConstrPlutusData();\n  if (!constrPlutusData || constrPlutusData.getAlternative() !== BigInt(0)) {\n    throw new Error(\n      \"Error: serializeAddressObj: Address must contain a constructor 0\",\n    );\n  }\n\n  const plutusDataList = constrPlutusData.getData();\n  if (plutusDataList.getLength() !== 2) {\n    throw new Error(\"Error: serializeAddressObj: Address must contain 2 parts\");\n  }\n\n  const paymentData = plutusDataList.get(0);\n  const paymentConstrData = paymentData.asConstrPlutusData();\n  if (!paymentConstrData) {\n    throw new Error(\n      \"Error: serializeAddressObj: Payment part must be a constructor\",\n    );\n  }\n\n  const paymentConstrDataList = paymentConstrData.getData();\n  if (paymentConstrDataList.getLength() !== 1) {\n    throw new Error(\n      \"Error: serializeAddressObj: Payment part must contain 1 element\",\n    );\n  }\n\n  const paymentBytes = paymentConstrDataList.get(0).asBoundedBytes();\n  if (!paymentBytes) {\n    throw new Error(\n      \"Error: serializeAddressObj: Payment inner part must be bytes\",\n    );\n  }\n\n  if (\n    paymentConstrData.getAlternative() !== BigInt(0) &&\n    paymentConstrData.getAlternative() !== BigInt(1)\n  ) {\n    throw new Error(\n      \"Error: serializeAddressObj: Payment part must be alternative 0 or 1\",\n    );\n  }\n  const cardanoPaymentCredential = {\n    hash: Hash28ByteBase16(Buffer.from(paymentBytes).toString(\"hex\")),\n    type: Number(paymentConstrData.getAlternative()),\n  };\n\n  const delegationData = plutusDataList.get(1);\n  // Option<Referenced<Credential>>\n  const delegationConstrData = delegationData.asConstrPlutusData();\n  if (!delegationConstrData) {\n    throw new Error(\n      \"Error: serializeAddressObj: Delegation part must be a constructor\",\n    );\n  }\n\n  if (delegationConstrData.getAlternative() === BigInt(1)) {\n    return EnterpriseAddress.fromCredentials(\n      networkId,\n      cardanoPaymentCredential,\n    )\n      .toAddress()\n      .toBech32()\n      .toString();\n  } else if (delegationConstrData.getAlternative() === BigInt(0)) {\n    const delegationDataList = delegationConstrData.getData();\n    if (delegationDataList.getLength() !== 1) {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation part must contain 1 element\",\n      );\n    }\n\n    const delegationDataInner = delegationDataList.get(0);\n    // Referenced<Credential>\n    const delegationDataInnerConstrData =\n      delegationDataInner.asConstrPlutusData();\n    if (!delegationDataInnerConstrData) {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation inner part must be a constructor\",\n      );\n    }\n\n    if (delegationDataInnerConstrData.getAlternative() === BigInt(0)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 1 element\",\n        );\n      }\n      // Credential\n      const delegationCredential = delegationDataInnerList\n        .get(0)\n        .asConstrPlutusData();\n      if (!delegationCredential) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must be a constructor\",\n        );\n      }\n\n      const delegationBytesList = delegationCredential.getData();\n      if (delegationBytesList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must contain 1 element\",\n        );\n      }\n\n      const delegationBytes = delegationBytesList.get(0).asBoundedBytes();\n      if (!delegationBytes) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must be of type bytes\",\n        );\n      }\n\n      const cardanoStakeCredential = {\n        hash: Hash28ByteBase16(Buffer.from(delegationBytes).toString(\"hex\")),\n        type: Number(delegationCredential.getAlternative()),\n      };\n\n      return BaseAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoStakeCredential,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else if (delegationDataInnerConstrData.getAlternative() === BigInt(1)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 3) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 3 elements\",\n        );\n      }\n\n      const slot = delegationDataInnerList.get(0).asInteger();\n      if (!slot) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part slot must be integer\",\n        );\n      }\n\n      const txIndex = delegationDataInnerList.get(1).asInteger();\n      if (!txIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part txIndex must be integer\",\n        );\n      }\n\n      const certIndex = delegationDataInnerList.get(2).asInteger();\n      if (!certIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part certIndex must be integer\",\n        );\n      }\n\n      const cardanoPointer = {\n        slot: slot,\n        txIndex: TxIndex(Number(txIndex)),\n        certIndex: CertIndex(Number(certIndex)),\n      };\n\n      return PointerAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoPointer,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation inner part must be alternative 0 or 1\",\n      );\n    }\n  } else {\n    throw new Error(\n      \"Error: serializeAddressObj: Delegation part must be alternative 0 or 1\",\n    );\n  }\n};"
        },
        {
          "name": "if",
          "signature": "if (delegationConstrData.getAlternative() === BigInt(1)) {",
          "documentation": "",
          "parameters": [
            {
              "name": "delegationConstrData.getAlternative(",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 204,
          "raw": "  if (delegationConstrData.getAlternative() === BigInt(1)) {\n    return EnterpriseAddress.fromCredentials(\n      networkId,\n      cardanoPaymentCredential,\n    )\n      .toAddress()\n      .toBech32()\n      .toString();\n  } else if (delegationConstrData.getAlternative() === BigInt(0)) {\n    const delegationDataList = delegationConstrData.getData();\n    if (delegationDataList.getLength() !== 1) {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation part must contain 1 element\",\n      );\n    }\n\n    const delegationDataInner = delegationDataList.get(0);\n    // Referenced<Credential>\n    const delegationDataInnerConstrData =\n      delegationDataInner.asConstrPlutusData();\n    if (!delegationDataInnerConstrData) {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation inner part must be a constructor\",\n      );\n    }\n\n    if (delegationDataInnerConstrData.getAlternative() === BigInt(0)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 1 element\",\n        );\n      }\n      // Credential\n      const delegationCredential = delegationDataInnerList\n        .get(0)\n        .asConstrPlutusData();\n      if (!delegationCredential) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must be a constructor\",\n        );\n      }\n\n      const delegationBytesList = delegationCredential.getData();\n      if (delegationBytesList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must contain 1 element\",\n        );\n      }\n\n      const delegationBytes = delegationBytesList.get(0).asBoundedBytes();\n      if (!delegationBytes) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must be of type bytes\",\n        );\n      }\n\n      const cardanoStakeCredential = {\n        hash: Hash28ByteBase16(Buffer.from(delegationBytes).toString(\"hex\")),\n        type: Number(delegationCredential.getAlternative()),\n      };\n\n      return BaseAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoStakeCredential,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else if (delegationDataInnerConstrData.getAlternative() === BigInt(1)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 3) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 3 elements\",\n        );\n      }\n\n      const slot = delegationDataInnerList.get(0).asInteger();\n      if (!slot) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part slot must be integer\",\n        );\n      }\n\n      const txIndex = delegationDataInnerList.get(1).asInteger();\n      if (!txIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part txIndex must be integer\",\n        );\n      }\n\n      const certIndex = delegationDataInnerList.get(2).asInteger();\n      if (!certIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part certIndex must be integer\",\n        );\n      }\n\n      const cardanoPointer = {\n        slot: slot,\n        txIndex: TxIndex(Number(txIndex)),\n        certIndex: CertIndex(Number(certIndex)),\n      };\n\n      return PointerAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoPointer,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation inner part must be alternative 0 or 1\",\n      );\n    }\n  } else {\n    throw new Error(\n      \"Error: serializeAddressObj: Delegation part must be alternative 0 or 1\",\n    );\n  }",
          "source": "mesh-core-cst",
          "implementation": "  if (delegationConstrData.getAlternative() === BigInt(1)) {\n    return EnterpriseAddress.fromCredentials(\n      networkId,\n      cardanoPaymentCredential,\n    )\n      .toAddress()\n      .toBech32()\n      .toString();\n  } else if (delegationConstrData.getAlternative() === BigInt(0)) {\n    const delegationDataList = delegationConstrData.getData();\n    if (delegationDataList.getLength() !== 1) {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation part must contain 1 element\",\n      );\n    }\n\n    const delegationDataInner = delegationDataList.get(0);\n    // Referenced<Credential>\n    const delegationDataInnerConstrData =\n      delegationDataInner.asConstrPlutusData();\n    if (!delegationDataInnerConstrData) {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation inner part must be a constructor\",\n      );\n    }\n\n    if (delegationDataInnerConstrData.getAlternative() === BigInt(0)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 1 element\",\n        );\n      }\n      // Credential\n      const delegationCredential = delegationDataInnerList\n        .get(0)\n        .asConstrPlutusData();\n      if (!delegationCredential) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must be a constructor\",\n        );\n      }\n\n      const delegationBytesList = delegationCredential.getData();\n      if (delegationBytesList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must contain 1 element\",\n        );\n      }\n\n      const delegationBytes = delegationBytesList.get(0).asBoundedBytes();\n      if (!delegationBytes) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must be of type bytes\",\n        );\n      }\n\n      const cardanoStakeCredential = {\n        hash: Hash28ByteBase16(Buffer.from(delegationBytes).toString(\"hex\")),\n        type: Number(delegationCredential.getAlternative()),\n      };\n\n      return BaseAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoStakeCredential,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else if (delegationDataInnerConstrData.getAlternative() === BigInt(1)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 3) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 3 elements\",\n        );\n      }\n\n      const slot = delegationDataInnerList.get(0).asInteger();\n      if (!slot) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part slot must be integer\",\n        );\n      }\n\n      const txIndex = delegationDataInnerList.get(1).asInteger();\n      if (!txIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part txIndex must be integer\",\n        );\n      }\n\n      const certIndex = delegationDataInnerList.get(2).asInteger();\n      if (!certIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part certIndex must be integer\",\n        );\n      }\n\n      const cardanoPointer = {\n        slot: slot,\n        txIndex: TxIndex(Number(txIndex)),\n        certIndex: CertIndex(Number(certIndex)),\n      };\n\n      return PointerAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoPointer,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation inner part must be alternative 0 or 1\",\n      );\n    }\n  } else {\n    throw new Error(\n      \"Error: serializeAddressObj: Delegation part must be alternative 0 or 1\",\n    );\n  }"
        },
        {
          "name": "if",
          "signature": "if (delegationDataInnerConstrData.getAlternative() === BigInt(0)) {",
          "documentation": "",
          "parameters": [
            {
              "name": "delegationDataInnerConstrData.getAlternative(",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 230,
          "raw": "    if (delegationDataInnerConstrData.getAlternative() === BigInt(0)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 1 element\",\n        );\n      }\n      // Credential\n      const delegationCredential = delegationDataInnerList\n        .get(0)\n        .asConstrPlutusData();\n      if (!delegationCredential) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must be a constructor\",\n        );\n      }\n\n      const delegationBytesList = delegationCredential.getData();\n      if (delegationBytesList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must contain 1 element\",\n        );\n      }\n\n      const delegationBytes = delegationBytesList.get(0).asBoundedBytes();\n      if (!delegationBytes) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must be of type bytes\",\n        );\n      }\n\n      const cardanoStakeCredential = {\n        hash: Hash28ByteBase16(Buffer.from(delegationBytes).toString(\"hex\")),\n        type: Number(delegationCredential.getAlternative()),\n      };\n\n      return BaseAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoStakeCredential,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else if (delegationDataInnerConstrData.getAlternative() === BigInt(1)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 3) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 3 elements\",\n        );\n      }\n\n      const slot = delegationDataInnerList.get(0).asInteger();\n      if (!slot) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part slot must be integer\",\n        );\n      }\n\n      const txIndex = delegationDataInnerList.get(1).asInteger();\n      if (!txIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part txIndex must be integer\",\n        );\n      }\n\n      const certIndex = delegationDataInnerList.get(2).asInteger();\n      if (!certIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part certIndex must be integer\",\n        );\n      }\n\n      const cardanoPointer = {\n        slot: slot,\n        txIndex: TxIndex(Number(txIndex)),\n        certIndex: CertIndex(Number(certIndex)),\n      };\n\n      return PointerAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoPointer,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation inner part must be alternative 0 or 1\",\n      );\n    }",
          "source": "mesh-core-cst",
          "implementation": "    if (delegationDataInnerConstrData.getAlternative() === BigInt(0)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 1 element\",\n        );\n      }\n      // Credential\n      const delegationCredential = delegationDataInnerList\n        .get(0)\n        .asConstrPlutusData();\n      if (!delegationCredential) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must be a constructor\",\n        );\n      }\n\n      const delegationBytesList = delegationCredential.getData();\n      if (delegationBytesList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must contain 1 element\",\n        );\n      }\n\n      const delegationBytes = delegationBytesList.get(0).asBoundedBytes();\n      if (!delegationBytes) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must be of type bytes\",\n        );\n      }\n\n      const cardanoStakeCredential = {\n        hash: Hash28ByteBase16(Buffer.from(delegationBytes).toString(\"hex\")),\n        type: Number(delegationCredential.getAlternative()),\n      };\n\n      return BaseAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoStakeCredential,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else if (delegationDataInnerConstrData.getAlternative() === BigInt(1)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 3) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 3 elements\",\n        );\n      }\n\n      const slot = delegationDataInnerList.get(0).asInteger();\n      if (!slot) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part slot must be integer\",\n        );\n      }\n\n      const txIndex = delegationDataInnerList.get(1).asInteger();\n      if (!txIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part txIndex must be integer\",\n        );\n      }\n\n      const certIndex = delegationDataInnerList.get(2).asInteger();\n      if (!certIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part certIndex must be integer\",\n        );\n      }\n\n      const cardanoPointer = {\n        slot: slot,\n        txIndex: TxIndex(Number(txIndex)),\n        certIndex: CertIndex(Number(certIndex)),\n      };\n\n      return PointerAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoPointer,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation inner part must be alternative 0 or 1\",\n      );\n    }"
        },
        {
          "name": "serializeAddressObj",
          "signature": "export const serializeAddressObj = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 329,
          "raw": "export const serializeAddressObj = (\n  plutusDataAddressObject: PubKeyAddress | ScriptAddress,\n  networkId = 0,\n): string => {\n  const cardanoPlutusData = fromJsonToPlutusData(plutusDataAddressObject);\n  return plutusDataToAddrBech32(cardanoPlutusData, networkId);\n};",
          "source": "mesh-core-cst",
          "implementation": "export const serializeAddressObj = (\n  plutusDataAddressObject: PubKeyAddress | ScriptAddress,\n  networkId = 0,\n): string => {\n  const cardanoPlutusData = fromJsonToPlutusData(plutusDataAddressObject);\n  return plutusDataToAddrBech32(cardanoPlutusData, networkId);\n};"
        },
        {
          "name": "serializePlutusAddressToBech32",
          "signature": "export const serializePlutusAddressToBech32 = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 337,
          "raw": "export const serializePlutusAddressToBech32 = (\n  plutusHex: string,\n  networkId = 0,\n) => {\n  const cardanoPlutusData = PlutusData.fromCbor(HexBlob(plutusHex));\n  return plutusDataToAddrBech32(cardanoPlutusData, networkId).toString();\n};",
          "source": "mesh-core-cst",
          "implementation": "export const serializePlutusAddressToBech32 = (\n  plutusHex: string,\n  networkId = 0,\n) => {\n  const cardanoPlutusData = PlutusData.fromCbor(HexBlob(plutusHex));\n  return plutusDataToAddrBech32(cardanoPlutusData, networkId).toString();\n};"
        },
        {
          "name": "deserializeBech32Address",
          "signature": "export const deserializeBech32Address = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 345,
          "raw": "export const deserializeBech32Address = (\n  bech32Addr: string,\n): DeserializedAddress => {\n  const deserializedAddress = Address.fromBech32(bech32Addr).getProps();\n  return {\n    pubKeyHash:\n      deserializedAddress.paymentPart?.type === CredentialType.KeyHash\n        ? deserializedAddress.paymentPart?.hash\n        : \"\",\n    scriptHash:\n      deserializedAddress.paymentPart?.type === CredentialType.ScriptHash\n        ? deserializedAddress.paymentPart?.hash\n        : \"\",\n    stakeCredentialHash:\n      deserializedAddress.delegationPart?.type === CredentialType.KeyHash\n        ? deserializedAddress.delegationPart?.hash\n        : \"\",\n    stakeScriptCredentialHash:\n      deserializedAddress.delegationPart?.type === CredentialType.ScriptHash\n        ? deserializedAddress.delegationPart?.hash\n        : \"\",\n  };\n};",
          "source": "mesh-core-cst",
          "implementation": "export const deserializeBech32Address = (\n  bech32Addr: string,\n): DeserializedAddress => {\n  const deserializedAddress = Address.fromBech32(bech32Addr).getProps();\n  return {\n    pubKeyHash:\n      deserializedAddress.paymentPart?.type === CredentialType.KeyHash\n        ? deserializedAddress.paymentPart?.hash\n        : \"\",\n    scriptHash:\n      deserializedAddress.paymentPart?.type === CredentialType.ScriptHash\n        ? deserializedAddress.paymentPart?.hash\n        : \"\",\n    stakeCredentialHash:\n      deserializedAddress.delegationPart?.type === CredentialType.KeyHash\n        ? deserializedAddress.delegationPart?.hash\n        : \"\",\n    stakeScriptCredentialHash:\n      deserializedAddress.delegationPart?.type === CredentialType.ScriptHash\n        ? deserializedAddress.delegationPart?.hash\n        : \"\",\n  };\n};"
        },
        {
          "name": "deserializeAddress",
          "signature": "export const deserializeAddress = (address: string): Address => {",
          "documentation": "",
          "parameters": [
            {
              "name": "address",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Address",
          "isPublic": true,
          "line": 369,
          "raw": "export const deserializeAddress = (address: string): Address => {\n  const _address = Address.fromString(address);\n  if (_address === null) throw new Error(\"Invalid address\");\n  return _address;\n};",
          "source": "mesh-core-cst",
          "implementation": "export const deserializeAddress = (address: string): Address => {\n  const _address = Address.fromString(address);\n  if (_address === null) throw new Error(\"Invalid address\");\n  return _address;\n};"
        },
        {
          "name": "scriptHashToBech32",
          "signature": "export const scriptHashToBech32 = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 375,
          "raw": "export const scriptHashToBech32 = (\n  scriptHash: string,\n  stakeCredentialHash?: string,\n  networkId = 0,\n  isScriptStakeCredentialHash = false,\n) => {\n  if (stakeCredentialHash) {\n    return BaseAddress.fromCredentials(\n      networkId,\n      { hash: Hash28ByteBase16(scriptHash), type: CredentialType.ScriptHash },\n      {\n        hash: Hash28ByteBase16(stakeCredentialHash),\n        type: isScriptStakeCredentialHash\n          ? CredentialType.ScriptHash\n          : CredentialType.KeyHash,\n      },\n    )\n      .toAddress()\n      .toBech32()\n      .toString();\n  } else {\n    return EnterpriseAddress.fromCredentials(networkId, {\n      hash: Hash28ByteBase16(scriptHash),\n      type: CredentialType.ScriptHash,\n    })\n      .toAddress()\n      .toBech32()\n      .toString();\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const scriptHashToBech32 = (\n  scriptHash: string,\n  stakeCredentialHash?: string,\n  networkId = 0,\n  isScriptStakeCredentialHash = false,\n) => {\n  if (stakeCredentialHash) {\n    return BaseAddress.fromCredentials(\n      networkId,\n      { hash: Hash28ByteBase16(scriptHash), type: CredentialType.ScriptHash },\n      {\n        hash: Hash28ByteBase16(stakeCredentialHash),\n        type: isScriptStakeCredentialHash\n          ? CredentialType.ScriptHash\n          : CredentialType.KeyHash,\n      },\n    )\n      .toAddress()\n      .toBech32()\n      .toString();\n  } else {\n    return EnterpriseAddress.fromCredentials(networkId, {\n      hash: Hash28ByteBase16(scriptHash),\n      type: CredentialType.ScriptHash,\n    })\n      .toAddress()\n      .toBech32()\n      .toString();\n  }\n};"
        },
        {
          "name": "v2ScriptToBech32",
          "signature": "export const v2ScriptToBech32 = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 406,
          "raw": "export const v2ScriptToBech32 = (\n  scriptCbor: string,\n  stakeCredential?: string,\n  networkId = 0,\n  isScriptStakeCredential = false,\n) =>\n  scriptHashToBech32(\n    Script.fromCbor(HexBlob(scriptCbor)).hash().toString(),\n    stakeCredential,\n    networkId,\n    isScriptStakeCredential,\n  );\n\nexport const scriptHashToRewardAddress = (hash: string, networkId = 0) => {\n  return RewardAddress.fromCredentials(networkId, {\n    hash: Hash28ByteBase16(hash),\n    type: CredentialType.ScriptHash,\n  })\n    .toAddress()\n    .toBech32()\n    .toString();\n};",
          "source": "mesh-core-cst",
          "implementation": "export const v2ScriptToBech32 = (\n  scriptCbor: string,\n  stakeCredential?: string,\n  networkId = 0,\n  isScriptStakeCredential = false,\n) =>\n  scriptHashToBech32(\n    Script.fromCbor(HexBlob(scriptCbor)).hash().toString(),\n    stakeCredential,\n    networkId,\n    isScriptStakeCredential,\n  );\n\nexport const scriptHashToRewardAddress = (hash: string, networkId = 0) => {\n  return RewardAddress.fromCredentials(networkId, {\n    hash: Hash28ByteBase16(hash),\n    type: CredentialType.ScriptHash,\n  })\n    .toAddress()\n    .toBech32()\n    .toString();\n};"
        },
        {
          "name": "scriptHashToRewardAddress",
          "signature": "export const scriptHashToRewardAddress = (hash: string, networkId = 0) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "hash",
              "type": "string",
              "optional": false
            },
            {
              "name": "networkId",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 419,
          "raw": "export const scriptHashToRewardAddress = (hash: string, networkId = 0) => {\n  return RewardAddress.fromCredentials(networkId, {\n    hash: Hash28ByteBase16(hash),\n    type: CredentialType.ScriptHash,\n  })\n    .toAddress()\n    .toBech32()\n    .toString();\n};",
          "source": "mesh-core-cst",
          "implementation": "export const scriptHashToRewardAddress = (hash: string, networkId = 0) => {\n  return RewardAddress.fromCredentials(networkId, {\n    hash: Hash28ByteBase16(hash),\n    type: CredentialType.ScriptHash,\n  })\n    .toAddress()\n    .toBech32()\n    .toString();\n};"
        },
        {
          "name": "keyHashToRewardAddress",
          "signature": "export const keyHashToRewardAddress = (hash: string, networkId = 0) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "hash",
              "type": "string",
              "optional": false
            },
            {
              "name": "networkId",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 429,
          "raw": "export const keyHashToRewardAddress = (hash: string, networkId = 0) => {\n  return RewardAddress.fromCredentials(networkId, {\n    hash: Hash28ByteBase16(hash),\n    type: CredentialType.KeyHash,\n  })\n    .toAddress()\n    .toBech32()\n    .toString();\n};",
          "source": "mesh-core-cst",
          "implementation": "export const keyHashToRewardAddress = (hash: string, networkId = 0) => {\n  return RewardAddress.fromCredentials(networkId, {\n    hash: Hash28ByteBase16(hash),\n    type: CredentialType.KeyHash,\n  })\n    .toAddress()\n    .toBech32()\n    .toString();\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "serialzeAddress",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 28,
          "raw": "export const serialzeAddress = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "isPaymentScript",
          "type": "any",
          "value": "!pubKeyHash;",
          "isPublic": true,
          "line": 39,
          "raw": "const isPaymentScript = !pubKeyHash;",
          "source": "mesh-core-cst"
        },
        {
          "name": "isStakeScript",
          "type": "any",
          "value": "!stakeCredentialHash;",
          "isPublic": true,
          "line": 40,
          "raw": "const isStakeScript = !stakeCredentialHash;",
          "source": "mesh-core-cst"
        },
        {
          "name": "paymentHash",
          "type": "any",
          "value": "isPaymentScript ? scriptHash : pubKeyHash;",
          "isPublic": true,
          "line": 42,
          "raw": "const paymentHash = isPaymentScript ? scriptHash : pubKeyHash;",
          "source": "mesh-core-cst"
        },
        {
          "name": "stakeHash",
          "type": "any",
          "value": "isStakeScript",
          "isPublic": true,
          "line": 44,
          "raw": "const stakeHash = isStakeScript",
          "source": "mesh-core-cst"
        },
        {
          "name": "addressObj",
          "type": "any",
          "value": "isPaymentScript",
          "isPublic": true,
          "line": 53,
          "raw": "const addressObj = isPaymentScript",
          "source": "mesh-core-cst"
        },
        {
          "name": "addrBech32ToPlutusData",
          "type": "any",
          "value": "(bech32: string): PlutusData => {",
          "isPublic": true,
          "line": 59,
          "raw": "const addrBech32ToPlutusData = (bech32: string): PlutusData => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "cardanoAddress",
          "type": "any",
          "value": "Address.fromBech32(bech32);",
          "isPublic": true,
          "line": 60,
          "raw": "const cardanoAddress = Address.fromBech32(bech32);",
          "source": "mesh-core-cst"
        },
        {
          "name": "cardanoAddressProps",
          "type": "any",
          "value": "cardanoAddress.getProps();",
          "isPublic": true,
          "line": 61,
          "raw": "const cardanoAddressProps = cardanoAddress.getProps();",
          "source": "mesh-core-cst"
        },
        {
          "name": "paymentPartList",
          "type": "any",
          "value": "new PlutusList();",
          "isPublic": true,
          "line": 62,
          "raw": "const paymentPartList = new PlutusList();",
          "source": "mesh-core-cst"
        },
        {
          "name": "paymentPart",
          "type": "any",
          "value": "PlutusData.newConstrPlutusData(",
          "isPublic": true,
          "line": 73,
          "raw": "const paymentPart = PlutusData.newConstrPlutusData(",
          "source": "mesh-core-cst"
        },
        {
          "name": "delegationPartList",
          "type": "any",
          "value": "new PlutusList();",
          "isPublic": true,
          "line": 79,
          "raw": "const delegationPartList = new PlutusList();",
          "source": "mesh-core-cst"
        },
        {
          "name": "inlineDelegationPart",
          "type": "any",
          "value": "PlutusData.newConstrPlutusData(",
          "isPublic": true,
          "line": 89,
          "raw": "const inlineDelegationPart = PlutusData.newConstrPlutusData(",
          "source": "mesh-core-cst"
        },
        {
          "name": "someList",
          "type": "any",
          "value": "new PlutusList();",
          "isPublic": true,
          "line": 94,
          "raw": "const someList = new PlutusList();",
          "source": "mesh-core-cst"
        },
        {
          "name": "pointerList",
          "type": "any",
          "value": "new PlutusList();",
          "isPublic": true,
          "line": 101,
          "raw": "const pointerList = new PlutusList();",
          "source": "mesh-core-cst"
        },
        {
          "name": "pointer",
          "type": "any",
          "value": "PlutusData.newConstrPlutusData(",
          "isPublic": true,
          "line": 111,
          "raw": "const pointer = PlutusData.newConstrPlutusData(",
          "source": "mesh-core-cst"
        },
        {
          "name": "someList",
          "type": "any",
          "value": "new PlutusList();",
          "isPublic": true,
          "line": 116,
          "raw": "const someList = new PlutusList();",
          "source": "mesh-core-cst"
        },
        {
          "name": "addressList",
          "type": "any",
          "value": "new PlutusList();",
          "isPublic": true,
          "line": 127,
          "raw": "const addressList = new PlutusList();",
          "source": "mesh-core-cst"
        },
        {
          "name": "addrBech32ToPlutusDataHex",
          "type": "any",
          "value": "(bech32: string): string => {",
          "isPublic": true,
          "line": 136,
          "raw": "export const addrBech32ToPlutusDataHex = (bech32: string): string => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "addrBech32ToPlutusDataObj",
          "type": "any",
          "value": "<T>(bech32: string): T => {",
          "isPublic": true,
          "line": 140,
          "raw": "export const addrBech32ToPlutusDataObj = <T>(bech32: string): T => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusDataToAddrBech32",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 144,
          "raw": "const plutusDataToAddrBech32 = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "constrPlutusData",
          "type": "any",
          "value": "plutusData.asConstrPlutusData();",
          "isPublic": true,
          "line": 148,
          "raw": "const constrPlutusData = plutusData.asConstrPlutusData();",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusDataList",
          "type": "any",
          "value": "constrPlutusData.getData();",
          "isPublic": true,
          "line": 155,
          "raw": "const plutusDataList = constrPlutusData.getData();",
          "source": "mesh-core-cst"
        },
        {
          "name": "paymentData",
          "type": "any",
          "value": "plutusDataList.get(0);",
          "isPublic": true,
          "line": 160,
          "raw": "const paymentData = plutusDataList.get(0);",
          "source": "mesh-core-cst"
        },
        {
          "name": "paymentConstrData",
          "type": "any",
          "value": "paymentData.asConstrPlutusData();",
          "isPublic": true,
          "line": 161,
          "raw": "const paymentConstrData = paymentData.asConstrPlutusData();",
          "source": "mesh-core-cst"
        },
        {
          "name": "paymentConstrDataList",
          "type": "any",
          "value": "paymentConstrData.getData();",
          "isPublic": true,
          "line": 168,
          "raw": "const paymentConstrDataList = paymentConstrData.getData();",
          "source": "mesh-core-cst"
        },
        {
          "name": "paymentBytes",
          "type": "any",
          "value": "paymentConstrDataList.get(0).asBoundedBytes();",
          "isPublic": true,
          "line": 175,
          "raw": "const paymentBytes = paymentConstrDataList.get(0).asBoundedBytes();",
          "source": "mesh-core-cst"
        },
        {
          "name": "cardanoPaymentCredential",
          "type": "any",
          "value": "{",
          "isPublic": true,
          "line": 190,
          "raw": "const cardanoPaymentCredential = {",
          "source": "mesh-core-cst"
        },
        {
          "name": "delegationData",
          "type": "any",
          "value": "plutusDataList.get(1);",
          "isPublic": true,
          "line": 195,
          "raw": "const delegationData = plutusDataList.get(1);",
          "source": "mesh-core-cst"
        },
        {
          "name": "delegationConstrData",
          "type": "any",
          "value": "delegationData.asConstrPlutusData();",
          "isPublic": true,
          "line": 197,
          "raw": "const delegationConstrData = delegationData.asConstrPlutusData();",
          "source": "mesh-core-cst"
        },
        {
          "name": "delegationDataList",
          "type": "any",
          "value": "delegationConstrData.getData();",
          "isPublic": true,
          "line": 213,
          "raw": "const delegationDataList = delegationConstrData.getData();",
          "source": "mesh-core-cst"
        },
        {
          "name": "delegationDataInner",
          "type": "any",
          "value": "delegationDataList.get(0);",
          "isPublic": true,
          "line": 220,
          "raw": "const delegationDataInner = delegationDataList.get(0);",
          "source": "mesh-core-cst"
        },
        {
          "name": "delegationDataInnerList",
          "type": "any",
          "value": "delegationDataInnerConstrData.getData();",
          "isPublic": true,
          "line": 231,
          "raw": "const delegationDataInnerList = delegationDataInnerConstrData.getData();",
          "source": "mesh-core-cst"
        },
        {
          "name": "delegationCredential",
          "type": "any",
          "value": "delegationDataInnerList",
          "isPublic": true,
          "line": 238,
          "raw": "const delegationCredential = delegationDataInnerList",
          "source": "mesh-core-cst"
        },
        {
          "name": "delegationBytesList",
          "type": "any",
          "value": "delegationCredential.getData();",
          "isPublic": true,
          "line": 247,
          "raw": "const delegationBytesList = delegationCredential.getData();",
          "source": "mesh-core-cst"
        },
        {
          "name": "delegationBytes",
          "type": "any",
          "value": "delegationBytesList.get(0).asBoundedBytes();",
          "isPublic": true,
          "line": 254,
          "raw": "const delegationBytes = delegationBytesList.get(0).asBoundedBytes();",
          "source": "mesh-core-cst"
        },
        {
          "name": "cardanoStakeCredential",
          "type": "any",
          "value": "{",
          "isPublic": true,
          "line": 261,
          "raw": "const cardanoStakeCredential = {",
          "source": "mesh-core-cst"
        },
        {
          "name": "delegationDataInnerList",
          "type": "any",
          "value": "delegationDataInnerConstrData.getData();",
          "isPublic": true,
          "line": 275,
          "raw": "const delegationDataInnerList = delegationDataInnerConstrData.getData();",
          "source": "mesh-core-cst"
        },
        {
          "name": "slot",
          "type": "any",
          "value": "delegationDataInnerList.get(0).asInteger();",
          "isPublic": true,
          "line": 282,
          "raw": "const slot = delegationDataInnerList.get(0).asInteger();",
          "source": "mesh-core-cst"
        },
        {
          "name": "txIndex",
          "type": "any",
          "value": "delegationDataInnerList.get(1).asInteger();",
          "isPublic": true,
          "line": 289,
          "raw": "const txIndex = delegationDataInnerList.get(1).asInteger();",
          "source": "mesh-core-cst"
        },
        {
          "name": "certIndex",
          "type": "any",
          "value": "delegationDataInnerList.get(2).asInteger();",
          "isPublic": true,
          "line": 296,
          "raw": "const certIndex = delegationDataInnerList.get(2).asInteger();",
          "source": "mesh-core-cst"
        },
        {
          "name": "cardanoPointer",
          "type": "any",
          "value": "{",
          "isPublic": true,
          "line": 303,
          "raw": "const cardanoPointer = {",
          "source": "mesh-core-cst"
        },
        {
          "name": "serializeAddressObj",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 329,
          "raw": "export const serializeAddressObj = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "cardanoPlutusData",
          "type": "any",
          "value": "fromJsonToPlutusData(plutusDataAddressObject);",
          "isPublic": true,
          "line": 333,
          "raw": "const cardanoPlutusData = fromJsonToPlutusData(plutusDataAddressObject);",
          "source": "mesh-core-cst"
        },
        {
          "name": "serializePlutusAddressToBech32",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 337,
          "raw": "export const serializePlutusAddressToBech32 = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "cardanoPlutusData",
          "type": "any",
          "value": "PlutusData.fromCbor(HexBlob(plutusHex));",
          "isPublic": true,
          "line": 341,
          "raw": "const cardanoPlutusData = PlutusData.fromCbor(HexBlob(plutusHex));",
          "source": "mesh-core-cst"
        },
        {
          "name": "deserializeBech32Address",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 345,
          "raw": "export const deserializeBech32Address = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "deserializedAddress",
          "type": "any",
          "value": "Address.fromBech32(bech32Addr).getProps();",
          "isPublic": true,
          "line": 348,
          "raw": "const deserializedAddress = Address.fromBech32(bech32Addr).getProps();",
          "source": "mesh-core-cst"
        },
        {
          "name": "deserializeAddress",
          "type": "any",
          "value": "(address: string): Address => {",
          "isPublic": true,
          "line": 369,
          "raw": "export const deserializeAddress = (address: string): Address => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "_address",
          "type": "any",
          "value": "Address.fromString(address);",
          "isPublic": true,
          "line": 370,
          "raw": "const _address = Address.fromString(address);",
          "source": "mesh-core-cst"
        },
        {
          "name": "scriptHashToBech32",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 375,
          "raw": "export const scriptHashToBech32 = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "v2ScriptToBech32",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 406,
          "raw": "export const v2ScriptToBech32 = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "scriptHashToRewardAddress",
          "type": "any",
          "value": "(hash: string, networkId = 0) => {",
          "isPublic": true,
          "line": 419,
          "raw": "export const scriptHashToRewardAddress = (hash: string, networkId = 0) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "keyHashToRewardAddress",
          "type": "any",
          "value": "(hash: string, networkId = 0) => {",
          "isPublic": true,
          "line": 429,
          "raw": "export const keyHashToRewardAddress = (hash: string, networkId = 0) => {",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { HexBlob } from \"@cardano-sdk/util\";\n\nimport {\n  DeserializedAddress,\n  pubKeyAddress,\n  PubKeyAddress,\n  scriptAddress,\n  ScriptAddress,\n} from \"@meshsdk/common\";\n\nimport {\n  Address,\n  BaseAddress,\n  CertIndex,\n  ConstrPlutusData,\n  CredentialType,\n  EnterpriseAddress,\n  Hash28ByteBase16,\n  PlutusData,\n  PlutusList,\n  PointerAddress,\n  RewardAddress,\n  Script,\n  TxIndex,\n} from \"../types\";\nimport { fromJsonToPlutusData, fromPlutusDataToJson } from \"./data\";\n\nexport const serialzeAddress = (\n  deserializedAddress: Partial<DeserializedAddress>,\n  networkId = 0,\n) => {\n  const {\n    pubKeyHash,\n    scriptHash,\n    stakeCredentialHash,\n    stakeScriptCredentialHash,\n  } = deserializedAddress;\n\n  const isPaymentScript = !pubKeyHash;\n  const isStakeScript = !stakeCredentialHash;\n\n  const paymentHash = isPaymentScript ? scriptHash : pubKeyHash;\n\n  const stakeHash = isStakeScript\n    ? stakeScriptCredentialHash\n    : stakeCredentialHash;\n\n  if (!paymentHash)\n    throw new Error(\n      \"Error: serializeAddress: Address must contain a payment part\",\n    );\n\n  const addressObj = isPaymentScript\n    ? scriptAddress(paymentHash, stakeHash, isStakeScript)\n    : pubKeyAddress(paymentHash, stakeHash, isStakeScript);\n  return serializeAddressObj(addressObj, networkId);\n};\n\nconst addrBech32ToPlutusData = (bech32: string): PlutusData => {\n  const cardanoAddress = Address.fromBech32(bech32);\n  const cardanoAddressProps = cardanoAddress.getProps();\n  const paymentPartList = new PlutusList();\n  if (!cardanoAddressProps.paymentPart) {\n    throw new Error(\n      \"Error: addrBech32ToPlutusDataHex: Address must contain a payment part\",\n    );\n  }\n  paymentPartList.add(\n    PlutusData.newBytes(\n      Buffer.from(cardanoAddressProps.paymentPart.hash, \"hex\"),\n    ),\n  );\n  const paymentPart = PlutusData.newConstrPlutusData(\n    new ConstrPlutusData(\n      BigInt(cardanoAddressProps.paymentPart.type),\n      paymentPartList,\n    ),\n  );\n  const delegationPartList = new PlutusList();\n  let delegationPart;\n  if (cardanoAddressProps.delegationPart) {\n    delegationPartList.add(\n      PlutusData.newBytes(\n        Buffer.from(cardanoAddressProps.delegationPart.hash, \"hex\"),\n      ),\n    );\n\n    // Inline(StakeCredential)\n    const inlineDelegationPart = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(0), delegationPartList),\n    );\n\n    // Some(Inline(StakeCredential))\n    const someList = new PlutusList();\n    someList.add(inlineDelegationPart);\n    delegationPart = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(0), someList),\n    );\n  } else if (cardanoAddressProps.pointer) {\n    // Pointer\n    const pointerList = new PlutusList();\n    pointerList.add(\n      PlutusData.newInteger(BigInt(cardanoAddressProps.pointer.slot)),\n    );\n    pointerList.add(\n      PlutusData.newInteger(BigInt(cardanoAddressProps.pointer.txIndex)),\n    );\n    pointerList.add(\n      PlutusData.newInteger(BigInt(cardanoAddressProps.pointer.certIndex)),\n    );\n    const pointer = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(1), pointerList),\n    );\n\n    // Some(Pointer)\n    const someList = new PlutusList();\n    someList.add(pointer);\n    delegationPart = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(0), someList),\n    );\n  } else {\n    delegationPart = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(1), new PlutusList()),\n    );\n  }\n\n  const addressList = new PlutusList();\n  addressList.add(paymentPart);\n  addressList.add(delegationPart);\n\n  return PlutusData.newConstrPlutusData(\n    new ConstrPlutusData(BigInt(0), addressList),\n  );\n};\n\nexport const addrBech32ToPlutusDataHex = (bech32: string): string => {\n  return addrBech32ToPlutusData(bech32).toCbor();\n};\n\nexport const addrBech32ToPlutusDataObj = <T>(bech32: string): T => {\n  return fromPlutusDataToJson(addrBech32ToPlutusData(bech32)) as T;\n};\n\nconst plutusDataToAddrBech32 = (\n  plutusData: PlutusData,\n  networkId = 0,\n): string => {\n  const constrPlutusData = plutusData.asConstrPlutusData();\n  if (!constrPlutusData || constrPlutusData.getAlternative() !== BigInt(0)) {\n    throw new Error(\n      \"Error: serializeAddressObj: Address must contain a constructor 0\",\n    );\n  }\n\n  const plutusDataList = constrPlutusData.getData();\n  if (plutusDataList.getLength() !== 2) {\n    throw new Error(\"Error: serializeAddressObj: Address must contain 2 parts\");\n  }\n\n  const paymentData = plutusDataList.get(0);\n  const paymentConstrData = paymentData.asConstrPlutusData();\n  if (!paymentConstrData) {\n    throw new Error(\n      \"Error: serializeAddressObj: Payment part must be a constructor\",\n    );\n  }\n\n  const paymentConstrDataList = paymentConstrData.getData();\n  if (paymentConstrDataList.getLength() !== 1) {\n    throw new Error(\n      \"Error: serializeAddressObj: Payment part must contain 1 element\",\n    );\n  }\n\n  const paymentBytes = paymentConstrDataList.get(0).asBoundedBytes();\n  if (!paymentBytes) {\n    throw new Error(\n      \"Error: serializeAddressObj: Payment inner part must be bytes\",\n    );\n  }\n\n  if (\n    paymentConstrData.getAlternative() !== BigInt(0) &&\n    paymentConstrData.getAlternative() !== BigInt(1)\n  ) {\n    throw new Error(\n      \"Error: serializeAddressObj: Payment part must be alternative 0 or 1\",\n    );\n  }\n  const cardanoPaymentCredential = {\n    hash: Hash28ByteBase16(Buffer.from(paymentBytes).toString(\"hex\")),\n    type: Number(paymentConstrData.getAlternative()),\n  };\n\n  const delegationData = plutusDataList.get(1);\n  // Option<Referenced<Credential>>\n  const delegationConstrData = delegationData.asConstrPlutusData();\n  if (!delegationConstrData) {\n    throw new Error(\n      \"Error: serializeAddressObj: Delegation part must be a constructor\",\n    );\n  }\n\n  if (delegationConstrData.getAlternative() === BigInt(1)) {\n    return EnterpriseAddress.fromCredentials(\n      networkId,\n      cardanoPaymentCredential,\n    )\n      .toAddress()\n      .toBech32()\n      .toString();\n  } else if (delegationConstrData.getAlternative() === BigInt(0)) {\n    const delegationDataList = delegationConstrData.getData();\n    if (delegationDataList.getLength() !== 1) {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation part must contain 1 element\",\n      );\n    }\n\n    const delegationDataInner = delegationDataList.get(0);\n    // Referenced<Credential>\n    const delegationDataInnerConstrData =\n      delegationDataInner.asConstrPlutusData();\n    if (!delegationDataInnerConstrData) {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation inner part must be a constructor\",\n      );\n    }\n\n    if (delegationDataInnerConstrData.getAlternative() === BigInt(0)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 1 element\",\n        );\n      }\n      // Credential\n      const delegationCredential = delegationDataInnerList\n        .get(0)\n        .asConstrPlutusData();\n      if (!delegationCredential) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must be a constructor\",\n        );\n      }\n\n      const delegationBytesList = delegationCredential.getData();\n      if (delegationBytesList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must contain 1 element\",\n        );\n      }\n\n      const delegationBytes = delegationBytesList.get(0).asBoundedBytes();\n      if (!delegationBytes) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must be of type bytes\",\n        );\n      }\n\n      const cardanoStakeCredential = {\n        hash: Hash28ByteBase16(Buffer.from(delegationBytes).toString(\"hex\")),\n        type: Number(delegationCredential.getAlternative()),\n      };\n\n      return BaseAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoStakeCredential,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else if (delegationDataInnerConstrData.getAlternative() === BigInt(1)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 3) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 3 elements\",\n        );\n      }\n\n      const slot = delegationDataInnerList.get(0).asInteger();\n      if (!slot) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part slot must be integer\",\n        );\n      }\n\n      const txIndex = delegationDataInnerList.get(1).asInteger();\n      if (!txIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part txIndex must be integer\",\n        );\n      }\n\n      const certIndex = delegationDataInnerList.get(2).asInteger();\n      if (!certIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part certIndex must be integer\",\n        );\n      }\n\n      const cardanoPointer = {\n        slot: slot,\n        txIndex: TxIndex(Number(txIndex)),\n        certIndex: CertIndex(Number(certIndex)),\n      };\n\n      return PointerAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoPointer,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation inner part must be alternative 0 or 1\",\n      );\n    }\n  } else {\n    throw new Error(\n      \"Error: serializeAddressObj: Delegation part must be alternative 0 or 1\",\n    );\n  }\n};\n\nexport const serializeAddressObj = (\n  plutusDataAddressObject: PubKeyAddress | ScriptAddress,\n  networkId = 0,\n): string => {\n  const cardanoPlutusData = fromJsonToPlutusData(plutusDataAddressObject);\n  return plutusDataToAddrBech32(cardanoPlutusData, networkId);\n};\n\nexport const serializePlutusAddressToBech32 = (\n  plutusHex: string,\n  networkId = 0,\n) => {\n  const cardanoPlutusData = PlutusData.fromCbor(HexBlob(plutusHex));\n  return plutusDataToAddrBech32(cardanoPlutusData, networkId).toString();\n};\n\nexport const deserializeBech32Address = (\n  bech32Addr: string,\n): DeserializedAddress => {\n  const deserializedAddress = Address.fromBech32(bech32Addr).getProps();\n  return {\n    pubKeyHash:\n      deserializedAddress.paymentPart?.type === CredentialType.KeyHash\n        ? deserializedAddress.paymentPart?.hash\n        : \"\",\n    scriptHash:\n      deserializedAddress.paymentPart?.type === CredentialType.ScriptHash\n        ? deserializedAddress.paymentPart?.hash\n        : \"\",\n    stakeCredentialHash:\n      deserializedAddress.delegationPart?.type === CredentialType.KeyHash\n        ? deserializedAddress.delegationPart?.hash\n        : \"\",\n    stakeScriptCredentialHash:\n      deserializedAddress.delegationPart?.type === CredentialType.ScriptHash\n        ? deserializedAddress.delegationPart?.hash\n        : \"\",\n  };\n};\n\nexport const deserializeAddress = (address: string): Address => {\n  const _address = Address.fromString(address);\n  if (_address === null) throw new Error(\"Invalid address\");\n  return _address;\n};\n\nexport const scriptHashToBech32 = (\n  scriptHash: string,\n  stakeCredentialHash?: string,\n  networkId = 0,\n  isScriptStakeCredentialHash = false,\n) => {\n  if (stakeCredentialHash) {\n    return BaseAddress.fromCredentials(\n      networkId,\n      { hash: Hash28ByteBase16(scriptHash), type: CredentialType.ScriptHash },\n      {\n        hash: Hash28ByteBase16(stakeCredentialHash),\n        type: isScriptStakeCredentialHash\n          ? CredentialType.ScriptHash\n          : CredentialType.KeyHash,\n      },\n    )\n      .toAddress()\n      .toBech32()\n      .toString();\n  } else {\n    return EnterpriseAddress.fromCredentials(networkId, {\n      hash: Hash28ByteBase16(scriptHash),\n      type: CredentialType.ScriptHash,\n    })\n      .toAddress()\n      .toBech32()\n      .toString();\n  }\n};\n\nexport const v2ScriptToBech32 = (\n  scriptCbor: string,\n  stakeCredential?: string,\n  networkId = 0,\n  isScriptStakeCredential = false,\n) =>\n  scriptHashToBech32(\n    Script.fromCbor(HexBlob(scriptCbor)).hash().toString(),\n    stakeCredential,\n    networkId,\n    isScriptStakeCredential,\n  );\n\nexport const scriptHashToRewardAddress = (hash: string, networkId = 0) => {\n  return RewardAddress.fromCredentials(networkId, {\n    hash: Hash28ByteBase16(hash),\n    type: CredentialType.ScriptHash,\n  })\n    .toAddress()\n    .toBech32()\n    .toString();\n};\n\nexport const keyHashToRewardAddress = (hash: string, networkId = 0) => {\n  return RewardAddress.fromCredentials(networkId, {\n    hash: Hash28ByteBase16(hash),\n    type: CredentialType.KeyHash,\n  })\n    .toAddress()\n    .toBech32()\n    .toString();\n};\n",
      "dependencies": [
        "serialzeAddress",
        "addrBech32ToPlutusDataHex",
        "addrBech32ToPlutusDataObj",
        "serializeAddressObj",
        "serializePlutusAddressToBech32",
        "deserializeBech32Address",
        "deserializeAddress",
        "scriptHashToBech32",
        "v2ScriptToBech32",
        "scriptHashToRewardAddress",
        "keyHashToRewardAddress"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:utils.builder.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/utils/builder.ts",
      "name": "utils.builder.ts",
      "imports": [
        {
          "module": "buildBaseAddress",
          "items": [],
          "line": 28,
          "raw": "export const buildBaseAddress = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "buildEnterpriseAddress",
          "items": [],
          "line": 46,
          "raw": "export const buildEnterpriseAddress = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "clampScalar",
          "items": [],
          "line": 56,
          "raw": "export const clampScalar = (scalar: Buffer): Buffer => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "buildBip32PrivateKey",
          "items": [],
          "line": 67,
          "raw": "export const buildBip32PrivateKey = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "buildRewardAddress",
          "items": [],
          "line": 87,
          "raw": "export const buildRewardAddress = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "buildKeys",
          "items": [],
          "line": 108,
          "raw": "export const buildKeys = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "buildEd25519PrivateKeyFromSecretKey",
          "items": [],
          "line": 146,
          "raw": "export const buildEd25519PrivateKeyFromSecretKey = (secretKeyHex: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "buildScriptPubkey",
          "items": [],
          "line": 158,
          "raw": "export const buildScriptPubkey = (keyHash: Ed25519KeyHash): NativeScript => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "buildDRepID",
          "items": [],
          "line": 163,
          "raw": "export const buildDRepID = (",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "buildBaseAddress",
          "signature": "export const buildBaseAddress = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 28,
          "raw": "export const buildBaseAddress = (\n  networkId: number,\n  paymentKeyHash: Hash28ByteBase16,\n  stakeKeyHash: Hash28ByteBase16,\n): BaseAddress => {\n  return BaseAddress.fromCredentials(\n    networkId,\n    {\n      hash: paymentKeyHash,\n      type: CredentialType.KeyHash,\n    },\n    {\n      hash: stakeKeyHash,\n      type: CredentialType.KeyHash,\n    },\n  );\n};",
          "source": "mesh-core-cst",
          "implementation": "export const buildBaseAddress = (\n  networkId: number,\n  paymentKeyHash: Hash28ByteBase16,\n  stakeKeyHash: Hash28ByteBase16,\n): BaseAddress => {\n  return BaseAddress.fromCredentials(\n    networkId,\n    {\n      hash: paymentKeyHash,\n      type: CredentialType.KeyHash,\n    },\n    {\n      hash: stakeKeyHash,\n      type: CredentialType.KeyHash,\n    },\n  );\n};"
        },
        {
          "name": "buildEnterpriseAddress",
          "signature": "export const buildEnterpriseAddress = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 46,
          "raw": "export const buildEnterpriseAddress = (\n  networkId: number,\n  paymentKeyHash: Hash28ByteBase16,\n): EnterpriseAddress => {\n  return EnterpriseAddress.fromCredentials(networkId, {\n    hash: paymentKeyHash,\n    type: CredentialType.KeyHash,\n  });\n};",
          "source": "mesh-core-cst",
          "implementation": "export const buildEnterpriseAddress = (\n  networkId: number,\n  paymentKeyHash: Hash28ByteBase16,\n): EnterpriseAddress => {\n  return EnterpriseAddress.fromCredentials(networkId, {\n    hash: paymentKeyHash,\n    type: CredentialType.KeyHash,\n  });\n};"
        },
        {
          "name": "clampScalar",
          "signature": "export const clampScalar = (scalar: Buffer): Buffer => {",
          "documentation": "",
          "parameters": [
            {
              "name": "scalar",
              "type": "Buffer",
              "optional": false
            }
          ],
          "returnType": "Buffer",
          "isPublic": true,
          "line": 56,
          "raw": "export const clampScalar = (scalar: Buffer): Buffer => {\n  if (scalar[0] !== undefined) {\n    scalar[0] &= 0b1111_1000;\n  }\n  if (scalar[31] !== undefined) {\n    scalar[31] &= 0b0001_1111;\n    scalar[31] |= 0b0100_0000;\n  }\n  return scalar;\n};",
          "source": "mesh-core-cst",
          "implementation": "export const clampScalar = (scalar: Buffer): Buffer => {\n  if (scalar[0] !== undefined) {\n    scalar[0] &= 0b1111_1000;\n  }\n  if (scalar[31] !== undefined) {\n    scalar[31] &= 0b0001_1111;\n    scalar[31] |= 0b0100_0000;\n  }\n  return scalar;\n};"
        },
        {
          "name": "buildBip32PrivateKey",
          "signature": "export const buildBip32PrivateKey = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 67,
          "raw": "export const buildBip32PrivateKey = (\n  entropy: string,\n  password = \"\",\n): Bip32PrivateKey => {\n  const PBKDF2_ITERATIONS = 4096;\n  const PBKDF2_KEY_SIZE = 96;\n  const PBKDF2_DIGEST_ALGORITHM = \"sha512\";\n\n  const _entropy = Buffer.from(entropy, \"hex\");\n\n  const xprv = pbkdf2Sync(\n    password,\n    _entropy,\n    PBKDF2_ITERATIONS,\n    PBKDF2_KEY_SIZE,\n    PBKDF2_DIGEST_ALGORITHM,\n  );\n  return Bip32PrivateKey.fromBytes(clampScalar(xprv));\n};",
          "source": "mesh-core-cst",
          "implementation": "export const buildBip32PrivateKey = (\n  entropy: string,\n  password = \"\",\n): Bip32PrivateKey => {\n  const PBKDF2_ITERATIONS = 4096;\n  const PBKDF2_KEY_SIZE = 96;\n  const PBKDF2_DIGEST_ALGORITHM = \"sha512\";\n\n  const _entropy = Buffer.from(entropy, \"hex\");\n\n  const xprv = pbkdf2Sync(\n    password,\n    _entropy,\n    PBKDF2_ITERATIONS,\n    PBKDF2_KEY_SIZE,\n    PBKDF2_DIGEST_ALGORITHM,\n  );\n  return Bip32PrivateKey.fromBytes(clampScalar(xprv));\n};"
        },
        {
          "name": "buildRewardAddress",
          "signature": "export const buildRewardAddress = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 87,
          "raw": "export const buildRewardAddress = (\n  networkId: number,\n  stakeKeyHash: Hash28ByteBase16,\n): RewardAddress => {\n  const cred = {\n    type: CredentialType.KeyHash,\n    hash: stakeKeyHash,\n  };\n  return RewardAddress.fromCredentials(networkId, cred);\n};",
          "source": "mesh-core-cst",
          "implementation": "export const buildRewardAddress = (\n  networkId: number,\n  stakeKeyHash: Hash28ByteBase16,\n): RewardAddress => {\n  const cred = {\n    type: CredentialType.KeyHash,\n    hash: stakeKeyHash,\n  };\n  return RewardAddress.fromCredentials(networkId, cred);\n};"
        },
        {
          "name": "buildKeys",
          "signature": "export const buildKeys = (",
          "documentation": "/**\n * Build a set of keys from a given private key\n *\n * NOTE - Must be called after `await Crypto.Ready()`\n *\n * @param privateKeyHex - The BIP32 private key hex to derive keys from\n * @param accountIndex - The account index to derive keys for\n * @param keyIndex - The key index to derive keys for\n * @returns The payment and stake keys, and optionally the dRep key if a Bip32PrivateKey is provided\n */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 108,
          "raw": "/**\n * Build a set of keys from a given private key\n *\n * NOTE - Must be called after `await Crypto.Ready()`\n *\n * @param privateKeyHex - The BIP32 private key hex to derive keys from\n * @param accountIndex - The account index to derive keys for\n * @param keyIndex - The key index to derive keys for\n * @returns The payment and stake keys, and optionally the dRep key if a Bip32PrivateKey is provided\n */\nexport const buildKeys = (\n  privateKeyHex: string | [string, string],\n  accountIndex: number,\n  keyIndex = 0,\n): {\n  paymentKey: Ed25519PrivateKey;\n  stakeKey: Ed25519PrivateKey;\n  dRepKey?: Ed25519PrivateKey;\n} => {\n  if (typeof privateKeyHex === \"string\") {\n    const privateKey = Bip32PrivateKey.fromHex(\n      Bip32PrivateKeyHex(privateKeyHex),\n    );\n\n    // hardened derivation\n    const accountKey = privateKey.derive([\n      HARDENED_KEY_START + 1852, // purpose\n      HARDENED_KEY_START + 1815, // coin type\n      HARDENED_KEY_START + accountIndex, // account index\n    ]);\n\n    const paymentKey = accountKey.derive([0, keyIndex]).toRawKey(); // external chain, payment key index\n    const stakeKey = accountKey.derive([2, 0]).toRawKey(); // staking key, index 0\n    const dRepKey = accountKey.derive([3, keyIndex]).toRawKey(); // dRep Keys, index\n\n    return { paymentKey, stakeKey, dRepKey };\n  } else {\n    const paymentKey = Ed25519PrivateKey.fromNormalHex(\n      Ed25519PrivateNormalKeyHex(privateKeyHex[0]),\n    );\n    const stakeKey = Ed25519PrivateKey.fromNormalHex(\n      Ed25519PrivateNormalKeyHex(privateKeyHex[1]),\n    );\n\n    return { paymentKey, stakeKey };\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const buildKeys = (\n  privateKeyHex: string | [string, string],\n  accountIndex: number,\n  keyIndex = 0,\n): {\n  paymentKey: Ed25519PrivateKey;\n  stakeKey: Ed25519PrivateKey;\n  dRepKey?: Ed25519PrivateKey;\n} => {\n  if (typeof privateKeyHex === \"string\") {\n    const privateKey = Bip32PrivateKey.fromHex(\n      Bip32PrivateKeyHex(privateKeyHex),\n    );\n\n    // hardened derivation\n    const accountKey = privateKey.derive([\n      HARDENED_KEY_START + 1852, // purpose\n      HARDENED_KEY_START + 1815, // coin type\n      HARDENED_KEY_START + accountIndex, // account index\n    ]);\n\n    const paymentKey = accountKey.derive([0, keyIndex]).toRawKey(); // external chain, payment key index\n    const stakeKey = accountKey.derive([2, 0]).toRawKey(); // staking key, index 0\n    const dRepKey = accountKey.derive([3, keyIndex]).toRawKey(); // dRep Keys, index\n\n    return { paymentKey, stakeKey, dRepKey };\n  } else {\n    const paymentKey = Ed25519PrivateKey.fromNormalHex(\n      Ed25519PrivateNormalKeyHex(privateKeyHex[0]),\n    );\n    const stakeKey = Ed25519PrivateKey.fromNormalHex(\n      Ed25519PrivateNormalKeyHex(privateKeyHex[1]),\n    );\n\n    return { paymentKey, stakeKey };\n  }\n};"
        },
        {
          "name": "buildEd25519PrivateKeyFromSecretKey",
          "signature": "export const buildEd25519PrivateKeyFromSecretKey = (secretKeyHex: string) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "secretKeyHex",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 146,
          "raw": "export const buildEd25519PrivateKeyFromSecretKey = (secretKeyHex: string) => {\n  return Ed25519PrivateKey.fromExtendedBytes(\n    new Uint8Array(\n      clampScalar(\n        Buffer.from(\n          hash.sha512().update(Buffer.from(secretKeyHex, \"hex\")).digest(),\n        ),\n      ),\n    ),\n  );\n};",
          "source": "mesh-core-cst",
          "implementation": "export const buildEd25519PrivateKeyFromSecretKey = (secretKeyHex: string) => {\n  return Ed25519PrivateKey.fromExtendedBytes(\n    new Uint8Array(\n      clampScalar(\n        Buffer.from(\n          hash.sha512().update(Buffer.from(secretKeyHex, \"hex\")).digest(),\n        ),\n      ),\n    ),\n  );\n};"
        },
        {
          "name": "buildScriptPubkey",
          "signature": "export const buildScriptPubkey = (keyHash: Ed25519KeyHash): NativeScript => {",
          "documentation": "",
          "parameters": [
            {
              "name": "keyHash",
              "type": "Ed25519KeyHash",
              "optional": false
            }
          ],
          "returnType": "NativeScript",
          "isPublic": true,
          "line": 158,
          "raw": "export const buildScriptPubkey = (keyHash: Ed25519KeyHash): NativeScript => {\n  const scriptPubkey = new ScriptPubkey(Ed25519KeyHashHex(keyHash.hex()));\n  return NativeScript.newScriptPubkey(scriptPubkey);\n};",
          "source": "mesh-core-cst",
          "implementation": "export const buildScriptPubkey = (keyHash: Ed25519KeyHash): NativeScript => {\n  const scriptPubkey = new ScriptPubkey(Ed25519KeyHashHex(keyHash.hex()));\n  return NativeScript.newScriptPubkey(scriptPubkey);\n};"
        },
        {
          "name": "buildDRepID",
          "signature": "export const buildDRepID = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 163,
          "raw": "export const buildDRepID = (\n  dRepKey: Ed25519PublicKeyHex,\n  networkId: NetworkId = NetworkId.Testnet,\n  addressType: AddressType = AddressType.EnterpriseKey,\n): DRepID => {\n  const dRepKeyBytes = Buffer.from(dRepKey, \"hex\");\n  const dRepIdHex = blake2b(28).update(dRepKeyBytes).digest(\"hex\");\n  const paymentAddress = EnterpriseAddress.packParts({\n    networkId,\n    paymentPart: {\n      hash: Hash28ByteBase16(dRepIdHex),\n      type: CredentialType.KeyHash,\n    },\n    type: addressType,\n  });\n  return HexBlob.toTypedBech32<DRepID>(\n    \"drep\",\n    HexBlob.fromBytes(paymentAddress),\n  );\n};",
          "source": "mesh-core-cst",
          "implementation": "export const buildDRepID = (\n  dRepKey: Ed25519PublicKeyHex,\n  networkId: NetworkId = NetworkId.Testnet,\n  addressType: AddressType = AddressType.EnterpriseKey,\n): DRepID => {\n  const dRepKeyBytes = Buffer.from(dRepKey, \"hex\");\n  const dRepIdHex = blake2b(28).update(dRepKeyBytes).digest(\"hex\");\n  const paymentAddress = EnterpriseAddress.packParts({\n    networkId,\n    paymentPart: {\n      hash: Hash28ByteBase16(dRepIdHex),\n      type: CredentialType.KeyHash,\n    },\n    type: addressType,\n  });\n  return HexBlob.toTypedBech32<DRepID>(\n    \"drep\",\n    HexBlob.fromBytes(paymentAddress),\n  );\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "buildBaseAddress",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 28,
          "raw": "export const buildBaseAddress = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "buildEnterpriseAddress",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 46,
          "raw": "export const buildEnterpriseAddress = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "clampScalar",
          "type": "any",
          "value": "(scalar: Buffer): Buffer => {",
          "isPublic": true,
          "line": 56,
          "raw": "export const clampScalar = (scalar: Buffer): Buffer => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "buildBip32PrivateKey",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 67,
          "raw": "export const buildBip32PrivateKey = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "PBKDF2_ITERATIONS",
          "type": "any",
          "value": "4096;",
          "isPublic": true,
          "line": 71,
          "raw": "const PBKDF2_ITERATIONS = 4096;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PBKDF2_KEY_SIZE",
          "type": "any",
          "value": "96;",
          "isPublic": true,
          "line": 72,
          "raw": "const PBKDF2_KEY_SIZE = 96;",
          "source": "mesh-core-cst"
        },
        {
          "name": "PBKDF2_DIGEST_ALGORITHM",
          "type": "any",
          "value": "\"sha512\";",
          "isPublic": true,
          "line": 73,
          "raw": "const PBKDF2_DIGEST_ALGORITHM = \"sha512\";",
          "source": "mesh-core-cst"
        },
        {
          "name": "_entropy",
          "type": "any",
          "value": "Buffer.from(entropy, \"hex\");",
          "isPublic": true,
          "line": 75,
          "raw": "const _entropy = Buffer.from(entropy, \"hex\");",
          "source": "mesh-core-cst"
        },
        {
          "name": "xprv",
          "type": "any",
          "value": "pbkdf2Sync(",
          "isPublic": true,
          "line": 77,
          "raw": "const xprv = pbkdf2Sync(",
          "source": "mesh-core-cst"
        },
        {
          "name": "buildRewardAddress",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 87,
          "raw": "export const buildRewardAddress = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "cred",
          "type": "any",
          "value": "{",
          "isPublic": true,
          "line": 91,
          "raw": "const cred = {",
          "source": "mesh-core-cst"
        },
        {
          "name": "buildKeys",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 108,
          "raw": "export const buildKeys = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "privateKey",
          "type": "any",
          "value": "Bip32PrivateKey.fromHex(",
          "isPublic": true,
          "line": 118,
          "raw": "const privateKey = Bip32PrivateKey.fromHex(",
          "source": "mesh-core-cst"
        },
        {
          "name": "accountKey",
          "type": "any",
          "value": "privateKey.derive([",
          "isPublic": true,
          "line": 123,
          "raw": "const accountKey = privateKey.derive([",
          "source": "mesh-core-cst"
        },
        {
          "name": "paymentKey",
          "type": "any",
          "value": "accountKey.derive([0, keyIndex]).toRawKey(); // external chain, payment key index",
          "isPublic": true,
          "line": 129,
          "raw": "const paymentKey = accountKey.derive([0, keyIndex]).toRawKey(); // external chain, payment key index",
          "source": "mesh-core-cst"
        },
        {
          "name": "stakeKey",
          "type": "any",
          "value": "accountKey.derive([2, 0]).toRawKey(); // staking key, index 0",
          "isPublic": true,
          "line": 130,
          "raw": "const stakeKey = accountKey.derive([2, 0]).toRawKey(); // staking key, index 0",
          "source": "mesh-core-cst"
        },
        {
          "name": "dRepKey",
          "type": "any",
          "value": "accountKey.derive([3, keyIndex]).toRawKey(); // dRep Keys, index",
          "isPublic": true,
          "line": 131,
          "raw": "const dRepKey = accountKey.derive([3, keyIndex]).toRawKey(); // dRep Keys, index",
          "source": "mesh-core-cst"
        },
        {
          "name": "paymentKey",
          "type": "any",
          "value": "Ed25519PrivateKey.fromNormalHex(",
          "isPublic": true,
          "line": 135,
          "raw": "const paymentKey = Ed25519PrivateKey.fromNormalHex(",
          "source": "mesh-core-cst"
        },
        {
          "name": "stakeKey",
          "type": "any",
          "value": "Ed25519PrivateKey.fromNormalHex(",
          "isPublic": true,
          "line": 138,
          "raw": "const stakeKey = Ed25519PrivateKey.fromNormalHex(",
          "source": "mesh-core-cst"
        },
        {
          "name": "buildEd25519PrivateKeyFromSecretKey",
          "type": "any",
          "value": "(secretKeyHex: string) => {",
          "isPublic": true,
          "line": 146,
          "raw": "export const buildEd25519PrivateKeyFromSecretKey = (secretKeyHex: string) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "buildScriptPubkey",
          "type": "any",
          "value": "(keyHash: Ed25519KeyHash): NativeScript => {",
          "isPublic": true,
          "line": 158,
          "raw": "export const buildScriptPubkey = (keyHash: Ed25519KeyHash): NativeScript => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "scriptPubkey",
          "type": "any",
          "value": "new ScriptPubkey(Ed25519KeyHashHex(keyHash.hex()));",
          "isPublic": true,
          "line": 159,
          "raw": "const scriptPubkey = new ScriptPubkey(Ed25519KeyHashHex(keyHash.hex()));",
          "source": "mesh-core-cst"
        },
        {
          "name": "buildDRepID",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 163,
          "raw": "export const buildDRepID = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "dRepKeyBytes",
          "type": "any",
          "value": "Buffer.from(dRepKey, \"hex\");",
          "isPublic": true,
          "line": 168,
          "raw": "const dRepKeyBytes = Buffer.from(dRepKey, \"hex\");",
          "source": "mesh-core-cst"
        },
        {
          "name": "dRepIdHex",
          "type": "any",
          "value": "blake2b(28).update(dRepKeyBytes).digest(\"hex\");",
          "isPublic": true,
          "line": 169,
          "raw": "const dRepIdHex = blake2b(28).update(dRepKeyBytes).digest(\"hex\");",
          "source": "mesh-core-cst"
        },
        {
          "name": "paymentAddress",
          "type": "any",
          "value": "EnterpriseAddress.packParts({",
          "isPublic": true,
          "line": 170,
          "raw": "const paymentAddress = EnterpriseAddress.packParts({",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { pbkdf2Sync } from \"crypto\";\nimport { blake2b, ready } from \"@cardano-sdk/crypto\";\nimport { HexBlob } from \"@cardano-sdk/util\";\nimport hash from \"hash.js\";\n\nimport { HARDENED_KEY_START } from \"@meshsdk/common\";\n\nimport {\n  AddressType,\n  BaseAddress,\n  Bip32PrivateKey,\n  Bip32PrivateKeyHex,\n  CredentialType,\n  DRepID,\n  Ed25519KeyHash,\n  Ed25519KeyHashHex,\n  Ed25519PrivateKey,\n  Ed25519PrivateNormalKeyHex,\n  Ed25519PublicKeyHex,\n  EnterpriseAddress,\n  Hash28ByteBase16,\n  NativeScript,\n  NetworkId,\n  RewardAddress,\n  ScriptPubkey,\n} from \"../types\";\n\nexport const buildBaseAddress = (\n  networkId: number,\n  paymentKeyHash: Hash28ByteBase16,\n  stakeKeyHash: Hash28ByteBase16,\n): BaseAddress => {\n  return BaseAddress.fromCredentials(\n    networkId,\n    {\n      hash: paymentKeyHash,\n      type: CredentialType.KeyHash,\n    },\n    {\n      hash: stakeKeyHash,\n      type: CredentialType.KeyHash,\n    },\n  );\n};\n\nexport const buildEnterpriseAddress = (\n  networkId: number,\n  paymentKeyHash: Hash28ByteBase16,\n): EnterpriseAddress => {\n  return EnterpriseAddress.fromCredentials(networkId, {\n    hash: paymentKeyHash,\n    type: CredentialType.KeyHash,\n  });\n};\n\nexport const clampScalar = (scalar: Buffer): Buffer => {\n  if (scalar[0] !== undefined) {\n    scalar[0] &= 0b1111_1000;\n  }\n  if (scalar[31] !== undefined) {\n    scalar[31] &= 0b0001_1111;\n    scalar[31] |= 0b0100_0000;\n  }\n  return scalar;\n};\n\nexport const buildBip32PrivateKey = (\n  entropy: string,\n  password = \"\",\n): Bip32PrivateKey => {\n  const PBKDF2_ITERATIONS = 4096;\n  const PBKDF2_KEY_SIZE = 96;\n  const PBKDF2_DIGEST_ALGORITHM = \"sha512\";\n\n  const _entropy = Buffer.from(entropy, \"hex\");\n\n  const xprv = pbkdf2Sync(\n    password,\n    _entropy,\n    PBKDF2_ITERATIONS,\n    PBKDF2_KEY_SIZE,\n    PBKDF2_DIGEST_ALGORITHM,\n  );\n  return Bip32PrivateKey.fromBytes(clampScalar(xprv));\n};\n\nexport const buildRewardAddress = (\n  networkId: number,\n  stakeKeyHash: Hash28ByteBase16,\n): RewardAddress => {\n  const cred = {\n    type: CredentialType.KeyHash,\n    hash: stakeKeyHash,\n  };\n  return RewardAddress.fromCredentials(networkId, cred);\n};\n\n/**\n * Build a set of keys from a given private key\n *\n * NOTE - Must be called after `await Crypto.Ready()`\n *\n * @param privateKeyHex - The BIP32 private key hex to derive keys from\n * @param accountIndex - The account index to derive keys for\n * @param keyIndex - The key index to derive keys for\n * @returns The payment and stake keys, and optionally the dRep key if a Bip32PrivateKey is provided\n */\nexport const buildKeys = (\n  privateKeyHex: string | [string, string],\n  accountIndex: number,\n  keyIndex = 0,\n): {\n  paymentKey: Ed25519PrivateKey;\n  stakeKey: Ed25519PrivateKey;\n  dRepKey?: Ed25519PrivateKey;\n} => {\n  if (typeof privateKeyHex === \"string\") {\n    const privateKey = Bip32PrivateKey.fromHex(\n      Bip32PrivateKeyHex(privateKeyHex),\n    );\n\n    // hardened derivation\n    const accountKey = privateKey.derive([\n      HARDENED_KEY_START + 1852, // purpose\n      HARDENED_KEY_START + 1815, // coin type\n      HARDENED_KEY_START + accountIndex, // account index\n    ]);\n\n    const paymentKey = accountKey.derive([0, keyIndex]).toRawKey(); // external chain, payment key index\n    const stakeKey = accountKey.derive([2, 0]).toRawKey(); // staking key, index 0\n    const dRepKey = accountKey.derive([3, keyIndex]).toRawKey(); // dRep Keys, index\n\n    return { paymentKey, stakeKey, dRepKey };\n  } else {\n    const paymentKey = Ed25519PrivateKey.fromNormalHex(\n      Ed25519PrivateNormalKeyHex(privateKeyHex[0]),\n    );\n    const stakeKey = Ed25519PrivateKey.fromNormalHex(\n      Ed25519PrivateNormalKeyHex(privateKeyHex[1]),\n    );\n\n    return { paymentKey, stakeKey };\n  }\n};\n\nexport const buildEd25519PrivateKeyFromSecretKey = (secretKeyHex: string) => {\n  return Ed25519PrivateKey.fromExtendedBytes(\n    new Uint8Array(\n      clampScalar(\n        Buffer.from(\n          hash.sha512().update(Buffer.from(secretKeyHex, \"hex\")).digest(),\n        ),\n      ),\n    ),\n  );\n};\n\nexport const buildScriptPubkey = (keyHash: Ed25519KeyHash): NativeScript => {\n  const scriptPubkey = new ScriptPubkey(Ed25519KeyHashHex(keyHash.hex()));\n  return NativeScript.newScriptPubkey(scriptPubkey);\n};\n\nexport const buildDRepID = (\n  dRepKey: Ed25519PublicKeyHex,\n  networkId: NetworkId = NetworkId.Testnet,\n  addressType: AddressType = AddressType.EnterpriseKey,\n): DRepID => {\n  const dRepKeyBytes = Buffer.from(dRepKey, \"hex\");\n  const dRepIdHex = blake2b(28).update(dRepKeyBytes).digest(\"hex\");\n  const paymentAddress = EnterpriseAddress.packParts({\n    networkId,\n    paymentPart: {\n      hash: Hash28ByteBase16(dRepIdHex),\n      type: CredentialType.KeyHash,\n    },\n    type: addressType,\n  });\n  return HexBlob.toTypedBech32<DRepID>(\n    \"drep\",\n    HexBlob.fromBytes(paymentAddress),\n  );\n};\n",
      "dependencies": [
        "buildBaseAddress",
        "buildEnterpriseAddress",
        "clampScalar",
        "buildBip32PrivateKey",
        "buildRewardAddress",
        "buildKeys",
        "buildEd25519PrivateKeyFromSecretKey",
        "buildScriptPubkey",
        "buildDRepID"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:utils.certificate.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/utils/certificate.ts",
      "name": "utils.certificate.ts",
      "imports": [
        {
          "module": "toCardanoCert",
          "items": [],
          "line": 12,
          "raw": "export const toCardanoCert = (cert: CertificateType): CardanoCert => {",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "toCardanoCert",
          "signature": "export const toCardanoCert = (cert: CertificateType): CardanoCert => {",
          "documentation": "",
          "parameters": [
            {
              "name": "cert",
              "type": "CertificateType",
              "optional": false
            }
          ],
          "returnType": "CardanoCert",
          "isPublic": true,
          "line": 12,
          "raw": "export const toCardanoCert = (cert: CertificateType): CardanoCert => {\n  switch (cert.type) {\n    case \"RegisterPool\": {\n      let relays: Serialization.Relay[] = [];\n\n      for (const relay of cert.poolParams.relays) {\n        switch (relay.type) {\n          case \"SingleHostAddr\": {\n            relays.push(\n              Serialization.Relay.newSingleHostAddr(\n                new Serialization.SingleHostAddr(\n                  relay.port,\n                  relay.IPV4,\n                  relay.IPV6,\n                ),\n              ),\n            );\n            break;\n          }\n          case \"SingleHostName\": {\n            relays.push(\n              Serialization.Relay.newSingleHostName(\n                new Serialization.SingleHostName(relay.domainName, relay.port),\n              ),\n            );\n            break;\n          }\n          case \"MultiHostName\": {\n            relays.push(\n              Serialization.Relay.newMultiHostName(\n                new Serialization.MultiHostName(relay.domainName),\n              ),\n            );\n            break;\n          }\n        }\n      }\n\n      let poolOwners: Serialization.CborSet<\n        Crypto.Ed25519KeyHashHex,\n        Serialization.Hash<Crypto.Ed25519KeyHashHex>\n      > = Serialization.CborSet.fromCore([], Serialization.Hash.fromCore);\n\n      let poolOwnersValues = [...poolOwners.values()];\n      for (const poolOwner of cert.poolParams.owners) {\n        poolOwnersValues.push(\n          Serialization.Hash.fromCore(Ed25519KeyHashHex(poolOwner)),\n        );\n      }\n      poolOwners.setValues(poolOwnersValues);\n\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.poolParams.rewardAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      const metadata = cert.poolParams.metadata\n        ? new Serialization.PoolMetadata(\n            cert.poolParams.metadata.URL,\n            Crypto.Hash32ByteBase16(cert.poolParams.metadata.hash),\n          )\n        : undefined;\n\n      return CardanoCert.newPoolRegistration(\n        new Serialization.PoolRegistration(\n          new Serialization.PoolParams(\n            Ed25519KeyHashHex(cert.poolParams.operator),\n            Cardano.VrfVkHex(cert.poolParams.vrfKeyHash),\n            BigInt(cert.poolParams.pledge),\n            BigInt(cert.poolParams.cost),\n            new Serialization.UnitInterval(\n              BigInt(cert.poolParams.margin[0]),\n              BigInt(cert.poolParams.margin[1]),\n            ),\n            rewardAddress,\n            poolOwners,\n            relays,\n            metadata,\n          ),\n        ),\n      );\n    }\n    case \"RegisterStake\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      return CardanoCert.newStakeRegistration(\n        new Serialization.StakeRegistration(\n          rewardAddress.getPaymentCredential(),\n        ),\n      );\n    }\n    case \"DelegateStake\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      return CardanoCert.newStakeDelegation(\n        new Serialization.StakeDelegation(\n          rewardAddress.getPaymentCredential(),\n          cert.poolId.startsWith(\"pool1\")\n            ? Cardano.PoolId.toKeyHash(Cardano.PoolId(cert.poolId))\n            : Ed25519KeyHashHex(cert.poolId),\n        ),\n      );\n    }\n    case \"DeregisterStake\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      return CardanoCert.newStakeDeregistration(\n        new Serialization.StakeDeregistration(\n          rewardAddress.getPaymentCredential(),\n        ),\n      );\n    }\n    case \"RetirePool\": {\n      return CardanoCert.newPoolRetirement(\n        new Serialization.PoolRetirement(\n          cert.poolId.startsWith(\"pool1\")\n            ? Cardano.PoolId.toKeyHash(Cardano.PoolId(cert.poolId))\n            : Ed25519KeyHashHex(cert.poolId),\n          Cardano.EpochNo(cert.epoch),\n        ),\n      );\n    }\n    case \"VoteDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      if ((cert.drep as { dRepId: string }).dRepId !== undefined) {\n        return CardanoCert.newVoteDelegationCert(\n          new Serialization.VoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            toDRep((cert.drep as { dRepId: string }).dRepId),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysAbstain: null }).alwaysAbstain !== undefined\n      ) {\n        return CardanoCert.newVoteDelegationCert(\n          new Serialization.VoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysAbstain(),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysNoConfidence: null }).alwaysNoConfidence !==\n        undefined\n      ) {\n        return CardanoCert.newVoteDelegationCert(\n          new Serialization.VoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysNoConfidence(),\n          ),\n        );\n      } else {\n        throw new Error(\"Malformed DRep type\");\n      }\n    }\n    case \"StakeAndVoteDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      if ((cert.drep as { dRepId: string }).dRepId !== undefined) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            toDRep((cert.drep as { dRepId: string }).dRepId),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysAbstain: null }).alwaysAbstain !== undefined\n      ) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysAbstain(),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysNoConfidence: null }).alwaysNoConfidence !==\n        undefined\n      ) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysNoConfidence(),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else {\n        throw new Error(\"Malformed DRep type\");\n      }\n    }\n    case \"StakeRegistrationAndDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      return CardanoCert.newStakeRegistrationDelegationCert(\n        new Serialization.StakeRegistrationDelegation(\n          rewardAddress.getPaymentCredential(),\n          BigInt(cert.coin),\n          Ed25519KeyHashHex(cert.poolKeyHash),\n        ),\n      );\n    }\n    case \"VoteRegistrationAndDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      if ((cert.drep as { dRepId: string }).dRepId !== undefined) {\n        return CardanoCert.newVoteRegistrationDelegationCert(\n          new Serialization.VoteRegistrationDelegation(\n            rewardAddress.getPaymentCredential(),\n            BigInt(cert.coin),\n            toDRep((cert.drep as { dRepId: string }).dRepId),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysAbstain: null }).alwaysAbstain !== undefined\n      ) {\n        return CardanoCert.newVoteRegistrationDelegationCert(\n          new Serialization.VoteRegistrationDelegation(\n            rewardAddress.getPaymentCredential(),\n            BigInt(cert.coin),\n            Serialization.DRep.newAlwaysAbstain(),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysNoConfidence: null }).alwaysNoConfidence !==\n        undefined\n      ) {\n        return CardanoCert.newVoteRegistrationDelegationCert(\n          new Serialization.VoteRegistrationDelegation(\n            rewardAddress.getPaymentCredential(),\n            BigInt(cert.coin),\n            Serialization.DRep.newAlwaysNoConfidence(),\n          ),\n        );\n      } else {\n        throw new Error(\"Malformed DRep type\");\n      }\n    }\n    case \"StakeVoteRegistrationAndDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      if ((cert.drep as { dRepId: string }).dRepId !== undefined) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            toDRep((cert.drep as { dRepId: string }).dRepId),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysAbstain: null }).alwaysAbstain !== undefined\n      ) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysAbstain(),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysNoConfidence: null }).alwaysNoConfidence !==\n        undefined\n      ) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysNoConfidence(),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else {\n        throw new Error(\"Malformed DRep type\");\n      }\n    }\n    case \"CommitteeHotAuth\": {\n      const hotCred = Cardano.Address.fromBech32(\n        cert.committeeHotKeyAddress,\n      ).getProps().paymentPart;\n      const coldCred = Cardano.Address.fromBech32(\n        cert.committeeColdKeyAddress,\n      ).getProps().paymentPart;\n      if (!hotCred || !coldCred) {\n        throw new Error(\"Malformed hot/cold credential\");\n      }\n      return CardanoCert.newAuthCommitteeHotCert(\n        new Serialization.AuthCommitteeHot(coldCred, hotCred),\n      );\n    }\n    case \"CommitteeColdResign\": {\n      const coldCred = Cardano.Address.fromBech32(\n        cert.committeeColdKeyAddress,\n      ).getProps().paymentPart;\n      if (!coldCred) {\n        throw new Error(\"Malformed hot/cold credential\");\n      }\n      let anchor: Serialization.Anchor | undefined = undefined;\n      if (cert.anchor) {\n        anchor = new Serialization.Anchor(\n          cert.anchor.anchorUrl,\n          Hash32ByteBase16(cert.anchor.anchorDataHash),\n        );\n      }\n      return CardanoCert.newResignCommitteeColdCert(\n        new Serialization.ResignCommitteeCold(coldCred, anchor),\n      );\n    }\n    case \"DRepRegistration\": {\n      let anchor: Serialization.Anchor | undefined = undefined;\n      if (cert.anchor) {\n        anchor = new Serialization.Anchor(\n          cert.anchor.anchorUrl,\n          Hash32ByteBase16(cert.anchor.anchorDataHash),\n        );\n      }\n\n      const coreDRep = toDRep(cert.drepId).toCore();\n      if (Cardano.isDRepCredential(coreDRep)) {\n        return CardanoCert.newRegisterDelegateRepresentativeCert(\n          new Serialization.RegisterDelegateRepresentative(\n            coreDRep,\n            BigInt(cert.coin),\n            anchor,\n          ),\n        );\n      } else {\n        throw new Error(\"DRepId must be a Credential\");\n      }\n    }\n    case \"DRepDeregistration\": {\n      const coreDRep = toDRep(cert.drepId).toCore();\n      if (Cardano.isDRepCredential(coreDRep)) {\n        return CardanoCert.newUnregisterDelegateRepresentativeCert(\n          new Serialization.UnregisterDelegateRepresentative(\n            coreDRep,\n            BigInt(cert.coin),\n          ),\n        );\n      } else {\n        throw new Error(\"DRepId must be a Credential\");\n      }\n    }\n    case \"DRepUpdate\": {\n      let anchor: Serialization.Anchor | undefined = undefined;\n      if (cert.anchor) {\n        anchor = new Serialization.Anchor(\n          cert.anchor.anchorUrl,\n          Hash32ByteBase16(cert.anchor.anchorDataHash),\n        );\n      }\n\n      const coreDRep = toDRep(cert.drepId).toCore();\n      if (Cardano.isDRepCredential(coreDRep)) {\n        return CardanoCert.newUpdateDelegateRepresentativeCert(\n          new Serialization.UpdateDelegateRepresentative(coreDRep, anchor),\n        );\n      } else {\n        throw new Error(\"DRepId must be a Credential\");\n      }\n    }\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const toCardanoCert = (cert: CertificateType): CardanoCert => {\n  switch (cert.type) {\n    case \"RegisterPool\": {\n      let relays: Serialization.Relay[] = [];\n\n      for (const relay of cert.poolParams.relays) {\n        switch (relay.type) {\n          case \"SingleHostAddr\": {\n            relays.push(\n              Serialization.Relay.newSingleHostAddr(\n                new Serialization.SingleHostAddr(\n                  relay.port,\n                  relay.IPV4,\n                  relay.IPV6,\n                ),\n              ),\n            );\n            break;\n          }\n          case \"SingleHostName\": {\n            relays.push(\n              Serialization.Relay.newSingleHostName(\n                new Serialization.SingleHostName(relay.domainName, relay.port),\n              ),\n            );\n            break;\n          }\n          case \"MultiHostName\": {\n            relays.push(\n              Serialization.Relay.newMultiHostName(\n                new Serialization.MultiHostName(relay.domainName),\n              ),\n            );\n            break;\n          }\n        }\n      }\n\n      let poolOwners: Serialization.CborSet<\n        Crypto.Ed25519KeyHashHex,\n        Serialization.Hash<Crypto.Ed25519KeyHashHex>\n      > = Serialization.CborSet.fromCore([], Serialization.Hash.fromCore);\n\n      let poolOwnersValues = [...poolOwners.values()];\n      for (const poolOwner of cert.poolParams.owners) {\n        poolOwnersValues.push(\n          Serialization.Hash.fromCore(Ed25519KeyHashHex(poolOwner)),\n        );\n      }\n      poolOwners.setValues(poolOwnersValues);\n\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.poolParams.rewardAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      const metadata = cert.poolParams.metadata\n        ? new Serialization.PoolMetadata(\n            cert.poolParams.metadata.URL,\n            Crypto.Hash32ByteBase16(cert.poolParams.metadata.hash),\n          )\n        : undefined;\n\n      return CardanoCert.newPoolRegistration(\n        new Serialization.PoolRegistration(\n          new Serialization.PoolParams(\n            Ed25519KeyHashHex(cert.poolParams.operator),\n            Cardano.VrfVkHex(cert.poolParams.vrfKeyHash),\n            BigInt(cert.poolParams.pledge),\n            BigInt(cert.poolParams.cost),\n            new Serialization.UnitInterval(\n              BigInt(cert.poolParams.margin[0]),\n              BigInt(cert.poolParams.margin[1]),\n            ),\n            rewardAddress,\n            poolOwners,\n            relays,\n            metadata,\n          ),\n        ),\n      );\n    }\n    case \"RegisterStake\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      return CardanoCert.newStakeRegistration(\n        new Serialization.StakeRegistration(\n          rewardAddress.getPaymentCredential(),\n        ),\n      );\n    }\n    case \"DelegateStake\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      return CardanoCert.newStakeDelegation(\n        new Serialization.StakeDelegation(\n          rewardAddress.getPaymentCredential(),\n          cert.poolId.startsWith(\"pool1\")\n            ? Cardano.PoolId.toKeyHash(Cardano.PoolId(cert.poolId))\n            : Ed25519KeyHashHex(cert.poolId),\n        ),\n      );\n    }\n    case \"DeregisterStake\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      return CardanoCert.newStakeDeregistration(\n        new Serialization.StakeDeregistration(\n          rewardAddress.getPaymentCredential(),\n        ),\n      );\n    }\n    case \"RetirePool\": {\n      return CardanoCert.newPoolRetirement(\n        new Serialization.PoolRetirement(\n          cert.poolId.startsWith(\"pool1\")\n            ? Cardano.PoolId.toKeyHash(Cardano.PoolId(cert.poolId))\n            : Ed25519KeyHashHex(cert.poolId),\n          Cardano.EpochNo(cert.epoch),\n        ),\n      );\n    }\n    case \"VoteDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      if ((cert.drep as { dRepId: string }).dRepId !== undefined) {\n        return CardanoCert.newVoteDelegationCert(\n          new Serialization.VoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            toDRep((cert.drep as { dRepId: string }).dRepId),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysAbstain: null }).alwaysAbstain !== undefined\n      ) {\n        return CardanoCert.newVoteDelegationCert(\n          new Serialization.VoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysAbstain(),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysNoConfidence: null }).alwaysNoConfidence !==\n        undefined\n      ) {\n        return CardanoCert.newVoteDelegationCert(\n          new Serialization.VoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysNoConfidence(),\n          ),\n        );\n      } else {\n        throw new Error(\"Malformed DRep type\");\n      }\n    }\n    case \"StakeAndVoteDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      if ((cert.drep as { dRepId: string }).dRepId !== undefined) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            toDRep((cert.drep as { dRepId: string }).dRepId),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysAbstain: null }).alwaysAbstain !== undefined\n      ) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysAbstain(),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysNoConfidence: null }).alwaysNoConfidence !==\n        undefined\n      ) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysNoConfidence(),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else {\n        throw new Error(\"Malformed DRep type\");\n      }\n    }\n    case \"StakeRegistrationAndDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      return CardanoCert.newStakeRegistrationDelegationCert(\n        new Serialization.StakeRegistrationDelegation(\n          rewardAddress.getPaymentCredential(),\n          BigInt(cert.coin),\n          Ed25519KeyHashHex(cert.poolKeyHash),\n        ),\n      );\n    }\n    case \"VoteRegistrationAndDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      if ((cert.drep as { dRepId: string }).dRepId !== undefined) {\n        return CardanoCert.newVoteRegistrationDelegationCert(\n          new Serialization.VoteRegistrationDelegation(\n            rewardAddress.getPaymentCredential(),\n            BigInt(cert.coin),\n            toDRep((cert.drep as { dRepId: string }).dRepId),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysAbstain: null }).alwaysAbstain !== undefined\n      ) {\n        return CardanoCert.newVoteRegistrationDelegationCert(\n          new Serialization.VoteRegistrationDelegation(\n            rewardAddress.getPaymentCredential(),\n            BigInt(cert.coin),\n            Serialization.DRep.newAlwaysAbstain(),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysNoConfidence: null }).alwaysNoConfidence !==\n        undefined\n      ) {\n        return CardanoCert.newVoteRegistrationDelegationCert(\n          new Serialization.VoteRegistrationDelegation(\n            rewardAddress.getPaymentCredential(),\n            BigInt(cert.coin),\n            Serialization.DRep.newAlwaysNoConfidence(),\n          ),\n        );\n      } else {\n        throw new Error(\"Malformed DRep type\");\n      }\n    }\n    case \"StakeVoteRegistrationAndDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      if ((cert.drep as { dRepId: string }).dRepId !== undefined) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            toDRep((cert.drep as { dRepId: string }).dRepId),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysAbstain: null }).alwaysAbstain !== undefined\n      ) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysAbstain(),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysNoConfidence: null }).alwaysNoConfidence !==\n        undefined\n      ) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysNoConfidence(),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else {\n        throw new Error(\"Malformed DRep type\");\n      }\n    }\n    case \"CommitteeHotAuth\": {\n      const hotCred = Cardano.Address.fromBech32(\n        cert.committeeHotKeyAddress,\n      ).getProps().paymentPart;\n      const coldCred = Cardano.Address.fromBech32(\n        cert.committeeColdKeyAddress,\n      ).getProps().paymentPart;\n      if (!hotCred || !coldCred) {\n        throw new Error(\"Malformed hot/cold credential\");\n      }\n      return CardanoCert.newAuthCommitteeHotCert(\n        new Serialization.AuthCommitteeHot(coldCred, hotCred),\n      );\n    }\n    case \"CommitteeColdResign\": {\n      const coldCred = Cardano.Address.fromBech32(\n        cert.committeeColdKeyAddress,\n      ).getProps().paymentPart;\n      if (!coldCred) {\n        throw new Error(\"Malformed hot/cold credential\");\n      }\n      let anchor: Serialization.Anchor | undefined = undefined;\n      if (cert.anchor) {\n        anchor = new Serialization.Anchor(\n          cert.anchor.anchorUrl,\n          Hash32ByteBase16(cert.anchor.anchorDataHash),\n        );\n      }\n      return CardanoCert.newResignCommitteeColdCert(\n        new Serialization.ResignCommitteeCold(coldCred, anchor),\n      );\n    }\n    case \"DRepRegistration\": {\n      let anchor: Serialization.Anchor | undefined = undefined;\n      if (cert.anchor) {\n        anchor = new Serialization.Anchor(\n          cert.anchor.anchorUrl,\n          Hash32ByteBase16(cert.anchor.anchorDataHash),\n        );\n      }\n\n      const coreDRep = toDRep(cert.drepId).toCore();\n      if (Cardano.isDRepCredential(coreDRep)) {\n        return CardanoCert.newRegisterDelegateRepresentativeCert(\n          new Serialization.RegisterDelegateRepresentative(\n            coreDRep,\n            BigInt(cert.coin),\n            anchor,\n          ),\n        );\n      } else {\n        throw new Error(\"DRepId must be a Credential\");\n      }\n    }\n    case \"DRepDeregistration\": {\n      const coreDRep = toDRep(cert.drepId).toCore();\n      if (Cardano.isDRepCredential(coreDRep)) {\n        return CardanoCert.newUnregisterDelegateRepresentativeCert(\n          new Serialization.UnregisterDelegateRepresentative(\n            coreDRep,\n            BigInt(cert.coin),\n          ),\n        );\n      } else {\n        throw new Error(\"DRepId must be a Credential\");\n      }\n    }\n    case \"DRepUpdate\": {\n      let anchor: Serialization.Anchor | undefined = undefined;\n      if (cert.anchor) {\n        anchor = new Serialization.Anchor(\n          cert.anchor.anchorUrl,\n          Hash32ByteBase16(cert.anchor.anchorDataHash),\n        );\n      }\n\n      const coreDRep = toDRep(cert.drepId).toCore();\n      if (Cardano.isDRepCredential(coreDRep)) {\n        return CardanoCert.newUpdateDelegateRepresentativeCert(\n          new Serialization.UpdateDelegateRepresentative(coreDRep, anchor),\n        );\n      } else {\n        throw new Error(\"DRepId must be a Credential\");\n      }\n    }\n  }\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "toCardanoCert",
          "type": "any",
          "value": "(cert: CertificateType): CardanoCert => {",
          "isPublic": true,
          "line": 12,
          "raw": "export const toCardanoCert = (cert: CertificateType): CardanoCert => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "rewardAddress",
          "type": "any",
          "value": "Cardano.RewardAddress.fromAddress(",
          "isPublic": true,
          "line": 63,
          "raw": "const rewardAddress = Cardano.RewardAddress.fromAddress(",
          "source": "mesh-core-cst"
        },
        {
          "name": "metadata",
          "type": "any",
          "value": "cert.poolParams.metadata",
          "isPublic": true,
          "line": 73,
          "raw": "const metadata = cert.poolParams.metadata",
          "source": "mesh-core-cst"
        },
        {
          "name": "rewardAddress",
          "type": "any",
          "value": "Cardano.RewardAddress.fromAddress(",
          "isPublic": true,
          "line": 100,
          "raw": "const rewardAddress = Cardano.RewardAddress.fromAddress(",
          "source": "mesh-core-cst"
        },
        {
          "name": "rewardAddress",
          "type": "any",
          "value": "Cardano.RewardAddress.fromAddress(",
          "isPublic": true,
          "line": 117,
          "raw": "const rewardAddress = Cardano.RewardAddress.fromAddress(",
          "source": "mesh-core-cst"
        },
        {
          "name": "rewardAddress",
          "type": "any",
          "value": "Cardano.RewardAddress.fromAddress(",
          "isPublic": true,
          "line": 137,
          "raw": "const rewardAddress = Cardano.RewardAddress.fromAddress(",
          "source": "mesh-core-cst"
        },
        {
          "name": "rewardAddress",
          "type": "any",
          "value": "Cardano.RewardAddress.fromAddress(",
          "isPublic": true,
          "line": 164,
          "raw": "const rewardAddress = Cardano.RewardAddress.fromAddress(",
          "source": "mesh-core-cst"
        },
        {
          "name": "rewardAddress",
          "type": "any",
          "value": "Cardano.RewardAddress.fromAddress(",
          "isPublic": true,
          "line": 205,
          "raw": "const rewardAddress = Cardano.RewardAddress.fromAddress(",
          "source": "mesh-core-cst"
        },
        {
          "name": "rewardAddress",
          "type": "any",
          "value": "Cardano.RewardAddress.fromAddress(",
          "isPublic": true,
          "line": 249,
          "raw": "const rewardAddress = Cardano.RewardAddress.fromAddress(",
          "source": "mesh-core-cst"
        },
        {
          "name": "rewardAddress",
          "type": "any",
          "value": "Cardano.RewardAddress.fromAddress(",
          "isPublic": true,
          "line": 268,
          "raw": "const rewardAddress = Cardano.RewardAddress.fromAddress(",
          "source": "mesh-core-cst"
        },
        {
          "name": "rewardAddress",
          "type": "any",
          "value": "Cardano.RewardAddress.fromAddress(",
          "isPublic": true,
          "line": 312,
          "raw": "const rewardAddress = Cardano.RewardAddress.fromAddress(",
          "source": "mesh-core-cst"
        },
        {
          "name": "hotCred",
          "type": "any",
          "value": "Cardano.Address.fromBech32(",
          "isPublic": true,
          "line": 356,
          "raw": "const hotCred = Cardano.Address.fromBech32(",
          "source": "mesh-core-cst"
        },
        {
          "name": "coldCred",
          "type": "any",
          "value": "Cardano.Address.fromBech32(",
          "isPublic": true,
          "line": 359,
          "raw": "const coldCred = Cardano.Address.fromBech32(",
          "source": "mesh-core-cst"
        },
        {
          "name": "coldCred",
          "type": "any",
          "value": "Cardano.Address.fromBech32(",
          "isPublic": true,
          "line": 370,
          "raw": "const coldCred = Cardano.Address.fromBech32(",
          "source": "mesh-core-cst"
        },
        {
          "name": "coreDRep",
          "type": "any",
          "value": "toDRep(cert.drepId).toCore();",
          "isPublic": true,
          "line": 396,
          "raw": "const coreDRep = toDRep(cert.drepId).toCore();",
          "source": "mesh-core-cst"
        },
        {
          "name": "coreDRep",
          "type": "any",
          "value": "toDRep(cert.drepId).toCore();",
          "isPublic": true,
          "line": 410,
          "raw": "const coreDRep = toDRep(cert.drepId).toCore();",
          "source": "mesh-core-cst"
        },
        {
          "name": "coreDRep",
          "type": "any",
          "value": "toDRep(cert.drepId).toCore();",
          "isPublic": true,
          "line": 431,
          "raw": "const coreDRep = toDRep(cert.drepId).toCore();",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { Cardano, Serialization } from \"@cardano-sdk/core\";\n\nimport { CertificateType } from \"@meshsdk/common\";\n\nimport { Crypto, toDRep } from \"..\";\nimport {\n  Certificate as CardanoCert,\n  Ed25519KeyHashHex,\n  Hash32ByteBase16,\n} from \"../types\";\n\nexport const toCardanoCert = (cert: CertificateType): CardanoCert => {\n  switch (cert.type) {\n    case \"RegisterPool\": {\n      let relays: Serialization.Relay[] = [];\n\n      for (const relay of cert.poolParams.relays) {\n        switch (relay.type) {\n          case \"SingleHostAddr\": {\n            relays.push(\n              Serialization.Relay.newSingleHostAddr(\n                new Serialization.SingleHostAddr(\n                  relay.port,\n                  relay.IPV4,\n                  relay.IPV6,\n                ),\n              ),\n            );\n            break;\n          }\n          case \"SingleHostName\": {\n            relays.push(\n              Serialization.Relay.newSingleHostName(\n                new Serialization.SingleHostName(relay.domainName, relay.port),\n              ),\n            );\n            break;\n          }\n          case \"MultiHostName\": {\n            relays.push(\n              Serialization.Relay.newMultiHostName(\n                new Serialization.MultiHostName(relay.domainName),\n              ),\n            );\n            break;\n          }\n        }\n      }\n\n      let poolOwners: Serialization.CborSet<\n        Crypto.Ed25519KeyHashHex,\n        Serialization.Hash<Crypto.Ed25519KeyHashHex>\n      > = Serialization.CborSet.fromCore([], Serialization.Hash.fromCore);\n\n      let poolOwnersValues = [...poolOwners.values()];\n      for (const poolOwner of cert.poolParams.owners) {\n        poolOwnersValues.push(\n          Serialization.Hash.fromCore(Ed25519KeyHashHex(poolOwner)),\n        );\n      }\n      poolOwners.setValues(poolOwnersValues);\n\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.poolParams.rewardAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      const metadata = cert.poolParams.metadata\n        ? new Serialization.PoolMetadata(\n            cert.poolParams.metadata.URL,\n            Crypto.Hash32ByteBase16(cert.poolParams.metadata.hash),\n          )\n        : undefined;\n\n      return CardanoCert.newPoolRegistration(\n        new Serialization.PoolRegistration(\n          new Serialization.PoolParams(\n            Ed25519KeyHashHex(cert.poolParams.operator),\n            Cardano.VrfVkHex(cert.poolParams.vrfKeyHash),\n            BigInt(cert.poolParams.pledge),\n            BigInt(cert.poolParams.cost),\n            new Serialization.UnitInterval(\n              BigInt(cert.poolParams.margin[0]),\n              BigInt(cert.poolParams.margin[1]),\n            ),\n            rewardAddress,\n            poolOwners,\n            relays,\n            metadata,\n          ),\n        ),\n      );\n    }\n    case \"RegisterStake\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      return CardanoCert.newStakeRegistration(\n        new Serialization.StakeRegistration(\n          rewardAddress.getPaymentCredential(),\n        ),\n      );\n    }\n    case \"DelegateStake\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      return CardanoCert.newStakeDelegation(\n        new Serialization.StakeDelegation(\n          rewardAddress.getPaymentCredential(),\n          cert.poolId.startsWith(\"pool1\")\n            ? Cardano.PoolId.toKeyHash(Cardano.PoolId(cert.poolId))\n            : Ed25519KeyHashHex(cert.poolId),\n        ),\n      );\n    }\n    case \"DeregisterStake\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      return CardanoCert.newStakeDeregistration(\n        new Serialization.StakeDeregistration(\n          rewardAddress.getPaymentCredential(),\n        ),\n      );\n    }\n    case \"RetirePool\": {\n      return CardanoCert.newPoolRetirement(\n        new Serialization.PoolRetirement(\n          cert.poolId.startsWith(\"pool1\")\n            ? Cardano.PoolId.toKeyHash(Cardano.PoolId(cert.poolId))\n            : Ed25519KeyHashHex(cert.poolId),\n          Cardano.EpochNo(cert.epoch),\n        ),\n      );\n    }\n    case \"VoteDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      if ((cert.drep as { dRepId: string }).dRepId !== undefined) {\n        return CardanoCert.newVoteDelegationCert(\n          new Serialization.VoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            toDRep((cert.drep as { dRepId: string }).dRepId),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysAbstain: null }).alwaysAbstain !== undefined\n      ) {\n        return CardanoCert.newVoteDelegationCert(\n          new Serialization.VoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysAbstain(),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysNoConfidence: null }).alwaysNoConfidence !==\n        undefined\n      ) {\n        return CardanoCert.newVoteDelegationCert(\n          new Serialization.VoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysNoConfidence(),\n          ),\n        );\n      } else {\n        throw new Error(\"Malformed DRep type\");\n      }\n    }\n    case \"StakeAndVoteDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      if ((cert.drep as { dRepId: string }).dRepId !== undefined) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            toDRep((cert.drep as { dRepId: string }).dRepId),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysAbstain: null }).alwaysAbstain !== undefined\n      ) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysAbstain(),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysNoConfidence: null }).alwaysNoConfidence !==\n        undefined\n      ) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysNoConfidence(),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else {\n        throw new Error(\"Malformed DRep type\");\n      }\n    }\n    case \"StakeRegistrationAndDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      return CardanoCert.newStakeRegistrationDelegationCert(\n        new Serialization.StakeRegistrationDelegation(\n          rewardAddress.getPaymentCredential(),\n          BigInt(cert.coin),\n          Ed25519KeyHashHex(cert.poolKeyHash),\n        ),\n      );\n    }\n    case \"VoteRegistrationAndDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      if ((cert.drep as { dRepId: string }).dRepId !== undefined) {\n        return CardanoCert.newVoteRegistrationDelegationCert(\n          new Serialization.VoteRegistrationDelegation(\n            rewardAddress.getPaymentCredential(),\n            BigInt(cert.coin),\n            toDRep((cert.drep as { dRepId: string }).dRepId),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysAbstain: null }).alwaysAbstain !== undefined\n      ) {\n        return CardanoCert.newVoteRegistrationDelegationCert(\n          new Serialization.VoteRegistrationDelegation(\n            rewardAddress.getPaymentCredential(),\n            BigInt(cert.coin),\n            Serialization.DRep.newAlwaysAbstain(),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysNoConfidence: null }).alwaysNoConfidence !==\n        undefined\n      ) {\n        return CardanoCert.newVoteRegistrationDelegationCert(\n          new Serialization.VoteRegistrationDelegation(\n            rewardAddress.getPaymentCredential(),\n            BigInt(cert.coin),\n            Serialization.DRep.newAlwaysNoConfidence(),\n          ),\n        );\n      } else {\n        throw new Error(\"Malformed DRep type\");\n      }\n    }\n    case \"StakeVoteRegistrationAndDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      if ((cert.drep as { dRepId: string }).dRepId !== undefined) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            toDRep((cert.drep as { dRepId: string }).dRepId),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysAbstain: null }).alwaysAbstain !== undefined\n      ) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysAbstain(),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysNoConfidence: null }).alwaysNoConfidence !==\n        undefined\n      ) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysNoConfidence(),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else {\n        throw new Error(\"Malformed DRep type\");\n      }\n    }\n    case \"CommitteeHotAuth\": {\n      const hotCred = Cardano.Address.fromBech32(\n        cert.committeeHotKeyAddress,\n      ).getProps().paymentPart;\n      const coldCred = Cardano.Address.fromBech32(\n        cert.committeeColdKeyAddress,\n      ).getProps().paymentPart;\n      if (!hotCred || !coldCred) {\n        throw new Error(\"Malformed hot/cold credential\");\n      }\n      return CardanoCert.newAuthCommitteeHotCert(\n        new Serialization.AuthCommitteeHot(coldCred, hotCred),\n      );\n    }\n    case \"CommitteeColdResign\": {\n      const coldCred = Cardano.Address.fromBech32(\n        cert.committeeColdKeyAddress,\n      ).getProps().paymentPart;\n      if (!coldCred) {\n        throw new Error(\"Malformed hot/cold credential\");\n      }\n      let anchor: Serialization.Anchor | undefined = undefined;\n      if (cert.anchor) {\n        anchor = new Serialization.Anchor(\n          cert.anchor.anchorUrl,\n          Hash32ByteBase16(cert.anchor.anchorDataHash),\n        );\n      }\n      return CardanoCert.newResignCommitteeColdCert(\n        new Serialization.ResignCommitteeCold(coldCred, anchor),\n      );\n    }\n    case \"DRepRegistration\": {\n      let anchor: Serialization.Anchor | undefined = undefined;\n      if (cert.anchor) {\n        anchor = new Serialization.Anchor(\n          cert.anchor.anchorUrl,\n          Hash32ByteBase16(cert.anchor.anchorDataHash),\n        );\n      }\n\n      const coreDRep = toDRep(cert.drepId).toCore();\n      if (Cardano.isDRepCredential(coreDRep)) {\n        return CardanoCert.newRegisterDelegateRepresentativeCert(\n          new Serialization.RegisterDelegateRepresentative(\n            coreDRep,\n            BigInt(cert.coin),\n            anchor,\n          ),\n        );\n      } else {\n        throw new Error(\"DRepId must be a Credential\");\n      }\n    }\n    case \"DRepDeregistration\": {\n      const coreDRep = toDRep(cert.drepId).toCore();\n      if (Cardano.isDRepCredential(coreDRep)) {\n        return CardanoCert.newUnregisterDelegateRepresentativeCert(\n          new Serialization.UnregisterDelegateRepresentative(\n            coreDRep,\n            BigInt(cert.coin),\n          ),\n        );\n      } else {\n        throw new Error(\"DRepId must be a Credential\");\n      }\n    }\n    case \"DRepUpdate\": {\n      let anchor: Serialization.Anchor | undefined = undefined;\n      if (cert.anchor) {\n        anchor = new Serialization.Anchor(\n          cert.anchor.anchorUrl,\n          Hash32ByteBase16(cert.anchor.anchorDataHash),\n        );\n      }\n\n      const coreDRep = toDRep(cert.drepId).toCore();\n      if (Cardano.isDRepCredential(coreDRep)) {\n        return CardanoCert.newUpdateDelegateRepresentativeCert(\n          new Serialization.UpdateDelegateRepresentative(coreDRep, anchor),\n        );\n      } else {\n        throw new Error(\"DRepId must be a Credential\");\n      }\n    }\n  }\n};\n",
      "dependencies": [
        "toCardanoCert"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:utils.converter.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/utils/converter.ts",
      "name": "utils.converter.ts",
      "imports": [
        {
          "module": "toAddress",
          "items": [],
          "line": 51,
          "raw": "export const toAddress = (bech32: string): Address =>",
          "source": "mesh-core-cst"
        },
        {
          "module": "toCardanoAddress",
          "items": [],
          "line": 54,
          "raw": "export const toCardanoAddress = (address: string): Address => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "toBaseAddress",
          "items": [],
          "line": 66,
          "raw": "export const toBaseAddress = (bech32: string): BaseAddress | undefined => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "toEnterpriseAddress",
          "items": [],
          "line": 70,
          "raw": "export const toEnterpriseAddress = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "toRewardAddress",
          "items": [],
          "line": 76,
          "raw": "export const toRewardAddress = (bech32: string): RewardAddress | undefined =>",
          "source": "mesh-core-cst"
        },
        {
          "module": "fromTxUnspentOutput",
          "items": [],
          "line": 79,
          "raw": "export const fromTxUnspentOutput = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "toTxUnspentOutput",
          "items": [],
          "line": 109,
          "raw": "export const toTxUnspentOutput = (utxo: UTxO) => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "addressToBech32",
          "items": [],
          "line": 139,
          "raw": "export const addressToBech32 = (address: Address): string => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "fromValue",
          "items": [],
          "line": 143,
          "raw": "export const fromValue = (value: Value) => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "toScriptRef",
          "items": [],
          "line": 168,
          "raw": "export const toScriptRef = (script: PlutusScript | NativeScript): Script => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "fromScriptRef",
          "items": [],
          "line": 181,
          "raw": "export const fromScriptRef = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "fromNativeScript",
          "items": [],
          "line": 219,
          "raw": "export const fromNativeScript = (script: CstNativeScript) => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "toNativeScript",
          "items": [],
          "line": 282,
          "raw": "export const toNativeScript = (script: NativeScript) => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "toValue",
          "items": [],
          "line": 326,
          "raw": "export const toValue = (assets: Asset[]) => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "toDRep",
          "items": [],
          "line": 344,
          "raw": "export const toDRep = (dRepId: string): Serialization.DRep => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "getDRepIds",
          "items": [],
          "line": 388,
          "raw": "export const getDRepIds = (",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "toAddress",
          "signature": "export const toAddress = (bech32: string): Address =>",
          "documentation": "",
          "parameters": [
            {
              "name": "bech32",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Address",
          "isPublic": true,
          "line": 51,
          "raw": "export const toAddress = (bech32: string): Address =>\n  Address.fromBech32(bech32);\n\nexport const toCardanoAddress = (address: string): Address => {\n  try {\n    return Address.fromBech32(address);\n  } catch {\n    try {\n      return Address.fromBase58(address);\n    } catch {\n      throw new Error(`Invalid address format, ${address}`);\n    }\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const toAddress = (bech32: string): Address =>\n  Address.fromBech32(bech32);\n\nexport const toCardanoAddress = (address: string): Address => {\n  try {\n    return Address.fromBech32(address);\n  } catch {\n    try {\n      return Address.fromBase58(address);\n    } catch {\n      throw new Error(`Invalid address format, ${address}`);\n    }\n  }\n};"
        },
        {
          "name": "toCardanoAddress",
          "signature": "export const toCardanoAddress = (address: string): Address => {",
          "documentation": "",
          "parameters": [
            {
              "name": "address",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Address",
          "isPublic": true,
          "line": 54,
          "raw": "export const toCardanoAddress = (address: string): Address => {\n  try {\n    return Address.fromBech32(address);\n  } catch {\n    try {\n      return Address.fromBase58(address);\n    } catch {\n      throw new Error(`Invalid address format, ${address}`);\n    }\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const toCardanoAddress = (address: string): Address => {\n  try {\n    return Address.fromBech32(address);\n  } catch {\n    try {\n      return Address.fromBase58(address);\n    } catch {\n      throw new Error(`Invalid address format, ${address}`);\n    }\n  }\n};"
        },
        {
          "name": "toBaseAddress",
          "signature": "export const toBaseAddress = (bech32: string): BaseAddress | undefined => {",
          "documentation": "",
          "parameters": [
            {
              "name": "bech32",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "BaseAddress | undefined",
          "isPublic": true,
          "line": 66,
          "raw": "export const toBaseAddress = (bech32: string): BaseAddress | undefined => {\n  return BaseAddress.fromAddress(toAddress(bech32));\n};",
          "source": "mesh-core-cst",
          "implementation": "export const toBaseAddress = (bech32: string): BaseAddress | undefined => {\n  return BaseAddress.fromAddress(toAddress(bech32));\n};"
        },
        {
          "name": "toEnterpriseAddress",
          "signature": "export const toEnterpriseAddress = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 70,
          "raw": "export const toEnterpriseAddress = (\n  bech32: string,\n): EnterpriseAddress | undefined => {\n  return EnterpriseAddress.fromAddress(toAddress(bech32));\n};",
          "source": "mesh-core-cst",
          "implementation": "export const toEnterpriseAddress = (\n  bech32: string,\n): EnterpriseAddress | undefined => {\n  return EnterpriseAddress.fromAddress(toAddress(bech32));\n};"
        },
        {
          "name": "toRewardAddress",
          "signature": "export const toRewardAddress = (bech32: string): RewardAddress | undefined =>",
          "documentation": "",
          "parameters": [
            {
              "name": "bech32",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "RewardAddress | undefined",
          "isPublic": true,
          "line": 76,
          "raw": "export const toRewardAddress = (bech32: string): RewardAddress | undefined =>\n  RewardAddress.fromAddress(toAddress(bech32));\n\nexport const fromTxUnspentOutput = (\n  txUnspentOutput: TransactionUnspentOutput,\n): UTxO => {\n  const dataHash = txUnspentOutput.output().datum()\n    ? txUnspentOutput.output().datum()?.toCbor().toString()\n    : undefined;\n\n  const scriptRef = txUnspentOutput.output().scriptRef()\n    ? txUnspentOutput.output().scriptRef()?.toCbor().toString()\n    : undefined;\n\n  const plutusData = txUnspentOutput.output().datum()?.asInlineData()\n    ? txUnspentOutput.output().datum()?.asInlineData()?.toCbor().toString()\n    : undefined;\n\n  return <UTxO>{\n    input: {\n      outputIndex: Number(txUnspentOutput.input().index()),\n      txHash: txUnspentOutput.input().transactionId(),\n    },\n    output: {\n      address: txUnspentOutput.output().address().toBech32(),\n      amount: fromValue(txUnspentOutput.output().amount()),\n      dataHash: dataHash, // todo not sure if correct\n      plutusData: plutusData, // todo not sure if correct\n      scriptRef: scriptRef, // todo not sure if correct\n    },\n  };\n};",
          "source": "mesh-core-cst",
          "implementation": "export const toRewardAddress = (bech32: string): RewardAddress | undefined =>\n  RewardAddress.fromAddress(toAddress(bech32));\n\nexport const fromTxUnspentOutput = (\n  txUnspentOutput: TransactionUnspentOutput,\n): UTxO => {\n  const dataHash = txUnspentOutput.output().datum()\n    ? txUnspentOutput.output().datum()?.toCbor().toString()\n    : undefined;\n\n  const scriptRef = txUnspentOutput.output().scriptRef()\n    ? txUnspentOutput.output().scriptRef()?.toCbor().toString()\n    : undefined;\n\n  const plutusData = txUnspentOutput.output().datum()?.asInlineData()\n    ? txUnspentOutput.output().datum()?.asInlineData()?.toCbor().toString()\n    : undefined;\n\n  return <UTxO>{\n    input: {\n      outputIndex: Number(txUnspentOutput.input().index()),\n      txHash: txUnspentOutput.input().transactionId(),\n    },\n    output: {\n      address: txUnspentOutput.output().address().toBech32(),\n      amount: fromValue(txUnspentOutput.output().amount()),\n      dataHash: dataHash, // todo not sure if correct\n      plutusData: plutusData, // todo not sure if correct\n      scriptRef: scriptRef, // todo not sure if correct\n    },\n  };\n};"
        },
        {
          "name": "fromTxUnspentOutput",
          "signature": "export const fromTxUnspentOutput = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 79,
          "raw": "export const fromTxUnspentOutput = (\n  txUnspentOutput: TransactionUnspentOutput,\n): UTxO => {\n  const dataHash = txUnspentOutput.output().datum()\n    ? txUnspentOutput.output().datum()?.toCbor().toString()\n    : undefined;\n\n  const scriptRef = txUnspentOutput.output().scriptRef()\n    ? txUnspentOutput.output().scriptRef()?.toCbor().toString()\n    : undefined;\n\n  const plutusData = txUnspentOutput.output().datum()?.asInlineData()\n    ? txUnspentOutput.output().datum()?.asInlineData()?.toCbor().toString()\n    : undefined;\n\n  return <UTxO>{\n    input: {\n      outputIndex: Number(txUnspentOutput.input().index()),\n      txHash: txUnspentOutput.input().transactionId(),\n    },\n    output: {\n      address: txUnspentOutput.output().address().toBech32(),\n      amount: fromValue(txUnspentOutput.output().amount()),\n      dataHash: dataHash, // todo not sure if correct\n      plutusData: plutusData, // todo not sure if correct\n      scriptRef: scriptRef, // todo not sure if correct\n    },\n  };\n};",
          "source": "mesh-core-cst",
          "implementation": "export const fromTxUnspentOutput = (\n  txUnspentOutput: TransactionUnspentOutput,\n): UTxO => {\n  const dataHash = txUnspentOutput.output().datum()\n    ? txUnspentOutput.output().datum()?.toCbor().toString()\n    : undefined;\n\n  const scriptRef = txUnspentOutput.output().scriptRef()\n    ? txUnspentOutput.output().scriptRef()?.toCbor().toString()\n    : undefined;\n\n  const plutusData = txUnspentOutput.output().datum()?.asInlineData()\n    ? txUnspentOutput.output().datum()?.asInlineData()?.toCbor().toString()\n    : undefined;\n\n  return <UTxO>{\n    input: {\n      outputIndex: Number(txUnspentOutput.input().index()),\n      txHash: txUnspentOutput.input().transactionId(),\n    },\n    output: {\n      address: txUnspentOutput.output().address().toBech32(),\n      amount: fromValue(txUnspentOutput.output().amount()),\n      dataHash: dataHash, // todo not sure if correct\n      plutusData: plutusData, // todo not sure if correct\n      scriptRef: scriptRef, // todo not sure if correct\n    },\n  };\n};"
        },
        {
          "name": "toTxUnspentOutput",
          "signature": "export const toTxUnspentOutput = (utxo: UTxO) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "utxo",
              "type": "UTxO",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 109,
          "raw": "export const toTxUnspentOutput = (utxo: UTxO) => {\n  const txInput = new TransactionInput(\n    deserializeTxHash(utxo.input.txHash),\n    BigInt(utxo.input.outputIndex),\n  );\n\n  const txOutput = new TransactionOutput(\n    toAddress(utxo.output.address),\n    toValue(utxo.output.amount),\n  );\n\n  if (utxo.output.dataHash !== undefined) {\n    txOutput.setDatum(\n      Datum.fromCore(deserializeDataHash(utxo.output.dataHash)),\n    );\n  }\n\n  if (utxo.output.plutusData !== undefined) {\n    const plutusData = deserializePlutusData(utxo.output.plutusData);\n    const datum = new Serialization.Datum(undefined, plutusData);\n    txOutput.setDatum(datum);\n  }\n\n  if (utxo.output.scriptRef !== undefined) {\n    txOutput.setScriptRef(deserializeScriptRef(utxo.output.scriptRef));\n  }\n\n  return new TransactionUnspentOutput(txInput, txOutput);\n};",
          "source": "mesh-core-cst",
          "implementation": "export const toTxUnspentOutput = (utxo: UTxO) => {\n  const txInput = new TransactionInput(\n    deserializeTxHash(utxo.input.txHash),\n    BigInt(utxo.input.outputIndex),\n  );\n\n  const txOutput = new TransactionOutput(\n    toAddress(utxo.output.address),\n    toValue(utxo.output.amount),\n  );\n\n  if (utxo.output.dataHash !== undefined) {\n    txOutput.setDatum(\n      Datum.fromCore(deserializeDataHash(utxo.output.dataHash)),\n    );\n  }\n\n  if (utxo.output.plutusData !== undefined) {\n    const plutusData = deserializePlutusData(utxo.output.plutusData);\n    const datum = new Serialization.Datum(undefined, plutusData);\n    txOutput.setDatum(datum);\n  }\n\n  if (utxo.output.scriptRef !== undefined) {\n    txOutput.setScriptRef(deserializeScriptRef(utxo.output.scriptRef));\n  }\n\n  return new TransactionUnspentOutput(txInput, txOutput);\n};"
        },
        {
          "name": "addressToBech32",
          "signature": "export const addressToBech32 = (address: Address): string => {",
          "documentation": "",
          "parameters": [
            {
              "name": "address",
              "type": "Address",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 139,
          "raw": "export const addressToBech32 = (address: Address): string => {\n  return address.toBech32();\n};",
          "source": "mesh-core-cst",
          "implementation": "export const addressToBech32 = (address: Address): string => {\n  return address.toBech32();\n};"
        },
        {
          "name": "fromValue",
          "signature": "export const fromValue = (value: Value) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "value",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 143,
          "raw": "export const fromValue = (value: Value) => {\n  const assets: Asset[] = [\n    { unit: \"lovelace\", quantity: value.coin().toString() },\n  ];\n\n  const multiAsset = value.multiasset();\n  if (multiAsset !== undefined) {\n    const _assets = Array.from(multiAsset.keys());\n    for (let i = 0; i < _assets.length; i += 1) {\n      const assetId = _assets[i];\n      if (assetId !== undefined) {\n        const assetQuantity = multiAsset.get(assetId);\n        if (assetQuantity !== undefined) {\n          assets.push({\n            unit: assetId as Unit,\n            quantity: assetQuantity.toString() as Quantity,\n          });\n        }\n      }\n    }\n  }\n\n  return assets;\n};",
          "source": "mesh-core-cst",
          "implementation": "export const fromValue = (value: Value) => {\n  const assets: Asset[] = [\n    { unit: \"lovelace\", quantity: value.coin().toString() },\n  ];\n\n  const multiAsset = value.multiasset();\n  if (multiAsset !== undefined) {\n    const _assets = Array.from(multiAsset.keys());\n    for (let i = 0; i < _assets.length; i += 1) {\n      const assetId = _assets[i];\n      if (assetId !== undefined) {\n        const assetQuantity = multiAsset.get(assetId);\n        if (assetQuantity !== undefined) {\n          assets.push({\n            unit: assetId as Unit,\n            quantity: assetQuantity.toString() as Quantity,\n          });\n        }\n      }\n    }\n  }\n\n  return assets;\n};"
        },
        {
          "name": "toScriptRef",
          "signature": "export const toScriptRef = (script: PlutusScript | NativeScript): Script => {",
          "documentation": "",
          "parameters": [
            {
              "name": "script",
              "type": "PlutusScript | NativeScript",
              "optional": false
            }
          ],
          "returnType": "Script",
          "isPublic": true,
          "line": 168,
          "raw": "export const toScriptRef = (script: PlutusScript | NativeScript): Script => {\n  if (\"code\" in script) {\n    const plutusScript = deserializePlutusScript(script.code, script.version);\n    if (plutusScript instanceof PlutusV1Script)\n      return Script.newPlutusV1Script(plutusScript);\n    if (plutusScript instanceof PlutusV2Script)\n      return Script.newPlutusV2Script(plutusScript);\n    if (plutusScript instanceof PlutusV3Script)\n      return Script.newPlutusV3Script(plutusScript);\n  }\n  return Script.newNativeScript(toNativeScript(script as NativeScript));\n};",
          "source": "mesh-core-cst",
          "implementation": "export const toScriptRef = (script: PlutusScript | NativeScript): Script => {\n  if (\"code\" in script) {\n    const plutusScript = deserializePlutusScript(script.code, script.version);\n    if (plutusScript instanceof PlutusV1Script)\n      return Script.newPlutusV1Script(plutusScript);\n    if (plutusScript instanceof PlutusV2Script)\n      return Script.newPlutusV2Script(plutusScript);\n    if (plutusScript instanceof PlutusV3Script)\n      return Script.newPlutusV3Script(plutusScript);\n  }\n  return Script.newNativeScript(toNativeScript(script as NativeScript));\n};"
        },
        {
          "name": "fromScriptRef",
          "signature": "export const fromScriptRef = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 181,
          "raw": "export const fromScriptRef = (\n  scriptRef: string,\n): PlutusScript | NativeScript | undefined => {\n  const script = Script.fromCbor(HexBlob(scriptRef));\n\n  const plutusScriptCodeV3 = script.asPlutusV3()?.toCbor().toString();\n  if (plutusScriptCodeV3) {\n    return {\n      code: plutusScriptCodeV3,\n      version: \"V3\",\n    };\n  }\n\n  const plutusScriptCodeV2 = script.asPlutusV2()?.toCbor().toString();\n  if (plutusScriptCodeV2) {\n    return {\n      code: plutusScriptCodeV2,\n      version: \"V2\",\n    };\n  }\n\n  const plutusScriptCodeV1 = script.asPlutusV1()?.toCbor().toString();\n  if (plutusScriptCodeV1) {\n    return {\n      code: plutusScriptCodeV1,\n      version: \"V1\",\n    };\n  }\n\n  // TODO: implement from native script\n  const nativeScript = script.asNative();\n  if (!nativeScript) {\n    throw new Error(\"Invalid script\");\n  }\n\n  return fromNativeScript(nativeScript);\n};",
          "source": "mesh-core-cst",
          "implementation": "export const fromScriptRef = (\n  scriptRef: string,\n): PlutusScript | NativeScript | undefined => {\n  const script = Script.fromCbor(HexBlob(scriptRef));\n\n  const plutusScriptCodeV3 = script.asPlutusV3()?.toCbor().toString();\n  if (plutusScriptCodeV3) {\n    return {\n      code: plutusScriptCodeV3,\n      version: \"V3\",\n    };\n  }\n\n  const plutusScriptCodeV2 = script.asPlutusV2()?.toCbor().toString();\n  if (plutusScriptCodeV2) {\n    return {\n      code: plutusScriptCodeV2,\n      version: \"V2\",\n    };\n  }\n\n  const plutusScriptCodeV1 = script.asPlutusV1()?.toCbor().toString();\n  if (plutusScriptCodeV1) {\n    return {\n      code: plutusScriptCodeV1,\n      version: \"V1\",\n    };\n  }\n\n  // TODO: implement from native script\n  const nativeScript = script.asNative();\n  if (!nativeScript) {\n    throw new Error(\"Invalid script\");\n  }\n\n  return fromNativeScript(nativeScript);\n};"
        },
        {
          "name": "fromNativeScript",
          "signature": "export const fromNativeScript = (script: CstNativeScript) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "script",
              "type": "CstNativeScript",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 219,
          "raw": "export const fromNativeScript = (script: CstNativeScript) => {\n  const fromNativeScripts = (scripts: CstNativeScript[]) => {\n    const nativeScripts = new Array<NativeScript>();\n\n    for (let index = 0; index < scripts.length; index += 1) {\n      const script = scripts[index];\n      if (script) {\n        nativeScripts.push(fromNativeScript(script));\n      }\n    }\n\n    return nativeScripts;\n  };\n\n  switch (script.kind()) {\n    case RequireAllOf: {\n      const scriptAll = script.asScriptAll()!;\n      return <NativeScript>{\n        type: \"all\",\n        scripts: fromNativeScripts(scriptAll.nativeScripts()),\n      };\n    }\n    case RequireAnyOf: {\n      const scriptAny = script.asScriptAny()!;\n      return <NativeScript>{\n        type: \"any\",\n        scripts: fromNativeScripts(scriptAny.nativeScripts()),\n      };\n    }\n    case RequireNOf: {\n      const scriptNOfK = script.asScriptNOfK()!;\n      return <NativeScript>{\n        type: \"atLeast\",\n        required: scriptNOfK.required(),\n        scripts: fromNativeScripts(scriptNOfK.nativeScripts()),\n      };\n    }\n    case RequireTimeAfter: {\n      const timelockStart = script.asTimelockStart()!;\n      return <NativeScript>{\n        type: \"after\",\n        slot: timelockStart.slot().toString(),\n      };\n    }\n    case RequireTimeBefore: {\n      const timelockExpiry = script.asTimelockExpiry()!;\n      return <NativeScript>{\n        type: \"before\",\n        slot: timelockExpiry.slot().toString(),\n      };\n    }\n    case RequireSignature: {\n      const scriptPubkey = script.asScriptPubkey()!;\n      return <NativeScript>{\n        type: \"sig\",\n        keyHash: scriptPubkey.keyHash().toString(),\n      };\n    }\n    default:\n      throw new Error(`Script Kind: ${script.kind()}, is not supported`);\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const fromNativeScript = (script: CstNativeScript) => {\n  const fromNativeScripts = (scripts: CstNativeScript[]) => {\n    const nativeScripts = new Array<NativeScript>();\n\n    for (let index = 0; index < scripts.length; index += 1) {\n      const script = scripts[index];\n      if (script) {\n        nativeScripts.push(fromNativeScript(script));\n      }\n    }\n\n    return nativeScripts;\n  };\n\n  switch (script.kind()) {\n    case RequireAllOf: {\n      const scriptAll = script.asScriptAll()!;\n      return <NativeScript>{\n        type: \"all\",\n        scripts: fromNativeScripts(scriptAll.nativeScripts()),\n      };\n    }\n    case RequireAnyOf: {\n      const scriptAny = script.asScriptAny()!;\n      return <NativeScript>{\n        type: \"any\",\n        scripts: fromNativeScripts(scriptAny.nativeScripts()),\n      };\n    }\n    case RequireNOf: {\n      const scriptNOfK = script.asScriptNOfK()!;\n      return <NativeScript>{\n        type: \"atLeast\",\n        required: scriptNOfK.required(),\n        scripts: fromNativeScripts(scriptNOfK.nativeScripts()),\n      };\n    }\n    case RequireTimeAfter: {\n      const timelockStart = script.asTimelockStart()!;\n      return <NativeScript>{\n        type: \"after\",\n        slot: timelockStart.slot().toString(),\n      };\n    }\n    case RequireTimeBefore: {\n      const timelockExpiry = script.asTimelockExpiry()!;\n      return <NativeScript>{\n        type: \"before\",\n        slot: timelockExpiry.slot().toString(),\n      };\n    }\n    case RequireSignature: {\n      const scriptPubkey = script.asScriptPubkey()!;\n      return <NativeScript>{\n        type: \"sig\",\n        keyHash: scriptPubkey.keyHash().toString(),\n      };\n    }\n    default:\n      throw new Error(`Script Kind: ${script.kind()}, is not supported`);\n  }\n};"
        },
        {
          "name": "fromNativeScripts",
          "signature": "const fromNativeScripts = (scripts: CstNativeScript[]) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "scripts",
              "type": "CstNativeScript[]",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 220,
          "raw": "  const fromNativeScripts = (scripts: CstNativeScript[]) => {\n    const nativeScripts = new Array<NativeScript>();\n\n    for (let index = 0; index < scripts.length; index += 1) {\n      const script = scripts[index];\n      if (script) {\n        nativeScripts.push(fromNativeScript(script));\n      }\n    }\n\n    return nativeScripts;\n  };",
          "source": "mesh-core-cst",
          "implementation": "  const fromNativeScripts = (scripts: CstNativeScript[]) => {\n    const nativeScripts = new Array<NativeScript>();\n\n    for (let index = 0; index < scripts.length; index += 1) {\n      const script = scripts[index];\n      if (script) {\n        nativeScripts.push(fromNativeScript(script));\n      }\n    }\n\n    return nativeScripts;\n  };"
        },
        {
          "name": "toNativeScript",
          "signature": "export const toNativeScript = (script: NativeScript) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "script",
              "type": "NativeScript",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 282,
          "raw": "export const toNativeScript = (script: NativeScript) => {\n  const toNativeScripts = (scripts: NativeScript[]) => {\n    const nativeScripts: CstNativeScript[] = [];\n\n    scripts.forEach((script) => {\n      nativeScripts.push(toNativeScript(script));\n    });\n\n    return nativeScripts;\n  };\n\n  switch (script.type) {\n    case \"all\":\n      return CstNativeScript.newScriptAll(\n        new Serialization.ScriptAll(toNativeScripts(script.scripts)),\n      );\n    case \"any\":\n      return CstNativeScript.newScriptAny(\n        new Serialization.ScriptAny(toNativeScripts(script.scripts)),\n      );\n    case \"atLeast\":\n      return CstNativeScript.newScriptNOfK(\n        new Serialization.ScriptNOfK(\n          toNativeScripts(script.scripts),\n          script.required,\n        ),\n      );\n    case \"after\":\n      return CstNativeScript.newTimelockStart(\n        new Serialization.TimelockStart(Slot(parseInt(script.slot))),\n      );\n    case \"before\":\n      return CstNativeScript.newTimelockExpiry(\n        new Serialization.TimelockExpiry(Slot(parseInt(script.slot))),\n      );\n    case \"sig\":\n      return CstNativeScript.newScriptPubkey(\n        new Serialization.ScriptPubkey(\n          Ed25519KeyHash.fromBytes(toBytes(script.keyHash)).hex(),\n        ),\n      );\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const toNativeScript = (script: NativeScript) => {\n  const toNativeScripts = (scripts: NativeScript[]) => {\n    const nativeScripts: CstNativeScript[] = [];\n\n    scripts.forEach((script) => {\n      nativeScripts.push(toNativeScript(script));\n    });\n\n    return nativeScripts;\n  };\n\n  switch (script.type) {\n    case \"all\":\n      return CstNativeScript.newScriptAll(\n        new Serialization.ScriptAll(toNativeScripts(script.scripts)),\n      );\n    case \"any\":\n      return CstNativeScript.newScriptAny(\n        new Serialization.ScriptAny(toNativeScripts(script.scripts)),\n      );\n    case \"atLeast\":\n      return CstNativeScript.newScriptNOfK(\n        new Serialization.ScriptNOfK(\n          toNativeScripts(script.scripts),\n          script.required,\n        ),\n      );\n    case \"after\":\n      return CstNativeScript.newTimelockStart(\n        new Serialization.TimelockStart(Slot(parseInt(script.slot))),\n      );\n    case \"before\":\n      return CstNativeScript.newTimelockExpiry(\n        new Serialization.TimelockExpiry(Slot(parseInt(script.slot))),\n      );\n    case \"sig\":\n      return CstNativeScript.newScriptPubkey(\n        new Serialization.ScriptPubkey(\n          Ed25519KeyHash.fromBytes(toBytes(script.keyHash)).hex(),\n        ),\n      );\n  }\n};"
        },
        {
          "name": "toNativeScripts",
          "signature": "const toNativeScripts = (scripts: NativeScript[]) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "scripts",
              "type": "NativeScript[]",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 283,
          "raw": "  const toNativeScripts = (scripts: NativeScript[]) => {\n    const nativeScripts: CstNativeScript[] = [];\n\n    scripts.forEach((script) => {\n      nativeScripts.push(toNativeScript(script));\n    });\n\n    return nativeScripts;\n  };",
          "source": "mesh-core-cst",
          "implementation": "  const toNativeScripts = (scripts: NativeScript[]) => {\n    const nativeScripts: CstNativeScript[] = [];\n\n    scripts.forEach((script) => {\n      nativeScripts.push(toNativeScript(script));\n    });\n\n    return nativeScripts;\n  };"
        },
        {
          "name": "toValue",
          "signature": "export const toValue = (assets: Asset[]) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "assets",
              "type": "Asset[]",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 326,
          "raw": "export const toValue = (assets: Asset[]) => {\n  const multiAsset: TokenMap = new Map();\n  assets\n    .filter((asset) => asset.unit !== \"lovelace\" && asset.unit !== \"\")\n    .forEach((asset) => {\n      multiAsset.set(AssetId(asset.unit), BigInt(asset.quantity));\n    });\n\n  const lovelace = assets.find((asset) => asset.unit === \"lovelace\" || asset.unit === \"\");\n  const value = new Value(BigInt(lovelace ? lovelace.quantity : 0));\n\n  if (assets.length > 1 || !lovelace) {\n    value.setMultiasset(multiAsset);\n  }\n\n  return value;\n};",
          "source": "mesh-core-cst",
          "implementation": "export const toValue = (assets: Asset[]) => {\n  const multiAsset: TokenMap = new Map();\n  assets\n    .filter((asset) => asset.unit !== \"lovelace\" && asset.unit !== \"\")\n    .forEach((asset) => {\n      multiAsset.set(AssetId(asset.unit), BigInt(asset.quantity));\n    });\n\n  const lovelace = assets.find((asset) => asset.unit === \"lovelace\" || asset.unit === \"\");\n  const value = new Value(BigInt(lovelace ? lovelace.quantity : 0));\n\n  if (assets.length > 1 || !lovelace) {\n    value.setMultiasset(multiAsset);\n  }\n\n  return value;\n};"
        },
        {
          "name": "toDRep",
          "signature": "export const toDRep = (dRepId: string): Serialization.DRep => {",
          "documentation": "",
          "parameters": [
            {
              "name": "dRepId",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Serialization.DRep",
          "isPublic": true,
          "line": 344,
          "raw": "export const toDRep = (dRepId: string): Serialization.DRep => {\n  if (dRepId.length === 58) {\n    // CIP-129 DRepIds have length of 58\n    const { prefix, words } = bech32.decode(dRepId);\n    if (prefix !== \"drep\") {\n      throw new Error(\"Invalid DRepId prefix\");\n    }\n    const bytes = base32.decode(new Uint8Array(words));\n    if (bytes[0] === 0x22) {\n      return Serialization.DRep.newKeyHash(\n        Ed25519KeyHashHex(bytes.subarray(1).toString(\"hex\")),\n      );\n    } else if (bytes[0] === 0x23) {\n      return Serialization.DRep.newScriptHash(\n        Hash28ByteBase16(bytes.subarray(1).toString(\"hex\")),\n      );\n    } else {\n      throw new Error(\"Malformed CIP129 DRepId\");\n    }\n  } else {\n    // CIP-105 DRepIds have length of 56 or 63 depending on vkey or script prefix\n    const { prefix, words } = bech32.decode(dRepId);\n    switch (prefix) {\n      case \"drep\": {\n        return Serialization.DRep.newKeyHash(\n          Ed25519KeyHashHex(\n            base32.decode(new Uint8Array(words)).toString(\"hex\"),\n          ),\n        );\n      }\n      case \"drep_script\": {\n        return Serialization.DRep.newScriptHash(\n          Hash28ByteBase16(\n            base32.decode(new Uint8Array(words)).toString(\"hex\"),\n          ),\n        );\n      }\n      default: {\n        throw new Error(\"Malformed DRepId prefix\");\n      }\n    }\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const toDRep = (dRepId: string): Serialization.DRep => {\n  if (dRepId.length === 58) {\n    // CIP-129 DRepIds have length of 58\n    const { prefix, words } = bech32.decode(dRepId);\n    if (prefix !== \"drep\") {\n      throw new Error(\"Invalid DRepId prefix\");\n    }\n    const bytes = base32.decode(new Uint8Array(words));\n    if (bytes[0] === 0x22) {\n      return Serialization.DRep.newKeyHash(\n        Ed25519KeyHashHex(bytes.subarray(1).toString(\"hex\")),\n      );\n    } else if (bytes[0] === 0x23) {\n      return Serialization.DRep.newScriptHash(\n        Hash28ByteBase16(bytes.subarray(1).toString(\"hex\")),\n      );\n    } else {\n      throw new Error(\"Malformed CIP129 DRepId\");\n    }\n  } else {\n    // CIP-105 DRepIds have length of 56 or 63 depending on vkey or script prefix\n    const { prefix, words } = bech32.decode(dRepId);\n    switch (prefix) {\n      case \"drep\": {\n        return Serialization.DRep.newKeyHash(\n          Ed25519KeyHashHex(\n            base32.decode(new Uint8Array(words)).toString(\"hex\"),\n          ),\n        );\n      }\n      case \"drep_script\": {\n        return Serialization.DRep.newScriptHash(\n          Hash28ByteBase16(\n            base32.decode(new Uint8Array(words)).toString(\"hex\"),\n          ),\n        );\n      }\n      default: {\n        throw new Error(\"Malformed DRepId prefix\");\n      }\n    }\n  }\n};"
        },
        {
          "name": "getDRepIds",
          "signature": "export const getDRepIds = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 388,
          "raw": "export const getDRepIds = (\n  dRepId: string,\n): {\n  cip105: string;\n  cip129: string;\n} => {\n  let result = {\n    cip105: \"\",\n    cip129: \"\",\n  };\n  if (dRepId.length === 58) {\n    result.cip129 = dRepId;\n    const { prefix, words } = bech32.decode(dRepId);\n    if (prefix !== \"drep\") {\n      throw new Error(\"Malformed CIP129 DRepId\");\n    }\n    const bytes = base32.decode(new Uint8Array(words));\n    if (bytes[0] === 0x22) {\n      result.cip105 = bech32.encode(\"drep\", base32.encode(bytes.subarray(1)));\n    } else if (bytes[0] === 0x23) {\n      result.cip105 = bech32.encode(\n        \"drep_script\",\n        base32.encode(bytes.subarray(1)),\n      );\n    } else {\n      throw new Error(\"Malformed CIP129 DRepId\");\n    }\n  } else {\n    result.cip105 = dRepId;\n    try {\n      const { prefix, words } = bech32.decode(dRepId);\n      let rawBytes = base32.decode(new Uint8Array(words));\n      if (prefix === \"drep\") {\n        if (!rawBytes) {\n          throw new Error(\"Malformed key hash in DRepId\");\n        }\n        let rawBytesWithPrefix = new Uint8Array(rawBytes.length + 1);\n        rawBytesWithPrefix.set([0x22]);\n        rawBytesWithPrefix.set(rawBytes, 1);\n        let base32RawBytes = base32.encode(rawBytesWithPrefix);\n        result.cip129 = bech32.encode(\"drep\", base32RawBytes);\n      } else if (prefix === \"drep_script\") {\n        if (!rawBytes) {\n          throw new Error(\"Malformed script hash in DRepId\");\n        }\n        let rawBytesWithPrefix = new Uint8Array(rawBytes.length + 1);\n        rawBytesWithPrefix.set([0x23]);\n        rawBytesWithPrefix.set(rawBytes, 1);\n        let base32RawBytes = base32.encode(rawBytesWithPrefix);\n        result.cip129 = bech32.encode(\"drep\", base32RawBytes);\n      } else {\n        throw new Error(\"Can only calculate DRepIds for script/key DReps\");\n      }\n    } catch (e) {\n      console.error(e);\n      throw new Error(\"Malformed DRepId\");\n    }\n  }\n  return result;\n};",
          "source": "mesh-core-cst",
          "implementation": "export const getDRepIds = (\n  dRepId: string,\n): {\n  cip105: string;\n  cip129: string;\n} => {\n  let result = {\n    cip105: \"\",\n    cip129: \"\",\n  };\n  if (dRepId.length === 58) {\n    result.cip129 = dRepId;\n    const { prefix, words } = bech32.decode(dRepId);\n    if (prefix !== \"drep\") {\n      throw new Error(\"Malformed CIP129 DRepId\");\n    }\n    const bytes = base32.decode(new Uint8Array(words));\n    if (bytes[0] === 0x22) {\n      result.cip105 = bech32.encode(\"drep\", base32.encode(bytes.subarray(1)));\n    } else if (bytes[0] === 0x23) {\n      result.cip105 = bech32.encode(\n        \"drep_script\",\n        base32.encode(bytes.subarray(1)),\n      );\n    } else {\n      throw new Error(\"Malformed CIP129 DRepId\");\n    }\n  } else {\n    result.cip105 = dRepId;\n    try {\n      const { prefix, words } = bech32.decode(dRepId);\n      let rawBytes = base32.decode(new Uint8Array(words));\n      if (prefix === \"drep\") {\n        if (!rawBytes) {\n          throw new Error(\"Malformed key hash in DRepId\");\n        }\n        let rawBytesWithPrefix = new Uint8Array(rawBytes.length + 1);\n        rawBytesWithPrefix.set([0x22]);\n        rawBytesWithPrefix.set(rawBytes, 1);\n        let base32RawBytes = base32.encode(rawBytesWithPrefix);\n        result.cip129 = bech32.encode(\"drep\", base32RawBytes);\n      } else if (prefix === \"drep_script\") {\n        if (!rawBytes) {\n          throw new Error(\"Malformed script hash in DRepId\");\n        }\n        let rawBytesWithPrefix = new Uint8Array(rawBytes.length + 1);\n        rawBytesWithPrefix.set([0x23]);\n        rawBytesWithPrefix.set(rawBytes, 1);\n        let base32RawBytes = base32.encode(rawBytesWithPrefix);\n        result.cip129 = bech32.encode(\"drep\", base32RawBytes);\n      } else {\n        throw new Error(\"Can only calculate DRepIds for script/key DReps\");\n      }\n    } catch (e) {\n      console.error(e);\n      throw new Error(\"Malformed DRepId\");\n    }\n  }\n  return result;\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "toAddress",
          "type": "any",
          "value": "(bech32: string): Address =>",
          "isPublic": true,
          "line": 51,
          "raw": "export const toAddress = (bech32: string): Address =>",
          "source": "mesh-core-cst"
        },
        {
          "name": "toCardanoAddress",
          "type": "any",
          "value": "(address: string): Address => {",
          "isPublic": true,
          "line": 54,
          "raw": "export const toCardanoAddress = (address: string): Address => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "toBaseAddress",
          "type": "any",
          "value": "(bech32: string): BaseAddress | undefined => {",
          "isPublic": true,
          "line": 66,
          "raw": "export const toBaseAddress = (bech32: string): BaseAddress | undefined => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "toEnterpriseAddress",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 70,
          "raw": "export const toEnterpriseAddress = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "toRewardAddress",
          "type": "any",
          "value": "(bech32: string): RewardAddress | undefined =>",
          "isPublic": true,
          "line": 76,
          "raw": "export const toRewardAddress = (bech32: string): RewardAddress | undefined =>",
          "source": "mesh-core-cst"
        },
        {
          "name": "fromTxUnspentOutput",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 79,
          "raw": "export const fromTxUnspentOutput = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "dataHash",
          "type": "any",
          "value": "txUnspentOutput.output().datum()",
          "isPublic": true,
          "line": 82,
          "raw": "const dataHash = txUnspentOutput.output().datum()",
          "source": "mesh-core-cst"
        },
        {
          "name": "scriptRef",
          "type": "any",
          "value": "txUnspentOutput.output().scriptRef()",
          "isPublic": true,
          "line": 86,
          "raw": "const scriptRef = txUnspentOutput.output().scriptRef()",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusData",
          "type": "any",
          "value": "txUnspentOutput.output().datum()?.asInlineData()",
          "isPublic": true,
          "line": 90,
          "raw": "const plutusData = txUnspentOutput.output().datum()?.asInlineData()",
          "source": "mesh-core-cst"
        },
        {
          "name": "toTxUnspentOutput",
          "type": "any",
          "value": "(utxo: UTxO) => {",
          "isPublic": true,
          "line": 109,
          "raw": "export const toTxUnspentOutput = (utxo: UTxO) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "txInput",
          "type": "any",
          "value": "new TransactionInput(",
          "isPublic": true,
          "line": 110,
          "raw": "const txInput = new TransactionInput(",
          "source": "mesh-core-cst"
        },
        {
          "name": "txOutput",
          "type": "any",
          "value": "new TransactionOutput(",
          "isPublic": true,
          "line": 115,
          "raw": "const txOutput = new TransactionOutput(",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusData",
          "type": "any",
          "value": "deserializePlutusData(utxo.output.plutusData);",
          "isPublic": true,
          "line": 127,
          "raw": "const plutusData = deserializePlutusData(utxo.output.plutusData);",
          "source": "mesh-core-cst"
        },
        {
          "name": "datum",
          "type": "any",
          "value": "new Serialization.Datum(undefined, plutusData);",
          "isPublic": true,
          "line": 128,
          "raw": "const datum = new Serialization.Datum(undefined, plutusData);",
          "source": "mesh-core-cst"
        },
        {
          "name": "addressToBech32",
          "type": "any",
          "value": "(address: Address): string => {",
          "isPublic": true,
          "line": 139,
          "raw": "export const addressToBech32 = (address: Address): string => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "fromValue",
          "type": "any",
          "value": "(value: Value) => {",
          "isPublic": true,
          "line": 143,
          "raw": "export const fromValue = (value: Value) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "assets",
          "type": "Asset[]",
          "value": "[",
          "isPublic": true,
          "line": 144,
          "raw": "const assets: Asset[] = [",
          "source": "mesh-core-cst"
        },
        {
          "name": "multiAsset",
          "type": "any",
          "value": "value.multiasset();",
          "isPublic": true,
          "line": 148,
          "raw": "const multiAsset = value.multiasset();",
          "source": "mesh-core-cst"
        },
        {
          "name": "_assets",
          "type": "any",
          "value": "Array.from(multiAsset.keys());",
          "isPublic": true,
          "line": 150,
          "raw": "const _assets = Array.from(multiAsset.keys());",
          "source": "mesh-core-cst"
        },
        {
          "name": "assetId",
          "type": "any",
          "value": "_assets[i];",
          "isPublic": true,
          "line": 152,
          "raw": "const assetId = _assets[i];",
          "source": "mesh-core-cst"
        },
        {
          "name": "assetQuantity",
          "type": "any",
          "value": "multiAsset.get(assetId);",
          "isPublic": true,
          "line": 154,
          "raw": "const assetQuantity = multiAsset.get(assetId);",
          "source": "mesh-core-cst"
        },
        {
          "name": "toScriptRef",
          "type": "any",
          "value": "(script: PlutusScript | NativeScript): Script => {",
          "isPublic": true,
          "line": 168,
          "raw": "export const toScriptRef = (script: PlutusScript | NativeScript): Script => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusScript",
          "type": "any",
          "value": "deserializePlutusScript(script.code, script.version);",
          "isPublic": true,
          "line": 170,
          "raw": "const plutusScript = deserializePlutusScript(script.code, script.version);",
          "source": "mesh-core-cst"
        },
        {
          "name": "fromScriptRef",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 181,
          "raw": "export const fromScriptRef = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "script",
          "type": "any",
          "value": "Script.fromCbor(HexBlob(scriptRef));",
          "isPublic": true,
          "line": 184,
          "raw": "const script = Script.fromCbor(HexBlob(scriptRef));",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusScriptCodeV3",
          "type": "any",
          "value": "script.asPlutusV3()?.toCbor().toString();",
          "isPublic": true,
          "line": 186,
          "raw": "const plutusScriptCodeV3 = script.asPlutusV3()?.toCbor().toString();",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusScriptCodeV2",
          "type": "any",
          "value": "script.asPlutusV2()?.toCbor().toString();",
          "isPublic": true,
          "line": 194,
          "raw": "const plutusScriptCodeV2 = script.asPlutusV2()?.toCbor().toString();",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusScriptCodeV1",
          "type": "any",
          "value": "script.asPlutusV1()?.toCbor().toString();",
          "isPublic": true,
          "line": 202,
          "raw": "const plutusScriptCodeV1 = script.asPlutusV1()?.toCbor().toString();",
          "source": "mesh-core-cst"
        },
        {
          "name": "nativeScript",
          "type": "any",
          "value": "script.asNative();",
          "isPublic": true,
          "line": 211,
          "raw": "const nativeScript = script.asNative();",
          "source": "mesh-core-cst"
        },
        {
          "name": "fromNativeScript",
          "type": "any",
          "value": "(script: CstNativeScript) => {",
          "isPublic": true,
          "line": 219,
          "raw": "export const fromNativeScript = (script: CstNativeScript) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "fromNativeScripts",
          "type": "any",
          "value": "(scripts: CstNativeScript[]) => {",
          "isPublic": true,
          "line": 220,
          "raw": "const fromNativeScripts = (scripts: CstNativeScript[]) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "nativeScripts",
          "type": "any",
          "value": "new Array<NativeScript>();",
          "isPublic": true,
          "line": 221,
          "raw": "const nativeScripts = new Array<NativeScript>();",
          "source": "mesh-core-cst"
        },
        {
          "name": "script",
          "type": "any",
          "value": "scripts[index];",
          "isPublic": true,
          "line": 224,
          "raw": "const script = scripts[index];",
          "source": "mesh-core-cst"
        },
        {
          "name": "scriptAll",
          "type": "any",
          "value": "script.asScriptAll()!;",
          "isPublic": true,
          "line": 235,
          "raw": "const scriptAll = script.asScriptAll()!;",
          "source": "mesh-core-cst"
        },
        {
          "name": "scriptAny",
          "type": "any",
          "value": "script.asScriptAny()!;",
          "isPublic": true,
          "line": 242,
          "raw": "const scriptAny = script.asScriptAny()!;",
          "source": "mesh-core-cst"
        },
        {
          "name": "scriptNOfK",
          "type": "any",
          "value": "script.asScriptNOfK()!;",
          "isPublic": true,
          "line": 249,
          "raw": "const scriptNOfK = script.asScriptNOfK()!;",
          "source": "mesh-core-cst"
        },
        {
          "name": "timelockStart",
          "type": "any",
          "value": "script.asTimelockStart()!;",
          "isPublic": true,
          "line": 257,
          "raw": "const timelockStart = script.asTimelockStart()!;",
          "source": "mesh-core-cst"
        },
        {
          "name": "timelockExpiry",
          "type": "any",
          "value": "script.asTimelockExpiry()!;",
          "isPublic": true,
          "line": 264,
          "raw": "const timelockExpiry = script.asTimelockExpiry()!;",
          "source": "mesh-core-cst"
        },
        {
          "name": "scriptPubkey",
          "type": "any",
          "value": "script.asScriptPubkey()!;",
          "isPublic": true,
          "line": 271,
          "raw": "const scriptPubkey = script.asScriptPubkey()!;",
          "source": "mesh-core-cst"
        },
        {
          "name": "toNativeScript",
          "type": "any",
          "value": "(script: NativeScript) => {",
          "isPublic": true,
          "line": 282,
          "raw": "export const toNativeScript = (script: NativeScript) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "toNativeScripts",
          "type": "any",
          "value": "(scripts: NativeScript[]) => {",
          "isPublic": true,
          "line": 283,
          "raw": "const toNativeScripts = (scripts: NativeScript[]) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "nativeScripts",
          "type": "CstNativeScript[]",
          "value": "[];",
          "isPublic": true,
          "line": 284,
          "raw": "const nativeScripts: CstNativeScript[] = [];",
          "source": "mesh-core-cst"
        },
        {
          "name": "toValue",
          "type": "any",
          "value": "(assets: Asset[]) => {",
          "isPublic": true,
          "line": 326,
          "raw": "export const toValue = (assets: Asset[]) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "multiAsset",
          "type": "TokenMap",
          "value": "new Map();",
          "isPublic": true,
          "line": 327,
          "raw": "const multiAsset: TokenMap = new Map();",
          "source": "mesh-core-cst"
        },
        {
          "name": "lovelace",
          "type": "any",
          "value": "assets.find((asset) => asset.unit === \"lovelace\" || asset.unit === \"\");",
          "isPublic": true,
          "line": 334,
          "raw": "const lovelace = assets.find((asset) => asset.unit === \"lovelace\" || asset.unit === \"\");",
          "source": "mesh-core-cst"
        },
        {
          "name": "value",
          "type": "any",
          "value": "new Value(BigInt(lovelace ? lovelace.quantity : 0));",
          "isPublic": true,
          "line": 335,
          "raw": "const value = new Value(BigInt(lovelace ? lovelace.quantity : 0));",
          "source": "mesh-core-cst"
        },
        {
          "name": "toDRep",
          "type": "any",
          "value": "(dRepId: string): Serialization.DRep => {",
          "isPublic": true,
          "line": 344,
          "raw": "export const toDRep = (dRepId: string): Serialization.DRep => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "bytes",
          "type": "any",
          "value": "base32.decode(new Uint8Array(words));",
          "isPublic": true,
          "line": 351,
          "raw": "const bytes = base32.decode(new Uint8Array(words));",
          "source": "mesh-core-cst"
        },
        {
          "name": "getDRepIds",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 388,
          "raw": "export const getDRepIds = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "bytes",
          "type": "any",
          "value": "base32.decode(new Uint8Array(words));",
          "isPublic": true,
          "line": 404,
          "raw": "const bytes = base32.decode(new Uint8Array(words));",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { Serialization } from \"@cardano-sdk/core\";\nimport { Ed25519KeyHash } from \"@cardano-sdk/crypto\";\nimport { HexBlob } from \"@cardano-sdk/util\";\nimport base32 from \"base32-encoding\";\nimport { bech32 } from \"bech32\";\n\nimport {\n  Asset,\n  NativeScript,\n  PlutusScript,\n  Quantity,\n  toBytes,\n  Unit,\n  UTxO,\n} from \"@meshsdk/common\";\n\nimport {\n  Address,\n  AssetId,\n  BaseAddress,\n  NativeScript as CstNativeScript,\n  Datum,\n  Ed25519KeyHashHex,\n  EnterpriseAddress,\n  Hash28ByteBase16,\n  PlutusV1Script,\n  PlutusV2Script,\n  PlutusV3Script,\n  RequireAllOf,\n  RequireAnyOf,\n  RequireNOf,\n  RequireSignature,\n  RequireTimeAfter,\n  RequireTimeBefore,\n  RewardAddress,\n  Script,\n  Slot,\n  TokenMap,\n  TransactionInput,\n  TransactionOutput,\n  TransactionUnspentOutput,\n  Value,\n} from \"../types\";\nimport { deserializeDataHash, deserializePlutusData } from \"./data\";\nimport {\n  deserializePlutusScript,\n  deserializeScriptRef,\n  deserializeTxHash,\n} from \"./deserializer\";\n\nexport const toAddress = (bech32: string): Address =>\n  Address.fromBech32(bech32);\n\nexport const toCardanoAddress = (address: string): Address => {\n  try {\n    return Address.fromBech32(address);\n  } catch {\n    try {\n      return Address.fromBase58(address);\n    } catch {\n      throw new Error(`Invalid address format, ${address}`);\n    }\n  }\n};\n\nexport const toBaseAddress = (bech32: string): BaseAddress | undefined => {\n  return BaseAddress.fromAddress(toAddress(bech32));\n};\n\nexport const toEnterpriseAddress = (\n  bech32: string,\n): EnterpriseAddress | undefined => {\n  return EnterpriseAddress.fromAddress(toAddress(bech32));\n};\n\nexport const toRewardAddress = (bech32: string): RewardAddress | undefined =>\n  RewardAddress.fromAddress(toAddress(bech32));\n\nexport const fromTxUnspentOutput = (\n  txUnspentOutput: TransactionUnspentOutput,\n): UTxO => {\n  const dataHash = txUnspentOutput.output().datum()\n    ? txUnspentOutput.output().datum()?.toCbor().toString()\n    : undefined;\n\n  const scriptRef = txUnspentOutput.output().scriptRef()\n    ? txUnspentOutput.output().scriptRef()?.toCbor().toString()\n    : undefined;\n\n  const plutusData = txUnspentOutput.output().datum()?.asInlineData()\n    ? txUnspentOutput.output().datum()?.asInlineData()?.toCbor().toString()\n    : undefined;\n\n  return <UTxO>{\n    input: {\n      outputIndex: Number(txUnspentOutput.input().index()),\n      txHash: txUnspentOutput.input().transactionId(),\n    },\n    output: {\n      address: txUnspentOutput.output().address().toBech32(),\n      amount: fromValue(txUnspentOutput.output().amount()),\n      dataHash: dataHash, // todo not sure if correct\n      plutusData: plutusData, // todo not sure if correct\n      scriptRef: scriptRef, // todo not sure if correct\n    },\n  };\n};\n\nexport const toTxUnspentOutput = (utxo: UTxO) => {\n  const txInput = new TransactionInput(\n    deserializeTxHash(utxo.input.txHash),\n    BigInt(utxo.input.outputIndex),\n  );\n\n  const txOutput = new TransactionOutput(\n    toAddress(utxo.output.address),\n    toValue(utxo.output.amount),\n  );\n\n  if (utxo.output.dataHash !== undefined) {\n    txOutput.setDatum(\n      Datum.fromCore(deserializeDataHash(utxo.output.dataHash)),\n    );\n  }\n\n  if (utxo.output.plutusData !== undefined) {\n    const plutusData = deserializePlutusData(utxo.output.plutusData);\n    const datum = new Serialization.Datum(undefined, plutusData);\n    txOutput.setDatum(datum);\n  }\n\n  if (utxo.output.scriptRef !== undefined) {\n    txOutput.setScriptRef(deserializeScriptRef(utxo.output.scriptRef));\n  }\n\n  return new TransactionUnspentOutput(txInput, txOutput);\n};\n\nexport const addressToBech32 = (address: Address): string => {\n  return address.toBech32();\n};\n\nexport const fromValue = (value: Value) => {\n  const assets: Asset[] = [\n    { unit: \"lovelace\", quantity: value.coin().toString() },\n  ];\n\n  const multiAsset = value.multiasset();\n  if (multiAsset !== undefined) {\n    const _assets = Array.from(multiAsset.keys());\n    for (let i = 0; i < _assets.length; i += 1) {\n      const assetId = _assets[i];\n      if (assetId !== undefined) {\n        const assetQuantity = multiAsset.get(assetId);\n        if (assetQuantity !== undefined) {\n          assets.push({\n            unit: assetId as Unit,\n            quantity: assetQuantity.toString() as Quantity,\n          });\n        }\n      }\n    }\n  }\n\n  return assets;\n};\n\nexport const toScriptRef = (script: PlutusScript | NativeScript): Script => {\n  if (\"code\" in script) {\n    const plutusScript = deserializePlutusScript(script.code, script.version);\n    if (plutusScript instanceof PlutusV1Script)\n      return Script.newPlutusV1Script(plutusScript);\n    if (plutusScript instanceof PlutusV2Script)\n      return Script.newPlutusV2Script(plutusScript);\n    if (plutusScript instanceof PlutusV3Script)\n      return Script.newPlutusV3Script(plutusScript);\n  }\n  return Script.newNativeScript(toNativeScript(script as NativeScript));\n};\n\nexport const fromScriptRef = (\n  scriptRef: string,\n): PlutusScript | NativeScript | undefined => {\n  const script = Script.fromCbor(HexBlob(scriptRef));\n\n  const plutusScriptCodeV3 = script.asPlutusV3()?.toCbor().toString();\n  if (plutusScriptCodeV3) {\n    return {\n      code: plutusScriptCodeV3,\n      version: \"V3\",\n    };\n  }\n\n  const plutusScriptCodeV2 = script.asPlutusV2()?.toCbor().toString();\n  if (plutusScriptCodeV2) {\n    return {\n      code: plutusScriptCodeV2,\n      version: \"V2\",\n    };\n  }\n\n  const plutusScriptCodeV1 = script.asPlutusV1()?.toCbor().toString();\n  if (plutusScriptCodeV1) {\n    return {\n      code: plutusScriptCodeV1,\n      version: \"V1\",\n    };\n  }\n\n  // TODO: implement from native script\n  const nativeScript = script.asNative();\n  if (!nativeScript) {\n    throw new Error(\"Invalid script\");\n  }\n\n  return fromNativeScript(nativeScript);\n};\n\nexport const fromNativeScript = (script: CstNativeScript) => {\n  const fromNativeScripts = (scripts: CstNativeScript[]) => {\n    const nativeScripts = new Array<NativeScript>();\n\n    for (let index = 0; index < scripts.length; index += 1) {\n      const script = scripts[index];\n      if (script) {\n        nativeScripts.push(fromNativeScript(script));\n      }\n    }\n\n    return nativeScripts;\n  };\n\n  switch (script.kind()) {\n    case RequireAllOf: {\n      const scriptAll = script.asScriptAll()!;\n      return <NativeScript>{\n        type: \"all\",\n        scripts: fromNativeScripts(scriptAll.nativeScripts()),\n      };\n    }\n    case RequireAnyOf: {\n      const scriptAny = script.asScriptAny()!;\n      return <NativeScript>{\n        type: \"any\",\n        scripts: fromNativeScripts(scriptAny.nativeScripts()),\n      };\n    }\n    case RequireNOf: {\n      const scriptNOfK = script.asScriptNOfK()!;\n      return <NativeScript>{\n        type: \"atLeast\",\n        required: scriptNOfK.required(),\n        scripts: fromNativeScripts(scriptNOfK.nativeScripts()),\n      };\n    }\n    case RequireTimeAfter: {\n      const timelockStart = script.asTimelockStart()!;\n      return <NativeScript>{\n        type: \"after\",\n        slot: timelockStart.slot().toString(),\n      };\n    }\n    case RequireTimeBefore: {\n      const timelockExpiry = script.asTimelockExpiry()!;\n      return <NativeScript>{\n        type: \"before\",\n        slot: timelockExpiry.slot().toString(),\n      };\n    }\n    case RequireSignature: {\n      const scriptPubkey = script.asScriptPubkey()!;\n      return <NativeScript>{\n        type: \"sig\",\n        keyHash: scriptPubkey.keyHash().toString(),\n      };\n    }\n    default:\n      throw new Error(`Script Kind: ${script.kind()}, is not supported`);\n  }\n};\n\nexport const toNativeScript = (script: NativeScript) => {\n  const toNativeScripts = (scripts: NativeScript[]) => {\n    const nativeScripts: CstNativeScript[] = [];\n\n    scripts.forEach((script) => {\n      nativeScripts.push(toNativeScript(script));\n    });\n\n    return nativeScripts;\n  };\n\n  switch (script.type) {\n    case \"all\":\n      return CstNativeScript.newScriptAll(\n        new Serialization.ScriptAll(toNativeScripts(script.scripts)),\n      );\n    case \"any\":\n      return CstNativeScript.newScriptAny(\n        new Serialization.ScriptAny(toNativeScripts(script.scripts)),\n      );\n    case \"atLeast\":\n      return CstNativeScript.newScriptNOfK(\n        new Serialization.ScriptNOfK(\n          toNativeScripts(script.scripts),\n          script.required,\n        ),\n      );\n    case \"after\":\n      return CstNativeScript.newTimelockStart(\n        new Serialization.TimelockStart(Slot(parseInt(script.slot))),\n      );\n    case \"before\":\n      return CstNativeScript.newTimelockExpiry(\n        new Serialization.TimelockExpiry(Slot(parseInt(script.slot))),\n      );\n    case \"sig\":\n      return CstNativeScript.newScriptPubkey(\n        new Serialization.ScriptPubkey(\n          Ed25519KeyHash.fromBytes(toBytes(script.keyHash)).hex(),\n        ),\n      );\n  }\n};\n\nexport const toValue = (assets: Asset[]) => {\n  const multiAsset: TokenMap = new Map();\n  assets\n    .filter((asset) => asset.unit !== \"lovelace\" && asset.unit !== \"\")\n    .forEach((asset) => {\n      multiAsset.set(AssetId(asset.unit), BigInt(asset.quantity));\n    });\n\n  const lovelace = assets.find((asset) => asset.unit === \"lovelace\" || asset.unit === \"\");\n  const value = new Value(BigInt(lovelace ? lovelace.quantity : 0));\n\n  if (assets.length > 1 || !lovelace) {\n    value.setMultiasset(multiAsset);\n  }\n\n  return value;\n};\n\nexport const toDRep = (dRepId: string): Serialization.DRep => {\n  if (dRepId.length === 58) {\n    // CIP-129 DRepIds have length of 58\n    const { prefix, words } = bech32.decode(dRepId);\n    if (prefix !== \"drep\") {\n      throw new Error(\"Invalid DRepId prefix\");\n    }\n    const bytes = base32.decode(new Uint8Array(words));\n    if (bytes[0] === 0x22) {\n      return Serialization.DRep.newKeyHash(\n        Ed25519KeyHashHex(bytes.subarray(1).toString(\"hex\")),\n      );\n    } else if (bytes[0] === 0x23) {\n      return Serialization.DRep.newScriptHash(\n        Hash28ByteBase16(bytes.subarray(1).toString(\"hex\")),\n      );\n    } else {\n      throw new Error(\"Malformed CIP129 DRepId\");\n    }\n  } else {\n    // CIP-105 DRepIds have length of 56 or 63 depending on vkey or script prefix\n    const { prefix, words } = bech32.decode(dRepId);\n    switch (prefix) {\n      case \"drep\": {\n        return Serialization.DRep.newKeyHash(\n          Ed25519KeyHashHex(\n            base32.decode(new Uint8Array(words)).toString(\"hex\"),\n          ),\n        );\n      }\n      case \"drep_script\": {\n        return Serialization.DRep.newScriptHash(\n          Hash28ByteBase16(\n            base32.decode(new Uint8Array(words)).toString(\"hex\"),\n          ),\n        );\n      }\n      default: {\n        throw new Error(\"Malformed DRepId prefix\");\n      }\n    }\n  }\n};\n\nexport const getDRepIds = (\n  dRepId: string,\n): {\n  cip105: string;\n  cip129: string;\n} => {\n  let result = {\n    cip105: \"\",\n    cip129: \"\",\n  };\n  if (dRepId.length === 58) {\n    result.cip129 = dRepId;\n    const { prefix, words } = bech32.decode(dRepId);\n    if (prefix !== \"drep\") {\n      throw new Error(\"Malformed CIP129 DRepId\");\n    }\n    const bytes = base32.decode(new Uint8Array(words));\n    if (bytes[0] === 0x22) {\n      result.cip105 = bech32.encode(\"drep\", base32.encode(bytes.subarray(1)));\n    } else if (bytes[0] === 0x23) {\n      result.cip105 = bech32.encode(\n        \"drep_script\",\n        base32.encode(bytes.subarray(1)),\n      );\n    } else {\n      throw new Error(\"Malformed CIP129 DRepId\");\n    }\n  } else {\n    result.cip105 = dRepId;\n    try {\n      const { prefix, words } = bech32.decode(dRepId);\n      let rawBytes = base32.decode(new Uint8Array(words));\n      if (prefix === \"drep\") {\n        if (!rawBytes) {\n          throw new Error(\"Malformed key hash in DRepId\");\n        }\n        let rawBytesWithPrefix = new Uint8Array(rawBytes.length + 1);\n        rawBytesWithPrefix.set([0x22]);\n        rawBytesWithPrefix.set(rawBytes, 1);\n        let base32RawBytes = base32.encode(rawBytesWithPrefix);\n        result.cip129 = bech32.encode(\"drep\", base32RawBytes);\n      } else if (prefix === \"drep_script\") {\n        if (!rawBytes) {\n          throw new Error(\"Malformed script hash in DRepId\");\n        }\n        let rawBytesWithPrefix = new Uint8Array(rawBytes.length + 1);\n        rawBytesWithPrefix.set([0x23]);\n        rawBytesWithPrefix.set(rawBytes, 1);\n        let base32RawBytes = base32.encode(rawBytesWithPrefix);\n        result.cip129 = bech32.encode(\"drep\", base32RawBytes);\n      } else {\n        throw new Error(\"Can only calculate DRepIds for script/key DReps\");\n      }\n    } catch (e) {\n      console.error(e);\n      throw new Error(\"Malformed DRepId\");\n    }\n  }\n  return result;\n};\n",
      "dependencies": [
        "toAddress",
        "toCardanoAddress",
        "toBaseAddress",
        "toEnterpriseAddress",
        "toRewardAddress",
        "fromTxUnspentOutput",
        "toTxUnspentOutput",
        "addressToBech32",
        "fromValue",
        "toScriptRef",
        "fromScriptRef",
        "fromNativeScript",
        "toNativeScript",
        "toValue",
        "toDRep",
        "getDRepIds"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:utils.data.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/utils/data.ts",
      "name": "utils.data.ts",
      "imports": [
        {
          "module": "toPlutusData",
          "items": [],
          "line": 14,
          "raw": "export const toPlutusData = (data: Data): PlutusData => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "fromJsonToPlutusData",
          "items": [],
          "line": 87,
          "raw": "export const fromJsonToPlutusData = (data: object): PlutusData => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "fromBuilderToPlutusData",
          "items": [],
          "line": 149,
          "raw": "export const fromBuilderToPlutusData = (data: BuilderData): PlutusData => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "fromPlutusDataToJson",
          "items": [],
          "line": 169,
          "raw": "export const fromPlutusDataToJson = (data: PlutusData): object => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "parseDatumCbor",
          "items": [],
          "line": 249,
          "raw": "export const parseDatumCbor = <T = any>(datumCbor: string): T => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "parseInlineDatum",
          "items": [],
          "line": 253,
          "raw": "export const parseInlineDatum = <T extends { inline_datum?: string }, X>(",
          "source": "mesh-core-cst"
        },
        {
          "module": "deserializeDataHash",
          "items": [],
          "line": 260,
          "raw": "export const deserializeDataHash = (dataHash: string): DatumHash =>",
          "source": "mesh-core-cst"
        },
        {
          "module": "deserializePlutusData",
          "items": [],
          "line": 263,
          "raw": "export const deserializePlutusData = (plutusData: string): PlutusData =>",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "toPlutusData",
          "signature": "export const toPlutusData = (data: Data): PlutusData => {",
          "documentation": "",
          "parameters": [
            {
              "name": "data",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "PlutusData",
          "isPublic": true,
          "line": 14,
          "raw": "export const toPlutusData = (data: Data): PlutusData => {\n  const toPlutusList = (data: Data[]) => {\n    const plutusList = new PlutusList();\n    data.forEach((element) => {\n      plutusList.add(toPlutusData(element));\n    });\n    return plutusList;\n  };\n\n  switch (typeof data) {\n    case \"string\":\n      return PlutusData.newBytes(toBytes(data));\n    case \"number\":\n      return PlutusData.newInteger(BigInt(data));\n    case \"bigint\":\n      return PlutusData.newInteger(BigInt(data));\n    case \"object\":\n      if (data instanceof Array) {\n        const plutusList = toPlutusList(data);\n        return PlutusData.newList(plutusList);\n      } else if (data instanceof Map) {\n        const plutusMap = new PlutusMap();\n        data.forEach((value, key) => {\n          plutusMap.insert(toPlutusData(key), toPlutusData(value));\n        });\n        return PlutusData.newMap(plutusMap);\n      } else {\n        return PlutusData.newConstrPlutusData(\n          new ConstrPlutusData(\n            BigInt(data.alternative),\n            toPlutusList(data.fields),\n          ),\n        );\n      }\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const toPlutusData = (data: Data): PlutusData => {\n  const toPlutusList = (data: Data[]) => {\n    const plutusList = new PlutusList();\n    data.forEach((element) => {\n      plutusList.add(toPlutusData(element));\n    });\n    return plutusList;\n  };\n\n  switch (typeof data) {\n    case \"string\":\n      return PlutusData.newBytes(toBytes(data));\n    case \"number\":\n      return PlutusData.newInteger(BigInt(data));\n    case \"bigint\":\n      return PlutusData.newInteger(BigInt(data));\n    case \"object\":\n      if (data instanceof Array) {\n        const plutusList = toPlutusList(data);\n        return PlutusData.newList(plutusList);\n      } else if (data instanceof Map) {\n        const plutusMap = new PlutusMap();\n        data.forEach((value, key) => {\n          plutusMap.insert(toPlutusData(key), toPlutusData(value));\n        });\n        return PlutusData.newMap(plutusMap);\n      } else {\n        return PlutusData.newConstrPlutusData(\n          new ConstrPlutusData(\n            BigInt(data.alternative),\n            toPlutusList(data.fields),\n          ),\n        );\n      }\n  }\n};"
        },
        {
          "name": "toPlutusList",
          "signature": "const toPlutusList = (data: Data[]) => {",
          "documentation": "",
          "parameters": [
            {
              "name": "data",
              "type": "Data[]",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 15,
          "raw": "  const toPlutusList = (data: Data[]) => {\n    const plutusList = new PlutusList();\n    data.forEach((element) => {\n      plutusList.add(toPlutusData(element));\n    });\n    return plutusList;\n  };",
          "source": "mesh-core-cst",
          "implementation": "  const toPlutusList = (data: Data[]) => {\n    const plutusList = new PlutusList();\n    data.forEach((element) => {\n      plutusList.add(toPlutusData(element));\n    });\n    return plutusList;\n  };"
        },
        {
          "name": "isConstrPlutusDataJson",
          "signature": "const isConstrPlutusDataJson = (data: object): data is ConstrPlutusDataJson => {",
          "documentation": "",
          "parameters": [
            {
              "name": "data",
              "type": "object",
              "optional": false
            }
          ],
          "returnType": "data is ConstrPlutusDataJson",
          "isPublic": true,
          "line": 56,
          "raw": "const isConstrPlutusDataJson = (data: object): data is ConstrPlutusDataJson => {\n  return (\n    typeof data === \"object\" &&\n    \"constructor\" in data &&\n    (typeof data.constructor === \"number\" ||\n      typeof data.constructor === \"bigint\" ||\n      typeof data.constructor === \"string\") &&\n    \"fields\" in data &&\n    Array.isArray(data.fields)\n  );\n};",
          "source": "mesh-core-cst",
          "implementation": "const isConstrPlutusDataJson = (data: object): data is ConstrPlutusDataJson => {\n  return (\n    typeof data === \"object\" &&\n    \"constructor\" in data &&\n    (typeof data.constructor === \"number\" ||\n      typeof data.constructor === \"bigint\" ||\n      typeof data.constructor === \"string\") &&\n    \"fields\" in data &&\n    Array.isArray(data.fields)\n  );\n};"
        },
        {
          "name": "isMapPlutusDataJson",
          "signature": "function isMapPlutusDataJson(data: any) {",
          "documentation": "",
          "parameters": [
            {
              "name": "data",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 73,
          "raw": "function isMapPlutusDataJson(data: any) {\n  return typeof data === \"object\" && Array.isArray(data);\n}",
          "source": "mesh-core-cst",
          "implementation": "function isMapPlutusDataJson(data: any) {\n  return typeof data === \"object\" && Array.isArray(data);\n}"
        },
        {
          "name": "isKeyValuePlutusDataJson",
          "signature": "function isKeyValuePlutusDataJson(data: any): data is KeyValuePlutusDataJson {",
          "documentation": "",
          "parameters": [
            {
              "name": "data",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "data is KeyValuePlutusDataJson",
          "isPublic": true,
          "line": 77,
          "raw": "function isKeyValuePlutusDataJson(data: any): data is KeyValuePlutusDataJson {\n  return (\n    typeof data === \"object\" &&\n    \"k\" in data &&\n    typeof data.k === \"object\" &&\n    \"v\" in data &&\n    typeof data.v === \"object\"\n  );\n}",
          "source": "mesh-core-cst",
          "implementation": "function isKeyValuePlutusDataJson(data: any): data is KeyValuePlutusDataJson {\n  return (\n    typeof data === \"object\" &&\n    \"k\" in data &&\n    typeof data.k === \"object\" &&\n    \"v\" in data &&\n    typeof data.v === \"object\"\n  );\n}"
        },
        {
          "name": "fromJsonToPlutusData",
          "signature": "export const fromJsonToPlutusData = (data: object): PlutusData => {",
          "documentation": "",
          "parameters": [
            {
              "name": "data",
              "type": "object",
              "optional": false
            }
          ],
          "returnType": "PlutusData",
          "isPublic": true,
          "line": 87,
          "raw": "export const fromJsonToPlutusData = (data: object): PlutusData => {\n  if (isConstrPlutusDataJson(data)) {\n    const plutusList = new PlutusList();\n    data.fields.map((val) => {\n      plutusList.add(fromJsonToPlutusData(val));\n    });\n    const plutusConstrData = new ConstrPlutusData(\n      BigInt(data.constructor),\n      plutusList,\n    );\n    return PlutusData.newConstrPlutusData(plutusConstrData);\n  } else if (\"int\" in data && Object.keys(data).length === 1) {\n    if (\n      typeof data.int === \"bigint\" ||\n      typeof data.int === \"number\" ||\n      typeof data.int === \"string\"\n    ) {\n      return PlutusData.newInteger(BigInt(data.int));\n    } else {\n      throw new Error(\n        \"Malformed int field in Plutus data, expected one of bigint, number or string\",\n      );\n    }\n  } else if (\"bytes\" in data && Object.keys(data).length === 1) {\n    if (typeof data.bytes === \"string\") {\n      return PlutusData.newBytes(Buffer.from(data.bytes, \"hex\"));\n    } else {\n      throw new Error(\"Malformed bytes field in Plutus data, expected string\");\n    }\n  } else if (\"list\" in data && Object.keys(data).length === 1) {\n    if (Array.isArray(data.list)) {\n      const plutusList = new PlutusList();\n      data.list.map((val) => {\n        plutusList.add(fromJsonToPlutusData(val));\n      });\n      return PlutusData.newList(plutusList);\n    } else {\n      throw new Error(\"Malformed list field in Plutus data, expected list\");\n    }\n  } else if (\"map\" in data && Object.keys(data).length === 1) {\n    if (isMapPlutusDataJson(data.map)) {\n      const plutusMap = new PlutusMap();\n      data.map.forEach((val) => {\n        if (isKeyValuePlutusDataJson(val)) {\n          plutusMap.insert(\n            fromJsonToPlutusData(val.k),\n            fromJsonToPlutusData(val.v),\n          );\n        } else {\n          throw new Error(\"Malformed key value pair in Plutus data map\");\n        }\n      });\n      return PlutusData.newMap(plutusMap);\n    } else {\n      console.log(data);\n      throw new Error(\"Malformed map field in Plutus data\");\n    }\n  } else {\n    throw new Error(\"Malformed Plutus data json\");\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const fromJsonToPlutusData = (data: object): PlutusData => {\n  if (isConstrPlutusDataJson(data)) {\n    const plutusList = new PlutusList();\n    data.fields.map((val) => {\n      plutusList.add(fromJsonToPlutusData(val));\n    });\n    const plutusConstrData = new ConstrPlutusData(\n      BigInt(data.constructor),\n      plutusList,\n    );\n    return PlutusData.newConstrPlutusData(plutusConstrData);\n  } else if (\"int\" in data && Object.keys(data).length === 1) {\n    if (\n      typeof data.int === \"bigint\" ||\n      typeof data.int === \"number\" ||\n      typeof data.int === \"string\"\n    ) {\n      return PlutusData.newInteger(BigInt(data.int));\n    } else {\n      throw new Error(\n        \"Malformed int field in Plutus data, expected one of bigint, number or string\",\n      );\n    }\n  } else if (\"bytes\" in data && Object.keys(data).length === 1) {\n    if (typeof data.bytes === \"string\") {\n      return PlutusData.newBytes(Buffer.from(data.bytes, \"hex\"));\n    } else {\n      throw new Error(\"Malformed bytes field in Plutus data, expected string\");\n    }\n  } else if (\"list\" in data && Object.keys(data).length === 1) {\n    if (Array.isArray(data.list)) {\n      const plutusList = new PlutusList();\n      data.list.map((val) => {\n        plutusList.add(fromJsonToPlutusData(val));\n      });\n      return PlutusData.newList(plutusList);\n    } else {\n      throw new Error(\"Malformed list field in Plutus data, expected list\");\n    }\n  } else if (\"map\" in data && Object.keys(data).length === 1) {\n    if (isMapPlutusDataJson(data.map)) {\n      const plutusMap = new PlutusMap();\n      data.map.forEach((val) => {\n        if (isKeyValuePlutusDataJson(val)) {\n          plutusMap.insert(\n            fromJsonToPlutusData(val.k),\n            fromJsonToPlutusData(val.v),\n          );\n        } else {\n          throw new Error(\"Malformed key value pair in Plutus data map\");\n        }\n      });\n      return PlutusData.newMap(plutusMap);\n    } else {\n      console.log(data);\n      throw new Error(\"Malformed map field in Plutus data\");\n    }\n  } else {\n    throw new Error(\"Malformed Plutus data json\");\n  }\n};"
        },
        {
          "name": "fromBuilderToPlutusData",
          "signature": "export const fromBuilderToPlutusData = (data: BuilderData): PlutusData => {",
          "documentation": "",
          "parameters": [
            {
              "name": "data",
              "type": "BuilderData",
              "optional": false
            }
          ],
          "returnType": "PlutusData",
          "isPublic": true,
          "line": 149,
          "raw": "export const fromBuilderToPlutusData = (data: BuilderData): PlutusData => {\n  if (data.type === \"Mesh\") {\n    return toPlutusData(data.content);\n  } else if (data.type === \"CBOR\") {\n    return PlutusData.fromCbor(HexBlob(data.content));\n  } else if (data.type === \"JSON\") {\n    let content: object;\n    if (typeof data.content === \"string\") {\n      content = JSON.parse(data.content);\n    } else {\n      content = data.content;\n    }\n    return fromJsonToPlutusData(content);\n  } else {\n    throw new Error(\n      \"Malformed builder data, expected types of, Mesh, CBOR or JSON\",\n    );\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const fromBuilderToPlutusData = (data: BuilderData): PlutusData => {\n  if (data.type === \"Mesh\") {\n    return toPlutusData(data.content);\n  } else if (data.type === \"CBOR\") {\n    return PlutusData.fromCbor(HexBlob(data.content));\n  } else if (data.type === \"JSON\") {\n    let content: object;\n    if (typeof data.content === \"string\") {\n      content = JSON.parse(data.content);\n    } else {\n      content = data.content;\n    }\n    return fromJsonToPlutusData(content);\n  } else {\n    throw new Error(\n      \"Malformed builder data, expected types of, Mesh, CBOR or JSON\",\n    );\n  }\n};"
        },
        {
          "name": "fromPlutusDataToJson",
          "signature": "export const fromPlutusDataToJson = (data: PlutusData): object => {",
          "documentation": "",
          "parameters": [
            {
              "name": "data",
              "type": "PlutusData",
              "optional": false
            }
          ],
          "returnType": "object",
          "isPublic": true,
          "line": 169,
          "raw": "export const fromPlutusDataToJson = (data: PlutusData): object => {\n  if (data.getKind() === PlutusDataKind.ConstrPlutusData) {\n    const plutusData = data.asConstrPlutusData();\n    if (plutusData !== undefined) {\n      const fields = plutusData.getData();\n      const list: object[] = [];\n      for (let i = 0; i < fields.getLength(); i++) {\n        const element = fields.get(i);\n        list.push(fromPlutusDataToJson(element));\n      }\n      return {\n        constructor: plutusData.getAlternative(),\n        fields: list,\n      };\n    } else {\n      throw new Error(\"Invalid constructor data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Map) {\n    const plutusMap = data.asMap();\n    const mapList: {\n      k: object;\n      v: object;\n    }[] = [];\n    if (plutusMap !== undefined) {\n      const keys = plutusMap.getKeys();\n      for (let i = 0; i < keys.getLength(); i++) {\n        const key = keys.get(i);\n        const value = plutusMap.get(key);\n        if (value) {\n          mapList.push({\n            k: fromPlutusDataToJson(key),\n            v: fromPlutusDataToJson(value),\n          });\n        }\n      }\n      return {\n        map: mapList,\n      };\n    } else {\n      throw new Error(\"Invalid map data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.List) {\n    const plutusList = data.asList();\n    if (plutusList !== undefined) {\n      const list: object[] = [];\n      for (let i = 0; i < plutusList.getLength(); i++) {\n        const element = plutusList.get(i);\n        list.push(fromPlutusDataToJson(element));\n      }\n      return { list: list };\n    } else {\n      throw new Error(\"Invalid list data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Integer) {\n    const plutusInt = data.asInteger();\n    if (plutusInt !== undefined) {\n      return {\n        int: plutusInt,\n      };\n    } else {\n      throw new Error(\"Invalid integer data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Bytes) {\n    const plutusBytes = data.asBoundedBytes();\n    if (plutusBytes !== undefined) {\n      return {\n        bytes: Buffer.from(plutusBytes).toString(\"hex\"),\n      };\n    } else {\n      throw new Error(\"Invalid bytes data found\");\n    }\n  } else {\n    throw new Error(\"Invalid Plutus data found\");\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const fromPlutusDataToJson = (data: PlutusData): object => {\n  if (data.getKind() === PlutusDataKind.ConstrPlutusData) {\n    const plutusData = data.asConstrPlutusData();\n    if (plutusData !== undefined) {\n      const fields = plutusData.getData();\n      const list: object[] = [];\n      for (let i = 0; i < fields.getLength(); i++) {\n        const element = fields.get(i);\n        list.push(fromPlutusDataToJson(element));\n      }\n      return {\n        constructor: plutusData.getAlternative(),\n        fields: list,\n      };\n    } else {\n      throw new Error(\"Invalid constructor data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Map) {\n    const plutusMap = data.asMap();\n    const mapList: {\n      k: object;\n      v: object;\n    }[] = [];\n    if (plutusMap !== undefined) {\n      const keys = plutusMap.getKeys();\n      for (let i = 0; i < keys.getLength(); i++) {\n        const key = keys.get(i);\n        const value = plutusMap.get(key);\n        if (value) {\n          mapList.push({\n            k: fromPlutusDataToJson(key),\n            v: fromPlutusDataToJson(value),\n          });\n        }\n      }\n      return {\n        map: mapList,\n      };\n    } else {\n      throw new Error(\"Invalid map data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.List) {\n    const plutusList = data.asList();\n    if (plutusList !== undefined) {\n      const list: object[] = [];\n      for (let i = 0; i < plutusList.getLength(); i++) {\n        const element = plutusList.get(i);\n        list.push(fromPlutusDataToJson(element));\n      }\n      return { list: list };\n    } else {\n      throw new Error(\"Invalid list data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Integer) {\n    const plutusInt = data.asInteger();\n    if (plutusInt !== undefined) {\n      return {\n        int: plutusInt,\n      };\n    } else {\n      throw new Error(\"Invalid integer data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Bytes) {\n    const plutusBytes = data.asBoundedBytes();\n    if (plutusBytes !== undefined) {\n      return {\n        bytes: Buffer.from(plutusBytes).toString(\"hex\"),\n      };\n    } else {\n      throw new Error(\"Invalid bytes data found\");\n    }\n  } else {\n    throw new Error(\"Invalid Plutus data found\");\n  }\n};"
        },
        {
          "name": "if",
          "signature": "if (data.getKind() === PlutusDataKind.ConstrPlutusData) {",
          "documentation": "",
          "parameters": [
            {
              "name": "data.getKind(",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 170,
          "raw": "  if (data.getKind() === PlutusDataKind.ConstrPlutusData) {\n    const plutusData = data.asConstrPlutusData();\n    if (plutusData !== undefined) {\n      const fields = plutusData.getData();\n      const list: object[] = [];\n      for (let i = 0; i < fields.getLength(); i++) {\n        const element = fields.get(i);\n        list.push(fromPlutusDataToJson(element));\n      }\n      return {\n        constructor: plutusData.getAlternative(),\n        fields: list,\n      };\n    } else {\n      throw new Error(\"Invalid constructor data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Map) {\n    const plutusMap = data.asMap();\n    const mapList: {\n      k: object;\n      v: object;\n    }[] = [];\n    if (plutusMap !== undefined) {\n      const keys = plutusMap.getKeys();\n      for (let i = 0; i < keys.getLength(); i++) {\n        const key = keys.get(i);\n        const value = plutusMap.get(key);\n        if (value) {\n          mapList.push({\n            k: fromPlutusDataToJson(key),\n            v: fromPlutusDataToJson(value),\n          });\n        }\n      }\n      return {\n        map: mapList,\n      };\n    } else {\n      throw new Error(\"Invalid map data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.List) {\n    const plutusList = data.asList();\n    if (plutusList !== undefined) {\n      const list: object[] = [];\n      for (let i = 0; i < plutusList.getLength(); i++) {\n        const element = plutusList.get(i);\n        list.push(fromPlutusDataToJson(element));\n      }\n      return { list: list };\n    } else {\n      throw new Error(\"Invalid list data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Integer) {\n    const plutusInt = data.asInteger();\n    if (plutusInt !== undefined) {\n      return {\n        int: plutusInt,\n      };\n    } else {\n      throw new Error(\"Invalid integer data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Bytes) {\n    const plutusBytes = data.asBoundedBytes();\n    if (plutusBytes !== undefined) {\n      return {\n        bytes: Buffer.from(plutusBytes).toString(\"hex\"),\n      };\n    } else {\n      throw new Error(\"Invalid bytes data found\");\n    }\n  } else {\n    throw new Error(\"Invalid Plutus data found\");\n  }",
          "source": "mesh-core-cst",
          "implementation": "  if (data.getKind() === PlutusDataKind.ConstrPlutusData) {\n    const plutusData = data.asConstrPlutusData();\n    if (plutusData !== undefined) {\n      const fields = plutusData.getData();\n      const list: object[] = [];\n      for (let i = 0; i < fields.getLength(); i++) {\n        const element = fields.get(i);\n        list.push(fromPlutusDataToJson(element));\n      }\n      return {\n        constructor: plutusData.getAlternative(),\n        fields: list,\n      };\n    } else {\n      throw new Error(\"Invalid constructor data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Map) {\n    const plutusMap = data.asMap();\n    const mapList: {\n      k: object;\n      v: object;\n    }[] = [];\n    if (plutusMap !== undefined) {\n      const keys = plutusMap.getKeys();\n      for (let i = 0; i < keys.getLength(); i++) {\n        const key = keys.get(i);\n        const value = plutusMap.get(key);\n        if (value) {\n          mapList.push({\n            k: fromPlutusDataToJson(key),\n            v: fromPlutusDataToJson(value),\n          });\n        }\n      }\n      return {\n        map: mapList,\n      };\n    } else {\n      throw new Error(\"Invalid map data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.List) {\n    const plutusList = data.asList();\n    if (plutusList !== undefined) {\n      const list: object[] = [];\n      for (let i = 0; i < plutusList.getLength(); i++) {\n        const element = plutusList.get(i);\n        list.push(fromPlutusDataToJson(element));\n      }\n      return { list: list };\n    } else {\n      throw new Error(\"Invalid list data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Integer) {\n    const plutusInt = data.asInteger();\n    if (plutusInt !== undefined) {\n      return {\n        int: plutusInt,\n      };\n    } else {\n      throw new Error(\"Invalid integer data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Bytes) {\n    const plutusBytes = data.asBoundedBytes();\n    if (plutusBytes !== undefined) {\n      return {\n        bytes: Buffer.from(plutusBytes).toString(\"hex\"),\n      };\n    } else {\n      throw new Error(\"Invalid bytes data found\");\n    }\n  } else {\n    throw new Error(\"Invalid Plutus data found\");\n  }"
        },
        {
          "name": "deserializeDataHash",
          "signature": "export const deserializeDataHash = (dataHash: string): DatumHash =>",
          "documentation": "",
          "parameters": [
            {
              "name": "dataHash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "DatumHash",
          "isPublic": true,
          "line": 260,
          "raw": "export const deserializeDataHash = (dataHash: string): DatumHash =>",
          "source": "mesh-core-cst",
          "implementation": "export const deserializeDataHash = (dataHash: string): DatumHash =>"
        },
        {
          "name": "deserializePlutusData",
          "signature": "export const deserializePlutusData = (plutusData: string): PlutusData =>",
          "documentation": "",
          "parameters": [
            {
              "name": "plutusData",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "PlutusData",
          "isPublic": true,
          "line": 263,
          "raw": "export const deserializePlutusData = (plutusData: string): PlutusData =>",
          "source": "mesh-core-cst",
          "implementation": "export const deserializePlutusData = (plutusData: string): PlutusData =>"
        }
      ],
      "types": [
        {
          "name": "ConstrPlutusDataJson",
          "definition": "type ConstrPlutusDataJson = {\n  constructor: number | bigint | string;\n  fields: object[];",
          "isPublic": true,
          "line": 51,
          "raw": "type ConstrPlutusDataJson = {",
          "source": "mesh-core-cst"
        },
        {
          "name": "KeyValuePlutusDataJson",
          "definition": "type KeyValuePlutusDataJson = {\n  k: object;\n  v: object;",
          "isPublic": true,
          "line": 68,
          "raw": "type KeyValuePlutusDataJson = {",
          "source": "mesh-core-cst"
        }
      ],
      "constants": [
        {
          "name": "toPlutusData",
          "type": "any",
          "value": "(data: Data): PlutusData => {",
          "isPublic": true,
          "line": 14,
          "raw": "export const toPlutusData = (data: Data): PlutusData => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "toPlutusList",
          "type": "any",
          "value": "(data: Data[]) => {",
          "isPublic": true,
          "line": 15,
          "raw": "const toPlutusList = (data: Data[]) => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusList",
          "type": "any",
          "value": "new PlutusList();",
          "isPublic": true,
          "line": 16,
          "raw": "const plutusList = new PlutusList();",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusList",
          "type": "any",
          "value": "toPlutusList(data);",
          "isPublic": true,
          "line": 32,
          "raw": "const plutusList = toPlutusList(data);",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusMap",
          "type": "any",
          "value": "new PlutusMap();",
          "isPublic": true,
          "line": 35,
          "raw": "const plutusMap = new PlutusMap();",
          "source": "mesh-core-cst"
        },
        {
          "name": "isConstrPlutusDataJson",
          "type": "any",
          "value": "(data: object): data is ConstrPlutusDataJson => {",
          "isPublic": true,
          "line": 56,
          "raw": "const isConstrPlutusDataJson = (data: object): data is ConstrPlutusDataJson => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "fromJsonToPlutusData",
          "type": "any",
          "value": "(data: object): PlutusData => {",
          "isPublic": true,
          "line": 87,
          "raw": "export const fromJsonToPlutusData = (data: object): PlutusData => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusList",
          "type": "any",
          "value": "new PlutusList();",
          "isPublic": true,
          "line": 89,
          "raw": "const plutusList = new PlutusList();",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusConstrData",
          "type": "any",
          "value": "new ConstrPlutusData(",
          "isPublic": true,
          "line": 93,
          "raw": "const plutusConstrData = new ConstrPlutusData(",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusList",
          "type": "any",
          "value": "new PlutusList();",
          "isPublic": true,
          "line": 118,
          "raw": "const plutusList = new PlutusList();",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusMap",
          "type": "any",
          "value": "new PlutusMap();",
          "isPublic": true,
          "line": 128,
          "raw": "const plutusMap = new PlutusMap();",
          "source": "mesh-core-cst"
        },
        {
          "name": "fromBuilderToPlutusData",
          "type": "any",
          "value": "(data: BuilderData): PlutusData => {",
          "isPublic": true,
          "line": 149,
          "raw": "export const fromBuilderToPlutusData = (data: BuilderData): PlutusData => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "fromPlutusDataToJson",
          "type": "any",
          "value": "(data: PlutusData): object => {",
          "isPublic": true,
          "line": 169,
          "raw": "export const fromPlutusDataToJson = (data: PlutusData): object => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusData",
          "type": "any",
          "value": "data.asConstrPlutusData();",
          "isPublic": true,
          "line": 171,
          "raw": "const plutusData = data.asConstrPlutusData();",
          "source": "mesh-core-cst"
        },
        {
          "name": "fields",
          "type": "any",
          "value": "plutusData.getData();",
          "isPublic": true,
          "line": 173,
          "raw": "const fields = plutusData.getData();",
          "source": "mesh-core-cst"
        },
        {
          "name": "list",
          "type": "object[]",
          "value": "[];",
          "isPublic": true,
          "line": 174,
          "raw": "const list: object[] = [];",
          "source": "mesh-core-cst"
        },
        {
          "name": "element",
          "type": "any",
          "value": "fields.get(i);",
          "isPublic": true,
          "line": 176,
          "raw": "const element = fields.get(i);",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusMap",
          "type": "any",
          "value": "data.asMap();",
          "isPublic": true,
          "line": 187,
          "raw": "const plutusMap = data.asMap();",
          "source": "mesh-core-cst"
        },
        {
          "name": "keys",
          "type": "any",
          "value": "plutusMap.getKeys();",
          "isPublic": true,
          "line": 193,
          "raw": "const keys = plutusMap.getKeys();",
          "source": "mesh-core-cst"
        },
        {
          "name": "key",
          "type": "any",
          "value": "keys.get(i);",
          "isPublic": true,
          "line": 195,
          "raw": "const key = keys.get(i);",
          "source": "mesh-core-cst"
        },
        {
          "name": "value",
          "type": "any",
          "value": "plutusMap.get(key);",
          "isPublic": true,
          "line": 196,
          "raw": "const value = plutusMap.get(key);",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusList",
          "type": "any",
          "value": "data.asList();",
          "isPublic": true,
          "line": 211,
          "raw": "const plutusList = data.asList();",
          "source": "mesh-core-cst"
        },
        {
          "name": "list",
          "type": "object[]",
          "value": "[];",
          "isPublic": true,
          "line": 213,
          "raw": "const list: object[] = [];",
          "source": "mesh-core-cst"
        },
        {
          "name": "element",
          "type": "any",
          "value": "plutusList.get(i);",
          "isPublic": true,
          "line": 215,
          "raw": "const element = plutusList.get(i);",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusInt",
          "type": "any",
          "value": "data.asInteger();",
          "isPublic": true,
          "line": 223,
          "raw": "const plutusInt = data.asInteger();",
          "source": "mesh-core-cst"
        },
        {
          "name": "plutusBytes",
          "type": "any",
          "value": "data.asBoundedBytes();",
          "isPublic": true,
          "line": 232,
          "raw": "const plutusBytes = data.asBoundedBytes();",
          "source": "mesh-core-cst"
        },
        {
          "name": "datumCborToJson",
          "type": "any",
          "value": "<T = any>(datumCbor: string): T => {",
          "isPublic": true,
          "line": 245,
          "raw": "const datumCborToJson = <T = any>(datumCbor: string): T => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "parsedDatum",
          "type": "any",
          "value": "PlutusData.fromCbor(HexBlob(datumCbor));",
          "isPublic": true,
          "line": 246,
          "raw": "const parsedDatum = PlutusData.fromCbor(HexBlob(datumCbor));",
          "source": "mesh-core-cst"
        },
        {
          "name": "parseDatumCbor",
          "type": "any",
          "value": "<T = any>(datumCbor: string): T => {",
          "isPublic": true,
          "line": 249,
          "raw": "export const parseDatumCbor = <T = any>(datumCbor: string): T => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "parseInlineDatum",
          "type": "any",
          "value": "<T extends { inline_datum?: string }, X>(",
          "isPublic": true,
          "line": 253,
          "raw": "export const parseInlineDatum = <T extends { inline_datum?: string }, X>(",
          "source": "mesh-core-cst"
        },
        {
          "name": "datumCbor",
          "type": "string",
          "value": "utxo.inline_datum || \"\";",
          "isPublic": true,
          "line": 256,
          "raw": "const datumCbor: string = utxo.inline_datum || \"\";",
          "source": "mesh-core-cst"
        },
        {
          "name": "deserializeDataHash",
          "type": "any",
          "value": "(dataHash: string): DatumHash =>",
          "isPublic": true,
          "line": 260,
          "raw": "export const deserializeDataHash = (dataHash: string): DatumHash =>",
          "source": "mesh-core-cst"
        },
        {
          "name": "deserializePlutusData",
          "type": "any",
          "value": "(plutusData: string): PlutusData =>",
          "isPublic": true,
          "line": 263,
          "raw": "export const deserializePlutusData = (plutusData: string): PlutusData =>",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { HexBlob } from \"@cardano-sdk/util\";\n\nimport { BuilderData, Data, toBytes } from \"@meshsdk/common\";\n\nimport {\n  ConstrPlutusData,\n  DatumHash,\n  PlutusData,\n  PlutusDataKind,\n  PlutusList,\n  PlutusMap,\n} from \"../types\";\n\nexport const toPlutusData = (data: Data): PlutusData => {\n  const toPlutusList = (data: Data[]) => {\n    const plutusList = new PlutusList();\n    data.forEach((element) => {\n      plutusList.add(toPlutusData(element));\n    });\n    return plutusList;\n  };\n\n  switch (typeof data) {\n    case \"string\":\n      return PlutusData.newBytes(toBytes(data));\n    case \"number\":\n      return PlutusData.newInteger(BigInt(data));\n    case \"bigint\":\n      return PlutusData.newInteger(BigInt(data));\n    case \"object\":\n      if (data instanceof Array) {\n        const plutusList = toPlutusList(data);\n        return PlutusData.newList(plutusList);\n      } else if (data instanceof Map) {\n        const plutusMap = new PlutusMap();\n        data.forEach((value, key) => {\n          plutusMap.insert(toPlutusData(key), toPlutusData(value));\n        });\n        return PlutusData.newMap(plutusMap);\n      } else {\n        return PlutusData.newConstrPlutusData(\n          new ConstrPlutusData(\n            BigInt(data.alternative),\n            toPlutusList(data.fields),\n          ),\n        );\n      }\n  }\n};\n\ntype ConstrPlutusDataJson = {\n  constructor: number | bigint | string;\n  fields: object[];\n};\n\nconst isConstrPlutusDataJson = (data: object): data is ConstrPlutusDataJson => {\n  return (\n    typeof data === \"object\" &&\n    \"constructor\" in data &&\n    (typeof data.constructor === \"number\" ||\n      typeof data.constructor === \"bigint\" ||\n      typeof data.constructor === \"string\") &&\n    \"fields\" in data &&\n    Array.isArray(data.fields)\n  );\n};\n\ntype KeyValuePlutusDataJson = {\n  k: object;\n  v: object;\n};\n\nfunction isMapPlutusDataJson(data: any) {\n  return typeof data === \"object\" && Array.isArray(data);\n}\n\nfunction isKeyValuePlutusDataJson(data: any): data is KeyValuePlutusDataJson {\n  return (\n    typeof data === \"object\" &&\n    \"k\" in data &&\n    typeof data.k === \"object\" &&\n    \"v\" in data &&\n    typeof data.v === \"object\"\n  );\n}\n\nexport const fromJsonToPlutusData = (data: object): PlutusData => {\n  if (isConstrPlutusDataJson(data)) {\n    const plutusList = new PlutusList();\n    data.fields.map((val) => {\n      plutusList.add(fromJsonToPlutusData(val));\n    });\n    const plutusConstrData = new ConstrPlutusData(\n      BigInt(data.constructor),\n      plutusList,\n    );\n    return PlutusData.newConstrPlutusData(plutusConstrData);\n  } else if (\"int\" in data && Object.keys(data).length === 1) {\n    if (\n      typeof data.int === \"bigint\" ||\n      typeof data.int === \"number\" ||\n      typeof data.int === \"string\"\n    ) {\n      return PlutusData.newInteger(BigInt(data.int));\n    } else {\n      throw new Error(\n        \"Malformed int field in Plutus data, expected one of bigint, number or string\",\n      );\n    }\n  } else if (\"bytes\" in data && Object.keys(data).length === 1) {\n    if (typeof data.bytes === \"string\") {\n      return PlutusData.newBytes(Buffer.from(data.bytes, \"hex\"));\n    } else {\n      throw new Error(\"Malformed bytes field in Plutus data, expected string\");\n    }\n  } else if (\"list\" in data && Object.keys(data).length === 1) {\n    if (Array.isArray(data.list)) {\n      const plutusList = new PlutusList();\n      data.list.map((val) => {\n        plutusList.add(fromJsonToPlutusData(val));\n      });\n      return PlutusData.newList(plutusList);\n    } else {\n      throw new Error(\"Malformed list field in Plutus data, expected list\");\n    }\n  } else if (\"map\" in data && Object.keys(data).length === 1) {\n    if (isMapPlutusDataJson(data.map)) {\n      const plutusMap = new PlutusMap();\n      data.map.forEach((val) => {\n        if (isKeyValuePlutusDataJson(val)) {\n          plutusMap.insert(\n            fromJsonToPlutusData(val.k),\n            fromJsonToPlutusData(val.v),\n          );\n        } else {\n          throw new Error(\"Malformed key value pair in Plutus data map\");\n        }\n      });\n      return PlutusData.newMap(plutusMap);\n    } else {\n      console.log(data);\n      throw new Error(\"Malformed map field in Plutus data\");\n    }\n  } else {\n    throw new Error(\"Malformed Plutus data json\");\n  }\n};\n\nexport const fromBuilderToPlutusData = (data: BuilderData): PlutusData => {\n  if (data.type === \"Mesh\") {\n    return toPlutusData(data.content);\n  } else if (data.type === \"CBOR\") {\n    return PlutusData.fromCbor(HexBlob(data.content));\n  } else if (data.type === \"JSON\") {\n    let content: object;\n    if (typeof data.content === \"string\") {\n      content = JSON.parse(data.content);\n    } else {\n      content = data.content;\n    }\n    return fromJsonToPlutusData(content);\n  } else {\n    throw new Error(\n      \"Malformed builder data, expected types of, Mesh, CBOR or JSON\",\n    );\n  }\n};\n\nexport const fromPlutusDataToJson = (data: PlutusData): object => {\n  if (data.getKind() === PlutusDataKind.ConstrPlutusData) {\n    const plutusData = data.asConstrPlutusData();\n    if (plutusData !== undefined) {\n      const fields = plutusData.getData();\n      const list: object[] = [];\n      for (let i = 0; i < fields.getLength(); i++) {\n        const element = fields.get(i);\n        list.push(fromPlutusDataToJson(element));\n      }\n      return {\n        constructor: plutusData.getAlternative(),\n        fields: list,\n      };\n    } else {\n      throw new Error(\"Invalid constructor data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Map) {\n    const plutusMap = data.asMap();\n    const mapList: {\n      k: object;\n      v: object;\n    }[] = [];\n    if (plutusMap !== undefined) {\n      const keys = plutusMap.getKeys();\n      for (let i = 0; i < keys.getLength(); i++) {\n        const key = keys.get(i);\n        const value = plutusMap.get(key);\n        if (value) {\n          mapList.push({\n            k: fromPlutusDataToJson(key),\n            v: fromPlutusDataToJson(value),\n          });\n        }\n      }\n      return {\n        map: mapList,\n      };\n    } else {\n      throw new Error(\"Invalid map data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.List) {\n    const plutusList = data.asList();\n    if (plutusList !== undefined) {\n      const list: object[] = [];\n      for (let i = 0; i < plutusList.getLength(); i++) {\n        const element = plutusList.get(i);\n        list.push(fromPlutusDataToJson(element));\n      }\n      return { list: list };\n    } else {\n      throw new Error(\"Invalid list data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Integer) {\n    const plutusInt = data.asInteger();\n    if (plutusInt !== undefined) {\n      return {\n        int: plutusInt,\n      };\n    } else {\n      throw new Error(\"Invalid integer data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Bytes) {\n    const plutusBytes = data.asBoundedBytes();\n    if (plutusBytes !== undefined) {\n      return {\n        bytes: Buffer.from(plutusBytes).toString(\"hex\"),\n      };\n    } else {\n      throw new Error(\"Invalid bytes data found\");\n    }\n  } else {\n    throw new Error(\"Invalid Plutus data found\");\n  }\n};\n\nconst datumCborToJson = <T = any>(datumCbor: string): T => {\n  const parsedDatum = PlutusData.fromCbor(HexBlob(datumCbor));\n  return fromPlutusDataToJson(parsedDatum) as T;\n};\nexport const parseDatumCbor = <T = any>(datumCbor: string): T => {\n  return datumCborToJson(datumCbor) as T;\n};\n\nexport const parseInlineDatum = <T extends { inline_datum?: string }, X>(\n  utxo: T,\n): X => {\n  const datumCbor: string = utxo.inline_datum || \"\";\n  return datumCborToJson(datumCbor) as X;\n};\n\nexport const deserializeDataHash = (dataHash: string): DatumHash =>\n  DatumHash(dataHash);\n\nexport const deserializePlutusData = (plutusData: string): PlutusData =>\n  PlutusData.fromCbor(HexBlob(plutusData));\n",
      "dependencies": [
        "toPlutusData",
        "fromJsonToPlutusData",
        "fromBuilderToPlutusData",
        "fromPlutusDataToJson",
        "parseDatumCbor",
        "parseInlineDatum",
        "deserializeDataHash",
        "deserializePlutusData"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:utils.deserializer.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/utils/deserializer.ts",
      "name": "utils.deserializer.ts",
      "imports": [
        {
          "module": "deserializeEd25519KeyHash",
          "items": [],
          "line": 21,
          "raw": "export const deserializeEd25519KeyHash = (ed25519KeyHash: string) =>",
          "source": "mesh-core-cst"
        },
        {
          "module": "deserializePlutusScript",
          "items": [],
          "line": 24,
          "raw": "export const deserializePlutusScript = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "deserializeNativeScript",
          "items": [],
          "line": 40,
          "raw": "export const deserializeNativeScript = (nativeScript: string): NativeScript =>",
          "source": "mesh-core-cst"
        },
        {
          "module": "deserializeScriptHash",
          "items": [],
          "line": 43,
          "raw": "export const deserializeScriptHash = (scriptHash: string) =>",
          "source": "mesh-core-cst"
        },
        {
          "module": "deserializeScriptRef",
          "items": [],
          "line": 46,
          "raw": "export const deserializeScriptRef = (scriptRef: string): Script =>",
          "source": "mesh-core-cst"
        },
        {
          "module": "deserializeTxUnspentOutput",
          "items": [],
          "line": 49,
          "raw": "export const deserializeTxUnspentOutput = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "deserializeValue",
          "items": [],
          "line": 54,
          "raw": "export const deserializeValue = (value: string): Value =>",
          "source": "mesh-core-cst"
        },
        {
          "module": "deserializeTx",
          "items": [],
          "line": 57,
          "raw": "export const deserializeTx = (tx: string): Transaction =>",
          "source": "mesh-core-cst"
        },
        {
          "module": "deserializeTxHash",
          "items": [],
          "line": 60,
          "raw": "export const deserializeTxHash = (txHash: string): TransactionId =>",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "deserializeEd25519KeyHash",
          "signature": "export const deserializeEd25519KeyHash = (ed25519KeyHash: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "ed25519KeyHash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 21,
          "raw": "export const deserializeEd25519KeyHash = (ed25519KeyHash: string) =>\n  Ed25519KeyHash.fromBytes(toBytes(ed25519KeyHash));\n\nexport const deserializePlutusScript = (\n  plutusScript: string,\n  version: LanguageVersion,\n): PlutusV1Script | PlutusV2Script | PlutusV3Script => {\n  switch (version) {\n    case \"V1\":\n      return PlutusV1Script.fromCbor(HexBlob(plutusScript));\n    case \"V2\":\n      return PlutusV2Script.fromCbor(HexBlob(plutusScript));\n    case \"V3\":\n      return PlutusV3Script.fromCbor(HexBlob(plutusScript));\n    default:\n      throw new Error(\"Invalid Plutus script version\");\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const deserializeEd25519KeyHash = (ed25519KeyHash: string) =>\n  Ed25519KeyHash.fromBytes(toBytes(ed25519KeyHash));\n\nexport const deserializePlutusScript = (\n  plutusScript: string,\n  version: LanguageVersion,\n): PlutusV1Script | PlutusV2Script | PlutusV3Script => {\n  switch (version) {\n    case \"V1\":\n      return PlutusV1Script.fromCbor(HexBlob(plutusScript));\n    case \"V2\":\n      return PlutusV2Script.fromCbor(HexBlob(plutusScript));\n    case \"V3\":\n      return PlutusV3Script.fromCbor(HexBlob(plutusScript));\n    default:\n      throw new Error(\"Invalid Plutus script version\");\n  }\n};"
        },
        {
          "name": "deserializePlutusScript",
          "signature": "export const deserializePlutusScript = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 24,
          "raw": "export const deserializePlutusScript = (\n  plutusScript: string,\n  version: LanguageVersion,\n): PlutusV1Script | PlutusV2Script | PlutusV3Script => {\n  switch (version) {\n    case \"V1\":\n      return PlutusV1Script.fromCbor(HexBlob(plutusScript));\n    case \"V2\":\n      return PlutusV2Script.fromCbor(HexBlob(plutusScript));\n    case \"V3\":\n      return PlutusV3Script.fromCbor(HexBlob(plutusScript));\n    default:\n      throw new Error(\"Invalid Plutus script version\");\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const deserializePlutusScript = (\n  plutusScript: string,\n  version: LanguageVersion,\n): PlutusV1Script | PlutusV2Script | PlutusV3Script => {\n  switch (version) {\n    case \"V1\":\n      return PlutusV1Script.fromCbor(HexBlob(plutusScript));\n    case \"V2\":\n      return PlutusV2Script.fromCbor(HexBlob(plutusScript));\n    case \"V3\":\n      return PlutusV3Script.fromCbor(HexBlob(plutusScript));\n    default:\n      throw new Error(\"Invalid Plutus script version\");\n  }\n};"
        },
        {
          "name": "deserializeNativeScript",
          "signature": "export const deserializeNativeScript = (nativeScript: string): NativeScript =>",
          "documentation": "",
          "parameters": [
            {
              "name": "nativeScript",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "NativeScript",
          "isPublic": true,
          "line": 40,
          "raw": "export const deserializeNativeScript = (nativeScript: string): NativeScript =>",
          "source": "mesh-core-cst",
          "implementation": "export const deserializeNativeScript = (nativeScript: string): NativeScript =>"
        },
        {
          "name": "deserializeScriptHash",
          "signature": "export const deserializeScriptHash = (scriptHash: string) =>",
          "documentation": "",
          "parameters": [
            {
              "name": "scriptHash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 43,
          "raw": "export const deserializeScriptHash = (scriptHash: string) =>",
          "source": "mesh-core-cst",
          "implementation": "export const deserializeScriptHash = (scriptHash: string) =>"
        },
        {
          "name": "deserializeScriptRef",
          "signature": "export const deserializeScriptRef = (scriptRef: string): Script =>",
          "documentation": "",
          "parameters": [
            {
              "name": "scriptRef",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Script",
          "isPublic": true,
          "line": 46,
          "raw": "export const deserializeScriptRef = (scriptRef: string): Script =>",
          "source": "mesh-core-cst",
          "implementation": "export const deserializeScriptRef = (scriptRef: string): Script =>"
        },
        {
          "name": "deserializeTxUnspentOutput",
          "signature": "export const deserializeTxUnspentOutput = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 49,
          "raw": "export const deserializeTxUnspentOutput = (",
          "source": "mesh-core-cst",
          "implementation": "export const deserializeTxUnspentOutput = ("
        },
        {
          "name": "deserializeValue",
          "signature": "export const deserializeValue = (value: string): Value =>",
          "documentation": "",
          "parameters": [
            {
              "name": "value",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Value",
          "isPublic": true,
          "line": 54,
          "raw": "export const deserializeValue = (value: string): Value =>",
          "source": "mesh-core-cst",
          "implementation": "export const deserializeValue = (value: string): Value =>"
        },
        {
          "name": "deserializeTx",
          "signature": "export const deserializeTx = (tx: string): Transaction =>",
          "documentation": "",
          "parameters": [
            {
              "name": "tx",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "isPublic": true,
          "line": 57,
          "raw": "export const deserializeTx = (tx: string): Transaction =>",
          "source": "mesh-core-cst",
          "implementation": "export const deserializeTx = (tx: string): Transaction =>"
        },
        {
          "name": "deserializeTxHash",
          "signature": "export const deserializeTxHash = (txHash: string): TransactionId =>",
          "documentation": "",
          "parameters": [
            {
              "name": "txHash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "TransactionId",
          "isPublic": true,
          "line": 60,
          "raw": "export const deserializeTxHash = (txHash: string): TransactionId =>",
          "source": "mesh-core-cst",
          "implementation": "export const deserializeTxHash = (txHash: string): TransactionId =>"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "deserializeEd25519KeyHash",
          "type": "any",
          "value": "(ed25519KeyHash: string) =>",
          "isPublic": true,
          "line": 21,
          "raw": "export const deserializeEd25519KeyHash = (ed25519KeyHash: string) =>",
          "source": "mesh-core-cst"
        },
        {
          "name": "deserializePlutusScript",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 24,
          "raw": "export const deserializePlutusScript = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "deserializeNativeScript",
          "type": "any",
          "value": "(nativeScript: string): NativeScript =>",
          "isPublic": true,
          "line": 40,
          "raw": "export const deserializeNativeScript = (nativeScript: string): NativeScript =>",
          "source": "mesh-core-cst"
        },
        {
          "name": "deserializeScriptHash",
          "type": "any",
          "value": "(scriptHash: string) =>",
          "isPublic": true,
          "line": 43,
          "raw": "export const deserializeScriptHash = (scriptHash: string) =>",
          "source": "mesh-core-cst"
        },
        {
          "name": "deserializeScriptRef",
          "type": "any",
          "value": "(scriptRef: string): Script =>",
          "isPublic": true,
          "line": 46,
          "raw": "export const deserializeScriptRef = (scriptRef: string): Script =>",
          "source": "mesh-core-cst"
        },
        {
          "name": "deserializeTxUnspentOutput",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 49,
          "raw": "export const deserializeTxUnspentOutput = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "deserializeValue",
          "type": "any",
          "value": "(value: string): Value =>",
          "isPublic": true,
          "line": 54,
          "raw": "export const deserializeValue = (value: string): Value =>",
          "source": "mesh-core-cst"
        },
        {
          "name": "deserializeTx",
          "type": "any",
          "value": "(tx: string): Transaction =>",
          "isPublic": true,
          "line": 57,
          "raw": "export const deserializeTx = (tx: string): Transaction =>",
          "source": "mesh-core-cst"
        },
        {
          "name": "deserializeTxHash",
          "type": "any",
          "value": "(txHash: string): TransactionId =>",
          "isPublic": true,
          "line": 60,
          "raw": "export const deserializeTxHash = (txHash: string): TransactionId =>",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { Serialization } from \"@cardano-sdk/core\";\nimport { Ed25519KeyHashHex } from \"@cardano-sdk/crypto\";\nimport { HexBlob } from \"@cardano-sdk/util\";\n\nimport { DeserializedAddress, LanguageVersion, toBytes } from \"@meshsdk/common\";\n\nimport {\n  Ed25519KeyHash,\n  NativeScript,\n  PlutusV1Script,\n  PlutusV2Script,\n  PlutusV3Script,\n  Script,\n  ScriptHash,\n  Transaction,\n  TransactionId,\n  TransactionUnspentOutput,\n  Value,\n} from \"../types\";\n\nexport const deserializeEd25519KeyHash = (ed25519KeyHash: string) =>\n  Ed25519KeyHash.fromBytes(toBytes(ed25519KeyHash));\n\nexport const deserializePlutusScript = (\n  plutusScript: string,\n  version: LanguageVersion,\n): PlutusV1Script | PlutusV2Script | PlutusV3Script => {\n  switch (version) {\n    case \"V1\":\n      return PlutusV1Script.fromCbor(HexBlob(plutusScript));\n    case \"V2\":\n      return PlutusV2Script.fromCbor(HexBlob(plutusScript));\n    case \"V3\":\n      return PlutusV3Script.fromCbor(HexBlob(plutusScript));\n    default:\n      throw new Error(\"Invalid Plutus script version\");\n  }\n};\n\nexport const deserializeNativeScript = (nativeScript: string): NativeScript =>\n  NativeScript.fromCbor(HexBlob(nativeScript));\n\nexport const deserializeScriptHash = (scriptHash: string) =>\n  ScriptHash.fromEd25519KeyHashHex(Ed25519KeyHashHex(scriptHash));\n\nexport const deserializeScriptRef = (scriptRef: string): Script =>\n  Script.fromCbor(HexBlob(scriptRef));\n\nexport const deserializeTxUnspentOutput = (\n  txUnspentOutput: string,\n): TransactionUnspentOutput =>\n  TransactionUnspentOutput.fromCbor(HexBlob(txUnspentOutput));\n\nexport const deserializeValue = (value: string): Value =>\n  Value.fromCbor(HexBlob(value));\n\nexport const deserializeTx = (tx: string): Transaction =>\n  Transaction.fromCbor(Serialization.TxCBOR(tx));\n\nexport const deserializeTxHash = (txHash: string): TransactionId =>\n  TransactionId(txHash);\n",
      "dependencies": [
        "deserializeEd25519KeyHash",
        "deserializePlutusScript",
        "deserializeNativeScript",
        "deserializeScriptHash",
        "deserializeScriptRef",
        "deserializeTxUnspentOutput",
        "deserializeValue",
        "deserializeTx",
        "deserializeTxHash"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:utils.encoding.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/utils/encoding.ts",
      "name": "utils.encoding.ts",
      "imports": [
        {
          "module": "bytesToHex",
          "items": [],
          "line": 5,
          "raw": "export const bytesToHex = (bytes: Uint8Array): HexBlob =>",
          "source": "mesh-core-cst"
        },
        {
          "module": "hexToBytes",
          "items": [],
          "line": 8,
          "raw": "export const hexToBytes = (hex: HexBlob): Uint8Array => Buffer.from(hex, \"hex\");",
          "source": "mesh-core-cst"
        },
        {
          "module": "utf8ToBytes",
          "items": [],
          "line": 10,
          "raw": "export const utf8ToBytes = (str: string): Uint8Array =>",
          "source": "mesh-core-cst"
        },
        {
          "module": "utf8ToHex",
          "items": [],
          "line": 13,
          "raw": "export const utf8ToHex = (str: string): HexBlob =>",
          "source": "mesh-core-cst"
        },
        {
          "module": "hexToBech32",
          "items": [],
          "line": 16,
          "raw": "export const hexToBech32 = (prefix: string, hex: string): string => {",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "bytesToHex",
          "signature": "export const bytesToHex = (bytes: Uint8Array): HexBlob =>",
          "documentation": "",
          "parameters": [
            {
              "name": "bytes",
              "type": "Uint8Array",
              "optional": false
            }
          ],
          "returnType": "HexBlob",
          "isPublic": true,
          "line": 5,
          "raw": "export const bytesToHex = (bytes: Uint8Array): HexBlob =>\n  Buffer.from(bytes).toString(\"hex\") as HexBlob;\n\nexport const hexToBytes = (hex: HexBlob): Uint8Array => Buffer.from(hex, \"hex\");\n\nexport const utf8ToBytes = (str: string): Uint8Array =>\n  Buffer.from(str, \"utf8\");\n\nexport const utf8ToHex = (str: string): HexBlob =>\n  Buffer.from(str, \"utf8\").toString(\"hex\") as HexBlob;\n\nexport const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};",
          "source": "mesh-core-cst",
          "implementation": "export const bytesToHex = (bytes: Uint8Array): HexBlob =>\n  Buffer.from(bytes).toString(\"hex\") as HexBlob;\n\nexport const hexToBytes = (hex: HexBlob): Uint8Array => Buffer.from(hex, \"hex\");\n\nexport const utf8ToBytes = (str: string): Uint8Array =>\n  Buffer.from(str, \"utf8\");\n\nexport const utf8ToHex = (str: string): HexBlob =>\n  Buffer.from(str, \"utf8\").toString(\"hex\") as HexBlob;\n\nexport const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};"
        },
        {
          "name": "hexToBytes",
          "signature": "export const hexToBytes = (hex: HexBlob): Uint8Array => Buffer.from(hex, \"hex\");",
          "documentation": "",
          "parameters": [
            {
              "name": "hex",
              "type": "HexBlob",
              "optional": false
            }
          ],
          "returnType": "Uint8Array",
          "isPublic": true,
          "line": 8,
          "raw": "export const hexToBytes = (hex: HexBlob): Uint8Array => Buffer.from(hex, \"hex\");\n\nexport const utf8ToBytes = (str: string): Uint8Array =>\n  Buffer.from(str, \"utf8\");\n\nexport const utf8ToHex = (str: string): HexBlob =>\n  Buffer.from(str, \"utf8\").toString(\"hex\") as HexBlob;\n\nexport const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};",
          "source": "mesh-core-cst",
          "implementation": "export const hexToBytes = (hex: HexBlob): Uint8Array => Buffer.from(hex, \"hex\");\n\nexport const utf8ToBytes = (str: string): Uint8Array =>\n  Buffer.from(str, \"utf8\");\n\nexport const utf8ToHex = (str: string): HexBlob =>\n  Buffer.from(str, \"utf8\").toString(\"hex\") as HexBlob;\n\nexport const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};"
        },
        {
          "name": "utf8ToBytes",
          "signature": "export const utf8ToBytes = (str: string): Uint8Array =>",
          "documentation": "",
          "parameters": [
            {
              "name": "str",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Uint8Array",
          "isPublic": true,
          "line": 10,
          "raw": "export const utf8ToBytes = (str: string): Uint8Array =>\n  Buffer.from(str, \"utf8\");\n\nexport const utf8ToHex = (str: string): HexBlob =>\n  Buffer.from(str, \"utf8\").toString(\"hex\") as HexBlob;\n\nexport const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};",
          "source": "mesh-core-cst",
          "implementation": "export const utf8ToBytes = (str: string): Uint8Array =>\n  Buffer.from(str, \"utf8\");\n\nexport const utf8ToHex = (str: string): HexBlob =>\n  Buffer.from(str, \"utf8\").toString(\"hex\") as HexBlob;\n\nexport const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};"
        },
        {
          "name": "utf8ToHex",
          "signature": "export const utf8ToHex = (str: string): HexBlob =>",
          "documentation": "",
          "parameters": [
            {
              "name": "str",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "HexBlob",
          "isPublic": true,
          "line": 13,
          "raw": "export const utf8ToHex = (str: string): HexBlob =>\n  Buffer.from(str, \"utf8\").toString(\"hex\") as HexBlob;\n\nexport const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};",
          "source": "mesh-core-cst",
          "implementation": "export const utf8ToHex = (str: string): HexBlob =>\n  Buffer.from(str, \"utf8\").toString(\"hex\") as HexBlob;\n\nexport const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};"
        },
        {
          "name": "hexToBech32",
          "signature": "export const hexToBech32 = (prefix: string, hex: string): string => {",
          "documentation": "",
          "parameters": [
            {
              "name": "prefix",
              "type": "string",
              "optional": false
            },
            {
              "name": "hex",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 16,
          "raw": "export const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};",
          "source": "mesh-core-cst",
          "implementation": "export const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "bytesToHex",
          "type": "any",
          "value": "(bytes: Uint8Array): HexBlob =>",
          "isPublic": true,
          "line": 5,
          "raw": "export const bytesToHex = (bytes: Uint8Array): HexBlob =>",
          "source": "mesh-core-cst"
        },
        {
          "name": "hexToBytes",
          "type": "any",
          "value": "(hex: HexBlob): Uint8Array => Buffer.from(hex, \"hex\");",
          "isPublic": true,
          "line": 8,
          "raw": "export const hexToBytes = (hex: HexBlob): Uint8Array => Buffer.from(hex, \"hex\");",
          "source": "mesh-core-cst"
        },
        {
          "name": "utf8ToBytes",
          "type": "any",
          "value": "(str: string): Uint8Array =>",
          "isPublic": true,
          "line": 10,
          "raw": "export const utf8ToBytes = (str: string): Uint8Array =>",
          "source": "mesh-core-cst"
        },
        {
          "name": "utf8ToHex",
          "type": "any",
          "value": "(str: string): HexBlob =>",
          "isPublic": true,
          "line": 13,
          "raw": "export const utf8ToHex = (str: string): HexBlob =>",
          "source": "mesh-core-cst"
        },
        {
          "name": "hexToBech32",
          "type": "any",
          "value": "(prefix: string, hex: string): string => {",
          "isPublic": true,
          "line": 16,
          "raw": "export const hexToBech32 = (prefix: string, hex: string): string => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "buf",
          "type": "any",
          "value": "Buffer.from(hex, \"hex\");",
          "isPublic": true,
          "line": 17,
          "raw": "const buf = Buffer.from(hex, \"hex\");",
          "source": "mesh-core-cst"
        },
        {
          "name": "base32RawBytes",
          "type": "any",
          "value": "base32.encode(buf);",
          "isPublic": true,
          "line": 18,
          "raw": "const base32RawBytes = base32.encode(buf);",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { HexBlob } from \"@cardano-sdk/util\";\nimport base32 from \"base32-encoding\";\nimport { bech32 } from \"bech32\";\n\nexport const bytesToHex = (bytes: Uint8Array): HexBlob =>\n  Buffer.from(bytes).toString(\"hex\") as HexBlob;\n\nexport const hexToBytes = (hex: HexBlob): Uint8Array => Buffer.from(hex, \"hex\");\n\nexport const utf8ToBytes = (str: string): Uint8Array =>\n  Buffer.from(str, \"utf8\");\n\nexport const utf8ToHex = (str: string): HexBlob =>\n  Buffer.from(str, \"utf8\").toString(\"hex\") as HexBlob;\n\nexport const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};\n",
      "dependencies": [
        "bytesToHex",
        "hexToBytes",
        "utf8ToBytes",
        "utf8ToHex",
        "hexToBech32"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:utils.fee.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/utils/fee.ts",
      "name": "utils.fee.ts",
      "imports": [
        {
          "module": "calculateFees",
          "items": [],
          "line": 3,
          "raw": "export const calculateFees = (",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "calculateFees",
          "signature": "export const calculateFees = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 3,
          "raw": "export const calculateFees = (\n  minFeeA: number,\n  minFeeB: number,\n  minFeeRefScriptCostPerByte: number,\n  priceMem: number,\n  priceStep: number,\n  tx: Transaction,\n  refScriptSize: number,\n): bigint => {\n  let fee = minFeeB + (tx.toCbor().length / 2) * minFeeA;\n  fee += calculateRefScriptFees(refScriptSize, minFeeRefScriptCostPerByte);\n  let scriptFee = BigInt(0);\n  let priceMemNumerator = priceMem;\n  let priceMemDenominator = 1;\n  while (priceMemNumerator % 1) {\n    priceMemNumerator *= 10;\n    priceMemDenominator *= 10;\n  }\n  let priceStepNumerator = priceStep;\n  let priceStepDenominator = 1;\n  while (priceStepNumerator % 1) {\n    priceStepNumerator *= 10;\n    priceStepDenominator *= 10;\n  }\n  if (tx.witnessSet().redeemers()) {\n    for (const redeemer of tx.witnessSet().redeemers()!.values()) {\n      scriptFee +=\n        (redeemer.exUnits().mem() * BigInt(priceMemNumerator.toString())) /\n        BigInt(priceMemDenominator.toString());\n      scriptFee +=\n        (redeemer.exUnits().steps() * BigInt(priceStepNumerator.toString())) /\n        BigInt(priceStepDenominator.toString());\n      if (priceMemNumerator % priceMemDenominator !== 0) {\n        scriptFee += BigInt(1);\n      }\n      if (priceStepNumerator % priceStepDenominator !== 0) {\n        scriptFee += BigInt(1);\n      }\n    }\n  }\n  return BigInt(fee) + scriptFee;\n};",
          "source": "mesh-core-cst",
          "implementation": "export const calculateFees = (\n  minFeeA: number,\n  minFeeB: number,\n  minFeeRefScriptCostPerByte: number,\n  priceMem: number,\n  priceStep: number,\n  tx: Transaction,\n  refScriptSize: number,\n): bigint => {\n  let fee = minFeeB + (tx.toCbor().length / 2) * minFeeA;\n  fee += calculateRefScriptFees(refScriptSize, minFeeRefScriptCostPerByte);\n  let scriptFee = BigInt(0);\n  let priceMemNumerator = priceMem;\n  let priceMemDenominator = 1;\n  while (priceMemNumerator % 1) {\n    priceMemNumerator *= 10;\n    priceMemDenominator *= 10;\n  }\n  let priceStepNumerator = priceStep;\n  let priceStepDenominator = 1;\n  while (priceStepNumerator % 1) {\n    priceStepNumerator *= 10;\n    priceStepDenominator *= 10;\n  }\n  if (tx.witnessSet().redeemers()) {\n    for (const redeemer of tx.witnessSet().redeemers()!.values()) {\n      scriptFee +=\n        (redeemer.exUnits().mem() * BigInt(priceMemNumerator.toString())) /\n        BigInt(priceMemDenominator.toString());\n      scriptFee +=\n        (redeemer.exUnits().steps() * BigInt(priceStepNumerator.toString())) /\n        BigInt(priceStepDenominator.toString());\n      if (priceMemNumerator % priceMemDenominator !== 0) {\n        scriptFee += BigInt(1);\n      }\n      if (priceStepNumerator % priceStepDenominator !== 0) {\n        scriptFee += BigInt(1);\n      }\n    }\n  }\n  return BigInt(fee) + scriptFee;\n};"
        },
        {
          "name": "calculateRefScriptFees",
          "signature": "const calculateRefScriptFees = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 46,
          "raw": "const calculateRefScriptFees = (\n  refScriptSize: number,\n  minFeeRefScriptCostPerByte: number,\n  tierMultiplier = 1.2,\n): number => {\n  let fee = 0;\n  const tierSize = 25600;\n  let currentRefScriptSize = refScriptSize;\n  let multiplier = 1;\n  while (currentRefScriptSize >= tierSize) {\n    fee += tierSize * multiplier * minFeeRefScriptCostPerByte;\n    currentRefScriptSize -= tierSize;\n    multiplier *= tierMultiplier;\n  }\n  if (currentRefScriptSize > 0) {\n    fee += currentRefScriptSize * multiplier * minFeeRefScriptCostPerByte;\n  }\n  fee = Math.ceil(fee);\n  return fee;\n};",
          "source": "mesh-core-cst",
          "implementation": "const calculateRefScriptFees = (\n  refScriptSize: number,\n  minFeeRefScriptCostPerByte: number,\n  tierMultiplier = 1.2,\n): number => {\n  let fee = 0;\n  const tierSize = 25600;\n  let currentRefScriptSize = refScriptSize;\n  let multiplier = 1;\n  while (currentRefScriptSize >= tierSize) {\n    fee += tierSize * multiplier * minFeeRefScriptCostPerByte;\n    currentRefScriptSize -= tierSize;\n    multiplier *= tierMultiplier;\n  }\n  if (currentRefScriptSize > 0) {\n    fee += currentRefScriptSize * multiplier * minFeeRefScriptCostPerByte;\n  }\n  fee = Math.ceil(fee);\n  return fee;\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "calculateFees",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 3,
          "raw": "export const calculateFees = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "calculateRefScriptFees",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 46,
          "raw": "const calculateRefScriptFees = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "tierSize",
          "type": "any",
          "value": "25600;",
          "isPublic": true,
          "line": 52,
          "raw": "const tierSize = 25600;",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { Transaction } from \"../types\";\n\nexport const calculateFees = (\n  minFeeA: number,\n  minFeeB: number,\n  minFeeRefScriptCostPerByte: number,\n  priceMem: number,\n  priceStep: number,\n  tx: Transaction,\n  refScriptSize: number,\n): bigint => {\n  let fee = minFeeB + (tx.toCbor().length / 2) * minFeeA;\n  fee += calculateRefScriptFees(refScriptSize, minFeeRefScriptCostPerByte);\n  let scriptFee = BigInt(0);\n  let priceMemNumerator = priceMem;\n  let priceMemDenominator = 1;\n  while (priceMemNumerator % 1) {\n    priceMemNumerator *= 10;\n    priceMemDenominator *= 10;\n  }\n  let priceStepNumerator = priceStep;\n  let priceStepDenominator = 1;\n  while (priceStepNumerator % 1) {\n    priceStepNumerator *= 10;\n    priceStepDenominator *= 10;\n  }\n  if (tx.witnessSet().redeemers()) {\n    for (const redeemer of tx.witnessSet().redeemers()!.values()) {\n      scriptFee +=\n        (redeemer.exUnits().mem() * BigInt(priceMemNumerator.toString())) /\n        BigInt(priceMemDenominator.toString());\n      scriptFee +=\n        (redeemer.exUnits().steps() * BigInt(priceStepNumerator.toString())) /\n        BigInt(priceStepDenominator.toString());\n      if (priceMemNumerator % priceMemDenominator !== 0) {\n        scriptFee += BigInt(1);\n      }\n      if (priceStepNumerator % priceStepDenominator !== 0) {\n        scriptFee += BigInt(1);\n      }\n    }\n  }\n  return BigInt(fee) + scriptFee;\n};\n\nconst calculateRefScriptFees = (\n  refScriptSize: number,\n  minFeeRefScriptCostPerByte: number,\n  tierMultiplier = 1.2,\n): number => {\n  let fee = 0;\n  const tierSize = 25600;\n  let currentRefScriptSize = refScriptSize;\n  let multiplier = 1;\n  while (currentRefScriptSize >= tierSize) {\n    fee += tierSize * multiplier * minFeeRefScriptCostPerByte;\n    currentRefScriptSize -= tierSize;\n    multiplier *= tierMultiplier;\n  }\n  if (currentRefScriptSize > 0) {\n    fee += currentRefScriptSize * multiplier * minFeeRefScriptCostPerByte;\n  }\n  fee = Math.ceil(fee);\n  return fee;\n};\n",
      "dependencies": [
        "calculateFees"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:utils.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/utils/index.ts",
      "name": "utils.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./builder\";\nexport * from \"./converter\";\nexport * from \"./deserializer\";\nexport * from \"./value\";\nexport * from \"./data\";\nexport * from \"./address\";\nexport * from \"./encoding\";\nexport * from \"./witness-set\";\nexport * from \"./fee\";\n",
      "dependencies": [],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:utils.metadata.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/utils/metadata.ts",
      "name": "utils.metadata.ts",
      "imports": [
        {
          "module": "toCardanoMetadataMap",
          "items": [],
          "line": 5,
          "raw": "export const toCardanoMetadataMap = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "toCardanoMetadatum",
          "items": [],
          "line": 15,
          "raw": "export const toCardanoMetadatum = (",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "toCardanoMetadataMap",
          "signature": "export const toCardanoMetadataMap = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 5,
          "raw": "export const toCardanoMetadataMap = (\n  metadata: TxMetadata,\n): Map<bigint, TransactionMetadatum> => {\n  let cardanoMetadataMap = new Map<bigint, TransactionMetadatum>();\n  metadata.forEach((val, key) => {\n    cardanoMetadataMap.set(key, toCardanoMetadatum(val));\n  });\n  return cardanoMetadataMap;\n};",
          "source": "mesh-core-cst",
          "implementation": "export const toCardanoMetadataMap = (\n  metadata: TxMetadata,\n): Map<bigint, TransactionMetadatum> => {\n  let cardanoMetadataMap = new Map<bigint, TransactionMetadatum>();\n  metadata.forEach((val, key) => {\n    cardanoMetadataMap.set(key, toCardanoMetadatum(val));\n  });\n  return cardanoMetadataMap;\n};"
        },
        {
          "name": "toCardanoMetadatum",
          "signature": "export const toCardanoMetadatum = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 15,
          "raw": "export const toCardanoMetadatum = (\n  metadatum: Metadatum,\n): TransactionMetadatum => {\n  if (typeof metadatum === \"number\") {\n    return TransactionMetadatum.newInteger(BigInt(metadatum));\n  } else if (typeof metadatum === \"string\") {\n    return TransactionMetadatum.newText(metadatum);\n  } else if (typeof metadatum === \"bigint\") {\n    return TransactionMetadatum.newInteger(metadatum);\n  } else if (metadatum instanceof Uint8Array) {\n    return TransactionMetadatum.newBytes(metadatum);\n  } else if (metadatum instanceof Map) {\n    const result: MetadatumMap = new MetadatumMap();\n    metadatum.forEach((value, key) => {\n      result.insert(toCardanoMetadatum(key), toCardanoMetadatum(value));\n    });\n    return TransactionMetadatum.newMap(result);\n  } else if (Array.isArray(metadatum)) {\n    const result: MetadatumList = new MetadatumList();\n    metadatum.forEach((val) => {\n      result.add(toCardanoMetadatum(val));\n    });\n    return TransactionMetadatum.newList(result);\n  } else {\n    throw new Error(\"metadatumToObj: Unsupported Metadatum type\");\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const toCardanoMetadatum = (\n  metadatum: Metadatum,\n): TransactionMetadatum => {\n  if (typeof metadatum === \"number\") {\n    return TransactionMetadatum.newInteger(BigInt(metadatum));\n  } else if (typeof metadatum === \"string\") {\n    return TransactionMetadatum.newText(metadatum);\n  } else if (typeof metadatum === \"bigint\") {\n    return TransactionMetadatum.newInteger(metadatum);\n  } else if (metadatum instanceof Uint8Array) {\n    return TransactionMetadatum.newBytes(metadatum);\n  } else if (metadatum instanceof Map) {\n    const result: MetadatumMap = new MetadatumMap();\n    metadatum.forEach((value, key) => {\n      result.insert(toCardanoMetadatum(key), toCardanoMetadatum(value));\n    });\n    return TransactionMetadatum.newMap(result);\n  } else if (Array.isArray(metadatum)) {\n    const result: MetadatumList = new MetadatumList();\n    metadatum.forEach((val) => {\n      result.add(toCardanoMetadatum(val));\n    });\n    return TransactionMetadatum.newList(result);\n  } else {\n    throw new Error(\"metadatumToObj: Unsupported Metadatum type\");\n  }\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "toCardanoMetadataMap",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 5,
          "raw": "export const toCardanoMetadataMap = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "toCardanoMetadatum",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 15,
          "raw": "export const toCardanoMetadatum = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "result",
          "type": "MetadatumMap",
          "value": "new MetadatumMap();",
          "isPublic": true,
          "line": 27,
          "raw": "const result: MetadatumMap = new MetadatumMap();",
          "source": "mesh-core-cst"
        },
        {
          "name": "result",
          "type": "MetadatumList",
          "value": "new MetadatumList();",
          "isPublic": true,
          "line": 33,
          "raw": "const result: MetadatumList = new MetadatumList();",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { Metadatum, TxMetadata } from \"@meshsdk/common\";\n\nimport { MetadatumList, MetadatumMap, TransactionMetadatum } from \"../types\";\n\nexport const toCardanoMetadataMap = (\n  metadata: TxMetadata,\n): Map<bigint, TransactionMetadatum> => {\n  let cardanoMetadataMap = new Map<bigint, TransactionMetadatum>();\n  metadata.forEach((val, key) => {\n    cardanoMetadataMap.set(key, toCardanoMetadatum(val));\n  });\n  return cardanoMetadataMap;\n};\n\nexport const toCardanoMetadatum = (\n  metadatum: Metadatum,\n): TransactionMetadatum => {\n  if (typeof metadatum === \"number\") {\n    return TransactionMetadatum.newInteger(BigInt(metadatum));\n  } else if (typeof metadatum === \"string\") {\n    return TransactionMetadatum.newText(metadatum);\n  } else if (typeof metadatum === \"bigint\") {\n    return TransactionMetadatum.newInteger(metadatum);\n  } else if (metadatum instanceof Uint8Array) {\n    return TransactionMetadatum.newBytes(metadatum);\n  } else if (metadatum instanceof Map) {\n    const result: MetadatumMap = new MetadatumMap();\n    metadatum.forEach((value, key) => {\n      result.insert(toCardanoMetadatum(key), toCardanoMetadatum(value));\n    });\n    return TransactionMetadatum.newMap(result);\n  } else if (Array.isArray(metadatum)) {\n    const result: MetadatumList = new MetadatumList();\n    metadatum.forEach((val) => {\n      result.add(toCardanoMetadatum(val));\n    });\n    return TransactionMetadatum.newList(result);\n  } else {\n    throw new Error(\"metadatumToObj: Unsupported Metadatum type\");\n  }\n};\n",
      "dependencies": [
        "toCardanoMetadataMap",
        "toCardanoMetadatum"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:utils.script-data-hash.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/utils/script-data-hash.ts",
      "name": "utils.script-data-hash.ts",
      "imports": [
        {
          "module": "hashScriptData",
          "items": [],
          "line": 24,
          "raw": "export const hashScriptData = (",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "hashScriptData",
          "signature": "export const hashScriptData = (",
          "documentation": "/**\n * Computes the hash of script data in a transaction, including redeemers, datums, and cost models.\n *\n * This function takes arrays of redeemers and datums, along with cost models, and encodes\n * them in a CBOR (Concise Binary Object Representation) format. The encoded data is then\n * hashed using the Blake2b hashing algorithm to produce a 32-byte hash. This hash is\n * representative of the script data in a transaction on the Cardano blockchain.\n *\n * @param costModels The cost models for script execution.\n * @param redemeers The redeemers in the transaction. If not present or empty, the function may return undefined.\n * @param datums The datums in the transaction.\n * @returns The hashed script data, or undefined if no redeemers are provided.\n */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 24,
          "raw": "/**\n * Computes the hash of script data in a transaction, including redeemers, datums, and cost models.\n *\n * This function takes arrays of redeemers and datums, along with cost models, and encodes\n * them in a CBOR (Concise Binary Object Representation) format. The encoded data is then\n * hashed using the Blake2b hashing algorithm to produce a 32-byte hash. This hash is\n * representative of the script data in a transaction on the Cardano blockchain.\n *\n * @param costModels The cost models for script execution.\n * @param redemeers The redeemers in the transaction. If not present or empty, the function may return undefined.\n * @param datums The datums in the transaction.\n * @returns The hashed script data, or undefined if no redeemers are provided.\n */\nexport const hashScriptData = (\n  costModels: Serialization.Costmdls,\n  redemeers?: Serialization.Redeemers,\n  datums?: Serialization.CborSet<Cardano.PlutusData, PlutusData>,\n): Crypto.Hash32ByteBase16 | undefined => {\n  const writer = new Serialization.CborWriter();\n  if (datums && datums.size() > 0 && (!redemeers || redemeers.size() === 0)) {\n    /*\n     ; Note that in the case that a transaction includes datums but does not\n     ; include any redeemers, the script data format becomes (in hex):\n     ; [ A0 | datums | A0 ]\n     ; corresponding to a CBOR empty list and an empty map).\n    */\n    writer.writeEncodedValue(CBOR_EMPTY_MAP);\n    writer.writeEncodedValue(Buffer.from(datums.toCbor(), \"hex\"));\n    writer.writeEncodedValue(CBOR_EMPTY_MAP);\n  } else {\n    if (!redemeers || redemeers.size() === 0) return undefined;\n    /*\n     ; script data format:\n     ; [ redeemers | datums | language views ]\n     ; The redeemers are exactly the data present in the transaction witness set.\n     ; Similarly for the datums, if present. If no datums are provided, the middle\n     ; field is an empty string.\n    */\n    writer.writeEncodedValue(Buffer.from(redemeers.toCbor(), \"hex\"));\n    if (datums && datums.size() > 0) {\n      writer.writeEncodedValue(Buffer.from(datums.toCbor(), \"hex\"));\n    }\n    writer.writeEncodedValue(\n      Buffer.from(costModels.languageViewsEncoding(), \"hex\"),\n    );\n  }\n\n  return Hash32ByteBase16.fromHexBlob(\n    HexBlob.fromBytes(\n      Crypto.blake2b(Crypto.blake2b.BYTES).update(writer.encode()).digest(),\n    ),\n  );\n};",
          "source": "mesh-core-cst",
          "implementation": "export const hashScriptData = (\n  costModels: Serialization.Costmdls,\n  redemeers?: Serialization.Redeemers,\n  datums?: Serialization.CborSet<Cardano.PlutusData, PlutusData>,\n): Crypto.Hash32ByteBase16 | undefined => {\n  const writer = new Serialization.CborWriter();\n  if (datums && datums.size() > 0 && (!redemeers || redemeers.size() === 0)) {\n    /*\n     ; Note that in the case that a transaction includes datums but does not\n     ; include any redeemers, the script data format becomes (in hex):\n     ; [ A0 | datums | A0 ]\n     ; corresponding to a CBOR empty list and an empty map).\n    */\n    writer.writeEncodedValue(CBOR_EMPTY_MAP);\n    writer.writeEncodedValue(Buffer.from(datums.toCbor(), \"hex\"));\n    writer.writeEncodedValue(CBOR_EMPTY_MAP);\n  } else {\n    if (!redemeers || redemeers.size() === 0) return undefined;\n    /*\n     ; script data format:\n     ; [ redeemers | datums | language views ]\n     ; The redeemers are exactly the data present in the transaction witness set.\n     ; Similarly for the datums, if present. If no datums are provided, the middle\n     ; field is an empty string.\n    */\n    writer.writeEncodedValue(Buffer.from(redemeers.toCbor(), \"hex\"));\n    if (datums && datums.size() > 0) {\n      writer.writeEncodedValue(Buffer.from(datums.toCbor(), \"hex\"));\n    }\n    writer.writeEncodedValue(\n      Buffer.from(costModels.languageViewsEncoding(), \"hex\"),\n    );\n  }\n\n  return Hash32ByteBase16.fromHexBlob(\n    HexBlob.fromBytes(\n      Crypto.blake2b(Crypto.blake2b.BYTES).update(writer.encode()).digest(),\n    ),\n  );\n};"
        },
        {
          "name": "if",
          "signature": "if (!redemeers || redemeers.size() === 0) return undefined;",
          "documentation": "",
          "parameters": [
            {
              "name": "!redemeers || redemeers.size(",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 41,
          "raw": "    if (!redemeers || redemeers.size() === 0) return undefined;\n    /*\n     ; script data format:\n     ; [ redeemers | datums | language views ]\n     ; The redeemers are exactly the data present in the transaction witness set.\n     ; Similarly for the datums, if present. If no datums are provided, the middle\n     ; field is an empty string.\n    */\n    writer.writeEncodedValue(Buffer.from(redemeers.toCbor(), \"hex\"));\n    if (datums && datums.size() > 0) {\n      writer.writeEncodedValue(Buffer.from(datums.toCbor(), \"hex\"));\n    }",
          "source": "mesh-core-cst",
          "implementation": "    if (!redemeers || redemeers.size() === 0) return undefined;\n    /*\n     ; script data format:\n     ; [ redeemers | datums | language views ]\n     ; The redeemers are exactly the data present in the transaction witness set.\n     ; Similarly for the datums, if present. If no datums are provided, the middle\n     ; field is an empty string.\n    */\n    writer.writeEncodedValue(Buffer.from(redemeers.toCbor(), \"hex\"));\n    if (datums && datums.size() > 0) {\n      writer.writeEncodedValue(Buffer.from(datums.toCbor(), \"hex\"));\n    }"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "CBOR_EMPTY_MAP",
          "type": "any",
          "value": "new Uint8Array([0xa0]);",
          "isPublic": true,
          "line": 9,
          "raw": "const CBOR_EMPTY_MAP = new Uint8Array([0xa0]);",
          "source": "mesh-core-cst"
        },
        {
          "name": "hashScriptData",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 24,
          "raw": "export const hashScriptData = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "writer",
          "type": "any",
          "value": "new Serialization.CborWriter();",
          "isPublic": true,
          "line": 29,
          "raw": "const writer = new Serialization.CborWriter();",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "/* eslint-disable unicorn/number-literal-case */\nimport { Cardano, Serialization } from \"@cardano-sdk/core\";\nimport * as Crypto from \"@cardano-sdk/crypto\";\nimport { Hash32ByteBase16 } from \"@cardano-sdk/crypto\";\nimport { HexBlob } from \"@cardano-sdk/util\";\n\nimport { PlutusData } from \"../types\";\n\nconst CBOR_EMPTY_MAP = new Uint8Array([0xa0]);\n\n/**\n * Computes the hash of script data in a transaction, including redeemers, datums, and cost models.\n *\n * This function takes arrays of redeemers and datums, along with cost models, and encodes\n * them in a CBOR (Concise Binary Object Representation) format. The encoded data is then\n * hashed using the Blake2b hashing algorithm to produce a 32-byte hash. This hash is\n * representative of the script data in a transaction on the Cardano blockchain.\n *\n * @param costModels The cost models for script execution.\n * @param redemeers The redeemers in the transaction. If not present or empty, the function may return undefined.\n * @param datums The datums in the transaction.\n * @returns The hashed script data, or undefined if no redeemers are provided.\n */\nexport const hashScriptData = (\n  costModels: Serialization.Costmdls,\n  redemeers?: Serialization.Redeemers,\n  datums?: Serialization.CborSet<Cardano.PlutusData, PlutusData>,\n): Crypto.Hash32ByteBase16 | undefined => {\n  const writer = new Serialization.CborWriter();\n  if (datums && datums.size() > 0 && (!redemeers || redemeers.size() === 0)) {\n    /*\n     ; Note that in the case that a transaction includes datums but does not\n     ; include any redeemers, the script data format becomes (in hex):\n     ; [ A0 | datums | A0 ]\n     ; corresponding to a CBOR empty list and an empty map).\n    */\n    writer.writeEncodedValue(CBOR_EMPTY_MAP);\n    writer.writeEncodedValue(Buffer.from(datums.toCbor(), \"hex\"));\n    writer.writeEncodedValue(CBOR_EMPTY_MAP);\n  } else {\n    if (!redemeers || redemeers.size() === 0) return undefined;\n    /*\n     ; script data format:\n     ; [ redeemers | datums | language views ]\n     ; The redeemers are exactly the data present in the transaction witness set.\n     ; Similarly for the datums, if present. If no datums are provided, the middle\n     ; field is an empty string.\n    */\n    writer.writeEncodedValue(Buffer.from(redemeers.toCbor(), \"hex\"));\n    if (datums && datums.size() > 0) {\n      writer.writeEncodedValue(Buffer.from(datums.toCbor(), \"hex\"));\n    }\n    writer.writeEncodedValue(\n      Buffer.from(costModels.languageViewsEncoding(), \"hex\"),\n    );\n  }\n\n  return Hash32ByteBase16.fromHexBlob(\n    HexBlob.fromBytes(\n      Crypto.blake2b(Crypto.blake2b.BYTES).update(writer.encode()).digest(),\n    ),\n  );\n};\n",
      "dependencies": [
        "hashScriptData"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:utils.value.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/utils/value.ts",
      "name": "utils.value.ts",
      "imports": [
        {
          "module": "mergeValue",
          "items": [],
          "line": 3,
          "raw": "export function mergeValue(a: Value, b: Value): Value {",
          "source": "mesh-core-cst"
        },
        {
          "module": "negateValue",
          "items": [],
          "line": 19,
          "raw": "export function negateValue(v: Value): Value {",
          "source": "mesh-core-cst"
        },
        {
          "module": "subValue",
          "items": [],
          "line": 30,
          "raw": "export function subValue(a: Value, b: Value): Value {",
          "source": "mesh-core-cst"
        },
        {
          "module": "negatives",
          "items": [],
          "line": 34,
          "raw": "export function negatives(v: Value): Value {",
          "source": "mesh-core-cst"
        },
        {
          "module": "assetTypes",
          "items": [],
          "line": 48,
          "raw": "export function assetTypes(v: Value): number {",
          "source": "mesh-core-cst"
        },
        {
          "module": "empty",
          "items": [],
          "line": 59,
          "raw": "export function empty(v: Value): boolean {",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "mergeValue",
          "signature": "export function mergeValue(a: Value, b: Value): Value {",
          "documentation": "",
          "parameters": [
            {
              "name": "a",
              "type": "Value",
              "optional": false
            },
            {
              "name": "b",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "Value",
          "isPublic": true,
          "line": 3,
          "raw": "export function mergeValue(a: Value, b: Value): Value {\n  const ma = a.multiasset() ?? new Map();\n  b.multiasset()?.forEach((v, k) => {\n    const newVal = (ma.get(k) ?? 0n) + v;\n    if (newVal == 0n) {\n      ma.delete(k);\n    } else {\n      ma.set(k, newVal);\n    }\n  });\n  return new Value(\n    BigInt(a.coin()) + BigInt(b.coin()),\n    ma.size > 0 ? ma : undefined,\n  );\n}",
          "source": "mesh-core-cst",
          "implementation": "export function mergeValue(a: Value, b: Value): Value {\n  const ma = a.multiasset() ?? new Map();\n  b.multiasset()?.forEach((v, k) => {\n    const newVal = (ma.get(k) ?? 0n) + v;\n    if (newVal == 0n) {\n      ma.delete(k);\n    } else {\n      ma.set(k, newVal);\n    }\n  });\n  return new Value(\n    BigInt(a.coin()) + BigInt(b.coin()),\n    ma.size > 0 ? ma : undefined,\n  );\n}"
        },
        {
          "name": "newVal",
          "signature": "const newVal = (ma.get(k) ?? 0n) + v;",
          "documentation": "",
          "parameters": [
            {
              "name": "ma.get(k",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "any",
          "isPublic": true,
          "line": 6,
          "raw": "    const newVal = (ma.get(k) ?? 0n) + v;\n    if (newVal == 0n) {\n      ma.delete(k);\n    } else {\n      ma.set(k, newVal);\n    }",
          "source": "mesh-core-cst",
          "implementation": "    const newVal = (ma.get(k) ?? 0n) + v;\n    if (newVal == 0n) {\n      ma.delete(k);\n    } else {\n      ma.set(k, newVal);\n    }"
        },
        {
          "name": "negateValue",
          "signature": "export function negateValue(v: Value): Value {",
          "documentation": "",
          "parameters": [
            {
              "name": "v",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "Value",
          "isPublic": true,
          "line": 19,
          "raw": "export function negateValue(v: Value): Value {\n  const entries = v.multiasset()?.entries();\n  const tokenMap: TokenMap = new Map();\n  if (entries) {\n    for (const entry of entries) {\n      tokenMap.set(entry[0], -entry[1]);\n    }\n  }\n  return new Value(-v.coin(), tokenMap);\n}",
          "source": "mesh-core-cst",
          "implementation": "export function negateValue(v: Value): Value {\n  const entries = v.multiasset()?.entries();\n  const tokenMap: TokenMap = new Map();\n  if (entries) {\n    for (const entry of entries) {\n      tokenMap.set(entry[0], -entry[1]);\n    }\n  }\n  return new Value(-v.coin(), tokenMap);\n}"
        },
        {
          "name": "subValue",
          "signature": "export function subValue(a: Value, b: Value): Value {",
          "documentation": "",
          "parameters": [
            {
              "name": "a",
              "type": "Value",
              "optional": false
            },
            {
              "name": "b",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "Value",
          "isPublic": true,
          "line": 30,
          "raw": "export function subValue(a: Value, b: Value): Value {\n  return mergeValue(a, negateValue(b));\n}",
          "source": "mesh-core-cst",
          "implementation": "export function subValue(a: Value, b: Value): Value {\n  return mergeValue(a, negateValue(b));\n}"
        },
        {
          "name": "negatives",
          "signature": "export function negatives(v: Value): Value {",
          "documentation": "",
          "parameters": [
            {
              "name": "v",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "Value",
          "isPublic": true,
          "line": 34,
          "raw": "export function negatives(v: Value): Value {\n  const entries = v.multiasset()?.entries();\n  const coin = v.coin() < 0n ? v.coin() : 0n;\n  const tokenMap: TokenMap = new Map();\n  if (entries) {\n    for (const entry of entries) {\n      if (entry[1] < 0n) {\n        tokenMap.set(entry[0], entry[1]);\n      }\n    }\n  }\n  return new Value(coin, tokenMap);\n}",
          "source": "mesh-core-cst",
          "implementation": "export function negatives(v: Value): Value {\n  const entries = v.multiasset()?.entries();\n  const coin = v.coin() < 0n ? v.coin() : 0n;\n  const tokenMap: TokenMap = new Map();\n  if (entries) {\n    for (const entry of entries) {\n      if (entry[1] < 0n) {\n        tokenMap.set(entry[0], entry[1]);\n      }\n    }\n  }\n  return new Value(coin, tokenMap);\n}"
        },
        {
          "name": "assetTypes",
          "signature": "export function assetTypes(v: Value): number {",
          "documentation": "",
          "parameters": [
            {
              "name": "v",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "number",
          "isPublic": true,
          "line": 48,
          "raw": "export function assetTypes(v: Value): number {\n  let count = v.coin() == 0n ? 0 : 1;\n  const entries = v.multiasset();\n  if (entries) {\n    entries.forEach(() => {\n      count += 1;\n    });\n  }\n  return count;\n}",
          "source": "mesh-core-cst",
          "implementation": "export function assetTypes(v: Value): number {\n  let count = v.coin() == 0n ? 0 : 1;\n  const entries = v.multiasset();\n  if (entries) {\n    entries.forEach(() => {\n      count += 1;\n    });\n  }\n  return count;\n}"
        },
        {
          "name": "empty",
          "signature": "export function empty(v: Value): boolean {",
          "documentation": "",
          "parameters": [
            {
              "name": "v",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "boolean",
          "isPublic": true,
          "line": 59,
          "raw": "export function empty(v: Value): boolean {\n  return assetTypes(v) == 0;\n}",
          "source": "mesh-core-cst",
          "implementation": "export function empty(v: Value): boolean {\n  return assetTypes(v) == 0;\n}"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "ma",
          "type": "any",
          "value": "a.multiasset() ?? new Map();",
          "isPublic": true,
          "line": 4,
          "raw": "const ma = a.multiasset() ?? new Map();",
          "source": "mesh-core-cst"
        },
        {
          "name": "newVal",
          "type": "any",
          "value": "(ma.get(k) ?? 0n) + v;",
          "isPublic": true,
          "line": 6,
          "raw": "const newVal = (ma.get(k) ?? 0n) + v;",
          "source": "mesh-core-cst"
        },
        {
          "name": "entries",
          "type": "any",
          "value": "v.multiasset()?.entries();",
          "isPublic": true,
          "line": 20,
          "raw": "const entries = v.multiasset()?.entries();",
          "source": "mesh-core-cst"
        },
        {
          "name": "tokenMap",
          "type": "TokenMap",
          "value": "new Map();",
          "isPublic": true,
          "line": 21,
          "raw": "const tokenMap: TokenMap = new Map();",
          "source": "mesh-core-cst"
        },
        {
          "name": "entries",
          "type": "any",
          "value": "v.multiasset()?.entries();",
          "isPublic": true,
          "line": 35,
          "raw": "const entries = v.multiasset()?.entries();",
          "source": "mesh-core-cst"
        },
        {
          "name": "coin",
          "type": "any",
          "value": "v.coin() < 0n ? v.coin() : 0n;",
          "isPublic": true,
          "line": 36,
          "raw": "const coin = v.coin() < 0n ? v.coin() : 0n;",
          "source": "mesh-core-cst"
        },
        {
          "name": "tokenMap",
          "type": "TokenMap",
          "value": "new Map();",
          "isPublic": true,
          "line": 37,
          "raw": "const tokenMap: TokenMap = new Map();",
          "source": "mesh-core-cst"
        },
        {
          "name": "entries",
          "type": "any",
          "value": "v.multiasset();",
          "isPublic": true,
          "line": 50,
          "raw": "const entries = v.multiasset();",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { TokenMap, Value } from \"../types\";\n\nexport function mergeValue(a: Value, b: Value): Value {\n  const ma = a.multiasset() ?? new Map();\n  b.multiasset()?.forEach((v, k) => {\n    const newVal = (ma.get(k) ?? 0n) + v;\n    if (newVal == 0n) {\n      ma.delete(k);\n    } else {\n      ma.set(k, newVal);\n    }\n  });\n  return new Value(\n    BigInt(a.coin()) + BigInt(b.coin()),\n    ma.size > 0 ? ma : undefined,\n  );\n}\n\nexport function negateValue(v: Value): Value {\n  const entries = v.multiasset()?.entries();\n  const tokenMap: TokenMap = new Map();\n  if (entries) {\n    for (const entry of entries) {\n      tokenMap.set(entry[0], -entry[1]);\n    }\n  }\n  return new Value(-v.coin(), tokenMap);\n}\n\nexport function subValue(a: Value, b: Value): Value {\n  return mergeValue(a, negateValue(b));\n}\n\nexport function negatives(v: Value): Value {\n  const entries = v.multiasset()?.entries();\n  const coin = v.coin() < 0n ? v.coin() : 0n;\n  const tokenMap: TokenMap = new Map();\n  if (entries) {\n    for (const entry of entries) {\n      if (entry[1] < 0n) {\n        tokenMap.set(entry[0], entry[1]);\n      }\n    }\n  }\n  return new Value(coin, tokenMap);\n}\n\nexport function assetTypes(v: Value): number {\n  let count = v.coin() == 0n ? 0 : 1;\n  const entries = v.multiasset();\n  if (entries) {\n    entries.forEach(() => {\n      count += 1;\n    });\n  }\n  return count;\n}\n\nexport function empty(v: Value): boolean {\n  return assetTypes(v) == 0;\n}\n",
      "dependencies": [
        "mergeValue",
        "negateValue",
        "subValue",
        "negatives",
        "assetTypes",
        "empty"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:utils.vote.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/utils/vote.ts",
      "name": "utils.vote.ts",
      "imports": [
        {
          "module": "toCardanoVoter",
          "items": [],
          "line": 18,
          "raw": "export const toCardanoVoter = (voter: Voter): Serialization.Voter => {",
          "source": "mesh-core-cst"
        },
        {
          "module": "toCardanoVotingProcedure",
          "items": [],
          "line": 60,
          "raw": "export const toCardanoVotingProcedure = (",
          "source": "mesh-core-cst"
        },
        {
          "module": "toCardanoGovernanceActionId",
          "items": [],
          "line": 92,
          "raw": "export const toCardanoGovernanceActionId = (",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "toCardanoVoter",
          "signature": "export const toCardanoVoter = (voter: Voter): Serialization.Voter => {",
          "documentation": "",
          "parameters": [
            {
              "name": "voter",
              "type": "Voter",
              "optional": false
            }
          ],
          "returnType": "Serialization.Voter",
          "isPublic": true,
          "line": 18,
          "raw": "export const toCardanoVoter = (voter: Voter): Serialization.Voter => {\n  switch (voter.type) {\n    case \"ConstitutionalCommittee\": {\n      switch (voter.hotCred.type) {\n        case \"KeyHash\": {\n          return Serialization.Voter.newConstitutionalCommitteeHotKey({\n            type: 0,\n            hash: Hash28ByteBase16(voter.hotCred.keyHash),\n          });\n        }\n        case \"ScriptHash\": {\n          return Serialization.Voter.newConstitutionalCommitteeHotKey({\n            type: 1,\n            hash: Hash28ByteBase16(voter.hotCred.scriptHash),\n          });\n        }\n      }\n    }\n    case \"DRep\": {\n      const cardanoDrep = toDRep(voter.drepId);\n      if (cardanoDrep.toKeyHash() !== undefined) {\n        return Serialization.Voter.newDrep({\n          type: 0,\n          hash: Hash28ByteBase16(cardanoDrep.toKeyHash()!),\n        });\n      } else if (cardanoDrep.toScriptHash() !== undefined) {\n        return Serialization.Voter.newDrep({\n          type: 1,\n          hash: Hash28ByteBase16(cardanoDrep.toScriptHash()!),\n        });\n      } else {\n        throw new Error(\"Invalid DRep provided\");\n      }\n    }\n    case \"StakingPool\": {\n      return Serialization.Voter.newStakingPool(\n        Ed25519KeyHashHex(voter.keyHash),\n      );\n    }\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "export const toCardanoVoter = (voter: Voter): Serialization.Voter => {\n  switch (voter.type) {\n    case \"ConstitutionalCommittee\": {\n      switch (voter.hotCred.type) {\n        case \"KeyHash\": {\n          return Serialization.Voter.newConstitutionalCommitteeHotKey({\n            type: 0,\n            hash: Hash28ByteBase16(voter.hotCred.keyHash),\n          });\n        }\n        case \"ScriptHash\": {\n          return Serialization.Voter.newConstitutionalCommitteeHotKey({\n            type: 1,\n            hash: Hash28ByteBase16(voter.hotCred.scriptHash),\n          });\n        }\n      }\n    }\n    case \"DRep\": {\n      const cardanoDrep = toDRep(voter.drepId);\n      if (cardanoDrep.toKeyHash() !== undefined) {\n        return Serialization.Voter.newDrep({\n          type: 0,\n          hash: Hash28ByteBase16(cardanoDrep.toKeyHash()!),\n        });\n      } else if (cardanoDrep.toScriptHash() !== undefined) {\n        return Serialization.Voter.newDrep({\n          type: 1,\n          hash: Hash28ByteBase16(cardanoDrep.toScriptHash()!),\n        });\n      } else {\n        throw new Error(\"Invalid DRep provided\");\n      }\n    }\n    case \"StakingPool\": {\n      return Serialization.Voter.newStakingPool(\n        Ed25519KeyHashHex(voter.keyHash),\n      );\n    }\n  }\n};"
        },
        {
          "name": "toCardanoVotingProcedure",
          "signature": "export const toCardanoVotingProcedure = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 60,
          "raw": "export const toCardanoVotingProcedure = (\n  votingProcedure: VotingProcedure,\n): Serialization.VotingProcedure => {\n  return new Serialization.VotingProcedure(\n    toCardanoVoteKind(votingProcedure.voteKind),\n    votingProcedure.anchor\n      ? toCardanoAnchor(votingProcedure.anchor)\n      : undefined,\n  );\n};",
          "source": "mesh-core-cst",
          "implementation": "export const toCardanoVotingProcedure = (\n  votingProcedure: VotingProcedure,\n): Serialization.VotingProcedure => {\n  return new Serialization.VotingProcedure(\n    toCardanoVoteKind(votingProcedure.voteKind),\n    votingProcedure.anchor\n      ? toCardanoAnchor(votingProcedure.anchor)\n      : undefined,\n  );\n};"
        },
        {
          "name": "toCardanoAnchor",
          "signature": "const toCardanoAnchor = (anchor: Anchor): Serialization.Anchor => {",
          "documentation": "",
          "parameters": [
            {
              "name": "anchor",
              "type": "Anchor",
              "optional": false
            }
          ],
          "returnType": "Serialization.Anchor",
          "isPublic": true,
          "line": 71,
          "raw": "const toCardanoAnchor = (anchor: Anchor): Serialization.Anchor => {\n  return new Serialization.Anchor(\n    anchor.anchorUrl,\n    Hash32ByteBase16(anchor.anchorDataHash),\n  );\n};",
          "source": "mesh-core-cst",
          "implementation": "const toCardanoAnchor = (anchor: Anchor): Serialization.Anchor => {\n  return new Serialization.Anchor(\n    anchor.anchorUrl,\n    Hash32ByteBase16(anchor.anchorDataHash),\n  );\n};"
        },
        {
          "name": "toCardanoVoteKind",
          "signature": "const toCardanoVoteKind = (voteType: VoteKind): Cardano.Vote => {",
          "documentation": "",
          "parameters": [
            {
              "name": "voteType",
              "type": "VoteKind",
              "optional": false
            }
          ],
          "returnType": "Cardano.Vote",
          "isPublic": true,
          "line": 78,
          "raw": "const toCardanoVoteKind = (voteType: VoteKind): Cardano.Vote => {\n  switch (voteType) {\n    case \"Yes\": {\n      return 1;\n    }\n    case \"No\": {\n      return 0;\n    }\n    case \"Abstain\": {\n      return 2;\n    }\n  }\n};",
          "source": "mesh-core-cst",
          "implementation": "const toCardanoVoteKind = (voteType: VoteKind): Cardano.Vote => {\n  switch (voteType) {\n    case \"Yes\": {\n      return 1;\n    }\n    case \"No\": {\n      return 0;\n    }\n    case \"Abstain\": {\n      return 2;\n    }\n  }\n};"
        },
        {
          "name": "toCardanoGovernanceActionId",
          "signature": "export const toCardanoGovernanceActionId = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 92,
          "raw": "export const toCardanoGovernanceActionId = (\n  govActionId: RefTxIn,\n): Serialization.GovernanceActionId => {\n  return new Serialization.GovernanceActionId(\n    Cardano.TransactionId(govActionId.txHash),\n    BigInt(govActionId.txIndex),\n  );\n};",
          "source": "mesh-core-cst",
          "implementation": "export const toCardanoGovernanceActionId = (\n  govActionId: RefTxIn,\n): Serialization.GovernanceActionId => {\n  return new Serialization.GovernanceActionId(\n    Cardano.TransactionId(govActionId.txHash),\n    BigInt(govActionId.txIndex),\n  );\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "toCardanoVoter",
          "type": "any",
          "value": "(voter: Voter): Serialization.Voter => {",
          "isPublic": true,
          "line": 18,
          "raw": "export const toCardanoVoter = (voter: Voter): Serialization.Voter => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "cardanoDrep",
          "type": "any",
          "value": "toDRep(voter.drepId);",
          "isPublic": true,
          "line": 37,
          "raw": "const cardanoDrep = toDRep(voter.drepId);",
          "source": "mesh-core-cst"
        },
        {
          "name": "toCardanoVotingProcedure",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 60,
          "raw": "export const toCardanoVotingProcedure = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "toCardanoAnchor",
          "type": "any",
          "value": "(anchor: Anchor): Serialization.Anchor => {",
          "isPublic": true,
          "line": 71,
          "raw": "const toCardanoAnchor = (anchor: Anchor): Serialization.Anchor => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "toCardanoVoteKind",
          "type": "any",
          "value": "(voteType: VoteKind): Cardano.Vote => {",
          "isPublic": true,
          "line": 78,
          "raw": "const toCardanoVoteKind = (voteType: VoteKind): Cardano.Vote => {",
          "source": "mesh-core-cst"
        },
        {
          "name": "toCardanoGovernanceActionId",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 92,
          "raw": "export const toCardanoGovernanceActionId = (",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { Cardano, Serialization } from \"@cardano-sdk/core\";\n\nimport {\n  Anchor,\n  RefTxIn,\n  VoteKind,\n  Voter,\n  VotingProcedure,\n} from \"@meshsdk/common\";\n\nimport {\n  Ed25519KeyHashHex,\n  Hash28ByteBase16,\n  Hash32ByteBase16,\n} from \"../types\";\nimport { toDRep } from \"./converter\";\n\nexport const toCardanoVoter = (voter: Voter): Serialization.Voter => {\n  switch (voter.type) {\n    case \"ConstitutionalCommittee\": {\n      switch (voter.hotCred.type) {\n        case \"KeyHash\": {\n          return Serialization.Voter.newConstitutionalCommitteeHotKey({\n            type: 0,\n            hash: Hash28ByteBase16(voter.hotCred.keyHash),\n          });\n        }\n        case \"ScriptHash\": {\n          return Serialization.Voter.newConstitutionalCommitteeHotKey({\n            type: 1,\n            hash: Hash28ByteBase16(voter.hotCred.scriptHash),\n          });\n        }\n      }\n    }\n    case \"DRep\": {\n      const cardanoDrep = toDRep(voter.drepId);\n      if (cardanoDrep.toKeyHash() !== undefined) {\n        return Serialization.Voter.newDrep({\n          type: 0,\n          hash: Hash28ByteBase16(cardanoDrep.toKeyHash()!),\n        });\n      } else if (cardanoDrep.toScriptHash() !== undefined) {\n        return Serialization.Voter.newDrep({\n          type: 1,\n          hash: Hash28ByteBase16(cardanoDrep.toScriptHash()!),\n        });\n      } else {\n        throw new Error(\"Invalid DRep provided\");\n      }\n    }\n    case \"StakingPool\": {\n      return Serialization.Voter.newStakingPool(\n        Ed25519KeyHashHex(voter.keyHash),\n      );\n    }\n  }\n};\n\nexport const toCardanoVotingProcedure = (\n  votingProcedure: VotingProcedure,\n): Serialization.VotingProcedure => {\n  return new Serialization.VotingProcedure(\n    toCardanoVoteKind(votingProcedure.voteKind),\n    votingProcedure.anchor\n      ? toCardanoAnchor(votingProcedure.anchor)\n      : undefined,\n  );\n};\n\nconst toCardanoAnchor = (anchor: Anchor): Serialization.Anchor => {\n  return new Serialization.Anchor(\n    anchor.anchorUrl,\n    Hash32ByteBase16(anchor.anchorDataHash),\n  );\n};\n\nconst toCardanoVoteKind = (voteType: VoteKind): Cardano.Vote => {\n  switch (voteType) {\n    case \"Yes\": {\n      return 1;\n    }\n    case \"No\": {\n      return 0;\n    }\n    case \"Abstain\": {\n      return 2;\n    }\n  }\n};\n\nexport const toCardanoGovernanceActionId = (\n  govActionId: RefTxIn,\n): Serialization.GovernanceActionId => {\n  return new Serialization.GovernanceActionId(\n    Cardano.TransactionId(govActionId.txHash),\n    BigInt(govActionId.txIndex),\n  );\n};\n",
      "dependencies": [
        "toCardanoVoter",
        "toCardanoVotingProcedure",
        "toCardanoGovernanceActionId"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "mesh-core-cst:utils.witness-set.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/utils/witness-set.ts",
      "name": "utils.witness-set.ts",
      "imports": [
        {
          "module": "addVKeyWitnessSetToTransaction",
          "items": [],
          "line": 10,
          "raw": "export const addVKeyWitnessSetToTransaction = (",
          "source": "mesh-core-cst"
        }
      ],
      "functions": [
        {
          "name": "addVKeyWitnessSetToTransaction",
          "signature": "export const addVKeyWitnessSetToTransaction = (",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 10,
          "raw": "export const addVKeyWitnessSetToTransaction = (\n  txHex: string,\n  vkeyWitnessSet: string,\n): string => {\n  const tx = Transaction.fromCbor(TxCBOR(txHex));\n  const currentWitnessSet = tx.witnessSet();\n  const newVkeyWitnessSet = TransactionWitnessSet.fromCbor(\n    HexBlob(vkeyWitnessSet),\n  );\n\n  const currentVkeyWitnesses = currentWitnessSet.vkeys();\n  const newVkeyWitnesses = newVkeyWitnessSet.vkeys();\n  const allVkeyWitnesses = [\n    ...(currentVkeyWitnesses?.values() ?? []),\n    ...(newVkeyWitnesses?.values() ?? []),\n  ];\n\n  currentWitnessSet.setVkeys(\n    CborSet.fromCore(\n      allVkeyWitnesses.map((vkw) => vkw.toCore()),\n      VkeyWitness.fromCore,\n    ),\n  );\n  tx.setWitnessSet(currentWitnessSet);\n  return tx.toCbor();\n};",
          "source": "mesh-core-cst",
          "implementation": "export const addVKeyWitnessSetToTransaction = (\n  txHex: string,\n  vkeyWitnessSet: string,\n): string => {\n  const tx = Transaction.fromCbor(TxCBOR(txHex));\n  const currentWitnessSet = tx.witnessSet();\n  const newVkeyWitnessSet = TransactionWitnessSet.fromCbor(\n    HexBlob(vkeyWitnessSet),\n  );\n\n  const currentVkeyWitnesses = currentWitnessSet.vkeys();\n  const newVkeyWitnesses = newVkeyWitnessSet.vkeys();\n  const allVkeyWitnesses = [\n    ...(currentVkeyWitnesses?.values() ?? []),\n    ...(newVkeyWitnesses?.values() ?? []),\n  ];\n\n  currentWitnessSet.setVkeys(\n    CborSet.fromCore(\n      allVkeyWitnesses.map((vkw) => vkw.toCore()),\n      VkeyWitness.fromCore,\n    ),\n  );\n  tx.setWitnessSet(currentWitnessSet);\n  return tx.toCbor();\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "addVKeyWitnessSetToTransaction",
          "type": "any",
          "value": "(",
          "isPublic": true,
          "line": 10,
          "raw": "export const addVKeyWitnessSetToTransaction = (",
          "source": "mesh-core-cst"
        },
        {
          "name": "tx",
          "type": "any",
          "value": "Transaction.fromCbor(TxCBOR(txHex));",
          "isPublic": true,
          "line": 14,
          "raw": "const tx = Transaction.fromCbor(TxCBOR(txHex));",
          "source": "mesh-core-cst"
        },
        {
          "name": "currentWitnessSet",
          "type": "any",
          "value": "tx.witnessSet();",
          "isPublic": true,
          "line": 15,
          "raw": "const currentWitnessSet = tx.witnessSet();",
          "source": "mesh-core-cst"
        },
        {
          "name": "newVkeyWitnessSet",
          "type": "any",
          "value": "TransactionWitnessSet.fromCbor(",
          "isPublic": true,
          "line": 16,
          "raw": "const newVkeyWitnessSet = TransactionWitnessSet.fromCbor(",
          "source": "mesh-core-cst"
        },
        {
          "name": "currentVkeyWitnesses",
          "type": "any",
          "value": "currentWitnessSet.vkeys();",
          "isPublic": true,
          "line": 20,
          "raw": "const currentVkeyWitnesses = currentWitnessSet.vkeys();",
          "source": "mesh-core-cst"
        },
        {
          "name": "newVkeyWitnesses",
          "type": "any",
          "value": "newVkeyWitnessSet.vkeys();",
          "isPublic": true,
          "line": 21,
          "raw": "const newVkeyWitnesses = newVkeyWitnessSet.vkeys();",
          "source": "mesh-core-cst"
        },
        {
          "name": "allVkeyWitnesses",
          "type": "any",
          "value": "[",
          "isPublic": true,
          "line": 22,
          "raw": "const allVkeyWitnesses = [",
          "source": "mesh-core-cst"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import {\n  CborSet,\n  HexBlob,\n  Transaction,\n  TransactionWitnessSet,\n  TxCBOR,\n  VkeyWitness,\n} from \"../types\";\n\nexport const addVKeyWitnessSetToTransaction = (\n  txHex: string,\n  vkeyWitnessSet: string,\n): string => {\n  const tx = Transaction.fromCbor(TxCBOR(txHex));\n  const currentWitnessSet = tx.witnessSet();\n  const newVkeyWitnessSet = TransactionWitnessSet.fromCbor(\n    HexBlob(vkeyWitnessSet),\n  );\n\n  const currentVkeyWitnesses = currentWitnessSet.vkeys();\n  const newVkeyWitnesses = newVkeyWitnessSet.vkeys();\n  const allVkeyWitnesses = [\n    ...(currentVkeyWitnesses?.values() ?? []),\n    ...(newVkeyWitnesses?.values() ?? []),\n  ];\n\n  currentWitnessSet.setVkeys(\n    CborSet.fromCore(\n      allVkeyWitnesses.map((vkw) => vkw.toCore()),\n      VkeyWitness.fromCore,\n    ),\n  );\n  tx.setWitnessSet(currentWitnessSet);\n  return tx.toCbor();\n};\n",
      "dependencies": [
        "addVKeyWitnessSetToTransaction"
      ],
      "source": "mesh-core-cst",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:core.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/core.ts",
      "name": "core.ts",
      "imports": [
        {
          "module": "bitcoin",
          "items": [],
          "line": 12,
          "raw": "export { bitcoin, ECPair, bip32, bip39 };",
          "source": "bitcoin"
        },
        {
          "module": "ECPair",
          "items": [],
          "line": 12,
          "raw": "export { bitcoin, ECPair, bip32, bip39 };",
          "source": "bitcoin"
        },
        {
          "module": "bip32",
          "items": [],
          "line": 12,
          "raw": "export { bitcoin, ECPair, bip32, bip39 };",
          "source": "bitcoin"
        },
        {
          "module": "bip39",
          "items": [],
          "line": 12,
          "raw": "export { bitcoin, ECPair, bip32, bip39 };",
          "source": "bitcoin"
        }
      ],
      "functions": [],
      "types": [],
      "constants": [
        {
          "name": "bip32",
          "type": "any",
          "value": "BIP32Factory(ecc);",
          "isPublic": true,
          "line": 7,
          "raw": "const bip32 = BIP32Factory(ecc);",
          "source": "bitcoin"
        },
        {
          "name": "ECPair",
          "type": "any",
          "value": "ECPairFactory(ecc);",
          "isPublic": true,
          "line": 8,
          "raw": "const ECPair = ECPairFactory(ecc);",
          "source": "bitcoin"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import * as bitcoin from \"bitcoinjs-lib\";\nimport * as ecc from \"@bitcoin-js/tiny-secp256k1-asmjs\";\nimport * as bip39 from \"bip39\";\nimport { BIP32Factory } from \"bip32\";\nimport { ECPairFactory } from \"ecpair\";\n\nconst bip32 = BIP32Factory(ecc);\nconst ECPair = ECPairFactory(ecc);\n\nbitcoin.initEccLib(ecc);\n\nexport { bitcoin, ECPair, bip32, bip39 };\n",
      "dependencies": [
        "bitcoin",
        "ECPair",
        "bip32",
        "bip39"
      ],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/index.ts",
      "name": "index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./core\";\nexport * from \"./interfaces\";\nexport * from \"./providers\";\nexport * from \"./utils\";\nexport * from \"./types\";\nexport * from \"./wallets\";\n",
      "dependencies": [],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:interfaces.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/interfaces/index.ts",
      "name": "interfaces.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./wallet\";\n",
      "dependencies": [],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:interfaces.provider.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/interfaces/provider.ts",
      "name": "interfaces.provider.ts",
      "imports": [
        {
          "module": "IBitcoinProvider",
          "items": [],
          "line": 7,
          "raw": "export interface IBitcoinProvider {",
          "source": "bitcoin"
        }
      ],
      "functions": [
        {
          "name": "fetchAddress",
          "signature": "fetchAddress(address: string): Promise<AddressInfo>;",
          "documentation": "",
          "parameters": [
            {
              "name": "address",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Promise<AddressInfo>;",
          "isPublic": true,
          "line": 8,
          "raw": "  fetchAddress(address: string): Promise<AddressInfo>;",
          "source": "bitcoin",
          "implementation": "  fetchAddress(address: string): Promise<AddressInfo>;"
        },
        {
          "name": "fetchAddressUTxOs",
          "signature": "fetchAddressUTxOs(address: string): Promise<UTxO[]>;",
          "documentation": "",
          "parameters": [
            {
              "name": "address",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Promise<UTxO[]>;",
          "isPublic": true,
          "line": 13,
          "raw": "  fetchAddressUTxOs(address: string): Promise<UTxO[]>;",
          "source": "bitcoin",
          "implementation": "  fetchAddressUTxOs(address: string): Promise<UTxO[]>;"
        },
        {
          "name": "fetchScript",
          "signature": "fetchScript(hash: string): Promise<ScriptInfo>;",
          "documentation": "",
          "parameters": [
            {
              "name": "hash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Promise<ScriptInfo>;",
          "isPublic": true,
          "line": 14,
          "raw": "  fetchScript(hash: string): Promise<ScriptInfo>;",
          "source": "bitcoin",
          "implementation": "  fetchScript(hash: string): Promise<ScriptInfo>;"
        },
        {
          "name": "fetchScriptUTxOs",
          "signature": "fetchScriptUTxOs(hash: string): Promise<UTxO[]>;",
          "documentation": "",
          "parameters": [
            {
              "name": "hash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Promise<UTxO[]>;",
          "isPublic": true,
          "line": 19,
          "raw": "  fetchScriptUTxOs(hash: string): Promise<UTxO[]>;",
          "source": "bitcoin",
          "implementation": "  fetchScriptUTxOs(hash: string): Promise<UTxO[]>;"
        },
        {
          "name": "fetchTransactionStatus",
          "signature": "fetchTransactionStatus(txid: string): Promise<TransactionsStatus>;",
          "documentation": "",
          "parameters": [
            {
              "name": "txid",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Promise<TransactionsStatus>;",
          "isPublic": true,
          "line": 20,
          "raw": "  fetchTransactionStatus(txid: string): Promise<TransactionsStatus>;",
          "source": "bitcoin",
          "implementation": "  fetchTransactionStatus(txid: string): Promise<TransactionsStatus>;"
        },
        {
          "name": "submitTx",
          "signature": "submitTx(tx: string): Promise<string>;",
          "documentation": "",
          "parameters": [
            {
              "name": "tx",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Promise<string>;",
          "isPublic": true,
          "line": 21,
          "raw": "  submitTx(tx: string): Promise<string>;",
          "source": "bitcoin",
          "implementation": "  submitTx(tx: string): Promise<string>;"
        }
      ],
      "types": [
        {
          "name": "IBitcoinProvider",
          "definition": "export interface IBitcoinProvider {\n  fetchAddress(address: string): Promise<AddressInfo>;",
          "isPublic": true,
          "line": 7,
          "raw": "export interface IBitcoinProvider {",
          "source": "bitcoin"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { UTxO } from \"../types\";\nimport { AddressInfo } from \"../types/address-info\";\nimport { ScriptInfo } from \"../types/script-info\";\nimport { TransactionsInfo } from \"../types/transactions-info\";\nimport { TransactionsStatus } from \"../types/transactions-status\";\n\nexport interface IBitcoinProvider {\n  fetchAddress(address: string): Promise<AddressInfo>;\n  fetchAddressTransactions(\n    address: string,\n    last_seen_txid?: string\n  ): Promise<TransactionsInfo[]>;\n  fetchAddressUTxOs(address: string): Promise<UTxO[]>;\n  fetchScript(hash: string): Promise<ScriptInfo>;\n  fetchScriptTransactions(\n    hash: string,\n    last_seen_txid?: string\n  ): Promise<TransactionsInfo[]>;\n  fetchScriptUTxOs(hash: string): Promise<UTxO[]>;\n  fetchTransactionStatus(txid: string): Promise<TransactionsStatus>;\n  submitTx(tx: string): Promise<string>;\n}\n",
      "dependencies": [
        "IBitcoinProvider"
      ],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:interfaces.wallet.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/interfaces/wallet.ts",
      "name": "interfaces.wallet.ts",
      "imports": [
        {
          "module": "IBitcoinWallet",
          "items": [],
          "line": 1,
          "raw": "export interface IBitcoinWallet {",
          "source": "bitcoin"
        }
      ],
      "functions": [
        {
          "name": "getChangeAddress",
          "signature": "getChangeAddress(): Promise<string>;",
          "documentation": "",
          "parameters": [],
          "returnType": "Promise<string>;",
          "isPublic": true,
          "line": 2,
          "raw": "  getChangeAddress(): Promise<string>;",
          "source": "bitcoin",
          "implementation": "  getChangeAddress(): Promise<string>;"
        },
        {
          "name": "getNetworkId",
          "signature": "getNetworkId(): Promise<0 | 1>;",
          "documentation": "",
          "parameters": [],
          "returnType": "Promise<0 | 1>;",
          "isPublic": true,
          "line": 3,
          "raw": "  getNetworkId(): Promise<0 | 1>;",
          "source": "bitcoin",
          "implementation": "  getNetworkId(): Promise<0 | 1>;"
        },
        {
          "name": "signTx",
          "signature": "signTx(signedTx: string): Promise<string>;",
          "documentation": "",
          "parameters": [
            {
              "name": "signedTx",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Promise<string>;",
          "isPublic": true,
          "line": 4,
          "raw": "  signTx(signedTx: string): Promise<string>;",
          "source": "bitcoin",
          "implementation": "  signTx(signedTx: string): Promise<string>;"
        },
        {
          "name": "submitTx",
          "signature": "submitTx(tx: string): Promise<string>;",
          "documentation": "",
          "parameters": [
            {
              "name": "tx",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Promise<string>;",
          "isPublic": true,
          "line": 5,
          "raw": "  submitTx(tx: string): Promise<string>;",
          "source": "bitcoin",
          "implementation": "  submitTx(tx: string): Promise<string>;"
        }
      ],
      "types": [
        {
          "name": "IBitcoinWallet",
          "definition": "export interface IBitcoinWallet {\n  getChangeAddress(): Promise<string>;",
          "isPublic": true,
          "line": 1,
          "raw": "export interface IBitcoinWallet {",
          "source": "bitcoin"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export interface IBitcoinWallet {\n  getChangeAddress(): Promise<string>;\n  getNetworkId(): Promise<0 | 1>;\n  signTx(signedTx: string): Promise<string>;\n  submitTx(tx: string): Promise<string>;\n}\n",
      "dependencies": [
        "IBitcoinWallet"
      ],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:providers.blockstream.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/providers/blockstream.ts",
      "name": "providers.blockstream.ts",
      "imports": [
        {
          "module": "BlockstreamProvider",
          "items": [],
          "line": 13,
          "raw": "export class BlockstreamProvider implements IBitcoinProvider {",
          "source": "bitcoin"
        }
      ],
      "functions": [],
      "types": [],
      "constants": [
        {
          "name": "url",
          "type": "any",
          "value": "last_seen_txid",
          "isPublic": true,
          "line": 57,
          "raw": "const url = last_seen_txid",
          "source": "bitcoin"
        },
        {
          "name": "url",
          "type": "any",
          "value": "last_seen_txid",
          "isPublic": true,
          "line": 117,
          "raw": "const url = last_seen_txid",
          "source": "bitcoin"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import axios, { AxiosInstance } from \"axios\";\nimport { IBitcoinProvider } from \"../interfaces/provider\";\nimport { UTxO } from \"../types\";\nimport { parseHttpError } from \"./common\";\nimport { AddressInfo } from \"../types/address-info\";\nimport { ScriptInfo } from \"../types/script-info\";\nimport { TransactionsInfo } from \"../types/transactions-info\";\nimport { TransactionsStatus } from \"../types/transactions-status\";\n\n/**\n * https://github.com/Blockstream/esplora/blob/master/API.md\n */\nexport class BlockstreamProvider implements IBitcoinProvider {\n  private readonly _axiosInstance: AxiosInstance;\n\n  constructor(network: \"mainnet\" | \"testnet\" = \"mainnet\") {\n    const baseURL =\n      network === \"testnet\"\n        ? \"https://blockstream.info/testnet/api\"\n        : \"https://blockstream.info/api\";\n\n    this._axiosInstance = axios.create({\n      baseURL,\n    });\n  }\n\n  /**\n   * Get information about an address.\n   * @param address - The address.\n   * @returns AddressInfo\n   */\n  async fetchAddress(address: string): Promise<AddressInfo> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `/address/${address}`\n      );\n\n      if (status === 200) return data as AddressInfo;\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }\n\n  /**\n   * Get transaction history for the specified address, sorted with newest first.\n   * Returns up to 50 mempool transactions plus the first 25 confirmed transactions. You can request more confirmed transactions using `last_seen_txid`.\n   * @param address - The address.\n   * @param last_seen_txid - The last seen transaction ID (optional).\n   * @returns TransactionsInfo[]\n   */\n  async fetchAddressTransactions(\n    address: string,\n    last_seen_txid?: string\n  ): Promise<TransactionsInfo[]> {\n    try {\n      const url = last_seen_txid\n        ? `/address/${address}/txs/chain/${last_seen_txid}`\n        : `/address/${address}/txs`;\n      const { data, status } = await this._axiosInstance.get(url);\n\n      if (status === 200) return data as TransactionsInfo[];\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }\n\n  /**\n   * Get the list of unspent transaction outputs associated with the address.\n   * @param address - The address.\n   * @returns UTxO[]\n   */\n  async fetchAddressUTxOs(address: string): Promise<UTxO[]> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `/address/${address}/utxo`\n      );\n\n      if (status === 200) return data as UTxO[];\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }\n\n  /**\n   * Get information about a scripthash.\n   * @param hash - The hash of the script.\n   * @returns ScriptInfo\n   */\n  async fetchScript(hash: string): Promise<ScriptInfo> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `/scripthash/${hash}`\n      );\n\n      if (status === 200) return data as ScriptInfo;\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }\n\n  /**\n   * Get transaction history for the specified scripthash, sorted with newest first.\n   * Returns up to 50 mempool transactions plus the first 25 confirmed transactions. You can request more confirmed transactions using `last_seen_txid`.\n   * @param hash - The hash of the script.\n   * @param last_seen_txid - The last seen transaction ID (optional).\n   * @returns TransactionsInfo[]\n   */\n  async fetchScriptTransactions(\n    hash: string,\n    last_seen_txid?: string\n  ): Promise<TransactionsInfo[]> {\n    try {\n      const url = last_seen_txid\n        ? `/scripthash/${hash}/txs/chain/${last_seen_txid}`\n        : `/scripthash/${hash}/txs`;\n      const { data, status } = await this._axiosInstance.get(url);\n\n      if (status === 200) return data as TransactionsInfo[];\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }\n\n  /**\n   * Get the list of unspent transaction outputs associated with the scripthash.\n   * @param hash - The hash of the script.\n   * @returns UTxO[]\n   */\n  async fetchScriptUTxOs(hash: string): Promise<UTxO[]> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `/scripthash/${hash}/utxo`\n      );\n\n      if (status === 200) return data as UTxO[];\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }\n\n  /**\n   * Fetches the status of a transaction\n   * @param txid - The transaction ID.\n   * @returns TransactionsStatus\n   */\n  async fetchTransactionStatus(txid: string): Promise<TransactionsStatus> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `/tx/${txid}/status`\n      );\n\n      if (status === 200) return data as TransactionsStatus;\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }\n\n  /**\n   * Broadcast a raw transaction to the network.\n   * The transaction should be provided as hex in the request body. The txid will be returned on success.\n   * @param tx - The transaction in hex format.\n   * @returns The transaction ID.\n   */\n  async submitTx(tx: string): Promise<string> {\n    try {\n      const { data, status } = await this._axiosInstance.post(\"/tx\", tx, {\n        headers: { \"Content-Type\": \"text/plain\" },\n      });\n\n      if (status === 200) return data as string;\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }\n}\n",
      "dependencies": [
        "BlockstreamProvider"
      ],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:providers.common.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/providers/common.ts",
      "name": "providers.common.ts",
      "imports": [
        {
          "module": "parseHttpError",
          "items": [],
          "line": 3,
          "raw": "export const parseHttpError = (error: unknown): string => {",
          "source": "bitcoin"
        }
      ],
      "functions": [
        {
          "name": "parseHttpError",
          "signature": "export const parseHttpError = (error: unknown): string => {",
          "documentation": "",
          "parameters": [
            {
              "name": "error",
              "type": "unknown",
              "optional": false
            }
          ],
          "returnType": "string",
          "isPublic": true,
          "line": 3,
          "raw": "export const parseHttpError = (error: unknown): string => {\n  if (!axios.isAxiosError(error)) {\n    return JSON.stringify(error);\n  }\n\n  if (error.response) {\n    return JSON.stringify({\n      data: error.response.data,\n      headers: error.response.headers,\n      status: error.response.status,\n    });\n  }\n\n  if (error.request && !(error.request instanceof XMLHttpRequest)) {\n    return JSON.stringify(error.request);\n  }\n\n  return JSON.stringify({ code: error.code, message: error.message });\n};",
          "source": "bitcoin",
          "implementation": "export const parseHttpError = (error: unknown): string => {\n  if (!axios.isAxiosError(error)) {\n    return JSON.stringify(error);\n  }\n\n  if (error.response) {\n    return JSON.stringify({\n      data: error.response.data,\n      headers: error.response.headers,\n      status: error.response.status,\n    });\n  }\n\n  if (error.request && !(error.request instanceof XMLHttpRequest)) {\n    return JSON.stringify(error.request);\n  }\n\n  return JSON.stringify({ code: error.code, message: error.message });\n};"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "parseHttpError",
          "type": "any",
          "value": "(error: unknown): string => {",
          "isPublic": true,
          "line": 3,
          "raw": "export const parseHttpError = (error: unknown): string => {",
          "source": "bitcoin"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import axios from \"axios\";\n\nexport const parseHttpError = (error: unknown): string => {\n  if (!axios.isAxiosError(error)) {\n    return JSON.stringify(error);\n  }\n\n  if (error.response) {\n    return JSON.stringify({\n      data: error.response.data,\n      headers: error.response.headers,\n      status: error.response.status,\n    });\n  }\n\n  if (error.request && !(error.request instanceof XMLHttpRequest)) {\n    return JSON.stringify(error.request);\n  }\n\n  return JSON.stringify({ code: error.code, message: error.message });\n};\n",
      "dependencies": [
        "parseHttpError"
      ],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:providers.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/providers/index.ts",
      "name": "providers.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./blockstream\";\n",
      "dependencies": [],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:types.address-info.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/address-info.ts",
      "name": "types.address-info.ts",
      "imports": [
        {
          "module": "AddressInfo",
          "items": [],
          "line": 4,
          "raw": "export type AddressInfo = {",
          "source": "bitcoin"
        }
      ],
      "functions": [],
      "types": [
        {
          "name": "AddressInfo",
          "definition": "export type AddressInfo = {\n  address: string;\n  chain_stats: ChainStats;",
          "isPublic": true,
          "line": 4,
          "raw": "export type AddressInfo = {",
          "source": "bitcoin"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { ChainStats } from \"./chain-stats\";\nimport { MempoolStats } from \"./mempool-stats\";\n\nexport type AddressInfo = {\n  address: string;\n  chain_stats: ChainStats;\n  mempool_stats: MempoolStats;\n};\n",
      "dependencies": [
        "AddressInfo"
      ],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:types.address.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/address.ts",
      "name": "types.address.ts",
      "imports": [
        {
          "module": "Address",
          "items": [],
          "line": 1,
          "raw": "export type Address = {",
          "source": "bitcoin"
        }
      ],
      "functions": [],
      "types": [
        {
          "name": "Address",
          "definition": "export type Address = {\n  address: string;\n  publicKey?: string;",
          "isPublic": true,
          "line": 1,
          "raw": "export type Address = {",
          "source": "bitcoin"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export type Address = {\n  address: string;\n  publicKey?: string;\n  purpose: \"payment\" | \"ordinals\" | \"stacks\";\n  addressType: \"p2tr\" | \"p2wpkh\" | \"p2sh\" | \"stacks\";\n}",
      "dependencies": [
        "Address"
      ],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:types.chain-stats.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/chain-stats.ts",
      "name": "types.chain-stats.ts",
      "imports": [
        {
          "module": "ChainStats",
          "items": [],
          "line": 1,
          "raw": "export type ChainStats = {",
          "source": "bitcoin"
        }
      ],
      "functions": [],
      "types": [
        {
          "name": "ChainStats",
          "definition": "export type ChainStats = {\n  funded_txo_count: number;\n  funded_txo_sum: number;",
          "isPublic": true,
          "line": 1,
          "raw": "export type ChainStats = {",
          "source": "bitcoin"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export type ChainStats = {\n  funded_txo_count: number;\n  funded_txo_sum: number;\n  spent_txo_count: number;\n  spent_txo_sum: number;\n  tx_count: number;\n};\n",
      "dependencies": [
        "ChainStats"
      ],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:types.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/index.ts",
      "name": "types.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from './address';\nexport * from './utxo';",
      "dependencies": [],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:types.mempool-stats.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/mempool-stats.ts",
      "name": "types.mempool-stats.ts",
      "imports": [
        {
          "module": "MempoolStats",
          "items": [],
          "line": 1,
          "raw": "export type MempoolStats = {",
          "source": "bitcoin"
        }
      ],
      "functions": [],
      "types": [
        {
          "name": "MempoolStats",
          "definition": "export type MempoolStats = {\n  funded_txo_count: number;\n  funded_txo_sum: number;",
          "isPublic": true,
          "line": 1,
          "raw": "export type MempoolStats = {",
          "source": "bitcoin"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export type MempoolStats = {\n  funded_txo_count: number;\n  funded_txo_sum: number;\n  spent_txo_count: number;\n  spent_txo_sum: number;\n  tx_count: number;\n};\n",
      "dependencies": [
        "MempoolStats"
      ],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:types.script-info.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/script-info.ts",
      "name": "types.script-info.ts",
      "imports": [
        {
          "module": "ScriptInfo",
          "items": [],
          "line": 4,
          "raw": "export type ScriptInfo = {",
          "source": "bitcoin"
        }
      ],
      "functions": [],
      "types": [
        {
          "name": "ScriptInfo",
          "definition": "export type ScriptInfo = {\n  scripthash: string;\n  chain_stats: ChainStats;",
          "isPublic": true,
          "line": 4,
          "raw": "export type ScriptInfo = {",
          "source": "bitcoin"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { ChainStats } from \"./chain-stats\";\nimport { MempoolStats } from \"./mempool-stats\";\n\nexport type ScriptInfo = {\n  scripthash: string;\n  chain_stats: ChainStats;\n  mempool_stats: MempoolStats;\n};\n",
      "dependencies": [
        "ScriptInfo"
      ],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:types.transactions-info.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/transactions-info.ts",
      "name": "types.transactions-info.ts",
      "imports": [
        {
          "module": "TransactionsInfo",
          "items": [],
          "line": 3,
          "raw": "export type TransactionsInfo = {",
          "source": "bitcoin"
        }
      ],
      "functions": [],
      "types": [
        {
          "name": "TransactionsInfo",
          "definition": "export type TransactionsInfo = {\n  txid: string;\n  version: number;",
          "isPublic": true,
          "line": 3,
          "raw": "export type TransactionsInfo = {",
          "source": "bitcoin"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { TransactionsStatus } from \"./transactions-status\";\n\nexport type TransactionsInfo = {\n  txid: string;\n  version: number;\n  locktime: number;\n  vin: {\n    txid: string;\n    vout: number;\n    prevout: {\n      scriptpubkey: string;\n      scriptpubkey_asm: string;\n      scriptpubkey_type: string;\n      scriptpubkey_address: string;\n      value: number;\n    };\n    scriptsig: string;\n    scriptsig_asm: string;\n    witness: string[];\n    is_coinbase: boolean;\n    sequence: number;\n  }[];\n  vout: {\n    scriptpubkey: string;\n    scriptpubkey_asm: string;\n    scriptpubkey_type: string;\n    scriptpubkey_address: string;\n    value: number;\n  }[];\n  size: number;\n  weight: number;\n  fee: number;\n  status: TransactionsStatus;\n};\n",
      "dependencies": [
        "TransactionsInfo"
      ],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:types.transactions-status.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/transactions-status.ts",
      "name": "types.transactions-status.ts",
      "imports": [
        {
          "module": "TransactionsStatus",
          "items": [],
          "line": 1,
          "raw": "export type TransactionsStatus = {",
          "source": "bitcoin"
        }
      ],
      "functions": [],
      "types": [
        {
          "name": "TransactionsStatus",
          "definition": "export type TransactionsStatus = {\n  confirmed: boolean;\n  block_height: number;",
          "isPublic": true,
          "line": 1,
          "raw": "export type TransactionsStatus = {",
          "source": "bitcoin"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export type TransactionsStatus = {\n  confirmed: boolean;\n  block_height: number;\n  block_hash: string;\n  block_time: number;\n};\n",
      "dependencies": [
        "TransactionsStatus"
      ],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:types.utxo.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/utxo.ts",
      "name": "types.utxo.ts",
      "imports": [
        {
          "module": "UTxO",
          "items": [],
          "line": 1,
          "raw": "export type UTxO = {",
          "source": "bitcoin"
        }
      ],
      "functions": [],
      "types": [
        {
          "name": "UTxO",
          "definition": "export type UTxO = {\n  status: {\n    block_hash: string;\n    block_height: number;\n    block_time: number;",
          "isPublic": true,
          "line": 1,
          "raw": "export type UTxO = {",
          "source": "bitcoin"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export type UTxO = {\n  status: {\n    block_hash: string;\n    block_height: number;\n    block_time: number;\n    confirmed: boolean;\n  };\n  txid: string;\n  value: number;\n  vout: number;\n};\n",
      "dependencies": [
        "UTxO"
      ],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:utils.address.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/utils/address.ts",
      "name": "utils.address.ts",
      "imports": [
        {
          "module": "resolveAddress",
          "items": [],
          "line": 4,
          "raw": "export function resolveAddress(",
          "source": "bitcoin"
        }
      ],
      "functions": [
        {
          "name": "resolveAddress",
          "signature": "export function resolveAddress(",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 4,
          "raw": "export function resolveAddress(\n  publicKey: string | Buffer,\n  network: \"mainnet\" | \"testnet\" | bitcoin.networks.Network\n): Address {\n  const p2wpkh = bitcoin.payments.p2wpkh({\n    pubkey:\n      typeof publicKey === \"string\" ? Buffer.from(publicKey, \"hex\") : publicKey,\n    network:\n      network === \"mainnet\"\n        ? bitcoin.networks.bitcoin\n        : network === \"testnet\"\n          ? bitcoin.networks.testnet\n          : network,\n  });\n\n  if (!p2wpkh?.address) {\n    throw new Error(\"Address is not initialized.\");\n  }\n\n  const pubKeyHex = Buffer.isBuffer(publicKey)\n    ? publicKey.toString(\"hex\")\n    : publicKey;\n\n  return {\n    address: p2wpkh.address,\n    publicKey: pubKeyHex,\n    purpose: \"payment\",\n    addressType: \"p2wpkh\",\n  };\n}",
          "source": "bitcoin",
          "implementation": "export function resolveAddress(\n  publicKey: string | Buffer,\n  network: \"mainnet\" | \"testnet\" | bitcoin.networks.Network\n): Address {\n  const p2wpkh = bitcoin.payments.p2wpkh({\n    pubkey:\n      typeof publicKey === \"string\" ? Buffer.from(publicKey, \"hex\") : publicKey,\n    network:\n      network === \"mainnet\"\n        ? bitcoin.networks.bitcoin\n        : network === \"testnet\"\n          ? bitcoin.networks.testnet\n          : network,\n  });\n\n  if (!p2wpkh?.address) {\n    throw new Error(\"Address is not initialized.\");\n  }\n\n  const pubKeyHex = Buffer.isBuffer(publicKey)\n    ? publicKey.toString(\"hex\")\n    : publicKey;\n\n  return {\n    address: p2wpkh.address,\n    publicKey: pubKeyHex,\n    purpose: \"payment\",\n    addressType: \"p2wpkh\",\n  };\n}"
        }
      ],
      "types": [],
      "constants": [
        {
          "name": "p2wpkh",
          "type": "any",
          "value": "bitcoin.payments.p2wpkh({",
          "isPublic": true,
          "line": 8,
          "raw": "const p2wpkh = bitcoin.payments.p2wpkh({",
          "source": "bitcoin"
        },
        {
          "name": "pubKeyHex",
          "type": "any",
          "value": "Buffer.isBuffer(publicKey)",
          "isPublic": true,
          "line": 23,
          "raw": "const pubKeyHex = Buffer.isBuffer(publicKey)",
          "source": "bitcoin"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { bitcoin } from \"../core\";\nimport { Address } from \"../types\";\n\nexport function resolveAddress(\n  publicKey: string | Buffer,\n  network: \"mainnet\" | \"testnet\" | bitcoin.networks.Network\n): Address {\n  const p2wpkh = bitcoin.payments.p2wpkh({\n    pubkey:\n      typeof publicKey === \"string\" ? Buffer.from(publicKey, \"hex\") : publicKey,\n    network:\n      network === \"mainnet\"\n        ? bitcoin.networks.bitcoin\n        : network === \"testnet\"\n          ? bitcoin.networks.testnet\n          : network,\n  });\n\n  if (!p2wpkh?.address) {\n    throw new Error(\"Address is not initialized.\");\n  }\n\n  const pubKeyHex = Buffer.isBuffer(publicKey)\n    ? publicKey.toString(\"hex\")\n    : publicKey;\n\n  return {\n    address: p2wpkh.address,\n    publicKey: pubKeyHex,\n    purpose: \"payment\",\n    addressType: \"p2wpkh\",\n  };\n}\n",
      "dependencies": [
        "resolveAddress"
      ],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:utils.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/utils/index.ts",
      "name": "utils.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./address\";\n",
      "dependencies": [],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:wallets.browser.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/wallets/browser/index.ts",
      "name": "wallets.browser.index.ts",
      "imports": [
        {
          "module": "BrowserWallet",
          "items": [],
          "line": 10,
          "raw": "export class BrowserWallet implements IBitcoinWallet {",
          "source": "bitcoin"
        }
      ],
      "functions": [],
      "types": [],
      "constants": [
        {
          "name": "response",
          "type": "any",
          "value": "await WalletStaticMethods.request(\"getAccounts\", {",
          "isPublic": true,
          "line": 27,
          "raw": "const response = await WalletStaticMethods.request(\"getAccounts\", {",
          "source": "bitcoin"
        },
        {
          "name": "response",
          "type": "any",
          "value": "await this.request(\"getAddresses\", {",
          "isPublic": true,
          "line": 39,
          "raw": "const response = await this.request(\"getAddresses\", {",
          "source": "bitcoin"
        },
        {
          "name": "addresses",
          "type": "any",
          "value": "await this.getAddresses();",
          "isPublic": true,
          "line": 51,
          "raw": "const addresses = await this.getAddresses();",
          "source": "bitcoin"
        },
        {
          "name": "address",
          "type": "any",
          "value": "addresses?.find((address) => address.purpose === \"payment\");",
          "isPublic": true,
          "line": 52,
          "raw": "const address = addresses?.find((address) => address.purpose === \"payment\");",
          "source": "bitcoin"
        },
        {
          "name": "address",
          "type": "any",
          "value": "addresses?.find(",
          "isPublic": true,
          "line": 86,
          "raw": "const address = addresses?.find(",
          "source": "bitcoin"
        },
        {
          "name": "response",
          "type": "any",
          "value": "await this.request(\"signMessage\", {",
          "isPublic": true,
          "line": 94,
          "raw": "const response = await this.request(\"signMessage\", {",
          "source": "bitcoin"
        },
        {
          "name": "response",
          "type": "any",
          "value": "await provider.request(method, params);",
          "isPublic": true,
          "line": 134,
          "raw": "const response = await provider.request(method, params);",
          "source": "bitcoin"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "// https://developer.bitcoin.org/reference/rpc/index.html#wallet-rpcs\n\nimport { Address } from \"../../types/address\";\nimport { IBitcoinWallet } from \"../../interfaces/wallet\";\n\ndeclare const window: {\n  BitcoinProvider?: any;\n};\n\nexport class BrowserWallet implements IBitcoinWallet {\n  private readonly _purposes: string[];\n\n  constructor(purposes: string[]) {\n    this._purposes = purposes;\n  }\n\n  /**\n   * This is the entrypoint to start communication with the user's wallet. The wallet should request the user's permission to connect the web page to the user's wallet, and if permission has been granted, the wallet will be returned and exposing the full API for the dApp to use.\n   * @param message - A message to display to the user when requesting permission to connect the wallet.\n   * @param purposes - An array of purposes for which the wallet is being connected. Default is `[\"payment\"]`. Options are `[\"payment\", \"ordinals\", \"stacks\"]`.\n   * @returns\n   */\n  static async enable(\n    message: string,\n    purposes = [\"payment\"]\n  ): Promise<BrowserWallet> {\n    const response = await WalletStaticMethods.request(\"getAccounts\", {\n      purposes: purposes,\n      message: message,\n    });\n    if (response.status === \"success\") {\n      return new BrowserWallet(purposes);\n    }\n    throw new Error(\"Failed to enable wallet\");\n  }\n\n  async getAddresses(): Promise<Address[] | undefined> {\n    try {\n      const response = await this.request(\"getAddresses\", {\n        purposes: this._purposes,\n      });\n      if (response.status === \"success\") {\n        return response.result.addresses as Address[];\n      }\n    } catch (err) {\n      console.error(\"getAccounts ~ error:\", err);\n    }\n  }\n\n  async getChangeAddress() {\n    const addresses = await this.getAddresses();\n    const address = addresses?.find((address) => address.purpose === \"payment\");\n    if (address) return address.address;\n    throw new Error(\"No change address found\");\n  }\n\n  async getCollateral() {\n    console.log(\"Method getCollateral not implemented.\");\n    return [];\n  }\n\n  async getNetworkId(): Promise<0 | 1> {\n    return 1;\n  }\n\n  async request(method: string, params?: any) {\n    return WalletStaticMethods.request(method, params);\n  }\n\n  async signData(\n    payload: string,\n    address?: string,\n    addressType: \"p2wpkh\" | \"p2tr\" | \"stacks\" = \"p2wpkh\"\n  ): Promise<\n    | {\n        address: string;\n        signature: string;\n        messageHash: string;\n      }\n    | undefined\n  > {\n    try {\n      let _address = address;\n      if (!_address) {\n        _address = await this.getAddresses().then((addresses) => {\n          const address = addresses?.find(\n            (address) => address.addressType === addressType\n          );\n          return address?.address;\n        });\n      }\n\n      if (_address) {\n        const response = await this.request(\"signMessage\", {\n          message: payload,\n          address: _address,\n        });\n        if (response.status === \"success\") {\n          return response.result;\n        }\n      }\n    } catch (err) {\n      console.error(\"signMessage ~ error:\", err);\n    }\n  }\n\n  async signTx(signedTx: string): Promise<string> {\n    console.log(\"Method signTx not implemented.\");\n    return \"\";\n  }\n\n  async submitTx(signedTx: string): Promise<string> {\n    console.log(\"Method submitTx not implemented.\");\n    return \"\";\n  }\n}\n\nclass WalletStaticMethods {\n  static async request(\n    method: string, // todo define\n    params: any, // todo define\n    providerId?: string\n  ): Promise<any> {\n    let provider = window.BitcoinProvider;\n    // todo extend to all wallets based on providerId\n\n    if (!provider) {\n      throw new Error(\"No wallet provider was found\");\n    }\n    if (!method) {\n      throw new Error(\"A wallet method is required\");\n    }\n\n    const response = await provider.request(method, params);\n\n    if (response.result) {\n      return {\n        status: \"success\",\n        result: response.result,\n      };\n    }\n\n    return {\n      status: \"error\",\n      error: response.error,\n    };\n  }\n}\n",
      "dependencies": [
        "BrowserWallet"
      ],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/wallets/embedded/index.ts",
      "name": "wallets.embedded.index.ts",
      "imports": [
        {
          "module": "CreateWalletOptions",
          "items": [],
          "line": 10,
          "raw": "export type CreateWalletOptions = {",
          "source": "bitcoin"
        },
        {
          "module": "TransactionPayload",
          "items": [],
          "line": 25,
          "raw": "export type TransactionPayload = {",
          "source": "bitcoin"
        },
        {
          "module": "EmbeddedWallet",
          "items": [],
          "line": 40,
          "raw": "export class EmbeddedWallet {",
          "source": "bitcoin"
        },
        {
          "module": "verifySignature",
          "items": [],
          "line": 296,
          "raw": "export function verifySignature(",
          "source": "bitcoin"
        }
      ],
      "functions": [
        {
          "name": "getAddress",
          "signature": "getAddress(): Address {",
          "documentation": "  /**\n   * Returns the wallet's SegWit (P2WPKH) address and associated public key.\n   *\n   * @returns {Address} The wallet address object including address, public key, and metadata.\n   * @throws {Error} If internal address or public key is not properly initialized.\n   */",
          "parameters": [],
          "returnType": "Address",
          "isPublic": true,
          "line": 74,
          "raw": "  /**\n   * Returns the wallet's SegWit (P2WPKH) address and associated public key.\n   *\n   * @returns {Address} The wallet address object including address, public key, and metadata.\n   * @throws {Error} If internal address or public key is not properly initialized.\n   */\n  getAddress(): Address {\n    if (this._isReadOnly && this._address) {\n      return {\n        address: this._address,\n        purpose: \"payment\",\n        addressType: \"p2wpkh\",\n      };\n    }\n\n    if (!this._wallet) {\n      throw new Error(\"Wallet not initialized properly.\");\n    }\n\n    return resolveAddress(this._wallet.publicKey, this._network);\n\n    // const p2wpkh = bitcoin.payments.p2wpkh({\n    //   pubkey: this._wallet.publicKey,\n    //   network: this._network,\n    // });\n\n    // if (!p2wpkh?.address) {\n    //   throw new Error(\"Address is not initialized.\");\n    // }\n\n    // return {\n    //   address: p2wpkh.address,\n    //   publicKey: this._wallet.publicKey.toString(\"hex\"),\n    //   purpose: \"payment\",\n    //   addressType: \"p2wpkh\",\n    // };\n  }",
          "source": "bitcoin",
          "implementation": "  getAddress(): Address {\n    if (this._isReadOnly && this._address) {\n      return {\n        address: this._address,\n        purpose: \"payment\",\n        addressType: \"p2wpkh\",\n      };\n    }\n\n    if (!this._wallet) {\n      throw new Error(\"Wallet not initialized properly.\");\n    }\n\n    return resolveAddress(this._wallet.publicKey, this._network);\n\n    // const p2wpkh = bitcoin.payments.p2wpkh({\n    //   pubkey: this._wallet.publicKey,\n    //   network: this._network,\n    // });\n\n    // if (!p2wpkh?.address) {\n    //   throw new Error(\"Address is not initialized.\");\n    // }\n\n    // return {\n    //   address: p2wpkh.address,\n    //   publicKey: this._wallet.publicKey.toString(\"hex\"),\n    //   purpose: \"payment\",\n    //   addressType: \"p2wpkh\",\n    // };\n  }"
        },
        {
          "name": "getPublicKey",
          "signature": "getPublicKey(): string {",
          "documentation": "  /**\n   * Returns the hex-encoded public key of the wallet.\n   *\n   * @returns {string} The public key in hexadecimal format.\n   * @throws {Error} If the wallet is read-only and public key is not available.\n   */",
          "parameters": [],
          "returnType": "string",
          "isPublic": true,
          "line": 112,
          "raw": "  /**\n   * Returns the hex-encoded public key of the wallet.\n   *\n   * @returns {string} The public key in hexadecimal format.\n   * @throws {Error} If the wallet is read-only and public key is not available.\n   */\n  getPublicKey(): string {\n    if (this._isReadOnly) {\n      throw new Error(\"Public key is not available for read-only wallets.\");\n    }\n\n    if (!this._wallet) {\n      throw new Error(\"Wallet not initialized properly.\");\n    }\n\n    return this._wallet.publicKey.toString(\"hex\");\n  }",
          "source": "bitcoin",
          "implementation": "  getPublicKey(): string {\n    if (this._isReadOnly) {\n      throw new Error(\"Public key is not available for read-only wallets.\");\n    }\n\n    if (!this._wallet) {\n      throw new Error(\"Wallet not initialized properly.\");\n    }\n\n    return this._wallet.publicKey.toString(\"hex\");\n  }"
        },
        {
          "name": "getNetworkId",
          "signature": "getNetworkId(): 0 | 1 {",
          "documentation": "  /**\n   * Returns the network identifier of the wallet.\n   * 0': Indicates the Bitcoin mainnet.\n   * 1': Indicates the Bitcoin testnet.\n   *\n   * @returns {0 | 1} The Bitcoin network ID.\n   */",
          "parameters": [],
          "returnType": "0 | 1",
          "isPublic": true,
          "line": 131,
          "raw": "  /**\n   * Returns the network identifier of the wallet.\n   * 0': Indicates the Bitcoin mainnet.\n   * 1': Indicates the Bitcoin testnet.\n   *\n   * @returns {0 | 1} The Bitcoin network ID.\n   */\n  getNetworkId(): 0 | 1 {\n    return this._network === bitcoin.networks.testnet ? 1 : 0;\n  }",
          "source": "bitcoin",
          "implementation": "  getNetworkId(): 0 | 1 {\n    return this._network === bitcoin.networks.testnet ? 1 : 0;\n  }"
        },
        {
          "name": "_derive",
          "signature": "function _derive(",
          "documentation": "",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 257,
          "raw": "function _derive(\n  words: string[],\n  path: string = \"m/84'/0'/0'/0/0\",\n  network?: Network\n): BIP32Interface {\n  const mnemonic = words.join(\" \");\n\n  if (!validateMnemonic(mnemonic)) {\n    throw new Error(\"Invalid mnemonic provided.\");\n  }\n\n  const seed = mnemonicToSeedSync(mnemonic);\n  const root = bip32.fromSeed(seed, network);\n  const child = root.derivePath(path);\n\n  return child;\n}",
          "source": "bitcoin",
          "implementation": "function _derive(\n  words: string[],\n  path: string = \"m/84'/0'/0'/0/0\",\n  network?: Network\n): BIP32Interface {\n  const mnemonic = words.join(\" \");\n\n  if (!validateMnemonic(mnemonic)) {\n    throw new Error(\"Invalid mnemonic provided.\");\n  }\n\n  const seed = mnemonicToSeedSync(mnemonic);\n  const root = bip32.fromSeed(seed, network);\n  const child = root.derivePath(path);\n\n  return child;\n}"
        },
        {
          "name": "varIntBuffer",
          "signature": "function varIntBuffer(n: number): Buffer {",
          "documentation": "",
          "parameters": [
            {
              "name": "n",
              "type": "number",
              "optional": false
            }
          ],
          "returnType": "Buffer",
          "isPublic": true,
          "line": 275,
          "raw": "function varIntBuffer(n: number): Buffer {\n  if (n < 0xfd) return Buffer.from([n]);\n  if (n <= 0xffff) return Buffer.from([0xfd, n & 0xff, n >> 8]);\n  if (n <= 0xffffffff)\n    return Buffer.from([\n      0xfe,\n      n & 0xff,\n      (n >> 8) & 0xff,\n      (n >> 16) & 0xff,\n      (n >> 24) & 0xff,\n    ]);\n  throw new Error(\"Message too long\");\n}",
          "source": "bitcoin",
          "implementation": "function varIntBuffer(n: number): Buffer {\n  if (n < 0xfd) return Buffer.from([n]);\n  if (n <= 0xffff) return Buffer.from([0xfd, n & 0xff, n >> 8]);\n  if (n <= 0xffffffff)\n    return Buffer.from([\n      0xfe,\n      n & 0xff,\n      (n >> 8) & 0xff,\n      (n >> 16) & 0xff,\n      (n >> 24) & 0xff,\n    ]);\n  throw new Error(\"Message too long\");\n}"
        },
        {
          "name": "verifySignature",
          "signature": "export function verifySignature(",
          "documentation": "/**\n * Verifies if a signature is valid for a given message and public key.\n * @param message - The original message that was signed.\n * @param signatureBase64 - The base64-encoded signature to verify.\n * @param publicKeyHex - The hex-encoded public key to verify against.\n * @returns {boolean} True if the signature is valid and matches the public key.\n */",
          "parameters": [],
          "returnType": "any",
          "isPublic": true,
          "line": 296,
          "raw": "/**\n * Verifies if a signature is valid for a given message and public key.\n * @param message - The original message that was signed.\n * @param signatureBase64 - The base64-encoded signature to verify.\n * @param publicKeyHex - The hex-encoded public key to verify against.\n * @returns {boolean} True if the signature is valid and matches the public key.\n */\nexport function verifySignature(\n  message: string,\n  signatureBase64: string,\n  publicKeyHex: string\n): boolean {\n  try {\n    const messageBuffer = Buffer.from(message, \"utf8\");\n    const bufferToHash = Buffer.concat([\n      varIntBuffer(messageBuffer.length),\n      messageBuffer,\n    ]);\n    const hash = bitcoin.crypto.hash256(bufferToHash);\n    const signature = Buffer.from(signatureBase64, \"base64\");\n    const publicKey = Buffer.from(publicKeyHex, \"hex\");\n\n    return ECPair.fromPublicKey(publicKey).verify(hash, signature);\n  } catch (e) {\n    return false;\n  }\n}",
          "source": "bitcoin",
          "implementation": "export function verifySignature(\n  message: string,\n  signatureBase64: string,\n  publicKeyHex: string\n): boolean {\n  try {\n    const messageBuffer = Buffer.from(message, \"utf8\");\n    const bufferToHash = Buffer.concat([\n      varIntBuffer(messageBuffer.length),\n      messageBuffer,\n    ]);\n    const hash = bitcoin.crypto.hash256(bufferToHash);\n    const signature = Buffer.from(signatureBase64, \"base64\");\n    const publicKey = Buffer.from(publicKeyHex, \"hex\");\n\n    return ECPair.fromPublicKey(publicKey).verify(hash, signature);\n  } catch (e) {\n    return false;\n  }\n}"
        }
      ],
      "types": [
        {
          "name": "CreateWalletOptions",
          "definition": "export type CreateWalletOptions = {\n  testnet: boolean;\n  key:\n    | {\n        type: \"mnemonic\";\n        words: string[];",
          "isPublic": true,
          "line": 10,
          "raw": "export type CreateWalletOptions = {",
          "source": "bitcoin"
        },
        {
          "name": "TransactionPayload",
          "definition": "export type TransactionPayload = {\n  inputs: {\n    txid: string;\n    vout: number;\n    value: number;",
          "isPublic": true,
          "line": 25,
          "raw": "export type TransactionPayload = {",
          "source": "bitcoin"
        }
      ],
      "constants": [
        {
          "name": "address",
          "type": "any",
          "value": "this.getAddress();",
          "isPublic": true,
          "line": 140,
          "raw": "const address = this.getAddress();",
          "source": "bitcoin"
        },
        {
          "name": "keyPair",
          "type": "any",
          "value": "ECPair.fromPrivateKey(this._wallet.privateKey, {",
          "isPublic": true,
          "line": 165,
          "raw": "const keyPair = ECPair.fromPrivateKey(this._wallet.privateKey, {",
          "source": "bitcoin"
        },
        {
          "name": "messageBuffer",
          "type": "any",
          "value": "Buffer.from(message, \"utf8\");",
          "isPublic": true,
          "line": 169,
          "raw": "const messageBuffer = Buffer.from(message, \"utf8\");",
          "source": "bitcoin"
        },
        {
          "name": "bufferToHash",
          "type": "any",
          "value": "Buffer.concat([",
          "isPublic": true,
          "line": 172,
          "raw": "const bufferToHash = Buffer.concat([",
          "source": "bitcoin"
        },
        {
          "name": "hash",
          "type": "any",
          "value": "bitcoin.crypto.hash256(bufferToHash);",
          "isPublic": true,
          "line": 176,
          "raw": "const hash = bitcoin.crypto.hash256(bufferToHash);",
          "source": "bitcoin"
        },
        {
          "name": "signature",
          "type": "any",
          "value": "keyPair.sign(hash);",
          "isPublic": true,
          "line": 178,
          "raw": "const signature = keyPair.sign(hash);",
          "source": "bitcoin"
        },
        {
          "name": "psbt",
          "type": "any",
          "value": "new bitcoin.Psbt({ network: this._network });",
          "isPublic": true,
          "line": 198,
          "raw": "const psbt = new bitcoin.Psbt({ network: this._network });",
          "source": "bitcoin"
        },
        {
          "name": "p2wpkh",
          "type": "any",
          "value": "bitcoin.payments.p2wpkh({",
          "isPublic": true,
          "line": 199,
          "raw": "const p2wpkh = bitcoin.payments.p2wpkh({",
          "source": "bitcoin"
        },
        {
          "name": "ecPair",
          "type": "any",
          "value": "ECPair.fromPrivateKey(this._wallet.privateKey, {",
          "isPublic": true,
          "line": 203,
          "raw": "const ecPair = ECPair.fromPrivateKey(this._wallet.privateKey, {",
          "source": "bitcoin"
        },
        {
          "name": "mnemonic",
          "type": "any",
          "value": "bip39.generateMnemonic(strength);",
          "isPublic": true,
          "line": 252,
          "raw": "const mnemonic = bip39.generateMnemonic(strength);",
          "source": "bitcoin"
        },
        {
          "name": "mnemonic",
          "type": "any",
          "value": "words.join(\" \");",
          "isPublic": true,
          "line": 262,
          "raw": "const mnemonic = words.join(\" \");",
          "source": "bitcoin"
        },
        {
          "name": "seed",
          "type": "any",
          "value": "mnemonicToSeedSync(mnemonic);",
          "isPublic": true,
          "line": 268,
          "raw": "const seed = mnemonicToSeedSync(mnemonic);",
          "source": "bitcoin"
        },
        {
          "name": "root",
          "type": "any",
          "value": "bip32.fromSeed(seed, network);",
          "isPublic": true,
          "line": 269,
          "raw": "const root = bip32.fromSeed(seed, network);",
          "source": "bitcoin"
        },
        {
          "name": "child",
          "type": "any",
          "value": "root.derivePath(path);",
          "isPublic": true,
          "line": 270,
          "raw": "const child = root.derivePath(path);",
          "source": "bitcoin"
        },
        {
          "name": "messageBuffer",
          "type": "any",
          "value": "Buffer.from(message, \"utf8\");",
          "isPublic": true,
          "line": 302,
          "raw": "const messageBuffer = Buffer.from(message, \"utf8\");",
          "source": "bitcoin"
        },
        {
          "name": "bufferToHash",
          "type": "any",
          "value": "Buffer.concat([",
          "isPublic": true,
          "line": 303,
          "raw": "const bufferToHash = Buffer.concat([",
          "source": "bitcoin"
        },
        {
          "name": "hash",
          "type": "any",
          "value": "bitcoin.crypto.hash256(bufferToHash);",
          "isPublic": true,
          "line": 307,
          "raw": "const hash = bitcoin.crypto.hash256(bufferToHash);",
          "source": "bitcoin"
        },
        {
          "name": "signature",
          "type": "any",
          "value": "Buffer.from(signatureBase64, \"base64\");",
          "isPublic": true,
          "line": 308,
          "raw": "const signature = Buffer.from(signatureBase64, \"base64\");",
          "source": "bitcoin"
        },
        {
          "name": "publicKey",
          "type": "any",
          "value": "Buffer.from(publicKeyHex, \"hex\");",
          "isPublic": true,
          "line": 309,
          "raw": "const publicKey = Buffer.from(publicKeyHex, \"hex\");",
          "source": "bitcoin"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "import { bitcoin, bip32, bip39, ECPair } from \"../../core\";\nimport { BIP32Interface } from \"bip32\";\nimport { UTxO } from \"../../types/utxo\";\nimport { Address } from \"../../types/address\";\nimport { IBitcoinProvider } from \"../../interfaces/provider\";\nimport type { Network } from \"bitcoinjs-lib\";\nimport { mnemonicToSeedSync, validateMnemonic } from \"bip39\";\nimport { resolveAddress } from \"../../utils\";\n\nexport type CreateWalletOptions = {\n  testnet: boolean;\n  key:\n    | {\n        type: \"mnemonic\";\n        words: string[];\n      }\n    | {\n        type: \"address\";\n        address: string;\n      };\n  path?: string;\n  provider?: IBitcoinProvider;\n};\n\nexport type TransactionPayload = {\n  inputs: {\n    txid: string;\n    vout: number;\n    value: number;\n  }[];\n  outputs: {\n    address: string;\n    value: number;\n  }[];\n};\n\n/**\n * EmbeddedWallet is a class that provides a simple interface to interact with Bitcoin wallets.\n */\nexport class EmbeddedWallet {\n  private readonly _network: Network;\n  private readonly _wallet?: BIP32Interface;\n  private readonly _provider?: IBitcoinProvider;\n  private readonly _isReadOnly: boolean;\n  private readonly _address?: string;\n\n  constructor(options: CreateWalletOptions) {\n    this._network = options.testnet\n      ? bitcoin.networks.testnet\n      : bitcoin.networks.bitcoin;\n\n    if (options.key.type === \"mnemonic\") {\n      this._wallet = _derive(\n        options.key.words,\n        options.path ?? \"m/84'/0'/0'/0/0\",\n        this._network\n      );\n      this._isReadOnly = false;\n    } else {\n      // Read-only wallet initialized with just an address\n      this._address = options.key.address;\n      this._isReadOnly = true;\n    }\n\n    this._provider = options.provider;\n  }\n\n  /**\n   * Returns the wallet's SegWit (P2WPKH) address and associated public key.\n   *\n   * @returns {Address} The wallet address object including address, public key, and metadata.\n   * @throws {Error} If internal address or public key is not properly initialized.\n   */\n  getAddress(): Address {\n    if (this._isReadOnly && this._address) {\n      return {\n        address: this._address,\n        purpose: \"payment\",\n        addressType: \"p2wpkh\",\n      };\n    }\n\n    if (!this._wallet) {\n      throw new Error(\"Wallet not initialized properly.\");\n    }\n\n    return resolveAddress(this._wallet.publicKey, this._network);\n\n    // const p2wpkh = bitcoin.payments.p2wpkh({\n    //   pubkey: this._wallet.publicKey,\n    //   network: this._network,\n    // });\n\n    // if (!p2wpkh?.address) {\n    //   throw new Error(\"Address is not initialized.\");\n    // }\n\n    // return {\n    //   address: p2wpkh.address,\n    //   publicKey: this._wallet.publicKey.toString(\"hex\"),\n    //   purpose: \"payment\",\n    //   addressType: \"p2wpkh\",\n    // };\n  }\n\n  /**\n   * Returns the hex-encoded public key of the wallet.\n   *\n   * @returns {string} The public key in hexadecimal format.\n   * @throws {Error} If the wallet is read-only and public key is not available.\n   */\n  getPublicKey(): string {\n    if (this._isReadOnly) {\n      throw new Error(\"Public key is not available for read-only wallets.\");\n    }\n\n    if (!this._wallet) {\n      throw new Error(\"Wallet not initialized properly.\");\n    }\n\n    return this._wallet.publicKey.toString(\"hex\");\n  }\n\n  /**\n   * Returns the network identifier of the wallet.\n   * 0': Indicates the Bitcoin mainnet.\n   * 1': Indicates the Bitcoin testnet.\n   *\n   * @returns {0 | 1} The Bitcoin network ID.\n   */\n  getNetworkId(): 0 | 1 {\n    return this._network === bitcoin.networks.testnet ? 1 : 0;\n  }\n\n  /**\n   * Get UTXOs for the wallet address.\n   * @returns An array of UTXOs.\n   */\n  async getUTxOs(): Promise<UTxO[]> {\n    const address = this.getAddress();\n    if (this._provider === undefined) {\n      throw new Error(\"`provider` is not defined. Provide a BitcoinProvider.\");\n    }\n\n    return await this._provider.fetchAddressUTxOs(address.address);\n  }\n\n  /**\n   * Signs a given message using the wallet's private key.\n   *\n   * @param message - The message to be signed.\n   * @returns The signature of the message as a string.\n   * @throws {Error} If the wallet is read-only or private key is not available.\n   */\n  async signData(message: string): Promise<string> {\n    if (this._isReadOnly) {\n      throw new Error(\"Cannot sign data with a read-only wallet.\");\n    }\n\n    if (!this._wallet || !this._wallet.privateKey) {\n      throw new Error(\"Private key is not available for signing.\");\n    }\n\n    // Create ECPair from private key\n    const keyPair = ECPair.fromPrivateKey(this._wallet.privateKey, {\n      compressed: true,\n    });\n    // Prepare message buffer\n    const messageBuffer = Buffer.from(message, \"utf8\");\n    // Prepare the buffer to sign (see bitcoinjs-message implementation)\n\n    const bufferToHash = Buffer.concat([\n      varIntBuffer(messageBuffer.length),\n      messageBuffer,\n    ]);\n    const hash = bitcoin.crypto.hash256(bufferToHash);\n    // Sign the hash\n    const signature = keyPair.sign(hash);\n    // DER encode and return as base64\n    return signature.toString(\"base64\");\n  }\n\n  /**\n   * Sign a transaction payload.\n   * @param payload - The transaction payload to sign.\n   * @returns The signed transaction in hex format.\n   * @throws {Error} If the wallet is read-only or private key is not available.\n   */\n  async signTx(payload: TransactionPayload): Promise<string> {\n    if (this._isReadOnly) {\n      throw new Error(\"Cannot sign transactions with a read-only wallet.\");\n    }\n\n    if (!this._wallet || !this._wallet.privateKey) {\n      throw new Error(\"Private key is not available for signing.\");\n    }\n\n    const psbt = new bitcoin.Psbt({ network: this._network });\n    const p2wpkh = bitcoin.payments.p2wpkh({\n      pubkey: this._wallet.publicKey,\n      network: this._network,\n    });\n    const ecPair = ECPair.fromPrivateKey(this._wallet.privateKey, {\n      network: this._network,\n    });\n\n    for (const input of payload.inputs) {\n      psbt.addInput({\n        hash: input.txid,\n        index: input.vout,\n        witnessUtxo: {\n          script: p2wpkh.output!,\n          value: input.value,\n        },\n      });\n    }\n\n    for (const output of payload.outputs) {\n      psbt.addOutput({\n        address: output.address,\n        value: output.value,\n      });\n    }\n\n    for (let i = 0; i < payload.inputs.length; i++) {\n      psbt.signInput(i, this._wallet);\n      psbt.validateSignaturesOfInput(i, (pubkey, hash, signature) => {\n        return (\n          ecPair.publicKey.equals(pubkey) && ecPair.verify(hash, signature)\n        );\n      });\n    }\n\n    psbt.finalizeAllInputs();\n    return psbt.extractTransaction().toHex();\n  }\n\n  /**\n   * Generates a mnemonic phrase and returns it as an array of words.\n   *\n   * @param {number} [strength=128] - The strength of the mnemonic in bits (must be a multiple of 32 between 128 and 256).\n   * @returns {string[]} An array of words representing the generated mnemonic.\n   * @throws {Error} If the strength is not valid.\n   */\n  static brew(strength: number = 128): string[] {\n    if (![128, 160, 192, 224, 256].includes(strength)) {\n      throw new Error(\n        \"Invalid strength. Must be one of: 128, 160, 192, 224, 256.\"\n      );\n    }\n\n    const mnemonic = bip39.generateMnemonic(strength);\n    return mnemonic.split(\" \");\n  }\n}\n\nfunction _derive(\n  words: string[],\n  path: string = \"m/84'/0'/0'/0/0\",\n  network?: Network\n): BIP32Interface {\n  const mnemonic = words.join(\" \");\n\n  if (!validateMnemonic(mnemonic)) {\n    throw new Error(\"Invalid mnemonic provided.\");\n  }\n\n  const seed = mnemonicToSeedSync(mnemonic);\n  const root = bip32.fromSeed(seed, network);\n  const child = root.derivePath(path);\n\n  return child;\n}\n\nfunction varIntBuffer(n: number): Buffer {\n  if (n < 0xfd) return Buffer.from([n]);\n  if (n <= 0xffff) return Buffer.from([0xfd, n & 0xff, n >> 8]);\n  if (n <= 0xffffffff)\n    return Buffer.from([\n      0xfe,\n      n & 0xff,\n      (n >> 8) & 0xff,\n      (n >> 16) & 0xff,\n      (n >> 24) & 0xff,\n    ]);\n  throw new Error(\"Message too long\");\n}\n\n/**\n * Verifies if a signature is valid for a given message and public key.\n * @param message - The original message that was signed.\n * @param signatureBase64 - The base64-encoded signature to verify.\n * @param publicKeyHex - The hex-encoded public key to verify against.\n * @returns {boolean} True if the signature is valid and matches the public key.\n */\nexport function verifySignature(\n  message: string,\n  signatureBase64: string,\n  publicKeyHex: string\n): boolean {\n  try {\n    const messageBuffer = Buffer.from(message, \"utf8\");\n    const bufferToHash = Buffer.concat([\n      varIntBuffer(messageBuffer.length),\n      messageBuffer,\n    ]);\n    const hash = bitcoin.crypto.hash256(bufferToHash);\n    const signature = Buffer.from(signatureBase64, \"base64\");\n    const publicKey = Buffer.from(publicKeyHex, \"hex\");\n\n    return ECPair.fromPublicKey(publicKey).verify(hash, signature);\n  } catch (e) {\n    return false;\n  }\n}\n",
      "dependencies": [
        "CreateWalletOptions",
        "TransactionPayload",
        "EmbeddedWallet",
        "verifySignature"
      ],
      "source": "bitcoin",
      "isReExportFile": false
    },
    {
      "key": "bitcoin:wallets.index.ts",
      "path": "/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/wallets/index.ts",
      "name": "wallets.index.ts",
      "imports": [],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "export * from \"./browser\";\nexport * from \"./embedded\";\n",
      "dependencies": [],
      "source": "bitcoin",
      "isReExportFile": false
    }
  ],
  "functions": [
    {
      "key": "mesh-contract:common.ts.getScriptAddress",
      "fullName": "mesh-contract:common.ts.getScriptAddress",
      "name": "getScriptAddress",
      "signature": "getScriptAddress = (scriptCbor: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "scriptCbor",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 69,
      "raw": "  getScriptAddress = (scriptCbor: string) => {\n    const { address } = serializePlutusScript(\n      { code: scriptCbor, version: this.languageVersion },\n      this.stakeCredential,\n      this.networkId,\n    );\n    return address;\n  };",
      "source": "mesh-contract",
      "implementation": "  getScriptAddress = (scriptCbor: string) => {\n    const { address } = serializePlutusScript(\n      { code: scriptCbor, version: this.languageVersion },\n      this.stakeCredential,\n      this.networkId,\n    );\n    return address;\n  };"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.common.ts.getScriptCbor",
      "fullName": "mesh-contract:content-ownership.offchain.common.ts.getScriptCbor",
      "name": "getScriptCbor",
      "signature": "export const getScriptCbor = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 24,
      "raw": "export const getScriptCbor = (\n  oracleParamUtxo: UTxO[\"input\"],\n  scriptIndex: ScriptIndex,\n) => {\n  const validators = blueprint.validators;\n  const oracleNFTCbor = applyParamsToScript(\n    validators[4]!.compiledCode,\n    [outputReference(oracleParamUtxo.txHash, oracleParamUtxo.outputIndex)],\n    \"JSON\",\n  );\n  const oracleNFTToParam = builtinByteString(\n    resolveScriptHash(oracleNFTCbor, \"V3\"),\n  );\n  switch (scriptIndex) {\n    case \"OracleNFT\":\n      return oracleNFTCbor;\n    case \"OracleValidator\":\n      return applyParamsToScript(validators[6]!.compiledCode, [], \"JSON\");\n    case \"ContentRegistry\":\n      return applyParamsToScript(\n        validators[0]!.compiledCode,\n        [oracleNFTToParam],\n        \"JSON\",\n      );\n    case \"ContentRefToken\":\n      return applyParamsToScript(\n        validators[2]!.compiledCode,\n        [oracleNFTToParam],\n        \"JSON\",\n      );\n    case \"OwnershipRegistry\":\n      return applyParamsToScript(\n        validators[8]!.compiledCode,\n        [oracleNFTToParam],\n        \"JSON\",\n      );\n    case \"OwnershipRefToken\":\n      return applyParamsToScript(\n        validators[10]!.compiledCode,\n        [oracleNFTToParam],\n        \"JSON\",\n      );\n  }\n};",
      "source": "mesh-contract",
      "implementation": "export const getScriptCbor = (\n  oracleParamUtxo: UTxO[\"input\"],\n  scriptIndex: ScriptIndex,\n) => {\n  const validators = blueprint.validators;\n  const oracleNFTCbor = applyParamsToScript(\n    validators[4]!.compiledCode,\n    [outputReference(oracleParamUtxo.txHash, oracleParamUtxo.outputIndex)],\n    \"JSON\",\n  );\n  const oracleNFTToParam = builtinByteString(\n    resolveScriptHash(oracleNFTCbor, \"V3\"),\n  );\n  switch (scriptIndex) {\n    case \"OracleNFT\":\n      return oracleNFTCbor;\n    case \"OracleValidator\":\n      return applyParamsToScript(validators[6]!.compiledCode, [], \"JSON\");\n    case \"ContentRegistry\":\n      return applyParamsToScript(\n        validators[0]!.compiledCode,\n        [oracleNFTToParam],\n        \"JSON\",\n      );\n    case \"ContentRefToken\":\n      return applyParamsToScript(\n        validators[2]!.compiledCode,\n        [oracleNFTToParam],\n        \"JSON\",\n      );\n    case \"OwnershipRegistry\":\n      return applyParamsToScript(\n        validators[8]!.compiledCode,\n        [oracleNFTToParam],\n        \"JSON\",\n      );\n    case \"OwnershipRefToken\":\n      return applyParamsToScript(\n        validators[10]!.compiledCode,\n        [oracleNFTToParam],\n        \"JSON\",\n      );\n  }\n};"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.common.ts.getScriptHash",
      "fullName": "mesh-contract:content-ownership.offchain.common.ts.getScriptHash",
      "name": "getScriptHash",
      "signature": "export const getScriptHash = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 69,
      "raw": "export const getScriptHash = (\n  oracleParamUtxo: UTxO[\"input\"],\n  scriptIndex: ScriptIndex,\n) => {\n  const scriptCbor = getScriptCbor(oracleParamUtxo, scriptIndex);\n  return resolveScriptHash(scriptCbor, \"V3\");\n};",
      "source": "mesh-contract",
      "implementation": "export const getScriptHash = (\n  oracleParamUtxo: UTxO[\"input\"],\n  scriptIndex: ScriptIndex,\n) => {\n  const scriptCbor = getScriptCbor(oracleParamUtxo, scriptIndex);\n  return resolveScriptHash(scriptCbor, \"V3\");\n};"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.common.ts.getScriptInfo",
      "fullName": "mesh-contract:content-ownership.offchain.common.ts.getScriptInfo",
      "name": "getScriptInfo",
      "signature": "export const getScriptInfo = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 77,
      "raw": "export const getScriptInfo = (\n  oracleParamUtxo: UTxO[\"input\"],\n  stakeCredential?: string,\n  networkId = 0,\n) => {\n  const info = {\n    oracleNFT: {\n      hash: getScriptHash(oracleParamUtxo, \"OracleNFT\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"OracleNFT\"),\n    },\n    oracleValidator: {\n      hash: getScriptHash(oracleParamUtxo, \"OracleValidator\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"OracleValidator\"),\n      address: \"\",\n    },\n    contentRegistry: {\n      hash: getScriptHash(oracleParamUtxo, \"ContentRegistry\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"ContentRegistry\"),\n      address: \"\",\n    },\n    contentRefToken: {\n      hash: getScriptHash(oracleParamUtxo, \"ContentRefToken\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"ContentRefToken\"),\n    },\n    ownershipRegistry: {\n      hash: getScriptHash(oracleParamUtxo, \"OwnershipRegistry\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"OwnershipRegistry\"),\n      address: \"\",\n    },\n    ownershipRefToken: {\n      hash: getScriptHash(oracleParamUtxo, \"OwnershipRefToken\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"OwnershipRefToken\"),\n    },\n  };\n\n  const oracleAddress = serializePlutusScript(\n    { code: info.oracleValidator.cbor, version: \"V3\" },\n    stakeCredential,\n    networkId,\n  ).address;\n  const contentRegistryAddress = serializePlutusScript(\n    { code: info.contentRegistry.cbor, version: \"V3\" },\n    stakeCredential,\n    networkId,\n  ).address;\n  const ownershipRegistryAddress = serializePlutusScript(\n    { code: info.ownershipRegistry.cbor, version: \"V3\" },\n    stakeCredential,\n    networkId,\n  ).address;\n  info.oracleValidator.address = oracleAddress;\n  info.contentRegistry.address = contentRegistryAddress;\n  info.ownershipRegistry.address = ownershipRegistryAddress;\n\n  return info;\n};",
      "source": "mesh-contract",
      "implementation": "export const getScriptInfo = (\n  oracleParamUtxo: UTxO[\"input\"],\n  stakeCredential?: string,\n  networkId = 0,\n) => {\n  const info = {\n    oracleNFT: {\n      hash: getScriptHash(oracleParamUtxo, \"OracleNFT\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"OracleNFT\"),\n    },\n    oracleValidator: {\n      hash: getScriptHash(oracleParamUtxo, \"OracleValidator\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"OracleValidator\"),\n      address: \"\",\n    },\n    contentRegistry: {\n      hash: getScriptHash(oracleParamUtxo, \"ContentRegistry\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"ContentRegistry\"),\n      address: \"\",\n    },\n    contentRefToken: {\n      hash: getScriptHash(oracleParamUtxo, \"ContentRefToken\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"ContentRefToken\"),\n    },\n    ownershipRegistry: {\n      hash: getScriptHash(oracleParamUtxo, \"OwnershipRegistry\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"OwnershipRegistry\"),\n      address: \"\",\n    },\n    ownershipRefToken: {\n      hash: getScriptHash(oracleParamUtxo, \"OwnershipRefToken\"),\n      cbor: getScriptCbor(oracleParamUtxo, \"OwnershipRefToken\"),\n    },\n  };\n\n  const oracleAddress = serializePlutusScript(\n    { code: info.oracleValidator.cbor, version: \"V3\" },\n    stakeCredential,\n    networkId,\n  ).address;\n  const contentRegistryAddress = serializePlutusScript(\n    { code: info.contentRegistry.cbor, version: \"V3\" },\n    stakeCredential,\n    networkId,\n  ).address;\n  const ownershipRegistryAddress = serializePlutusScript(\n    { code: info.ownershipRegistry.cbor, version: \"V3\" },\n    stakeCredential,\n    networkId,\n  ).address;\n  info.oracleValidator.address = oracleAddress;\n  info.contentRegistry.address = contentRegistryAddress;\n  info.ownershipRegistry.address = ownershipRegistryAddress;\n\n  return info;\n};"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.getOwnerNativeScript",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.getOwnerNativeScript",
      "name": "getOwnerNativeScript",
      "signature": "getOwnerNativeScript = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 135,
      "raw": "  getOwnerNativeScript = () => {\n    const { pubKeyHash: keyHash } = deserializeAddress(this.operationAddress);\n    const nativeScript: NativeScript = {\n      type: \"all\",\n      scripts: [\n        {\n          type: \"sig\",\n          keyHash: keyHash,\n        },\n      ],\n    };\n\n    const { address: scriptAddress } = serializeNativeScript(\n      nativeScript,\n      undefined,\n      this.networkId,\n    );\n\n    return {\n      nativeScript,\n      scriptAddress,\n    };\n  };",
      "source": "mesh-contract",
      "implementation": "  getOwnerNativeScript = () => {\n    const { pubKeyHash: keyHash } = deserializeAddress(this.operationAddress);\n    const nativeScript: NativeScript = {\n      type: \"all\",\n      scripts: [\n        {\n          type: \"sig\",\n          keyHash: keyHash,\n        },\n      ],\n    };\n\n    const { address: scriptAddress } = serializeNativeScript(\n      nativeScript,\n      undefined,\n      this.networkId,\n    );\n\n    return {\n      nativeScript,\n      scriptAddress,\n    };\n  };"
    },
    {
      "key": "mesh-contract:escrow.offchain.ts.initiateEscrowDatum",
      "fullName": "mesh-contract:escrow.offchain.ts.initiateEscrowDatum",
      "name": "initiateEscrowDatum",
      "signature": "export const initiateEscrowDatum = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 31,
      "raw": "export const initiateEscrowDatum = (\n  walletAddress: string,\n  amount: Asset[],\n): InitiationDatum => {\n  const { pubKeyHash, stakeCredentialHash } = deserializeAddress(walletAddress);\n  return conStr0([\n    pubKeyAddress(pubKeyHash, stakeCredentialHash),\n    value(amount),\n  ]);\n};",
      "source": "mesh-contract",
      "implementation": "export const initiateEscrowDatum = (\n  walletAddress: string,\n  amount: Asset[],\n): InitiationDatum => {\n  const { pubKeyHash, stakeCredentialHash } = deserializeAddress(walletAddress);\n  return conStr0([\n    pubKeyAddress(pubKeyHash, stakeCredentialHash),\n    value(amount),\n  ]);\n};"
    },
    {
      "key": "mesh-contract:escrow.offchain.ts.activeEscrowDatum",
      "fullName": "mesh-contract:escrow.offchain.ts.activeEscrowDatum",
      "name": "activeEscrowDatum",
      "signature": "export const activeEscrowDatum = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 45,
      "raw": "export const activeEscrowDatum = (\n  initiationDatum: InitiationDatum,\n  walletAddress: string,\n  amount: Asset[],\n): ActiveEscrowDatum => {\n  const { pubKeyHash, stakeCredentialHash } = deserializeAddress(walletAddress);\n  const [initiator, initiatorAmount] = initiationDatum.fields;\n  return conStr1([\n    initiator,\n    initiatorAmount,\n    pubKeyAddress(pubKeyHash, stakeCredentialHash),\n    value(amount),\n  ]);\n};",
      "source": "mesh-contract",
      "implementation": "export const activeEscrowDatum = (\n  initiationDatum: InitiationDatum,\n  walletAddress: string,\n  amount: Asset[],\n): ActiveEscrowDatum => {\n  const { pubKeyHash, stakeCredentialHash } = deserializeAddress(walletAddress);\n  const [initiator, initiatorAmount] = initiationDatum.fields;\n  return conStr1([\n    initiator,\n    initiatorAmount,\n    pubKeyAddress(pubKeyHash, stakeCredentialHash),\n    value(amount),\n  ]);\n};"
    },
    {
      "key": "mesh-contract:escrow.offchain.ts.recipientDepositRedeemer",
      "fullName": "mesh-contract:escrow.offchain.ts.recipientDepositRedeemer",
      "name": "recipientDepositRedeemer",
      "signature": "export const recipientDepositRedeemer = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 61,
      "raw": "export const recipientDepositRedeemer = (\n  recipient: string,\n  depositAmount: Asset[],\n) => initiateEscrowDatum(recipient, depositAmount);\n\nexport class MeshEscrowContract extends MeshTxInitiator {\n  scriptCbor: string;\n  scriptAddress: string;\n\n  constructor(inputs: MeshTxInitiatorInput) {\n    super(inputs);\n    this.scriptCbor = this.getScriptCbor();\n    this.scriptAddress = this.getScriptAddress(this.scriptCbor);\n  }\n\n  getScriptCbor = () => {\n    switch (this.version) {\n      case 3:\n        return applyParamsToScript(blueprintV3.validators[0]!.compiledCode, []);\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };\n\n  initiateEscrow = async (escrowAmount: Asset[]): Promise<string> => {\n    const { utxos, walletAddress } = await this.getWalletInfoForTx();\n\n    await this.mesh\n      .txOut(this.scriptAddress, escrowAmount)\n      .txOutInlineDatumValue(\n        initiateEscrowDatum(walletAddress, escrowAmount),\n        \"JSON\",\n      )\n      .changeAddress(walletAddress)\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  cancelEscrow = async (escrowUtxo: UTxO): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n\n    const inputDatum = deserializeDatum<InitiationDatum | ActiveEscrowDatum>(\n      escrowUtxo.output.plutusData!,\n    );\n\n    if (inputDatum.constructor === 1) {\n      const [\n        initiatorAddressObj,\n        initiatorAmount,\n        recipientAddressObj,\n        recipientAmount,\n      ] = inputDatum.fields;\n\n      const initiatorAddress = serializeAddressObj(\n        initiatorAddressObj,\n        this.networkId,\n      );\n      const recipientAddress = serializeAddressObj(\n        recipientAddressObj!,\n        this.networkId,\n      );\n      const initiatorToReceive =\n        MeshValue.fromValue(initiatorAmount).toAssets();\n      const recipientToReceive = MeshValue.fromValue(\n        recipientAmount!,\n      ).toAssets();\n      this.mesh\n        .txOut(initiatorAddress, initiatorToReceive)\n        .txOut(recipientAddress, recipientToReceive);\n    }\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        escrowUtxo.input.txHash,\n        escrowUtxo.input.outputIndex,\n        escrowUtxo.output.amount,\n        this.scriptAddress,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(mConStr1([]))\n      .txInScript(this.scriptCbor)\n      .requiredSignerHash(deserializeAddress(walletAddress).pubKeyHash)\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  recipientDeposit = async (\n    escrowUtxo: UTxO,\n    depositAmount: Asset[],\n  ): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n\n    const inputDatum = deserializeDatum<InitiationDatum>(\n      escrowUtxo.output.plutusData!,\n    );\n    const outputDatum = activeEscrowDatum(\n      inputDatum,\n      walletAddress,\n      depositAmount,\n    );\n\n    const inputAssets = MeshValue.fromValue(inputDatum.fields[1]).toAssets();\n    const escrowAmount = mergeAssets([...depositAmount, ...inputAssets]);\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        escrowUtxo.input.txHash,\n        escrowUtxo.input.outputIndex,\n        escrowUtxo.output.amount,\n        this.scriptAddress,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .txInRedeemerValue(\n        recipientDepositRedeemer(walletAddress, depositAmount),\n        \"JSON\",\n        DEFAULT_REDEEMER_BUDGET,\n      )\n      .txInScript(this.scriptCbor)\n      .txOut(this.scriptAddress, escrowAmount)\n      .txOutInlineDatumValue(outputDatum, \"JSON\")\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  completeEscrow = async (escrowUtxo: UTxO): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n\n    const inputDatum = deserializeDatum<ActiveEscrowDatum>(\n      escrowUtxo.output.plutusData!,\n    );\n    const [\n      initiatorAddressObj,\n      initiatorAmount,\n      recipientAddressObj,\n      recipientAmount,\n    ] = inputDatum.fields;\n    const initiatorAddress = serializeAddressObj(\n      initiatorAddressObj,\n      this.networkId,\n    );\n    const recipientAddress = serializeAddressObj(\n      recipientAddressObj,\n      this.networkId,\n    );\n    const initiatorToReceive = MeshValue.fromValue(recipientAmount).toAssets();\n    const recipientToReceive = MeshValue.fromValue(initiatorAmount).toAssets();\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        escrowUtxo.input.txHash,\n        escrowUtxo.input.outputIndex,\n        escrowUtxo.output.amount,\n        this.scriptAddress,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(mConStr2([]))\n      .txInScript(this.scriptCbor)\n      .txOut(initiatorAddress, initiatorToReceive)\n      .txOut(recipientAddress, recipientToReceive)\n      .requiredSignerHash(deserializeAddress(recipientAddress).pubKeyHash)\n      .requiredSignerHash(deserializeAddress(initiatorAddress).pubKeyHash)\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {\n    return await this._getUtxoByTxHash(txHash, this.scriptCbor);\n  };\n}",
      "source": "mesh-contract",
      "implementation": "export const recipientDepositRedeemer = (\n  recipient: string,\n  depositAmount: Asset[],\n) => initiateEscrowDatum(recipient, depositAmount);\n\nexport class MeshEscrowContract extends MeshTxInitiator {\n  scriptCbor: string;\n  scriptAddress: string;\n\n  constructor(inputs: MeshTxInitiatorInput) {\n    super(inputs);\n    this.scriptCbor = this.getScriptCbor();\n    this.scriptAddress = this.getScriptAddress(this.scriptCbor);\n  }\n\n  getScriptCbor = () => {\n    switch (this.version) {\n      case 3:\n        return applyParamsToScript(blueprintV3.validators[0]!.compiledCode, []);\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };\n\n  initiateEscrow = async (escrowAmount: Asset[]): Promise<string> => {\n    const { utxos, walletAddress } = await this.getWalletInfoForTx();\n\n    await this.mesh\n      .txOut(this.scriptAddress, escrowAmount)\n      .txOutInlineDatumValue(\n        initiateEscrowDatum(walletAddress, escrowAmount),\n        \"JSON\",\n      )\n      .changeAddress(walletAddress)\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  cancelEscrow = async (escrowUtxo: UTxO): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n\n    const inputDatum = deserializeDatum<InitiationDatum | ActiveEscrowDatum>(\n      escrowUtxo.output.plutusData!,\n    );\n\n    if (inputDatum.constructor === 1) {\n      const [\n        initiatorAddressObj,\n        initiatorAmount,\n        recipientAddressObj,\n        recipientAmount,\n      ] = inputDatum.fields;\n\n      const initiatorAddress = serializeAddressObj(\n        initiatorAddressObj,\n        this.networkId,\n      );\n      const recipientAddress = serializeAddressObj(\n        recipientAddressObj!,\n        this.networkId,\n      );\n      const initiatorToReceive =\n        MeshValue.fromValue(initiatorAmount).toAssets();\n      const recipientToReceive = MeshValue.fromValue(\n        recipientAmount!,\n      ).toAssets();\n      this.mesh\n        .txOut(initiatorAddress, initiatorToReceive)\n        .txOut(recipientAddress, recipientToReceive);\n    }\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        escrowUtxo.input.txHash,\n        escrowUtxo.input.outputIndex,\n        escrowUtxo.output.amount,\n        this.scriptAddress,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(mConStr1([]))\n      .txInScript(this.scriptCbor)\n      .requiredSignerHash(deserializeAddress(walletAddress).pubKeyHash)\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  recipientDeposit = async (\n    escrowUtxo: UTxO,\n    depositAmount: Asset[],\n  ): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n\n    const inputDatum = deserializeDatum<InitiationDatum>(\n      escrowUtxo.output.plutusData!,\n    );\n    const outputDatum = activeEscrowDatum(\n      inputDatum,\n      walletAddress,\n      depositAmount,\n    );\n\n    const inputAssets = MeshValue.fromValue(inputDatum.fields[1]).toAssets();\n    const escrowAmount = mergeAssets([...depositAmount, ...inputAssets]);\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        escrowUtxo.input.txHash,\n        escrowUtxo.input.outputIndex,\n        escrowUtxo.output.amount,\n        this.scriptAddress,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .txInRedeemerValue(\n        recipientDepositRedeemer(walletAddress, depositAmount),\n        \"JSON\",\n        DEFAULT_REDEEMER_BUDGET,\n      )\n      .txInScript(this.scriptCbor)\n      .txOut(this.scriptAddress, escrowAmount)\n      .txOutInlineDatumValue(outputDatum, \"JSON\")\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  completeEscrow = async (escrowUtxo: UTxO): Promise<string> => {\n    const { utxos, walletAddress, collateral } =\n      await this.getWalletInfoForTx();\n\n    const inputDatum = deserializeDatum<ActiveEscrowDatum>(\n      escrowUtxo.output.plutusData!,\n    );\n    const [\n      initiatorAddressObj,\n      initiatorAmount,\n      recipientAddressObj,\n      recipientAmount,\n    ] = inputDatum.fields;\n    const initiatorAddress = serializeAddressObj(\n      initiatorAddressObj,\n      this.networkId,\n    );\n    const recipientAddress = serializeAddressObj(\n      recipientAddressObj,\n      this.networkId,\n    );\n    const initiatorToReceive = MeshValue.fromValue(recipientAmount).toAssets();\n    const recipientToReceive = MeshValue.fromValue(initiatorAmount).toAssets();\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        escrowUtxo.input.txHash,\n        escrowUtxo.input.outputIndex,\n        escrowUtxo.output.amount,\n        this.scriptAddress,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(mConStr2([]))\n      .txInScript(this.scriptCbor)\n      .txOut(initiatorAddress, initiatorToReceive)\n      .txOut(recipientAddress, recipientToReceive)\n      .requiredSignerHash(deserializeAddress(recipientAddress).pubKeyHash)\n      .requiredSignerHash(deserializeAddress(initiatorAddress).pubKeyHash)\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {\n    return await this._getUtxoByTxHash(txHash, this.scriptCbor);\n  };\n}"
    },
    {
      "key": "mesh-contract:escrow.offchain.ts.getScriptCbor",
      "fullName": "mesh-contract:escrow.offchain.ts.getScriptCbor",
      "name": "getScriptCbor",
      "signature": "getScriptCbor = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 76,
      "raw": "  getScriptCbor = () => {\n    switch (this.version) {\n      case 3:\n        return applyParamsToScript(blueprintV3.validators[0]!.compiledCode, []);\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };",
      "source": "mesh-contract",
      "implementation": "  getScriptCbor = () => {\n    switch (this.version) {\n      case 3:\n        return applyParamsToScript(blueprintV3.validators[0]!.compiledCode, []);\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };"
    },
    {
      "key": "mesh-contract:giftcard.offchain.ts.redeemCbor",
      "fullName": "mesh-contract:giftcard.offchain.ts.redeemCbor",
      "name": "redeemCbor",
      "signature": "redeemCbor = (tokenNameHex: string, policyId: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "tokenNameHex",
          "type": "string",
          "optional": false
        },
        {
          "name": "policyId",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 68,
      "raw": "  redeemCbor = (tokenNameHex: string, policyId: string) => {\n    let scriptCbor;\n    switch (this.version) {\n      case 2:\n        scriptCbor = blueprintV2.validators[2]!.compiledCode;\n        break;\n      default:\n        scriptCbor = blueprintV1.validators[1]!.compiledCode;\n    }\n\n    return applyParamsToScript(scriptCbor, [tokenNameHex, policyId]);\n  };",
      "source": "mesh-contract",
      "implementation": "  redeemCbor = (tokenNameHex: string, policyId: string) => {\n    let scriptCbor;\n    switch (this.version) {\n      case 2:\n        scriptCbor = blueprintV2.validators[2]!.compiledCode;\n        break;\n      default:\n        scriptCbor = blueprintV1.validators[1]!.compiledCode;\n    }\n\n    return applyParamsToScript(scriptCbor, [tokenNameHex, policyId]);\n  };"
    },
    {
      "key": "mesh-contract:giftcard.offchain.ts.paramTxHash",
      "fullName": "mesh-contract:giftcard.offchain.ts.paramTxHash",
      "name": "paramTxHash",
      "signature": "const paramTxHash = (inlineDatum[0] as BuiltinByteString).bytes;",
      "documentation": "",
      "parameters": [
        {
          "name": "inlineDatum[0] as BuiltinByteString",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 152,
      "raw": "    const paramTxHash = (inlineDatum[0] as BuiltinByteString).bytes;\n    const paramTxId = (inlineDatum[1] as Integer).int as number;\n    const tokenNameHex = (inlineDatum[2] as BuiltinByteString).bytes;\n    const giftCardScript = this.giftCardCbor(\n      tokenNameHex,\n      paramTxHash,\n      paramTxId,\n    );\n\n    const giftCardPolicy = resolveScriptHash(\n      giftCardScript,\n      this.languageVersion,\n    );\n\n    const redeemScript = this.redeemCbor(tokenNameHex, giftCardPolicy);\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        giftCardUtxo.input.txHash,\n        giftCardUtxo.input.outputIndex,\n        giftCardUtxo.output.amount,\n        giftCardUtxo.output.address,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(\"\")\n      .txInScript(redeemScript)\n      .mintPlutusScript(this.languageVersion)\n      .mint(\"-1\", giftCardPolicy, tokenNameHex)\n      .mintingScript(giftCardScript)\n      .mintRedeemerValue(mConStr1([]))\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {",
      "source": "mesh-contract",
      "implementation": "    const paramTxHash = (inlineDatum[0] as BuiltinByteString).bytes;\n    const paramTxId = (inlineDatum[1] as Integer).int as number;\n    const tokenNameHex = (inlineDatum[2] as BuiltinByteString).bytes;\n    const giftCardScript = this.giftCardCbor(\n      tokenNameHex,\n      paramTxHash,\n      paramTxId,\n    );\n\n    const giftCardPolicy = resolveScriptHash(\n      giftCardScript,\n      this.languageVersion,\n    );\n\n    const redeemScript = this.redeemCbor(tokenNameHex, giftCardPolicy);\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        giftCardUtxo.input.txHash,\n        giftCardUtxo.input.outputIndex,\n        giftCardUtxo.output.amount,\n        giftCardUtxo.output.address,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(\"\")\n      .txInScript(redeemScript)\n      .mintPlutusScript(this.languageVersion)\n      .mint(\"-1\", giftCardPolicy, tokenNameHex)\n      .mintingScript(giftCardScript)\n      .mintRedeemerValue(mConStr1([]))\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {"
    },
    {
      "key": "mesh-contract:giftcard.offchain.ts.paramTxId",
      "fullName": "mesh-contract:giftcard.offchain.ts.paramTxId",
      "name": "paramTxId",
      "signature": "const paramTxId = (inlineDatum[1] as Integer).int as number;",
      "documentation": "",
      "parameters": [
        {
          "name": "inlineDatum[1] as Integer",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 153,
      "raw": "    const paramTxId = (inlineDatum[1] as Integer).int as number;\n    const tokenNameHex = (inlineDatum[2] as BuiltinByteString).bytes;\n    const giftCardScript = this.giftCardCbor(\n      tokenNameHex,\n      paramTxHash,\n      paramTxId,\n    );\n\n    const giftCardPolicy = resolveScriptHash(\n      giftCardScript,\n      this.languageVersion,\n    );\n\n    const redeemScript = this.redeemCbor(tokenNameHex, giftCardPolicy);\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        giftCardUtxo.input.txHash,\n        giftCardUtxo.input.outputIndex,\n        giftCardUtxo.output.amount,\n        giftCardUtxo.output.address,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(\"\")\n      .txInScript(redeemScript)\n      .mintPlutusScript(this.languageVersion)\n      .mint(\"-1\", giftCardPolicy, tokenNameHex)\n      .mintingScript(giftCardScript)\n      .mintRedeemerValue(mConStr1([]))\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {",
      "source": "mesh-contract",
      "implementation": "    const paramTxId = (inlineDatum[1] as Integer).int as number;\n    const tokenNameHex = (inlineDatum[2] as BuiltinByteString).bytes;\n    const giftCardScript = this.giftCardCbor(\n      tokenNameHex,\n      paramTxHash,\n      paramTxId,\n    );\n\n    const giftCardPolicy = resolveScriptHash(\n      giftCardScript,\n      this.languageVersion,\n    );\n\n    const redeemScript = this.redeemCbor(tokenNameHex, giftCardPolicy);\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        giftCardUtxo.input.txHash,\n        giftCardUtxo.input.outputIndex,\n        giftCardUtxo.output.amount,\n        giftCardUtxo.output.address,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(\"\")\n      .txInScript(redeemScript)\n      .mintPlutusScript(this.languageVersion)\n      .mint(\"-1\", giftCardPolicy, tokenNameHex)\n      .mintingScript(giftCardScript)\n      .mintRedeemerValue(mConStr1([]))\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {"
    },
    {
      "key": "mesh-contract:giftcard.offchain.ts.tokenNameHex",
      "fullName": "mesh-contract:giftcard.offchain.ts.tokenNameHex",
      "name": "tokenNameHex",
      "signature": "const tokenNameHex = (inlineDatum[2] as BuiltinByteString).bytes;",
      "documentation": "",
      "parameters": [
        {
          "name": "inlineDatum[2] as BuiltinByteString",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 154,
      "raw": "    const tokenNameHex = (inlineDatum[2] as BuiltinByteString).bytes;\n    const giftCardScript = this.giftCardCbor(\n      tokenNameHex,\n      paramTxHash,\n      paramTxId,\n    );\n\n    const giftCardPolicy = resolveScriptHash(\n      giftCardScript,\n      this.languageVersion,\n    );\n\n    const redeemScript = this.redeemCbor(tokenNameHex, giftCardPolicy);\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        giftCardUtxo.input.txHash,\n        giftCardUtxo.input.outputIndex,\n        giftCardUtxo.output.amount,\n        giftCardUtxo.output.address,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(\"\")\n      .txInScript(redeemScript)\n      .mintPlutusScript(this.languageVersion)\n      .mint(\"-1\", giftCardPolicy, tokenNameHex)\n      .mintingScript(giftCardScript)\n      .mintRedeemerValue(mConStr1([]))\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {",
      "source": "mesh-contract",
      "implementation": "    const tokenNameHex = (inlineDatum[2] as BuiltinByteString).bytes;\n    const giftCardScript = this.giftCardCbor(\n      tokenNameHex,\n      paramTxHash,\n      paramTxId,\n    );\n\n    const giftCardPolicy = resolveScriptHash(\n      giftCardScript,\n      this.languageVersion,\n    );\n\n    const redeemScript = this.redeemCbor(tokenNameHex, giftCardPolicy);\n\n    await this.mesh\n      .spendingPlutusScript(this.languageVersion)\n      .txIn(\n        giftCardUtxo.input.txHash,\n        giftCardUtxo.input.outputIndex,\n        giftCardUtxo.output.amount,\n        giftCardUtxo.output.address,\n      )\n      .spendingReferenceTxInInlineDatumPresent()\n      .spendingReferenceTxInRedeemerValue(\"\")\n      .txInScript(redeemScript)\n      .mintPlutusScript(this.languageVersion)\n      .mint(\"-1\", giftCardPolicy, tokenNameHex)\n      .mintingScript(giftCardScript)\n      .mintRedeemerValue(mConStr1([]))\n      .changeAddress(walletAddress)\n      .txInCollateral(\n        collateral.input.txHash,\n        collateral.input.outputIndex,\n        collateral.output.amount,\n        collateral.output.address,\n      )\n      .selectUtxosFrom(utxos)\n      .complete();\n    return this.mesh.txHex;\n  };\n\n  getUtxoByTxHash = async (txHash: string): Promise<UTxO | undefined> => {"
    },
    {
      "key": "mesh-contract:hello-world.offchain.ts.getScriptCbor",
      "fullName": "mesh-contract:hello-world.offchain.ts.getScriptCbor",
      "name": "getScriptCbor",
      "signature": "getScriptCbor = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 31,
      "raw": "  getScriptCbor = () => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };",
      "source": "mesh-contract",
      "implementation": "  getScriptCbor = () => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };"
    },
    {
      "key": "mesh-contract:marketplace.offchain.ts.marketplaceDatum",
      "fullName": "mesh-contract:marketplace.offchain.ts.marketplaceDatum",
      "name": "marketplaceDatum",
      "signature": "export const marketplaceDatum = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 33,
      "raw": "export const marketplaceDatum = (\n  sellerAddress: string,\n  lovelaceFee: number,\n  assetHex: string,\n): MarketplaceDatum => {\n  const { pubKeyHash, stakeCredentialHash } = deserializeAddress(sellerAddress);\n  const { policyId, assetName } = parseAssetUnit(assetHex);\n  return conStr0([\n    pubKeyAddress(pubKeyHash, stakeCredentialHash),\n    integer(lovelaceFee),\n    currencySymbol(policyId),\n    tokenName(assetName),\n  ]);\n};",
      "source": "mesh-contract",
      "implementation": "export const marketplaceDatum = (\n  sellerAddress: string,\n  lovelaceFee: number,\n  assetHex: string,\n): MarketplaceDatum => {\n  const { pubKeyHash, stakeCredentialHash } = deserializeAddress(sellerAddress);\n  const { policyId, assetName } = parseAssetUnit(assetHex);\n  return conStr0([\n    pubKeyAddress(pubKeyHash, stakeCredentialHash),\n    integer(lovelaceFee),\n    currencySymbol(policyId),\n    tokenName(assetName),\n  ]);\n};"
    },
    {
      "key": "mesh-contract:payment-splitter.offchain.ts.wrapPayees",
      "fullName": "mesh-contract:payment-splitter.offchain.ts.wrapPayees",
      "name": "wrapPayees",
      "signature": "wrapPayees = (payees: string[]) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "payees",
          "type": "string[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 19,
      "raw": "  wrapPayees = (payees: string[]) =>\n    list(\n      payees.map((payee) =>\n        builtinByteString(deserializeAddress(payee).pubKeyHash),\n      ),\n    );\n\n  constructor(inputs: MeshTxInitiatorInput, payees: string[]) {\n    super(inputs);\n\n    if (inputs.wallet) {\n      inputs.wallet.getUsedAddresses().then((addresses) => {\n        this.payees = [addresses[0]!, ...payees];\n      });\n    } else {\n      this.payees = payees;\n      console.warn(\n        \"Wallet not provided. Therefore the payment address will not be added to the payees list which makes it impossible to trigger the payout.\",\n      );\n    }\n\n    this.scriptCbor = this.getScriptCbor();\n    this.scriptAddress = this.getScriptAddress(this.scriptCbor);\n  }",
      "source": "mesh-contract",
      "implementation": "  wrapPayees = (payees: string[]) =>\n    list(\n      payees.map((payee) =>\n        builtinByteString(deserializeAddress(payee).pubKeyHash),\n      ),\n    );\n\n  constructor(inputs: MeshTxInitiatorInput, payees: string[]) {\n    super(inputs);\n\n    if (inputs.wallet) {\n      inputs.wallet.getUsedAddresses().then((addresses) => {\n        this.payees = [addresses[0]!, ...payees];\n      });\n    } else {\n      this.payees = payees;\n      console.warn(\n        \"Wallet not provided. Therefore the payment address will not be added to the payees list which makes it impossible to trigger the payout.\",\n      );\n    }\n\n    this.scriptCbor = this.getScriptCbor();\n    this.scriptAddress = this.getScriptAddress(this.scriptCbor);\n  }"
    },
    {
      "key": "mesh-contract:payment-splitter.offchain.ts.getScriptCbor",
      "fullName": "mesh-contract:payment-splitter.offchain.ts.getScriptCbor",
      "name": "getScriptCbor",
      "signature": "getScriptCbor = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 44,
      "raw": "  getScriptCbor = () => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(\n          blueprintV2.validators[0]!.compiledCode,\n          [this.wrapPayees(this.payees)],\n          \"JSON\",\n        );\n\n      default:\n        return applyParamsToScript(\n          blueprintV1.validators[0]!.compiledCode,\n          [this.wrapPayees(this.payees)],\n          \"JSON\",\n        );\n    }\n  };",
      "source": "mesh-contract",
      "implementation": "  getScriptCbor = () => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(\n          blueprintV2.validators[0]!.compiledCode,\n          [this.wrapPayees(this.payees)],\n          \"JSON\",\n        );\n\n      default:\n        return applyParamsToScript(\n          blueprintV1.validators[0]!.compiledCode,\n          [this.wrapPayees(this.payees)],\n          \"JSON\",\n        );\n    }\n  };"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.getOracleCbor",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.getOracleCbor",
      "name": "getOracleCbor",
      "signature": "getOracleCbor = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 42,
      "raw": "  getOracleCbor = () => {\n    return applyCborEncoding(blueprint.validators[0]!.compiledCode);\n  };",
      "source": "mesh-contract",
      "implementation": "  getOracleCbor = () => {\n    return applyCborEncoding(blueprint.validators[0]!.compiledCode);\n  };"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.getOracleNFTCbor",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.getOracleNFTCbor",
      "name": "getOracleNFTCbor",
      "signature": "getOracleNFTCbor = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 46,
      "raw": "  getOracleNFTCbor = () => {\n    return applyParamsToScript(blueprint.validators[2]!.compiledCode, [\n      mOutputReference(this.paramUtxo.txHash, this.paramUtxo.outputIndex),\n    ]);\n  };",
      "source": "mesh-contract",
      "implementation": "  getOracleNFTCbor = () => {\n    return applyParamsToScript(blueprint.validators[2]!.compiledCode, [\n      mOutputReference(this.paramUtxo.txHash, this.paramUtxo.outputIndex),\n    ]);\n  };"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.getNFTCbor",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.getNFTCbor",
      "name": "getNFTCbor",
      "signature": "getNFTCbor = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 52,
      "raw": "  getNFTCbor = () => {\n    const oracleNftPolicyId = resolveScriptHash(this.getOracleNFTCbor(), \"V3\");\n    return applyParamsToScript(blueprint.validators[4]!.compiledCode, [\n      stringToHex(this.collectionName),\n      oracleNftPolicyId,\n    ]);\n  };",
      "source": "mesh-contract",
      "implementation": "  getNFTCbor = () => {\n    const oracleNftPolicyId = resolveScriptHash(this.getOracleNFTCbor(), \"V3\");\n    return applyParamsToScript(blueprint.validators[4]!.compiledCode, [\n      stringToHex(this.collectionName),\n      oracleNftPolicyId,\n    ]);\n  };"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.oracleUtxo",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.oracleUtxo",
      "name": "oracleUtxo",
      "signature": "const oracleUtxo = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 235,
      "raw": "    const oracleUtxo = (\n      await this.getAddressUtxosWithToken(this.oracleAddress, oracleNftPolicyId)\n    )[0]!;\n    const oracleDatum: OracleDatum = parseDatumCbor(\n      oracleUtxo!.output.plutusData!,\n    );\n\n    const nftIndex = oracleDatum.fields[0].int;\n    const lovelacePrice = oracleDatum.fields[1].int;\n    const feeCollectorAddressObj = oracleDatum.fields[2];\n    const feeCollectorAddress = serializeAddressObj(\n      feeCollectorAddressObj,\n      this.networkId,\n    );\n\n    const policyId = resolveScriptHash(this.getNFTCbor(), \"V3\");\n\n    return {\n      nftIndex,\n      policyId,\n      lovelacePrice,\n      oracleUtxo,\n      oracleNftPolicyId,\n      feeCollectorAddress,\n      feeCollectorAddressObj,\n    };",
      "source": "mesh-contract",
      "implementation": "    const oracleUtxo = (\n      await this.getAddressUtxosWithToken(this.oracleAddress, oracleNftPolicyId)\n    )[0]!;\n    const oracleDatum: OracleDatum = parseDatumCbor(\n      oracleUtxo!.output.plutusData!,\n    );\n\n    const nftIndex = oracleDatum.fields[0].int;\n    const lovelacePrice = oracleDatum.fields[1].int;\n    const feeCollectorAddressObj = oracleDatum.fields[2];\n    const feeCollectorAddress = serializeAddressObj(\n      feeCollectorAddressObj,\n      this.networkId,\n    );\n\n    const policyId = resolveScriptHash(this.getNFTCbor(), \"V3\");\n\n    return {\n      nftIndex,\n      policyId,\n      lovelacePrice,\n      oracleUtxo,\n      oracleNftPolicyId,\n      feeCollectorAddress,\n      feeCollectorAddressObj,\n    };"
    },
    {
      "key": "mesh-contract:swap.offchain.ts.getScriptCbor",
      "fullName": "mesh-contract:swap.offchain.ts.getScriptCbor",
      "name": "getScriptCbor",
      "signature": "getScriptCbor = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 37,
      "raw": "  getScriptCbor = () => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };",
      "source": "mesh-contract",
      "implementation": "  getScriptCbor = () => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };"
    },
    {
      "key": "mesh-contract:vesting.offchain.ts.getScriptCbor",
      "fullName": "mesh-contract:vesting.offchain.ts.getScriptCbor",
      "name": "getScriptCbor",
      "signature": "getScriptCbor = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 35,
      "raw": "  getScriptCbor = () => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };",
      "source": "mesh-contract",
      "implementation": "  getScriptCbor = () => {\n    switch (this.version) {\n      case 2:\n        return applyParamsToScript(blueprintV2.validators[0]!.compiledCode, []);\n      default:\n        return applyParamsToScript(blueprintV1.validators[0]!.compiledCode, []);\n    }\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshTxInToCSDKUtxo",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshTxInToCSDKUtxo",
      "name": "meshTxInToCSDKUtxo",
      "signature": "const meshTxInToCSDKUtxo = (txIn: TxIn): CSDK.Utxo => {",
      "documentation": "",
      "parameters": [
        {
          "name": "txIn",
          "type": "TxIn",
          "optional": false
        }
      ],
      "returnType": "CSDK.Utxo",
      "isPublic": true,
      "line": 224,
      "raw": "const meshTxInToCSDKUtxo = (txIn: TxIn): CSDK.Utxo => {\n  return [\n    {\n      txId: <CSDK.TransactionId>txIn.txIn.txHash,\n      index: txIn.txIn.txIndex,\n      address: <CSDK.PaymentAddress>txIn.txIn.address,\n    },\n    {\n      address: <CSDK.PaymentAddress>txIn.txIn.address,\n      value: meshAssetsToCSDKValue(txIn.txIn.amount),\n    },\n  ];\n};",
      "source": "mesh-transaction",
      "implementation": "const meshTxInToCSDKUtxo = (txIn: TxIn): CSDK.Utxo => {\n  return [\n    {\n      txId: <CSDK.TransactionId>txIn.txIn.txHash,\n      index: txIn.txIn.txIndex,\n      address: <CSDK.PaymentAddress>txIn.txIn.address,\n    },\n    {\n      address: <CSDK.PaymentAddress>txIn.txIn.address,\n      value: meshAssetsToCSDKValue(txIn.txIn.amount),\n    },\n  ];\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshUtxoToCSDKUtxo",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshUtxoToCSDKUtxo",
      "name": "meshUtxoToCSDKUtxo",
      "signature": "const meshUtxoToCSDKUtxo = (utxo: UTxO): CSDK.Utxo => {",
      "documentation": "",
      "parameters": [
        {
          "name": "utxo",
          "type": "UTxO",
          "optional": false
        }
      ],
      "returnType": "CSDK.Utxo",
      "isPublic": true,
      "line": 238,
      "raw": "const meshUtxoToCSDKUtxo = (utxo: UTxO): CSDK.Utxo => {\n  return [\n    {\n      txId: <CSDK.TransactionId>utxo.input.txHash,\n      index: utxo.input.outputIndex,\n      address: <CSDK.PaymentAddress>utxo.output.address,\n    },\n    {\n      address: <CSDK.PaymentAddress>utxo.output.address,\n      value: meshAssetsToCSDKValue(utxo.output.amount),\n      datumHash: meshDataHashToCSDKDataHash(utxo.output.dataHash),\n      datum: meshDatumToCSDKDatum(utxo.output.plutusData),\n      scriptReference: meshScriptReferenceToCSDKScriptReference(\n        utxo.output.scriptRef,\n      ),\n    },\n  ];\n};",
      "source": "mesh-transaction",
      "implementation": "const meshUtxoToCSDKUtxo = (utxo: UTxO): CSDK.Utxo => {\n  return [\n    {\n      txId: <CSDK.TransactionId>utxo.input.txHash,\n      index: utxo.input.outputIndex,\n      address: <CSDK.PaymentAddress>utxo.output.address,\n    },\n    {\n      address: <CSDK.PaymentAddress>utxo.output.address,\n      value: meshAssetsToCSDKValue(utxo.output.amount),\n      datumHash: meshDataHashToCSDKDataHash(utxo.output.dataHash),\n      datum: meshDatumToCSDKDatum(utxo.output.plutusData),\n      scriptReference: meshScriptReferenceToCSDKScriptReference(\n        utxo.output.scriptRef,\n      ),\n    },\n  ];\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshScriptReferenceToCSDKScriptReference",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshScriptReferenceToCSDKScriptReference",
      "name": "meshScriptReferenceToCSDKScriptReference",
      "signature": "const meshScriptReferenceToCSDKScriptReference = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 257,
      "raw": "const meshScriptReferenceToCSDKScriptReference = (\n  scriptReference?: string,\n): CSDK.Script | undefined => {\n  if (!scriptReference) {\n    return undefined;\n  }\n\n  return Serialization.Script.fromCbor(<HexBlob>scriptReference).toCore();\n};",
      "source": "mesh-transaction",
      "implementation": "const meshScriptReferenceToCSDKScriptReference = (\n  scriptReference?: string,\n): CSDK.Script | undefined => {\n  if (!scriptReference) {\n    return undefined;\n  }\n\n  return Serialization.Script.fromCbor(<HexBlob>scriptReference).toCore();\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshDatumToCSDKDatum",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshDatumToCSDKDatum",
      "name": "meshDatumToCSDKDatum",
      "signature": "const meshDatumToCSDKDatum = (datum?: string): CSDK.PlutusData | undefined => {",
      "documentation": "",
      "parameters": [
        {
          "name": "datum",
          "type": "string",
          "optional": true
        }
      ],
      "returnType": "CSDK.PlutusData | undefined",
      "isPublic": true,
      "line": 267,
      "raw": "const meshDatumToCSDKDatum = (datum?: string): CSDK.PlutusData | undefined => {\n  if (!datum) {\n    return undefined;\n  }\n\n  return Serialization.PlutusData.fromCbor(<HexBlob>datum).toCore();\n};",
      "source": "mesh-transaction",
      "implementation": "const meshDatumToCSDKDatum = (datum?: string): CSDK.PlutusData | undefined => {\n  if (!datum) {\n    return undefined;\n  }\n\n  return Serialization.PlutusData.fromCbor(<HexBlob>datum).toCore();\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshDataHashToCSDKDataHash",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshDataHashToCSDKDataHash",
      "name": "meshDataHashToCSDKDataHash",
      "signature": "const meshDataHashToCSDKDataHash = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 275,
      "raw": "const meshDataHashToCSDKDataHash = (\n  hash?: string,\n): CSDK.DatumHash | undefined => {\n  if (!hash) {\n    return undefined;\n  }\n  return <CSDK.DatumHash>hash;\n};",
      "source": "mesh-transaction",
      "implementation": "const meshDataHashToCSDKDataHash = (\n  hash?: string,\n): CSDK.DatumHash | undefined => {\n  if (!hash) {\n    return undefined;\n  }\n  return <CSDK.DatumHash>hash;\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshAssetsToCSDKValue",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshAssetsToCSDKValue",
      "name": "meshAssetsToCSDKValue",
      "signature": "const meshAssetsToCSDKValue = (assets?: Asset[]): CSDK.Value => {",
      "documentation": "",
      "parameters": [
        {
          "name": "assets",
          "type": "Asset[]",
          "optional": true
        }
      ],
      "returnType": "CSDK.Value",
      "isPublic": true,
      "line": 284,
      "raw": "const meshAssetsToCSDKValue = (assets?: Asset[]): CSDK.Value => {\n  if (!assets) {\n    throw new Error(\n      \"Missing required assets. Be sure that you resolve all required UTxOs\",\n    );\n  }\n\n  let lovelace = 0n;\n  const sdkAssets = new Map<CSDK.AssetId, bigint>();\n\n  for (const asset of assets) {\n    if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n      lovelace = BigInt(asset.quantity);\n    } else {\n      const assetId = <CSDK.AssetId>asset.unit;\n      sdkAssets.set(assetId, BigInt(asset.quantity));\n    }\n  }\n\n  if (sdkAssets.size === 0) {\n    return { coins: lovelace };\n  }\n\n  return {\n    coins: lovelace,\n    assets: sdkAssets,\n  };\n};",
      "source": "mesh-transaction",
      "implementation": "const meshAssetsToCSDKValue = (assets?: Asset[]): CSDK.Value => {\n  if (!assets) {\n    throw new Error(\n      \"Missing required assets. Be sure that you resolve all required UTxOs\",\n    );\n  }\n\n  let lovelace = 0n;\n  const sdkAssets = new Map<CSDK.AssetId, bigint>();\n\n  for (const asset of assets) {\n    if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n      lovelace = BigInt(asset.quantity);\n    } else {\n      const assetId = <CSDK.AssetId>asset.unit;\n      sdkAssets.set(assetId, BigInt(asset.quantity));\n    }\n  }\n\n  if (sdkAssets.size === 0) {\n    return { coins: lovelace };\n  }\n\n  return {\n    coins: lovelace,\n    assets: sdkAssets,\n  };\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshAssetsToCSDKAssets",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshAssetsToCSDKAssets",
      "name": "meshAssetsToCSDKAssets",
      "signature": "const meshAssetsToCSDKAssets = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 313,
      "raw": "const meshAssetsToCSDKAssets = (\n  assets?: Asset[],\n): CSDK.TokenMap | undefined => {\n  if (!assets) {\n    return undefined;\n  }\n\n  const sdkAssets = new Map<CSDK.AssetId, bigint>();\n\n  for (const asset of assets) {\n    if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n      throw new Error(\"Unexpected lovelace asset in assets\");\n    } else {\n      const assetId = <CSDK.AssetId>asset.unit;\n      sdkAssets.set(assetId, BigInt(asset.quantity));\n    }\n  }\n\n  return sdkAssets;\n};",
      "source": "mesh-transaction",
      "implementation": "const meshAssetsToCSDKAssets = (\n  assets?: Asset[],\n): CSDK.TokenMap | undefined => {\n  if (!assets) {\n    return undefined;\n  }\n\n  const sdkAssets = new Map<CSDK.AssetId, bigint>();\n\n  for (const asset of assets) {\n    if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n      throw new Error(\"Unexpected lovelace asset in assets\");\n    } else {\n      const assetId = <CSDK.AssetId>asset.unit;\n      sdkAssets.set(assetId, BigInt(asset.quantity));\n    }\n  }\n\n  return sdkAssets;\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSDKOutputToMeshOutput",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSDKOutputToMeshOutput",
      "name": "CSDKOutputToMeshOutput",
      "signature": "const CSDKOutputToMeshOutput = (output: CSDK.TxOut): TxOutput => {",
      "documentation": "",
      "parameters": [
        {
          "name": "output",
          "type": "CSDK.TxOut",
          "optional": false
        }
      ],
      "returnType": "TxOutput",
      "isPublic": true,
      "line": 334,
      "raw": "const CSDKOutputToMeshOutput = (output: CSDK.TxOut): TxOutput => {\n  const amount = CSDKValueToMeshAssets(output.value);\n  return {\n    address: output.address,\n    amount: amount,\n  };\n};",
      "source": "mesh-transaction",
      "implementation": "const CSDKOutputToMeshOutput = (output: CSDK.TxOut): TxOutput => {\n  const amount = CSDKValueToMeshAssets(output.value);\n  return {\n    address: output.address,\n    amount: amount,\n  };\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSDKValueToMeshAssets",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSDKValueToMeshAssets",
      "name": "CSDKValueToMeshAssets",
      "signature": "const CSDKValueToMeshAssets = (value: CSDK.Value): Asset[] => {",
      "documentation": "",
      "parameters": [
        {
          "name": "value",
          "type": "CSDK.Value",
          "optional": false
        }
      ],
      "returnType": "Asset[]",
      "isPublic": true,
      "line": 342,
      "raw": "const CSDKValueToMeshAssets = (value: CSDK.Value): Asset[] => {\n  const assets: Asset[] = [];\n\n  if (value.coins !== 0n) {\n    assets.push({\n      unit: \"lovelace\",\n      quantity: value.coins.toString(),\n    });\n  }\n\n  if (value.assets) {\n    for (const [assetId, quantity] of value.assets) {\n      assets.push({\n        unit: assetId,\n        quantity: quantity.toString(),\n      });\n    }\n  }\n\n  return assets;\n};",
      "source": "mesh-transaction",
      "implementation": "const CSDKValueToMeshAssets = (value: CSDK.Value): Asset[] => {\n  const assets: Asset[] = [];\n\n  if (value.coins !== 0n) {\n    assets.push({\n      unit: \"lovelace\",\n      quantity: value.coins.toString(),\n    });\n  }\n\n  if (value.assets) {\n    for (const [assetId, quantity] of value.assets) {\n      assets.push({\n        unit: assetId,\n        quantity: quantity.toString(),\n      });\n    }\n  }\n\n  return assets;\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSDKTokenMapToMeshAssets",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSDKTokenMapToMeshAssets",
      "name": "CSDKTokenMapToMeshAssets",
      "signature": "const CSDKTokenMapToMeshAssets = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 364,
      "raw": "const CSDKTokenMapToMeshAssets = (\n  tokenMap?: CSDK.TokenMap,\n): Asset[] | undefined => {\n  if (!tokenMap) {\n    return undefined;\n  }\n\n  const assets: Asset[] = [];\n\n  for (const [assetId, quantity] of tokenMap) {\n    assets.push({\n      unit: assetId,\n      quantity: quantity.toString(),\n    });\n  }\n\n  return assets;\n};",
      "source": "mesh-transaction",
      "implementation": "const CSDKTokenMapToMeshAssets = (\n  tokenMap?: CSDK.TokenMap,\n): Asset[] | undefined => {\n  if (!tokenMap) {\n    return undefined;\n  }\n\n  const assets: Asset[] = [];\n\n  for (const [assetId, quantity] of tokenMap) {\n    assets.push({\n      unit: assetId,\n      quantity: quantity.toString(),\n    });\n  }\n\n  return assets;\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshOutputToCSDKOutput",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshOutputToCSDKOutput",
      "name": "meshOutputToCSDKOutput",
      "signature": "const meshOutputToCSDKOutput = (output: Output): CSDK.TxOut => {",
      "documentation": "",
      "parameters": [
        {
          "name": "output",
          "type": "Output",
          "optional": false
        }
      ],
      "returnType": "CSDK.TxOut",
      "isPublic": true,
      "line": 383,
      "raw": "const meshOutputToCSDKOutput = (output: Output): CSDK.TxOut => {\n  const { dataHash, datum, scriptReference } =\n    meshOutputToCSDKOutputsScriptData(output);\n\n  return {\n    address: <CSDK.PaymentAddress>output.address,\n    value: meshAssetsToCSDKValue(output.amount),\n    datumHash: dataHash,\n    datum: datum,\n    scriptReference: scriptReference,\n  };\n};",
      "source": "mesh-transaction",
      "implementation": "const meshOutputToCSDKOutput = (output: Output): CSDK.TxOut => {\n  const { dataHash, datum, scriptReference } =\n    meshOutputToCSDKOutputsScriptData(output);\n\n  return {\n    address: <CSDK.PaymentAddress>output.address,\n    value: meshAssetsToCSDKValue(output.amount),\n    datumHash: dataHash,\n    datum: datum,\n    scriptReference: scriptReference,\n  };\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.makeAggregatedCSDKOOutput",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.makeAggregatedCSDKOOutput",
      "name": "makeAggregatedCSDKOOutput",
      "signature": "const makeAggregatedCSDKOOutput = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 396,
      "raw": "const makeAggregatedCSDKOOutput = (\n  outputs: Output[],\n): CSDK.TxOut | undefined => {\n  let totalAssets = new Map<string, bigint>();\n\n  for (const output of outputs) {\n    totalAssets = sumAssets(totalAssets, output.amount);\n  }\n\n  if (totalAssets.size === 0) {\n    return undefined;\n  }\n\n  return {\n    address: <CSDK.PaymentAddress>FAKE_ADDRESS,\n    value: assetsMapToCSDKValue(totalAssets),\n  };\n};",
      "source": "mesh-transaction",
      "implementation": "const makeAggregatedCSDKOOutput = (\n  outputs: Output[],\n): CSDK.TxOut | undefined => {\n  let totalAssets = new Map<string, bigint>();\n\n  for (const output of outputs) {\n    totalAssets = sumAssets(totalAssets, output.amount);\n  }\n\n  if (totalAssets.size === 0) {\n    return undefined;\n  }\n\n  return {\n    address: <CSDK.PaymentAddress>FAKE_ADDRESS,\n    value: assetsMapToCSDKValue(totalAssets),\n  };\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshOutputToCSDKOutputsScriptData",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshOutputToCSDKOutputsScriptData",
      "name": "meshOutputToCSDKOutputsScriptData",
      "signature": "const meshOutputToCSDKOutputsScriptData = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 415,
      "raw": "const meshOutputToCSDKOutputsScriptData = (\n  output: Output,\n): {\n  dataHash?: CSDK.DatumHash;\n  datum?: CSDK.PlutusData;\n  scriptReference?: CSDK.Script;\n} => {\n  let dataHash: CSDK.DatumHash | undefined = undefined;\n  let datum: CSDK.PlutusData | undefined = undefined;\n  let scriptReference: CSDK.Script | undefined;\n\n  if (output.datum?.type === \"Hash\") {\n    dataHash = meshDataHashToCSDKDataHash(\n      HexBlob(fromBuilderToPlutusData(output.datum.data).hash()),\n    );\n  } else if (output.datum?.type === \"Inline\") {\n    datum = meshDatumToCSDKDatum(\n      fromBuilderToPlutusData(output.datum.data).toCbor(),\n    );\n  } else if (output.datum?.type === \"Embedded\") {\n    throw new Error(\"Embedded datum is not supported\");\n  }\n\n  let meshCoreScript = undefined;\n  if (output.referenceScript) {\n    switch (output.referenceScript.version) {\n      case \"V1\": {\n        meshCoreScript = Script.newPlutusV1Script(\n          PlutusV1Script.fromCbor(HexBlob(output.referenceScript.code)),\n        );\n        break;\n      }\n      case \"V2\": {\n        meshCoreScript = Script.newPlutusV2Script(\n          PlutusV2Script.fromCbor(HexBlob(output.referenceScript.code)),\n        );\n        break;\n      }\n      case \"V3\": {\n        meshCoreScript = Script.newPlutusV3Script(\n          PlutusV3Script.fromCbor(HexBlob(output.referenceScript.code)),\n        );\n        break;\n      }\n    }\n  }\n\n  scriptReference = meshScriptReferenceToCSDKScriptReference(\n    meshCoreScript?.toCbor(),\n  );\n\n  return {\n    dataHash,\n    datum,\n    scriptReference,\n  };\n};",
      "source": "mesh-transaction",
      "implementation": "const meshOutputToCSDKOutputsScriptData = (\n  output: Output,\n): {\n  dataHash?: CSDK.DatumHash;\n  datum?: CSDK.PlutusData;\n  scriptReference?: CSDK.Script;\n} => {\n  let dataHash: CSDK.DatumHash | undefined = undefined;\n  let datum: CSDK.PlutusData | undefined = undefined;\n  let scriptReference: CSDK.Script | undefined;\n\n  if (output.datum?.type === \"Hash\") {\n    dataHash = meshDataHashToCSDKDataHash(\n      HexBlob(fromBuilderToPlutusData(output.datum.data).hash()),\n    );\n  } else if (output.datum?.type === \"Inline\") {\n    datum = meshDatumToCSDKDatum(\n      fromBuilderToPlutusData(output.datum.data).toCbor(),\n    );\n  } else if (output.datum?.type === \"Embedded\") {\n    throw new Error(\"Embedded datum is not supported\");\n  }\n\n  let meshCoreScript = undefined;\n  if (output.referenceScript) {\n    switch (output.referenceScript.version) {\n      case \"V1\": {\n        meshCoreScript = Script.newPlutusV1Script(\n          PlutusV1Script.fromCbor(HexBlob(output.referenceScript.code)),\n        );\n        break;\n      }\n      case \"V2\": {\n        meshCoreScript = Script.newPlutusV2Script(\n          PlutusV2Script.fromCbor(HexBlob(output.referenceScript.code)),\n        );\n        break;\n      }\n      case \"V3\": {\n        meshCoreScript = Script.newPlutusV3Script(\n          PlutusV3Script.fromCbor(HexBlob(output.referenceScript.code)),\n        );\n        break;\n      }\n    }\n  }\n\n  scriptReference = meshScriptReferenceToCSDKScriptReference(\n    meshCoreScript?.toCbor(),\n  );\n\n  return {\n    dataHash,\n    datum,\n    scriptReference,\n  };\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.assetsMapToCSDKValue",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.assetsMapToCSDKValue",
      "name": "assetsMapToCSDKValue",
      "signature": "const assetsMapToCSDKValue = (assets: Map<string, bigint>): CSDK.Value => {",
      "documentation": "",
      "parameters": [
        {
          "name": "assets",
          "type": "Map<string, bigint>",
          "optional": false
        }
      ],
      "returnType": "CSDK.Value",
      "isPublic": true,
      "line": 473,
      "raw": "const assetsMapToCSDKValue = (assets: Map<string, bigint>): CSDK.Value => {\n  let lovelace = 0n;\n  const sdkAssets = new Map<CSDK.AssetId, bigint>();\n\n  for (const [unit, quantity] of assets) {\n    if (unit === \"lovelace\" || unit === \"\") {\n      lovelace = BigInt(quantity);\n    } else {\n      const assetId = <CSDK.AssetId>unit;\n      sdkAssets.set(assetId, BigInt(quantity));\n    }\n  }\n\n  if (sdkAssets.size === 0) {\n    return { coins: lovelace };\n  }\n\n  return {\n    coins: lovelace,\n    assets: sdkAssets,\n  };\n};",
      "source": "mesh-transaction",
      "implementation": "const assetsMapToCSDKValue = (assets: Map<string, bigint>): CSDK.Value => {\n  let lovelace = 0n;\n  const sdkAssets = new Map<CSDK.AssetId, bigint>();\n\n  for (const [unit, quantity] of assets) {\n    if (unit === \"lovelace\" || unit === \"\") {\n      lovelace = BigInt(quantity);\n    } else {\n      const assetId = <CSDK.AssetId>unit;\n      sdkAssets.set(assetId, BigInt(quantity));\n    }\n  }\n\n  if (sdkAssets.size === 0) {\n    return { coins: lovelace };\n  }\n\n  return {\n    coins: lovelace,\n    assets: sdkAssets,\n  };\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.sumAssets",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.sumAssets",
      "name": "sumAssets",
      "signature": "const sumAssets = (a: Map<string, bigint>, b: Asset[]): Map<string, bigint> => {",
      "documentation": "",
      "parameters": [
        {
          "name": "a",
          "type": "Map<string, bigint>",
          "optional": false
        },
        {
          "name": "b",
          "type": "Asset[]",
          "optional": false
        }
      ],
      "returnType": "Map<string, bigint>",
      "isPublic": true,
      "line": 496,
      "raw": "const sumAssets = (a: Map<string, bigint>, b: Asset[]): Map<string, bigint> => {\n  for (const asset of b) {\n    const currentAmount = a.get(asset.unit) ?? 0n;\n    a.set(asset.unit, currentAmount + BigInt(asset.quantity));\n  }\n  return a;\n};",
      "source": "mesh-transaction",
      "implementation": "const sumAssets = (a: Map<string, bigint>, b: Asset[]): Map<string, bigint> => {\n  for (const asset of b) {\n    const currentAmount = a.get(asset.unit) ?? 0n;\n    a.set(asset.unit, currentAmount + BigInt(asset.quantity));\n  }\n  return a;\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshImplicitCoinToCSDKImplicitCoins",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshImplicitCoinToCSDKImplicitCoins",
      "name": "meshImplicitCoinToCSDKImplicitCoins",
      "signature": "const meshImplicitCoinToCSDKImplicitCoins = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 504,
      "raw": "const meshImplicitCoinToCSDKImplicitCoins = (\n  implicitCoins?: ImplicitValue,\n): CardanoSelection.ImplicitValue | undefined => {\n  if (!implicitCoins) {\n    return undefined;\n  }\n  const mint = meshAssetsToCSDKAssets(implicitCoins.mint);\n  const totalInput = implicitCoins.reclaimDeposit + implicitCoins.withdrawals;\n  const CSKDImplicitCoin = {\n    withdrawals: implicitCoins.withdrawals,\n    input: totalInput,\n    deposit: implicitCoins.deposit,\n    reclaimDeposit: implicitCoins.reclaimDeposit,\n  };\n\n  return {\n    coin: CSKDImplicitCoin,\n    mint: mint,\n  };\n};",
      "source": "mesh-transaction",
      "implementation": "const meshImplicitCoinToCSDKImplicitCoins = (\n  implicitCoins?: ImplicitValue,\n): CardanoSelection.ImplicitValue | undefined => {\n  if (!implicitCoins) {\n    return undefined;\n  }\n  const mint = meshAssetsToCSDKAssets(implicitCoins.mint);\n  const totalInput = implicitCoins.reclaimDeposit + implicitCoins.withdrawals;\n  const CSKDImplicitCoin = {\n    withdrawals: implicitCoins.withdrawals,\n    input: totalInput,\n    deposit: implicitCoins.deposit,\n    reclaimDeposit: implicitCoins.reclaimDeposit,\n  };\n\n  return {\n    coin: CSKDImplicitCoin,\n    mint: mint,\n  };\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshActionToCSDKRedeemer",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshActionToCSDKRedeemer",
      "name": "meshActionToCSDKRedeemer",
      "signature": "const meshActionToCSDKRedeemer = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 525,
      "raw": "const meshActionToCSDKRedeemer = (\n  action: Omit<Action, \"data\">,\n): CSDK.Redeemer => {\n  return {\n    purpose: meshRedeemerTagToCSDKRedeemerTag(action.tag),\n    index: action.index,\n    executionUnits: {\n      steps: action.budget.steps,\n      memory: action.budget.mem,\n    },\n    data: 0n,\n  };\n};",
      "source": "mesh-transaction",
      "implementation": "const meshActionToCSDKRedeemer = (\n  action: Omit<Action, \"data\">,\n): CSDK.Redeemer => {\n  return {\n    purpose: meshRedeemerTagToCSDKRedeemerTag(action.tag),\n    index: action.index,\n    executionUnits: {\n      steps: action.budget.steps,\n      memory: action.budget.mem,\n    },\n    data: 0n,\n  };\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSDKRedeemerToMeshAction",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSDKRedeemerToMeshAction",
      "name": "CSDKRedeemerToMeshAction",
      "signature": "const CSDKRedeemerToMeshAction = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 539,
      "raw": "const CSDKRedeemerToMeshAction = (\n  redeemer: CSDK.Redeemer,\n): Omit<Action, \"data\"> => {\n  return {\n    tag: CSDKRedeemerTagToMeshRedeemerTag(redeemer.purpose),\n    index: redeemer.index,\n    budget: {\n      steps: redeemer.executionUnits.steps,\n      mem: redeemer.executionUnits.memory,\n    },\n  };\n};",
      "source": "mesh-transaction",
      "implementation": "const CSDKRedeemerToMeshAction = (\n  redeemer: CSDK.Redeemer,\n): Omit<Action, \"data\"> => {\n  return {\n    tag: CSDKRedeemerTagToMeshRedeemerTag(redeemer.purpose),\n    index: redeemer.index,\n    budget: {\n      steps: redeemer.executionUnits.steps,\n      mem: redeemer.executionUnits.memory,\n    },\n  };\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshRedeemerTagToCSDKRedeemerTag",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshRedeemerTagToCSDKRedeemerTag",
      "name": "meshRedeemerTagToCSDKRedeemerTag",
      "signature": "const meshRedeemerTagToCSDKRedeemerTag = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 552,
      "raw": "const meshRedeemerTagToCSDKRedeemerTag = (\n  tag: RedeemerTagType,\n): CSDK.RedeemerPurpose => {\n  switch (tag) {\n    case \"SPEND\":\n      return CSDK.RedeemerPurpose.spend;\n    case \"MINT\":\n      return CSDK.RedeemerPurpose.mint;\n    case \"CERT\":\n      return CSDK.RedeemerPurpose.certificate;\n    case \"REWARD\":\n      return CSDK.RedeemerPurpose.withdrawal;\n    case \"PROPOSE\":\n      return CSDK.RedeemerPurpose.propose;\n    case \"VOTE\":\n      return CSDK.RedeemerPurpose.vote;\n  }\n};",
      "source": "mesh-transaction",
      "implementation": "const meshRedeemerTagToCSDKRedeemerTag = (\n  tag: RedeemerTagType,\n): CSDK.RedeemerPurpose => {\n  switch (tag) {\n    case \"SPEND\":\n      return CSDK.RedeemerPurpose.spend;\n    case \"MINT\":\n      return CSDK.RedeemerPurpose.mint;\n    case \"CERT\":\n      return CSDK.RedeemerPurpose.certificate;\n    case \"REWARD\":\n      return CSDK.RedeemerPurpose.withdrawal;\n    case \"PROPOSE\":\n      return CSDK.RedeemerPurpose.propose;\n    case \"VOTE\":\n      return CSDK.RedeemerPurpose.vote;\n  }\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSDKRedeemerTagToMeshRedeemerTag",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSDKRedeemerTagToMeshRedeemerTag",
      "name": "CSDKRedeemerTagToMeshRedeemerTag",
      "signature": "const CSDKRedeemerTagToMeshRedeemerTag = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 571,
      "raw": "const CSDKRedeemerTagToMeshRedeemerTag = (\n  tag: CSDK.RedeemerPurpose,\n): RedeemerTagType => {\n  switch (tag) {\n    case CSDK.RedeemerPurpose.spend:\n      return \"SPEND\";\n    case CSDK.RedeemerPurpose.mint:\n      return \"MINT\";\n    case CSDK.RedeemerPurpose.certificate:\n      return \"CERT\";\n    case CSDK.RedeemerPurpose.withdrawal:\n      return \"REWARD\";\n    case CSDK.RedeemerPurpose.propose:\n      return \"PROPOSE\";\n    case CSDK.RedeemerPurpose.vote:\n      return \"VOTE\";\n  }\n};",
      "source": "mesh-transaction",
      "implementation": "const CSDKRedeemerTagToMeshRedeemerTag = (\n  tag: CSDK.RedeemerPurpose,\n): RedeemerTagType => {\n  switch (tag) {\n    case CSDK.RedeemerPurpose.spend:\n      return \"SPEND\";\n    case CSDK.RedeemerPurpose.mint:\n      return \"MINT\";\n    case CSDK.RedeemerPurpose.certificate:\n      return \"CERT\";\n    case CSDK.RedeemerPurpose.withdrawal:\n      return \"REWARD\";\n    case CSDK.RedeemerPurpose.propose:\n      return \"PROPOSE\";\n    case CSDK.RedeemerPurpose.vote:\n      return \"VOTE\";\n  }\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.serializeMockTx",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.serializeMockTx",
      "name": "serializeMockTx",
      "signature": "serializeMockTx = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 101,
      "raw": "  serializeMockTx = () => {\n    const builderBody = this.meshTxBuilderBody;\n    const { keyHashes, byronAddresses } = this.collectAllRequiredSignatures();\n    builderBody.expectedNumberKeyWitnesses = keyHashes.size;\n    builderBody.expectedByronAddressWitnesses = Array.from(byronAddresses);\n    return this.serializer.serializeTxBodyWithMockSignatures(\n      this.meshTxBuilderBody,\n      this._protocolParams,\n    );\n  };",
      "source": "mesh-transaction",
      "implementation": "  serializeMockTx = () => {\n    const builderBody = this.meshTxBuilderBody;\n    const { keyHashes, byronAddresses } = this.collectAllRequiredSignatures();\n    builderBody.expectedNumberKeyWitnesses = keyHashes.size;\n    builderBody.expectedByronAddressWitnesses = Array.from(byronAddresses);\n    return this.serializer.serializeTxBodyWithMockSignatures(\n      this.meshTxBuilderBody,\n      this._protocolParams,\n    );\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.completeSync",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.completeSync",
      "name": "completeSync",
      "signature": "completeSync = (customizedTx?: MeshTxBuilderBody) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "customizedTx",
          "type": "MeshTxBuilderBody",
          "optional": true
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 131,
      "raw": "  completeSync = (customizedTx?: MeshTxBuilderBody) => {\n    if (customizedTx) {\n      this.meshTxBuilderBody = customizedTx;\n    } else {\n      this.queueAllLastItem();\n    }\n    this.removeDuplicateInputs();\n    this.removeDuplicateRefInputs();\n    this.addUtxosFromSelection();\n    return this.serializer.serializeTxBody(\n      this.meshTxBuilderBody,\n      this._protocolParams,\n    );\n  };",
      "source": "mesh-transaction",
      "implementation": "  completeSync = (customizedTx?: MeshTxBuilderBody) => {\n    if (customizedTx) {\n      this.meshTxBuilderBody = customizedTx;\n    } else {\n      this.queueAllLastItem();\n    }\n    this.removeDuplicateInputs();\n    this.removeDuplicateRefInputs();\n    this.addUtxosFromSelection();\n    return this.serializer.serializeTxBody(\n      this.meshTxBuilderBody,\n      this._protocolParams,\n    );\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.async",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.async",
      "name": "async",
      "signature": "async (): Promise<CoinSelectionInterface.TransactionPrototype> => {",
      "documentation": "",
      "parameters": [],
      "returnType": "Promise<CoinSelectionInterface.TransactionPrototype>",
      "isPublic": true,
      "line": 205,
      "raw": "    async (): Promise<CoinSelectionInterface.TransactionPrototype> => {\n      const callbacks: CoinSelectionInterface.BuilderCallbacks = {\n        computeMinimumCost: async (\n          selectionSkeleton: TransactionPrototype,\n        ): Promise<TransactionCost> => {\n          const clonedBuilder = this.clone();\n          await clonedBuilder.updateByTxPrototype(selectionSkeleton);\n\n          try {\n            await clonedBuilder.evaluateRedeemers();\n          } catch (error) {\n            if (error instanceof Error) {\n              throw new Error(`Evaluate redeemers failed: ${error.message}`);\n            } else if (typeof error === \"string\") {\n              throw new Error(`Evaluate redeemers failed: ${error}`);\n            } else if (typeof error === \"object\") {\n              throw new Error(\n                `Evaluate redeemers failed: ${JSON.stringify(error)}`,\n              );\n            } else {\n              throw new Error(`Evaluate redeemers failed: ${String(error)}`);\n            }\n          }\n          const fee = clonedBuilder.getActualFee();\n          const redeemers = clonedBuilder.getRedeemerCosts();\n          return {\n            fee,\n            redeemers,\n          };\n        },\n        tokenBundleSizeExceedsLimit: (tokenBundle) => {\n          const maxValueSize = this._protocolParams.maxValSize;\n          if (tokenBundle) {\n            const valueSize =\n              this.serializer.serializeValue(tokenBundle).length / 2;\n            return valueSize > maxValueSize;\n          }\n          return false;\n        },\n        computeMinimumCoinQuantity: (output) => {\n          return this.calculateMinLovelaceForOutput(output);\n        },\n        maxSizeExceed: async (selectionSkeleton) => {\n          const clonedBuilder = this.clone();\n          await clonedBuilder.updateByTxPrototype(selectionSkeleton);\n          const maxTxSize = this._protocolParams.maxTxSize;\n          const txSize = clonedBuilder.getSerializedSize();\n          return txSize > maxTxSize;\n        },\n      };\n\n      const currentInputs = this.meshTxBuilderBody.inputs;\n      const currentOutputs = this.meshTxBuilderBody.outputs;\n      const changeAddress = this.meshTxBuilderBody.changeAddress;\n      const utxosForSelection = await this.getUtxosForSelection();\n      const implicitValue = {\n        withdrawals: this.getTotalWithdrawal(),\n        deposit: this.getTotalDeposit(),\n        reclaimDeposit: this.getTotalRefund(),\n        mint: this.getTotalMint(),\n      };\n\n      const inputSelector = new CardanoSdkInputSelector(callbacks);\n      return await inputSelector.select(\n        currentInputs,\n        currentOutputs,\n        implicitValue,\n        utxosForSelection,\n        changeAddress,\n      );\n    };",
      "source": "mesh-transaction",
      "implementation": "    async (): Promise<CoinSelectionInterface.TransactionPrototype> => {\n      const callbacks: CoinSelectionInterface.BuilderCallbacks = {\n        computeMinimumCost: async (\n          selectionSkeleton: TransactionPrototype,\n        ): Promise<TransactionCost> => {\n          const clonedBuilder = this.clone();\n          await clonedBuilder.updateByTxPrototype(selectionSkeleton);\n\n          try {\n            await clonedBuilder.evaluateRedeemers();\n          } catch (error) {\n            if (error instanceof Error) {\n              throw new Error(`Evaluate redeemers failed: ${error.message}`);\n            } else if (typeof error === \"string\") {\n              throw new Error(`Evaluate redeemers failed: ${error}`);\n            } else if (typeof error === \"object\") {\n              throw new Error(\n                `Evaluate redeemers failed: ${JSON.stringify(error)}`,\n              );\n            } else {\n              throw new Error(`Evaluate redeemers failed: ${String(error)}`);\n            }\n          }\n          const fee = clonedBuilder.getActualFee();\n          const redeemers = clonedBuilder.getRedeemerCosts();\n          return {\n            fee,\n            redeemers,\n          };\n        },\n        tokenBundleSizeExceedsLimit: (tokenBundle) => {\n          const maxValueSize = this._protocolParams.maxValSize;\n          if (tokenBundle) {\n            const valueSize =\n              this.serializer.serializeValue(tokenBundle).length / 2;\n            return valueSize > maxValueSize;\n          }\n          return false;\n        },\n        computeMinimumCoinQuantity: (output) => {\n          return this.calculateMinLovelaceForOutput(output);\n        },\n        maxSizeExceed: async (selectionSkeleton) => {\n          const clonedBuilder = this.clone();\n          await clonedBuilder.updateByTxPrototype(selectionSkeleton);\n          const maxTxSize = this._protocolParams.maxTxSize;\n          const txSize = clonedBuilder.getSerializedSize();\n          return txSize > maxTxSize;\n        },\n      };\n\n      const currentInputs = this.meshTxBuilderBody.inputs;\n      const currentOutputs = this.meshTxBuilderBody.outputs;\n      const changeAddress = this.meshTxBuilderBody.changeAddress;\n      const utxosForSelection = await this.getUtxosForSelection();\n      const implicitValue = {\n        withdrawals: this.getTotalWithdrawal(),\n        deposit: this.getTotalDeposit(),\n        reclaimDeposit: this.getTotalRefund(),\n        mint: this.getTotalMint(),\n      };\n\n      const inputSelector = new CardanoSdkInputSelector(callbacks);\n      return await inputSelector.select(\n        currentInputs,\n        currentOutputs,\n        implicitValue,\n        utxosForSelection,\n        changeAddress,\n      );\n    };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.sortTxParts",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.sortTxParts",
      "name": "sortTxParts",
      "signature": "sortTxParts = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 322,
      "raw": "  sortTxParts = () => {\n    this.sortInputs();\n    this.sortMints();\n    this.sortWithdrawals();\n    this.sortVotes();\n  };",
      "source": "mesh-transaction",
      "implementation": "  sortTxParts = () => {\n    this.sortInputs();\n    this.sortMints();\n    this.sortWithdrawals();\n    this.sortVotes();\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.sortInputs",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.sortInputs",
      "name": "sortInputs",
      "signature": "sortInputs = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 329,
      "raw": "  sortInputs = () => {\n    // Sort inputs based on txHash and txIndex\n    this.meshTxBuilderBody.inputs.sort((a, b) => {\n      if (a.txIn.txHash < b.txIn.txHash) return -1;\n      if (a.txIn.txHash > b.txIn.txHash) return 1;\n      if (a.txIn.txIndex < b.txIn.txIndex) return -1;\n      if (a.txIn.txIndex > b.txIn.txIndex) return 1;\n      return 0;\n    });\n  };",
      "source": "mesh-transaction",
      "implementation": "  sortInputs = () => {\n    // Sort inputs based on txHash and txIndex\n    this.meshTxBuilderBody.inputs.sort((a, b) => {\n      if (a.txIn.txHash < b.txIn.txHash) return -1;\n      if (a.txIn.txHash > b.txIn.txHash) return 1;\n      if (a.txIn.txIndex < b.txIn.txIndex) return -1;\n      if (a.txIn.txIndex > b.txIn.txIndex) return 1;\n      return 0;\n    });\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.sortMints",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.sortMints",
      "name": "sortMints",
      "signature": "sortMints = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 340,
      "raw": "  sortMints = () => {\n    // Sort mints based on policy id\n    this.meshTxBuilderBody.mints.sort((a, b) => {\n      if (a.policyId < b.policyId) return -1;\n      if (a.policyId > b.policyId) return 1;\n      return 0;\n    });\n  };",
      "source": "mesh-transaction",
      "implementation": "  sortMints = () => {\n    // Sort mints based on policy id\n    this.meshTxBuilderBody.mints.sort((a, b) => {\n      if (a.policyId < b.policyId) return -1;\n      if (a.policyId > b.policyId) return 1;\n      return 0;\n    });\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.sortWithdrawals",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.sortWithdrawals",
      "name": "sortWithdrawals",
      "signature": "sortWithdrawals = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 375,
      "raw": "  sortWithdrawals = () => {\n    this.meshTxBuilderBody.withdrawals.sort((a, b) => {\n      const credentialA = CstAddress.fromString(a.address)\n        ?.asReward()\n        ?.getPaymentCredential();\n      const credentialB = CstAddress.fromString(b.address)\n        ?.asReward()\n        ?.getPaymentCredential();\n      if (credentialA && credentialB) {\n        return this.compareCredentials(credentialA, credentialB);\n      }\n      return 0;\n    });\n  };",
      "source": "mesh-transaction",
      "implementation": "  sortWithdrawals = () => {\n    this.meshTxBuilderBody.withdrawals.sort((a, b) => {\n      const credentialA = CstAddress.fromString(a.address)\n        ?.asReward()\n        ?.getPaymentCredential();\n      const credentialB = CstAddress.fromString(b.address)\n        ?.asReward()\n        ?.getPaymentCredential();\n      if (credentialA && credentialB) {\n        return this.compareCredentials(credentialA, credentialB);\n      }\n      return 0;\n    });\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.sortVotes",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.sortVotes",
      "name": "sortVotes",
      "signature": "sortVotes = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 390,
      "raw": "  sortVotes = () => {\n    const variantOrder: Record<Voter[\"type\"], number> = {\n      ConstitutionalCommittee: 0,\n      DRep: 1,\n      StakingPool: 2,\n    };\n    this.meshTxBuilderBody.votes.sort((a, b) => {\n      const voterA = a.vote.voter;\n      const voterB = b.vote.voter;\n      const orderA = variantOrder[voterA.type];\n      const orderB = variantOrder[voterB.type];\n      if (orderA !== orderB) return orderA - orderB;\n\n      // Same variant, compare inner values\n      if (\n        voterA.type === \"ConstitutionalCommittee\" &&\n        voterB.type === \"ConstitutionalCommittee\"\n      ) {\n        const credA = voterA.hotCred;\n        const credB = voterB.hotCred;\n        // Script credentials come before Key credentials\n        if (credA.type === \"ScriptHash\" && credB.type === \"KeyHash\") {\n          return -1;\n        }\n        if (credA.type === \"KeyHash\" && credB.type === \"ScriptHash\") {\n          return 1;\n        }\n        // If same type, compare the hashes\n        if (credA.type === credB.type) {\n          const hashA =\n            credA.type === \"KeyHash\" ? credA.keyHash : credA.scriptHash;\n          const hashB =\n            credB.type === \"KeyHash\" ? credB.keyHash : credB.scriptHash;\n          if (hashA < hashB) return -1;\n          if (hashA > hashB) return 1;\n          return 0;\n        }\n        return 0;\n      }\n      if (voterA.type === \"DRep\" && voterB.type === \"DRep\") {\n        const drepA = coreToCstDRep(voterA.drepId);\n        const drepB = coreToCstDRep(voterB.drepId);\n        const scriptHashA = drepA.toScriptHash();\n        const scriptHashB = drepB.toScriptHash();\n        const keyHashA = drepA.toKeyHash();\n        const keyHashB = drepB.toKeyHash();\n\n        // Script hashes come before key hashes\n        if (scriptHashA != null && scriptHashB != null) {\n          if (scriptHashA < scriptHashB) return -1;\n          if (scriptHashA > scriptHashB) return 1;\n          return 0;\n        }\n        if (scriptHashA != null) return -1;\n        if (scriptHashB != null) return 1;\n        // If both are key hashes, compare them\n        if (keyHashA != null && keyHashB != null) {\n          if (keyHashA < keyHashB) return -1;\n          if (keyHashA > keyHashB) return 1;\n          return 0;\n        }\n        return 0;\n      }\n      if (voterA.type === \"StakingPool\" && voterB.type === \"StakingPool\") {\n        if (voterA.keyHash < voterB.keyHash) return -1;\n        if (voterA.keyHash > voterB.keyHash) return 1;\n        return 0;\n      }\n      return 0;\n    });\n  };",
      "source": "mesh-transaction",
      "implementation": "  sortVotes = () => {\n    const variantOrder: Record<Voter[\"type\"], number> = {\n      ConstitutionalCommittee: 0,\n      DRep: 1,\n      StakingPool: 2,\n    };\n    this.meshTxBuilderBody.votes.sort((a, b) => {\n      const voterA = a.vote.voter;\n      const voterB = b.vote.voter;\n      const orderA = variantOrder[voterA.type];\n      const orderB = variantOrder[voterB.type];\n      if (orderA !== orderB) return orderA - orderB;\n\n      // Same variant, compare inner values\n      if (\n        voterA.type === \"ConstitutionalCommittee\" &&\n        voterB.type === \"ConstitutionalCommittee\"\n      ) {\n        const credA = voterA.hotCred;\n        const credB = voterB.hotCred;\n        // Script credentials come before Key credentials\n        if (credA.type === \"ScriptHash\" && credB.type === \"KeyHash\") {\n          return -1;\n        }\n        if (credA.type === \"KeyHash\" && credB.type === \"ScriptHash\") {\n          return 1;\n        }\n        // If same type, compare the hashes\n        if (credA.type === credB.type) {\n          const hashA =\n            credA.type === \"KeyHash\" ? credA.keyHash : credA.scriptHash;\n          const hashB =\n            credB.type === \"KeyHash\" ? credB.keyHash : credB.scriptHash;\n          if (hashA < hashB) return -1;\n          if (hashA > hashB) return 1;\n          return 0;\n        }\n        return 0;\n      }\n      if (voterA.type === \"DRep\" && voterB.type === \"DRep\") {\n        const drepA = coreToCstDRep(voterA.drepId);\n        const drepB = coreToCstDRep(voterB.drepId);\n        const scriptHashA = drepA.toScriptHash();\n        const scriptHashB = drepB.toScriptHash();\n        const keyHashA = drepA.toKeyHash();\n        const keyHashB = drepB.toKeyHash();\n\n        // Script hashes come before key hashes\n        if (scriptHashA != null && scriptHashB != null) {\n          if (scriptHashA < scriptHashB) return -1;\n          if (scriptHashA > scriptHashB) return 1;\n          return 0;\n        }\n        if (scriptHashA != null) return -1;\n        if (scriptHashB != null) return 1;\n        // If both are key hashes, compare them\n        if (keyHashA != null && keyHashB != null) {\n          if (keyHashA < keyHashB) return -1;\n          if (keyHashA > keyHashB) return 1;\n          return 0;\n        }\n        return 0;\n      }\n      if (voterA.type === \"StakingPool\" && voterB.type === \"StakingPool\") {\n        if (voterA.keyHash < voterB.keyHash) return -1;\n        if (voterA.keyHash > voterB.keyHash) return 1;\n        return 0;\n      }\n      return 0;\n    });\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.completeUnbalancedSync",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.completeUnbalancedSync",
      "name": "completeUnbalancedSync",
      "signature": "completeUnbalancedSync = (customizedTx?: MeshTxBuilderBody) => {",
      "documentation": "  /**\n   * It builds the transaction without dependencies\n   * @param customizedTx The optional customized transaction body\n   * @returns The transaction in hex, unbalanced\n   */",
      "parameters": [
        {
          "name": "customizedTx",
          "type": "MeshTxBuilderBody",
          "optional": true
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 558,
      "raw": "  /**\n   * It builds the transaction without dependencies\n   * @param customizedTx The optional customized transaction body\n   * @returns The transaction in hex, unbalanced\n   */\n  completeUnbalancedSync = (customizedTx?: MeshTxBuilderBody) => {\n    if (customizedTx) {\n      this.meshTxBuilderBody = customizedTx;\n      if (customizedTx.fee) {\n        this.setFee(customizedTx.fee);\n      }\n    } else {\n      this.queueAllLastItem();\n    }\n    this.removeDuplicateInputs();\n    this.removeDuplicateRefInputs();\n    return this.serializer.serializeTxBody(\n      this.meshTxBuilderBody,\n      this._protocolParams,\n    );\n  };",
      "source": "mesh-transaction",
      "implementation": "  completeUnbalancedSync = (customizedTx?: MeshTxBuilderBody) => {\n    if (customizedTx) {\n      this.meshTxBuilderBody = customizedTx;\n      if (customizedTx.fee) {\n        this.setFee(customizedTx.fee);\n      }\n    } else {\n      this.queueAllLastItem();\n    }\n    this.removeDuplicateInputs();\n    this.removeDuplicateRefInputs();\n    return this.serializer.serializeTxBody(\n      this.meshTxBuilderBody,\n      this._protocolParams,\n    );\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.completeSigning",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.completeSigning",
      "name": "completeSigning",
      "signature": "completeSigning = () => {",
      "documentation": "  /**\n   * Complete the signing process\n   * @returns The signed transaction in hex\n   */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 579,
      "raw": "  /**\n   * Complete the signing process\n   * @returns The signed transaction in hex\n   */\n  completeSigning = () => {\n    const signedTxHex = this.serializer.addSigningKeys(\n      this.txHex,\n      this.meshTxBuilderBody.signingKey,\n    );\n    this.txHex = signedTxHex;\n    return signedTxHex;\n  };",
      "source": "mesh-transaction",
      "implementation": "  completeSigning = () => {\n    const signedTxHex = this.serializer.addSigningKeys(\n      this.txHex,\n      this.meshTxBuilderBody.signingKey,\n    );\n    this.txHex = signedTxHex;\n    return signedTxHex;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.minRefScriptFee",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.minRefScriptFee",
      "name": "minRefScriptFee",
      "signature": "function minRefScriptFee(",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 1750,
      "raw": "function minRefScriptFee(\n  totalRefScriptsSize: bigint,\n  refScriptCoinsPerByte: number,\n): bigint {\n  const multiplier = new BigNumber(12).dividedBy(new BigNumber(10)); // 1.2\n  const sizeIncrement = new BigNumber(25600);\n  const baseFee = new BigNumber(refScriptCoinsPerByte);\n\n  const totalSize = new BigNumber(totalRefScriptsSize.toString());\n\n  return tierRefScriptFee(multiplier, sizeIncrement, baseFee, totalSize);\n}",
      "source": "mesh-transaction",
      "implementation": "function minRefScriptFee(\n  totalRefScriptsSize: bigint,\n  refScriptCoinsPerByte: number,\n): bigint {\n  const multiplier = new BigNumber(12).dividedBy(new BigNumber(10)); // 1.2\n  const sizeIncrement = new BigNumber(25600);\n  const baseFee = new BigNumber(refScriptCoinsPerByte);\n\n  const totalSize = new BigNumber(totalRefScriptsSize.toString());\n\n  return tierRefScriptFee(multiplier, sizeIncrement, baseFee, totalSize);\n}"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.tierRefScriptFee",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.tierRefScriptFee",
      "name": "tierRefScriptFee",
      "signature": "function tierRefScriptFee(",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 1763,
      "raw": "function tierRefScriptFee(\n  multiplier: BigNumber,\n  sizeIncrement: BigNumber,\n  baseFee: BigNumber,\n  totalSize: BigNumber,\n): bigint {\n  if (multiplier.lte(0) || sizeIncrement.eq(0)) {\n    throw new Error(\"Size increment and multiplier must be positive\");\n  }\n\n  const fullTiers = totalSize.dividedToIntegerBy(sizeIncrement);\n  const partialTierSize = totalSize.mod(sizeIncrement);\n\n  const tierPrice = baseFee.multipliedBy(sizeIncrement);\n  let acc = new BigNumber(0);\n  const one = new BigNumber(1);\n\n  if (fullTiers.gt(0)) {\n    const multiplierPow = multiplier.pow(fullTiers.toNumber());\n    const progressionEnumerator = one.minus(multiplierPow);\n    const progressionDenom = one.minus(multiplier);\n    const tierProgressionSum =\n      progressionEnumerator.dividedBy(progressionDenom);\n    acc = acc.plus(tierPrice.multipliedBy(tierProgressionSum));\n  }\n\n  if (partialTierSize.gt(0)) {\n    const multiplierPow = multiplier.pow(fullTiers.toNumber());\n    const lastTierPrice = baseFee.multipliedBy(multiplierPow);\n    const partialTierFee = lastTierPrice.multipliedBy(partialTierSize);\n    acc = acc.plus(partialTierFee);\n  }\n\n  return BigInt(acc.integerValue(BigNumber.ROUND_FLOOR).toString());\n}",
      "source": "mesh-transaction",
      "implementation": "function tierRefScriptFee(\n  multiplier: BigNumber,\n  sizeIncrement: BigNumber,\n  baseFee: BigNumber,\n  totalSize: BigNumber,\n): bigint {\n  if (multiplier.lte(0) || sizeIncrement.eq(0)) {\n    throw new Error(\"Size increment and multiplier must be positive\");\n  }\n\n  const fullTiers = totalSize.dividedToIntegerBy(sizeIncrement);\n  const partialTierSize = totalSize.mod(sizeIncrement);\n\n  const tierPrice = baseFee.multipliedBy(sizeIncrement);\n  let acc = new BigNumber(0);\n  const one = new BigNumber(1);\n\n  if (fullTiers.gt(0)) {\n    const multiplierPow = multiplier.pow(fullTiers.toNumber());\n    const progressionEnumerator = one.minus(multiplierPow);\n    const progressionDenom = one.minus(multiplier);\n    const tierProgressionSum =\n      progressionEnumerator.dividedBy(progressionDenom);\n    acc = acc.plus(tierPrice.multipliedBy(tierProgressionSum));\n  }\n\n  if (partialTierSize.gt(0)) {\n    const multiplierPow = multiplier.pow(fullTiers.toNumber());\n    const lastTierPrice = baseFee.multipliedBy(multiplierPow);\n    const partialTierFee = lastTierPrice.multipliedBy(partialTierSize);\n    acc = acc.plus(partialTierFee);\n  }\n\n  return BigInt(acc.integerValue(BigNumber.ROUND_FLOOR).toString());\n}"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.cloneOutput",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.cloneOutput",
      "name": "cloneOutput",
      "signature": "export const cloneOutput = (output: Output): Output => {",
      "documentation": "",
      "parameters": [
        {
          "name": "output",
          "type": "Output",
          "optional": false
        }
      ],
      "returnType": "Output",
      "isPublic": true,
      "line": 1799,
      "raw": "export const cloneOutput = (output: Output): Output => {\n  return JSONBig.parse(JSONBig.stringify(output));\n};",
      "source": "mesh-transaction",
      "implementation": "export const cloneOutput = (output: Output): Output => {\n  return JSONBig.parse(JSONBig.stringify(output));\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.setLoveLace",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.setLoveLace",
      "name": "setLoveLace",
      "signature": "export const setLoveLace = (output: Output, lovelace: bigint): Output => {",
      "documentation": "",
      "parameters": [
        {
          "name": "output",
          "type": "Output",
          "optional": false
        },
        {
          "name": "lovelace",
          "type": "bigint",
          "optional": false
        }
      ],
      "returnType": "Output",
      "isPublic": true,
      "line": 1803,
      "raw": "export const setLoveLace = (output: Output, lovelace: bigint): Output => {\n  let lovelaceSet = false;\n  for (let asset of output.amount) {\n    if (asset.unit === \"lovelace\") {\n      asset.quantity = lovelace.toString();\n      lovelaceSet = true;\n      break;\n    }\n  }\n\n  if (!lovelaceSet) {\n    output.amount.push({\n      unit: \"lovelace\",\n      quantity: lovelace.toString(),\n    });\n  }\n  return output;\n};",
      "source": "mesh-transaction",
      "implementation": "export const setLoveLace = (output: Output, lovelace: bigint): Output => {\n  let lovelaceSet = false;\n  for (let asset of output.amount) {\n    if (asset.unit === \"lovelace\") {\n      asset.quantity = lovelace.toString();\n      lovelaceSet = true;\n      break;\n    }\n  }\n\n  if (!lovelaceSet) {\n    output.amount.push({\n      unit: \"lovelace\",\n      quantity: lovelace.toString(),\n    });\n  }\n  return output;\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.getLovelace",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.getLovelace",
      "name": "getLovelace",
      "signature": "export const getLovelace = (output: Output): bigint => {",
      "documentation": "",
      "parameters": [
        {
          "name": "output",
          "type": "Output",
          "optional": false
        }
      ],
      "returnType": "bigint",
      "isPublic": true,
      "line": 1822,
      "raw": "export const getLovelace = (output: Output): bigint => {\n  for (let asset of output.amount) {\n    if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n      return BigInt(asset.quantity);\n    }\n  }\n  return 0n;\n};",
      "source": "mesh-transaction",
      "implementation": "export const getLovelace = (output: Output): bigint => {\n  for (let asset of output.amount) {\n    if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n      return BigInt(asset.quantity);\n    }\n  }\n  return 0n;\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.getOutputMinLovelace",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.getOutputMinLovelace",
      "name": "getOutputMinLovelace",
      "signature": "export const getOutputMinLovelace = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 1831,
      "raw": "export const getOutputMinLovelace = (\n  output: Output,\n  coinsPerUtxoSize = DEFAULT_PROTOCOL_PARAMETERS.coinsPerUtxoSize,\n): bigint => {\n  const serializer = new CardanoSDKSerializer();\n  let currentOutput = cloneOutput(output);\n  let lovelace = getLovelace(currentOutput);\n  let minLovelace = 0n;\n  for (let i = 0; i < 3; i++) {\n    const txOutSize = BigInt(\n      serializer.serializeOutput(currentOutput).length / 2,\n    );\n    const txOutByteCost = BigInt(coinsPerUtxoSize);\n    const totalOutCost = (160n + BigInt(txOutSize)) * txOutByteCost;\n    minLovelace = totalOutCost;\n    if (lovelace < totalOutCost) {\n      lovelace = totalOutCost;\n    } else {\n      break;\n    }\n    currentOutput = setLoveLace(currentOutput, lovelace);\n  }\n\n  return minLovelace;\n};",
      "source": "mesh-transaction",
      "implementation": "export const getOutputMinLovelace = (\n  output: Output,\n  coinsPerUtxoSize = DEFAULT_PROTOCOL_PARAMETERS.coinsPerUtxoSize,\n): bigint => {\n  const serializer = new CardanoSDKSerializer();\n  let currentOutput = cloneOutput(output);\n  let lovelace = getLovelace(currentOutput);\n  let minLovelace = 0n;\n  for (let i = 0; i < 3; i++) {\n    const txOutSize = BigInt(\n      serializer.serializeOutput(currentOutput).length / 2,\n    );\n    const txOutByteCost = BigInt(coinsPerUtxoSize);\n    const totalOutCost = (160n + BigInt(txOutSize)) * txOutByteCost;\n    minLovelace = totalOutCost;\n    if (lovelace < totalOutCost) {\n      lovelace = totalOutCost;\n    } else {\n      break;\n    }\n    currentOutput = setLoveLace(currentOutput, lovelace);\n  }\n\n  return minLovelace;\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.totalOutCost",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.totalOutCost",
      "name": "totalOutCost",
      "signature": "const totalOutCost = (160n + BigInt(txOutSize)) * txOutByteCost;",
      "documentation": "",
      "parameters": [
        {
          "name": "160n + BigInt(txOutSize",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1844,
      "raw": "    const totalOutCost = (160n + BigInt(txOutSize)) * txOutByteCost;\n    minLovelace = totalOutCost;\n    if (lovelace < totalOutCost) {\n      lovelace = totalOutCost;\n    } else {\n      break;\n    }",
      "source": "mesh-transaction",
      "implementation": "    const totalOutCost = (160n + BigInt(txOutSize)) * txOutByteCost;\n    minLovelace = totalOutCost;\n    if (lovelace < totalOutCost) {\n      lovelace = totalOutCost;\n    } else {\n      break;\n    }"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.txInScript",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.txInScript",
      "name": "txInScript",
      "signature": "txInScript = (scriptCbor: string) => {",
      "documentation": "  /**\n   * Set the script for transaction input\n   * @param {string} scriptCbor The CborHex of the script\n   * @param version Optional - The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "scriptCbor",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 131,
      "raw": "  /**\n   * Set the script for transaction input\n   * @param {string} scriptCbor The CborHex of the script\n   * @param version Optional - The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */\n  txInScript = (scriptCbor: string) => {\n    if (!this.txInQueueItem) throw Error(\"Undefined input\");\n    if (this.txInQueueItem.type === \"PubKey\") {\n      this.txInQueueItem = {\n        type: \"SimpleScript\",\n        txIn: this.txInQueueItem.txIn,\n        simpleScriptTxIn: {\n          scriptSource: {\n            type: \"Provided\",\n            scriptCode: scriptCbor,\n          },\n        },\n      };\n    }\n    if (this.txInQueueItem.type === \"Script\") {\n      this.txInQueueItem.scriptTxIn.scriptSource = {\n        type: \"Provided\",\n        script: {\n          code: scriptCbor,\n          version: this.plutusSpendingScriptVersion || \"V2\",\n        },\n      };\n    }\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  txInScript = (scriptCbor: string) => {\n    if (!this.txInQueueItem) throw Error(\"Undefined input\");\n    if (this.txInQueueItem.type === \"PubKey\") {\n      this.txInQueueItem = {\n        type: \"SimpleScript\",\n        txIn: this.txInQueueItem.txIn,\n        simpleScriptTxIn: {\n          scriptSource: {\n            type: \"Provided\",\n            scriptCode: scriptCbor,\n          },\n        },\n      };\n    }\n    if (this.txInQueueItem.type === \"Script\") {\n      this.txInQueueItem.scriptTxIn.scriptSource = {\n        type: \"Provided\",\n        script: {\n          code: scriptCbor,\n          version: this.plutusSpendingScriptVersion || \"V2\",\n        },\n      };\n    }\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.txInInlineDatumPresent",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.txInInlineDatumPresent",
      "name": "txInInlineDatumPresent",
      "signature": "txInInlineDatumPresent = () => {",
      "documentation": "  /**\n   * Tell the transaction builder that the input UTxO has inlined datum\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 203,
      "raw": "  /**\n   * Tell the transaction builder that the input UTxO has inlined datum\n   * @returns The MeshTxBuilder instance\n   */\n  txInInlineDatumPresent = () => {\n    if (!this.txInQueueItem) throw Error(\"Undefined input\");\n    if (this.txInQueueItem.type === \"PubKey\")\n      throw Error(\n        \"Inline datum present attempted to be called a non script input\",\n      );\n    if (this.txInQueueItem.type === \"SimpleScript\")\n      throw Error(\n        \"Inline datum present attempted to be called on a simple script input\",\n      );\n    const { txHash, txIndex } = this.txInQueueItem.txIn;\n    if (txHash && txIndex.toString()) {\n      this.txInQueueItem.scriptTxIn.datumSource = {\n        type: \"Inline\",\n        txHash,\n        txIndex,\n      };\n    }\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  txInInlineDatumPresent = () => {\n    if (!this.txInQueueItem) throw Error(\"Undefined input\");\n    if (this.txInQueueItem.type === \"PubKey\")\n      throw Error(\n        \"Inline datum present attempted to be called a non script input\",\n      );\n    if (this.txInQueueItem.type === \"SimpleScript\")\n      throw Error(\n        \"Inline datum present attempted to be called on a simple script input\",\n      );\n    const { txHash, txIndex } = this.txInQueueItem.txIn;\n    if (txHash && txIndex.toString()) {\n      this.txInQueueItem.scriptTxIn.datumSource = {\n        type: \"Inline\",\n        txHash,\n        txIndex,\n      };\n    }\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.txOut",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.txOut",
      "name": "txOut",
      "signature": "txOut = (address: string, amount: Asset[]) => {",
      "documentation": "  /**\n   * Set the output for transaction\n   * @param {string} address The recipient of the output\n   * @param {Asset[]} amount The amount of other native assets attached with UTxO\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "address",
          "type": "string",
          "optional": false
        },
        {
          "name": "amount",
          "type": "Asset[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 301,
      "raw": "  /**\n   * Set the output for transaction\n   * @param {string} address The recipient of the output\n   * @param {Asset[]} amount The amount of other native assets attached with UTxO\n   * @returns The MeshTxBuilder instance\n   */\n  txOut = (address: string, amount: Asset[]) => {\n    if (this.txOutput) {\n      this.meshTxBuilderBody.outputs.push(this.txOutput);\n      this.txOutput = undefined;\n    }\n    this.txOutput = {\n      address,\n      amount,\n    };\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  txOut = (address: string, amount: Asset[]) => {\n    if (this.txOutput) {\n      this.meshTxBuilderBody.outputs.push(this.txOutput);\n      this.txOutput = undefined;\n    }\n    this.txOutput = {\n      address,\n      amount,\n    };\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.spendingPlutusScript",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.spendingPlutusScript",
      "name": "spendingPlutusScript",
      "signature": "spendingPlutusScript = (languageVersion: LanguageVersion) => {",
      "documentation": "  /**\n   * Set the reference script to be attached with the output\n   * @param languageVersion The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "languageVersion",
          "type": "LanguageVersion",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 443,
      "raw": "  /**\n   * Set the reference script to be attached with the output\n   * @param languageVersion The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */\n  spendingPlutusScript = (languageVersion: LanguageVersion) => {\n    // This flag should signal a start to a script input\n    // The next step after will be to add a tx-in\n    // After which, we will REQUIRE, script, datum and redeemer info\n    // for unlocking this particular input\n    this.addingPlutusScriptInput = true;\n    this.plutusSpendingScriptVersion = languageVersion;\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  spendingPlutusScript = (languageVersion: LanguageVersion) => {\n    // This flag should signal a start to a script input\n    // The next step after will be to add a tx-in\n    // After which, we will REQUIRE, script, datum and redeemer info\n    // for unlocking this particular input\n    this.addingPlutusScriptInput = true;\n    this.plutusSpendingScriptVersion = languageVersion;\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.spendingPlutusScriptV1",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.spendingPlutusScriptV1",
      "name": "spendingPlutusScriptV1",
      "signature": "spendingPlutusScriptV1 = () => {",
      "documentation": "  /**\n   * Set the instruction that it is currently using V1 Plutus spending scripts\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 456,
      "raw": "  /**\n   * Set the instruction that it is currently using V1 Plutus spending scripts\n   * @returns The MeshTxBuilder instance\n   */\n  spendingPlutusScriptV1 = () => {\n    // This flag should signal a start to a script input\n    // The next step after will be to add a tx-in\n    // After which, we will REQUIRE, script, datum and redeemer info\n    // for unlocking this particular input\n    this.addingPlutusScriptInput = true;\n    this.plutusSpendingScriptVersion = \"V1\";\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  spendingPlutusScriptV1 = () => {\n    // This flag should signal a start to a script input\n    // The next step after will be to add a tx-in\n    // After which, we will REQUIRE, script, datum and redeemer info\n    // for unlocking this particular input\n    this.addingPlutusScriptInput = true;\n    this.plutusSpendingScriptVersion = \"V1\";\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.spendingPlutusScriptV2",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.spendingPlutusScriptV2",
      "name": "spendingPlutusScriptV2",
      "signature": "spendingPlutusScriptV2 = () => {",
      "documentation": "  /**\n   * Set the instruction that it is currently using V2 Plutus spending scripts\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 469,
      "raw": "  /**\n   * Set the instruction that it is currently using V2 Plutus spending scripts\n   * @returns The MeshTxBuilder instance\n   */\n  spendingPlutusScriptV2 = () => {\n    // This flag should signal a start to a script input\n    // The next step after will be to add a tx-in\n    // After which, we will REQUIRE, script, datum and redeemer info\n    // for unlocking this particular input\n    this.addingPlutusScriptInput = true;\n    this.plutusSpendingScriptVersion = \"V2\";\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  spendingPlutusScriptV2 = () => {\n    // This flag should signal a start to a script input\n    // The next step after will be to add a tx-in\n    // After which, we will REQUIRE, script, datum and redeemer info\n    // for unlocking this particular input\n    this.addingPlutusScriptInput = true;\n    this.plutusSpendingScriptVersion = \"V2\";\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.spendingPlutusScriptV3",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.spendingPlutusScriptV3",
      "name": "spendingPlutusScriptV3",
      "signature": "spendingPlutusScriptV3 = () => {",
      "documentation": "  /**\n   * Set the instruction that it is currently using V3 Plutus spending scripts\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 482,
      "raw": "  /**\n   * Set the instruction that it is currently using V3 Plutus spending scripts\n   * @returns The MeshTxBuilder instance\n   */\n  spendingPlutusScriptV3 = () => {\n    // This flag should signal a start to a script input\n    // The next step after will be to add a tx-in\n    // After which, we will REQUIRE, script, datum and redeemer info\n    // for unlocking this particular input\n    this.addingPlutusScriptInput = true;\n    this.plutusSpendingScriptVersion = \"V3\";\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  spendingPlutusScriptV3 = () => {\n    // This flag should signal a start to a script input\n    // The next step after will be to add a tx-in\n    // After which, we will REQUIRE, script, datum and redeemer info\n    // for unlocking this particular input\n    this.addingPlutusScriptInput = true;\n    this.plutusSpendingScriptVersion = \"V3\";\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.spendingReferenceTxInInlineDatumPresent",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.spendingReferenceTxInInlineDatumPresent",
      "name": "spendingReferenceTxInInlineDatumPresent",
      "signature": "spendingReferenceTxInInlineDatumPresent = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 532,
      "raw": "  spendingReferenceTxInInlineDatumPresent = () => {\n    this.txInInlineDatumPresent();\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  spendingReferenceTxInInlineDatumPresent = () => {\n    this.txInInlineDatumPresent();\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.mintPlutusScript",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.mintPlutusScript",
      "name": "mintPlutusScript",
      "signature": "mintPlutusScript = (languageVersion: LanguageVersion) => {",
      "documentation": "  /**\n   * Set the minting script for the current mint\n   * @param languageVersion The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "languageVersion",
          "type": "LanguageVersion",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 577,
      "raw": "  /**\n   * Set the minting script for the current mint\n   * @param languageVersion The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */\n  mintPlutusScript = (languageVersion: LanguageVersion) => {\n    this.addingPlutusMint = true;\n    this.plutusMintingScriptVersion = languageVersion;\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  mintPlutusScript = (languageVersion: LanguageVersion) => {\n    this.addingPlutusMint = true;\n    this.plutusMintingScriptVersion = languageVersion;\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.mintPlutusScriptV1",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.mintPlutusScriptV1",
      "name": "mintPlutusScriptV1",
      "signature": "mintPlutusScriptV1 = () => {",
      "documentation": "  /**\n   * Set the instruction that it is currently using V1 Plutus minting scripts\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 586,
      "raw": "  /**\n   * Set the instruction that it is currently using V1 Plutus minting scripts\n   * @returns The MeshTxBuilder instance\n   */\n  mintPlutusScriptV1 = () => {\n    this.addingPlutusMint = true;\n    this.plutusMintingScriptVersion = \"V1\";\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  mintPlutusScriptV1 = () => {\n    this.addingPlutusMint = true;\n    this.plutusMintingScriptVersion = \"V1\";\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.mintPlutusScriptV2",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.mintPlutusScriptV2",
      "name": "mintPlutusScriptV2",
      "signature": "mintPlutusScriptV2 = () => {",
      "documentation": "  /**\n   * Set the instruction that it is currently using V2 Plutus minting scripts\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 595,
      "raw": "  /**\n   * Set the instruction that it is currently using V2 Plutus minting scripts\n   * @returns The MeshTxBuilder instance\n   */\n  mintPlutusScriptV2 = () => {\n    this.addingPlutusMint = true;\n    this.plutusMintingScriptVersion = \"V2\";\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  mintPlutusScriptV2 = () => {\n    this.addingPlutusMint = true;\n    this.plutusMintingScriptVersion = \"V2\";\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.mintPlutusScriptV3",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.mintPlutusScriptV3",
      "name": "mintPlutusScriptV3",
      "signature": "mintPlutusScriptV3 = () => {",
      "documentation": "  /**\n   * Set the instruction that it is currently using V3 Plutus minting scripts\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 604,
      "raw": "  /**\n   * Set the instruction that it is currently using V3 Plutus minting scripts\n   * @returns The MeshTxBuilder instance\n   */\n  mintPlutusScriptV3 = () => {\n    this.addingPlutusMint = true;\n    this.plutusMintingScriptVersion = \"V3\";\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  mintPlutusScriptV3 = () => {\n    this.addingPlutusMint = true;\n    this.plutusMintingScriptVersion = \"V3\";\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.mint",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.mint",
      "name": "mint",
      "signature": "mint = (quantity: string, policy: string, name: string) => {",
      "documentation": "  /**\n   * Set the minting value of transaction\n   * @param quantity The quantity of asset to be minted\n   * @param policy The policy id of the asset to be minted\n   * @param name The hex of token name of the asset to be minted\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "quantity",
          "type": "string",
          "optional": false
        },
        {
          "name": "policy",
          "type": "string",
          "optional": false
        },
        {
          "name": "name",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 617,
      "raw": "  /**\n   * Set the minting value of transaction\n   * @param quantity The quantity of asset to be minted\n   * @param policy The policy id of the asset to be minted\n   * @param name The hex of token name of the asset to be minted\n   * @returns The MeshTxBuilder instance\n   */\n  mint = (quantity: string, policy: string, name: string) => {\n    if (this.mintItem) {\n      this.queueMint();\n    }\n    this.mintItem = {\n      type: this.addingPlutusMint ? \"Plutus\" : \"Native\",\n      policyId: policy,\n      assetName: name,\n      amount: quantity,\n    };\n    this.addingPlutusMint = false;\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  mint = (quantity: string, policy: string, name: string) => {\n    if (this.mintItem) {\n      this.queueMint();\n    }\n    this.mintItem = {\n      type: this.addingPlutusMint ? \"Plutus\" : \"Native\",\n      policyId: policy,\n      assetName: name,\n      amount: quantity,\n    };\n    this.addingPlutusMint = false;\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.mintingScript",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.mintingScript",
      "name": "mintingScript",
      "signature": "mintingScript = (scriptCBOR: string) => {",
      "documentation": "  /**\n   * Set the minting script of current mint\n   * @param scriptCBOR The CBOR hex of the minting policy script\n   * @param version Optional - The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "scriptCBOR",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 637,
      "raw": "  /**\n   * Set the minting script of current mint\n   * @param scriptCBOR The CBOR hex of the minting policy script\n   * @param version Optional - The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */\n  mintingScript = (scriptCBOR: string) => {\n    if (!this.mintItem) throw Error(\"Undefined mint\");\n    if (!this.mintItem.type) throw Error(\"Mint information missing\");\n    if (this.mintItem.type === \"Native\") {\n      this.mintItem.scriptSource = {\n        type: \"Provided\",\n        scriptCode: scriptCBOR,\n      };\n    }\n    if (this.mintItem.type === \"Plutus\") {\n      this.mintItem.scriptSource = {\n        type: \"Provided\",\n        script: {\n          code: scriptCBOR,\n          version: this.plutusMintingScriptVersion || \"V2\",\n        },\n      };\n    }\n\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  mintingScript = (scriptCBOR: string) => {\n    if (!this.mintItem) throw Error(\"Undefined mint\");\n    if (!this.mintItem.type) throw Error(\"Mint information missing\");\n    if (this.mintItem.type === \"Native\") {\n      this.mintItem.scriptSource = {\n        type: \"Provided\",\n        scriptCode: scriptCBOR,\n      };\n    }\n    if (this.mintItem.type === \"Plutus\") {\n      this.mintItem.scriptSource = {\n        type: \"Provided\",\n        script: {\n          code: scriptCBOR,\n          version: this.plutusMintingScriptVersion || \"V2\",\n        },\n      };\n    }\n\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.requiredSignerHash",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.requiredSignerHash",
      "name": "requiredSignerHash",
      "signature": "requiredSignerHash = (pubKeyHash: string) => {",
      "documentation": "  /**\n   * Set the required signer of the transaction\n   * @param pubKeyHash The PubKeyHash of the required signer\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "pubKeyHash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 743,
      "raw": "  /**\n   * Set the required signer of the transaction\n   * @param pubKeyHash The PubKeyHash of the required signer\n   * @returns The MeshTxBuilder instance\n   */\n  requiredSignerHash = (pubKeyHash: string) => {\n    this.meshTxBuilderBody.requiredSignatures.push(pubKeyHash);\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  requiredSignerHash = (pubKeyHash: string) => {\n    this.meshTxBuilderBody.requiredSignatures.push(pubKeyHash);\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.withdrawalPlutusScript",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.withdrawalPlutusScript",
      "name": "withdrawalPlutusScript",
      "signature": "withdrawalPlutusScript = (languageVersion: LanguageVersion) => {",
      "documentation": "  /**\n   * Set the instruction that it is currently using V1 Plutus withdrawal scripts\n   * @param languageVersion The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "languageVersion",
          "type": "LanguageVersion",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 782,
      "raw": "  /**\n   * Set the instruction that it is currently using V1 Plutus withdrawal scripts\n   * @param languageVersion The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */\n  withdrawalPlutusScript = (languageVersion: LanguageVersion) => {\n    this.addingPlutusWithdrawal = true;\n    this.plutusWithdrawalScriptVersion = languageVersion;\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  withdrawalPlutusScript = (languageVersion: LanguageVersion) => {\n    this.addingPlutusWithdrawal = true;\n    this.plutusWithdrawalScriptVersion = languageVersion;\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.withdrawalPlutusScriptV1",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.withdrawalPlutusScriptV1",
      "name": "withdrawalPlutusScriptV1",
      "signature": "withdrawalPlutusScriptV1 = () => {",
      "documentation": "  /**\n   * Set the instruction that it is currently using a Plutus withdrawal scripts\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 791,
      "raw": "  /**\n   * Set the instruction that it is currently using a Plutus withdrawal scripts\n   * @returns The MeshTxBuilder instance\n   */\n  withdrawalPlutusScriptV1 = () => {\n    this.addingPlutusWithdrawal = true;\n    this.plutusWithdrawalScriptVersion = \"V1\";\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  withdrawalPlutusScriptV1 = () => {\n    this.addingPlutusWithdrawal = true;\n    this.plutusWithdrawalScriptVersion = \"V1\";\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.withdrawalPlutusScriptV2",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.withdrawalPlutusScriptV2",
      "name": "withdrawalPlutusScriptV2",
      "signature": "withdrawalPlutusScriptV2 = () => {",
      "documentation": "  /**\n   * Set the instruction that it is currently using V2 Plutus withdrawal scripts\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 801,
      "raw": "  /**\n   * Set the instruction that it is currently using V2 Plutus withdrawal scripts\n   * @returns The MeshTxBuilder instance\n   */\n  withdrawalPlutusScriptV2 = () => {\n    this.addingPlutusWithdrawal = true;\n    this.plutusWithdrawalScriptVersion = \"V2\";\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  withdrawalPlutusScriptV2 = () => {\n    this.addingPlutusWithdrawal = true;\n    this.plutusWithdrawalScriptVersion = \"V2\";\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.withdrawalPlutusScriptV3",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.withdrawalPlutusScriptV3",
      "name": "withdrawalPlutusScriptV3",
      "signature": "withdrawalPlutusScriptV3 = () => {",
      "documentation": "  /**\n   * Set the instruction that it is currently using V3 Plutus withdrawal scripts\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 811,
      "raw": "  /**\n   * Set the instruction that it is currently using V3 Plutus withdrawal scripts\n   * @returns The MeshTxBuilder instance\n   */\n  withdrawalPlutusScriptV3 = () => {\n    this.addingPlutusWithdrawal = true;\n    this.plutusWithdrawalScriptVersion = \"V3\";\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  withdrawalPlutusScriptV3 = () => {\n    this.addingPlutusWithdrawal = true;\n    this.plutusWithdrawalScriptVersion = \"V3\";\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.withdrawal",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.withdrawal",
      "name": "withdrawal",
      "signature": "withdrawal = (rewardAddress: string, coin: string) => {",
      "documentation": "  /**\n   * Withdraw stake rewards in the MeshTxBuilder instance\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @param coin The amount of lovelaces in the withdrawal\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "rewardAddress",
          "type": "string",
          "optional": false
        },
        {
          "name": "coin",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 823,
      "raw": "  /**\n   * Withdraw stake rewards in the MeshTxBuilder instance\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @param coin The amount of lovelaces in the withdrawal\n   * @returns The MeshTxBuilder instance\n   */\n  withdrawal = (rewardAddress: string, coin: string) => {\n    if (this.withdrawalItem) {\n      this.queueWithdrawal();\n    }\n    if (this.addingPlutusWithdrawal) {\n      const withdrawal: Withdrawal = {\n        type: \"ScriptWithdrawal\",\n        address: rewardAddress,\n        coin: coin,\n      };\n      this.withdrawalItem = withdrawal;\n      this.addingPlutusWithdrawal = false;\n      return this;\n    }\n\n    const withdrawal: Withdrawal = {\n      type: \"PubKeyWithdrawal\",\n      address: rewardAddress,\n      coin: coin,\n    };\n    this.withdrawalItem = withdrawal;\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  withdrawal = (rewardAddress: string, coin: string) => {\n    if (this.withdrawalItem) {\n      this.queueWithdrawal();\n    }\n    if (this.addingPlutusWithdrawal) {\n      const withdrawal: Withdrawal = {\n        type: \"ScriptWithdrawal\",\n        address: rewardAddress,\n        coin: coin,\n      };\n      this.withdrawalItem = withdrawal;\n      this.addingPlutusWithdrawal = false;\n      return this;\n    }\n\n    const withdrawal: Withdrawal = {\n      type: \"PubKeyWithdrawal\",\n      address: rewardAddress,\n      coin: coin,\n    };\n    this.withdrawalItem = withdrawal;\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.withdrawalScript",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.withdrawalScript",
      "name": "withdrawalScript",
      "signature": "withdrawalScript = (scriptCbor: string) => {",
      "documentation": "  /**\n   * Add a withdrawal script to the MeshTxBuilder instance\n   * @param scriptCbor The script in CBOR format\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "scriptCbor",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 852,
      "raw": "  /**\n   * Add a withdrawal script to the MeshTxBuilder instance\n   * @param scriptCbor The script in CBOR format\n   * @returns The MeshTxBuilder instance\n   */\n  withdrawalScript = (scriptCbor: string) => {\n    if (!this.withdrawalItem)\n      throw Error(\"withdrawalScript: Undefined withdrawal\");\n    if (this.withdrawalItem.type === \"PubKeyWithdrawal\") {\n      this.withdrawalItem = {\n        type: \"SimpleScriptWithdrawal\",\n        address: this.withdrawalItem.address,\n        coin: this.withdrawalItem.coin,\n        scriptSource: {\n          type: \"Provided\",\n          scriptCode: scriptCbor,\n        },\n      };\n    } else {\n      this.withdrawalItem.scriptSource = {\n        type: \"Provided\",\n        script: {\n          code: scriptCbor,\n          version: this.plutusWithdrawalScriptVersion || \"V2\",\n        },\n      };\n    }\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  withdrawalScript = (scriptCbor: string) => {\n    if (!this.withdrawalItem)\n      throw Error(\"withdrawalScript: Undefined withdrawal\");\n    if (this.withdrawalItem.type === \"PubKeyWithdrawal\") {\n      this.withdrawalItem = {\n        type: \"SimpleScriptWithdrawal\",\n        address: this.withdrawalItem.address,\n        coin: this.withdrawalItem.coin,\n        scriptSource: {\n          type: \"Provided\",\n          scriptCode: scriptCbor,\n        },\n      };\n    } else {\n      this.withdrawalItem.scriptSource = {\n        type: \"Provided\",\n        script: {\n          code: scriptCbor,\n          version: this.plutusWithdrawalScriptVersion || \"V2\",\n        },\n      };\n    }\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.votePlutusScript",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.votePlutusScript",
      "name": "votePlutusScript",
      "signature": "votePlutusScript = (languageVersion: LanguageVersion) => {",
      "documentation": "  /**\n   * Set the instruction that it is currently using a Plutus voting scripts\n   * @param languageVersion The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "languageVersion",
          "type": "LanguageVersion",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 940,
      "raw": "  /**\n   * Set the instruction that it is currently using a Plutus voting scripts\n   * @param languageVersion The Plutus script version\n   * @returns The MeshTxBuilder instance\n   */\n  votePlutusScript = (languageVersion: LanguageVersion) => {\n    this.addingPlutusVote = true;\n    this.plutusVoteScriptVersion = languageVersion;\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  votePlutusScript = (languageVersion: LanguageVersion) => {\n    this.addingPlutusVote = true;\n    this.plutusVoteScriptVersion = languageVersion;\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.votePlutusScriptV1",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.votePlutusScriptV1",
      "name": "votePlutusScriptV1",
      "signature": "votePlutusScriptV1 = () => {",
      "documentation": "  /**\n   * Set the instruction that it is currently using V1 Plutus voting scripts\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 949,
      "raw": "  /**\n   * Set the instruction that it is currently using V1 Plutus voting scripts\n   * @returns The MeshTxBuilder instance\n   */\n  votePlutusScriptV1 = () => {\n    this.addingPlutusVote = true;\n    this.plutusVoteScriptVersion = \"V1\";\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  votePlutusScriptV1 = () => {\n    this.addingPlutusVote = true;\n    this.plutusVoteScriptVersion = \"V1\";\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.votePlutusScriptV2",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.votePlutusScriptV2",
      "name": "votePlutusScriptV2",
      "signature": "votePlutusScriptV2 = () => {",
      "documentation": "  /**\n   * Set the instruction that it is currently using V2 Plutus voting scripts\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 959,
      "raw": "  /**\n   * Set the instruction that it is currently using V2 Plutus voting scripts\n   * @returns The MeshTxBuilder instance\n   */\n  votePlutusScriptV2 = () => {\n    this.addingPlutusVote = true;\n    this.plutusVoteScriptVersion = \"V2\";\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  votePlutusScriptV2 = () => {\n    this.addingPlutusVote = true;\n    this.plutusVoteScriptVersion = \"V2\";\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.votePlutusScriptV3",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.votePlutusScriptV3",
      "name": "votePlutusScriptV3",
      "signature": "votePlutusScriptV3 = () => {",
      "documentation": "  /**\n   * Set the instruction that it is currently using V3 Plutus voting scripts\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 969,
      "raw": "  /**\n   * Set the instruction that it is currently using V3 Plutus voting scripts\n   * @returns The MeshTxBuilder instance\n   */\n  votePlutusScriptV3 = () => {\n    this.addingPlutusVote = true;\n    this.plutusVoteScriptVersion = \"V3\";\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  votePlutusScriptV3 = () => {\n    this.addingPlutusVote = true;\n    this.plutusVoteScriptVersion = \"V3\";\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.voteScript",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.voteScript",
      "name": "voteScript",
      "signature": "voteScript = (scriptCbor: string) => {",
      "documentation": "  /**\n   * Add a voting script to the MeshTxBuilder instance\n   * @param scriptCbor The script in CBOR format\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "scriptCbor",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1021,
      "raw": "  /**\n   * Add a voting script to the MeshTxBuilder instance\n   * @param scriptCbor The script in CBOR format\n   * @returns The MeshTxBuilder instance\n   */\n  voteScript = (scriptCbor: string) => {\n    if (!this.voteItem) throw Error(\"voteScript: Undefined vote\");\n    if (this.voteItem.type === \"BasicVote\") {\n      this.voteItem = {\n        type: \"SimpleScriptVote\",\n        vote: this.voteItem.vote,\n        simpleScriptSource: {\n          type: \"Provided\",\n          scriptCode: scriptCbor,\n        },\n      };\n    } else if (this.voteItem.type === \"ScriptVote\") {\n      this.voteItem.scriptSource = {\n        type: \"Provided\",\n        script: {\n          code: scriptCbor,\n          version: this.plutusVoteScriptVersion || \"V2\",\n        },\n      };\n    } else if (this.voteItem.type === \"SimpleScriptVote\") {\n      throw Error(\"voteScript: Script is already defined for current vote\");\n    }\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  voteScript = (scriptCbor: string) => {\n    if (!this.voteItem) throw Error(\"voteScript: Undefined vote\");\n    if (this.voteItem.type === \"BasicVote\") {\n      this.voteItem = {\n        type: \"SimpleScriptVote\",\n        vote: this.voteItem.vote,\n        simpleScriptSource: {\n          type: \"Provided\",\n          scriptCode: scriptCbor,\n        },\n      };\n    } else if (this.voteItem.type === \"ScriptVote\") {\n      this.voteItem.scriptSource = {\n        type: \"Provided\",\n        script: {\n          code: scriptCbor,\n          version: this.plutusVoteScriptVersion || \"V2\",\n        },\n      };\n    } else if (this.voteItem.type === \"SimpleScriptVote\") {\n      throw Error(\"voteScript: Script is already defined for current vote\");\n    }\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.registerPoolCertificate",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.registerPoolCertificate",
      "name": "registerPoolCertificate",
      "signature": "registerPoolCertificate = (poolParams: PoolParams) => {",
      "documentation": "  /**\n   * Creates a pool registration certificate, and adds it to the transaction\n   * @param poolParams Parameters for pool registration\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "poolParams",
          "type": "PoolParams",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1114,
      "raw": "  /**\n   * Creates a pool registration certificate, and adds it to the transaction\n   * @param poolParams Parameters for pool registration\n   * @returns The MeshTxBuilder instance\n   */\n  registerPoolCertificate = (poolParams: PoolParams) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"RegisterPool\",\n        poolParams,\n      },\n    });\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  registerPoolCertificate = (poolParams: PoolParams) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"RegisterPool\",\n        poolParams,\n      },\n    });\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.registerStakeCertificate",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.registerStakeCertificate",
      "name": "registerStakeCertificate",
      "signature": "registerStakeCertificate = (rewardAddress: string) => {",
      "documentation": "  /**\n   * Creates a stake registration certificate, and adds it to the transaction\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "rewardAddress",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1130,
      "raw": "  /**\n   * Creates a stake registration certificate, and adds it to the transaction\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @returns The MeshTxBuilder instance\n   */\n  registerStakeCertificate = (rewardAddress: string) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"RegisterStake\",\n        stakeKeyAddress: rewardAddress,\n      },\n    });\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  registerStakeCertificate = (rewardAddress: string) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"RegisterStake\",\n        stakeKeyAddress: rewardAddress,\n      },\n    });\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.delegateStakeCertificate",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.delegateStakeCertificate",
      "name": "delegateStakeCertificate",
      "signature": "delegateStakeCertificate = (rewardAddress: string, poolId: string) => {",
      "documentation": "  /**\n   * Creates a stake delegation certificate, and adds it to the transaction\n   * This will delegate stake from the corresponding stake address to the pool\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @param poolId poolId can be in either bech32 or hex form\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "rewardAddress",
          "type": "string",
          "optional": false
        },
        {
          "name": "poolId",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1148,
      "raw": "  /**\n   * Creates a stake delegation certificate, and adds it to the transaction\n   * This will delegate stake from the corresponding stake address to the pool\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @param poolId poolId can be in either bech32 or hex form\n   * @returns The MeshTxBuilder instance\n   */\n  delegateStakeCertificate = (rewardAddress: string, poolId: string) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"DelegateStake\",\n        stakeKeyAddress: rewardAddress,\n        poolId,\n      },\n    });\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  delegateStakeCertificate = (rewardAddress: string, poolId: string) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"DelegateStake\",\n        stakeKeyAddress: rewardAddress,\n        poolId,\n      },\n    });\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.deregisterStakeCertificate",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.deregisterStakeCertificate",
      "name": "deregisterStakeCertificate",
      "signature": "deregisterStakeCertificate = (rewardAddress: string) => {",
      "documentation": "  /**\n   * Creates a stake deregister certificate, and adds it to the transaction\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "rewardAddress",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1165,
      "raw": "  /**\n   * Creates a stake deregister certificate, and adds it to the transaction\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @returns The MeshTxBuilder instance\n   */\n  deregisterStakeCertificate = (rewardAddress: string) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"DeregisterStake\",\n        stakeKeyAddress: rewardAddress,\n      },\n    });\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  deregisterStakeCertificate = (rewardAddress: string) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"DeregisterStake\",\n        stakeKeyAddress: rewardAddress,\n      },\n    });\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.retirePoolCertificate",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.retirePoolCertificate",
      "name": "retirePoolCertificate",
      "signature": "retirePoolCertificate = (poolId: string, epoch: number) => {",
      "documentation": "  /**\n   * Creates a pool retire certificate, and adds it to the transaction\n   * @param poolId poolId can be in either bech32 or hex form\n   * @param epoch The intended epoch to retire the pool\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "poolId",
          "type": "string",
          "optional": false
        },
        {
          "name": "epoch",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1182,
      "raw": "  /**\n   * Creates a pool retire certificate, and adds it to the transaction\n   * @param poolId poolId can be in either bech32 or hex form\n   * @param epoch The intended epoch to retire the pool\n   * @returns The MeshTxBuilder instance\n   */\n  retirePoolCertificate = (poolId: string, epoch: number) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"RetirePool\",\n        poolId,\n        epoch,\n      },\n    });\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  retirePoolCertificate = (poolId: string, epoch: number) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"RetirePool\",\n        poolId,\n        epoch,\n      },\n    });\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.drepUpdateCertificate",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.drepUpdateCertificate",
      "name": "drepUpdateCertificate",
      "signature": "drepUpdateCertificate = (drepId: string, anchor?: Anchor) => {",
      "documentation": "  /**\n   * Update DRep certificate, and adds it to the transaction\n   * @param drepId The bech32 drep id (i.e. starts with `drep1xxxxx`)\n   * @param anchor The DRep anchor, consists of a URL and a hash of the doc\n   */",
      "parameters": [
        {
          "name": "drepId",
          "type": "string",
          "optional": false
        },
        {
          "name": "anchor",
          "type": "Anchor",
          "optional": true
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1244,
      "raw": "  /**\n   * Update DRep certificate, and adds it to the transaction\n   * @param drepId The bech32 drep id (i.e. starts with `drep1xxxxx`)\n   * @param anchor The DRep anchor, consists of a URL and a hash of the doc\n   */\n  drepUpdateCertificate = (drepId: string, anchor?: Anchor) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"DRepUpdate\",\n        drepId,\n        anchor,\n      },\n    });\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  drepUpdateCertificate = (drepId: string, anchor?: Anchor) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"DRepUpdate\",\n        drepId,\n        anchor,\n      },\n    });\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.voteDelegationCertificate",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.voteDelegationCertificate",
      "name": "voteDelegationCertificate",
      "signature": "voteDelegationCertificate = (drep: DRep, rewardAddress: string) => {",
      "documentation": "  /**\n   * Dregister DRep certificate, and adds it to the transaction\n   * @param drepId The bech32 drep id (i.e. starts with `drep1xxxxx`)\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "drep",
          "type": "DRep",
          "optional": false
        },
        {
          "name": "rewardAddress",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1262,
      "raw": "  /**\n   * Dregister DRep certificate, and adds it to the transaction\n   * @param drepId The bech32 drep id (i.e. starts with `drep1xxxxx`)\n   * @param rewardAddress The bech32 reward address (i.e. start with `stake_xxxxx`)\n   * @returns The MeshTxBuilder instance\n   */\n  voteDelegationCertificate = (drep: DRep, rewardAddress: string) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"VoteDelegation\",\n        drep,\n        stakeKeyAddress: rewardAddress,\n      },\n    });\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  voteDelegationCertificate = (drep: DRep, rewardAddress: string) => {\n    this.meshTxBuilderBody.certificates.push({\n      type: \"BasicCertificate\",\n      certType: {\n        type: \"VoteDelegation\",\n        drep,\n        stakeKeyAddress: rewardAddress,\n      },\n    });\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.certificateScript",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.certificateScript",
      "name": "certificateScript",
      "signature": "certificateScript = (scriptCbor: string, version?: LanguageVersion) => {",
      "documentation": "  /**\n   * Adds a script witness to the certificate\n   * @param scriptCbor The CborHex of the script\n   * @param version Optional - The plutus version of the script, null version implies Native Script\n   */",
      "parameters": [
        {
          "name": "scriptCbor",
          "type": "string",
          "optional": false
        },
        {
          "name": "version",
          "type": "LanguageVersion",
          "optional": true
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1279,
      "raw": "  /**\n   * Adds a script witness to the certificate\n   * @param scriptCbor The CborHex of the script\n   * @param version Optional - The plutus version of the script, null version implies Native Script\n   */\n  certificateScript = (scriptCbor: string, version?: LanguageVersion) => {\n    const currentCert = this.meshTxBuilderBody.certificates.pop();\n    if (!currentCert) {\n      throw Error(\n        \"Certificate script attempted to be defined, but no certificate was found\",\n      );\n    }\n    if (!version) {\n      this.meshTxBuilderBody.certificates.push({\n        type: \"SimpleScriptCertificate\",\n        certType: currentCert.certType,\n        simpleScriptSource: {\n          type: \"Provided\",\n          scriptCode: scriptCbor,\n        },\n      });\n    } else {\n      this.meshTxBuilderBody.certificates.push({\n        type: \"ScriptCertificate\",\n        certType: currentCert.certType,\n        scriptSource: {\n          type: \"Provided\",\n          script: {\n            code: scriptCbor,\n            version,\n          },\n        },\n        redeemer:\n          currentCert.type === \"ScriptCertificate\"\n            ? currentCert.redeemer\n            : undefined,\n      });\n    }\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  certificateScript = (scriptCbor: string, version?: LanguageVersion) => {\n    const currentCert = this.meshTxBuilderBody.certificates.pop();\n    if (!currentCert) {\n      throw Error(\n        \"Certificate script attempted to be defined, but no certificate was found\",\n      );\n    }\n    if (!version) {\n      this.meshTxBuilderBody.certificates.push({\n        type: \"SimpleScriptCertificate\",\n        certType: currentCert.certType,\n        simpleScriptSource: {\n          type: \"Provided\",\n          scriptCode: scriptCbor,\n        },\n      });\n    } else {\n      this.meshTxBuilderBody.certificates.push({\n        type: \"ScriptCertificate\",\n        certType: currentCert.certType,\n        scriptSource: {\n          type: \"Provided\",\n          script: {\n            code: scriptCbor,\n            version,\n          },\n        },\n        redeemer:\n          currentCert.type === \"ScriptCertificate\"\n            ? currentCert.redeemer\n            : undefined,\n      });\n    }\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.changeAddress",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.changeAddress",
      "name": "changeAddress",
      "signature": "changeAddress = (addr: string) => {",
      "documentation": "  /**\n   * Configure the address to accept change UTxO\n   * @param addr The address to accept change UTxO\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "addr",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1399,
      "raw": "  /**\n   * Configure the address to accept change UTxO\n   * @param addr The address to accept change UTxO\n   * @returns The MeshTxBuilder instance\n   */\n  changeAddress = (addr: string) => {\n    this.meshTxBuilderBody.changeAddress = addr;\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  changeAddress = (addr: string) => {\n    this.meshTxBuilderBody.changeAddress = addr;\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.invalidBefore",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.invalidBefore",
      "name": "invalidBefore",
      "signature": "invalidBefore = (slot: number) => {",
      "documentation": "  /**\n   * Set the transaction valid interval to be valid only after the slot\n   * @param slot The transaction is valid only after this slot\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "slot",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1409,
      "raw": "  /**\n   * Set the transaction valid interval to be valid only after the slot\n   * @param slot The transaction is valid only after this slot\n   * @returns The MeshTxBuilder instance\n   */\n  invalidBefore = (slot: number) => {\n    this.meshTxBuilderBody.validityRange.invalidBefore = slot;\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  invalidBefore = (slot: number) => {\n    this.meshTxBuilderBody.validityRange.invalidBefore = slot;\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.invalidHereafter",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.invalidHereafter",
      "name": "invalidHereafter",
      "signature": "invalidHereafter = (slot: number) => {",
      "documentation": "  /**\n   * Set the transaction valid interval to be valid only before the slot\n   * @param slot The transaction is valid only before this slot\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "slot",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1419,
      "raw": "  /**\n   * Set the transaction valid interval to be valid only before the slot\n   * @param slot The transaction is valid only before this slot\n   * @returns The MeshTxBuilder instance\n   */\n  invalidHereafter = (slot: number) => {\n    this.meshTxBuilderBody.validityRange.invalidHereafter = slot;\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  invalidHereafter = (slot: number) => {\n    this.meshTxBuilderBody.validityRange.invalidHereafter = slot;\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.signingKey",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.signingKey",
      "name": "signingKey",
      "signature": "signingKey = (skeyHex: string) => {",
      "documentation": "  /**\n   * Sign the transaction with the private key\n   * @param skeyHex The private key in cborHex (with or without 5820 prefix, i.e. the format when generated from cardano-cli)\n   * @returns\n   */",
      "parameters": [
        {
          "name": "skeyHex",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1448,
      "raw": "  /**\n   * Sign the transaction with the private key\n   * @param skeyHex The private key in cborHex (with or without 5820 prefix, i.e. the format when generated from cardano-cli)\n   * @returns\n   */\n  signingKey = (skeyHex: string) => {\n    this.meshTxBuilderBody.signingKey.push(skeyHex);\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  signingKey = (skeyHex: string) => {\n    this.meshTxBuilderBody.signingKey.push(skeyHex);\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.selectUtxosFrom",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.selectUtxosFrom",
      "name": "selectUtxosFrom",
      "signature": "selectUtxosFrom = (extraInputs: UTxO[]) => {",
      "documentation": "  /**\n   * Selects utxos to fill output value and puts them into inputs\n   * @param extraInputs The inputs already placed into the object will remain, these extra inputs will be used to fill the remaining  value needed\n   */",
      "parameters": [
        {
          "name": "extraInputs",
          "type": "UTxO[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1457,
      "raw": "  /**\n   * Selects utxos to fill output value and puts them into inputs\n   * @param extraInputs The inputs already placed into the object will remain, these extra inputs will be used to fill the remaining  value needed\n   */\n  selectUtxosFrom = (extraInputs: UTxO[]) => {\n    for (const input of extraInputs) {\n      const address = input.output.address;\n      if (!address) {\n        throw Error(\"Address is missing from the extra input\");\n      }\n      const decodedAddress = Address.fromString(<HexBlob>address);\n      if (\n        decodedAddress?.getProps().paymentPart?.type !== CredentialType.KeyHash\n      ) {\n        throw Error(\"Only KeyHash address is supported for utxo selection\");\n      }\n    }\n    this.meshTxBuilderBody.extraInputs = extraInputs;\n    this.meshTxBuilderBody.selectionConfig = {\n      ...this.meshTxBuilderBody.selectionConfig,\n    };\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  selectUtxosFrom = (extraInputs: UTxO[]) => {\n    for (const input of extraInputs) {\n      const address = input.output.address;\n      if (!address) {\n        throw Error(\"Address is missing from the extra input\");\n      }\n      const decodedAddress = Address.fromString(<HexBlob>address);\n      if (\n        decodedAddress?.getProps().paymentPart?.type !== CredentialType.KeyHash\n      ) {\n        throw Error(\"Only KeyHash address is supported for utxo selection\");\n      }\n    }\n    this.meshTxBuilderBody.extraInputs = extraInputs;\n    this.meshTxBuilderBody.selectionConfig = {\n      ...this.meshTxBuilderBody.selectionConfig,\n    };\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.protocolParams",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.protocolParams",
      "name": "protocolParams",
      "signature": "protocolParams = (params: Partial<Protocol>) => {",
      "documentation": "  /**\n   * Set the protocol parameters to be used for the transaction other than the default one\n   * @param params (Part of) the protocol parameters to be used for the transaction\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "params",
          "type": "Partial<Protocol>",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1482,
      "raw": "  /**\n   * Set the protocol parameters to be used for the transaction other than the default one\n   * @param params (Part of) the protocol parameters to be used for the transaction\n   * @returns The MeshTxBuilder instance\n   */\n  protocolParams = (params: Partial<Protocol>) => {\n    const updatedParams = { ...DEFAULT_PROTOCOL_PARAMETERS, ...params };\n    this._protocolParams = updatedParams;\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  protocolParams = (params: Partial<Protocol>) => {\n    const updatedParams = { ...DEFAULT_PROTOCOL_PARAMETERS, ...params };\n    this._protocolParams = updatedParams;\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.setFee",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.setFee",
      "name": "setFee",
      "signature": "setFee = (fee: string) => {",
      "documentation": "  /**\n   * Sets a specific fee for the transaction to use\n   * @param fee The specified fee\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "fee",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1493,
      "raw": "  /**\n   * Sets a specific fee for the transaction to use\n   * @param fee The specified fee\n   * @returns The MeshTxBuilder instance\n   */\n  setFee = (fee: string) => {\n    this.manualFee = fee;\n    this.meshTxBuilderBody.fee = fee;\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  setFee = (fee: string) => {\n    this.manualFee = fee;\n    this.meshTxBuilderBody.fee = fee;\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.setTotalCollateral",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.setTotalCollateral",
      "name": "setTotalCollateral",
      "signature": "setTotalCollateral = (collateral: string) => {",
      "documentation": "  /**\n   * Sets a total collateral for the transaction to use, a collateral return\n   * will be generated to either the change address or the specified collateral return address\n   * @param collateral The specified collateral\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "collateral",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1505,
      "raw": "  /**\n   * Sets a total collateral for the transaction to use, a collateral return\n   * will be generated to either the change address or the specified collateral return address\n   * @param collateral The specified collateral\n   * @returns The MeshTxBuilder instance\n   */\n  setTotalCollateral = (collateral: string) => {\n    this.meshTxBuilderBody.totalCollateral = collateral;\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  setTotalCollateral = (collateral: string) => {\n    this.meshTxBuilderBody.totalCollateral = collateral;\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.setCollateralReturnAddress",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.setCollateralReturnAddress",
      "name": "setCollateralReturnAddress",
      "signature": "setCollateralReturnAddress = (address: string) => {",
      "documentation": "  /**\n   * Sets the collateral return address, if none is set, the change address will be used\n   * @param address The address to use for collateral return\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "address",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1515,
      "raw": "  /**\n   * Sets the collateral return address, if none is set, the change address will be used\n   * @param address The address to use for collateral return\n   * @returns The MeshTxBuilder instance\n   */\n  setCollateralReturnAddress = (address: string) => {\n    this.meshTxBuilderBody.collateralReturnAddress = address;\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  setCollateralReturnAddress = (address: string) => {\n    this.meshTxBuilderBody.collateralReturnAddress = address;\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.setNetwork",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.setNetwork",
      "name": "setNetwork",
      "signature": "setNetwork = (network: Network | number[][]) => {",
      "documentation": "  /**\n   * Sets the network to use, this is mainly to know the cost models to be used to calculate script integrity hash\n   * @param network The specific network this transaction is being built for (\"testnet\" | \"preview\" | \"preprod\" | \"mainnet\")\n   * @returns The MeshTxBuilder instance\n   */",
      "parameters": [
        {
          "name": "network",
          "type": "Network | number[][]",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1525,
      "raw": "  /**\n   * Sets the network to use, this is mainly to know the cost models to be used to calculate script integrity hash\n   * @param network The specific network this transaction is being built for (\"testnet\" | \"preview\" | \"preprod\" | \"mainnet\")\n   * @returns The MeshTxBuilder instance\n   */\n  setNetwork = (network: Network | number[][]) => {\n    this.meshTxBuilderBody.network = network;\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  setNetwork = (network: Network | number[][]) => {\n    this.meshTxBuilderBody.network = network;\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.chainTx",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.chainTx",
      "name": "chainTx",
      "signature": "chainTx(txHex: string): this {",
      "documentation": "  /**\n   * Add a transaction that is used as input, but not yet reflected on the global blockchain\n   * @param txHex The transaction hex of chained transaction\n   * @returns The MeshTxBuilderCore instance\n   */",
      "parameters": [
        {
          "name": "txHex",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "this",
      "isPublic": true,
      "line": 1535,
      "raw": "  /**\n   * Add a transaction that is used as input, but not yet reflected on the global blockchain\n   * @param txHex The transaction hex of chained transaction\n   * @returns The MeshTxBuilderCore instance\n   */\n  chainTx(txHex: string): this {\n    this.meshTxBuilderBody.chainedTxs.push(txHex);\n    return this;\n  }",
      "source": "mesh-transaction",
      "implementation": "  chainTx(txHex: string): this {\n    this.meshTxBuilderBody.chainedTxs.push(txHex);\n    return this;\n  }"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.addUtxosFromSelection",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.addUtxosFromSelection",
      "name": "addUtxosFromSelection",
      "signature": "addUtxosFromSelection = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 1853,
      "raw": "  addUtxosFromSelection = () => {\n    const requiredAssets = this.meshTxBuilderBody.outputs.reduce(\n      (map, output) => {\n        const outputAmount = output.amount;\n        outputAmount.forEach((asset) => {\n          const { unit, quantity } = asset;\n          const existingQuantity = Number(map.get(unit)) || 0;\n          map.set(unit, String(existingQuantity + Number(quantity)));\n        });\n        return map;\n      },\n      new Map<Unit, Quantity>(),\n    );\n    this.meshTxBuilderBody.inputs.reduce((map, input) => {\n      const inputAmount = input.txIn.amount;\n      inputAmount?.forEach((asset) => {\n        const { unit, quantity } = asset;\n        const existingQuantity = Number(map.get(unit)) || 0;\n        map.set(unit, String(existingQuantity - Number(quantity)));\n      });\n      return map;\n    }, requiredAssets);\n    this.meshTxBuilderBody.mints.reduce((map, mint) => {\n      for (const assetValue of mint.mintValue) {\n        const mintAmount: Asset = {\n          unit: mint.policyId + assetValue.assetName,\n          quantity: String(assetValue.amount),\n        };\n        const existingQuantity = Number(map.get(mintAmount.unit)) || 0;\n        map.set(\n          mintAmount.unit,\n          String(existingQuantity - Number(mintAmount.quantity)),\n        );\n      }\n      return map;\n    }, requiredAssets);\n    const selectionConfig = this.meshTxBuilderBody.selectionConfig;\n\n    const utxoSelection = new UtxoSelection(\n      selectionConfig.threshold,\n      selectionConfig.includeTxFees,\n    );\n\n    let selectedInputs: UTxO[] = [];\n    switch (selectionConfig.strategy) {\n      case \"keepRelevant\":\n        selectedInputs = utxoSelection.keepRelevant(\n          requiredAssets,\n          this.meshTxBuilderBody.extraInputs,\n        );\n      case \"largestFirst\":\n        selectedInputs = utxoSelection.largestFirst(\n          requiredAssets,\n          this.meshTxBuilderBody.extraInputs,\n        );\n        break;\n\n      case \"largestFirstMultiAsset\":\n        selectedInputs = utxoSelection.largestFirstMultiAsset(\n          requiredAssets,\n          this.meshTxBuilderBody.extraInputs,\n        );\n        break;\n\n      default:\n        selectedInputs = utxoSelection.experimental(\n          requiredAssets,\n          this.meshTxBuilderBody.extraInputs,\n        );\n        break;\n    }\n\n    selectedInputs.forEach((input) => {\n      const pubKeyTxIn: PubKeyTxIn = {\n        type: \"PubKey\",\n        txIn: {\n          txHash: input.input.txHash,\n          txIndex: input.input.outputIndex,\n          amount: input.output.amount,\n          address: input.output.address,\n        },\n      };\n      this.meshTxBuilderBody.inputs.push(pubKeyTxIn);\n      // If an input selected has script ref, then we must\n      // provide the script size to the tx builder also\n      if (input.output.scriptRef) {\n        this.meshTxBuilderBody.referenceInputs.push({\n          txHash: input.input.txHash,\n          txIndex: input.input.outputIndex,\n          scriptSize: input.output.scriptRef!.length / 2,\n        });\n      }\n      this.inputForEvaluation(input);\n    });\n  };",
      "source": "mesh-transaction",
      "implementation": "  addUtxosFromSelection = () => {\n    const requiredAssets = this.meshTxBuilderBody.outputs.reduce(\n      (map, output) => {\n        const outputAmount = output.amount;\n        outputAmount.forEach((asset) => {\n          const { unit, quantity } = asset;\n          const existingQuantity = Number(map.get(unit)) || 0;\n          map.set(unit, String(existingQuantity + Number(quantity)));\n        });\n        return map;\n      },\n      new Map<Unit, Quantity>(),\n    );\n    this.meshTxBuilderBody.inputs.reduce((map, input) => {\n      const inputAmount = input.txIn.amount;\n      inputAmount?.forEach((asset) => {\n        const { unit, quantity } = asset;\n        const existingQuantity = Number(map.get(unit)) || 0;\n        map.set(unit, String(existingQuantity - Number(quantity)));\n      });\n      return map;\n    }, requiredAssets);\n    this.meshTxBuilderBody.mints.reduce((map, mint) => {\n      for (const assetValue of mint.mintValue) {\n        const mintAmount: Asset = {\n          unit: mint.policyId + assetValue.assetName,\n          quantity: String(assetValue.amount),\n        };\n        const existingQuantity = Number(map.get(mintAmount.unit)) || 0;\n        map.set(\n          mintAmount.unit,\n          String(existingQuantity - Number(mintAmount.quantity)),\n        );\n      }\n      return map;\n    }, requiredAssets);\n    const selectionConfig = this.meshTxBuilderBody.selectionConfig;\n\n    const utxoSelection = new UtxoSelection(\n      selectionConfig.threshold,\n      selectionConfig.includeTxFees,\n    );\n\n    let selectedInputs: UTxO[] = [];\n    switch (selectionConfig.strategy) {\n      case \"keepRelevant\":\n        selectedInputs = utxoSelection.keepRelevant(\n          requiredAssets,\n          this.meshTxBuilderBody.extraInputs,\n        );\n      case \"largestFirst\":\n        selectedInputs = utxoSelection.largestFirst(\n          requiredAssets,\n          this.meshTxBuilderBody.extraInputs,\n        );\n        break;\n\n      case \"largestFirstMultiAsset\":\n        selectedInputs = utxoSelection.largestFirstMultiAsset(\n          requiredAssets,\n          this.meshTxBuilderBody.extraInputs,\n        );\n        break;\n\n      default:\n        selectedInputs = utxoSelection.experimental(\n          requiredAssets,\n          this.meshTxBuilderBody.extraInputs,\n        );\n        break;\n    }\n\n    selectedInputs.forEach((input) => {\n      const pubKeyTxIn: PubKeyTxIn = {\n        type: \"PubKey\",\n        txIn: {\n          txHash: input.input.txHash,\n          txIndex: input.input.outputIndex,\n          amount: input.output.amount,\n          address: input.output.address,\n        },\n      };\n      this.meshTxBuilderBody.inputs.push(pubKeyTxIn);\n      // If an input selected has script ref, then we must\n      // provide the script size to the tx builder also\n      if (input.output.scriptRef) {\n        this.meshTxBuilderBody.referenceInputs.push({\n          txHash: input.input.txHash,\n          txIndex: input.input.outputIndex,\n          scriptSize: input.output.scriptRef!.length / 2,\n        });\n      }\n      this.inputForEvaluation(input);\n    });\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.removeDuplicateInputs",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.removeDuplicateInputs",
      "name": "removeDuplicateInputs",
      "signature": "removeDuplicateInputs = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 1949,
      "raw": "  removeDuplicateInputs = () => {\n    const { inputs } = this.meshTxBuilderBody;\n    const getTxInId = (txIn: TxInParameter): string =>\n      `${txIn.txHash}#${txIn.txIndex}`;\n    const currentTxInIds: string[] = [];\n    const addedInputs: TxIn[] = [];\n    for (let i = 0; i < inputs.length; i += 1) {\n      const currentInput = inputs[i]!;\n      const currentTxInId = getTxInId(currentInput.txIn);\n      if (currentTxInIds.includes(currentTxInId)) {\n        continue;\n      } else {\n        currentTxInIds.push(currentTxInId);\n        addedInputs.push(currentInput);\n      }\n    }\n    this.meshTxBuilderBody.inputs = addedInputs;\n  };",
      "source": "mesh-transaction",
      "implementation": "  removeDuplicateInputs = () => {\n    const { inputs } = this.meshTxBuilderBody;\n    const getTxInId = (txIn: TxInParameter): string =>\n      `${txIn.txHash}#${txIn.txIndex}`;\n    const currentTxInIds: string[] = [];\n    const addedInputs: TxIn[] = [];\n    for (let i = 0; i < inputs.length; i += 1) {\n      const currentInput = inputs[i]!;\n      const currentTxInId = getTxInId(currentInput.txIn);\n      if (currentTxInIds.includes(currentTxInId)) {\n        continue;\n      } else {\n        currentTxInIds.push(currentTxInId);\n        addedInputs.push(currentInput);\n      }\n    }\n    this.meshTxBuilderBody.inputs = addedInputs;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.getTxInId",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.getTxInId",
      "name": "getTxInId",
      "signature": "const getTxInId = (txIn: RefTxIn): string =>",
      "documentation": "",
      "parameters": [
        {
          "name": "txIn",
          "type": "RefTxIn",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 1970,
      "raw": "    const getTxInId = (txIn: RefTxIn): string =>\n      `${txIn.txHash}#${txIn.txIndex}`;",
      "source": "mesh-transaction",
      "implementation": "    const getTxInId = (txIn: RefTxIn): string =>\n      `${txIn.txHash}#${txIn.txIndex}`;"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.removeDuplicateRefInputs",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.removeDuplicateRefInputs",
      "name": "removeDuplicateRefInputs",
      "signature": "removeDuplicateRefInputs = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 1968,
      "raw": "  removeDuplicateRefInputs = () => {\n    const { referenceInputs } = this.meshTxBuilderBody;\n    const getTxInId = (txIn: RefTxIn): string =>\n      `${txIn.txHash}#${txIn.txIndex}`;\n    const currentTxInIds: string[] = [];\n    const addedInputs: RefTxIn[] = [];\n    for (let i = 0; i < referenceInputs.length; i += 1) {\n      const currentInput = referenceInputs[i]!;\n      const currentTxInId = getTxInId(currentInput);\n      if (currentTxInIds.includes(currentTxInId)) {\n        continue;\n      } else {\n        currentTxInIds.push(currentTxInId);\n        addedInputs.push(currentInput);\n      }\n    }\n    this.meshTxBuilderBody.referenceInputs = addedInputs;\n  };",
      "source": "mesh-transaction",
      "implementation": "  removeDuplicateRefInputs = () => {\n    const { referenceInputs } = this.meshTxBuilderBody;\n    const getTxInId = (txIn: RefTxIn): string =>\n      `${txIn.txHash}#${txIn.txIndex}`;\n    const currentTxInIds: string[] = [];\n    const addedInputs: RefTxIn[] = [];\n    for (let i = 0; i < referenceInputs.length; i += 1) {\n      const currentInput = referenceInputs[i]!;\n      const currentTxInId = getTxInId(currentInput);\n      if (currentTxInIds.includes(currentTxInId)) {\n        continue;\n      } else {\n        currentTxInIds.push(currentTxInId);\n        addedInputs.push(currentInput);\n      }\n    }\n    this.meshTxBuilderBody.referenceInputs = addedInputs;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.emptyTxBuilderBody",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.emptyTxBuilderBody",
      "name": "emptyTxBuilderBody",
      "signature": "emptyTxBuilderBody = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 1987,
      "raw": "  emptyTxBuilderBody = () => {\n    this.meshTxBuilderBody = emptyTxBuilderBody();\n    return emptyTxBuilderBody;\n  };",
      "source": "mesh-transaction",
      "implementation": "  emptyTxBuilderBody = () => {\n    this.meshTxBuilderBody = emptyTxBuilderBody();\n    return emptyTxBuilderBody;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.reset",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.reset",
      "name": "reset",
      "signature": "reset = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 1992,
      "raw": "  reset = () => {\n    this.meshTxBuilderBody = emptyTxBuilderBody();\n    this.txEvaluationMultiplier = 1;\n    this.txOutput = undefined;\n    this.addingPlutusScriptInput = false;\n    this.plutusSpendingScriptVersion = undefined;\n    this.addingPlutusMint = false;\n    this.plutusMintingScriptVersion = undefined;\n    this.addingPlutusWithdrawal = false;\n    this.addingPlutusVote = false;\n    this.plutusWithdrawalScriptVersion = undefined;\n    this._protocolParams = DEFAULT_PROTOCOL_PARAMETERS;\n    this.mintItem = undefined;\n    this.txInQueueItem = undefined;\n    this.withdrawalItem = undefined;\n    this.voteItem = undefined;\n    this.collateralQueueItem = undefined;\n    this.refScriptTxInQueueItem = undefined;\n  };",
      "source": "mesh-transaction",
      "implementation": "  reset = () => {\n    this.meshTxBuilderBody = emptyTxBuilderBody();\n    this.txEvaluationMultiplier = 1;\n    this.txOutput = undefined;\n    this.addingPlutusScriptInput = false;\n    this.plutusSpendingScriptVersion = undefined;\n    this.addingPlutusMint = false;\n    this.plutusMintingScriptVersion = undefined;\n    this.addingPlutusWithdrawal = false;\n    this.addingPlutusVote = false;\n    this.plutusWithdrawalScriptVersion = undefined;\n    this._protocolParams = DEFAULT_PROTOCOL_PARAMETERS;\n    this.mintItem = undefined;\n    this.txInQueueItem = undefined;\n    this.withdrawalItem = undefined;\n    this.voteItem = undefined;\n    this.collateralQueueItem = undefined;\n    this.refScriptTxInQueueItem = undefined;\n  };"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.utils.ts.utxoToTxIn",
      "fullName": "mesh-transaction:mesh-tx-builder.utils.ts.utxoToTxIn",
      "name": "utxoToTxIn",
      "signature": "export const utxoToTxIn = (utxo: UTxO): [string, number, Asset[], string] => {",
      "documentation": "/**\n * Convert UTxO to TxIn parameters in array for MeshTxBuilder\n * @param utxo UTxO\n * @returns [txHash, outputIndex, amount, address]\n */",
      "parameters": [
        {
          "name": "utxo",
          "type": "UTxO",
          "optional": false
        }
      ],
      "returnType": "[string, number, Asset[], string]",
      "isPublic": true,
      "line": 19,
      "raw": "/**\n * Convert UTxO to TxIn parameters in array for MeshTxBuilder\n * @param utxo UTxO\n * @returns [txHash, outputIndex, amount, address]\n */\nexport const utxoToTxIn = (utxo: UTxO): [string, number, Asset[], string] => {\n  return [\n    utxo.input.txHash,\n    utxo.input.outputIndex,\n    utxo.output.amount,\n    utxo.output.address,\n  ];\n};",
      "source": "mesh-transaction",
      "implementation": "export const utxoToTxIn = (utxo: UTxO): [string, number, Asset[], string] => {\n  return [\n    utxo.input.txHash,\n    utxo.input.outputIndex,\n    utxo.output.amount,\n    utxo.output.address,\n  ];\n};"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.utils.ts.getUtxoMinLovelace",
      "fullName": "mesh-transaction:mesh-tx-builder.utils.ts.getUtxoMinLovelace",
      "name": "getUtxoMinLovelace",
      "signature": "export const getUtxoMinLovelace = (",
      "documentation": "/**\n * Calculate minimum lovelace required for a UTxO output\n * @param utxo Output of utxo\n * @param coinsPerUtxoSize From protocol parameters\n * @returns Minimum lovelace required for the UTxO\n */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 34,
      "raw": "/**\n * Calculate minimum lovelace required for a UTxO output\n * @param utxo Output of utxo\n * @param coinsPerUtxoSize From protocol parameters\n * @returns Minimum lovelace required for the UTxO\n */\nexport const getUtxoMinLovelace = (\n  utxo: TxOutput,\n  coinsPerUtxoSize = DEFAULT_PROTOCOL_PARAMETERS.coinsPerUtxoSize,\n): bigint => {\n  const referenceScript: PlutusScript | undefined = utxo.scriptRef\n    ? { code: utxo.scriptRef, version: \"V3\" } // Language version is not relevant in min utxo calculation\n    : undefined;\n\n  let datum:\n    | {\n        type: \"Hash\" | \"Inline\" | \"Embedded\";\n        data: BuilderData;\n      }\n    | undefined;\n\n  if (utxo.plutusData) {\n    datum = {\n      type: \"Inline\",\n      data: {\n        content: utxo.plutusData,\n        type: \"CBOR\",\n      },\n    };\n  } else if (utxo.dataHash) {\n    datum = {\n      type: \"Hash\",\n      data: {\n        content: utxo.dataHash, // usually this should be entire datum cbor, but irrelevant in min utxo calculation\n        type: \"CBOR\",\n      },\n    };\n  }\n\n  const output: Output = {\n    address: utxo.address,\n    amount: utxo.amount,\n    referenceScript,\n    datum,\n  };\n  const minLovelace = getOutputMinLovelace(output, coinsPerUtxoSize);\n  return minLovelace;\n};",
      "source": "mesh-transaction",
      "implementation": "export const getUtxoMinLovelace = (\n  utxo: TxOutput,\n  coinsPerUtxoSize = DEFAULT_PROTOCOL_PARAMETERS.coinsPerUtxoSize,\n): bigint => {\n  const referenceScript: PlutusScript | undefined = utxo.scriptRef\n    ? { code: utxo.scriptRef, version: \"V3\" } // Language version is not relevant in min utxo calculation\n    : undefined;\n\n  let datum:\n    | {\n        type: \"Hash\" | \"Inline\" | \"Embedded\";\n        data: BuilderData;\n      }\n    | undefined;\n\n  if (utxo.plutusData) {\n    datum = {\n      type: \"Inline\",\n      data: {\n        content: utxo.plutusData,\n        type: \"CBOR\",\n      },\n    };\n  } else if (utxo.dataHash) {\n    datum = {\n      type: \"Hash\",\n      data: {\n        content: utxo.dataHash, // usually this should be entire datum cbor, but irrelevant in min utxo calculation\n        type: \"CBOR\",\n      },\n    };\n  }\n\n  const output: Output = {\n    address: utxo.address,\n    amount: utxo.amount,\n    referenceScript,\n    datum,\n  };\n  const minLovelace = getOutputMinLovelace(output, coinsPerUtxoSize);\n  return minLovelace;\n};"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.sendAssets",
      "fullName": "mesh-transaction:transaction.index.ts.sendAssets",
      "name": "sendAssets",
      "signature": "sendAssets(recipient: Recipient, assets: Asset[] | string): Transaction {",
      "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * @param recipient The recipient of the output.\n   * @param assets The assets to send. Provide string for lovelace and Asset[] for tokens and/or lovelace.\n   * @returns The transaction builder.\n   * @see {@link https://meshjs.dev/apis/transaction#sendAssets}\n   */",
      "parameters": [
        {
          "name": "recipient",
          "type": "Recipient",
          "optional": false
        },
        {
          "name": "assets",
          "type": "Asset[] | string",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "isPublic": true,
      "line": 133,
      "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * @param recipient The recipient of the output.\n   * @param assets The assets to send. Provide string for lovelace and Asset[] for tokens and/or lovelace.\n   * @returns The transaction builder.\n   * @see {@link https://meshjs.dev/apis/transaction#sendAssets}\n   */\n  sendAssets(recipient: Recipient, assets: Asset[] | string): Transaction {\n    if (typeof assets === \"string\") {\n      assets = [\n        {\n          unit: \"lovelace\",\n          quantity: assets,\n        },\n      ];\n    }\n    if (typeof recipient === \"string\") {\n      this.txBuilder.txOut(recipient, assets);\n    }\n    if (typeof recipient === \"object\") {\n      this.txBuilder.txOut(recipient.address, assets);\n      if (recipient.datum) {\n        if (recipient.datum.inline) {\n          this.txBuilder.txOutInlineDatumValue(recipient.datum.value);\n        } else {\n          this.txBuilder.txOutDatumHashValue(recipient.datum.value);\n        }\n      }\n    }\n\n    return this;\n  }",
      "source": "mesh-transaction",
      "implementation": "  sendAssets(recipient: Recipient, assets: Asset[] | string): Transaction {\n    if (typeof assets === \"string\") {\n      assets = [\n        {\n          unit: \"lovelace\",\n          quantity: assets,\n        },\n      ];\n    }\n    if (typeof recipient === \"string\") {\n      this.txBuilder.txOut(recipient, assets);\n    }\n    if (typeof recipient === \"object\") {\n      this.txBuilder.txOut(recipient.address, assets);\n      if (recipient.datum) {\n        if (recipient.datum.inline) {\n          this.txBuilder.txOutInlineDatumValue(recipient.datum.value);\n        } else {\n          this.txBuilder.txOutDatumHashValue(recipient.datum.value);\n        }\n      }\n    }\n\n    return this;\n  }"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.sendLovelace",
      "fullName": "mesh-transaction:transaction.index.ts.sendLovelace",
      "name": "sendLovelace",
      "signature": "sendLovelace(recipient: Recipient, lovelace: string): Transaction {",
      "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Use sendAssets instead:\n   * ```ts\n   * this.sendAssets(recipient, lovelace);\n   * ```\n   *\n   * Deprecation reason - Unnecessary implementation which might cause confusion.\n   *\n   * @param {Recipient} recipient The recipient of the transaction.\n   * @param {string} lovelace The amount of lovelace to send.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#sendAda}\n   */",
      "parameters": [
        {
          "name": "recipient",
          "type": "Recipient",
          "optional": false
        },
        {
          "name": "lovelace",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "isPublic": true,
      "line": 175,
      "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Use sendAssets instead:\n   * ```ts\n   * this.sendAssets(recipient, lovelace);\n   * ```\n   *\n   * Deprecation reason - Unnecessary implementation which might cause confusion.\n   *\n   * @param {Recipient} recipient The recipient of the transaction.\n   * @param {string} lovelace The amount of lovelace to send.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#sendAda}\n   */\n  sendLovelace(recipient: Recipient, lovelace: string): Transaction {\n    return this.sendAssets(recipient, lovelace);\n  }",
      "source": "mesh-transaction",
      "implementation": "  sendLovelace(recipient: Recipient, lovelace: string): Transaction {\n    return this.sendAssets(recipient, lovelace);\n  }"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.sendToken",
      "fullName": "mesh-transaction:transaction.index.ts.sendToken",
      "name": "sendToken",
      "signature": "sendToken(recipient: Recipient, ticker: Token, amount: string): Transaction {",
      "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Please use sendAssets with helper function to obtain token unit instead:\n   * ```ts\n   * const assets = [{ unit: SUPPORTED_TOKENS.GIMBAL, quantity: \"100\" }]\n   * transaction.sendAssets(recipient, assets)\n   * ```\n   *\n   * Deprecation reason - Required maintenance on tokens.\n   *\n   * @param {Recipient} recipient The recipient of the transaction.\n   * @param {Token} ticker The ticker of the token to send.\n   * @param {string} amount The amount of the token to send.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#sendToken}\n   */",
      "parameters": [
        {
          "name": "recipient",
          "type": "Recipient",
          "optional": false
        },
        {
          "name": "ticker",
          "type": "Token",
          "optional": false
        },
        {
          "name": "amount",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "isPublic": true,
      "line": 197,
      "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Please use sendAssets with helper function to obtain token unit instead:\n   * ```ts\n   * const assets = [{ unit: SUPPORTED_TOKENS.GIMBAL, quantity: \"100\" }]\n   * transaction.sendAssets(recipient, assets)\n   * ```\n   *\n   * Deprecation reason - Required maintenance on tokens.\n   *\n   * @param {Recipient} recipient The recipient of the transaction.\n   * @param {Token} ticker The ticker of the token to send.\n   * @param {string} amount The amount of the token to send.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#sendToken}\n   */\n  sendToken(recipient: Recipient, ticker: Token, amount: string): Transaction {\n    const assets = [{ unit: SUPPORTED_TOKENS[ticker], quantity: amount }];\n    return this.sendAssets(recipient, assets);\n  }",
      "source": "mesh-transaction",
      "implementation": "  sendToken(recipient: Recipient, ticker: Token, amount: string): Transaction {\n    const assets = [{ unit: SUPPORTED_TOKENS[ticker], quantity: amount }];\n    return this.sendAssets(recipient, assets);\n  }"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.sendValue",
      "fullName": "mesh-transaction:transaction.index.ts.sendValue",
      "name": "sendValue",
      "signature": "sendValue(recipient: Recipient, value: UTxO): Transaction {",
      "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * ```ts\n   * const assets = value.output.amount;\n   * this.sendAssets(recipient, assets);\n   * ```\n   * Deprecation reason - Unnecessary implementation which might cause confusion.\n   *\n   * @param {Recipient} recipient The recipient of the output.\n   * @param {UTxO} value The UTxO value of the output.\n   * @returns {Transaction} The Transaction object.\n   */",
      "parameters": [
        {
          "name": "recipient",
          "type": "Recipient",
          "optional": false
        },
        {
          "name": "value",
          "type": "UTxO",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "isPublic": true,
      "line": 216,
      "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * ```ts\n   * const assets = value.output.amount;\n   * this.sendAssets(recipient, assets);\n   * ```\n   * Deprecation reason - Unnecessary implementation which might cause confusion.\n   *\n   * @param {Recipient} recipient The recipient of the output.\n   * @param {UTxO} value The UTxO value of the output.\n   * @returns {Transaction} The Transaction object.\n   */\n  sendValue(recipient: Recipient, value: UTxO): Transaction {\n    const assets = value.output.amount;\n    return this.sendAssets(recipient, assets);\n  }",
      "source": "mesh-transaction",
      "implementation": "  sendValue(recipient: Recipient, value: UTxO): Transaction {\n    const assets = value.output.amount;\n    return this.sendAssets(recipient, assets);\n  }"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.setTxInputs",
      "fullName": "mesh-transaction:transaction.index.ts.setTxInputs",
      "name": "setTxInputs",
      "signature": "setTxInputs(inputs: UTxO[]): Transaction {",
      "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * @param {UTxO[]} inputs The inputs to set.\n   * @returns {Transaction} The transaction.\n   */",
      "parameters": [
        {
          "name": "inputs",
          "type": "UTxO[]",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "isPublic": true,
      "line": 228,
      "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * @param {UTxO[]} inputs The inputs to set.\n   * @returns {Transaction} The transaction.\n   */\n  setTxInputs(inputs: UTxO[]): Transaction {\n    inputs.forEach((input) => {\n      this.txBuilder.txIn(\n        input.input.txHash,\n        input.input.outputIndex,\n        input.output.amount,\n        input.output.address,\n        input.output.scriptRef ? input.output.scriptRef.length / 2 : 0,\n      );\n    });\n\n    return this;\n  }",
      "source": "mesh-transaction",
      "implementation": "  setTxInputs(inputs: UTxO[]): Transaction {\n    inputs.forEach((input) => {\n      this.txBuilder.txIn(\n        input.input.txHash,\n        input.input.outputIndex,\n        input.output.amount,\n        input.output.address,\n        input.output.scriptRef ? input.output.scriptRef.length / 2 : 0,\n      );\n    });\n\n    return this;\n  }"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.setTxRefInputs",
      "fullName": "mesh-transaction:transaction.index.ts.setTxRefInputs",
      "name": "setTxRefInputs",
      "signature": "setTxRefInputs(inputs: UTxO[]): Transaction {",
      "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * @param {UTxO[]} inputs The reference inputs to set.\n   * @returns {Transaction} The transaction.\n   */",
      "parameters": [
        {
          "name": "inputs",
          "type": "UTxO[]",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "isPublic": true,
      "line": 249,
      "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * @param {UTxO[]} inputs The reference inputs to set.\n   * @returns {Transaction} The transaction.\n   */\n  setTxRefInputs(inputs: UTxO[]): Transaction {\n    inputs.forEach((input) => {\n      this.txBuilder.readOnlyTxInReference(\n        input.input.txHash,\n        input.input.outputIndex,\n      );\n    });\n\n    return this;\n  }",
      "source": "mesh-transaction",
      "implementation": "  setTxRefInputs(inputs: UTxO[]): Transaction {\n    inputs.forEach((input) => {\n      this.txBuilder.readOnlyTxInReference(\n        input.input.txHash,\n        input.input.outputIndex,\n      );\n    });\n\n    return this;\n  }"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.setNativeScriptInput",
      "fullName": "mesh-transaction:transaction.index.ts.setNativeScriptInput",
      "name": "setNativeScriptInput",
      "signature": "setNativeScriptInput(script: NativeScript, utxo: UTxO): Transaction {",
      "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the native script for the transaction.\n   * @param {NativeScript} script The native script to spend from.\n   * @param {UTxO} utxo The UTxO attached to the script.\n   * @returns {Transaction} The Transaction object.\n   */",
      "parameters": [
        {
          "name": "script",
          "type": "NativeScript",
          "optional": false
        },
        {
          "name": "utxo",
          "type": "UTxO",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "isPublic": true,
      "line": 269,
      "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the native script for the transaction.\n   * @param {NativeScript} script The native script to spend from.\n   * @param {UTxO} utxo The UTxO attached to the script.\n   * @returns {Transaction} The Transaction object.\n   */\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): Transaction {\n    const { scriptCbor } =\n      this.txBuilder.serializer.deserializer.script.deserializeNativeScript(\n        script,\n      );\n    this.txBuilder\n      .txIn(\n        utxo.input.txHash,\n        utxo.input.outputIndex,\n        utxo.output.amount,\n        utxo.output.address,\n      )\n      .txInScript(scriptCbor!);\n\n    return this;\n  }",
      "source": "mesh-transaction",
      "implementation": "  setNativeScriptInput(script: NativeScript, utxo: UTxO): Transaction {\n    const { scriptCbor } =\n      this.txBuilder.serializer.deserializer.script.deserializeNativeScript(\n        script,\n      );\n    this.txBuilder\n      .txIn(\n        utxo.input.txHash,\n        utxo.input.outputIndex,\n        utxo.output.amount,\n        utxo.output.address,\n      )\n      .txInScript(scriptCbor!);\n\n    return this;\n  }"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.setChangeAddress",
      "fullName": "mesh-transaction:transaction.index.ts.setChangeAddress",
      "name": "setChangeAddress",
      "signature": "setChangeAddress(changeAddress: string): Transaction {",
      "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the change address for the transaction.\n   *\n   * @param {string} changeAddress The change address.\n   * @returns {Transaction} The Transaction object.\n   */",
      "parameters": [
        {
          "name": "changeAddress",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "isPublic": true,
      "line": 552,
      "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the change address for the transaction.\n   *\n   * @param {string} changeAddress The change address.\n   * @returns {Transaction} The Transaction object.\n   */\n  setChangeAddress(changeAddress: string): Transaction {\n    this.txBuilder.changeAddress(changeAddress);\n    return this;\n  }",
      "source": "mesh-transaction",
      "implementation": "  setChangeAddress(changeAddress: string): Transaction {\n    this.txBuilder.changeAddress(changeAddress);\n    return this;\n  }"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.setCollateral",
      "fullName": "mesh-transaction:transaction.index.ts.setCollateral",
      "name": "setCollateral",
      "signature": "setCollateral(collateral: UTxO[]): Transaction {",
      "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the collateral for the transaction.\n   *\n   * @param {UTxO[]} collateral - Set the UTxO for collateral.\n   * @returns {Transaction} The Transaction object.\n   */",
      "parameters": [
        {
          "name": "collateral",
          "type": "UTxO[]",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "isPublic": true,
      "line": 566,
      "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the collateral for the transaction.\n   *\n   * @param {UTxO[]} collateral - Set the UTxO for collateral.\n   * @returns {Transaction} The Transaction object.\n   */\n  setCollateral(collateral: UTxO[]): Transaction {\n    collateral.forEach((collateralUtxo) => {\n      this.txBuilder.txInCollateral(\n        collateralUtxo.input.txHash,\n        collateralUtxo.input.outputIndex,\n        collateralUtxo.output.amount,\n        collateralUtxo.output.address,\n      );\n    });\n\n    return this;\n  }",
      "source": "mesh-transaction",
      "implementation": "  setCollateral(collateral: UTxO[]): Transaction {\n    collateral.forEach((collateralUtxo) => {\n      this.txBuilder.txInCollateral(\n        collateralUtxo.input.txHash,\n        collateralUtxo.input.outputIndex,\n        collateralUtxo.output.amount,\n        collateralUtxo.output.address,\n      );\n    });\n\n    return this;\n  }"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.setNetwork",
      "fullName": "mesh-transaction:transaction.index.ts.setNetwork",
      "name": "setNetwork",
      "signature": "setNetwork = (network: Network) => {",
      "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the network to use, this is mainly to know the cost models to be used to calculate script integrity hash\n   * @param network The specific network this transaction is being built for (\"testnet\" | \"preview\" | \"preprod\" | \"mainnet\")\n   * @returns The Transaction object.\n   */",
      "parameters": [
        {
          "name": "network",
          "type": "Network",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 587,
      "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the network to use, this is mainly to know the cost models to be used to calculate script integrity hash\n   * @param network The specific network this transaction is being built for (\"testnet\" | \"preview\" | \"preprod\" | \"mainnet\")\n   * @returns The Transaction object.\n   */\n  setNetwork = (network: Network) => {\n    this.txBuilder.setNetwork(network);\n    return this;\n  };",
      "source": "mesh-transaction",
      "implementation": "  setNetwork = (network: Network) => {\n    this.txBuilder.setNetwork(network);\n    return this;\n  };"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.setRequiredSigners",
      "fullName": "mesh-transaction:transaction.index.ts.setRequiredSigners",
      "name": "setRequiredSigners",
      "signature": "setRequiredSigners(addresses: string[]): Transaction {",
      "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the required signers for the transaction.\n   *\n   * @param {string[]} addresses The addresses of the required signers.\n   * @returns {Transaction} The Transaction object.\n   */",
      "parameters": [
        {
          "name": "addresses",
          "type": "string[]",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "isPublic": true,
      "line": 601,
      "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   * Sets the required signers for the transaction.\n   *\n   * @param {string[]} addresses The addresses of the required signers.\n   * @returns {Transaction} The Transaction object.\n   */\n  setRequiredSigners(addresses: string[]): Transaction {\n    addresses.forEach((address) => {\n      const { pubKeyHash } =\n        this.txBuilder.serializer.deserializer.key.deserializeAddress(address);\n      this.txBuilder.requiredSignerHash(pubKeyHash);\n    });\n\n    return this;\n  }",
      "source": "mesh-transaction",
      "implementation": "  setRequiredSigners(addresses: string[]): Transaction {\n    addresses.forEach((address) => {\n      const { pubKeyHash } =\n        this.txBuilder.serializer.deserializer.key.deserializeAddress(address);\n      this.txBuilder.requiredSignerHash(pubKeyHash);\n    });\n\n    return this;\n  }"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.setTimeToExpire",
      "fullName": "mesh-transaction:transaction.index.ts.setTimeToExpire",
      "name": "setTimeToExpire",
      "signature": "setTimeToExpire(slot: string): Transaction {",
      "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   *  Set the time to live for the transaction.\n   *\n   * @param {string} slot The slot number to expire the transaction at.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#setTimeLimit}\n   */",
      "parameters": [
        {
          "name": "slot",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "isPublic": true,
      "line": 621,
      "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   *  Set the time to live for the transaction.\n   *\n   * @param {string} slot The slot number to expire the transaction at.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#setTimeLimit}\n   */\n  setTimeToExpire(slot: string): Transaction {\n    this.txBuilder.invalidHereafter(Number(slot));\n    return this;\n  }",
      "source": "mesh-transaction",
      "implementation": "  setTimeToExpire(slot: string): Transaction {\n    this.txBuilder.invalidHereafter(Number(slot));\n    return this;\n  }"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.setTimeToStart",
      "fullName": "mesh-transaction:transaction.index.ts.setTimeToStart",
      "name": "setTimeToStart",
      "signature": "setTimeToStart(slot: string): Transaction {",
      "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   *  Sets the start slot for the transaction.\n   *\n   * @param {string} slot The start slot for the transaction.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#setTimeLimit}\n   */",
      "parameters": [
        {
          "name": "slot",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "isPublic": true,
      "line": 636,
      "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   *  Sets the start slot for the transaction.\n   *\n   * @param {string} slot The start slot for the transaction.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#setTimeLimit}\n   */\n  setTimeToStart(slot: string): Transaction {\n    this.txBuilder.invalidBefore(Number(slot));\n    return this;\n  }",
      "source": "mesh-transaction",
      "implementation": "  setTimeToStart(slot: string): Transaction {\n    this.txBuilder.invalidBefore(Number(slot));\n    return this;\n  }"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.setMetadata",
      "fullName": "mesh-transaction:transaction.index.ts.setMetadata",
      "name": "setMetadata",
      "signature": "setMetadata(label: number, metadata: Metadatum | object): Transaction {",
      "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   *  Add a JSON metadata entry to the transaction.\n   *\n   * @param {number} label The label to use for the metadata entry.\n   * @param {unknown} metadata The value to use for the metadata entry.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#setMetadata}\n   */",
      "parameters": [
        {
          "name": "label",
          "type": "number",
          "optional": false
        },
        {
          "name": "metadata",
          "type": "Metadatum | object",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "isPublic": true,
      "line": 652,
      "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   *\n   *  Add a JSON metadata entry to the transaction.\n   *\n   * @param {number} label The label to use for the metadata entry.\n   * @param {unknown} metadata The value to use for the metadata entry.\n   * @returns {Transaction} The Transaction object.\n   * @see {@link https://meshjs.dev/apis/transaction#setMetadata}\n   */\n  setMetadata(label: number, metadata: Metadatum | object): Transaction {\n    this.txBuilder.metadataValue(label, metadata);\n    return this;\n  }",
      "source": "mesh-transaction",
      "implementation": "  setMetadata(label: number, metadata: Metadatum | object): Transaction {\n    this.txBuilder.metadataValue(label, metadata);\n    return this;\n  }"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.withdrawRewards",
      "fullName": "mesh-transaction:transaction.index.ts.withdrawRewards",
      "name": "withdrawRewards",
      "signature": "withdrawRewards(rewardAddress: string, lovelace: string): Transaction {",
      "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */",
      "parameters": [
        {
          "name": "rewardAddress",
          "type": "string",
          "optional": false
        },
        {
          "name": "lovelace",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "isPublic": true,
      "line": 661,
      "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  withdrawRewards(rewardAddress: string, lovelace: string): Transaction {\n    this.txBuilder.withdrawal(rewardAddress, lovelace);\n    return this;\n  }",
      "source": "mesh-transaction",
      "implementation": "  withdrawRewards(rewardAddress: string, lovelace: string): Transaction {\n    this.txBuilder.withdrawal(rewardAddress, lovelace);\n    return this;\n  }"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.delegateStake",
      "fullName": "mesh-transaction:transaction.index.ts.delegateStake",
      "name": "delegateStake",
      "signature": "delegateStake(rewardAddress: string, poolId: string): Transaction {",
      "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */",
      "parameters": [
        {
          "name": "rewardAddress",
          "type": "string",
          "optional": false
        },
        {
          "name": "poolId",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "isPublic": true,
      "line": 670,
      "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  delegateStake(rewardAddress: string, poolId: string): Transaction {\n    this.txBuilder.delegateStakeCertificate(\n      rewardAddress,\n      this.txBuilder.serializer.deserializer.cert.deserializePoolId(poolId),\n    );\n    return this;\n  }",
      "source": "mesh-transaction",
      "implementation": "  delegateStake(rewardAddress: string, poolId: string): Transaction {\n    this.txBuilder.delegateStakeCertificate(\n      rewardAddress,\n      this.txBuilder.serializer.deserializer.cert.deserializePoolId(poolId),\n    );\n    return this;\n  }"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.deregisterStake",
      "fullName": "mesh-transaction:transaction.index.ts.deregisterStake",
      "name": "deregisterStake",
      "signature": "deregisterStake(rewardAddress: string): Transaction {",
      "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */",
      "parameters": [
        {
          "name": "rewardAddress",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "isPublic": true,
      "line": 682,
      "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  deregisterStake(rewardAddress: string): Transaction {\n    this.txBuilder.deregisterStakeCertificate(rewardAddress);\n    return this;\n  }",
      "source": "mesh-transaction",
      "implementation": "  deregisterStake(rewardAddress: string): Transaction {\n    this.txBuilder.deregisterStakeCertificate(rewardAddress);\n    return this;\n  }"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.registerStake",
      "fullName": "mesh-transaction:transaction.index.ts.registerStake",
      "name": "registerStake",
      "signature": "registerStake(rewardAddress: string): Transaction {",
      "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */",
      "parameters": [
        {
          "name": "rewardAddress",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "isPublic": true,
      "line": 691,
      "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  registerStake(rewardAddress: string): Transaction {\n    this.txBuilder.registerStakeCertificate(rewardAddress);\n    return this;\n  }",
      "source": "mesh-transaction",
      "implementation": "  registerStake(rewardAddress: string): Transaction {\n    this.txBuilder.registerStakeCertificate(rewardAddress);\n    return this;\n  }"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.registerPool",
      "fullName": "mesh-transaction:transaction.index.ts.registerPool",
      "name": "registerPool",
      "signature": "registerPool(params: PoolParams): Transaction {",
      "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */",
      "parameters": [
        {
          "name": "params",
          "type": "PoolParams",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "isPublic": true,
      "line": 700,
      "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  registerPool(params: PoolParams): Transaction {\n    this.txBuilder.registerPoolCertificate(params);\n    return this;\n  }",
      "source": "mesh-transaction",
      "implementation": "  registerPool(params: PoolParams): Transaction {\n    this.txBuilder.registerPoolCertificate(params);\n    return this;\n  }"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.retirePool",
      "fullName": "mesh-transaction:transaction.index.ts.retirePool",
      "name": "retirePool",
      "signature": "retirePool(poolId: string, epochNo: number): Transaction {",
      "documentation": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */",
      "parameters": [
        {
          "name": "poolId",
          "type": "string",
          "optional": false
        },
        {
          "name": "epochNo",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "isPublic": true,
      "line": 709,
      "raw": "  /**\n   * [Deprecated] - `Transaction` class is on planning for V2.\n   * Use `MeshTxBuilder` instead for tx-building for now.\n   */\n  retirePool(poolId: string, epochNo: number): Transaction {\n    this.txBuilder.retirePoolCertificate(poolId, epochNo);\n    return this;\n  }",
      "source": "mesh-transaction",
      "implementation": "  retirePool(poolId: string, epochNo: number): Transaction {\n    this.txBuilder.retirePoolCertificate(poolId, epochNo);\n    return this;\n  }"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.mask",
      "fullName": "mesh-transaction:transaction.index.ts.mask",
      "name": "mask",
      "signature": "function mask(",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 808,
      "raw": "function mask(\n  metadatum: Serialization.TransactionMetadatum,\n): Serialization.TransactionMetadatum {\n  switch (metadatum.getKind()) {\n    case Serialization.TransactionMetadatumKind.Text:\n      return Serialization.TransactionMetadatum.newText(\n        \"0\".repeat(metadatum.asText()?.length ?? 0),\n      );\n    case Serialization.TransactionMetadatumKind.Bytes:\n    case Serialization.TransactionMetadatumKind.Integer:\n      return metadatum;\n    case Serialization.TransactionMetadatumKind.List:\n      const list = new Serialization.MetadatumList();\n      for (let i = 0; i < (metadatum.asList()?.getLength() ?? 0); i++) {\n        list.add(mask(metadatum.asList()?.get(i)!));\n      }\n      return Serialization.TransactionMetadatum.newList(list);\n    case Serialization.TransactionMetadatumKind.Map:\n      const map = new Serialization.MetadatumMap();\n      for (let i = 0; i < (metadatum.asMap()?.getLength() ?? 0); i++) {\n        const key = metadatum.asMap()?.getKeys().get(i)!;\n        const value = metadatum.asMap()?.get(key)!;\n        map.insert(key, mask(value));\n      }\n      return Serialization.TransactionMetadatum.newMap(map);\n    default:\n      throw new Error(`Unsupported metadatum kind: ${metadatum.getKind()}`);\n  }\n}",
      "source": "mesh-transaction",
      "implementation": "function mask(\n  metadatum: Serialization.TransactionMetadatum,\n): Serialization.TransactionMetadatum {\n  switch (metadatum.getKind()) {\n    case Serialization.TransactionMetadatumKind.Text:\n      return Serialization.TransactionMetadatum.newText(\n        \"0\".repeat(metadatum.asText()?.length ?? 0),\n      );\n    case Serialization.TransactionMetadatumKind.Bytes:\n    case Serialization.TransactionMetadatumKind.Integer:\n      return metadatum;\n    case Serialization.TransactionMetadatumKind.List:\n      const list = new Serialization.MetadatumList();\n      for (let i = 0; i < (metadatum.asList()?.getLength() ?? 0); i++) {\n        list.add(mask(metadatum.asList()?.get(i)!));\n      }\n      return Serialization.TransactionMetadatum.newList(list);\n    case Serialization.TransactionMetadatumKind.Map:\n      const map = new Serialization.MetadatumMap();\n      for (let i = 0; i < (metadatum.asMap()?.getLength() ?? 0); i++) {\n        const key = metadatum.asMap()?.getKeys().get(i)!;\n        const value = metadatum.asMap()?.get(key)!;\n        map.insert(key, mask(value));\n      }\n      return Serialization.TransactionMetadatum.newMap(map);\n    default:\n      throw new Error(`Unsupported metadatum kind: ${metadatum.getKind()}`);\n  }\n}"
    },
    {
      "key": "mesh-transaction:transaction.transaction-v2.ts.sendLovelace",
      "fullName": "mesh-transaction:transaction.transaction-v2.ts.sendLovelace",
      "name": "sendLovelace",
      "signature": "sendLovelace(recipient: Recipient, lovelace: string): this;",
      "documentation": "",
      "parameters": [
        {
          "name": "recipient",
          "type": "Recipient",
          "optional": false
        },
        {
          "name": "lovelace",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "this;",
      "isPublic": true,
      "line": 25,
      "raw": "  sendLovelace(recipient: Recipient, lovelace: string): this;\n  sendToken(recipient: Recipient, ticker: Token, amount: string): this;\n  sendValue(recipient: Recipient, value: UTxO): this;\n  setTxInputs(inputs: UTxO[]): this;\n  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;",
      "source": "mesh-transaction",
      "implementation": "  sendLovelace(recipient: Recipient, lovelace: string): this;\n  sendToken(recipient: Recipient, ticker: Token, amount: string): this;\n  sendValue(recipient: Recipient, value: UTxO): this;\n  setTxInputs(inputs: UTxO[]): this;\n  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;"
    },
    {
      "key": "mesh-transaction:transaction.transaction-v2.ts.sendToken",
      "fullName": "mesh-transaction:transaction.transaction-v2.ts.sendToken",
      "name": "sendToken",
      "signature": "sendToken(recipient: Recipient, ticker: Token, amount: string): this;",
      "documentation": "",
      "parameters": [
        {
          "name": "recipient",
          "type": "Recipient",
          "optional": false
        },
        {
          "name": "ticker",
          "type": "Token",
          "optional": false
        },
        {
          "name": "amount",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "this;",
      "isPublic": true,
      "line": 26,
      "raw": "  sendToken(recipient: Recipient, ticker: Token, amount: string): this;\n  sendValue(recipient: Recipient, value: UTxO): this;\n  setTxInputs(inputs: UTxO[]): this;\n  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;",
      "source": "mesh-transaction",
      "implementation": "  sendToken(recipient: Recipient, ticker: Token, amount: string): this;\n  sendValue(recipient: Recipient, value: UTxO): this;\n  setTxInputs(inputs: UTxO[]): this;\n  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;"
    },
    {
      "key": "mesh-transaction:transaction.transaction-v2.ts.sendValue",
      "fullName": "mesh-transaction:transaction.transaction-v2.ts.sendValue",
      "name": "sendValue",
      "signature": "sendValue(recipient: Recipient, value: UTxO): this;",
      "documentation": "",
      "parameters": [
        {
          "name": "recipient",
          "type": "Recipient",
          "optional": false
        },
        {
          "name": "value",
          "type": "UTxO",
          "optional": false
        }
      ],
      "returnType": "this;",
      "isPublic": true,
      "line": 27,
      "raw": "  sendValue(recipient: Recipient, value: UTxO): this;\n  setTxInputs(inputs: UTxO[]): this;\n  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;",
      "source": "mesh-transaction",
      "implementation": "  sendValue(recipient: Recipient, value: UTxO): this;\n  setTxInputs(inputs: UTxO[]): this;\n  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;"
    },
    {
      "key": "mesh-transaction:transaction.transaction-v2.ts.setTxInputs",
      "fullName": "mesh-transaction:transaction.transaction-v2.ts.setTxInputs",
      "name": "setTxInputs",
      "signature": "setTxInputs(inputs: UTxO[]): this;",
      "documentation": "",
      "parameters": [
        {
          "name": "inputs",
          "type": "UTxO[]",
          "optional": false
        }
      ],
      "returnType": "this;",
      "isPublic": true,
      "line": 28,
      "raw": "  setTxInputs(inputs: UTxO[]): this;\n  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;",
      "source": "mesh-transaction",
      "implementation": "  setTxInputs(inputs: UTxO[]): this;\n  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;"
    },
    {
      "key": "mesh-transaction:transaction.transaction-v2.ts.setTxRefInputs",
      "fullName": "mesh-transaction:transaction.transaction-v2.ts.setTxRefInputs",
      "name": "setTxRefInputs",
      "signature": "setTxRefInputs(inputs: UTxO[]): this;",
      "documentation": "",
      "parameters": [
        {
          "name": "inputs",
          "type": "UTxO[]",
          "optional": false
        }
      ],
      "returnType": "this;",
      "isPublic": true,
      "line": 29,
      "raw": "  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;",
      "source": "mesh-transaction",
      "implementation": "  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;"
    },
    {
      "key": "mesh-transaction:transaction.transaction-v2.ts.setNativeScriptInput",
      "fullName": "mesh-transaction:transaction.transaction-v2.ts.setNativeScriptInput",
      "name": "setNativeScriptInput",
      "signature": "setNativeScriptInput(script: NativeScript, utxo: UTxO): this;",
      "documentation": "",
      "parameters": [
        {
          "name": "script",
          "type": "NativeScript",
          "optional": false
        },
        {
          "name": "utxo",
          "type": "UTxO",
          "optional": false
        }
      ],
      "returnType": "this;",
      "isPublic": true,
      "line": 30,
      "raw": "  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;",
      "source": "mesh-transaction",
      "implementation": "  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;"
    },
    {
      "key": "mesh-transaction:transaction.transaction-v2.ts.setChangeAddress",
      "fullName": "mesh-transaction:transaction.transaction-v2.ts.setChangeAddress",
      "name": "setChangeAddress",
      "signature": "setChangeAddress(changeAddress: string): this;",
      "documentation": "",
      "parameters": [
        {
          "name": "changeAddress",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "this;",
      "isPublic": true,
      "line": 47,
      "raw": "  setChangeAddress(changeAddress: string): this;",
      "source": "mesh-transaction",
      "implementation": "  setChangeAddress(changeAddress: string): this;"
    },
    {
      "key": "mesh-transaction:transaction.transaction-v2.ts.setCollateral",
      "fullName": "mesh-transaction:transaction.transaction-v2.ts.setCollateral",
      "name": "setCollateral",
      "signature": "setCollateral(collateral: UTxO[]): this;",
      "documentation": "",
      "parameters": [
        {
          "name": "collateral",
          "type": "UTxO[]",
          "optional": false
        }
      ],
      "returnType": "this;",
      "isPublic": true,
      "line": 48,
      "raw": "  setCollateral(collateral: UTxO[]): this;",
      "source": "mesh-transaction",
      "implementation": "  setCollateral(collateral: UTxO[]): this;"
    },
    {
      "key": "mesh-transaction:transaction.transaction-v2.ts.setRequiredSigners",
      "fullName": "mesh-transaction:transaction.transaction-v2.ts.setRequiredSigners",
      "name": "setRequiredSigners",
      "signature": "setRequiredSigners(addresses: string[]): this;",
      "documentation": "",
      "parameters": [
        {
          "name": "addresses",
          "type": "string[]",
          "optional": false
        }
      ],
      "returnType": "this;",
      "isPublic": true,
      "line": 49,
      "raw": "  setRequiredSigners(addresses: string[]): this;",
      "source": "mesh-transaction",
      "implementation": "  setRequiredSigners(addresses: string[]): this;"
    },
    {
      "key": "mesh-transaction:transaction.transaction-v2.ts.setTimeToExpire",
      "fullName": "mesh-transaction:transaction.transaction-v2.ts.setTimeToExpire",
      "name": "setTimeToExpire",
      "signature": "setTimeToExpire(slot: string): this;",
      "documentation": "",
      "parameters": [
        {
          "name": "slot",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "this;",
      "isPublic": true,
      "line": 50,
      "raw": "  setTimeToExpire(slot: string): this;",
      "source": "mesh-transaction",
      "implementation": "  setTimeToExpire(slot: string): this;"
    },
    {
      "key": "mesh-transaction:transaction.transaction-v2.ts.setTimeToStart",
      "fullName": "mesh-transaction:transaction.transaction-v2.ts.setTimeToStart",
      "name": "setTimeToStart",
      "signature": "setTimeToStart(slot: string): this;",
      "documentation": "",
      "parameters": [
        {
          "name": "slot",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "this;",
      "isPublic": true,
      "line": 51,
      "raw": "  setTimeToStart(slot: string): this;",
      "source": "mesh-transaction",
      "implementation": "  setTimeToStart(slot: string): this;"
    },
    {
      "key": "mesh-transaction:transaction.transaction-v2.ts.withdrawRewards",
      "fullName": "mesh-transaction:transaction.transaction-v2.ts.withdrawRewards",
      "name": "withdrawRewards",
      "signature": "withdrawRewards(rewardAddress: string, lovelace: string): this;",
      "documentation": "",
      "parameters": [
        {
          "name": "rewardAddress",
          "type": "string",
          "optional": false
        },
        {
          "name": "lovelace",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "this;",
      "isPublic": true,
      "line": 56,
      "raw": "  withdrawRewards(rewardAddress: string, lovelace: string): this;",
      "source": "mesh-transaction",
      "implementation": "  withdrawRewards(rewardAddress: string, lovelace: string): this;"
    },
    {
      "key": "mesh-transaction:transaction.transaction-v2.ts.delegateStake",
      "fullName": "mesh-transaction:transaction.transaction-v2.ts.delegateStake",
      "name": "delegateStake",
      "signature": "delegateStake(rewardAddress: string, poolId: string): this;",
      "documentation": "",
      "parameters": [
        {
          "name": "rewardAddress",
          "type": "string",
          "optional": false
        },
        {
          "name": "poolId",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "this;",
      "isPublic": true,
      "line": 57,
      "raw": "  delegateStake(rewardAddress: string, poolId: string): this;",
      "source": "mesh-transaction",
      "implementation": "  delegateStake(rewardAddress: string, poolId: string): this;"
    },
    {
      "key": "mesh-transaction:transaction.transaction-v2.ts.deregisterStake",
      "fullName": "mesh-transaction:transaction.transaction-v2.ts.deregisterStake",
      "name": "deregisterStake",
      "signature": "deregisterStake(rewardAddress: string): this;",
      "documentation": "",
      "parameters": [
        {
          "name": "rewardAddress",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "this;",
      "isPublic": true,
      "line": 58,
      "raw": "  deregisterStake(rewardAddress: string): this;",
      "source": "mesh-transaction",
      "implementation": "  deregisterStake(rewardAddress: string): this;"
    },
    {
      "key": "mesh-transaction:transaction.transaction-v2.ts.registerStake",
      "fullName": "mesh-transaction:transaction.transaction-v2.ts.registerStake",
      "name": "registerStake",
      "signature": "registerStake(rewardAddress: string): this;",
      "documentation": "",
      "parameters": [
        {
          "name": "rewardAddress",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "this;",
      "isPublic": true,
      "line": 59,
      "raw": "  registerStake(rewardAddress: string): this;",
      "source": "mesh-transaction",
      "implementation": "  registerStake(rewardAddress: string): this;"
    },
    {
      "key": "mesh-transaction:transaction.transaction-v2.ts.registerPool",
      "fullName": "mesh-transaction:transaction.transaction-v2.ts.registerPool",
      "name": "registerPool",
      "signature": "registerPool(params: PoolParams): this;",
      "documentation": "",
      "parameters": [
        {
          "name": "params",
          "type": "PoolParams",
          "optional": false
        }
      ],
      "returnType": "this;",
      "isPublic": true,
      "line": 60,
      "raw": "  registerPool(params: PoolParams): this;",
      "source": "mesh-transaction",
      "implementation": "  registerPool(params: PoolParams): this;"
    },
    {
      "key": "mesh-transaction:transaction.transaction-v2.ts.retirePool",
      "fullName": "mesh-transaction:transaction.transaction-v2.ts.retirePool",
      "name": "retirePool",
      "signature": "retirePool(poolId: string, epochNo: number): this;",
      "documentation": "",
      "parameters": [
        {
          "name": "poolId",
          "type": "string",
          "optional": false
        },
        {
          "name": "epochNo",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "this;",
      "isPublic": true,
      "line": 61,
      "raw": "  retirePool(poolId: string, epochNo: number): this;",
      "source": "mesh-transaction",
      "implementation": "  retirePool(poolId: string, epochNo: number): this;"
    },
    {
      "key": "mesh-transaction:transaction.transaction-v2.ts.spendUtxo",
      "fullName": "mesh-transaction:transaction.transaction-v2.ts.spendUtxo",
      "name": "spendUtxo",
      "signature": "spendUtxo(utxo: UTxO, redeemer?: Data): this;",
      "documentation": "",
      "parameters": [
        {
          "name": "utxo",
          "type": "UTxO",
          "optional": false
        },
        {
          "name": "redeemer",
          "type": "Data",
          "optional": true
        }
      ],
      "returnType": "this;",
      "isPublic": true,
      "line": 62,
      "raw": "  spendUtxo(utxo: UTxO, redeemer?: Data): this;",
      "source": "mesh-transaction",
      "implementation": "  spendUtxo(utxo: UTxO, redeemer?: Data): this;"
    },
    {
      "key": "mesh-transaction:tx-parser.index.ts.getBuilderBody",
      "fullName": "mesh-transaction:tx-parser.index.ts.getBuilderBody",
      "name": "getBuilderBody",
      "signature": "getBuilderBody = () => this.serializer.parser.getBuilderBody();",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 59,
      "raw": "  getBuilderBody = () => this.serializer.parser.getBuilderBody();",
      "source": "mesh-transaction",
      "implementation": "  getBuilderBody = () => this.serializer.parser.getBuilderBody();"
    },
    {
      "key": "mesh-transaction:tx-parser.index.ts.getBuilderBodyWithoutChange",
      "fullName": "mesh-transaction:tx-parser.index.ts.getBuilderBodyWithoutChange",
      "name": "getBuilderBodyWithoutChange",
      "signature": "getBuilderBodyWithoutChange = () =>",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 61,
      "raw": "  getBuilderBodyWithoutChange = () =>",
      "source": "mesh-transaction",
      "implementation": "  getBuilderBodyWithoutChange = () =>"
    },
    {
      "key": "mesh-transaction:tx-parser.index.ts.toTester",
      "fullName": "mesh-transaction:tx-parser.index.ts.toTester",
      "name": "toTester",
      "signature": "toTester = () => this.serializer.parser.toTester();",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 64,
      "raw": "  toTester = () => this.serializer.parser.toTester();",
      "source": "mesh-transaction",
      "implementation": "  toTester = () => this.serializer.parser.toTester();"
    },
    {
      "key": "mesh-transaction:utils.metadata.ts.metadataObjToMap",
      "fullName": "mesh-transaction:utils.metadata.ts.metadataObjToMap",
      "name": "metadataObjToMap",
      "signature": "export const metadataObjToMap = (metadata: any): Metadatum => {",
      "documentation": "",
      "parameters": [
        {
          "name": "metadata",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Metadatum",
      "isPublic": true,
      "line": 7,
      "raw": "export const metadataObjToMap = (metadata: any): Metadatum => {\n  if (typeof metadata === \"bigint\") {\n    return metadata;\n  } else if (typeof metadata === \"string\") {\n    return metadata;\n  } else if (typeof metadata === \"number\") {\n    return metadata;\n  } else if (metadata instanceof Uint8Array) {\n    return metadata;\n  } else if (Array.isArray(metadata)) {\n    // Recursively process each element in the array\n    return metadata.map(metadataObjToMap);\n  } else if (metadata && typeof metadata === \"object\") {\n    // Convert to MetadatumMap recursively\n    const map: MetadatumMap = new Map();\n    if (metadata instanceof Map) {\n      // for Map\n      metadata.forEach((value, key) => {\n        map.set(metadataObjToMap(key), metadataObjToMap(value));\n      });\n    } else {\n      // for Object\n      Object.entries(metadata).forEach(([key, value]) => {\n        map.set(metadataObjToMap(key), metadataObjToMap(value));\n      });\n    }\n    return map;\n  } else {\n    throw new Error(\"Metadata map conversion: Unsupported metadata type\");\n  }\n};",
      "source": "mesh-transaction",
      "implementation": "export const metadataObjToMap = (metadata: any): Metadatum => {\n  if (typeof metadata === \"bigint\") {\n    return metadata;\n  } else if (typeof metadata === \"string\") {\n    return metadata;\n  } else if (typeof metadata === \"number\") {\n    return metadata;\n  } else if (metadata instanceof Uint8Array) {\n    return metadata;\n  } else if (Array.isArray(metadata)) {\n    // Recursively process each element in the array\n    return metadata.map(metadataObjToMap);\n  } else if (metadata && typeof metadata === \"object\") {\n    // Convert to MetadatumMap recursively\n    const map: MetadatumMap = new Map();\n    if (metadata instanceof Map) {\n      // for Map\n      metadata.forEach((value, key) => {\n        map.set(metadataObjToMap(key), metadataObjToMap(value));\n      });\n    } else {\n      // for Object\n      Object.entries(metadata).forEach(([key, value]) => {\n        map.set(metadataObjToMap(key), metadataObjToMap(value));\n      });\n    }\n    return map;\n  } else {\n    throw new Error(\"Metadata map conversion: Unsupported metadata type\");\n  }\n};"
    },
    {
      "key": "mesh-transaction:utils.metadata.ts.mergeContents",
      "fullName": "mesh-transaction:utils.metadata.ts.mergeContents",
      "name": "mergeContents",
      "signature": "export const mergeContents = (",
      "documentation": "/**\n * Recursively merge two metadata. Returns the 2nd item if the maximum allowed\n * merge depth has passed.\n *\n * Merging maps ({ key: value }):\n * Two maps are merged by recursively including the (key, value) pairs from both the maps.\n * When further merge isn't allowed (by currentDepth), the 2nd item is preferred,\n * replacing the 1st item.\n *\n * Merging arrays:\n * Two arrays are merged by concatenating them.\n * When merge isn't allowed (by currentDepth), the 2nd array is returned.\n *\n * Merging primitive types (number, string, etc.):\n * Primitive types are not merged in the sense of concatenating. In case they are the same,\n * either of them can be considered as the \"merged value\". 2nd item is returned here.\n * When merge isn't allowed (by currentDepth), the 2nd item is returned.\n *\n * @param a first item\n * @param b second item\n * @param currentDepth the current merge depth; decreases in a recursive call\n * @returns merged item or a preferred item, chosen according to currentDepth\n */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 62,
      "raw": "/**\n * Recursively merge two metadata. Returns the 2nd item if the maximum allowed\n * merge depth has passed.\n *\n * Merging maps ({ key: value }):\n * Two maps are merged by recursively including the (key, value) pairs from both the maps.\n * When further merge isn't allowed (by currentDepth), the 2nd item is preferred,\n * replacing the 1st item.\n *\n * Merging arrays:\n * Two arrays are merged by concatenating them.\n * When merge isn't allowed (by currentDepth), the 2nd array is returned.\n *\n * Merging primitive types (number, string, etc.):\n * Primitive types are not merged in the sense of concatenating. In case they are the same,\n * either of them can be considered as the \"merged value\". 2nd item is returned here.\n * When merge isn't allowed (by currentDepth), the 2nd item is returned.\n *\n * @param a first item\n * @param b second item\n * @param currentDepth the current merge depth; decreases in a recursive call\n * @returns merged item or a preferred item, chosen according to currentDepth\n */\nexport const mergeContents = (\n  a: Metadatum,\n  b: Metadatum,\n  currentDepth: number,\n): Metadatum => {\n  // Handle no merge\n  if (currentDepth <= 0) {\n    return b;\n  }\n  // Handle merging of maps\n  if (a instanceof Map && b instanceof Map) {\n    b.forEach((value: Metadatum, key: Metadatum) => {\n      if (a.has(key)) {\n        a.set(\n          key,\n          mergeContents(a.get(key) as Metadatum, value, currentDepth - 1),\n        );\n      } else {\n        a.set(key, value);\n      }\n    });\n    return a;\n  }\n  // Handle merging of arrays\n  else if (Array.isArray(a) && Array.isArray(b)) {\n    return [...a, ...b];\n  }\n  // Handle merging of primitive types\n  if (\n    (typeof a === \"number\" ||\n      typeof a === \"bigint\" ||\n      typeof a === \"string\" ||\n      a instanceof Uint8Array) &&\n    (typeof b === \"number\" ||\n      typeof b === \"bigint\" ||\n      typeof b === \"string\" ||\n      b instanceof Uint8Array)\n  ) {\n    if (typeof a === typeof b) {\n      if (a === b) {\n        // Equal primitive types (string, number or bigint)\n        return b;\n      }\n      if (\n        a instanceof Uint8Array &&\n        b instanceof Uint8Array &&\n        areUint8ArraysEqual(a, b)\n      ) {\n        // Equal Uint8Array values\n        return b;\n      }\n    }\n    // If values are not equal or types are mismatched\n    throw new Error(\n      `Tx metadata merge error: cannot merge ${JSONBig.stringify(a)} with ${JSONBig.stringify(b)}`,\n    );\n  }\n\n  // Unsupported or mismatched types\n  throw new Error(\n    `Tx metadata merge error: cannot merge ${getMetadatumType(a)} type with ${getMetadatumType(b)} type`,\n  );\n};",
      "source": "mesh-transaction",
      "implementation": "export const mergeContents = (\n  a: Metadatum,\n  b: Metadatum,\n  currentDepth: number,\n): Metadatum => {\n  // Handle no merge\n  if (currentDepth <= 0) {\n    return b;\n  }\n  // Handle merging of maps\n  if (a instanceof Map && b instanceof Map) {\n    b.forEach((value: Metadatum, key: Metadatum) => {\n      if (a.has(key)) {\n        a.set(\n          key,\n          mergeContents(a.get(key) as Metadatum, value, currentDepth - 1),\n        );\n      } else {\n        a.set(key, value);\n      }\n    });\n    return a;\n  }\n  // Handle merging of arrays\n  else if (Array.isArray(a) && Array.isArray(b)) {\n    return [...a, ...b];\n  }\n  // Handle merging of primitive types\n  if (\n    (typeof a === \"number\" ||\n      typeof a === \"bigint\" ||\n      typeof a === \"string\" ||\n      a instanceof Uint8Array) &&\n    (typeof b === \"number\" ||\n      typeof b === \"bigint\" ||\n      typeof b === \"string\" ||\n      b instanceof Uint8Array)\n  ) {\n    if (typeof a === typeof b) {\n      if (a === b) {\n        // Equal primitive types (string, number or bigint)\n        return b;\n      }\n      if (\n        a instanceof Uint8Array &&\n        b instanceof Uint8Array &&\n        areUint8ArraysEqual(a, b)\n      ) {\n        // Equal Uint8Array values\n        return b;\n      }\n    }\n    // If values are not equal or types are mismatched\n    throw new Error(\n      `Tx metadata merge error: cannot merge ${JSONBig.stringify(a)} with ${JSONBig.stringify(b)}`,\n    );\n  }\n\n  // Unsupported or mismatched types\n  throw new Error(\n    `Tx metadata merge error: cannot merge ${getMetadatumType(a)} type with ${getMetadatumType(b)} type`,\n  );\n};"
    },
    {
      "key": "mesh-transaction:utils.metadata.ts.getMergeDepth",
      "fullName": "mesh-transaction:utils.metadata.ts.getMergeDepth",
      "name": "getMergeDepth",
      "signature": "const getMergeDepth = (mergeOption: MetadataMergeLevel): number => {",
      "documentation": "",
      "parameters": [
        {
          "name": "mergeOption",
          "type": "MetadataMergeLevel",
          "optional": false
        }
      ],
      "returnType": "number",
      "isPublic": true,
      "line": 126,
      "raw": "const getMergeDepth = (mergeOption: MetadataMergeLevel): number => {\n  return typeof mergeOption === \"number\"\n    ? mergeOption\n    : mergeOption === true\n      ? 1\n      : 0;\n};",
      "source": "mesh-transaction",
      "implementation": "const getMergeDepth = (mergeOption: MetadataMergeLevel): number => {\n  return typeof mergeOption === \"number\"\n    ? mergeOption\n    : mergeOption === true\n      ? 1\n      : 0;\n};"
    },
    {
      "key": "mesh-transaction:utils.metadata.ts.getMetadatumType",
      "fullName": "mesh-transaction:utils.metadata.ts.getMetadatumType",
      "name": "getMetadatumType",
      "signature": "const getMetadatumType = (a: Metadatum): string => {",
      "documentation": "",
      "parameters": [
        {
          "name": "a",
          "type": "Metadatum",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 134,
      "raw": "const getMetadatumType = (a: Metadatum): string => {\n  if (a instanceof Map) return \"map\";\n  if (Array.isArray(a)) return \"array\";\n  return \"primitive\";\n};",
      "source": "mesh-transaction",
      "implementation": "const getMetadatumType = (a: Metadatum): string => {\n  if (a instanceof Map) return \"map\";\n  if (Array.isArray(a)) return \"array\";\n  return \"primitive\";\n};"
    },
    {
      "key": "mesh-transaction:utils.metadata.ts.areUint8ArraysEqual",
      "fullName": "mesh-transaction:utils.metadata.ts.areUint8ArraysEqual",
      "name": "areUint8ArraysEqual",
      "signature": "const areUint8ArraysEqual = (a: Uint8Array, b: Uint8Array): boolean => {",
      "documentation": "",
      "parameters": [
        {
          "name": "a",
          "type": "Uint8Array",
          "optional": false
        },
        {
          "name": "b",
          "type": "Uint8Array",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "isPublic": true,
      "line": 140,
      "raw": "const areUint8ArraysEqual = (a: Uint8Array, b: Uint8Array): boolean => {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};",
      "source": "mesh-transaction",
      "implementation": "const areUint8ArraysEqual = (a: Uint8Array, b: Uint8Array): boolean => {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};"
    },
    {
      "key": "mesh-wallet:app.index.ts.getEnterpriseAddress",
      "fullName": "mesh-wallet:app.index.ts.getEnterpriseAddress",
      "name": "getEnterpriseAddress",
      "signature": "getEnterpriseAddress(accountIndex = 0, keyIndex = 0): string {",
      "documentation": "",
      "parameters": [
        {
          "name": "accountIndex",
          "type": "any",
          "optional": false
        },
        {
          "name": "keyIndex",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 120,
      "raw": "  getEnterpriseAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.enterpriseAddressBech32;\n  }",
      "source": "mesh-wallet",
      "implementation": "  getEnterpriseAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.enterpriseAddressBech32;\n  }"
    },
    {
      "key": "mesh-wallet:app.index.ts.getPaymentAddress",
      "fullName": "mesh-wallet:app.index.ts.getPaymentAddress",
      "name": "getPaymentAddress",
      "signature": "getPaymentAddress(accountIndex = 0, keyIndex = 0): string {",
      "documentation": "",
      "parameters": [
        {
          "name": "accountIndex",
          "type": "any",
          "optional": false
        },
        {
          "name": "keyIndex",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 125,
      "raw": "  getPaymentAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.baseAddressBech32;\n  }",
      "source": "mesh-wallet",
      "implementation": "  getPaymentAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.baseAddressBech32;\n  }"
    },
    {
      "key": "mesh-wallet:app.index.ts.getRewardAddress",
      "fullName": "mesh-wallet:app.index.ts.getRewardAddress",
      "name": "getRewardAddress",
      "signature": "getRewardAddress(accountIndex = 0, keyIndex = 0): string {",
      "documentation": "",
      "parameters": [
        {
          "name": "accountIndex",
          "type": "any",
          "optional": false
        },
        {
          "name": "keyIndex",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 130,
      "raw": "  getRewardAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.rewardAddressBech32;\n  }",
      "source": "mesh-wallet",
      "implementation": "  getRewardAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.rewardAddressBech32;\n  }"
    },
    {
      "key": "mesh-wallet:app.index.ts.getNetworkId",
      "fullName": "mesh-wallet:app.index.ts.getNetworkId",
      "name": "getNetworkId",
      "signature": "getNetworkId(): number {",
      "documentation": "",
      "parameters": [],
      "returnType": "number",
      "isPublic": true,
      "line": 135,
      "raw": "  getNetworkId(): number {\n    return this._wallet.getNetworkId();\n  }",
      "source": "mesh-wallet",
      "implementation": "  getNetworkId(): number {\n    return this._wallet.getNetworkId();\n  }"
    },
    {
      "key": "mesh-wallet:app.index.ts.submitTx",
      "fullName": "mesh-wallet:app.index.ts.submitTx",
      "name": "submitTx",
      "signature": "submitTx(tx: string): Promise<string> {",
      "documentation": "",
      "parameters": [
        {
          "name": "tx",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Promise<string>",
      "isPublic": true,
      "line": 236,
      "raw": "  submitTx(tx: string): Promise<string> {\n    if (!this._submitter) {\n      throw new Error(\n        \"[AppWallet] Submitter is required to submit transactions. Please provide a submitter.\",\n      );\n    }\n    return this._submitter.submitTx(tx);\n  }",
      "source": "mesh-wallet",
      "implementation": "  submitTx(tx: string): Promise<string> {\n    if (!this._submitter) {\n      throw new Error(\n        \"[AppWallet] Submitter is required to submit transactions. Please provide a submitter.\",\n      );\n    }\n    return this._submitter.submitTx(tx);\n  }"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.getNetworkId",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.getNetworkId",
      "name": "getNetworkId",
      "signature": "getNetworkId(): Promise<number> {",
      "documentation": "  /**\n   * Returns the network ID of the currently connected account. 0 is testnet and 1 is mainnet but other networks can possibly be returned by wallets. Those other network ID values are not governed by CIP-30. This result will stay the same unless the connected account has changed.\n   *\n   * @returns network ID\n   */",
      "parameters": [],
      "returnType": "Promise<number>",
      "isPublic": true,
      "line": 207,
      "raw": "  /**\n   * Returns the network ID of the currently connected account. 0 is testnet and 1 is mainnet but other networks can possibly be returned by wallets. Those other network ID values are not governed by CIP-30. This result will stay the same unless the connected account has changed.\n   *\n   * @returns network ID\n   */\n  getNetworkId(): Promise<number> {\n    return this._walletInstance.getNetworkId();\n  }",
      "source": "mesh-wallet",
      "implementation": "  getNetworkId(): Promise<number> {\n    return this._walletInstance.getNetworkId();\n  }"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.submitTx",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.submitTx",
      "name": "submitTx",
      "signature": "submitTx(tx: string): Promise<string> {",
      "documentation": "  /**\n   * Submits the signed transaction to the blockchain network.\n   *\n   * As wallets should already have this ability to submit transaction, we allow apps to request that a transaction be sent through it. If the wallet accepts the transaction and tries to send it, it shall return the transaction ID for the app to track. The wallet can return error messages or failure if there was an error in sending it.\n   *\n   * @param tx\n   * @returns a transaction hash\n   */",
      "parameters": [
        {
          "name": "tx",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Promise<string>",
      "isPublic": true,
      "line": 365,
      "raw": "  /**\n   * Submits the signed transaction to the blockchain network.\n   *\n   * As wallets should already have this ability to submit transaction, we allow apps to request that a transaction be sent through it. If the wallet accepts the transaction and tries to send it, it shall return the transaction ID for the app to track. The wallet can return error messages or failure if there was an error in sending it.\n   *\n   * @param tx\n   * @returns a transaction hash\n   */\n  submitTx(tx: string): Promise<string> {\n    return this._walletInstance.submitTx(tx);\n  }",
      "source": "mesh-wallet",
      "implementation": "  submitTx(tx: string): Promise<string> {\n    return this._walletInstance.submitTx(tx);\n  }"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.utxos",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.utxos",
      "name": "utxos",
      "signature": "const utxos = (await this._walletInstance.getUtxos()) ?? [];",
      "documentation": "",
      "parameters": [
        {
          "name": "await this._walletInstance.getUtxos(",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 414,
      "raw": "    const utxos = (await this._walletInstance.getUtxos()) ?? [];\n    return utxos.map((u) => deserializeTxUnspentOutput(u));\n  }\n\n  /**\n   * A helper function to get the assets in the wallet.\n   *\n   * @returns a list of assets\n   */\n  async getAssets(): Promise<AssetExtended[]> {",
      "source": "mesh-wallet",
      "implementation": "    const utxos = (await this._walletInstance.getUtxos()) ?? [];\n    return utxos.map((u) => deserializeTxUnspentOutput(u));\n  }\n\n  /**\n   * A helper function to get the assets in the wallet.\n   *\n   * @returns a list of assets\n   */\n  async getAssets(): Promise<AssetExtended[]> {"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.dRepIDHash",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.dRepIDHash",
      "name": "dRepIDHash",
      "signature": "const dRepIDHash = (await dRepID.hash()).hex();",
      "documentation": "",
      "parameters": [
        {
          "name": "await dRepID.hash(",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 600,
      "raw": "    const dRepIDHash = (await dRepID.hash()).hex();\n    return {\n      dRepKeyHex,\n      dRepID,\n      dRepIDHash,\n    };",
      "source": "mesh-wallet",
      "implementation": "    const dRepIDHash = (await dRepID.hash()).hex();\n    return {\n      dRepKeyHex,\n      dRepID,\n      dRepIDHash,\n    };"
    },
    {
      "key": "mesh-wallet:browser.webauthn.cardano.build-wallet-from-passkey.ts.buildKey",
      "fullName": "mesh-wallet:browser.webauthn.cardano.build-wallet-from-passkey.ts.buildKey",
      "name": "buildKey",
      "signature": "function buildKey(entropy: Buffer, password: string) {",
      "documentation": "",
      "parameters": [
        {
          "name": "entropy",
          "type": "Buffer",
          "optional": false
        },
        {
          "name": "password",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 15,
      "raw": "function buildKey(entropy: Buffer, password: string) {\n  const bip32Key = Crypto.Bip32PrivateKey.fromBip39Entropy(entropy, password);\n\n  const bytes = base32.encode(bip32Key.bytes());\n  const bech32PrivateKey = bech32.encode(\"xprv\", bytes, 1023);\n\n  return {\n    bech32PrivateKey: bech32PrivateKey,\n  };\n}",
      "source": "mesh-wallet",
      "implementation": "function buildKey(entropy: Buffer, password: string) {\n  const bip32Key = Crypto.Bip32PrivateKey.fromBip39Entropy(entropy, password);\n\n  const bytes = base32.encode(bip32Key.bytes());\n  const bech32PrivateKey = bech32.encode(\"xprv\", bytes, 1023);\n\n  return {\n    bech32PrivateKey: bech32PrivateKey,\n  };\n}"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.getAccount",
      "fullName": "mesh-wallet:embedded.index.ts.getAccount",
      "name": "getAccount",
      "signature": "getAccount(accountIndex = 0, keyIndex = 0): Account {",
      "documentation": "",
      "parameters": [
        {
          "name": "accountIndex",
          "type": "any",
          "optional": false
        },
        {
          "name": "keyIndex",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Account",
      "isPublic": true,
      "line": 239,
      "raw": "  getAccount(accountIndex = 0, keyIndex = 0): Account {\n    if (this._walletSecret == undefined)\n      throw new Error(\"[EmbeddedWallet] No keys initialized\");\n\n    const { paymentKey, stakeKey, dRepKey } = buildKeys(\n      this._walletSecret,\n      accountIndex,\n      keyIndex,\n    );\n\n    const { baseAddress, enterpriseAddress, rewardAddress } =\n      WalletStaticMethods.getAddresses(paymentKey, stakeKey, this._networkId);\n\n    let _account: Account = {\n      baseAddress: baseAddress,\n      enterpriseAddress: enterpriseAddress,\n      rewardAddress: rewardAddress,\n\n      baseAddressBech32: baseAddress.toBech32(),\n      enterpriseAddressBech32: enterpriseAddress.toBech32(),\n      rewardAddressBech32: rewardAddress.toBech32(),\n\n      paymentKey: paymentKey,\n      stakeKey: stakeKey,\n      paymentKeyHex: paymentKey.hex(),\n      stakeKeyHex: stakeKey.hex(),\n    };\n\n    if (dRepKey) {\n      const { pubDRepKey, dRepIDBech32, dRepIDHash, dRepIDCip105 } =\n        WalletStaticMethods.getDRepKey(dRepKey, this._networkId);\n      _account.drepKey = dRepKey;\n      _account.pubDRepKey = pubDRepKey;\n      _account.dRepIDBech32 = dRepIDBech32;\n      _account.dRepIDHash = dRepIDHash;\n      _account.dRepIDCip105 = dRepIDCip105;\n    }\n\n    return _account;\n  }",
      "source": "mesh-wallet",
      "implementation": "  getAccount(accountIndex = 0, keyIndex = 0): Account {\n    if (this._walletSecret == undefined)\n      throw new Error(\"[EmbeddedWallet] No keys initialized\");\n\n    const { paymentKey, stakeKey, dRepKey } = buildKeys(\n      this._walletSecret,\n      accountIndex,\n      keyIndex,\n    );\n\n    const { baseAddress, enterpriseAddress, rewardAddress } =\n      WalletStaticMethods.getAddresses(paymentKey, stakeKey, this._networkId);\n\n    let _account: Account = {\n      baseAddress: baseAddress,\n      enterpriseAddress: enterpriseAddress,\n      rewardAddress: rewardAddress,\n\n      baseAddressBech32: baseAddress.toBech32(),\n      enterpriseAddressBech32: enterpriseAddress.toBech32(),\n      rewardAddressBech32: rewardAddress.toBech32(),\n\n      paymentKey: paymentKey,\n      stakeKey: stakeKey,\n      paymentKeyHex: paymentKey.hex(),\n      stakeKeyHex: stakeKey.hex(),\n    };\n\n    if (dRepKey) {\n      const { pubDRepKey, dRepIDBech32, dRepIDHash, dRepIDCip105 } =\n        WalletStaticMethods.getDRepKey(dRepKey, this._networkId);\n      _account.drepKey = dRepKey;\n      _account.pubDRepKey = pubDRepKey;\n      _account.dRepIDBech32 = dRepIDBech32;\n      _account.dRepIDHash = dRepIDHash;\n      _account.dRepIDCip105 = dRepIDCip105;\n    }\n\n    return _account;\n  }"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.getNetworkId",
      "fullName": "mesh-wallet:embedded.index.ts.getNetworkId",
      "name": "getNetworkId",
      "signature": "getNetworkId(): number {",
      "documentation": "  /**\n   * Get wallet network ID.\n   *\n   * @returns network ID\n   */",
      "parameters": [],
      "returnType": "number",
      "isPublic": true,
      "line": 285,
      "raw": "  /**\n   * Get wallet network ID.\n   *\n   * @returns network ID\n   */\n  getNetworkId(): number {\n    return this._networkId;\n  }",
      "source": "mesh-wallet",
      "implementation": "  getNetworkId(): number {\n    return this._networkId;\n  }"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.getUsedAddress",
      "fullName": "mesh-wallet:mesh.index.ts.getUsedAddress",
      "name": "getUsedAddress",
      "signature": "getUsedAddress(addressType: GetAddressType = \"payment\"): Address {",
      "documentation": "  /**\n   * Get a used address of type Address from the wallet.\n   *\n   * This is used in transaction building.\n   *\n   * @param addressType - the type of address to fetch UTXOs from (default: payment)\n   * @returns an Address object\n   */",
      "parameters": [
        {
          "name": "addressType",
          "type": "GetAddressType",
          "optional": false
        }
      ],
      "returnType": "Address",
      "isPublic": true,
      "line": 511,
      "raw": "  /**\n   * Get a used address of type Address from the wallet.\n   *\n   * This is used in transaction building.\n   *\n   * @param addressType - the type of address to fetch UTXOs from (default: payment)\n   * @returns an Address object\n   */\n  getUsedAddress(addressType: GetAddressType = \"payment\"): Address {\n    if (this.addresses.baseAddressBech32 && addressType === \"payment\") {\n      return toAddress(this.addresses.baseAddressBech32);\n    } else {\n      return toAddress(this.addresses.enterpriseAddressBech32!);\n    }\n  }",
      "source": "mesh-wallet",
      "implementation": "  getUsedAddress(addressType: GetAddressType = \"payment\"): Address {\n    if (this.addresses.baseAddressBech32 && addressType === \"payment\") {\n      return toAddress(this.addresses.baseAddressBech32);\n    } else {\n      return toAddress(this.addresses.enterpriseAddressBech32!);\n    }\n  }"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.getPubDRepKey",
      "fullName": "mesh-wallet:mesh.index.ts.getPubDRepKey",
      "name": "getPubDRepKey",
      "signature": "getPubDRepKey(): {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 640,
      "raw": "  getPubDRepKey(): {\n    pubDRepKey: string | undefined;\n    dRepIDBech32: string | undefined;\n    dRepIDHash: string | undefined;\n    dRepIDCip105: string | undefined;\n  } {\n    return {\n      pubDRepKey: this.addresses.pubDRepKey,\n      dRepIDBech32: this.addresses.dRepIDBech32,\n      dRepIDHash: this.addresses.dRepIDHash,\n      dRepIDCip105: this.addresses.dRepIDCip105,\n    };\n  }",
      "source": "mesh-wallet",
      "implementation": "  getPubDRepKey(): {\n    pubDRepKey: string | undefined;\n    dRepIDBech32: string | undefined;\n    dRepIDHash: string | undefined;\n    dRepIDCip105: string | undefined;\n  } {\n    return {\n      pubDRepKey: this.addresses.pubDRepKey,\n      dRepIDBech32: this.addresses.dRepIDBech32,\n      dRepIDHash: this.addresses.dRepIDHash,\n      dRepIDCip105: this.addresses.dRepIDCip105,\n    };\n  }"
    },
    {
      "key": "mesh-wallet:types.index.ts.getBalance",
      "fullName": "mesh-wallet:types.index.ts.getBalance",
      "name": "getBalance",
      "signature": "getBalance(): Promise<string>;",
      "documentation": "",
      "parameters": [],
      "returnType": "Promise<string>;",
      "isPublic": true,
      "line": 23,
      "raw": "  getBalance(): Promise<string>;\n  getChangeAddress(): Promise<string>;\n  getExtensions(): Promise<{ cip: number }[]>;",
      "source": "mesh-wallet",
      "implementation": "  getBalance(): Promise<string>;\n  getChangeAddress(): Promise<string>;\n  getExtensions(): Promise<{ cip: number }[]>;"
    },
    {
      "key": "mesh-wallet:types.index.ts.getChangeAddress",
      "fullName": "mesh-wallet:types.index.ts.getChangeAddress",
      "name": "getChangeAddress",
      "signature": "getChangeAddress(): Promise<string>;",
      "documentation": "",
      "parameters": [],
      "returnType": "Promise<string>;",
      "isPublic": true,
      "line": 24,
      "raw": "  getChangeAddress(): Promise<string>;\n  getExtensions(): Promise<{ cip: number }[]>;",
      "source": "mesh-wallet",
      "implementation": "  getChangeAddress(): Promise<string>;\n  getExtensions(): Promise<{ cip: number }[]>;"
    },
    {
      "key": "mesh-wallet:types.index.ts.getExtensions",
      "fullName": "mesh-wallet:types.index.ts.getExtensions",
      "name": "getExtensions",
      "signature": "getExtensions(): Promise<{ cip: number }[]>;",
      "documentation": "",
      "parameters": [],
      "returnType": "Promise<",
      "isPublic": true,
      "line": 25,
      "raw": "  getExtensions(): Promise<{ cip: number }[]>;",
      "source": "mesh-wallet",
      "implementation": "  getExtensions(): Promise<{ cip: number }[]>;"
    },
    {
      "key": "mesh-wallet:types.index.ts.getCollateral",
      "fullName": "mesh-wallet:types.index.ts.getCollateral",
      "name": "getCollateral",
      "signature": "getCollateral(): Promise<string[] | undefined>;",
      "documentation": "",
      "parameters": [],
      "returnType": "Promise<string[] | undefined>;",
      "isPublic": true,
      "line": 50,
      "raw": "  getCollateral(): Promise<string[] | undefined>;",
      "source": "mesh-wallet",
      "implementation": "  getCollateral(): Promise<string[] | undefined>;"
    },
    {
      "key": "mesh-wallet:types.index.ts.getNetworkId",
      "fullName": "mesh-wallet:types.index.ts.getNetworkId",
      "name": "getNetworkId",
      "signature": "getNetworkId(): Promise<number>;",
      "documentation": "",
      "parameters": [],
      "returnType": "Promise<number>;",
      "isPublic": true,
      "line": 27,
      "raw": "  getNetworkId(): Promise<number>;\n  getRewardAddresses(): Promise<string[]>;\n  getUnusedAddresses(): Promise<string[]>;\n  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {",
      "source": "mesh-wallet",
      "implementation": "  getNetworkId(): Promise<number>;\n  getRewardAddresses(): Promise<string[]>;\n  getUnusedAddresses(): Promise<string[]>;\n  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {"
    },
    {
      "key": "mesh-wallet:types.index.ts.getRewardAddresses",
      "fullName": "mesh-wallet:types.index.ts.getRewardAddresses",
      "name": "getRewardAddresses",
      "signature": "getRewardAddresses(): Promise<string[]>;",
      "documentation": "",
      "parameters": [],
      "returnType": "Promise<string[]>;",
      "isPublic": true,
      "line": 28,
      "raw": "  getRewardAddresses(): Promise<string[]>;\n  getUnusedAddresses(): Promise<string[]>;\n  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {",
      "source": "mesh-wallet",
      "implementation": "  getRewardAddresses(): Promise<string[]>;\n  getUnusedAddresses(): Promise<string[]>;\n  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {"
    },
    {
      "key": "mesh-wallet:types.index.ts.getUnusedAddresses",
      "fullName": "mesh-wallet:types.index.ts.getUnusedAddresses",
      "name": "getUnusedAddresses",
      "signature": "getUnusedAddresses(): Promise<string[]>;",
      "documentation": "",
      "parameters": [],
      "returnType": "Promise<string[]>;",
      "isPublic": true,
      "line": 29,
      "raw": "  getUnusedAddresses(): Promise<string[]>;\n  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {",
      "source": "mesh-wallet",
      "implementation": "  getUnusedAddresses(): Promise<string[]>;\n  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {"
    },
    {
      "key": "mesh-wallet:types.index.ts.getUsedAddresses",
      "fullName": "mesh-wallet:types.index.ts.getUsedAddresses",
      "name": "getUsedAddresses",
      "signature": "getUsedAddresses(): Promise<string[]>;",
      "documentation": "",
      "parameters": [],
      "returnType": "Promise<string[]>;",
      "isPublic": true,
      "line": 30,
      "raw": "  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {",
      "source": "mesh-wallet",
      "implementation": "  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {"
    },
    {
      "key": "mesh-wallet:types.index.ts.getUtxos",
      "fullName": "mesh-wallet:types.index.ts.getUtxos",
      "name": "getUtxos",
      "signature": "getUtxos(): Promise<string[] | undefined>;",
      "documentation": "",
      "parameters": [],
      "returnType": "Promise<string[] | undefined>;",
      "isPublic": true,
      "line": 31,
      "raw": "  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {",
      "source": "mesh-wallet",
      "implementation": "  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {"
    },
    {
      "key": "mesh-wallet:types.index.ts.signData",
      "fullName": "mesh-wallet:types.index.ts.signData",
      "name": "signData",
      "signature": "signData(address: string, payload: string): Promise<DataSignature>;",
      "documentation": "",
      "parameters": [
        {
          "name": "address",
          "type": "string",
          "optional": false
        },
        {
          "name": "payload",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Promise<DataSignature>;",
      "isPublic": true,
      "line": 44,
      "raw": "  signData(address: string, payload: string): Promise<DataSignature>;\n}\n\nexport type WalletInstance = Cip30WalletApi & Cip95WalletApi;\n\ntype ExperimentalFeatures = {",
      "source": "mesh-wallet",
      "implementation": "  signData(address: string, payload: string): Promise<DataSignature>;\n}\n\nexport type WalletInstance = Cip30WalletApi & Cip95WalletApi;\n\ntype ExperimentalFeatures = {"
    },
    {
      "key": "mesh-wallet:types.index.ts.signTx",
      "fullName": "mesh-wallet:types.index.ts.signTx",
      "name": "signTx",
      "signature": "signTx(tx: string, partialSign: boolean): Promise<string>;",
      "documentation": "",
      "parameters": [
        {
          "name": "tx",
          "type": "string",
          "optional": false
        },
        {
          "name": "partialSign",
          "type": "boolean",
          "optional": false
        }
      ],
      "returnType": "Promise<string>;",
      "isPublic": true,
      "line": 33,
      "raw": "  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {",
      "source": "mesh-wallet",
      "implementation": "  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {"
    },
    {
      "key": "mesh-wallet:types.index.ts.submitTx",
      "fullName": "mesh-wallet:types.index.ts.submitTx",
      "name": "submitTx",
      "signature": "submitTx(tx: string): Promise<string>;",
      "documentation": "",
      "parameters": [
        {
          "name": "tx",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Promise<string>;",
      "isPublic": true,
      "line": 36,
      "raw": "  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {",
      "source": "mesh-wallet",
      "implementation": "  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}\n\nexport interface Cip95WalletApi {"
    },
    {
      "key": "mesh-hydra:hydra-connection.ts.send",
      "fullName": "mesh-hydra:hydra-connection.ts.send",
      "name": "send",
      "signature": "send(data: unknown): void {",
      "documentation": "",
      "parameters": [
        {
          "name": "data",
          "type": "unknown",
          "optional": false
        }
      ],
      "returnType": "void",
      "isPublic": true,
      "line": 59,
      "raw": "  send(data: unknown): void {\n    const sendData = () => {\n      if (this._websocket?.readyState === WebSocket.OPEN) {\n        this._websocket.send(JSON.stringify(data));\n        return true;\n      }\n      return false;\n    };\n\n    const interval = setInterval(() => {\n      if (sendData()) {\n        clearInterval(interval);\n      }\n    }, 1000);\n\n    setTimeout(() => {\n      if (!sendData()) {\n        console.error(\"Failed to send data: WebSocket connection timeout.\");\n        clearInterval(interval);\n      }\n    }, 5000);\n  }",
      "source": "mesh-hydra",
      "implementation": "  send(data: unknown): void {\n    const sendData = () => {\n      if (this._websocket?.readyState === WebSocket.OPEN) {\n        this._websocket.send(JSON.stringify(data));\n        return true;\n      }\n      return false;\n    };\n\n    const interval = setInterval(() => {\n      if (sendData()) {\n        clearInterval(interval);\n      }\n    }, 1000);\n\n    setTimeout(() => {\n      if (!sendData()) {\n        console.error(\"Failed to send data: WebSocket connection timeout.\");\n        clearInterval(interval);\n      }\n    }, 5000);\n  }"
    },
    {
      "key": "mesh-hydra:hydra-connection.ts.sendData",
      "fullName": "mesh-hydra:hydra-connection.ts.sendData",
      "name": "sendData",
      "signature": "const sendData = () => {",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 60,
      "raw": "    const sendData = () => {\n      if (this._websocket?.readyState === WebSocket.OPEN) {\n        this._websocket.send(JSON.stringify(data));\n        return true;\n      }\n      return false;\n    };",
      "source": "mesh-hydra",
      "implementation": "    const sendData = () => {\n      if (this._websocket?.readyState === WebSocket.OPEN) {\n        this._websocket.send(JSON.stringify(data));\n        return true;\n      }\n      return false;\n    };"
    },
    {
      "key": "mesh-hydra:hydra-connection.ts.setTimeout",
      "fullName": "mesh-hydra:hydra-connection.ts.setTimeout",
      "name": "setTimeout",
      "signature": "setTimeout(() => {",
      "documentation": "",
      "parameters": [
        {
          "name": "(",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 74,
      "raw": "    setTimeout(() => {\n      if (!sendData()) {\n        console.error(\"Failed to send data: WebSocket connection timeout.\");\n        clearInterval(interval);\n      }\n    }, 5000);",
      "source": "mesh-hydra",
      "implementation": "    setTimeout(() => {\n      if (!sendData()) {\n        console.error(\"Failed to send data: WebSocket connection timeout.\");\n        clearInterval(interval);\n      }\n    }, 5000);"
    },
    {
      "key": "mesh-hydra:hydra-instance.ts.utxo",
      "fullName": "mesh-hydra:hydra-instance.ts.utxo",
      "name": "utxo",
      "signature": "const utxo = (await this.fetcher.fetchUTxOs(txHash, txIndex))[0];",
      "documentation": "",
      "parameters": [
        {
          "name": "await this.fetcher.fetchUTxOs(txHash, txIndex",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 36,
      "raw": "    const utxo = (await this.fetcher.fetchUTxOs(txHash, txIndex))[0];\n    if (!utxo) {\n      throw new Error(\"UTxO not found\");\n    }",
      "source": "mesh-hydra",
      "implementation": "    const utxo = (await this.fetcher.fetchUTxOs(txHash, txIndex))[0];\n    if (!utxo) {\n      throw new Error(\"UTxO not found\");\n    }"
    },
    {
      "key": "mesh-hydra:hydra-provider.ts.onStatusChange",
      "fullName": "mesh-hydra:hydra-provider.ts.onStatusChange",
      "name": "onStatusChange",
      "signature": "onStatusChange(callback: (status: hStatus) => void) {",
      "documentation": "",
      "parameters": [
        {
          "name": "callback",
          "type": "(status: hStatus",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 523,
      "raw": "  onStatusChange(callback: (status: hStatus) => void) {\n    this._eventEmitter.on(\"onstatuschange\", callback);\n  }",
      "source": "mesh-hydra",
      "implementation": "  onStatusChange(callback: (status: hStatus) => void) {\n    this._eventEmitter.on(\"onstatuschange\", callback);\n  }"
    },
    {
      "key": "mesh-hydra:hydra-provider.ts.fetchAccountInfo",
      "fullName": "mesh-hydra:hydra-provider.ts.fetchAccountInfo",
      "name": "fetchAccountInfo",
      "signature": "fetchAccountInfo(address: string): Promise<AccountInfo> {",
      "documentation": "",
      "parameters": [
        {
          "name": "address",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Promise<AccountInfo>",
      "isPublic": true,
      "line": 576,
      "raw": "  fetchAccountInfo(address: string): Promise<AccountInfo> {\n    throw new Error(\"Method not implemented.\");\n  }",
      "source": "mesh-hydra",
      "implementation": "  fetchAccountInfo(address: string): Promise<AccountInfo> {\n    throw new Error(\"Method not implemented.\");\n  }"
    },
    {
      "key": "mesh-hydra:hydra-provider.ts.fetchAssetMetadata",
      "fullName": "mesh-hydra:hydra-provider.ts.fetchAssetMetadata",
      "name": "fetchAssetMetadata",
      "signature": "fetchAssetMetadata(asset: string): Promise<AssetMetadata> {",
      "documentation": "",
      "parameters": [
        {
          "name": "asset",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Promise<AssetMetadata>",
      "isPublic": true,
      "line": 593,
      "raw": "  fetchAssetMetadata(asset: string): Promise<AssetMetadata> {\n    throw new Error(\"Method not implemented.\");\n  }",
      "source": "mesh-hydra",
      "implementation": "  fetchAssetMetadata(asset: string): Promise<AssetMetadata> {\n    throw new Error(\"Method not implemented.\");\n  }"
    },
    {
      "key": "mesh-hydra:hydra-provider.ts.fetchBlockInfo",
      "fullName": "mesh-hydra:hydra-provider.ts.fetchBlockInfo",
      "name": "fetchBlockInfo",
      "signature": "fetchBlockInfo(hash: string): Promise<BlockInfo> {",
      "documentation": "",
      "parameters": [
        {
          "name": "hash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Promise<BlockInfo>",
      "isPublic": true,
      "line": 597,
      "raw": "  fetchBlockInfo(hash: string): Promise<BlockInfo> {\n    throw new Error(\"Method not implemented.\");\n  }",
      "source": "mesh-hydra",
      "implementation": "  fetchBlockInfo(hash: string): Promise<BlockInfo> {\n    throw new Error(\"Method not implemented.\");\n  }"
    },
    {
      "key": "mesh-hydra:hydra-provider.ts.fetchTxInfo",
      "fullName": "mesh-hydra:hydra-provider.ts.fetchTxInfo",
      "name": "fetchTxInfo",
      "signature": "fetchTxInfo(hash: string): Promise<TransactionInfo> {",
      "documentation": "",
      "parameters": [
        {
          "name": "hash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Promise<TransactionInfo>",
      "isPublic": true,
      "line": 615,
      "raw": "  fetchTxInfo(hash: string): Promise<TransactionInfo> {\n    throw new Error(\"Method not implemented.\");\n  }",
      "source": "mesh-hydra",
      "implementation": "  fetchTxInfo(hash: string): Promise<TransactionInfo> {\n    throw new Error(\"Method not implemented.\");\n  }"
    },
    {
      "key": "mesh-hydra:types.hAssets.ts.hAssets",
      "fullName": "mesh-hydra:types.hAssets.ts.hAssets",
      "name": "hAssets",
      "signature": "export function hAssets(assets: Asset[]): hAssets {",
      "documentation": "",
      "parameters": [
        {
          "name": "assets",
          "type": "Asset[]",
          "optional": false
        }
      ],
      "returnType": "hAssets",
      "isPublic": true,
      "line": 11,
      "raw": "export function hAssets(assets: Asset[]): hAssets {\n  return assets.reduce((p, asset) => {\n      if (asset.unit === \"\" || asset.unit === \"lovelace\") {\n        p[\"lovelace\"] += BigInt(asset.quantity);\n      } else {\n        const policyId = asset.unit.slice(0, 56);\n        const assetName = asset.unit.slice(56);\n        if (!p[policyId]) p[policyId] = {};\n        p[policyId][assetName] = (p[policyId][assetName] ?? BigInt(0)) + BigInt(asset.quantity);\n      }\n      return p;\n    }, { lovelace: BigInt(0) } as hAssets\n  );\n}",
      "source": "mesh-hydra",
      "implementation": "export function hAssets(assets: Asset[]): hAssets {\n  return assets.reduce((p, asset) => {\n      if (asset.unit === \"\" || asset.unit === \"lovelace\") {\n        p[\"lovelace\"] += BigInt(asset.quantity);\n      } else {\n        const policyId = asset.unit.slice(0, 56);\n        const assetName = asset.unit.slice(56);\n        if (!p[policyId]) p[policyId] = {};\n        p[policyId][assetName] = (p[policyId][assetName] ?? BigInt(0)) + BigInt(asset.quantity);\n      }\n      return p;\n    }, { lovelace: BigInt(0) } as hAssets\n  );\n}"
    },
    {
      "key": "mesh-hydra:types.hStatus.ts.hStatus",
      "fullName": "mesh-hydra:types.hStatus.ts.hStatus",
      "name": "hStatus",
      "signature": "export function hStatus(value: { headStatus?: string; tag?: string; }): hStatus | null {",
      "documentation": "",
      "parameters": [
        {
          "name": "value",
          "type": "{ headStatus?: string; tag?: string; }",
          "optional": true
        }
      ],
      "returnType": "hStatus | null",
      "isPublic": true,
      "line": 3,
      "raw": "export function hStatus(value: { headStatus?: string; tag?: string; }): hStatus | null {\n  if (value.headStatus === \"Open\") return \"OPEN\";\n  \n  switch (value.tag) {\n    case \"HeadIsInitializing\":\n      return \"INITIALIZING\";\n    case \"HeadIsOpen\":\n      return \"OPEN\";\n    case \"HeadIsClosed\":\n      return \"CLOSED\";\n    case \"ReadyToFanout\":\n      return \"FANOUT_POSSIBLE\";\n    case \"HeadIsFinalized\":\n      return \"FINAL\";\n    default:\n      return null;\n  }\n}",
      "source": "mesh-hydra",
      "implementation": "export function hStatus(value: { headStatus?: string; tag?: string; }): hStatus | null {\n  if (value.headStatus === \"Open\") return \"OPEN\";\n  \n  switch (value.tag) {\n    case \"HeadIsInitializing\":\n      return \"INITIALIZING\";\n    case \"HeadIsOpen\":\n      return \"OPEN\";\n    case \"HeadIsClosed\":\n      return \"CLOSED\";\n    case \"ReadyToFanout\":\n      return \"FANOUT_POSSIBLE\";\n    case \"HeadIsFinalized\":\n      return \"FINAL\";\n    default:\n      return null;\n  }\n}"
    },
    {
      "key": "mesh-hydra:types.hUTxOs.ts.hUTxOs",
      "fullName": "mesh-hydra:types.hUTxOs.ts.hUTxOs",
      "name": "hUTxOs",
      "signature": "export function hUTxOs(utxos: UTxO[]): hUTxOs {",
      "documentation": "",
      "parameters": [
        {
          "name": "utxos",
          "type": "UTxO[]",
          "optional": false
        }
      ],
      "returnType": "hUTxOs",
      "isPublic": true,
      "line": 9,
      "raw": "export function hUTxOs(utxos: UTxO[]): hUTxOs {\n  return Object.fromEntries(utxos.map(\n    (utxo) => [utxo.input.txHash + \"#\" + utxo.input.outputIndex, hUTxO(utxo)]\n  ));\n}",
      "source": "mesh-hydra",
      "implementation": "export function hUTxOs(utxos: UTxO[]): hUTxOs {\n  return Object.fromEntries(utxos.map(\n    (utxo) => [utxo.input.txHash + \"#\" + utxo.input.outputIndex, hUTxO(utxo)]\n  ));\n}"
    },
    {
      "key": "mesh-hydra:types.hUTxOs.ts.hUTxO",
      "fullName": "mesh-hydra:types.hUTxOs.ts.hUTxO",
      "name": "hUTxO",
      "signature": "export function hUTxO(utxo: UTxO): hUTxO {",
      "documentation": "",
      "parameters": [
        {
          "name": "utxo",
          "type": "UTxO",
          "optional": false
        }
      ],
      "returnType": "hUTxO",
      "isPublic": true,
      "line": 25,
      "raw": "export function hUTxO(utxo: UTxO): hUTxO {\n  return {\n    address: utxo.output.address,\n    value: hAssets(utxo.output.amount),\n    referenceScript: null,\n    inlineDatum: utxo.output.plutusData ? JSON.parse(utxo.output.plutusData) : null,\n    inlineDatumhash: utxo.output.dataHash ?? null,\n    datum: utxo.output.plutusData ?? null,\n    datumhash: utxo.output.dataHash ?? null,\n  };\n}",
      "source": "mesh-hydra",
      "implementation": "export function hUTxO(utxo: UTxO): hUTxO {\n  return {\n    address: utxo.output.address,\n    value: hAssets(utxo.output.amount),\n    referenceScript: null,\n    inlineDatum: utxo.output.plutusData ? JSON.parse(utxo.output.plutusData) : null,\n    inlineDatumhash: utxo.output.dataHash ?? null,\n    datum: utxo.output.plutusData ?? null,\n    datumhash: utxo.output.dataHash ?? null,\n  };\n}"
    },
    {
      "key": "mesh-hydra:utils.parse-http-error.ts.parseHttpError",
      "fullName": "mesh-hydra:utils.parse-http-error.ts.parseHttpError",
      "name": "parseHttpError",
      "signature": "export const parseHttpError = (error: unknown): string => {",
      "documentation": "",
      "parameters": [
        {
          "name": "error",
          "type": "unknown",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 3,
      "raw": "export const parseHttpError = (error: unknown): string => {\n  if (!axios.isAxiosError(error)) {\n    return JSON.stringify(error);\n  }\n\n  if (error.response) {\n    return JSON.stringify({\n      data: error.response.data,\n      headers: error.response.headers,\n      status: error.response.status,\n    });\n  }\n\n  if (error.request && !(error.request instanceof XMLHttpRequest)) {\n    return JSON.stringify(error.request);\n  }\n\n  return JSON.stringify({ code: error.code, message: error.message });\n};",
      "source": "mesh-hydra",
      "implementation": "export const parseHttpError = (error: unknown): string => {\n  if (!axios.isAxiosError(error)) {\n    return JSON.stringify(error);\n  }\n\n  if (error.response) {\n    return JSON.stringify({\n      data: error.response.data,\n      headers: error.response.headers,\n      status: error.response.status,\n    });\n  }\n\n  if (error.request && !(error.request instanceof XMLHttpRequest)) {\n    return JSON.stringify(error.request);\n  }\n\n  return JSON.stringify({ code: error.code, message: error.message });\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.certificateFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.certificateFromObj",
      "name": "certificateFromObj",
      "signature": "export const certificateFromObj = (obj: any): Certificate => {",
      "documentation": "",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Certificate",
      "isPublic": true,
      "line": 12,
      "raw": "export const certificateFromObj = (obj: any): Certificate => {\n  if (\"basicCertificate\" in obj) {\n    return {\n      type: \"BasicCertificate\",\n      certType: baseCertFromObj(obj.basicCertificate),\n    };\n  } else if (\"scriptCertificate\" in obj) {\n    const certificate: Certificate = {\n      type: \"ScriptCertificate\",\n      certType: baseCertFromObj(obj.scriptCertificate.cert),\n    };\n\n    if (obj.scriptCertificate.redeemer) {\n      certificate.redeemer = redeemerFromObj(obj.scriptCertificate.redeemer);\n    }\n\n    if (obj.scriptCertificate.scriptSource) {\n      certificate.scriptSource = scriptSourceFromObj(\n        obj.scriptCertificate.scriptSource,\n      );\n    }\n\n    return certificate;\n  } else if (\"simpleScriptCertificate\" in obj) {\n    const certificate: Certificate = {\n      type: \"SimpleScriptCertificate\",\n      certType: baseCertFromObj(obj.simpleScriptCertificate.cert),\n    };\n\n    if (obj.simpleScriptCertificate.simpleScriptSource) {\n      certificate.simpleScriptSource = simpleScriptSourceFromObj(\n        obj.simpleScriptCertificate.simpleScriptSource,\n      );\n    }\n\n    return certificate;\n  }\n\n  throw new Error(\n    `certificateFromObj: Unknown certificate type in object: ${JSON.stringify(obj)}`,\n  );\n};",
      "source": "mesh-core-csl",
      "implementation": "export const certificateFromObj = (obj: any): Certificate => {\n  if (\"basicCertificate\" in obj) {\n    return {\n      type: \"BasicCertificate\",\n      certType: baseCertFromObj(obj.basicCertificate),\n    };\n  } else if (\"scriptCertificate\" in obj) {\n    const certificate: Certificate = {\n      type: \"ScriptCertificate\",\n      certType: baseCertFromObj(obj.scriptCertificate.cert),\n    };\n\n    if (obj.scriptCertificate.redeemer) {\n      certificate.redeemer = redeemerFromObj(obj.scriptCertificate.redeemer);\n    }\n\n    if (obj.scriptCertificate.scriptSource) {\n      certificate.scriptSource = scriptSourceFromObj(\n        obj.scriptCertificate.scriptSource,\n      );\n    }\n\n    return certificate;\n  } else if (\"simpleScriptCertificate\" in obj) {\n    const certificate: Certificate = {\n      type: \"SimpleScriptCertificate\",\n      certType: baseCertFromObj(obj.simpleScriptCertificate.cert),\n    };\n\n    if (obj.simpleScriptCertificate.simpleScriptSource) {\n      certificate.simpleScriptSource = simpleScriptSourceFromObj(\n        obj.simpleScriptCertificate.simpleScriptSource,\n      );\n    }\n\n    return certificate;\n  }\n\n  throw new Error(\n    `certificateFromObj: Unknown certificate type in object: ${JSON.stringify(obj)}`,\n  );\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.baseCertFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.baseCertFromObj",
      "name": "baseCertFromObj",
      "signature": "export const baseCertFromObj = (obj: any): CertificateType => {",
      "documentation": "",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "CertificateType",
      "isPublic": true,
      "line": 55,
      "raw": "export const baseCertFromObj = (obj: any): CertificateType => {\n  if (\"registerPool\" in obj) {\n    return {\n      type: \"RegisterPool\",\n      poolParams: poolParamsFromObj(obj.registerPool.poolParams),\n    };\n  } else if (\"registerStake\" in obj) {\n    return {\n      type: \"RegisterStake\",\n      stakeKeyAddress: obj.registerStake.stakeKeyAddress,\n    };\n  } else if (\"delegateStake\" in obj) {\n    return {\n      type: \"DelegateStake\",\n      stakeKeyAddress: obj.delegateStake.stakeKeyAddress,\n      poolId: obj.delegateStake.poolId,\n    };\n  } else if (\"deregisterStake\" in obj) {\n    return {\n      type: \"DeregisterStake\",\n      stakeKeyAddress: obj.deregisterStake.stakeKeyAddress,\n    };\n  } else if (\"retirePool\" in obj) {\n    return {\n      type: \"RetirePool\",\n      poolId: obj.retirePool.poolId,\n      epoch: obj.retirePool.epoch,\n    };\n  } else if (\"voteDelegation\" in obj) {\n    return {\n      type: \"VoteDelegation\",\n      stakeKeyAddress: obj.voteDelegation.stakeKeyAddress,\n      drep: obj.voteDelegation.drep,\n    };\n  } else if (\"stakeAndVoteDelegation\" in obj) {\n    return {\n      type: \"StakeAndVoteDelegation\",\n      stakeKeyAddress: obj.stakeAndVoteDelegation.stakeKeyAddress,\n      poolKeyHash: obj.stakeAndVoteDelegation.poolKeyHash,\n      drep: obj.stakeAndVoteDelegation.drep,\n    };\n  } else if (\"stakeRegistrationAndDelegation\" in obj) {\n    return {\n      type: \"StakeRegistrationAndDelegation\",\n      stakeKeyAddress: obj.stakeRegistrationAndDelegation.stakeKeyAddress,\n      poolKeyHash: obj.stakeRegistrationAndDelegation.poolKeyHash,\n      coin: obj.stakeRegistrationAndDelegation.coin,\n    };\n  } else if (\"voteRegistrationAndDelegation\" in obj) {\n    return {\n      type: \"VoteRegistrationAndDelegation\",\n      stakeKeyAddress: obj.voteRegistrationAndDelegation.stakeKeyAddress,\n      drep: obj.voteRegistrationAndDelegation.drep,\n      coin: obj.voteRegistrationAndDelegation.coin,\n    };\n  } else if (\"stakeVoteRegistrationAndDelegation\" in obj) {\n    return {\n      type: \"StakeVoteRegistrationAndDelegation\",\n      stakeKeyAddress: obj.stakeVoteRegistrationAndDelegation.stakeKeyAddress,\n      poolKeyHash: obj.stakeVoteRegistrationAndDelegation.poolKeyHash,\n      drep: obj.stakeVoteRegistrationAndDelegation.drep,\n      coin: obj.stakeVoteRegistrationAndDelegation.coin,\n    };\n  } else if (\"committeeHotAuth\" in obj) {\n    return {\n      type: \"CommitteeHotAuth\",\n      committeeColdKeyAddress: obj.committeeHotAuth.committeeColdKeyAddress,\n      committeeHotKeyAddress: obj.committeeHotAuth.committeeHotKeyAddress,\n    };\n  } else if (\"committeeColdResign\" in obj) {\n    return {\n      type: \"CommitteeColdResign\",\n      committeeColdKeyAddress: obj.committeeColdResign.committeeColdKeyAddress,\n      anchor: obj.committeeColdResign.anchor || undefined,\n    };\n  } else if (\"dRepRegistration\" in obj) {\n    return {\n      type: \"DRepRegistration\",\n      drepId: obj.dRepRegistration.drepId,\n      coin: obj.dRepRegistration.coin,\n      anchor: obj.dRepRegistration.anchor || undefined,\n    };\n  } else if (\"dRepDeregistration\" in obj) {\n    return {\n      type: \"DRepDeregistration\",\n      drepId: obj.dRepDeregistration.drepId,\n      coin: obj.dRepDeregistration.coin,\n    };\n  } else if (\"dRepUpdate\" in obj) {\n    return {\n      type: \"DRepUpdate\",\n      drepId: obj.dRepUpdate.drepId,\n      anchor: obj.dRepUpdate.anchor,\n    };\n  }\n\n  throw new Error(\n    `baseCertFromObj: Unknown certificate type in object: ${JSON.stringify(obj)}`,\n  );\n};",
      "source": "mesh-core-csl",
      "implementation": "export const baseCertFromObj = (obj: any): CertificateType => {\n  if (\"registerPool\" in obj) {\n    return {\n      type: \"RegisterPool\",\n      poolParams: poolParamsFromObj(obj.registerPool.poolParams),\n    };\n  } else if (\"registerStake\" in obj) {\n    return {\n      type: \"RegisterStake\",\n      stakeKeyAddress: obj.registerStake.stakeKeyAddress,\n    };\n  } else if (\"delegateStake\" in obj) {\n    return {\n      type: \"DelegateStake\",\n      stakeKeyAddress: obj.delegateStake.stakeKeyAddress,\n      poolId: obj.delegateStake.poolId,\n    };\n  } else if (\"deregisterStake\" in obj) {\n    return {\n      type: \"DeregisterStake\",\n      stakeKeyAddress: obj.deregisterStake.stakeKeyAddress,\n    };\n  } else if (\"retirePool\" in obj) {\n    return {\n      type: \"RetirePool\",\n      poolId: obj.retirePool.poolId,\n      epoch: obj.retirePool.epoch,\n    };\n  } else if (\"voteDelegation\" in obj) {\n    return {\n      type: \"VoteDelegation\",\n      stakeKeyAddress: obj.voteDelegation.stakeKeyAddress,\n      drep: obj.voteDelegation.drep,\n    };\n  } else if (\"stakeAndVoteDelegation\" in obj) {\n    return {\n      type: \"StakeAndVoteDelegation\",\n      stakeKeyAddress: obj.stakeAndVoteDelegation.stakeKeyAddress,\n      poolKeyHash: obj.stakeAndVoteDelegation.poolKeyHash,\n      drep: obj.stakeAndVoteDelegation.drep,\n    };\n  } else if (\"stakeRegistrationAndDelegation\" in obj) {\n    return {\n      type: \"StakeRegistrationAndDelegation\",\n      stakeKeyAddress: obj.stakeRegistrationAndDelegation.stakeKeyAddress,\n      poolKeyHash: obj.stakeRegistrationAndDelegation.poolKeyHash,\n      coin: obj.stakeRegistrationAndDelegation.coin,\n    };\n  } else if (\"voteRegistrationAndDelegation\" in obj) {\n    return {\n      type: \"VoteRegistrationAndDelegation\",\n      stakeKeyAddress: obj.voteRegistrationAndDelegation.stakeKeyAddress,\n      drep: obj.voteRegistrationAndDelegation.drep,\n      coin: obj.voteRegistrationAndDelegation.coin,\n    };\n  } else if (\"stakeVoteRegistrationAndDelegation\" in obj) {\n    return {\n      type: \"StakeVoteRegistrationAndDelegation\",\n      stakeKeyAddress: obj.stakeVoteRegistrationAndDelegation.stakeKeyAddress,\n      poolKeyHash: obj.stakeVoteRegistrationAndDelegation.poolKeyHash,\n      drep: obj.stakeVoteRegistrationAndDelegation.drep,\n      coin: obj.stakeVoteRegistrationAndDelegation.coin,\n    };\n  } else if (\"committeeHotAuth\" in obj) {\n    return {\n      type: \"CommitteeHotAuth\",\n      committeeColdKeyAddress: obj.committeeHotAuth.committeeColdKeyAddress,\n      committeeHotKeyAddress: obj.committeeHotAuth.committeeHotKeyAddress,\n    };\n  } else if (\"committeeColdResign\" in obj) {\n    return {\n      type: \"CommitteeColdResign\",\n      committeeColdKeyAddress: obj.committeeColdResign.committeeColdKeyAddress,\n      anchor: obj.committeeColdResign.anchor || undefined,\n    };\n  } else if (\"dRepRegistration\" in obj) {\n    return {\n      type: \"DRepRegistration\",\n      drepId: obj.dRepRegistration.drepId,\n      coin: obj.dRepRegistration.coin,\n      anchor: obj.dRepRegistration.anchor || undefined,\n    };\n  } else if (\"dRepDeregistration\" in obj) {\n    return {\n      type: \"DRepDeregistration\",\n      drepId: obj.dRepDeregistration.drepId,\n      coin: obj.dRepDeregistration.coin,\n    };\n  } else if (\"dRepUpdate\" in obj) {\n    return {\n      type: \"DRepUpdate\",\n      drepId: obj.dRepUpdate.drepId,\n      anchor: obj.dRepUpdate.anchor,\n    };\n  }\n\n  throw new Error(\n    `baseCertFromObj: Unknown certificate type in object: ${JSON.stringify(obj)}`,\n  );\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.poolParamsFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.poolParamsFromObj",
      "name": "poolParamsFromObj",
      "signature": "export const poolParamsFromObj = (obj: any): PoolParams => {",
      "documentation": "",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "PoolParams",
      "isPublic": true,
      "line": 157,
      "raw": "export const poolParamsFromObj = (obj: any): PoolParams => {\n  return {\n    vrfKeyHash: obj.vrfKeyHash,\n    operator: obj.operator,\n    pledge: obj.pledge,\n    cost: obj.cost,\n    margin: obj.margin,\n    relays: obj.relays.map((relay: any) => relayFromObj(relay)),\n    owners: obj.owners,\n    rewardAddress: obj.rewardAddress,\n    metadata: obj.metadata ? poolMetadataFromObj(obj.metadata) : undefined,\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const poolParamsFromObj = (obj: any): PoolParams => {\n  return {\n    vrfKeyHash: obj.vrfKeyHash,\n    operator: obj.operator,\n    pledge: obj.pledge,\n    cost: obj.cost,\n    margin: obj.margin,\n    relays: obj.relays.map((relay: any) => relayFromObj(relay)),\n    owners: obj.owners,\n    rewardAddress: obj.rewardAddress,\n    metadata: obj.metadata ? poolMetadataFromObj(obj.metadata) : undefined,\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.poolMetadataFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.poolMetadataFromObj",
      "name": "poolMetadataFromObj",
      "signature": "export const poolMetadataFromObj = (obj: any): PoolMetadata => {",
      "documentation": "",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "PoolMetadata",
      "isPublic": true,
      "line": 171,
      "raw": "export const poolMetadataFromObj = (obj: any): PoolMetadata => {\n  return {\n    URL: obj.url,\n    hash: obj.metadata,\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const poolMetadataFromObj = (obj: any): PoolMetadata => {\n  return {\n    URL: obj.url,\n    hash: obj.metadata,\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.relayFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.relayFromObj",
      "name": "relayFromObj",
      "signature": "export const relayFromObj = (obj: any): Relay => {",
      "documentation": "",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Relay",
      "isPublic": true,
      "line": 178,
      "raw": "export const relayFromObj = (obj: any): Relay => {\n  if (\"singleHostAddr\" in obj) {\n    return {\n      type: \"SingleHostAddr\",\n      IPV4: obj.singleHostAddr.ipv4,\n      IPV6: obj.singleHostAddr.ipv6,\n      port: obj.singleHostAddr.port,\n    };\n  } else if (\"singleHostName\" in obj) {\n    return {\n      type: \"SingleHostName\",\n      domainName: obj.singleHostName.hostname,\n      port: obj.singleHostName.port,\n    };\n  } else if (\"multiHostName\" in obj) {\n    return {\n      type: \"MultiHostName\",\n      domainName: obj.multiHostName.dnsName,\n    };\n  }\n\n  throw new Error(\n    `relayFromObj: Unknown relay type in object: ${JSON.stringify(obj)}`,\n  );\n};",
      "source": "mesh-core-csl",
      "implementation": "export const relayFromObj = (obj: any): Relay => {\n  if (\"singleHostAddr\" in obj) {\n    return {\n      type: \"SingleHostAddr\",\n      IPV4: obj.singleHostAddr.ipv4,\n      IPV6: obj.singleHostAddr.ipv6,\n      port: obj.singleHostAddr.port,\n    };\n  } else if (\"singleHostName\" in obj) {\n    return {\n      type: \"SingleHostName\",\n      domainName: obj.singleHostName.hostname,\n      port: obj.singleHostName.port,\n    };\n  } else if (\"multiHostName\" in obj) {\n    return {\n      type: \"MultiHostName\",\n      domainName: obj.multiHostName.dnsName,\n    };\n  }\n\n  throw new Error(\n    `relayFromObj: Unknown relay type in object: ${JSON.stringify(obj)}`,\n  );\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.data.ts.cborToBuilderData",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.data.ts.cborToBuilderData",
      "name": "cborToBuilderData",
      "signature": "export const cborToBuilderData = (cborHex: string): BuilderData => {",
      "documentation": "/**\n * Convert CBOR hex string back to BuilderData\n * @param cborHex The CBOR hex string to convert\n * @returns BuilderData object\n */",
      "parameters": [
        {
          "name": "cborHex",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "BuilderData",
      "isPublic": true,
      "line": 10,
      "raw": "/**\n * Convert CBOR hex string back to BuilderData\n * @param cborHex The CBOR hex string to convert\n * @returns BuilderData object\n */\nexport const cborToBuilderData = (cborHex: string): BuilderData => {\n  return {\n    type: \"CBOR\",\n    content: cborHex,\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const cborToBuilderData = (cborHex: string): BuilderData => {\n  return {\n    type: \"CBOR\",\n    content: cborHex,\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.data.ts.redeemerFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.data.ts.redeemerFromObj",
      "name": "redeemerFromObj",
      "signature": "export const redeemerFromObj = (obj: any): Redeemer => {",
      "documentation": "/**\n * Convert an object representation back to a Redeemer\n * @param obj The object representation of a Redeemer\n * @returns The Redeemer instance\n */",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Redeemer",
      "isPublic": true,
      "line": 22,
      "raw": "/**\n * Convert an object representation back to a Redeemer\n * @param obj The object representation of a Redeemer\n * @returns The Redeemer instance\n */\nexport const redeemerFromObj = (obj: any): Redeemer => {\n  return {\n    data: cborToBuilderData(obj.data),\n    exUnits: obj.exUnits,\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const redeemerFromObj = (obj: any): Redeemer => {\n  return {\n    data: cborToBuilderData(obj.data),\n    exUnits: obj.exUnits,\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.data.ts.dataFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.data.ts.dataFromObj",
      "name": "dataFromObj",
      "signature": "export const dataFromObj = (obj: any): any => {",
      "documentation": "/**\n * Convert an object representation back to Data\n * @param obj The object representation of Data\n * @returns The Data instance\n */",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 34,
      "raw": "/**\n * Convert an object representation back to Data\n * @param obj The object representation of Data\n * @returns The Data instance\n */\nexport const dataFromObj = (obj: any): any => {\n  if (obj === null) {\n    return null;\n  }\n\n  if (typeof obj === \"object\") {\n    if (Array.isArray(obj)) {\n      return obj.map((item) => dataFromObj(item));\n    } else if (\"map\" in obj) {\n      return Object.fromEntries(\n        obj.map.map((entry: any) => [\n          dataFromObj(entry.k),\n          dataFromObj(entry.v),\n        ]),\n      );\n    } else if (\"list\" in obj) {\n      return obj.list.map((item: any) => dataFromObj(item));\n    } else if (\"int\" in obj) {\n      return BigInt(obj.int);\n    } else if (\"bytes\" in obj) {\n      return obj.bytes;\n    } else if (\"constructor\" in obj) {\n      return {\n        constructor: obj.constructor,\n        fields: obj.fields.map((field: any) => dataFromObj(field)),\n      };\n    }\n  }\n\n  return obj;\n};",
      "source": "mesh-core-csl",
      "implementation": "export const dataFromObj = (obj: any): any => {\n  if (obj === null) {\n    return null;\n  }\n\n  if (typeof obj === \"object\") {\n    if (Array.isArray(obj)) {\n      return obj.map((item) => dataFromObj(item));\n    } else if (\"map\" in obj) {\n      return Object.fromEntries(\n        obj.map.map((entry: any) => [\n          dataFromObj(entry.k),\n          dataFromObj(entry.v),\n        ]),\n      );\n    } else if (\"list\" in obj) {\n      return obj.list.map((item: any) => dataFromObj(item));\n    } else if (\"int\" in obj) {\n      return BigInt(obj.int);\n    } else if (\"bytes\" in obj) {\n      return obj.bytes;\n    } else if (\"constructor\" in obj) {\n      return {\n        constructor: obj.constructor,\n        fields: obj.fields.map((field: any) => dataFromObj(field)),\n      };\n    }\n  }\n\n  return obj;\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.index.ts.txBuilderBodyFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.index.ts.txBuilderBodyFromObj",
      "name": "txBuilderBodyFromObj",
      "signature": "export const txBuilderBodyFromObj = (objJson: any): MeshTxBuilderBody => {",
      "documentation": "/**\n * Convert an object representation back to MeshTxBuilderBody\n * @param obj The object representation of the transaction body\n * @returns The MeshTxBuilderBody instance\n */",
      "parameters": [
        {
          "name": "objJson",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "MeshTxBuilderBody",
      "isPublic": true,
      "line": 23,
      "raw": "/**\n * Convert an object representation back to MeshTxBuilderBody\n * @param obj The object representation of the transaction body\n * @returns The MeshTxBuilderBody instance\n */\nexport const txBuilderBodyFromObj = (objJson: any): MeshTxBuilderBody => {\n  const txBuilderBody: MeshTxBuilderBody = emptyTxBuilderBody();\n  const obj = JSON.parse(objJson);\n\n  // Convert inputs\n  if (obj.inputs && Array.isArray(obj.inputs)) {\n    txBuilderBody.inputs = obj.inputs.map(txInFromObj);\n  }\n\n  // Convert outputs\n  if (obj.outputs && Array.isArray(obj.outputs)) {\n    txBuilderBody.outputs = obj.outputs.map(outputFromObj);\n  }\n\n  // Convert fee\n  if (obj.fee) {\n    txBuilderBody.fee = obj.fee.toString();\n  }\n\n  // Convert mint tokens\n  if (obj.mints && Array.isArray(obj.mints)) {\n    const mintItems: MintItem[] = obj.mints.map(mintItemFromObj);\n\n    const visitedPolicyId = new Set<string>();\n    const mintParams: Record<string, MintParam> = {};\n\n    mintItems.forEach((mintItem) => {\n      const mintValueItem = {\n        assetName: mintItem.assetName,\n        amount: mintItem.amount,\n      };\n      if (!visitedPolicyId.has(mintItem.policyId)) {\n        const mintParam: MintParam = {\n          type: mintItem.type,\n          policyId: mintItem.policyId,\n          mintValue: [],\n          redeemer: mintItem.redeemer,\n          scriptSource: mintItem.scriptSource,\n        };\n        mintParams[mintItem.policyId] = mintParam;\n      }\n      const mintParam = mintParams[mintItem.policyId]!;\n      mintParam.mintValue.push(mintValueItem);\n\n      visitedPolicyId.add(mintItem.policyId);\n    });\n\n    txBuilderBody.mints = Object.values(mintParams);\n  }\n\n  // Convert withdrawals\n  if (obj.withdrawals && Array.isArray(obj.withdrawals)) {\n    txBuilderBody.withdrawals = obj.withdrawals.map(withdrawalFromObj);\n  }\n\n  // Convert certificates\n  if (obj.certificates && Array.isArray(obj.certificates)) {\n    txBuilderBody.certificates = obj.certificates.map(certificateFromObj);\n  }\n\n  // Convert votes\n  if (obj.votes && Array.isArray(obj.votes)) {\n    txBuilderBody.votes = obj.votes.map(voteFromObj);\n  }\n\n  // Convert validity range\n  if (obj.validityRange) {\n    txBuilderBody.validityRange = validityRangeFromObj(obj.validityRange);\n  }\n\n  // Convert metadata\n  if (obj.metadata) {\n    txBuilderBody.metadata = metadataFromObj(obj.metadata);\n  }\n\n  // Convert required signers\n  if (obj.requiredSignatures && Array.isArray(obj.requiredSignatures)) {\n    txBuilderBody.requiredSignatures = [...obj.requiredSignatures];\n  }\n\n  // Convert reference inputs\n  if (obj.referenceInputs && Array.isArray(obj.referenceInputs)) {\n    txBuilderBody.referenceInputs = [...obj.referenceInputs];\n  }\n\n  // Convert collaterals\n  if (obj.collaterals && Array.isArray(obj.collaterals)) {\n    txBuilderBody.collaterals = obj.collaterals.map(collateralTxInFromObj);\n  }\n\n  // Convert change address\n  if (obj.changeAddress) {\n    txBuilderBody.changeAddress = obj.changeAddress;\n  }\n\n  // Convert signing keys\n  if (obj.signingKey && Array.isArray(obj.signingKey)) {\n    txBuilderBody.signingKey = [...obj.signingKey];\n  }\n\n  // Convert network\n  if (obj.network) {\n    txBuilderBody.network = networkFromObj(obj.network);\n  }\n\n  return txBuilderBody;\n};",
      "source": "mesh-core-csl",
      "implementation": "export const txBuilderBodyFromObj = (objJson: any): MeshTxBuilderBody => {\n  const txBuilderBody: MeshTxBuilderBody = emptyTxBuilderBody();\n  const obj = JSON.parse(objJson);\n\n  // Convert inputs\n  if (obj.inputs && Array.isArray(obj.inputs)) {\n    txBuilderBody.inputs = obj.inputs.map(txInFromObj);\n  }\n\n  // Convert outputs\n  if (obj.outputs && Array.isArray(obj.outputs)) {\n    txBuilderBody.outputs = obj.outputs.map(outputFromObj);\n  }\n\n  // Convert fee\n  if (obj.fee) {\n    txBuilderBody.fee = obj.fee.toString();\n  }\n\n  // Convert mint tokens\n  if (obj.mints && Array.isArray(obj.mints)) {\n    const mintItems: MintItem[] = obj.mints.map(mintItemFromObj);\n\n    const visitedPolicyId = new Set<string>();\n    const mintParams: Record<string, MintParam> = {};\n\n    mintItems.forEach((mintItem) => {\n      const mintValueItem = {\n        assetName: mintItem.assetName,\n        amount: mintItem.amount,\n      };\n      if (!visitedPolicyId.has(mintItem.policyId)) {\n        const mintParam: MintParam = {\n          type: mintItem.type,\n          policyId: mintItem.policyId,\n          mintValue: [],\n          redeemer: mintItem.redeemer,\n          scriptSource: mintItem.scriptSource,\n        };\n        mintParams[mintItem.policyId] = mintParam;\n      }\n      const mintParam = mintParams[mintItem.policyId]!;\n      mintParam.mintValue.push(mintValueItem);\n\n      visitedPolicyId.add(mintItem.policyId);\n    });\n\n    txBuilderBody.mints = Object.values(mintParams);\n  }\n\n  // Convert withdrawals\n  if (obj.withdrawals && Array.isArray(obj.withdrawals)) {\n    txBuilderBody.withdrawals = obj.withdrawals.map(withdrawalFromObj);\n  }\n\n  // Convert certificates\n  if (obj.certificates && Array.isArray(obj.certificates)) {\n    txBuilderBody.certificates = obj.certificates.map(certificateFromObj);\n  }\n\n  // Convert votes\n  if (obj.votes && Array.isArray(obj.votes)) {\n    txBuilderBody.votes = obj.votes.map(voteFromObj);\n  }\n\n  // Convert validity range\n  if (obj.validityRange) {\n    txBuilderBody.validityRange = validityRangeFromObj(obj.validityRange);\n  }\n\n  // Convert metadata\n  if (obj.metadata) {\n    txBuilderBody.metadata = metadataFromObj(obj.metadata);\n  }\n\n  // Convert required signers\n  if (obj.requiredSignatures && Array.isArray(obj.requiredSignatures)) {\n    txBuilderBody.requiredSignatures = [...obj.requiredSignatures];\n  }\n\n  // Convert reference inputs\n  if (obj.referenceInputs && Array.isArray(obj.referenceInputs)) {\n    txBuilderBody.referenceInputs = [...obj.referenceInputs];\n  }\n\n  // Convert collaterals\n  if (obj.collaterals && Array.isArray(obj.collaterals)) {\n    txBuilderBody.collaterals = obj.collaterals.map(collateralTxInFromObj);\n  }\n\n  // Convert change address\n  if (obj.changeAddress) {\n    txBuilderBody.changeAddress = obj.changeAddress;\n  }\n\n  // Convert signing keys\n  if (obj.signingKey && Array.isArray(obj.signingKey)) {\n    txBuilderBody.signingKey = [...obj.signingKey];\n  }\n\n  // Convert network\n  if (obj.network) {\n    txBuilderBody.network = networkFromObj(obj.network);\n  }\n\n  return txBuilderBody;\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.metadata.ts.metadataFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.metadata.ts.metadataFromObj",
      "name": "metadataFromObj",
      "signature": "export const metadataFromObj = (metadataArray: Metadata[]): TxMetadata => {",
      "documentation": "",
      "parameters": [
        {
          "name": "metadataArray",
          "type": "Metadata[]",
          "optional": false
        }
      ],
      "returnType": "TxMetadata",
      "isPublic": true,
      "line": 12,
      "raw": "export const metadataFromObj = (metadataArray: Metadata[]): TxMetadata => {\n  const result: TxMetadata = new Map<bigint, Metadatum>();\n\n  metadataArray.forEach((metadata) => {\n    const key = BigInt(metadata.tag);\n    const value = objToMetadatum(JSONBigParser.parse(metadata.metadata));\n    result.set(key, value);\n  });\n\n  return result;\n};",
      "source": "mesh-core-csl",
      "implementation": "export const metadataFromObj = (metadataArray: Metadata[]): TxMetadata => {\n  const result: TxMetadata = new Map<bigint, Metadatum>();\n\n  metadataArray.forEach((metadata) => {\n    const key = BigInt(metadata.tag);\n    const value = objToMetadatum(JSONBigParser.parse(metadata.metadata));\n    result.set(key, value);\n  });\n\n  return result;\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.metadata.ts.objToMetadatum",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.metadata.ts.objToMetadatum",
      "name": "objToMetadatum",
      "signature": "const objToMetadatum = (obj: any): Metadatum => {",
      "documentation": "",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Metadatum",
      "isPublic": true,
      "line": 24,
      "raw": "const objToMetadatum = (obj: any): Metadatum => {\n  if (typeof obj === \"number\") {\n    return obj;\n  } else if (typeof obj === \"string\") {\n    // Check if it's a BigInt string (valid digits only), then convert to BigInt\n    if (/^\\d+$/.test(obj)) {\n      return BigInt(obj);\n    }\n    // Check if its a negative BigInt string\n    if (/^-?\\d+$/.test(obj)) {\n      return BigInt(obj);\n    }\n    return obj;\n  } else if (typeof obj === \"bigint\") {\n    return obj;\n  } else if (typeof obj === \"object\" && obj !== null) {\n    if (Array.isArray(obj)) {\n      return obj.map(objToMetadatum);\n    } else {\n      // Convert object to Map\n      const result = new Map<Metadatum, Metadatum>();\n      Object.entries(obj).forEach(([key, value]) => {\n        // Convert key back to original type\n        let convertedKey: Metadatum = objToMetadatum(key);\n        result.set(convertedKey, objToMetadatum(value));\n      });\n      return result;\n    }\n  } else {\n    throw new Error(\"objToMetadatum: Unsupported object type\");\n  }\n};",
      "source": "mesh-core-csl",
      "implementation": "const objToMetadatum = (obj: any): Metadatum => {\n  if (typeof obj === \"number\") {\n    return obj;\n  } else if (typeof obj === \"string\") {\n    // Check if it's a BigInt string (valid digits only), then convert to BigInt\n    if (/^\\d+$/.test(obj)) {\n      return BigInt(obj);\n    }\n    // Check if its a negative BigInt string\n    if (/^-?\\d+$/.test(obj)) {\n      return BigInt(obj);\n    }\n    return obj;\n  } else if (typeof obj === \"bigint\") {\n    return obj;\n  } else if (typeof obj === \"object\" && obj !== null) {\n    if (Array.isArray(obj)) {\n      return obj.map(objToMetadatum);\n    } else {\n      // Convert object to Map\n      const result = new Map<Metadatum, Metadatum>();\n      Object.entries(obj).forEach(([key, value]) => {\n        // Convert key back to original type\n        let convertedKey: Metadatum = objToMetadatum(key);\n        result.set(convertedKey, objToMetadatum(value));\n      });\n      return result;\n    }\n  } else {\n    throw new Error(\"objToMetadatum: Unsupported object type\");\n  }\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.mint.ts.mintItemFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.mint.ts.mintItemFromObj",
      "name": "mintItemFromObj",
      "signature": "export const mintItemFromObj = (obj: any): MintItem => {",
      "documentation": "/**\n * Convert an object representation back to a MintItem\n * @param obj The object representation of a MintItem\n * @returns The MintItem instance\n */",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "MintItem",
      "isPublic": true,
      "line": 11,
      "raw": "/**\n * Convert an object representation back to a MintItem\n * @param obj The object representation of a MintItem\n * @returns The MintItem instance\n */\nexport const mintItemFromObj = (obj: any): MintItem => {\n  if (\"scriptMint\" in obj) {\n    return plutusMintItemFromObj(obj.scriptMint);\n  }\n\n  if (\"simpleScriptMint\" in obj) {\n    return nativeMintItemFromObj(obj.simpleScriptMint);\n  }\n\n  throw new Error(\n    `mintItemFromObj: Unknown mint item format: ${JSON.stringify(obj)}`,\n  );\n};",
      "source": "mesh-core-csl",
      "implementation": "export const mintItemFromObj = (obj: any): MintItem => {\n  if (\"scriptMint\" in obj) {\n    return plutusMintItemFromObj(obj.scriptMint);\n  }\n\n  if (\"simpleScriptMint\" in obj) {\n    return nativeMintItemFromObj(obj.simpleScriptMint);\n  }\n\n  throw new Error(\n    `mintItemFromObj: Unknown mint item format: ${JSON.stringify(obj)}`,\n  );\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.mint.ts.plutusMintItemFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.mint.ts.plutusMintItemFromObj",
      "name": "plutusMintItemFromObj",
      "signature": "export const plutusMintItemFromObj = (obj: any): MintItem => {",
      "documentation": "/**\n * Convert a Plutus mint item object representation back to a MintItem\n * @param obj The object representation of a Plutus mint item\n * @returns The MintItem instance with Plutus script\n */",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "MintItem",
      "isPublic": true,
      "line": 30,
      "raw": "/**\n * Convert a Plutus mint item object representation back to a MintItem\n * @param obj The object representation of a Plutus mint item\n * @returns The MintItem instance with Plutus script\n */\nexport const plutusMintItemFromObj = (obj: any): MintItem => {\n  const mintParams = mintParametersFromObj(obj.mint);\n  return {\n    ...mintParams,\n    type: \"Plutus\",\n    scriptSource: scriptSourceFromObj(obj.scriptSource),\n    redeemer: obj.redeemer ? redeemerFromObj(obj.redeemer) : undefined,\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const plutusMintItemFromObj = (obj: any): MintItem => {\n  const mintParams = mintParametersFromObj(obj.mint);\n  return {\n    ...mintParams,\n    type: \"Plutus\",\n    scriptSource: scriptSourceFromObj(obj.scriptSource),\n    redeemer: obj.redeemer ? redeemerFromObj(obj.redeemer) : undefined,\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.mint.ts.nativeMintItemFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.mint.ts.nativeMintItemFromObj",
      "name": "nativeMintItemFromObj",
      "signature": "export const nativeMintItemFromObj = (obj: any): MintItem => {",
      "documentation": "/**\n * Convert a Native mint item object representation back to a MintItem\n * @param obj The object representation of a Native mint item\n * @returns The MintItem instance with Native script\n */",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "MintItem",
      "isPublic": true,
      "line": 45,
      "raw": "/**\n * Convert a Native mint item object representation back to a MintItem\n * @param obj The object representation of a Native mint item\n * @returns The MintItem instance with Native script\n */\nexport const nativeMintItemFromObj = (obj: any): MintItem => {\n  const mintParams = mintParametersFromObj(obj.mint);\n  return {\n    ...mintParams,\n    type: \"Native\",\n    scriptSource: simpleScriptSourceFromObj(obj.scriptSource),\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const nativeMintItemFromObj = (obj: any): MintItem => {\n  const mintParams = mintParametersFromObj(obj.mint);\n  return {\n    ...mintParams,\n    type: \"Native\",\n    scriptSource: simpleScriptSourceFromObj(obj.scriptSource),\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.mint.ts.mintParametersFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.mint.ts.mintParametersFromObj",
      "name": "mintParametersFromObj",
      "signature": "export const mintParametersFromObj = (",
      "documentation": "/**\n * Convert mint parameters object representation back to MintItem parameters\n * @param obj The object representation of mint parameters\n * @returns The mint parameters\n */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 59,
      "raw": "/**\n * Convert mint parameters object representation back to MintItem parameters\n * @param obj The object representation of mint parameters\n * @returns The mint parameters\n */\nexport const mintParametersFromObj = (\n  obj: any,\n): Omit<MintItem, \"type\" | \"scriptSource\" | \"redeemer\"> => {\n  return {\n    policyId: obj.policyId,\n    assetName: obj.assetName,\n    amount: obj.amount.toString(),\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const mintParametersFromObj = (\n  obj: any,\n): Omit<MintItem, \"type\" | \"scriptSource\" | \"redeemer\"> => {\n  return {\n    policyId: obj.policyId,\n    assetName: obj.assetName,\n    amount: obj.amount.toString(),\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.network.ts.networkFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.network.ts.networkFromObj",
      "name": "networkFromObj",
      "signature": "export const networkFromObj = (obj: any): Network | number[][] => {",
      "documentation": "",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Network | number[][]",
      "isPublic": true,
      "line": 3,
      "raw": "export const networkFromObj = (obj: any): Network | number[][] => {\n  // Handle numeric and object network IDs\n  if (typeof obj === \"string\") {\n    return obj as Network;\n  } else if (obj && typeof obj === \"object\" && \"custom\" in obj) {\n    return obj.custom as number[][];\n  }\n\n  throw new Error(\n    `networkFromObj: Unknown network type in object: ${JSON.stringify(obj)}`,\n  );\n};",
      "source": "mesh-core-csl",
      "implementation": "export const networkFromObj = (obj: any): Network | number[][] => {\n  // Handle numeric and object network IDs\n  if (typeof obj === \"string\") {\n    return obj as Network;\n  } else if (obj && typeof obj === \"object\" && \"custom\" in obj) {\n    return obj.custom as number[][];\n  }\n\n  throw new Error(\n    `networkFromObj: Unknown network type in object: ${JSON.stringify(obj)}`,\n  );\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.output.ts.outputFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.output.ts.outputFromObj",
      "name": "outputFromObj",
      "signature": "export const outputFromObj = (obj: any): Output => {",
      "documentation": "/**\n * Convert an object representation back to an Output\n * @param obj The object representation of an Output\n * @returns The Output instance\n */",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Output",
      "isPublic": true,
      "line": 10,
      "raw": "/**\n * Convert an object representation back to an Output\n * @param obj The object representation of an Output\n * @returns The Output instance\n */\nexport const outputFromObj = (obj: any): Output => {\n  const output: Output = {\n    address: obj.address,\n    amount: obj.amount,\n  };\n\n  // Handle datum if present\n  if (obj.datum) {\n    if (\"inline\" in obj.datum) {\n      output.datum = {\n        type: \"Inline\",\n        data: cborToBuilderData(obj.datum.inline),\n      };\n    } else if (\"hash\" in obj.datum) {\n      output.datum = {\n        type: \"Hash\",\n        data: cborToBuilderData(obj.datum.hash),\n      };\n    } else if (\"embedded\" in obj.datum) {\n      output.datum = {\n        type: \"Embedded\",\n        data: cborToBuilderData(obj.datum.embedded),\n      };\n    }\n  }\n\n  // Handle reference script if present\n  if (obj.referenceScript) {\n    const scriptSource = obj.referenceScript.providedScriptSource;\n    output.referenceScript = {\n      code: scriptSource.scriptCbor,\n      version: scriptSource.languageVersion.toUpperCase(),\n    } as PlutusScript;\n  }\n\n  return output;\n};",
      "source": "mesh-core-csl",
      "implementation": "export const outputFromObj = (obj: any): Output => {\n  const output: Output = {\n    address: obj.address,\n    amount: obj.amount,\n  };\n\n  // Handle datum if present\n  if (obj.datum) {\n    if (\"inline\" in obj.datum) {\n      output.datum = {\n        type: \"Inline\",\n        data: cborToBuilderData(obj.datum.inline),\n      };\n    } else if (\"hash\" in obj.datum) {\n      output.datum = {\n        type: \"Hash\",\n        data: cborToBuilderData(obj.datum.hash),\n      };\n    } else if (\"embedded\" in obj.datum) {\n      output.datum = {\n        type: \"Embedded\",\n        data: cborToBuilderData(obj.datum.embedded),\n      };\n    }\n  }\n\n  // Handle reference script if present\n  if (obj.referenceScript) {\n    const scriptSource = obj.referenceScript.providedScriptSource;\n    output.referenceScript = {\n      code: scriptSource.scriptCbor,\n      version: scriptSource.languageVersion.toUpperCase(),\n    } as PlutusScript;\n  }\n\n  return output;\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.script.ts.scriptSourceFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.script.ts.scriptSourceFromObj",
      "name": "scriptSourceFromObj",
      "signature": "export const scriptSourceFromObj = (obj: any): ScriptSource => {",
      "documentation": "/**\n * Convert an object representation back to a ScriptSource\n * @param obj The object representation of a ScriptSource\n * @returns The ScriptSource instance\n */",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "ScriptSource",
      "isPublic": true,
      "line": 12,
      "raw": "/**\n * Convert an object representation back to a ScriptSource\n * @param obj The object representation of a ScriptSource\n * @returns The ScriptSource instance\n */\nexport const scriptSourceFromObj = (obj: any): ScriptSource => {\n  if (\"providedScriptSource\" in obj) {\n    return {\n      type: \"Provided\",\n      script: {\n        code: obj.providedScriptSource.scriptCbor,\n        version: obj.providedScriptSource.languageVersion.toUpperCase() as\n          | \"V1\"\n          | \"V2\",\n      } as PlutusScript,\n    };\n  }\n\n  if (\"inlineScriptSource\" in obj) {\n    return {\n      type: \"Inline\",\n      txHash: obj.inlineScriptSource.refTxIn.txHash,\n      txIndex: obj.inlineScriptSource.refTxIn.txIndex,\n      scriptHash: obj.inlineScriptSource.scriptHash || undefined,\n      version: obj.inlineScriptSource.languageVersion.toUpperCase() as\n        | \"V1\"\n        | \"V2\",\n      scriptSize: obj.inlineScriptSource.scriptSize.toString(),\n    };\n  }\n\n  throw new Error(\n    `scriptSourceFromObj: Unknown script source format: ${JSON.stringify(obj)}`,\n  );\n};",
      "source": "mesh-core-csl",
      "implementation": "export const scriptSourceFromObj = (obj: any): ScriptSource => {\n  if (\"providedScriptSource\" in obj) {\n    return {\n      type: \"Provided\",\n      script: {\n        code: obj.providedScriptSource.scriptCbor,\n        version: obj.providedScriptSource.languageVersion.toUpperCase() as\n          | \"V1\"\n          | \"V2\",\n      } as PlutusScript,\n    };\n  }\n\n  if (\"inlineScriptSource\" in obj) {\n    return {\n      type: \"Inline\",\n      txHash: obj.inlineScriptSource.refTxIn.txHash,\n      txIndex: obj.inlineScriptSource.refTxIn.txIndex,\n      scriptHash: obj.inlineScriptSource.scriptHash || undefined,\n      version: obj.inlineScriptSource.languageVersion.toUpperCase() as\n        | \"V1\"\n        | \"V2\",\n      scriptSize: obj.inlineScriptSource.scriptSize.toString(),\n    };\n  }\n\n  throw new Error(\n    `scriptSourceFromObj: Unknown script source format: ${JSON.stringify(obj)}`,\n  );\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.script.ts.simpleScriptSourceFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.script.ts.simpleScriptSourceFromObj",
      "name": "simpleScriptSourceFromObj",
      "signature": "export const simpleScriptSourceFromObj = (obj: any): SimpleScriptSourceInfo => {",
      "documentation": "/**\n * Convert an object representation back to a SimpleScriptSourceInfo\n * @param obj The object representation of a SimpleScriptSourceInfo\n * @returns The SimpleScriptSourceInfo instance\n */",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "SimpleScriptSourceInfo",
      "isPublic": true,
      "line": 48,
      "raw": "/**\n * Convert an object representation back to a SimpleScriptSourceInfo\n * @param obj The object representation of a SimpleScriptSourceInfo\n * @returns The SimpleScriptSourceInfo instance\n */\nexport const simpleScriptSourceFromObj = (obj: any): SimpleScriptSourceInfo => {\n  if (\"providedSimpleScriptSource\" in obj) {\n    return {\n      type: \"Provided\",\n      scriptCode: obj.providedSimpleScriptSource.scriptCbor,\n    };\n  }\n\n  if (\"inlineSimpleScriptSource\" in obj) {\n    return {\n      type: \"Inline\",\n      txHash: obj.inlineSimpleScriptSource.refTxIn.txHash,\n      txIndex: obj.inlineSimpleScriptSource.refTxIn.txIndex,\n      simpleScriptHash:\n        obj.inlineSimpleScriptSource.simpleScriptHash || undefined,\n    };\n  }\n\n  throw new Error(\n    `simpleScriptSourceFromObj: Unknown simple script source format: ${JSON.stringify(obj)}`,\n  );\n};",
      "source": "mesh-core-csl",
      "implementation": "export const simpleScriptSourceFromObj = (obj: any): SimpleScriptSourceInfo => {\n  if (\"providedSimpleScriptSource\" in obj) {\n    return {\n      type: \"Provided\",\n      scriptCode: obj.providedSimpleScriptSource.scriptCbor,\n    };\n  }\n\n  if (\"inlineSimpleScriptSource\" in obj) {\n    return {\n      type: \"Inline\",\n      txHash: obj.inlineSimpleScriptSource.refTxIn.txHash,\n      txIndex: obj.inlineSimpleScriptSource.refTxIn.txIndex,\n      simpleScriptHash:\n        obj.inlineSimpleScriptSource.simpleScriptHash || undefined,\n    };\n  }\n\n  throw new Error(\n    `simpleScriptSourceFromObj: Unknown simple script source format: ${JSON.stringify(obj)}`,\n  );\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.txInFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.txInFromObj",
      "name": "txInFromObj",
      "signature": "export const txInFromObj = (obj: any): TxIn => {",
      "documentation": "",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "TxIn",
      "isPublic": true,
      "line": 11,
      "raw": "export const txInFromObj = (obj: any): TxIn => {\n  if (\"pubKeyTxIn\" in obj) {\n    return {\n      type: \"PubKey\",\n      txIn: txInParameterFromObj(obj.pubKeyTxIn.txIn),\n    };\n  }\n\n  if (\"scriptTxIn\" in obj) {\n    return {\n      type: \"Script\",\n      txIn: txInParameterFromObj(obj.scriptTxIn.txIn),\n      scriptTxIn: scriptTxInParameterFromObj(obj.scriptTxIn.scriptTxIn),\n    };\n  }\n\n  if (\"simpleScriptTxIn\" in obj) {\n    return {\n      type: \"SimpleScript\",\n      txIn: txInParameterFromObj(obj.simpleScriptTxIn.txIn),\n      simpleScriptTxIn: simpleScriptTxInParameterFromObj(\n        obj.simpleScriptTxIn.simpleScriptTxIn,\n      ),\n    };\n  }\n\n  throw new Error(\"Invalid transaction input object format\");\n};",
      "source": "mesh-core-csl",
      "implementation": "export const txInFromObj = (obj: any): TxIn => {\n  if (\"pubKeyTxIn\" in obj) {\n    return {\n      type: \"PubKey\",\n      txIn: txInParameterFromObj(obj.pubKeyTxIn.txIn),\n    };\n  }\n\n  if (\"scriptTxIn\" in obj) {\n    return {\n      type: \"Script\",\n      txIn: txInParameterFromObj(obj.scriptTxIn.txIn),\n      scriptTxIn: scriptTxInParameterFromObj(obj.scriptTxIn.scriptTxIn),\n    };\n  }\n\n  if (\"simpleScriptTxIn\" in obj) {\n    return {\n      type: \"SimpleScript\",\n      txIn: txInParameterFromObj(obj.simpleScriptTxIn.txIn),\n      simpleScriptTxIn: simpleScriptTxInParameterFromObj(\n        obj.simpleScriptTxIn.simpleScriptTxIn,\n      ),\n    };\n  }\n\n  throw new Error(\"Invalid transaction input object format\");\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.txInParameterFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.txInParameterFromObj",
      "name": "txInParameterFromObj",
      "signature": "export const txInParameterFromObj = (obj: any): TxInParameter => {",
      "documentation": "",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "TxInParameter",
      "isPublic": true,
      "line": 40,
      "raw": "export const txInParameterFromObj = (obj: any): TxInParameter => {\n  return {\n    txHash: obj.txHash,\n    txIndex: obj.txIndex,\n    amount: obj.amount ?? undefined,\n    address: obj.address ?? undefined,\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const txInParameterFromObj = (obj: any): TxInParameter => {\n  return {\n    txHash: obj.txHash,\n    txIndex: obj.txIndex,\n    amount: obj.amount ?? undefined,\n    address: obj.address ?? undefined,\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.scriptTxInParameterFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.scriptTxInParameterFromObj",
      "name": "scriptTxInParameterFromObj",
      "signature": "export const scriptTxInParameterFromObj = (obj: any): ScriptTxInParameter => {",
      "documentation": "",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "ScriptTxInParameter",
      "isPublic": true,
      "line": 49,
      "raw": "export const scriptTxInParameterFromObj = (obj: any): ScriptTxInParameter => {\n  const result: ScriptTxInParameter = {};\n\n  if (obj.scriptSource) {\n    result.scriptSource = scriptSourceFromObj(obj.scriptSource);\n  }\n\n  if (obj.datumSource) {\n    if (\"providedDatumSource\" in obj.datumSource) {\n      result.datumSource = {\n        type: \"Provided\",\n        data: cborToBuilderData(obj.datumSource.providedDatumSource.data),\n      };\n    } else if (\"inlineDatumSource\" in obj.datumSource) {\n      result.datumSource = {\n        type: \"Inline\",\n        txHash: obj.datumSource.inlineDatumSource.txHash,\n        txIndex: obj.datumSource.inlineDatumSource.txIndex,\n      };\n    }\n  }\n\n  if (obj.redeemer) {\n    result.redeemer = redeemerFromObj(obj.redeemer);\n  }\n\n  return result;\n};",
      "source": "mesh-core-csl",
      "implementation": "export const scriptTxInParameterFromObj = (obj: any): ScriptTxInParameter => {\n  const result: ScriptTxInParameter = {};\n\n  if (obj.scriptSource) {\n    result.scriptSource = scriptSourceFromObj(obj.scriptSource);\n  }\n\n  if (obj.datumSource) {\n    if (\"providedDatumSource\" in obj.datumSource) {\n      result.datumSource = {\n        type: \"Provided\",\n        data: cborToBuilderData(obj.datumSource.providedDatumSource.data),\n      };\n    } else if (\"inlineDatumSource\" in obj.datumSource) {\n      result.datumSource = {\n        type: \"Inline\",\n        txHash: obj.datumSource.inlineDatumSource.txHash,\n        txIndex: obj.datumSource.inlineDatumSource.txIndex,\n      };\n    }\n  }\n\n  if (obj.redeemer) {\n    result.redeemer = redeemerFromObj(obj.redeemer);\n  }\n\n  return result;\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.simpleScriptTxInParameterFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.simpleScriptTxInParameterFromObj",
      "name": "simpleScriptTxInParameterFromObj",
      "signature": "export const simpleScriptTxInParameterFromObj = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 78,
      "raw": "export const simpleScriptTxInParameterFromObj = (\n  obj: any,\n): SimpleScriptTxInParameter => {\n  const result: SimpleScriptTxInParameter = {};\n\n  if (\"inlineSimpleScriptSource\" in obj) {\n    result.scriptSource = {\n      type: \"Inline\",\n      txHash: obj.inlineSimpleScriptSource.refTxIn.txHash,\n      txIndex: obj.inlineSimpleScriptSource.refTxIn.txIndex,\n      simpleScriptHash: obj.inlineSimpleScriptSource.simpleScriptHash,\n      scriptSize: obj.inlineSimpleScriptSource.scriptSize.toString(),\n    };\n  } else if (\"providedSimpleScriptSource\" in obj) {\n    result.scriptSource = {\n      type: \"Provided\",\n      scriptCode: obj.providedSimpleScriptSource.scriptCbor,\n    };\n  }\n\n  return result;\n};",
      "source": "mesh-core-csl",
      "implementation": "export const simpleScriptTxInParameterFromObj = (\n  obj: any,\n): SimpleScriptTxInParameter => {\n  const result: SimpleScriptTxInParameter = {};\n\n  if (\"inlineSimpleScriptSource\" in obj) {\n    result.scriptSource = {\n      type: \"Inline\",\n      txHash: obj.inlineSimpleScriptSource.refTxIn.txHash,\n      txIndex: obj.inlineSimpleScriptSource.refTxIn.txIndex,\n      simpleScriptHash: obj.inlineSimpleScriptSource.simpleScriptHash,\n      scriptSize: obj.inlineSimpleScriptSource.scriptSize.toString(),\n    };\n  } else if (\"providedSimpleScriptSource\" in obj) {\n    result.scriptSource = {\n      type: \"Provided\",\n      scriptCode: obj.providedSimpleScriptSource.scriptCbor,\n    };\n  }\n\n  return result;\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.collateralTxInFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.collateralTxInFromObj",
      "name": "collateralTxInFromObj",
      "signature": "export const collateralTxInFromObj = (obj: any): TxIn => {",
      "documentation": "",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "TxIn",
      "isPublic": true,
      "line": 101,
      "raw": "export const collateralTxInFromObj = (obj: any): TxIn => {\n  return {\n    type: \"PubKey\",\n    txIn: txInParameterFromObj(obj.txIn),\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const collateralTxInFromObj = (obj: any): TxIn => {\n  return {\n    type: \"PubKey\",\n    txIn: txInParameterFromObj(obj.txIn),\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.utxo.ts.utxoFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.utxo.ts.utxoFromObj",
      "name": "utxoFromObj",
      "signature": "export const utxoFromObj = (obj: any): UTxO => {",
      "documentation": "/**\n * Convert an object representation back to a UTxO\n * @param obj The object representation of the UTxO\n * @returns The UTxO instance\n */",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "UTxO",
      "isPublic": true,
      "line": 8,
      "raw": "/**\n * Convert an object representation back to a UTxO\n * @param obj The object representation of the UTxO\n * @returns The UTxO instance\n */\nexport const utxoFromObj = (obj: any): UTxO => {\n  return {\n    input: {\n      outputIndex: obj.input.outputIndex,\n      txHash: obj.input.txHash,\n    },\n    output: {\n      address: obj.output.address,\n      amount: obj.output.amount,\n      dataHash: obj.output.dataHash ?? undefined,\n      plutusData: obj.output.plutusData ?? undefined,\n      scriptRef: obj.output.scriptRef ?? undefined,\n      scriptHash: obj.output.scriptHash ?? undefined,\n    },\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const utxoFromObj = (obj: any): UTxO => {\n  return {\n    input: {\n      outputIndex: obj.input.outputIndex,\n      txHash: obj.input.txHash,\n    },\n    output: {\n      address: obj.output.address,\n      amount: obj.output.amount,\n      dataHash: obj.output.dataHash ?? undefined,\n      plutusData: obj.output.plutusData ?? undefined,\n      scriptRef: obj.output.scriptRef ?? undefined,\n      scriptHash: obj.output.scriptHash ?? undefined,\n    },\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.vote.ts.voteFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.vote.ts.voteFromObj",
      "name": "voteFromObj",
      "signature": "export const voteFromObj = (obj: any): Vote => {",
      "documentation": "",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Vote",
      "isPublic": true,
      "line": 6,
      "raw": "export const voteFromObj = (obj: any): Vote => {\n  if (\"basicVote\" in obj) {\n    return {\n      type: \"BasicVote\",\n      vote: voteTypeFromObj(obj.basicVote),\n    };\n  } else if (\"scriptVote\" in obj) {\n    return {\n      type: \"ScriptVote\",\n      vote: voteTypeFromObj(obj.scriptVote.vote),\n      redeemer: redeemerFromObj(obj.scriptVote.redeemer),\n      scriptSource: scriptSourceFromObj(obj.scriptVote.scriptSource),\n    };\n  } else if (\"simpleScriptVote\" in obj) {\n    return {\n      type: \"SimpleScriptVote\",\n      vote: voteTypeFromObj(obj.simpleScriptVote.vote),\n      simpleScriptSource: simpleScriptSourceFromObj(\n        obj.simpleScriptVote.simpleScriptSource,\n      ),\n    };\n  }\n  throw new Error(\"Invalid vote object structure\");\n};",
      "source": "mesh-core-csl",
      "implementation": "export const voteFromObj = (obj: any): Vote => {\n  if (\"basicVote\" in obj) {\n    return {\n      type: \"BasicVote\",\n      vote: voteTypeFromObj(obj.basicVote),\n    };\n  } else if (\"scriptVote\" in obj) {\n    return {\n      type: \"ScriptVote\",\n      vote: voteTypeFromObj(obj.scriptVote.vote),\n      redeemer: redeemerFromObj(obj.scriptVote.redeemer),\n      scriptSource: scriptSourceFromObj(obj.scriptVote.scriptSource),\n    };\n  } else if (\"simpleScriptVote\" in obj) {\n    return {\n      type: \"SimpleScriptVote\",\n      vote: voteTypeFromObj(obj.simpleScriptVote.vote),\n      simpleScriptSource: simpleScriptSourceFromObj(\n        obj.simpleScriptVote.simpleScriptSource,\n      ),\n    };\n  }\n  throw new Error(\"Invalid vote object structure\");\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.vote.ts.voteTypeFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.vote.ts.voteTypeFromObj",
      "name": "voteTypeFromObj",
      "signature": "const voteTypeFromObj = (obj: any): VoteType => {",
      "documentation": "",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "VoteType",
      "isPublic": true,
      "line": 31,
      "raw": "const voteTypeFromObj = (obj: any): VoteType => {\n  const voter = voterFromObj(obj);\n  const votingProcedure = {\n    voteKind: voteKindFromObj(obj.votingProcedure.voteKind),\n    anchor:\n      obj.votingProcedure.anchor === null\n        ? undefined\n        : (obj.votingProcedure.anchor as Anchor),\n  };\n\n  return {\n    voter,\n    votingProcedure,\n    govActionId: obj.govActionId,\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "const voteTypeFromObj = (obj: any): VoteType => {\n  const voter = voterFromObj(obj);\n  const votingProcedure = {\n    voteKind: voteKindFromObj(obj.votingProcedure.voteKind),\n    anchor:\n      obj.votingProcedure.anchor === null\n        ? undefined\n        : (obj.votingProcedure.anchor as Anchor),\n  };\n\n  return {\n    voter,\n    votingProcedure,\n    govActionId: obj.govActionId,\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.vote.ts.voterFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.vote.ts.voterFromObj",
      "name": "voterFromObj",
      "signature": "const voterFromObj = (obj: any) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 48,
      "raw": "const voterFromObj = (obj: any) => {\n  if (\"constitutionalCommitteeHotCred\" in obj.voter) {\n    const cred = obj.voter.constitutionalCommitteeHotCred;\n    return {\n      type: \"ConstitutionalCommittee\" as const,\n      hotCred:\n        \"keyHash\" in cred\n          ? { type: \"KeyHash\" as const, keyHash: cred.keyHash }\n          : { type: \"ScriptHash\" as const, scriptHash: cred.scriptHash },\n    };\n  } else if (\"dRepId\" in obj.voter) {\n    return {\n      type: \"DRep\" as const,\n      drepId: obj.voter.dRepId,\n    };\n  } else if (\"stakingPoolKeyHash\" in obj.voter) {\n    return {\n      type: \"StakingPool\" as const,\n      keyHash: obj.voter.stakingPoolKeyHash,\n    };\n  }\n  throw new Error(\"Invalid voter object structure\");\n};",
      "source": "mesh-core-csl",
      "implementation": "const voterFromObj = (obj: any) => {\n  if (\"constitutionalCommitteeHotCred\" in obj.voter) {\n    const cred = obj.voter.constitutionalCommitteeHotCred;\n    return {\n      type: \"ConstitutionalCommittee\" as const,\n      hotCred:\n        \"keyHash\" in cred\n          ? { type: \"KeyHash\" as const, keyHash: cred.keyHash }\n          : { type: \"ScriptHash\" as const, scriptHash: cred.scriptHash },\n    };\n  } else if (\"dRepId\" in obj.voter) {\n    return {\n      type: \"DRep\" as const,\n      drepId: obj.voter.dRepId,\n    };\n  } else if (\"stakingPoolKeyHash\" in obj.voter) {\n    return {\n      type: \"StakingPool\" as const,\n      keyHash: obj.voter.stakingPoolKeyHash,\n    };\n  }\n  throw new Error(\"Invalid voter object structure\");\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.vote.ts.voteKindFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.vote.ts.voteKindFromObj",
      "name": "voteKindFromObj",
      "signature": "const voteKindFromObj = (voteKind: string): VoteKind => {",
      "documentation": "",
      "parameters": [
        {
          "name": "voteKind",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "VoteKind",
      "isPublic": true,
      "line": 72,
      "raw": "const voteKindFromObj = (voteKind: string): VoteKind => {\n  switch (voteKind.toLowerCase()) {\n    case \"yes\":\n      return \"Yes\";\n    case \"no\":\n      return \"No\";\n    case \"abstain\":\n      return \"Abstain\";\n    default:\n      throw new Error(\"Invalid vote kind\");\n  }\n};",
      "source": "mesh-core-csl",
      "implementation": "const voteKindFromObj = (voteKind: string): VoteKind => {\n  switch (voteKind.toLowerCase()) {\n    case \"yes\":\n      return \"Yes\";\n    case \"no\":\n      return \"No\";\n    case \"abstain\":\n      return \"Abstain\";\n    default:\n      throw new Error(\"Invalid vote kind\");\n  }\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.withdrawal.ts.withdrawalFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.withdrawal.ts.withdrawalFromObj",
      "name": "withdrawalFromObj",
      "signature": "export const withdrawalFromObj = (obj: any): Withdrawal => {",
      "documentation": "",
      "parameters": [
        {
          "name": "obj",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "Withdrawal",
      "isPublic": true,
      "line": 6,
      "raw": "export const withdrawalFromObj = (obj: any): Withdrawal => {\n  if (\"pubKeyWithdrawal\" in obj) {\n    return {\n      type: \"PubKeyWithdrawal\",\n      address: obj.pubKeyWithdrawal.address,\n      coin: obj.pubKeyWithdrawal.coin.toString(),\n    };\n  } else if (\"plutusScriptWithdrawal\" in obj) {\n    return {\n      type: \"ScriptWithdrawal\",\n      address: obj.plutusScriptWithdrawal.address,\n      coin: obj.plutusScriptWithdrawal.coin.toString(),\n      scriptSource: obj.plutusScriptWithdrawal.scriptSource\n        ? scriptSourceFromObj(obj.plutusScriptWithdrawal.scriptSource)\n        : undefined,\n      redeemer: obj.plutusScriptWithdrawal.redeemer\n        ? redeemerFromObj(obj.plutusScriptWithdrawal.redeemer)\n        : undefined,\n    };\n  } else if (\"simpleScriptWithdrawal\" in obj) {\n    return {\n      type: \"SimpleScriptWithdrawal\",\n      address: obj.simpleScriptWithdrawal.address,\n      coin: obj.simpleScriptWithdrawal.coin.toString(),\n      scriptSource: obj.simpleScriptWithdrawal.scriptSource\n        ? simpleScriptSourceFromObj(obj.simpleScriptWithdrawal.scriptSource)\n        : undefined,\n    };\n  }\n\n  throw new Error(\"withdrawalFromObj: Invalid withdrawal object format\");\n};",
      "source": "mesh-core-csl",
      "implementation": "export const withdrawalFromObj = (obj: any): Withdrawal => {\n  if (\"pubKeyWithdrawal\" in obj) {\n    return {\n      type: \"PubKeyWithdrawal\",\n      address: obj.pubKeyWithdrawal.address,\n      coin: obj.pubKeyWithdrawal.coin.toString(),\n    };\n  } else if (\"plutusScriptWithdrawal\" in obj) {\n    return {\n      type: \"ScriptWithdrawal\",\n      address: obj.plutusScriptWithdrawal.address,\n      coin: obj.plutusScriptWithdrawal.coin.toString(),\n      scriptSource: obj.plutusScriptWithdrawal.scriptSource\n        ? scriptSourceFromObj(obj.plutusScriptWithdrawal.scriptSource)\n        : undefined,\n      redeemer: obj.plutusScriptWithdrawal.redeemer\n        ? redeemerFromObj(obj.plutusScriptWithdrawal.redeemer)\n        : undefined,\n    };\n  } else if (\"simpleScriptWithdrawal\" in obj) {\n    return {\n      type: \"SimpleScriptWithdrawal\",\n      address: obj.simpleScriptWithdrawal.address,\n      coin: obj.simpleScriptWithdrawal.coin.toString(),\n      scriptSource: obj.simpleScriptWithdrawal.scriptSource\n        ? simpleScriptSourceFromObj(obj.simpleScriptWithdrawal.scriptSource)\n        : undefined,\n    };\n  }\n\n  throw new Error(\"withdrawalFromObj: Invalid withdrawal object format\");\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.certificate.ts.certificateToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.certificate.ts.certificateToObj",
      "name": "certificateToObj",
      "signature": "export const certificateToObj = (certificate: Certificate): object => {",
      "documentation": "",
      "parameters": [
        {
          "name": "certificate",
          "type": "Certificate",
          "optional": false
        }
      ],
      "returnType": "object",
      "isPublic": true,
      "line": 12,
      "raw": "export const certificateToObj = (certificate: Certificate): object => {\r\n  const baseCert = certificate.certType;\r\n  switch (certificate.type) {\r\n    case \"BasicCertificate\":\r\n      return {\r\n        basicCertificate: baseCertToObj(baseCert),\r\n      };\r\n    case \"ScriptCertificate\":\r\n      return {\r\n        scriptCertificate: {\r\n          cert: baseCertToObj(baseCert),\r\n          redeemer: certificate.redeemer\r\n            ? redeemerToObj(certificate.redeemer)\r\n            : null,\r\n          scriptSource: certificate.scriptSource\r\n            ? scriptSourceToObj(certificate.scriptSource)\r\n            : null,\r\n        },\r\n      };\r\n    case \"SimpleScriptCertificate\":\r\n      return {\r\n        simpleScriptCertificate: {\r\n          cert: baseCertToObj(baseCert),\r\n          simpleScriptSource: certificate.simpleScriptSource\r\n            ? simpleScriptSourceToObj(certificate.simpleScriptSource)\r\n            : null,\r\n        },\r\n      };\r\n  }\r\n};\r",
      "source": "mesh-core-csl",
      "implementation": "export const certificateToObj = (certificate: Certificate): object => {\r\n  const baseCert = certificate.certType;\r\n  switch (certificate.type) {\r\n    case \"BasicCertificate\":\r\n      return {\r\n        basicCertificate: baseCertToObj(baseCert),\r\n      };\r\n    case \"ScriptCertificate\":\r\n      return {\r\n        scriptCertificate: {\r\n          cert: baseCertToObj(baseCert),\r\n          redeemer: certificate.redeemer\r\n            ? redeemerToObj(certificate.redeemer)\r\n            : null,\r\n          scriptSource: certificate.scriptSource\r\n            ? scriptSourceToObj(certificate.scriptSource)\r\n            : null,\r\n        },\r\n      };\r\n    case \"SimpleScriptCertificate\":\r\n      return {\r\n        simpleScriptCertificate: {\r\n          cert: baseCertToObj(baseCert),\r\n          simpleScriptSource: certificate.simpleScriptSource\r\n            ? simpleScriptSourceToObj(certificate.simpleScriptSource)\r\n            : null,\r\n        },\r\n      };\r\n  }\r\n};\r"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.certificate.ts.baseCertToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.certificate.ts.baseCertToObj",
      "name": "baseCertToObj",
      "signature": "export const baseCertToObj = (baseCert: CertificateType): object => {",
      "documentation": "",
      "parameters": [
        {
          "name": "baseCert",
          "type": "CertificateType",
          "optional": false
        }
      ],
      "returnType": "object",
      "isPublic": true,
      "line": 43,
      "raw": "export const baseCertToObj = (baseCert: CertificateType): object => {\r\n  switch (baseCert.type) {\r\n    case \"RegisterPool\":\r\n      return {\r\n        registerPool: {\r\n          poolParams: poolParamsToObj(baseCert.poolParams),\r\n        },\r\n      };\r\n    case \"RegisterStake\":\r\n      return {\r\n        registerStake: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          coin: 2000000, // TODO: change in conway era (this should become an argument)\r\n        },\r\n      };\r\n    case \"DelegateStake\":\r\n      return {\r\n        delegateStake: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          poolId: baseCert.poolId,\r\n        },\r\n      };\r\n    case \"DeregisterStake\":\r\n      return {\r\n        deregisterStake: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n        },\r\n      };\r\n    case \"RetirePool\":\r\n      return {\r\n        retirePool: {\r\n          poolId: baseCert.poolId,\r\n          epoch: baseCert.epoch,\r\n        },\r\n      };\r\n    case \"VoteDelegation\":\r\n      return {\r\n        voteDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          drep: baseCert.drep,\r\n        },\r\n      };\r\n    case \"StakeAndVoteDelegation\":\r\n      return {\r\n        stakeAndVoteDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          poolKeyHash: baseCert.poolKeyHash,\r\n          drep: baseCert.drep,\r\n        },\r\n      };\r\n    case \"StakeRegistrationAndDelegation\":\r\n      return {\r\n        stakeRegistrationAndDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          poolKeyHash: baseCert.poolKeyHash,\r\n          coin: baseCert.coin,\r\n        },\r\n      };\r\n    case \"VoteRegistrationAndDelegation\":\r\n      return {\r\n        voteRegistrationAndDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          drep: baseCert.drep,\r\n          coin: baseCert.coin,\r\n        },\r\n      };\r\n    case \"StakeVoteRegistrationAndDelegation\":\r\n      return {\r\n        stakeVoteRegistrationAndDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          poolKeyHash: baseCert.poolKeyHash,\r\n          drep: baseCert.drep,\r\n          coin: baseCert.coin,\r\n        },\r\n      };\r\n    case \"CommitteeHotAuth\":\r\n      return {\r\n        committeeHotAuth: {\r\n          committeeColdKeyAddress: baseCert.committeeColdKeyAddress,\r\n          committeeHotKeyAddress: baseCert.committeeHotKeyAddress,\r\n        },\r\n      };\r\n    case \"CommitteeColdResign\":\r\n      return {\r\n        committeeColdResign: {\r\n          committeeColdKeyAddress: baseCert.committeeColdKeyAddress,\r\n          anchor: baseCert.anchor ?? null,\r\n        },\r\n      };\r\n\r\n    case \"DRepRegistration\":\r\n      return {\r\n        dRepRegistration: {\r\n          drepId: baseCert.drepId,\r\n          coin: baseCert.coin,\r\n          anchor: baseCert.anchor ?? null,\r\n        },\r\n      };\r\n    case \"DRepDeregistration\":\r\n      return {\r\n        dRepDeregistration: {\r\n          drepId: baseCert.drepId,\r\n          coin: baseCert.coin,\r\n        },\r\n      };\r\n    case \"DRepUpdate\":\r\n      return {\r\n        dRepUpdate: {\r\n          drepId: baseCert.drepId,\r\n          anchor: baseCert.anchor,\r\n        },\r\n      };\r\n  }\r\n};\r",
      "source": "mesh-core-csl",
      "implementation": "export const baseCertToObj = (baseCert: CertificateType): object => {\r\n  switch (baseCert.type) {\r\n    case \"RegisterPool\":\r\n      return {\r\n        registerPool: {\r\n          poolParams: poolParamsToObj(baseCert.poolParams),\r\n        },\r\n      };\r\n    case \"RegisterStake\":\r\n      return {\r\n        registerStake: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          coin: 2000000, // TODO: change in conway era (this should become an argument)\r\n        },\r\n      };\r\n    case \"DelegateStake\":\r\n      return {\r\n        delegateStake: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          poolId: baseCert.poolId,\r\n        },\r\n      };\r\n    case \"DeregisterStake\":\r\n      return {\r\n        deregisterStake: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n        },\r\n      };\r\n    case \"RetirePool\":\r\n      return {\r\n        retirePool: {\r\n          poolId: baseCert.poolId,\r\n          epoch: baseCert.epoch,\r\n        },\r\n      };\r\n    case \"VoteDelegation\":\r\n      return {\r\n        voteDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          drep: baseCert.drep,\r\n        },\r\n      };\r\n    case \"StakeAndVoteDelegation\":\r\n      return {\r\n        stakeAndVoteDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          poolKeyHash: baseCert.poolKeyHash,\r\n          drep: baseCert.drep,\r\n        },\r\n      };\r\n    case \"StakeRegistrationAndDelegation\":\r\n      return {\r\n        stakeRegistrationAndDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          poolKeyHash: baseCert.poolKeyHash,\r\n          coin: baseCert.coin,\r\n        },\r\n      };\r\n    case \"VoteRegistrationAndDelegation\":\r\n      return {\r\n        voteRegistrationAndDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          drep: baseCert.drep,\r\n          coin: baseCert.coin,\r\n        },\r\n      };\r\n    case \"StakeVoteRegistrationAndDelegation\":\r\n      return {\r\n        stakeVoteRegistrationAndDelegation: {\r\n          stakeKeyAddress: baseCert.stakeKeyAddress,\r\n          poolKeyHash: baseCert.poolKeyHash,\r\n          drep: baseCert.drep,\r\n          coin: baseCert.coin,\r\n        },\r\n      };\r\n    case \"CommitteeHotAuth\":\r\n      return {\r\n        committeeHotAuth: {\r\n          committeeColdKeyAddress: baseCert.committeeColdKeyAddress,\r\n          committeeHotKeyAddress: baseCert.committeeHotKeyAddress,\r\n        },\r\n      };\r\n    case \"CommitteeColdResign\":\r\n      return {\r\n        committeeColdResign: {\r\n          committeeColdKeyAddress: baseCert.committeeColdKeyAddress,\r\n          anchor: baseCert.anchor ?? null,\r\n        },\r\n      };\r\n\r\n    case \"DRepRegistration\":\r\n      return {\r\n        dRepRegistration: {\r\n          drepId: baseCert.drepId,\r\n          coin: baseCert.coin,\r\n          anchor: baseCert.anchor ?? null,\r\n        },\r\n      };\r\n    case \"DRepDeregistration\":\r\n      return {\r\n        dRepDeregistration: {\r\n          drepId: baseCert.drepId,\r\n          coin: baseCert.coin,\r\n        },\r\n      };\r\n    case \"DRepUpdate\":\r\n      return {\r\n        dRepUpdate: {\r\n          drepId: baseCert.drepId,\r\n          anchor: baseCert.anchor,\r\n        },\r\n      };\r\n  }\r\n};\r"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.certificate.ts.poolParamsToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.certificate.ts.poolParamsToObj",
      "name": "poolParamsToObj",
      "signature": "export const poolParamsToObj = (poolParams: PoolParams): object => {",
      "documentation": "",
      "parameters": [
        {
          "name": "poolParams",
          "type": "PoolParams",
          "optional": false
        }
      ],
      "returnType": "object",
      "isPublic": true,
      "line": 158,
      "raw": "export const poolParamsToObj = (poolParams: PoolParams): object => {\r\n  return {\r\n    vrfKeyHash: poolParams.vrfKeyHash,\r\n    operator: poolParams.operator,\r\n    pledge: poolParams.pledge,\r\n    cost: poolParams.cost,\r\n    margin: poolParams.margin,\r\n    relays: poolParams.relays.map((relay) => relayToObj(relay)),\r\n    owners: poolParams.owners,\r\n    rewardAddress: poolParams.rewardAddress,\r\n    metadata: poolParams.metadata\r\n      ? poolMetadataToObj(poolParams.metadata)\r\n      : undefined,\r\n  };\r\n};\r",
      "source": "mesh-core-csl",
      "implementation": "export const poolParamsToObj = (poolParams: PoolParams): object => {\r\n  return {\r\n    vrfKeyHash: poolParams.vrfKeyHash,\r\n    operator: poolParams.operator,\r\n    pledge: poolParams.pledge,\r\n    cost: poolParams.cost,\r\n    margin: poolParams.margin,\r\n    relays: poolParams.relays.map((relay) => relayToObj(relay)),\r\n    owners: poolParams.owners,\r\n    rewardAddress: poolParams.rewardAddress,\r\n    metadata: poolParams.metadata\r\n      ? poolMetadataToObj(poolParams.metadata)\r\n      : undefined,\r\n  };\r\n};\r"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.certificate.ts.poolMetadataToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.certificate.ts.poolMetadataToObj",
      "name": "poolMetadataToObj",
      "signature": "export const poolMetadataToObj = (poolMetadata: PoolMetadata): object => {",
      "documentation": "",
      "parameters": [
        {
          "name": "poolMetadata",
          "type": "PoolMetadata",
          "optional": false
        }
      ],
      "returnType": "object",
      "isPublic": true,
      "line": 174,
      "raw": "export const poolMetadataToObj = (poolMetadata: PoolMetadata): object => {\r\n  return {\r\n    url: poolMetadata.URL,\r\n    metadata: poolMetadata.hash,\r\n  };\r\n};\r",
      "source": "mesh-core-csl",
      "implementation": "export const poolMetadataToObj = (poolMetadata: PoolMetadata): object => {\r\n  return {\r\n    url: poolMetadata.URL,\r\n    metadata: poolMetadata.hash,\r\n  };\r\n};\r"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.certificate.ts.relayToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.certificate.ts.relayToObj",
      "name": "relayToObj",
      "signature": "export const relayToObj = (relay: Relay): object => {",
      "documentation": "",
      "parameters": [
        {
          "name": "relay",
          "type": "Relay",
          "optional": false
        }
      ],
      "returnType": "object",
      "isPublic": true,
      "line": 181,
      "raw": "export const relayToObj = (relay: Relay): object => {\r\n  switch (relay.type) {\r\n    case \"SingleHostAddr\":\r\n      return {\r\n        singleHostAddr: {\r\n          ipv4: relay.IPV4,\r\n          ipv6: relay.IPV6,\r\n          port: relay.port,\r\n        },\r\n      };\r\n    case \"SingleHostName\":\r\n      return {\r\n        singleHostName: {\r\n          hostname: relay.domainName,\r\n          port: relay.port,\r\n        },\r\n      };\r\n    case \"MultiHostName\":\r\n      return {\r\n        multiHostName: {\r\n          dnsName: relay.domainName,\r\n        },\r\n      };\r\n  }\r\n};\r",
      "source": "mesh-core-csl",
      "implementation": "export const relayToObj = (relay: Relay): object => {\r\n  switch (relay.type) {\r\n    case \"SingleHostAddr\":\r\n      return {\r\n        singleHostAddr: {\r\n          ipv4: relay.IPV4,\r\n          ipv6: relay.IPV6,\r\n          port: relay.port,\r\n        },\r\n      };\r\n    case \"SingleHostName\":\r\n      return {\r\n        singleHostName: {\r\n          hostname: relay.domainName,\r\n          port: relay.port,\r\n        },\r\n      };\r\n    case \"MultiHostName\":\r\n      return {\r\n        multiHostName: {\r\n          dnsName: relay.domainName,\r\n        },\r\n      };\r\n  }\r\n};\r"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.data.ts.builderDataToCbor",
      "fullName": "mesh-core-csl:core.adaptor.toObj.data.ts.builderDataToCbor",
      "name": "builderDataToCbor",
      "signature": "export const builderDataToCbor = ({ type, content }: BuilderData): string => {",
      "documentation": "",
      "parameters": [
        {
          "name": "{ type",
          "type": "any",
          "optional": false
        },
        {
          "name": "content }: BuilderData",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 5,
      "raw": "export const builderDataToCbor = ({ type, content }: BuilderData): string => {\n  if (type === \"Mesh\") {\n    return toPlutusData(content).to_hex();\n  }\n  if (type === \"CBOR\") {\n    return csl.PlutusData.from_hex(content as string).to_hex();\n  }\n  return csl.PlutusData.from_json(\n    content as string,\n    csl.PlutusDatumSchema.DetailedSchema,\n  ).to_hex();\n};",
      "source": "mesh-core-csl",
      "implementation": "export const builderDataToCbor = ({ type, content }: BuilderData): string => {\n  if (type === \"Mesh\") {\n    return toPlutusData(content).to_hex();\n  }\n  if (type === \"CBOR\") {\n    return csl.PlutusData.from_hex(content as string).to_hex();\n  }\n  return csl.PlutusData.from_json(\n    content as string,\n    csl.PlutusDatumSchema.DetailedSchema,\n  ).to_hex();\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.data.ts.redeemerToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.data.ts.redeemerToObj",
      "name": "redeemerToObj",
      "signature": "export const redeemerToObj = (redeemer: Redeemer): object => {",
      "documentation": "",
      "parameters": [
        {
          "name": "redeemer",
          "type": "Redeemer",
          "optional": false
        }
      ],
      "returnType": "object",
      "isPublic": true,
      "line": 18,
      "raw": "export const redeemerToObj = (redeemer: Redeemer): object => {\n  return {\n    data: builderDataToCbor(redeemer.data),\n    exUnits: redeemer.exUnits,\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const redeemerToObj = (redeemer: Redeemer): object => {\n  return {\n    data: builderDataToCbor(redeemer.data),\n    exUnits: redeemer.exUnits,\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.index.ts.meshTxBuilderBodyToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.index.ts.meshTxBuilderBodyToObj",
      "name": "meshTxBuilderBodyToObj",
      "signature": "export const meshTxBuilderBodyToObj = ({",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 16,
      "raw": "export const meshTxBuilderBodyToObj = ({\n  inputs,\n  outputs,\n  collaterals,\n  requiredSignatures,\n  referenceInputs,\n  mints,\n  changeAddress,\n  metadata,\n  validityRange,\n  certificates,\n  signingKey,\n  withdrawals,\n  votes,\n  fee,\n  network,\n}: MeshTxBuilderBody) => {\n  let mintsObj: object[] = [];\n  mints.forEach((mint: MintParam) => {\n    mint.mintValue.forEach((mintValue) => {\n      mintsObj.push(\n        mintItemToObj({\n          type: mint.type,\n          policyId: mint.policyId,\n          assetName: mintValue.assetName,\n          amount: mintValue.amount,\n          scriptSource: mint.scriptSource,\n          redeemer: mint.redeemer,\n        }),\n      );\n    });\n  });\n  return {\n    inputs: inputs.map(txInToObj),\n    outputs: outputs.map(outputToObj),\n    collaterals: collaterals.map(collateralTxInToObj),\n    requiredSignatures,\n    referenceInputs: referenceInputs,\n    mints: mintsObj,\n    changeAddress,\n    metadata: txMetadataToObj(metadata),\n    validityRange: validityRangeToObj(validityRange),\n    certificates: certificates.map(certificateToObj),\n    signingKey: signingKey,\n    withdrawals: withdrawals.map(withdrawalToObj),\n    votes: votes.map(voteToObj),\n    fee,\n    network: networkToObj(network),\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const meshTxBuilderBodyToObj = ({\n  inputs,\n  outputs,\n  collaterals,\n  requiredSignatures,\n  referenceInputs,\n  mints,\n  changeAddress,\n  metadata,\n  validityRange,\n  certificates,\n  signingKey,\n  withdrawals,\n  votes,\n  fee,\n  network,\n}: MeshTxBuilderBody) => {\n  let mintsObj: object[] = [];\n  mints.forEach((mint: MintParam) => {\n    mint.mintValue.forEach((mintValue) => {\n      mintsObj.push(\n        mintItemToObj({\n          type: mint.type,\n          policyId: mint.policyId,\n          assetName: mintValue.assetName,\n          amount: mintValue.amount,\n          scriptSource: mint.scriptSource,\n          redeemer: mint.redeemer,\n        }),\n      );\n    });\n  });\n  return {\n    inputs: inputs.map(txInToObj),\n    outputs: outputs.map(outputToObj),\n    collaterals: collaterals.map(collateralTxInToObj),\n    requiredSignatures,\n    referenceInputs: referenceInputs,\n    mints: mintsObj,\n    changeAddress,\n    metadata: txMetadataToObj(metadata),\n    validityRange: validityRangeToObj(validityRange),\n    certificates: certificates.map(certificateToObj),\n    signingKey: signingKey,\n    withdrawals: withdrawals.map(withdrawalToObj),\n    votes: votes.map(voteToObj),\n    fee,\n    network: networkToObj(network),\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.metadata.ts.txMetadataToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.metadata.ts.txMetadataToObj",
      "name": "txMetadataToObj",
      "signature": "export const txMetadataToObj = (metadata: TxMetadata): Metadata[] => {",
      "documentation": "",
      "parameters": [
        {
          "name": "metadata",
          "type": "TxMetadata",
          "optional": false
        }
      ],
      "returnType": "Metadata[]",
      "isPublic": true,
      "line": 5,
      "raw": "export const txMetadataToObj = (metadata: TxMetadata): Metadata[] => {\n  const result: Metadata[] = [];\n  metadata.forEach((value: Metadatum, key: bigint) => {\n    result.push({\n      tag: key.toString(),\n      metadata: JSONbig.stringify(metadatumToObj(value)),\n    });\n  });\n  return result;\n};",
      "source": "mesh-core-csl",
      "implementation": "export const txMetadataToObj = (metadata: TxMetadata): Metadata[] => {\n  const result: Metadata[] = [];\n  metadata.forEach((value: Metadatum, key: bigint) => {\n    result.push({\n      tag: key.toString(),\n      metadata: JSONbig.stringify(metadatumToObj(value)),\n    });\n  });\n  return result;\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.metadata.ts.metadatumToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.metadata.ts.metadatumToObj",
      "name": "metadatumToObj",
      "signature": "const metadatumToObj = (metadatum: Metadatum): any => {",
      "documentation": "",
      "parameters": [
        {
          "name": "metadatum",
          "type": "Metadatum",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 16,
      "raw": "const metadatumToObj = (metadatum: Metadatum): any => {\n  if (typeof metadatum === \"number\" || typeof metadatum === \"string\") {\n    return metadatum;\n  } else if (typeof metadatum === \"bigint\") {\n    return metadatum.toString();\n  } else if (metadatum instanceof Uint8Array) {\n    return uint8ArrayToHex(metadatum);\n  } else if (metadatum instanceof Map) {\n    const result: Record<string | number, any> = {};\n    metadatum.forEach((value, key) => {\n      result[metadatumToObj(key)] = metadatumToObj(value);\n    });\n    return result;\n  } else if (Array.isArray(metadatum)) {\n    return metadatum.map(metadatumToObj);\n  } else {\n    throw new Error(\"metadatumToObj: Unsupported Metadatum type\");\n  }\n};",
      "source": "mesh-core-csl",
      "implementation": "const metadatumToObj = (metadatum: Metadatum): any => {\n  if (typeof metadatum === \"number\" || typeof metadatum === \"string\") {\n    return metadatum;\n  } else if (typeof metadatum === \"bigint\") {\n    return metadatum.toString();\n  } else if (metadatum instanceof Uint8Array) {\n    return uint8ArrayToHex(metadatum);\n  } else if (metadatum instanceof Map) {\n    const result: Record<string | number, any> = {};\n    metadatum.forEach((value, key) => {\n      result[metadatumToObj(key)] = metadatumToObj(value);\n    });\n    return result;\n  } else if (Array.isArray(metadatum)) {\n    return metadatum.map(metadatumToObj);\n  } else {\n    throw new Error(\"metadatumToObj: Unsupported Metadatum type\");\n  }\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.metadata.ts.uint8ArrayToHex",
      "fullName": "mesh-core-csl:core.adaptor.toObj.metadata.ts.uint8ArrayToHex",
      "name": "uint8ArrayToHex",
      "signature": "const uint8ArrayToHex = (bytes: Uint8Array): string => {",
      "documentation": "",
      "parameters": [
        {
          "name": "bytes",
          "type": "Uint8Array",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 36,
      "raw": "const uint8ArrayToHex = (bytes: Uint8Array): string => {\n  return Array.from(bytes)\n    .map((byte) => byte.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n};",
      "source": "mesh-core-csl",
      "implementation": "const uint8ArrayToHex = (bytes: Uint8Array): string => {\n  return Array.from(bytes)\n    .map((byte) => byte.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.mint.ts.mintItemToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.mint.ts.mintItemToObj",
      "name": "mintItemToObj",
      "signature": "export const mintItemToObj = (mintItem: MintItem): object => {",
      "documentation": "",
      "parameters": [
        {
          "name": "mintItem",
          "type": "MintItem",
          "optional": false
        }
      ],
      "returnType": "object",
      "isPublic": true,
      "line": 10,
      "raw": "export const mintItemToObj = (mintItem: MintItem): object => {\n  switch (mintItem.type) {\n    case \"Plutus\":\n      return {\n        scriptMint: plutusMintItemToObj(mintItem as Required<MintItem>),\n      };\n    case \"Native\":\n      return {\n        simpleScriptMint: nativeMintItemToObj(\n          mintItem as Omit<Required<MintItem>, \"redeemer\">,\n        ),\n      };\n  }\n};",
      "source": "mesh-core-csl",
      "implementation": "export const mintItemToObj = (mintItem: MintItem): object => {\n  switch (mintItem.type) {\n    case \"Plutus\":\n      return {\n        scriptMint: plutusMintItemToObj(mintItem as Required<MintItem>),\n      };\n    case \"Native\":\n      return {\n        simpleScriptMint: nativeMintItemToObj(\n          mintItem as Omit<Required<MintItem>, \"redeemer\">,\n        ),\n      };\n  }\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.mint.ts.plutusMintItemToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.mint.ts.plutusMintItemToObj",
      "name": "plutusMintItemToObj",
      "signature": "export const plutusMintItemToObj = (mintItem: Required<MintItem>): object => {",
      "documentation": "",
      "parameters": [
        {
          "name": "mintItem",
          "type": "Required<MintItem>",
          "optional": false
        }
      ],
      "returnType": "object",
      "isPublic": true,
      "line": 25,
      "raw": "export const plutusMintItemToObj = (mintItem: Required<MintItem>): object => {\n  let scriptSource: object = scriptSourceToObj(\n    mintItem.scriptSource as ScriptSource,\n  );\n\n  return {\n    mint: mintParametersObj(mintItem),\n    redeemer: mintItem.redeemer ? redeemerToObj(mintItem.redeemer) : null,\n    scriptSource,\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const plutusMintItemToObj = (mintItem: Required<MintItem>): object => {\n  let scriptSource: object = scriptSourceToObj(\n    mintItem.scriptSource as ScriptSource,\n  );\n\n  return {\n    mint: mintParametersObj(mintItem),\n    redeemer: mintItem.redeemer ? redeemerToObj(mintItem.redeemer) : null,\n    scriptSource,\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.mint.ts.nativeMintItemToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.mint.ts.nativeMintItemToObj",
      "name": "nativeMintItemToObj",
      "signature": "export const nativeMintItemToObj = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 37,
      "raw": "export const nativeMintItemToObj = (\n  mintItem: Omit<Required<MintItem>, \"redeemer\">,\n): object => {\n  return {\n    mint: mintParametersObj(mintItem),\n    scriptSource: simpleScriptSourceToObj(\n      mintItem.scriptSource as SimpleScriptSourceInfo,\n    ),\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const nativeMintItemToObj = (\n  mintItem: Omit<Required<MintItem>, \"redeemer\">,\n): object => {\n  return {\n    mint: mintParametersObj(mintItem),\n    scriptSource: simpleScriptSourceToObj(\n      mintItem.scriptSource as SimpleScriptSourceInfo,\n    ),\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.mint.ts.mintParametersObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.mint.ts.mintParametersObj",
      "name": "mintParametersObj",
      "signature": "export const mintParametersObj = (mintItem: MintItem): object => {",
      "documentation": "",
      "parameters": [
        {
          "name": "mintItem",
          "type": "MintItem",
          "optional": false
        }
      ],
      "returnType": "object",
      "isPublic": true,
      "line": 48,
      "raw": "export const mintParametersObj = (mintItem: MintItem): object => {\n  return {\n    policyId: mintItem.policyId,\n    assetName: mintItem.assetName,\n    amount: BigInt(mintItem.amount),\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const mintParametersObj = (mintItem: MintItem): object => {\n  return {\n    policyId: mintItem.policyId,\n    assetName: mintItem.assetName,\n    amount: BigInt(mintItem.amount),\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.network.ts.networkToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.network.ts.networkToObj",
      "name": "networkToObj",
      "signature": "export const networkToObj = (network: Network | number[][]) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "network",
          "type": "Network | number[][]",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 3,
      "raw": "export const networkToObj = (network: Network | number[][]) => {\r\n  if ((typeof network) === \"string\") {\r\n    return network;\r\n  } else {\r\n    return {\r\n      custom: network,\r\n    };\r\n  }\r\n};\r",
      "source": "mesh-core-csl",
      "implementation": "export const networkToObj = (network: Network | number[][]) => {\r\n  if ((typeof network) === \"string\") {\r\n    return network;\r\n  } else {\r\n    return {\r\n      custom: network,\r\n    };\r\n  }\r\n};\r"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.network.ts.if",
      "fullName": "mesh-core-csl:core.adaptor.toObj.network.ts.if",
      "name": "if",
      "signature": "if ((typeof network) === \"string\") {",
      "documentation": "",
      "parameters": [
        {
          "name": "(typeof network",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 4,
      "raw": "  if ((typeof network) === \"string\") {\r\n    return network;\r\n  } else {\r\n    return {\r\n      custom: network,\r\n    };\r\n  }\r",
      "source": "mesh-core-csl",
      "implementation": "  if ((typeof network) === \"string\") {\r\n    return network;\r\n  } else {\r\n    return {\r\n      custom: network,\r\n    };\r\n  }\r"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.output.ts.outputToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.output.ts.outputToObj",
      "name": "outputToObj",
      "signature": "export const outputToObj = (output: Output): object => {",
      "documentation": "",
      "parameters": [
        {
          "name": "output",
          "type": "Output",
          "optional": false
        }
      ],
      "returnType": "object",
      "isPublic": true,
      "line": 5,
      "raw": "export const outputToObj = (output: Output): object => {\n  let datum: object | null = null;\n  if (output.datum) {\n    switch (output.datum.type) {\n      case \"Inline\":\n        datum = { inline: builderDataToCbor(output.datum.data) };\n        break;\n      case \"Hash\":\n        datum = { hash: builderDataToCbor(output.datum.data) };\n        break;\n      case \"Embedded\":\n        datum = { embedded: builderDataToCbor(output.datum.data) };\n        break;\n    }\n  }\n\n  // TODO: add native script\n  const refScript = output.referenceScript as PlutusScript;\n\n  return {\n    address: output.address,\n    amount: output.amount,\n    datum,\n    referenceScript: output.referenceScript\n      ? {\n          providedScriptSource: {\n            scriptCbor: refScript.code,\n            languageVersion: refScript.version.toLocaleLowerCase(),\n          },\n        }\n      : null,\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const outputToObj = (output: Output): object => {\n  let datum: object | null = null;\n  if (output.datum) {\n    switch (output.datum.type) {\n      case \"Inline\":\n        datum = { inline: builderDataToCbor(output.datum.data) };\n        break;\n      case \"Hash\":\n        datum = { hash: builderDataToCbor(output.datum.data) };\n        break;\n      case \"Embedded\":\n        datum = { embedded: builderDataToCbor(output.datum.data) };\n        break;\n    }\n  }\n\n  // TODO: add native script\n  const refScript = output.referenceScript as PlutusScript;\n\n  return {\n    address: output.address,\n    amount: output.amount,\n    datum,\n    referenceScript: output.referenceScript\n      ? {\n          providedScriptSource: {\n            scriptCbor: refScript.code,\n            languageVersion: refScript.version.toLocaleLowerCase(),\n          },\n        }\n      : null,\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.script.ts.scriptSourceToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.script.ts.scriptSourceToObj",
      "name": "scriptSourceToObj",
      "signature": "export const scriptSourceToObj = (scriptSource: ScriptSource): object => {",
      "documentation": "",
      "parameters": [
        {
          "name": "scriptSource",
          "type": "ScriptSource",
          "optional": false
        }
      ],
      "returnType": "object",
      "isPublic": true,
      "line": 7,
      "raw": "export const scriptSourceToObj = (scriptSource: ScriptSource): object => {\n  if (scriptSource.type === \"Provided\") {\n    return {\n      providedScriptSource: {\n        scriptCbor: scriptSource.script.code,\n        languageVersion: (\n          scriptSource.script as PlutusScript\n        ).version!.toLocaleLowerCase(),\n      },\n    };\n  }\n\n  return {\n    inlineScriptSource: {\n      refTxIn: {\n        txHash: scriptSource.txHash,\n        txIndex: scriptSource.txIndex,\n      },\n      scriptHash: scriptSource.scriptHash ?? \"\",\n      languageVersion: scriptSource.version!.toLocaleLowerCase(),\n      scriptSize: BigInt(scriptSource.scriptSize ?? \"0\"),\n    },\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const scriptSourceToObj = (scriptSource: ScriptSource): object => {\n  if (scriptSource.type === \"Provided\") {\n    return {\n      providedScriptSource: {\n        scriptCbor: scriptSource.script.code,\n        languageVersion: (\n          scriptSource.script as PlutusScript\n        ).version!.toLocaleLowerCase(),\n      },\n    };\n  }\n\n  return {\n    inlineScriptSource: {\n      refTxIn: {\n        txHash: scriptSource.txHash,\n        txIndex: scriptSource.txIndex,\n      },\n      scriptHash: scriptSource.scriptHash ?? \"\",\n      languageVersion: scriptSource.version!.toLocaleLowerCase(),\n      scriptSize: BigInt(scriptSource.scriptSize ?? \"0\"),\n    },\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.script.ts.simpleScriptSourceToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.script.ts.simpleScriptSourceToObj",
      "name": "simpleScriptSourceToObj",
      "signature": "export const simpleScriptSourceToObj = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 32,
      "raw": "export const simpleScriptSourceToObj = (\n  scriptSource: SimpleScriptSourceInfo,\n): object => {\n  if (scriptSource.type === \"Provided\") {\n    return {\n      providedSimpleScriptSource: {\n        scriptCbor: scriptSource.scriptCode,\n      },\n    };\n  }\n\n  return {\n    inlineSimpleScriptSource: {\n      refTxIn: {\n        txHash: scriptSource.txHash,\n        txIndex: scriptSource.txIndex,\n      },\n      simpleScriptHash: scriptSource.simpleScriptHash ?? \"\",\n    },\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const simpleScriptSourceToObj = (\n  scriptSource: SimpleScriptSourceInfo,\n): object => {\n  if (scriptSource.type === \"Provided\") {\n    return {\n      providedSimpleScriptSource: {\n        scriptCbor: scriptSource.scriptCode,\n      },\n    };\n  }\n\n  return {\n    inlineSimpleScriptSource: {\n      refTxIn: {\n        txHash: scriptSource.txHash,\n        txIndex: scriptSource.txIndex,\n      },\n      simpleScriptHash: scriptSource.simpleScriptHash ?? \"\",\n    },\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.txIn.ts.txInToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.txIn.ts.txInToObj",
      "name": "txInToObj",
      "signature": "export const txInToObj = (txIn: TxIn): object => {",
      "documentation": "",
      "parameters": [
        {
          "name": "txIn",
          "type": "TxIn",
          "optional": false
        }
      ],
      "returnType": "object",
      "isPublic": true,
      "line": 11,
      "raw": "export const txInToObj = (txIn: TxIn): object => {\n  switch (txIn.type) {\n    case \"PubKey\":\n      return {\n        pubKeyTxIn: {\n          txIn: txInParameterToObj(txIn.txIn),\n        },\n      };\n\n    case \"Script\":\n      return {\n        scriptTxIn: {\n          txIn: txInParameterToObj(txIn.txIn),\n          scriptTxIn: scriptTxInParameterToObj(txIn.scriptTxIn),\n        },\n      };\n\n    case \"SimpleScript\":\n      return {\n        simpleScriptTxIn: {\n          txIn: txInParameterToObj(txIn.txIn),\n          simpleScriptTxIn: simpleScriptTxInParameterToObj(\n            txIn.simpleScriptTxIn,\n          ),\n        },\n      };\n  }\n};",
      "source": "mesh-core-csl",
      "implementation": "export const txInToObj = (txIn: TxIn): object => {\n  switch (txIn.type) {\n    case \"PubKey\":\n      return {\n        pubKeyTxIn: {\n          txIn: txInParameterToObj(txIn.txIn),\n        },\n      };\n\n    case \"Script\":\n      return {\n        scriptTxIn: {\n          txIn: txInParameterToObj(txIn.txIn),\n          scriptTxIn: scriptTxInParameterToObj(txIn.scriptTxIn),\n        },\n      };\n\n    case \"SimpleScript\":\n      return {\n        simpleScriptTxIn: {\n          txIn: txInParameterToObj(txIn.txIn),\n          simpleScriptTxIn: simpleScriptTxInParameterToObj(\n            txIn.simpleScriptTxIn,\n          ),\n        },\n      };\n  }\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.txIn.ts.collateralTxInToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.txIn.ts.collateralTxInToObj",
      "name": "collateralTxInToObj",
      "signature": "export const collateralTxInToObj = (txIn: TxIn): object => {",
      "documentation": "",
      "parameters": [
        {
          "name": "txIn",
          "type": "TxIn",
          "optional": false
        }
      ],
      "returnType": "object",
      "isPublic": true,
      "line": 40,
      "raw": "export const collateralTxInToObj = (txIn: TxIn): object => {\n  return {\n    txIn: txInParameterToObj(txIn.txIn),\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const collateralTxInToObj = (txIn: TxIn): object => {\n  return {\n    txIn: txInParameterToObj(txIn.txIn),\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.txIn.ts.txInParameterToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.txIn.ts.txInParameterToObj",
      "name": "txInParameterToObj",
      "signature": "export const txInParameterToObj = (txInParameter: TxInParameter): object => {",
      "documentation": "",
      "parameters": [
        {
          "name": "txInParameter",
          "type": "TxInParameter",
          "optional": false
        }
      ],
      "returnType": "object",
      "isPublic": true,
      "line": 46,
      "raw": "export const txInParameterToObj = (txInParameter: TxInParameter): object => {\n  return {\n    txHash: txInParameter.txHash,\n    txIndex: txInParameter.txIndex,\n    amount: txInParameter.amount ?? null,\n    address: txInParameter.address ?? null,\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const txInParameterToObj = (txInParameter: TxInParameter): object => {\n  return {\n    txHash: txInParameter.txHash,\n    txIndex: txInParameter.txIndex,\n    amount: txInParameter.amount ?? null,\n    address: txInParameter.address ?? null,\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.txIn.ts.scriptTxInParameterToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.txIn.ts.scriptTxInParameterToObj",
      "name": "scriptTxInParameterToObj",
      "signature": "export const scriptTxInParameterToObj = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 55,
      "raw": "export const scriptTxInParameterToObj = (\n  scriptTxInParameter: ScriptTxInParameter,\n): object => {\n  let scriptSource: object | null = null;\n  let datumSource: object | null = null;\n\n  if (scriptTxInParameter.scriptSource) {\n    scriptSource = scriptSourceToObj(scriptTxInParameter.scriptSource);\n  }\n\n  if (scriptTxInParameter.datumSource) {\n    switch (scriptTxInParameter.datumSource.type) {\n      case \"Provided\":\n        datumSource = {\n          providedDatumSource: {\n            data: builderDataToCbor(scriptTxInParameter.datumSource.data),\n          },\n        };\n        break;\n      case \"Inline\":\n        datumSource = {\n          inlineDatumSource: {\n            txHash: scriptTxInParameter.datumSource.txHash,\n            txIndex: scriptTxInParameter.datumSource.txIndex,\n          },\n        };\n        break;\n    }\n  }\n\n  return {\n    scriptSource,\n    datumSource,\n    redeemer: scriptTxInParameter.redeemer\n      ? redeemerToObj(scriptTxInParameter.redeemer)\n      : null,\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const scriptTxInParameterToObj = (\n  scriptTxInParameter: ScriptTxInParameter,\n): object => {\n  let scriptSource: object | null = null;\n  let datumSource: object | null = null;\n\n  if (scriptTxInParameter.scriptSource) {\n    scriptSource = scriptSourceToObj(scriptTxInParameter.scriptSource);\n  }\n\n  if (scriptTxInParameter.datumSource) {\n    switch (scriptTxInParameter.datumSource.type) {\n      case \"Provided\":\n        datumSource = {\n          providedDatumSource: {\n            data: builderDataToCbor(scriptTxInParameter.datumSource.data),\n          },\n        };\n        break;\n      case \"Inline\":\n        datumSource = {\n          inlineDatumSource: {\n            txHash: scriptTxInParameter.datumSource.txHash,\n            txIndex: scriptTxInParameter.datumSource.txIndex,\n          },\n        };\n        break;\n    }\n  }\n\n  return {\n    scriptSource,\n    datumSource,\n    redeemer: scriptTxInParameter.redeemer\n      ? redeemerToObj(scriptTxInParameter.redeemer)\n      : null,\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.txIn.ts.simpleScriptTxInParameterToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.txIn.ts.simpleScriptTxInParameterToObj",
      "name": "simpleScriptTxInParameterToObj",
      "signature": "export const simpleScriptTxInParameterToObj = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 94,
      "raw": "export const simpleScriptTxInParameterToObj = (\n  simpleScriptTxInParameter: SimpleScriptTxInParameter,\n) => {\n  if (simpleScriptTxInParameter.scriptSource) {\n    let scriptSource: object | null = null;\n\n    switch (simpleScriptTxInParameter.scriptSource.type) {\n      case \"Inline\":\n        scriptSource = {\n          inlineSimpleScriptSource: {\n            refTxIn: {\n              txHash: simpleScriptTxInParameter.scriptSource.txHash,\n              txIndex: simpleScriptTxInParameter.scriptSource.txIndex,\n            },\n            simpleScriptHash:\n              simpleScriptTxInParameter.scriptSource.simpleScriptHash ?? \"\",\n            scriptSize: BigInt(\n              simpleScriptTxInParameter.scriptSource.scriptSize ?? \"0\",\n            ),\n          },\n        };\n        break;\n      case \"Provided\":\n        scriptSource = {\n          providedSimpleScriptSource: {\n            scriptCbor: simpleScriptTxInParameter.scriptSource.scriptCode,\n          },\n        };\n        break;\n    }\n    return scriptSource;\n  }\n};",
      "source": "mesh-core-csl",
      "implementation": "export const simpleScriptTxInParameterToObj = (\n  simpleScriptTxInParameter: SimpleScriptTxInParameter,\n) => {\n  if (simpleScriptTxInParameter.scriptSource) {\n    let scriptSource: object | null = null;\n\n    switch (simpleScriptTxInParameter.scriptSource.type) {\n      case \"Inline\":\n        scriptSource = {\n          inlineSimpleScriptSource: {\n            refTxIn: {\n              txHash: simpleScriptTxInParameter.scriptSource.txHash,\n              txIndex: simpleScriptTxInParameter.scriptSource.txIndex,\n            },\n            simpleScriptHash:\n              simpleScriptTxInParameter.scriptSource.simpleScriptHash ?? \"\",\n            scriptSize: BigInt(\n              simpleScriptTxInParameter.scriptSource.scriptSize ?? \"0\",\n            ),\n          },\n        };\n        break;\n      case \"Provided\":\n        scriptSource = {\n          providedSimpleScriptSource: {\n            scriptCbor: simpleScriptTxInParameter.scriptSource.scriptCode,\n          },\n        };\n        break;\n    }\n    return scriptSource;\n  }\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.utxo.ts.utxoToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.utxo.ts.utxoToObj",
      "name": "utxoToObj",
      "signature": "export const utxoToObj = ({",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 3,
      "raw": "export const utxoToObj = ({\n  input: { outputIndex, txHash },\n  output: { address, amount, dataHash, plutusData, scriptRef, scriptHash },\n}: UTxO): object => {\n  return {\n    input: {\n      outputIndex,\n      txHash,\n    },\n    output: {\n      address,\n      amount,\n      dataHash: dataHash ?? null,\n      plutusData: plutusData ?? null,\n      scriptRef: scriptRef ?? null,\n      scriptHash: scriptHash ?? null,\n    },\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const utxoToObj = ({\n  input: { outputIndex, txHash },\n  output: { address, amount, dataHash, plutusData, scriptRef, scriptHash },\n}: UTxO): object => {\n  return {\n    input: {\n      outputIndex,\n      txHash,\n    },\n    output: {\n      address,\n      amount,\n      dataHash: dataHash ?? null,\n      plutusData: plutusData ?? null,\n      scriptRef: scriptRef ?? null,\n      scriptHash: scriptHash ?? null,\n    },\n  };\n};"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.vote.ts.voteToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.vote.ts.voteToObj",
      "name": "voteToObj",
      "signature": "export const voteToObj = (vote: Vote): object => {",
      "documentation": "",
      "parameters": [
        {
          "name": "vote",
          "type": "Vote",
          "optional": false
        }
      ],
      "returnType": "object",
      "isPublic": true,
      "line": 6,
      "raw": "export const voteToObj = (vote: Vote): object => {\r\n  if (vote.type === \"BasicVote\") {\r\n    return {\r\n      basicVote: voteTypeToObj(vote.vote),\r\n    };\r\n  } else if (vote.type === \"ScriptVote\") {\r\n    if (!vote.scriptSource) {\r\n      throw new Error(\"voteToObj: missing scriptSource in plutusScriptVote.\");\r\n    }\r\n    if (!vote.redeemer) {\r\n      throw new Error(\"voteToObj: missing redeemer in plutusScriptVote.\");\r\n    }\r\n\r\n    return {\r\n      scriptVote: {\r\n        vote: voteTypeToObj(vote.vote),\r\n        redeemer: redeemerToObj(vote.redeemer),\r\n        scriptSource: scriptSourceToObj(vote.scriptSource),\r\n      },\r\n    };\r\n  } else {\r\n    if (!vote.simpleScriptSource) {\r\n      throw new Error(\"voteToObj: missing script source in simpleScriptVote\");\r\n    }\r\n\r\n    return {\r\n      simpleScriptVote: {\r\n        vote: voteTypeToObj(vote.vote),\r\n        simpleScriptSource: simpleScriptSourceToObj(vote.simpleScriptSource),\r\n      },\r\n    };\r\n  }\r\n};\r",
      "source": "mesh-core-csl",
      "implementation": "export const voteToObj = (vote: Vote): object => {\r\n  if (vote.type === \"BasicVote\") {\r\n    return {\r\n      basicVote: voteTypeToObj(vote.vote),\r\n    };\r\n  } else if (vote.type === \"ScriptVote\") {\r\n    if (!vote.scriptSource) {\r\n      throw new Error(\"voteToObj: missing scriptSource in plutusScriptVote.\");\r\n    }\r\n    if (!vote.redeemer) {\r\n      throw new Error(\"voteToObj: missing redeemer in plutusScriptVote.\");\r\n    }\r\n\r\n    return {\r\n      scriptVote: {\r\n        vote: voteTypeToObj(vote.vote),\r\n        redeemer: redeemerToObj(vote.redeemer),\r\n        scriptSource: scriptSourceToObj(vote.scriptSource),\r\n      },\r\n    };\r\n  } else {\r\n    if (!vote.simpleScriptSource) {\r\n      throw new Error(\"voteToObj: missing script source in simpleScriptVote\");\r\n    }\r\n\r\n    return {\r\n      simpleScriptVote: {\r\n        vote: voteTypeToObj(vote.vote),\r\n        simpleScriptSource: simpleScriptSourceToObj(vote.simpleScriptSource),\r\n      },\r\n    };\r\n  }\r\n};\r"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.vote.ts.voteTypeToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.vote.ts.voteTypeToObj",
      "name": "voteTypeToObj",
      "signature": "const voteTypeToObj = (voteType: VoteType) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "voteType",
          "type": "VoteType",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 40,
      "raw": "const voteTypeToObj = (voteType: VoteType) => {\r\n  let voter = {};\r\n\r\n  switch (voteType.voter.type) {\r\n    case \"ConstitutionalCommittee\": {\r\n      let ccCred = {};\r\n      switch (voteType.voter.hotCred.type) {\r\n        case \"ScriptHash\": {\r\n          ccCred = {\r\n            scriptHash: voteType.voter.hotCred.scriptHash,\r\n          };\r\n          break;\r\n        }\r\n        case \"KeyHash\": {\r\n          ccCred = {\r\n            keyHash: voteType.voter.hotCred.keyHash,\r\n          };\r\n          break;\r\n        }\r\n      }\r\n      voter = {\r\n        constitutionalCommitteeHotCred: ccCred,\r\n      };\r\n      break;\r\n    }\r\n    case \"DRep\": {\r\n      voter = {\r\n        dRepId: voteType.voter.drepId,\r\n      };\r\n      break;\r\n    }\r\n    case \"StakingPool\": {\r\n      voter = {\r\n        stakingPoolKeyHash: voteType.voter.keyHash,\r\n      };\r\n      break;\r\n    }\r\n  }\r\n\r\n  let votingProcedure = {};\r\n  switch (voteType.votingProcedure.voteKind) {\r\n    case \"Yes\": {\r\n      votingProcedure = {\r\n        voteKind: \"yes\",\r\n        anchor: voteType.votingProcedure.anchor ?? null,\r\n      };\r\n      break;\r\n    }\r\n    case \"No\": {\r\n      votingProcedure = {\r\n        voteKind: \"no\",\r\n        anchor: voteType.votingProcedure.anchor ?? null,\r\n      };\r\n      break;\r\n    }\r\n    case \"Abstain\": {\r\n      votingProcedure = {\r\n        voteKind: \"abstain\",\r\n        anchor: voteType.votingProcedure.anchor ?? null,\r\n      };\r\n      break;\r\n    }\r\n  }\r\n\r\n  return {\r\n    voter,\r\n    votingProcedure,\r\n    govActionId: voteType.govActionId,\r\n  };\r\n};\r",
      "source": "mesh-core-csl",
      "implementation": "const voteTypeToObj = (voteType: VoteType) => {\r\n  let voter = {};\r\n\r\n  switch (voteType.voter.type) {\r\n    case \"ConstitutionalCommittee\": {\r\n      let ccCred = {};\r\n      switch (voteType.voter.hotCred.type) {\r\n        case \"ScriptHash\": {\r\n          ccCred = {\r\n            scriptHash: voteType.voter.hotCred.scriptHash,\r\n          };\r\n          break;\r\n        }\r\n        case \"KeyHash\": {\r\n          ccCred = {\r\n            keyHash: voteType.voter.hotCred.keyHash,\r\n          };\r\n          break;\r\n        }\r\n      }\r\n      voter = {\r\n        constitutionalCommitteeHotCred: ccCred,\r\n      };\r\n      break;\r\n    }\r\n    case \"DRep\": {\r\n      voter = {\r\n        dRepId: voteType.voter.drepId,\r\n      };\r\n      break;\r\n    }\r\n    case \"StakingPool\": {\r\n      voter = {\r\n        stakingPoolKeyHash: voteType.voter.keyHash,\r\n      };\r\n      break;\r\n    }\r\n  }\r\n\r\n  let votingProcedure = {};\r\n  switch (voteType.votingProcedure.voteKind) {\r\n    case \"Yes\": {\r\n      votingProcedure = {\r\n        voteKind: \"yes\",\r\n        anchor: voteType.votingProcedure.anchor ?? null,\r\n      };\r\n      break;\r\n    }\r\n    case \"No\": {\r\n      votingProcedure = {\r\n        voteKind: \"no\",\r\n        anchor: voteType.votingProcedure.anchor ?? null,\r\n      };\r\n      break;\r\n    }\r\n    case \"Abstain\": {\r\n      votingProcedure = {\r\n        voteKind: \"abstain\",\r\n        anchor: voteType.votingProcedure.anchor ?? null,\r\n      };\r\n      break;\r\n    }\r\n  }\r\n\r\n  return {\r\n    voter,\r\n    votingProcedure,\r\n    govActionId: voteType.govActionId,\r\n  };\r\n};\r"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.withdrawal.ts.withdrawalToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.withdrawal.ts.withdrawalToObj",
      "name": "withdrawalToObj",
      "signature": "export const withdrawalToObj = (withdrawal: Withdrawal): object => {",
      "documentation": "",
      "parameters": [
        {
          "name": "withdrawal",
          "type": "Withdrawal",
          "optional": false
        }
      ],
      "returnType": "object",
      "isPublic": true,
      "line": 6,
      "raw": "export const withdrawalToObj = (withdrawal: Withdrawal): object => {\n  if (withdrawal.type === \"PubKeyWithdrawal\") {\n    return {\n      pubKeyWithdrawal: {\n        address: withdrawal.address,\n        coin: BigInt(withdrawal.coin),\n      },\n    };\n  } else if (withdrawal.type === \"ScriptWithdrawal\") {\n    if (!withdrawal.scriptSource) {\n      throw new Error(\n        \"withdrawalToObj: missing scriptSource in plutusScriptWithdrawal.\",\n      );\n    }\n    if (!withdrawal.redeemer) {\n      throw new Error(\n        \"withdrawalToObj: missing redeemer in plutusScriptWithdrawal.\",\n      );\n    }\n\n    return {\n      plutusScriptWithdrawal: {\n        address: withdrawal.address,\n        coin: BigInt(withdrawal.coin),\n        scriptSource: scriptSourceToObj(withdrawal.scriptSource),\n        redeemer: redeemerToObj(withdrawal.redeemer),\n      },\n    };\n  } else {\n    if (!withdrawal.scriptSource) {\n      throw new Error(\n        \"withdrawalToObj: missing script source in simpleScriptWithdrawal\",\n      );\n    }\n\n    return {\n      simpleScriptWithdrawal: {\n        address: withdrawal.address,\n        coin: BigInt(withdrawal.coin),\n        scriptSource: simpleScriptSourceToObj(withdrawal.scriptSource),\n      },\n    };\n  }\n};",
      "source": "mesh-core-csl",
      "implementation": "export const withdrawalToObj = (withdrawal: Withdrawal): object => {\n  if (withdrawal.type === \"PubKeyWithdrawal\") {\n    return {\n      pubKeyWithdrawal: {\n        address: withdrawal.address,\n        coin: BigInt(withdrawal.coin),\n      },\n    };\n  } else if (withdrawal.type === \"ScriptWithdrawal\") {\n    if (!withdrawal.scriptSource) {\n      throw new Error(\n        \"withdrawalToObj: missing scriptSource in plutusScriptWithdrawal.\",\n      );\n    }\n    if (!withdrawal.redeemer) {\n      throw new Error(\n        \"withdrawalToObj: missing redeemer in plutusScriptWithdrawal.\",\n      );\n    }\n\n    return {\n      plutusScriptWithdrawal: {\n        address: withdrawal.address,\n        coin: BigInt(withdrawal.coin),\n        scriptSource: scriptSourceToObj(withdrawal.scriptSource),\n        redeemer: redeemerToObj(withdrawal.redeemer),\n      },\n    };\n  } else {\n    if (!withdrawal.scriptSource) {\n      throw new Error(\n        \"withdrawalToObj: missing script source in simpleScriptWithdrawal\",\n      );\n    }\n\n    return {\n      simpleScriptWithdrawal: {\n        address: withdrawal.address,\n        coin: BigInt(withdrawal.coin),\n        scriptSource: simpleScriptSourceToObj(withdrawal.scriptSource),\n      },\n    };\n  }\n};"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.addSigningKeys",
      "fullName": "mesh-core-csl:core.serializer.ts.addSigningKeys",
      "name": "addSigningKeys",
      "signature": "addSigningKeys(txHex: string, signingKeys: string[]): string {",
      "documentation": "",
      "parameters": [
        {
          "name": "txHex",
          "type": "string",
          "optional": false
        },
        {
          "name": "signingKeys",
          "type": "string[]",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 88,
      "raw": "  addSigningKeys(txHex: string, signingKeys: string[]): string {\n    if (signingKeys.length > 0) {\n      return signTransaction(txHex, signingKeys);\n    }\n    return txHex;\n  }",
      "source": "mesh-core-csl",
      "implementation": "  addSigningKeys(txHex: string, signingKeys: string[]): string {\n    if (signingKeys.length > 0) {\n      return signTransaction(txHex, signingKeys);\n    }\n    return txHex;\n  }"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.serializeData",
      "fullName": "mesh-core-csl:core.serializer.ts.serializeData",
      "name": "serializeData",
      "signature": "serializeData(data: BuilderData): string {",
      "documentation": "",
      "parameters": [
        {
          "name": "data",
          "type": "BuilderData",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 95,
      "raw": "  serializeData(data: BuilderData): string {\n    return builderDataToCbor(data);\n  }",
      "source": "mesh-core-csl",
      "implementation": "  serializeData(data: BuilderData): string {\n    return builderDataToCbor(data);\n  }"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.serializePoolId",
      "fullName": "mesh-core-csl:core.serializer.ts.serializePoolId",
      "name": "serializePoolId",
      "signature": "serializePoolId(hash: string): string {",
      "documentation": "",
      "parameters": [
        {
          "name": "hash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 106,
      "raw": "  serializePoolId(hash: string): string {\n    return serializePoolId(hash);\n  }",
      "source": "mesh-core-csl",
      "implementation": "  serializePoolId(hash: string): string {\n    return serializePoolId(hash);\n  }"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.serializeOutput",
      "fullName": "mesh-core-csl:core.serializer.ts.serializeOutput",
      "name": "serializeOutput",
      "signature": "serializeOutput(output: Output): string {",
      "documentation": "",
      "parameters": [
        {
          "name": "output",
          "type": "Output",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 192,
      "raw": "  serializeOutput(output: Output): string {\n    let cslOutputBuilder = csl.TransactionOutputBuilder.new().with_address(\n      csl.Address.from_bech32(output.address),\n    );\n    if (output.datum?.type === \"Hash\") {\n      cslOutputBuilder.with_data_hash(\n        csl.hash_plutus_data(castDataToPlutusData(output.datum.data)),\n      );\n    } else if (output.datum?.type === \"Inline\") {\n      cslOutputBuilder.with_plutus_data(\n        castDataToPlutusData(output.datum.data),\n      );\n    } else if (output.datum?.type === \"Embedded\") {\n      throw new Error(\"Embedded datum not supported\");\n    }\n    if (output.referenceScript) {\n      switch (output.referenceScript.version) {\n        case \"V1\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v1(),\n              ),\n            ),\n          );\n          break;\n        }\n        case \"V2\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v2(),\n              ),\n            ),\n          );\n          break;\n        }\n        case \"V3\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v3(),\n              ),\n            ),\n          );\n          break;\n        }\n        default: {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_native_script(\n              csl.NativeScript.from_hex(output.referenceScript.code),\n            ),\n          );\n          break;\n        }\n      }\n    }\n\n    return cslOutputBuilder\n      .next()\n      .with_value(toCslValue(output.amount))\n      .build()\n      .to_hex();\n  }",
      "source": "mesh-core-csl",
      "implementation": "  serializeOutput(output: Output): string {\n    let cslOutputBuilder = csl.TransactionOutputBuilder.new().with_address(\n      csl.Address.from_bech32(output.address),\n    );\n    if (output.datum?.type === \"Hash\") {\n      cslOutputBuilder.with_data_hash(\n        csl.hash_plutus_data(castDataToPlutusData(output.datum.data)),\n      );\n    } else if (output.datum?.type === \"Inline\") {\n      cslOutputBuilder.with_plutus_data(\n        castDataToPlutusData(output.datum.data),\n      );\n    } else if (output.datum?.type === \"Embedded\") {\n      throw new Error(\"Embedded datum not supported\");\n    }\n    if (output.referenceScript) {\n      switch (output.referenceScript.version) {\n        case \"V1\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v1(),\n              ),\n            ),\n          );\n          break;\n        }\n        case \"V2\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v2(),\n              ),\n            ),\n          );\n          break;\n        }\n        case \"V3\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v3(),\n              ),\n            ),\n          );\n          break;\n        }\n        default: {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_native_script(\n              csl.NativeScript.from_hex(output.referenceScript.code),\n            ),\n          );\n          break;\n        }\n      }\n    }\n\n    return cslOutputBuilder\n      .next()\n      .with_value(toCslValue(output.amount))\n      .build()\n      .to_hex();\n  }"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.serializeValue",
      "fullName": "mesh-core-csl:core.serializer.ts.serializeValue",
      "name": "serializeValue",
      "signature": "serializeValue(value: Asset[]): string {",
      "documentation": "",
      "parameters": [
        {
          "name": "value",
          "type": "Asset[]",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 308,
      "raw": "  serializeValue(value: Asset[]): string {\n    return toCslValue(value).to_hex();\n  }",
      "source": "mesh-core-csl",
      "implementation": "  serializeValue(value: Asset[]): string {\n    return toCslValue(value).to_hex();\n  }"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toAddress",
      "fullName": "mesh-core-csl:deser.converter.ts.toAddress",
      "name": "toAddress",
      "signature": "export const toAddress = (bech32: string) => csl.Address.from_bech32(bech32);",
      "documentation": "",
      "parameters": [
        {
          "name": "bech32",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 23,
      "raw": "export const toAddress = (bech32: string) => csl.Address.from_bech32(bech32);\n\nexport const toBaseAddress = (bech32: string) =>\n  csl.BaseAddress.from_address(toAddress(bech32));\n\nexport const toEnterpriseAddress = (bech32: string) =>\n  csl.EnterpriseAddress.from_address(toAddress(bech32));\n\nexport const toRewardAddress = (bech32: string) =>\n  csl.RewardAddress.from_address(toAddress(bech32));\n\n/* -----------------[ Bytes ]----------------- */\n\nexport const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};",
      "source": "mesh-core-csl",
      "implementation": "export const toAddress = (bech32: string) => csl.Address.from_bech32(bech32);\n\nexport const toBaseAddress = (bech32: string) =>\n  csl.BaseAddress.from_address(toAddress(bech32));\n\nexport const toEnterpriseAddress = (bech32: string) =>\n  csl.EnterpriseAddress.from_address(toAddress(bech32));\n\nexport const toRewardAddress = (bech32: string) =>\n  csl.RewardAddress.from_address(toAddress(bech32));\n\n/* -----------------[ Bytes ]----------------- */\n\nexport const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toBaseAddress",
      "fullName": "mesh-core-csl:deser.converter.ts.toBaseAddress",
      "name": "toBaseAddress",
      "signature": "export const toBaseAddress = (bech32: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "bech32",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 25,
      "raw": "export const toBaseAddress = (bech32: string) =>\n  csl.BaseAddress.from_address(toAddress(bech32));\n\nexport const toEnterpriseAddress = (bech32: string) =>\n  csl.EnterpriseAddress.from_address(toAddress(bech32));\n\nexport const toRewardAddress = (bech32: string) =>\n  csl.RewardAddress.from_address(toAddress(bech32));\n\n/* -----------------[ Bytes ]----------------- */\n\nexport const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};",
      "source": "mesh-core-csl",
      "implementation": "export const toBaseAddress = (bech32: string) =>\n  csl.BaseAddress.from_address(toAddress(bech32));\n\nexport const toEnterpriseAddress = (bech32: string) =>\n  csl.EnterpriseAddress.from_address(toAddress(bech32));\n\nexport const toRewardAddress = (bech32: string) =>\n  csl.RewardAddress.from_address(toAddress(bech32));\n\n/* -----------------[ Bytes ]----------------- */\n\nexport const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toEnterpriseAddress",
      "fullName": "mesh-core-csl:deser.converter.ts.toEnterpriseAddress",
      "name": "toEnterpriseAddress",
      "signature": "export const toEnterpriseAddress = (bech32: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "bech32",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 28,
      "raw": "export const toEnterpriseAddress = (bech32: string) =>\n  csl.EnterpriseAddress.from_address(toAddress(bech32));\n\nexport const toRewardAddress = (bech32: string) =>\n  csl.RewardAddress.from_address(toAddress(bech32));\n\n/* -----------------[ Bytes ]----------------- */\n\nexport const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};",
      "source": "mesh-core-csl",
      "implementation": "export const toEnterpriseAddress = (bech32: string) =>\n  csl.EnterpriseAddress.from_address(toAddress(bech32));\n\nexport const toRewardAddress = (bech32: string) =>\n  csl.RewardAddress.from_address(toAddress(bech32));\n\n/* -----------------[ Bytes ]----------------- */\n\nexport const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toRewardAddress",
      "fullName": "mesh-core-csl:deser.converter.ts.toRewardAddress",
      "name": "toRewardAddress",
      "signature": "export const toRewardAddress = (bech32: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "bech32",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 31,
      "raw": "export const toRewardAddress = (bech32: string) =>\n  csl.RewardAddress.from_address(toAddress(bech32));\n\n/* -----------------[ Bytes ]----------------- */\n\nexport const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};",
      "source": "mesh-core-csl",
      "implementation": "export const toRewardAddress = (bech32: string) =>\n  csl.RewardAddress.from_address(toAddress(bech32));\n\n/* -----------------[ Bytes ]----------------- */\n\nexport const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.fromBytes",
      "fullName": "mesh-core-csl:deser.converter.ts.fromBytes",
      "name": "fromBytes",
      "signature": "export const fromBytes = (bytes: Uint8Array) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "bytes",
          "type": "Uint8Array",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 36,
      "raw": "export const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};",
      "source": "mesh-core-csl",
      "implementation": "export const fromBytes = (bytes: Uint8Array) =>\n  Buffer.from(bytes).toString(\"hex\");\n\nexport const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toBytes",
      "fullName": "mesh-core-csl:deser.converter.ts.toBytes",
      "name": "toBytes",
      "signature": "export const toBytes = (hex: string): Uint8Array => {",
      "documentation": "",
      "parameters": [
        {
          "name": "hex",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Uint8Array",
      "isPublic": true,
      "line": 39,
      "raw": "export const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};",
      "source": "mesh-core-csl",
      "implementation": "export const toBytes = (hex: string): Uint8Array => {\n  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))\n    return Buffer.from(hex, \"hex\");\n\n  return Buffer.from(hex, \"utf-8\");\n};"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.fromUTF8",
      "fullName": "mesh-core-csl:deser.converter.ts.fromUTF8",
      "name": "fromUTF8",
      "signature": "export const fromUTF8 = (utf8: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "utf8",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 48,
      "raw": "export const fromUTF8 = (utf8: string) => {\n  if (utf8.length % 2 === 0 && /^[0-9A-F]*$/i.test(utf8)) return utf8;\n\n  return fromBytes(Buffer.from(utf8, \"utf-8\"));\n};",
      "source": "mesh-core-csl",
      "implementation": "export const fromUTF8 = (utf8: string) => {\n  if (utf8.length % 2 === 0 && /^[0-9A-F]*$/i.test(utf8)) return utf8;\n\n  return fromBytes(Buffer.from(utf8, \"utf-8\"));\n};"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toUTF8",
      "fullName": "mesh-core-csl:deser.converter.ts.toUTF8",
      "name": "toUTF8",
      "signature": "export const toUTF8 = (hex: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "hex",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 54,
      "raw": "export const toUTF8 = (hex: string) =>\n  Buffer.from(hex, \"hex\").toString(\"utf-8\");\n\n/* -----------------[ Lovelace ]----------------- */\n\nexport const fromLovelace = (lovelace: number) => lovelace / 1_000_000;\n\nexport const toLovelace = (ada: number) => ada * 1_000_000;\n\n// /* -----------------[ NativeScript ]----------------- */\n\n// export const fromNativeScript = (script: csl.NativeScript) => {\n//   const fromNativeScripts = (scripts: csl.NativeScripts) => {\n//     const nativeScripts = new Array<NativeScript>();\n\n//     for (let index = 0; index < scripts.len(); index += 1) {\n//       nativeScripts.push(fromNativeScript(scripts.get(index)));\n//     }\n\n//     return nativeScripts;\n//   };\n\n//   switch (script.kind()) {\n//     case csl.NativeScriptKind.ScriptAll: {\n//       const scriptAll = script.as_script_all()!;\n//       return <NativeScript>{\n//         type: \"all\",\n//         scripts: fromNativeScripts(scriptAll.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptAny: {\n//       const scriptAny = script.as_script_any()!;\n//       return <NativeScript>{\n//         type: \"any\",\n//         scripts: fromNativeScripts(scriptAny.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptNOfK: {\n//       const scriptNOfK = script.as_script_n_of_k()!;\n//       return <NativeScript>{\n//         type: \"atLeast\",\n//         required: scriptNOfK.n(),\n//         scripts: fromNativeScripts(scriptNOfK.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockStart: {\n//       const timelockStart = script.as_timelock_start()!;\n//       return <NativeScript>{\n//         type: \"after\",\n//         slot: timelockStart.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockExpiry: {\n//       const timelockExpiry = script.as_timelock_expiry()!;\n//       return <NativeScript>{\n//         type: \"before\",\n//         slot: timelockExpiry.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptPubkey: {\n//       const scriptPubkey = script.as_script_pubkey()!;\n//       return <NativeScript>{\n//         type: \"sig\",\n//         keyHash: scriptPubkey.addr_keyhash().to_hex(),\n//       };\n//     }\n//     default:\n//       throw new Error(`Script Kind: ${script.kind()}, is not supported`);\n//   }\n// };",
      "source": "mesh-core-csl",
      "implementation": "export const toUTF8 = (hex: string) =>\n  Buffer.from(hex, \"hex\").toString(\"utf-8\");\n\n/* -----------------[ Lovelace ]----------------- */\n\nexport const fromLovelace = (lovelace: number) => lovelace / 1_000_000;\n\nexport const toLovelace = (ada: number) => ada * 1_000_000;\n\n// /* -----------------[ NativeScript ]----------------- */\n\n// export const fromNativeScript = (script: csl.NativeScript) => {\n//   const fromNativeScripts = (scripts: csl.NativeScripts) => {\n//     const nativeScripts = new Array<NativeScript>();\n\n//     for (let index = 0; index < scripts.len(); index += 1) {\n//       nativeScripts.push(fromNativeScript(scripts.get(index)));\n//     }\n\n//     return nativeScripts;\n//   };\n\n//   switch (script.kind()) {\n//     case csl.NativeScriptKind.ScriptAll: {\n//       const scriptAll = script.as_script_all()!;\n//       return <NativeScript>{\n//         type: \"all\",\n//         scripts: fromNativeScripts(scriptAll.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptAny: {\n//       const scriptAny = script.as_script_any()!;\n//       return <NativeScript>{\n//         type: \"any\",\n//         scripts: fromNativeScripts(scriptAny.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptNOfK: {\n//       const scriptNOfK = script.as_script_n_of_k()!;\n//       return <NativeScript>{\n//         type: \"atLeast\",\n//         required: scriptNOfK.n(),\n//         scripts: fromNativeScripts(scriptNOfK.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockStart: {\n//       const timelockStart = script.as_timelock_start()!;\n//       return <NativeScript>{\n//         type: \"after\",\n//         slot: timelockStart.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockExpiry: {\n//       const timelockExpiry = script.as_timelock_expiry()!;\n//       return <NativeScript>{\n//         type: \"before\",\n//         slot: timelockExpiry.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptPubkey: {\n//       const scriptPubkey = script.as_script_pubkey()!;\n//       return <NativeScript>{\n//         type: \"sig\",\n//         keyHash: scriptPubkey.addr_keyhash().to_hex(),\n//       };\n//     }\n//     default:\n//       throw new Error(`Script Kind: ${script.kind()}, is not supported`);\n//   }\n// };"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.fromLovelace",
      "fullName": "mesh-core-csl:deser.converter.ts.fromLovelace",
      "name": "fromLovelace",
      "signature": "export const fromLovelace = (lovelace: number) => lovelace / 1_000_000;",
      "documentation": "",
      "parameters": [
        {
          "name": "lovelace",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 59,
      "raw": "export const fromLovelace = (lovelace: number) => lovelace / 1_000_000;\n\nexport const toLovelace = (ada: number) => ada * 1_000_000;\n\n// /* -----------------[ NativeScript ]----------------- */\n\n// export const fromNativeScript = (script: csl.NativeScript) => {\n//   const fromNativeScripts = (scripts: csl.NativeScripts) => {\n//     const nativeScripts = new Array<NativeScript>();\n\n//     for (let index = 0; index < scripts.len(); index += 1) {\n//       nativeScripts.push(fromNativeScript(scripts.get(index)));\n//     }\n\n//     return nativeScripts;\n//   };\n\n//   switch (script.kind()) {\n//     case csl.NativeScriptKind.ScriptAll: {\n//       const scriptAll = script.as_script_all()!;\n//       return <NativeScript>{\n//         type: \"all\",\n//         scripts: fromNativeScripts(scriptAll.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptAny: {\n//       const scriptAny = script.as_script_any()!;\n//       return <NativeScript>{\n//         type: \"any\",\n//         scripts: fromNativeScripts(scriptAny.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptNOfK: {\n//       const scriptNOfK = script.as_script_n_of_k()!;\n//       return <NativeScript>{\n//         type: \"atLeast\",\n//         required: scriptNOfK.n(),\n//         scripts: fromNativeScripts(scriptNOfK.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockStart: {\n//       const timelockStart = script.as_timelock_start()!;\n//       return <NativeScript>{\n//         type: \"after\",\n//         slot: timelockStart.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockExpiry: {\n//       const timelockExpiry = script.as_timelock_expiry()!;\n//       return <NativeScript>{\n//         type: \"before\",\n//         slot: timelockExpiry.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptPubkey: {\n//       const scriptPubkey = script.as_script_pubkey()!;\n//       return <NativeScript>{\n//         type: \"sig\",\n//         keyHash: scriptPubkey.addr_keyhash().to_hex(),\n//       };\n//     }\n//     default:\n//       throw new Error(`Script Kind: ${script.kind()}, is not supported`);\n//   }\n// };",
      "source": "mesh-core-csl",
      "implementation": "export const fromLovelace = (lovelace: number) => lovelace / 1_000_000;\n\nexport const toLovelace = (ada: number) => ada * 1_000_000;\n\n// /* -----------------[ NativeScript ]----------------- */\n\n// export const fromNativeScript = (script: csl.NativeScript) => {\n//   const fromNativeScripts = (scripts: csl.NativeScripts) => {\n//     const nativeScripts = new Array<NativeScript>();\n\n//     for (let index = 0; index < scripts.len(); index += 1) {\n//       nativeScripts.push(fromNativeScript(scripts.get(index)));\n//     }\n\n//     return nativeScripts;\n//   };\n\n//   switch (script.kind()) {\n//     case csl.NativeScriptKind.ScriptAll: {\n//       const scriptAll = script.as_script_all()!;\n//       return <NativeScript>{\n//         type: \"all\",\n//         scripts: fromNativeScripts(scriptAll.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptAny: {\n//       const scriptAny = script.as_script_any()!;\n//       return <NativeScript>{\n//         type: \"any\",\n//         scripts: fromNativeScripts(scriptAny.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptNOfK: {\n//       const scriptNOfK = script.as_script_n_of_k()!;\n//       return <NativeScript>{\n//         type: \"atLeast\",\n//         required: scriptNOfK.n(),\n//         scripts: fromNativeScripts(scriptNOfK.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockStart: {\n//       const timelockStart = script.as_timelock_start()!;\n//       return <NativeScript>{\n//         type: \"after\",\n//         slot: timelockStart.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockExpiry: {\n//       const timelockExpiry = script.as_timelock_expiry()!;\n//       return <NativeScript>{\n//         type: \"before\",\n//         slot: timelockExpiry.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptPubkey: {\n//       const scriptPubkey = script.as_script_pubkey()!;\n//       return <NativeScript>{\n//         type: \"sig\",\n//         keyHash: scriptPubkey.addr_keyhash().to_hex(),\n//       };\n//     }\n//     default:\n//       throw new Error(`Script Kind: ${script.kind()}, is not supported`);\n//   }\n// };"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toLovelace",
      "fullName": "mesh-core-csl:deser.converter.ts.toLovelace",
      "name": "toLovelace",
      "signature": "export const toLovelace = (ada: number) => ada * 1_000_000;",
      "documentation": "",
      "parameters": [
        {
          "name": "ada",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 61,
      "raw": "export const toLovelace = (ada: number) => ada * 1_000_000;\n\n// /* -----------------[ NativeScript ]----------------- */\n\n// export const fromNativeScript = (script: csl.NativeScript) => {\n//   const fromNativeScripts = (scripts: csl.NativeScripts) => {\n//     const nativeScripts = new Array<NativeScript>();\n\n//     for (let index = 0; index < scripts.len(); index += 1) {\n//       nativeScripts.push(fromNativeScript(scripts.get(index)));\n//     }\n\n//     return nativeScripts;\n//   };\n\n//   switch (script.kind()) {\n//     case csl.NativeScriptKind.ScriptAll: {\n//       const scriptAll = script.as_script_all()!;\n//       return <NativeScript>{\n//         type: \"all\",\n//         scripts: fromNativeScripts(scriptAll.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptAny: {\n//       const scriptAny = script.as_script_any()!;\n//       return <NativeScript>{\n//         type: \"any\",\n//         scripts: fromNativeScripts(scriptAny.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptNOfK: {\n//       const scriptNOfK = script.as_script_n_of_k()!;\n//       return <NativeScript>{\n//         type: \"atLeast\",\n//         required: scriptNOfK.n(),\n//         scripts: fromNativeScripts(scriptNOfK.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockStart: {\n//       const timelockStart = script.as_timelock_start()!;\n//       return <NativeScript>{\n//         type: \"after\",\n//         slot: timelockStart.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockExpiry: {\n//       const timelockExpiry = script.as_timelock_expiry()!;\n//       return <NativeScript>{\n//         type: \"before\",\n//         slot: timelockExpiry.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptPubkey: {\n//       const scriptPubkey = script.as_script_pubkey()!;\n//       return <NativeScript>{\n//         type: \"sig\",\n//         keyHash: scriptPubkey.addr_keyhash().to_hex(),\n//       };\n//     }\n//     default:\n//       throw new Error(`Script Kind: ${script.kind()}, is not supported`);\n//   }\n// };",
      "source": "mesh-core-csl",
      "implementation": "export const toLovelace = (ada: number) => ada * 1_000_000;\n\n// /* -----------------[ NativeScript ]----------------- */\n\n// export const fromNativeScript = (script: csl.NativeScript) => {\n//   const fromNativeScripts = (scripts: csl.NativeScripts) => {\n//     const nativeScripts = new Array<NativeScript>();\n\n//     for (let index = 0; index < scripts.len(); index += 1) {\n//       nativeScripts.push(fromNativeScript(scripts.get(index)));\n//     }\n\n//     return nativeScripts;\n//   };\n\n//   switch (script.kind()) {\n//     case csl.NativeScriptKind.ScriptAll: {\n//       const scriptAll = script.as_script_all()!;\n//       return <NativeScript>{\n//         type: \"all\",\n//         scripts: fromNativeScripts(scriptAll.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptAny: {\n//       const scriptAny = script.as_script_any()!;\n//       return <NativeScript>{\n//         type: \"any\",\n//         scripts: fromNativeScripts(scriptAny.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptNOfK: {\n//       const scriptNOfK = script.as_script_n_of_k()!;\n//       return <NativeScript>{\n//         type: \"atLeast\",\n//         required: scriptNOfK.n(),\n//         scripts: fromNativeScripts(scriptNOfK.native_scripts()),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockStart: {\n//       const timelockStart = script.as_timelock_start()!;\n//       return <NativeScript>{\n//         type: \"after\",\n//         slot: timelockStart.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.TimelockExpiry: {\n//       const timelockExpiry = script.as_timelock_expiry()!;\n//       return <NativeScript>{\n//         type: \"before\",\n//         slot: timelockExpiry.slot_bignum().to_str(),\n//       };\n//     }\n//     case csl.NativeScriptKind.ScriptPubkey: {\n//       const scriptPubkey = script.as_script_pubkey()!;\n//       return <NativeScript>{\n//         type: \"sig\",\n//         keyHash: scriptPubkey.addr_keyhash().to_hex(),\n//       };\n//     }\n//     default:\n//       throw new Error(`Script Kind: ${script.kind()}, is not supported`);\n//   }\n// };"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toScriptRef",
      "fullName": "mesh-core-csl:deser.converter.ts.toScriptRef",
      "name": "toScriptRef",
      "signature": "export const toScriptRef = (script: PlutusScript | NativeScript) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "script",
          "type": "PlutusScript | NativeScript",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 148,
      "raw": "export const toScriptRef = (script: PlutusScript | NativeScript) => {\n  if (\"code\" in script) {\n    const plutusScript = deserializePlutusScript(script.code, script.version);\n\n    return csl.ScriptRef.new_plutus_script(plutusScript);\n  }\n\n  return csl.ScriptRef.new_native_script(toNativeScript(script));\n};",
      "source": "mesh-core-csl",
      "implementation": "export const toScriptRef = (script: PlutusScript | NativeScript) => {\n  if (\"code\" in script) {\n    const plutusScript = deserializePlutusScript(script.code, script.version);\n\n    return csl.ScriptRef.new_plutus_script(plutusScript);\n  }\n\n  return csl.ScriptRef.new_native_script(toNativeScript(script));\n};"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toPlutusData",
      "fullName": "mesh-core-csl:deser.converter.ts.toPlutusData",
      "name": "toPlutusData",
      "signature": "export const toPlutusData = (data: Data): csl.PlutusData => {",
      "documentation": "",
      "parameters": [
        {
          "name": "data",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "csl.PlutusData",
      "isPublic": true,
      "line": 160,
      "raw": "export const toPlutusData = (data: Data): csl.PlutusData => {\n  const toPlutusList = (dataArray: Data[]) => {\n    const plutusList = csl.PlutusList.new();\n    dataArray.forEach((element) => {\n      plutusList.add(toPlutusData(element));\n    });\n\n    return plutusList;\n  };\n\n  switch (typeof data) {\n    case \"string\":\n      return csl.PlutusData.new_bytes(toBytes(data));\n    case \"number\":\n      return csl.PlutusData.new_integer(csl.BigInt.from_str(data.toString()));\n    case \"bigint\":\n      return csl.PlutusData.new_integer(csl.BigInt.from_str(data.toString()));\n    case \"object\":\n      if (data instanceof Array) {\n        const plutusList = toPlutusList(data);\n        return csl.PlutusData.new_list(plutusList);\n      }\n      if (data instanceof Map) {\n        const plutusMap = csl.PlutusMap.new();\n        data.forEach((value, key) => {\n          const plutusMapValue = csl.PlutusMapValues.new();\n          plutusMapValue.add(toPlutusData(value));\n          plutusMap.insert(toPlutusData(key), plutusMapValue);\n        });\n        return csl.PlutusData.new_map(plutusMap);\n      }\n      return csl.PlutusData.new_constr_plutus_data(\n        csl.ConstrPlutusData.new(\n          csl.BigNum.from_str(data.alternative.toString()),\n          toPlutusList(data.fields),\n        ),\n      );\n  }\n};",
      "source": "mesh-core-csl",
      "implementation": "export const toPlutusData = (data: Data): csl.PlutusData => {\n  const toPlutusList = (dataArray: Data[]) => {\n    const plutusList = csl.PlutusList.new();\n    dataArray.forEach((element) => {\n      plutusList.add(toPlutusData(element));\n    });\n\n    return plutusList;\n  };\n\n  switch (typeof data) {\n    case \"string\":\n      return csl.PlutusData.new_bytes(toBytes(data));\n    case \"number\":\n      return csl.PlutusData.new_integer(csl.BigInt.from_str(data.toString()));\n    case \"bigint\":\n      return csl.PlutusData.new_integer(csl.BigInt.from_str(data.toString()));\n    case \"object\":\n      if (data instanceof Array) {\n        const plutusList = toPlutusList(data);\n        return csl.PlutusData.new_list(plutusList);\n      }\n      if (data instanceof Map) {\n        const plutusMap = csl.PlutusMap.new();\n        data.forEach((value, key) => {\n          const plutusMapValue = csl.PlutusMapValues.new();\n          plutusMapValue.add(toPlutusData(value));\n          plutusMap.insert(toPlutusData(key), plutusMapValue);\n        });\n        return csl.PlutusData.new_map(plutusMap);\n      }\n      return csl.PlutusData.new_constr_plutus_data(\n        csl.ConstrPlutusData.new(\n          csl.BigNum.from_str(data.alternative.toString()),\n          toPlutusList(data.fields),\n        ),\n      );\n  }\n};"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toPlutusList",
      "fullName": "mesh-core-csl:deser.converter.ts.toPlutusList",
      "name": "toPlutusList",
      "signature": "const toPlutusList = (dataArray: Data[]) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "dataArray",
          "type": "Data[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 161,
      "raw": "  const toPlutusList = (dataArray: Data[]) => {\n    const plutusList = csl.PlutusList.new();\n    dataArray.forEach((element) => {\n      plutusList.add(toPlutusData(element));\n    });\n\n    return plutusList;\n  };",
      "source": "mesh-core-csl",
      "implementation": "  const toPlutusList = (dataArray: Data[]) => {\n    const plutusList = csl.PlutusList.new();\n    dataArray.forEach((element) => {\n      plutusList.add(toPlutusData(element));\n    });\n\n    return plutusList;\n  };"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.castRawDataToJsonString",
      "fullName": "mesh-core-csl:deser.converter.ts.castRawDataToJsonString",
      "name": "castRawDataToJsonString",
      "signature": "export const castRawDataToJsonString = (rawData: object | string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "rawData",
          "type": "object | string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 200,
      "raw": "export const castRawDataToJsonString = (rawData: object | string) => {\n  if (typeof rawData === \"object\") {\n    return JSONbig.stringify(rawData);\n  }\n  return rawData as string;\n};",
      "source": "mesh-core-csl",
      "implementation": "export const castRawDataToJsonString = (rawData: object | string) => {\n  if (typeof rawData === \"object\") {\n    return JSONbig.stringify(rawData);\n  }\n  return rawData as string;\n};"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.castDataToPlutusData",
      "fullName": "mesh-core-csl:deser.converter.ts.castDataToPlutusData",
      "name": "castDataToPlutusData",
      "signature": "export const castDataToPlutusData = ({",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 207,
      "raw": "export const castDataToPlutusData = ({\n  type,\n  content,\n}: BuilderData): csl.PlutusData => {\n  if (type === \"Mesh\") {\n    return toPlutusData(content);\n  }\n  if (type === \"CBOR\") {\n    return csl.PlutusData.from_hex(content as string);\n  }\n  return csl.PlutusData.from_json(\n    castRawDataToJsonString(content),\n    csl.PlutusDatumSchema.DetailedSchema,\n  );\n};",
      "source": "mesh-core-csl",
      "implementation": "export const castDataToPlutusData = ({\n  type,\n  content,\n}: BuilderData): csl.PlutusData => {\n  if (type === \"Mesh\") {\n    return toPlutusData(content);\n  }\n  if (type === \"CBOR\") {\n    return csl.PlutusData.from_hex(content as string);\n  }\n  return csl.PlutusData.from_json(\n    castRawDataToJsonString(content),\n    csl.PlutusDatumSchema.DetailedSchema,\n  );\n};"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toNativeScript",
      "fullName": "mesh-core-csl:deser.converter.ts.toNativeScript",
      "name": "toNativeScript",
      "signature": "export const toNativeScript = (script: NativeScript) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "script",
          "type": "NativeScript",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 223,
      "raw": "export const toNativeScript = (script: NativeScript) => {\n  const toNativeScripts = (scripts: NativeScript[]) => {\n    const nativeScripts = csl.NativeScripts.new();\n\n    scripts.forEach((script) => {\n      nativeScripts.add(toNativeScript(script));\n    });\n\n    return nativeScripts;\n  };\n\n  switch (script.type) {\n    case \"all\":\n      return csl.NativeScript.new_script_all(\n        csl.ScriptAll.new(toNativeScripts(script.scripts)),\n      );\n    case \"any\":\n      return csl.NativeScript.new_script_any(\n        csl.ScriptAny.new(toNativeScripts(script.scripts)),\n      );\n    case \"atLeast\":\n      return csl.NativeScript.new_script_n_of_k(\n        csl.ScriptNOfK.new(script.required, toNativeScripts(script.scripts)),\n      );\n    case \"after\":\n      return csl.NativeScript.new_timelock_start(\n        csl.TimelockStart.new_timelockstart(csl.BigNum.from_str(script.slot)),\n      );\n    case \"before\":\n      return csl.NativeScript.new_timelock_expiry(\n        csl.TimelockExpiry.new_timelockexpiry(csl.BigNum.from_str(script.slot)),\n      );\n    case \"sig\":\n      return csl.NativeScript.new_script_pubkey(\n        csl.ScriptPubkey.new(deserializeEd25519KeyHash(script.keyHash)),\n      );\n  }\n};",
      "source": "mesh-core-csl",
      "implementation": "export const toNativeScript = (script: NativeScript) => {\n  const toNativeScripts = (scripts: NativeScript[]) => {\n    const nativeScripts = csl.NativeScripts.new();\n\n    scripts.forEach((script) => {\n      nativeScripts.add(toNativeScript(script));\n    });\n\n    return nativeScripts;\n  };\n\n  switch (script.type) {\n    case \"all\":\n      return csl.NativeScript.new_script_all(\n        csl.ScriptAll.new(toNativeScripts(script.scripts)),\n      );\n    case \"any\":\n      return csl.NativeScript.new_script_any(\n        csl.ScriptAny.new(toNativeScripts(script.scripts)),\n      );\n    case \"atLeast\":\n      return csl.NativeScript.new_script_n_of_k(\n        csl.ScriptNOfK.new(script.required, toNativeScripts(script.scripts)),\n      );\n    case \"after\":\n      return csl.NativeScript.new_timelock_start(\n        csl.TimelockStart.new_timelockstart(csl.BigNum.from_str(script.slot)),\n      );\n    case \"before\":\n      return csl.NativeScript.new_timelock_expiry(\n        csl.TimelockExpiry.new_timelockexpiry(csl.BigNum.from_str(script.slot)),\n      );\n    case \"sig\":\n      return csl.NativeScript.new_script_pubkey(\n        csl.ScriptPubkey.new(deserializeEd25519KeyHash(script.keyHash)),\n      );\n  }\n};"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toNativeScripts",
      "fullName": "mesh-core-csl:deser.converter.ts.toNativeScripts",
      "name": "toNativeScripts",
      "signature": "const toNativeScripts = (scripts: NativeScript[]) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "scripts",
          "type": "NativeScript[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 224,
      "raw": "  const toNativeScripts = (scripts: NativeScript[]) => {\n    const nativeScripts = csl.NativeScripts.new();\n\n    scripts.forEach((script) => {\n      nativeScripts.add(toNativeScript(script));\n    });\n\n    return nativeScripts;\n  };",
      "source": "mesh-core-csl",
      "implementation": "  const toNativeScripts = (scripts: NativeScript[]) => {\n    const nativeScripts = csl.NativeScripts.new();\n\n    scripts.forEach((script) => {\n      nativeScripts.add(toNativeScript(script));\n    });\n\n    return nativeScripts;\n  };"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toCslValue",
      "fullName": "mesh-core-csl:deser.converter.ts.toCslValue",
      "name": "toCslValue",
      "signature": "export const toCslValue = (assets: Asset[]): csl.Value => {",
      "documentation": "",
      "parameters": [
        {
          "name": "assets",
          "type": "Asset[]",
          "optional": false
        }
      ],
      "returnType": "csl.Value",
      "isPublic": true,
      "line": 262,
      "raw": "export const toCslValue = (assets: Asset[]): csl.Value => {\n  let cslValue: csl.Value | undefined = undefined;\n  let multiAsset: csl.MultiAsset = csl.MultiAsset.new();\n  for (const asset of assets) {\n    if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n      cslValue = csl.Value.new(csl.BigNum.from_str(asset.quantity));\n    } else {\n      const policyId = csl.ScriptHash.from_hex(asset.unit.slice(0, 56));\n      const assetName = csl.AssetName.new(\n        Buffer.from(asset.unit.slice(56), \"hex\"),\n      );\n      const quantity = csl.BigNum.from_str(asset.quantity);\n      multiAsset.set_asset(policyId, assetName, quantity);\n    }\n  }\n  if (cslValue !== undefined) {\n    cslValue.set_multiasset(multiAsset);\n  } else {\n    cslValue = csl.Value.new(csl.BigNum.from_str(\"0\"));\n    cslValue.set_multiasset(multiAsset);\n  }\n  return cslValue;\n};",
      "source": "mesh-core-csl",
      "implementation": "export const toCslValue = (assets: Asset[]): csl.Value => {\n  let cslValue: csl.Value | undefined = undefined;\n  let multiAsset: csl.MultiAsset = csl.MultiAsset.new();\n  for (const asset of assets) {\n    if (asset.unit === \"lovelace\" || asset.unit === \"\") {\n      cslValue = csl.Value.new(csl.BigNum.from_str(asset.quantity));\n    } else {\n      const policyId = csl.ScriptHash.from_hex(asset.unit.slice(0, 56));\n      const assetName = csl.AssetName.new(\n        Buffer.from(asset.unit.slice(56), \"hex\"),\n      );\n      const quantity = csl.BigNum.from_str(asset.quantity);\n      multiAsset.set_asset(policyId, assetName, quantity);\n    }\n  }\n  if (cslValue !== undefined) {\n    cslValue.set_multiasset(multiAsset);\n  } else {\n    cslValue = csl.Value.new(csl.BigNum.from_str(\"0\"));\n    cslValue.set_multiasset(multiAsset);\n  }\n  return cslValue;\n};"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeAddress",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeAddress",
      "name": "deserializeAddress",
      "signature": "export const deserializeAddress = (address: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "address",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 8,
      "raw": "export const deserializeAddress = (address: string) =>",
      "source": "mesh-core-csl",
      "implementation": "export const deserializeAddress = (address: string) =>"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeBip32PrivateKey",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeBip32PrivateKey",
      "name": "deserializeBip32PrivateKey",
      "signature": "export const deserializeBip32PrivateKey = (bip32PrivateKey: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "bip32PrivateKey",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 11,
      "raw": "export const deserializeBip32PrivateKey = (bip32PrivateKey: string) =>",
      "source": "mesh-core-csl",
      "implementation": "export const deserializeBip32PrivateKey = (bip32PrivateKey: string) =>"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeDataHash",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeDataHash",
      "name": "deserializeDataHash",
      "signature": "export const deserializeDataHash = (dataHash: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "dataHash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 14,
      "raw": "export const deserializeDataHash = (dataHash: string) =>",
      "source": "mesh-core-csl",
      "implementation": "export const deserializeDataHash = (dataHash: string) =>"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeEd25519KeyHash",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeEd25519KeyHash",
      "name": "deserializeEd25519KeyHash",
      "signature": "export const deserializeEd25519KeyHash = (ed25519KeyHash: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "ed25519KeyHash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 17,
      "raw": "export const deserializeEd25519KeyHash = (ed25519KeyHash: string) =>",
      "source": "mesh-core-csl",
      "implementation": "export const deserializeEd25519KeyHash = (ed25519KeyHash: string) =>"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeEd25519Signature",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeEd25519Signature",
      "name": "deserializeEd25519Signature",
      "signature": "export const deserializeEd25519Signature = (ed25519Signature: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "ed25519Signature",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 20,
      "raw": "export const deserializeEd25519Signature = (ed25519Signature: string) =>",
      "source": "mesh-core-csl",
      "implementation": "export const deserializeEd25519Signature = (ed25519Signature: string) =>"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeNativeScript",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeNativeScript",
      "name": "deserializeNativeScript",
      "signature": "export const deserializeNativeScript = (nativeScript: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "nativeScript",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 23,
      "raw": "export const deserializeNativeScript = (nativeScript: string) =>",
      "source": "mesh-core-csl",
      "implementation": "export const deserializeNativeScript = (nativeScript: string) =>"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializePublicKey",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializePublicKey",
      "name": "deserializePublicKey",
      "signature": "export const deserializePublicKey = (publicKey: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "publicKey",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 26,
      "raw": "export const deserializePublicKey = (publicKey: string) =>",
      "source": "mesh-core-csl",
      "implementation": "export const deserializePublicKey = (publicKey: string) =>"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializePlutusData",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializePlutusData",
      "name": "deserializePlutusData",
      "signature": "export const deserializePlutusData = (plutusData: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "plutusData",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 29,
      "raw": "export const deserializePlutusData = (plutusData: string) =>",
      "source": "mesh-core-csl",
      "implementation": "export const deserializePlutusData = (plutusData: string) =>"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializePlutusScript",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializePlutusScript",
      "name": "deserializePlutusScript",
      "signature": "export const deserializePlutusScript = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 32,
      "raw": "export const deserializePlutusScript = (",
      "source": "mesh-core-csl",
      "implementation": "export const deserializePlutusScript = ("
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeScriptRef",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeScriptRef",
      "name": "deserializeScriptRef",
      "signature": "export const deserializeScriptRef = (scriptRef: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "scriptRef",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 41,
      "raw": "export const deserializeScriptRef = (scriptRef: string) =>",
      "source": "mesh-core-csl",
      "implementation": "export const deserializeScriptRef = (scriptRef: string) =>"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeScriptHash",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeScriptHash",
      "name": "deserializeScriptHash",
      "signature": "export const deserializeScriptHash = (scriptHash: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "scriptHash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 44,
      "raw": "export const deserializeScriptHash = (scriptHash: string) =>",
      "source": "mesh-core-csl",
      "implementation": "export const deserializeScriptHash = (scriptHash: string) =>"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeTx",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeTx",
      "name": "deserializeTx",
      "signature": "export const deserializeTx = (tx: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "tx",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 47,
      "raw": "export const deserializeTx = (tx: string) =>",
      "source": "mesh-core-csl",
      "implementation": "export const deserializeTx = (tx: string) =>"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeTxBody",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeTxBody",
      "name": "deserializeTxBody",
      "signature": "export const deserializeTxBody = (txBody: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "txBody",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 50,
      "raw": "export const deserializeTxBody = (txBody: string) =>",
      "source": "mesh-core-csl",
      "implementation": "export const deserializeTxBody = (txBody: string) =>"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeTxHash",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeTxHash",
      "name": "deserializeTxHash",
      "signature": "export const deserializeTxHash = (txHash: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "txHash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 53,
      "raw": "export const deserializeTxHash = (txHash: string) =>",
      "source": "mesh-core-csl",
      "implementation": "export const deserializeTxHash = (txHash: string) =>"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeTxUnspentOutput",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeTxUnspentOutput",
      "name": "deserializeTxUnspentOutput",
      "signature": "export const deserializeTxUnspentOutput = (txUnspentOutput: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "txUnspentOutput",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 56,
      "raw": "export const deserializeTxUnspentOutput = (txUnspentOutput: string) =>",
      "source": "mesh-core-csl",
      "implementation": "export const deserializeTxUnspentOutput = (txUnspentOutput: string) =>"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeTxWitnessSet",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeTxWitnessSet",
      "name": "deserializeTxWitnessSet",
      "signature": "export const deserializeTxWitnessSet = (txWitnessSet: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "txWitnessSet",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 59,
      "raw": "export const deserializeTxWitnessSet = (txWitnessSet: string) =>",
      "source": "mesh-core-csl",
      "implementation": "export const deserializeTxWitnessSet = (txWitnessSet: string) =>"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeValue",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeValue",
      "name": "deserializeValue",
      "signature": "export const deserializeValue = (value: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "value",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 62,
      "raw": "export const deserializeValue = (value: string) =>",
      "source": "mesh-core-csl",
      "implementation": "export const deserializeValue = (value: string) =>"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolveStakeKeyHash",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolveStakeKeyHash",
      "name": "resolveStakeKeyHash",
      "signature": "export const resolveStakeKeyHash = (bech32: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "bech32",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 22,
      "raw": "export const resolveStakeKeyHash = (bech32: string) => {\n  try {\n    const stakeKeyHash = [\n      toBaseAddress(bech32)?.stake_cred().to_keyhash(),\n      toRewardAddress(bech32)?.payment_cred().to_keyhash(),\n    ].find((kh) => kh !== undefined);\n\n    if (stakeKeyHash !== undefined) return stakeKeyHash.to_hex();\n\n    throw new Error(`Couldn't resolve stake key hash from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveStakeKeyHash: ${error}.`);\n  }\n};",
      "source": "mesh-core-csl",
      "implementation": "export const resolveStakeKeyHash = (bech32: string) => {\n  try {\n    const stakeKeyHash = [\n      toBaseAddress(bech32)?.stake_cred().to_keyhash(),\n      toRewardAddress(bech32)?.payment_cred().to_keyhash(),\n    ].find((kh) => kh !== undefined);\n\n    if (stakeKeyHash !== undefined) return stakeKeyHash.to_hex();\n\n    throw new Error(`Couldn't resolve stake key hash from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveStakeKeyHash: ${error}.`);\n  }\n};"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolvePrivateKey",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolvePrivateKey",
      "name": "resolvePrivateKey",
      "signature": "export const resolvePrivateKey = (words: string[]) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "words",
          "type": "string[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 37,
      "raw": "export const resolvePrivateKey = (words: string[]) => {\n  const buildBip32PrivateKey = (\n    entropy: string,\n    password = \"\",\n  ): csl.Bip32PrivateKey => {\n    return csl.Bip32PrivateKey.from_bip39_entropy(\n      toBytes(entropy),\n      toBytes(fromUTF8(password)),\n    );\n  };\n\n  const entropy = mnemonicToEntropy(words.join(\" \"));\n  const bip32PrivateKey = buildBip32PrivateKey(entropy);\n  const bech32PrivateKey = bip32PrivateKey.to_bech32();\n\n  bip32PrivateKey.free();\n\n  return bech32PrivateKey;\n};",
      "source": "mesh-core-csl",
      "implementation": "export const resolvePrivateKey = (words: string[]) => {\n  const buildBip32PrivateKey = (\n    entropy: string,\n    password = \"\",\n  ): csl.Bip32PrivateKey => {\n    return csl.Bip32PrivateKey.from_bip39_entropy(\n      toBytes(entropy),\n      toBytes(fromUTF8(password)),\n    );\n  };\n\n  const entropy = mnemonicToEntropy(words.join(\" \"));\n  const bip32PrivateKey = buildBip32PrivateKey(entropy);\n  const bech32PrivateKey = bip32PrivateKey.to_bech32();\n\n  bip32PrivateKey.free();\n\n  return bech32PrivateKey;\n};"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.buildBip32PrivateKey",
      "fullName": "mesh-core-csl:deser.resolver.ts.buildBip32PrivateKey",
      "name": "buildBip32PrivateKey",
      "signature": "const buildBip32PrivateKey = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 38,
      "raw": "  const buildBip32PrivateKey = (\n    entropy: string,\n    password = \"\",\n  ): csl.Bip32PrivateKey => {\n    return csl.Bip32PrivateKey.from_bip39_entropy(\n      toBytes(entropy),\n      toBytes(fromUTF8(password)),\n    );\n  };",
      "source": "mesh-core-csl",
      "implementation": "  const buildBip32PrivateKey = (\n    entropy: string,\n    password = \"\",\n  ): csl.Bip32PrivateKey => {\n    return csl.Bip32PrivateKey.from_bip39_entropy(\n      toBytes(entropy),\n      toBytes(fromUTF8(password)),\n    );\n  };"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolveNativeScriptAddress",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolveNativeScriptAddress",
      "name": "resolveNativeScriptAddress",
      "signature": "export const resolveNativeScriptAddress = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 57,
      "raw": "export const resolveNativeScriptAddress = (\n  script: NativeScript,\n  networkId = 0,\n) => {\n  const nativeScript = toNativeScript(script);\n\n  const enterpriseAddress = csl.EnterpriseAddress.new(\n    networkId,\n    csl.Credential.from_scripthash(nativeScript.hash()),\n  );\n\n  return enterpriseAddress.to_address().to_bech32();\n};",
      "source": "mesh-core-csl",
      "implementation": "export const resolveNativeScriptAddress = (\n  script: NativeScript,\n  networkId = 0,\n) => {\n  const nativeScript = toNativeScript(script);\n\n  const enterpriseAddress = csl.EnterpriseAddress.new(\n    networkId,\n    csl.Credential.from_scripthash(nativeScript.hash()),\n  );\n\n  return enterpriseAddress.to_address().to_bech32();\n};"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolvePlutusScriptAddress",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolvePlutusScriptAddress",
      "name": "resolvePlutusScriptAddress",
      "signature": "export const resolvePlutusScriptAddress = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 71,
      "raw": "export const resolvePlutusScriptAddress = (\n  script: PlutusScript,\n  networkId = 0,\n) => {\n  const plutusScript = deserializePlutusScript(script.code, script.version);\n\n  const enterpriseAddress = csl.EnterpriseAddress.new(\n    networkId,\n    csl.Credential.from_scripthash(plutusScript.hash()),\n  );\n\n  return enterpriseAddress.to_address().to_bech32();\n};",
      "source": "mesh-core-csl",
      "implementation": "export const resolvePlutusScriptAddress = (\n  script: PlutusScript,\n  networkId = 0,\n) => {\n  const plutusScript = deserializePlutusScript(script.code, script.version);\n\n  const enterpriseAddress = csl.EnterpriseAddress.new(\n    networkId,\n    csl.Credential.from_scripthash(plutusScript.hash()),\n  );\n\n  return enterpriseAddress.to_address().to_bech32();\n};"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolveNativeScriptHash",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolveNativeScriptHash",
      "name": "resolveNativeScriptHash",
      "signature": "export const resolveNativeScriptHash = (script: NativeScript) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "script",
          "type": "NativeScript",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 85,
      "raw": "export const resolveNativeScriptHash = (script: NativeScript) => {\n  return toNativeScript(script).hash().to_hex();\n};",
      "source": "mesh-core-csl",
      "implementation": "export const resolveNativeScriptHash = (script: NativeScript) => {\n  return toNativeScript(script).hash().to_hex();\n};"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolveScriptHashDRepId",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolveScriptHashDRepId",
      "name": "resolveScriptHashDRepId",
      "signature": "export const resolveScriptHashDRepId = (scriptHash: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "scriptHash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 89,
      "raw": "export const resolveScriptHashDRepId = (scriptHash: string) => {\n  return csl.DRep.new_script_hash(\n    csl.ScriptHash.from_hex(scriptHash),\n  ).to_bech32(true);\n};",
      "source": "mesh-core-csl",
      "implementation": "export const resolveScriptHashDRepId = (scriptHash: string) => {\n  return csl.DRep.new_script_hash(\n    csl.ScriptHash.from_hex(scriptHash),\n  ).to_bech32(true);\n};"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolveRewardAddress",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolveRewardAddress",
      "name": "resolveRewardAddress",
      "signature": "export const resolveRewardAddress = (bech32: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "bech32",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 95,
      "raw": "export const resolveRewardAddress = (bech32: string) => {\n  const buildRewardAddress = (\n    networkId: number,\n    stakeKeyHash: csl.Ed25519KeyHash,\n  ): csl.RewardAddress => {\n    return csl.RewardAddress.new(\n      networkId,\n      csl.Credential.from_keyhash(stakeKeyHash),\n    );\n  };\n\n  try {\n    const address = toAddress(bech32);\n    const baseAddress = toBaseAddress(bech32);\n    const stakeKeyHash = baseAddress?.stake_cred().to_keyhash();\n\n    if (stakeKeyHash !== undefined)\n      return buildRewardAddress(address.network_id(), stakeKeyHash)\n        .to_address()\n        .to_bech32();\n\n    throw new Error(`Couldn't resolve reward address from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveRewardAddress: ${error}.`);\n  }\n};",
      "source": "mesh-core-csl",
      "implementation": "export const resolveRewardAddress = (bech32: string) => {\n  const buildRewardAddress = (\n    networkId: number,\n    stakeKeyHash: csl.Ed25519KeyHash,\n  ): csl.RewardAddress => {\n    return csl.RewardAddress.new(\n      networkId,\n      csl.Credential.from_keyhash(stakeKeyHash),\n    );\n  };\n\n  try {\n    const address = toAddress(bech32);\n    const baseAddress = toBaseAddress(bech32);\n    const stakeKeyHash = baseAddress?.stake_cred().to_keyhash();\n\n    if (stakeKeyHash !== undefined)\n      return buildRewardAddress(address.network_id(), stakeKeyHash)\n        .to_address()\n        .to_bech32();\n\n    throw new Error(`Couldn't resolve reward address from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveRewardAddress: ${error}.`);\n  }\n};"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.buildRewardAddress",
      "fullName": "mesh-core-csl:deser.resolver.ts.buildRewardAddress",
      "name": "buildRewardAddress",
      "signature": "const buildRewardAddress = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 96,
      "raw": "  const buildRewardAddress = (\n    networkId: number,\n    stakeKeyHash: csl.Ed25519KeyHash,\n  ): csl.RewardAddress => {\n    return csl.RewardAddress.new(\n      networkId,\n      csl.Credential.from_keyhash(stakeKeyHash),\n    );\n  };",
      "source": "mesh-core-csl",
      "implementation": "  const buildRewardAddress = (\n    networkId: number,\n    stakeKeyHash: csl.Ed25519KeyHash,\n  ): csl.RewardAddress => {\n    return csl.RewardAddress.new(\n      networkId,\n      csl.Credential.from_keyhash(stakeKeyHash),\n    );\n  };"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolveDataHash",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolveDataHash",
      "name": "resolveDataHash",
      "signature": "export const resolveDataHash = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 122,
      "raw": "export const resolveDataHash = (\n  rawData: BuilderData[\"content\"],\n  type: PlutusDataType = \"Mesh\",\n) => {\n  const plutusData = castDataToPlutusData({\n    content: rawData,\n    type,\n  } as BuilderData);\n  const dataHash = csl.hash_plutus_data(plutusData);\n  return dataHash.to_hex();\n};",
      "source": "mesh-core-csl",
      "implementation": "export const resolveDataHash = (\n  rawData: BuilderData[\"content\"],\n  type: PlutusDataType = \"Mesh\",\n) => {\n  const plutusData = castDataToPlutusData({\n    content: rawData,\n    type,\n  } as BuilderData);\n  const dataHash = csl.hash_plutus_data(plutusData);\n  return dataHash.to_hex();\n};"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolveNativeScriptHex",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolveNativeScriptHex",
      "name": "resolveNativeScriptHex",
      "signature": "export const resolveNativeScriptHex = (script: NativeScript) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "script",
          "type": "NativeScript",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 134,
      "raw": "export const resolveNativeScriptHex = (script: NativeScript) => {\n  return toNativeScript(script).to_hex();\n};",
      "source": "mesh-core-csl",
      "implementation": "export const resolveNativeScriptHex = (script: NativeScript) => {\n  return toNativeScript(script).to_hex();\n};"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.serializePoolId",
      "fullName": "mesh-core-csl:deser.resolver.ts.serializePoolId",
      "name": "serializePoolId",
      "signature": "export const serializePoolId = (hash: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "hash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 138,
      "raw": "export const serializePoolId = (hash: string) => {\n  return csl.Ed25519KeyHash.from_hex(hash).to_bech32(\"pool1\");\n};",
      "source": "mesh-core-csl",
      "implementation": "export const serializePoolId = (hash: string) => {\n  return csl.Ed25519KeyHash.from_hex(hash).to_bech32(\"pool1\");\n};"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolveScriptRef",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolveScriptRef",
      "name": "resolveScriptRef",
      "signature": "export const resolveScriptRef = (script: PlutusScript | NativeScript) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "script",
          "type": "PlutusScript | NativeScript",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 142,
      "raw": "export const resolveScriptRef = (script: PlutusScript | NativeScript) => {\n  return toScriptRef(script).to_hex();\n};",
      "source": "mesh-core-csl",
      "implementation": "export const resolveScriptRef = (script: PlutusScript | NativeScript) => {\n  return toScriptRef(script).to_hex();\n};"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolveEd25519KeyHash",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolveEd25519KeyHash",
      "name": "resolveEd25519KeyHash",
      "signature": "export const resolveEd25519KeyHash = (bech32: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "bech32",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 146,
      "raw": "export const resolveEd25519KeyHash = (bech32: string) => {\n  return csl.Ed25519KeyHash.from_bech32(bech32).to_hex();\n};",
      "source": "mesh-core-csl",
      "implementation": "export const resolveEd25519KeyHash = (bech32: string) => {\n  return csl.Ed25519KeyHash.from_bech32(bech32).to_hex();\n};"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.serialzeAddress",
      "fullName": "mesh-core-csl:utils.address.ts.serialzeAddress",
      "name": "serialzeAddress",
      "signature": "export const serialzeAddress = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 12,
      "raw": "export const serialzeAddress = (\n  deserializedAddress: Partial<DeserializedAddress>,\n  networkId = 0,\n) => {\n  const {\n    pubKeyHash,\n    scriptHash,\n    stakeCredentialHash,\n    stakeScriptCredentialHash,\n  } = deserializedAddress;\n\n  const isPaymentScript = !pubKeyHash;\n  const isStakeScript = !stakeCredentialHash;\n\n  const paymentHash = isPaymentScript ? scriptHash : pubKeyHash;\n\n  const stakeHash = isStakeScript\n    ? stakeScriptCredentialHash\n    : stakeCredentialHash;\n\n  if (!paymentHash)\n    throw new Error(\n      \"Error: serializeAddress: Address must contain a payment part\",\n    );\n\n  const addressObj = isPaymentScript\n    ? scriptAddress(paymentHash, stakeHash, isStakeScript)\n    : pubKeyAddress(paymentHash, stakeHash, isStakeScript);\n  return serializeAddressObj(addressObj, networkId);\n};",
      "source": "mesh-core-csl",
      "implementation": "export const serialzeAddress = (\n  deserializedAddress: Partial<DeserializedAddress>,\n  networkId = 0,\n) => {\n  const {\n    pubKeyHash,\n    scriptHash,\n    stakeCredentialHash,\n    stakeScriptCredentialHash,\n  } = deserializedAddress;\n\n  const isPaymentScript = !pubKeyHash;\n  const isStakeScript = !stakeCredentialHash;\n\n  const paymentHash = isPaymentScript ? scriptHash : pubKeyHash;\n\n  const stakeHash = isStakeScript\n    ? stakeScriptCredentialHash\n    : stakeCredentialHash;\n\n  if (!paymentHash)\n    throw new Error(\n      \"Error: serializeAddress: Address must contain a payment part\",\n    );\n\n  const addressObj = isPaymentScript\n    ? scriptAddress(paymentHash, stakeHash, isStakeScript)\n    : pubKeyAddress(paymentHash, stakeHash, isStakeScript);\n  return serializeAddressObj(addressObj, networkId);\n};"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.addrBech32ToPlutusDataHex",
      "fullName": "mesh-core-csl:utils.address.ts.addrBech32ToPlutusDataHex",
      "name": "addrBech32ToPlutusDataHex",
      "signature": "export const addrBech32ToPlutusDataHex = (bech32: string): string => {",
      "documentation": "",
      "parameters": [
        {
          "name": "bech32",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 43,
      "raw": "export const addrBech32ToPlutusDataHex = (bech32: string): string => {\n  const hexAddress = csl.Address.from_bech32(bech32).to_hex();\n  const cslAddress = csl.Address.from_hex(hexAddress);\n  const hex = csl.PlutusData.from_address(cslAddress).to_hex();\n  return hex;\n};",
      "source": "mesh-core-csl",
      "implementation": "export const addrBech32ToPlutusDataHex = (bech32: string): string => {\n  const hexAddress = csl.Address.from_bech32(bech32).to_hex();\n  const cslAddress = csl.Address.from_hex(hexAddress);\n  const hex = csl.PlutusData.from_address(cslAddress).to_hex();\n  return hex;\n};"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.serializeAddressObj",
      "fullName": "mesh-core-csl:utils.address.ts.serializeAddressObj",
      "name": "serializeAddressObj",
      "signature": "export const serializeAddressObj = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 57,
      "raw": "export const serializeAddressObj = (\n  plutusDataAddressObject: PubKeyAddress | ScriptAddress,\n  networkId = 0,\n) => {\n  const bech32Addr = csl.parse_plutus_address_obj_to_bech32(\n    JSON.stringify(plutusDataAddressObject),\n    networkId,\n  );\n  return bech32Addr;\n};",
      "source": "mesh-core-csl",
      "implementation": "export const serializeAddressObj = (\n  plutusDataAddressObject: PubKeyAddress | ScriptAddress,\n  networkId = 0,\n) => {\n  const bech32Addr = csl.parse_plutus_address_obj_to_bech32(\n    JSON.stringify(plutusDataAddressObject),\n    networkId,\n  );\n  return bech32Addr;\n};"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.serializePlutusAddressToBech32",
      "fullName": "mesh-core-csl:utils.address.ts.serializePlutusAddressToBech32",
      "name": "serializePlutusAddressToBech32",
      "signature": "export const serializePlutusAddressToBech32 = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 68,
      "raw": "export const serializePlutusAddressToBech32 = (\n  plutusHex: string,\n  networkId = 0,\n) => {\n  const cslPlutusDataAddress = csl.PlutusData.from_hex(plutusHex);\n  const plutusDataAddressObject = JSON.parse(\n    cslPlutusDataAddress.to_json(csl.PlutusDatumSchema.DetailedSchema),\n  );\n  return serializeAddressObj(plutusDataAddressObject, networkId);\n};",
      "source": "mesh-core-csl",
      "implementation": "export const serializePlutusAddressToBech32 = (\n  plutusHex: string,\n  networkId = 0,\n) => {\n  const cslPlutusDataAddress = csl.PlutusData.from_hex(plutusHex);\n  const plutusDataAddressObject = JSON.parse(\n    cslPlutusDataAddress.to_json(csl.PlutusDatumSchema.DetailedSchema),\n  );\n  return serializeAddressObj(plutusDataAddressObject, networkId);\n};"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.deserializeBech32Address",
      "fullName": "mesh-core-csl:utils.address.ts.deserializeBech32Address",
      "name": "deserializeBech32Address",
      "signature": "export const deserializeBech32Address = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 79,
      "raw": "export const deserializeBech32Address = (\n  bech32Addr: string,\n): DeserializedAddress => {\n  const deserializedAddress = csl.deserialize_bech32_address(bech32Addr);\n  return {\n    pubKeyHash: deserializedAddress.get_pub_key_hash(),\n    scriptHash: deserializedAddress.get_script_hash(),\n    stakeCredentialHash: deserializedAddress.get_stake_key_hash(),\n    stakeScriptCredentialHash: deserializedAddress.get_stake_key_script_hash(),\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "export const deserializeBech32Address = (\n  bech32Addr: string,\n): DeserializedAddress => {\n  const deserializedAddress = csl.deserialize_bech32_address(bech32Addr);\n  return {\n    pubKeyHash: deserializedAddress.get_pub_key_hash(),\n    scriptHash: deserializedAddress.get_script_hash(),\n    stakeCredentialHash: deserializedAddress.get_stake_key_hash(),\n    stakeScriptCredentialHash: deserializedAddress.get_stake_key_script_hash(),\n  };\n};"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.scriptHashToBech32",
      "fullName": "mesh-core-csl:utils.address.ts.scriptHashToBech32",
      "name": "scriptHashToBech32",
      "signature": "export const scriptHashToBech32 = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 91,
      "raw": "export const scriptHashToBech32 = (",
      "source": "mesh-core-csl",
      "implementation": "export const scriptHashToBech32 = ("
    },
    {
      "key": "mesh-core-csl:utils.address.ts.v2ScriptToBech32",
      "fullName": "mesh-core-csl:utils.address.ts.v2ScriptToBech32",
      "name": "v2ScriptToBech32",
      "signature": "export const v2ScriptToBech32 = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 104,
      "raw": "export const v2ScriptToBech32 = (",
      "source": "mesh-core-csl",
      "implementation": "export const v2ScriptToBech32 = ("
    },
    {
      "key": "mesh-core-csl:utils.aiken.ts.applyParamsToScript",
      "fullName": "mesh-core-csl:utils.aiken.ts.applyParamsToScript",
      "name": "applyParamsToScript",
      "signature": "export const applyParamsToScript = (",
      "documentation": "/**\n * Apply parameters to a given script blueprint.\n *\n * @param rawScript - The raw script CborHex from blueprint.\n * @param params - The parameters to apply, in an array.\n * @param type - The type of the parameters, default to be Mesh's Data type. It could also be in JSON and raw CBOR.\n * @returns The double-cbor encoded script CborHex with the parameters applied.\n */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 13,
      "raw": "/**\n * Apply parameters to a given script blueprint.\n *\n * @param rawScript - The raw script CborHex from blueprint.\n * @param params - The parameters to apply, in an array.\n * @param type - The type of the parameters, default to be Mesh's Data type. It could also be in JSON and raw CBOR.\n * @returns The double-cbor encoded script CborHex with the parameters applied.\n */\nexport const applyParamsToScript = (\n  rawScript: string,\n  params: object[] | Data[],\n  type: PlutusDataType = \"Mesh\",\n): string => {\n  const cslParams = csl.JsVecString.new();\n  let paramType = \"cbor\";\n\n  switch (type) {\n    case \"JSON\":\n      paramType = \"json\";\n      params.forEach((param) => {\n        if (typeof param === \"object\") {\n          cslParams.add(JSON.stringify(param));\n        } else if (typeof param === \"string\") {\n          cslParams.add(param);\n        }\n      });\n      break;\n\n    case \"Mesh\":\n      params.forEach((param) => {\n        const paramCbor = toPlutusData(param as Data);\n        cslParams.add(paramCbor.to_hex());\n      });\n      break;\n\n    default:\n      params.forEach((param) => {\n        cslParams.add(param as string);\n      });\n      break;\n  }\n\n  return csl.js_apply_params_to_script(rawScript, cslParams, paramType);\n};",
      "source": "mesh-core-csl",
      "implementation": "export const applyParamsToScript = (\n  rawScript: string,\n  params: object[] | Data[],\n  type: PlutusDataType = \"Mesh\",\n): string => {\n  const cslParams = csl.JsVecString.new();\n  let paramType = \"cbor\";\n\n  switch (type) {\n    case \"JSON\":\n      paramType = \"json\";\n      params.forEach((param) => {\n        if (typeof param === \"object\") {\n          cslParams.add(JSON.stringify(param));\n        } else if (typeof param === \"string\") {\n          cslParams.add(param);\n        }\n      });\n      break;\n\n    case \"Mesh\":\n      params.forEach((param) => {\n        const paramCbor = toPlutusData(param as Data);\n        cslParams.add(paramCbor.to_hex());\n      });\n      break;\n\n    default:\n      params.forEach((param) => {\n        cslParams.add(param as string);\n      });\n      break;\n  }\n\n  return csl.js_apply_params_to_script(rawScript, cslParams, paramType);\n};"
    },
    {
      "key": "mesh-core-csl:utils.aiken.ts.applyCborEncoding",
      "fullName": "mesh-core-csl:utils.aiken.ts.applyCborEncoding",
      "name": "applyCborEncoding",
      "signature": "export const applyCborEncoding = (rawScript: string): string => {",
      "documentation": "/**\n * Apply Cbor encoding.\n *\n * @param rawScript - The raw script CborHex from blueprint.\n * @returns The double-cbor encoded script CborHex.\n */",
      "parameters": [
        {
          "name": "rawScript",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 56,
      "raw": "/**\n * Apply Cbor encoding.\n *\n * @param rawScript - The raw script CborHex from blueprint.\n * @returns The double-cbor encoded script CborHex.\n */\nexport const applyCborEncoding = (rawScript: string): string => {\n  return csl.js_apply_params_to_script(\n    rawScript,\n    csl.JsVecString.new(),\n    \"cbor\",\n  );\n};",
      "source": "mesh-core-csl",
      "implementation": "export const applyCborEncoding = (rawScript: string): string => {\n  return csl.js_apply_params_to_script(\n    rawScript,\n    csl.JsVecString.new(),\n    \"cbor\",\n  );\n};"
    },
    {
      "key": "mesh-core-csl:utils.credentials.ts.skeyToPubKeyHash",
      "fullName": "mesh-core-csl:utils.credentials.ts.skeyToPubKeyHash",
      "name": "skeyToPubKeyHash",
      "signature": "export const skeyToPubKeyHash = (skeyHex: string): string => {",
      "documentation": "",
      "parameters": [
        {
          "name": "skeyHex",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 3,
      "raw": "export const skeyToPubKeyHash = (skeyHex: string): string => {\n  const isHexUnclean = skeyHex.slice(0, 4) === \"5820\" && skeyHex.length === 68;\n  const cleanHex = isHexUnclean ? skeyHex.slice(4) : skeyHex;\n  return csl.PrivateKey.from_hex(cleanHex).to_public().hash().to_hex();\n};",
      "source": "mesh-core-csl",
      "implementation": "export const skeyToPubKeyHash = (skeyHex: string): string => {\n  const isHexUnclean = skeyHex.slice(0, 4) === \"5820\" && skeyHex.length === 68;\n  const cleanHex = isHexUnclean ? skeyHex.slice(4) : skeyHex;\n  return csl.PrivateKey.from_hex(cleanHex).to_public().hash().to_hex();\n};"
    },
    {
      "key": "mesh-core-csl:utils.drep.ts.getDRepIds",
      "fullName": "mesh-core-csl:utils.drep.ts.getDRepIds",
      "name": "getDRepIds",
      "signature": "export const getDRepIds = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 5,
      "raw": "export const getDRepIds = (\n  dRepId: string,\n): {\n  cip105: string;\n  cip129: string;\n} => {\n  const cslDrep = csl.DRep.from_bech32(dRepId);\n  let result = {\n    cip105: cslDrep.to_bech32(false),\n    cip129: cslDrep.to_bech32(true),\n  };\n  return result;\n};",
      "source": "mesh-core-csl",
      "implementation": "export const getDRepIds = (\n  dRepId: string,\n): {\n  cip105: string;\n  cip129: string;\n} => {\n  const cslDrep = csl.DRep.from_bech32(dRepId);\n  let result = {\n    cip105: cslDrep.to_bech32(false),\n    cip129: cslDrep.to_bech32(true),\n  };\n  return result;\n};"
    },
    {
      "key": "mesh-core-csl:utils.scripts.ts.getV2ScriptHash",
      "fullName": "mesh-core-csl:utils.scripts.ts.getV2ScriptHash",
      "name": "getV2ScriptHash",
      "signature": "export const getV2ScriptHash = (script: string): string =>",
      "documentation": "",
      "parameters": [
        {
          "name": "script",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 3,
      "raw": "export const getV2ScriptHash = (script: string): string =>",
      "source": "mesh-core-csl",
      "implementation": "export const getV2ScriptHash = (script: string): string =>"
    },
    {
      "key": "mesh-core-csl:utils.staking.ts.poolIdHexToBech32",
      "fullName": "mesh-core-csl:utils.staking.ts.poolIdHexToBech32",
      "name": "poolIdHexToBech32",
      "signature": "export const poolIdHexToBech32 = (poolIdHash: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "poolIdHash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 3,
      "raw": "export const poolIdHexToBech32 = (poolIdHash: string) => {\n  const cslPoolIdHash = csl.Ed25519KeyHash.from_hex(poolIdHash);\n  return cslPoolIdHash.to_bech32(\"pool\");\n};",
      "source": "mesh-core-csl",
      "implementation": "export const poolIdHexToBech32 = (poolIdHash: string) => {\n  const cslPoolIdHash = csl.Ed25519KeyHash.from_hex(poolIdHash);\n  return cslPoolIdHash.to_bech32(\"pool\");\n};"
    },
    {
      "key": "mesh-core-csl:utils.staking.ts.poolIdBech32ToHex",
      "fullName": "mesh-core-csl:utils.staking.ts.poolIdBech32ToHex",
      "name": "poolIdBech32ToHex",
      "signature": "export const poolIdBech32ToHex = (poolIdBech32: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "poolIdBech32",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 8,
      "raw": "export const poolIdBech32ToHex = (poolIdBech32: string) => {\n  const cslPoolIdHash = csl.Ed25519KeyHash.from_bech32(poolIdBech32);\n  return Buffer.from(cslPoolIdHash.to_bytes()).toString(\"hex\");\n};",
      "source": "mesh-core-csl",
      "implementation": "export const poolIdBech32ToHex = (poolIdBech32: string) => {\n  const cslPoolIdHash = csl.Ed25519KeyHash.from_bech32(poolIdBech32);\n  return Buffer.from(cslPoolIdHash.to_bytes()).toString(\"hex\");\n};"
    },
    {
      "key": "mesh-core-csl:utils.staking.ts.baseAddressToStakeAddress",
      "fullName": "mesh-core-csl:utils.staking.ts.baseAddressToStakeAddress",
      "name": "baseAddressToStakeAddress",
      "signature": "export const baseAddressToStakeAddress = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 13,
      "raw": "export const baseAddressToStakeAddress = (\n  baseAddressBech32: string,\n  network = 1,\n) => {\n  const networkId =\n    network === 1\n      ? csl.NetworkId.mainnet().kind()\n      : csl.NetworkId.testnet().kind();\n  const stakeCred = csl.BaseAddress.from_address(\n    csl.Address.from_bech32(baseAddressBech32),\n  )?.stake_cred();\n  if (stakeCred) {\n    const stakeAddress = csl.RewardAddress.new(networkId, stakeCred)\n      .to_address()\n      .to_bech32();\n    return stakeAddress;\n  }\n  return \"\";\n};",
      "source": "mesh-core-csl",
      "implementation": "export const baseAddressToStakeAddress = (\n  baseAddressBech32: string,\n  network = 1,\n) => {\n  const networkId =\n    network === 1\n      ? csl.NetworkId.mainnet().kind()\n      : csl.NetworkId.testnet().kind();\n  const stakeCred = csl.BaseAddress.from_address(\n    csl.Address.from_bech32(baseAddressBech32),\n  )?.stake_cred();\n  if (stakeCred) {\n    const stakeAddress = csl.RewardAddress.new(networkId, stakeCred)\n      .to_address()\n      .to_bech32();\n    return stakeAddress;\n  }\n  return \"\";\n};"
    },
    {
      "key": "mesh-core-csl:utils.staking.ts.rewardAddressToKeyHash",
      "fullName": "mesh-core-csl:utils.staking.ts.rewardAddressToKeyHash",
      "name": "rewardAddressToKeyHash",
      "signature": "export const rewardAddressToKeyHash = (rewardBech32: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "rewardBech32",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 33,
      "raw": "export const rewardAddressToKeyHash = (rewardBech32: string) => {\n  return toRewardAddress(rewardBech32)?.payment_cred().to_keyhash()?.to_hex();\n};",
      "source": "mesh-core-csl",
      "implementation": "export const rewardAddressToKeyHash = (rewardBech32: string) => {\n  return toRewardAddress(rewardBech32)?.payment_cred().to_keyhash()?.to_hex();\n};"
    },
    {
      "key": "mesh-core-csl:utils.staking.ts.scriptHashToRewardAddress",
      "fullName": "mesh-core-csl:utils.staking.ts.scriptHashToRewardAddress",
      "name": "scriptHashToRewardAddress",
      "signature": "export const scriptHashToRewardAddress = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 37,
      "raw": "export const scriptHashToRewardAddress = (\n  scriptHashHex: string,\n  network = 1,\n) => {\n  const networkId =\n    network === 1\n      ? csl.NetworkId.mainnet().kind()\n      : csl.NetworkId.testnet().kind();\n  const scriptHash = csl.ScriptHash.from_hex(scriptHashHex);\n  const credential = csl.Credential.from_scripthash(scriptHash);\n  const rewardAddress = csl.RewardAddress.new(networkId, credential)\n    .to_address()\n    .to_bech32();\n  return rewardAddress;\n};",
      "source": "mesh-core-csl",
      "implementation": "export const scriptHashToRewardAddress = (\n  scriptHashHex: string,\n  network = 1,\n) => {\n  const networkId =\n    network === 1\n      ? csl.NetworkId.mainnet().kind()\n      : csl.NetworkId.testnet().kind();\n  const scriptHash = csl.ScriptHash.from_hex(scriptHashHex);\n  const credential = csl.Credential.from_scripthash(scriptHash);\n  const rewardAddress = csl.RewardAddress.new(networkId, credential)\n    .to_address()\n    .to_bech32();\n  return rewardAddress;\n};"
    },
    {
      "key": "mesh-core-csl:utils.staking.ts.keyHashToRewardAddress",
      "fullName": "mesh-core-csl:utils.staking.ts.keyHashToRewardAddress",
      "name": "keyHashToRewardAddress",
      "signature": "export const keyHashToRewardAddress = (keyHashHex: string, network = 1) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "keyHashHex",
          "type": "string",
          "optional": false
        },
        {
          "name": "network",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 53,
      "raw": "export const keyHashToRewardAddress = (keyHashHex: string, network = 1) => {\n  const networkId =\n    network === 1\n      ? csl.NetworkId.mainnet().kind()\n      : csl.NetworkId.testnet().kind();\n  const keyHash = csl.Ed25519KeyHash.from_hex(keyHashHex);\n  const credential = csl.Credential.from_scripthash(keyHash);\n  const rewardAddress = csl.RewardAddress.new(networkId, credential)\n    .to_address()\n    .to_bech32();\n  return rewardAddress;\n};",
      "source": "mesh-core-csl",
      "implementation": "export const keyHashToRewardAddress = (keyHashHex: string, network = 1) => {\n  const networkId =\n    network === 1\n      ? csl.NetworkId.mainnet().kind()\n      : csl.NetworkId.testnet().kind();\n  const keyHash = csl.Ed25519KeyHash.from_hex(keyHashHex);\n  const credential = csl.Credential.from_scripthash(keyHash);\n  const rewardAddress = csl.RewardAddress.new(networkId, credential)\n    .to_address()\n    .to_bech32();\n  return rewardAddress;\n};"
    },
    {
      "key": "mesh-core-csl:utils.transaction-parser.ts.getRequiredInputs",
      "fullName": "mesh-core-csl:utils.transaction-parser.ts.getRequiredInputs",
      "name": "getRequiredInputs",
      "signature": "export const getRequiredInputs = (transactionHex: string): TxInput[] => {",
      "documentation": "",
      "parameters": [
        {
          "name": "transactionHex",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "TxInput[]",
      "isPublic": true,
      "line": 5,
      "raw": "export const getRequiredInputs = (transactionHex: string): TxInput[] => {\n  const result = js_get_required_inputs_to_resolve(transactionHex);\n  if (result.get_status() !== \"success\") {\n    throw new Error(`Failed to get required inputs: ${result.get_error()}`);\n  }\n  const utxosStr: string[] = JSON.parse(result.get_data());\n\n  return utxosStr.map((utxoStr) => {\n    const parts = utxoStr.split(\"#\");\n    if (parts.length !== 2) {\n      throw new Error(`Invalid UTxO format: ${utxoStr}`);\n    }\n    const [txHash, outputIndex] = parts;\n    if (!txHash || !outputIndex) {\n      throw new Error(\n        `Invalid UTxO format: ${utxoStr}. Expected format is txHash#outputIndex`,\n      );\n    }\n    return {\n      txHash: txHash,\n      outputIndex: parseInt(outputIndex),\n    };\n  });\n};",
      "source": "mesh-core-csl",
      "implementation": "export const getRequiredInputs = (transactionHex: string): TxInput[] => {\n  const result = js_get_required_inputs_to_resolve(transactionHex);\n  if (result.get_status() !== \"success\") {\n    throw new Error(`Failed to get required inputs: ${result.get_error()}`);\n  }\n  const utxosStr: string[] = JSON.parse(result.get_data());\n\n  return utxosStr.map((utxoStr) => {\n    const parts = utxoStr.split(\"#\");\n    if (parts.length !== 2) {\n      throw new Error(`Invalid UTxO format: ${utxoStr}`);\n    }\n    const [txHash, outputIndex] = parts;\n    if (!txHash || !outputIndex) {\n      throw new Error(\n        `Invalid UTxO format: ${utxoStr}. Expected format is txHash#outputIndex`,\n      );\n    }\n    return {\n      txHash: txHash,\n      outputIndex: parseInt(outputIndex),\n    };\n  });\n};"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.isSuccessAction",
      "fullName": "mesh-core-csl:utils.transaction.ts.isSuccessAction",
      "name": "isSuccessAction",
      "signature": "function isSuccessAction(",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 41,
      "raw": "function isSuccessAction(\n  action: ActionWasm,\n): action is { success: SuccessAction } {\n  return (action as { success: SuccessAction }).success !== undefined;\n}",
      "source": "mesh-core-csl",
      "implementation": "function isSuccessAction(\n  action: ActionWasm,\n): action is { success: SuccessAction } {\n  return (action as { success: SuccessAction }).success !== undefined;\n}"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.isErrorAction",
      "fullName": "mesh-core-csl:utils.transaction.ts.isErrorAction",
      "name": "isErrorAction",
      "signature": "function isErrorAction(action: ActionWasm): action is { error: ErrorAction } {",
      "documentation": "",
      "parameters": [
        {
          "name": "action",
          "type": "ActionWasm",
          "optional": false
        }
      ],
      "returnType": "action is",
      "isPublic": true,
      "line": 47,
      "raw": "function isErrorAction(action: ActionWasm): action is { error: ErrorAction } {\n  return (action as { error: ErrorAction }).error !== undefined;\n}",
      "source": "mesh-core-csl",
      "implementation": "function isErrorAction(action: ActionWasm): action is { error: ErrorAction } {\n  return (action as { error: ErrorAction }).error !== undefined;\n}"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.calculateTxHash",
      "fullName": "mesh-core-csl:utils.transaction.ts.calculateTxHash",
      "name": "calculateTxHash",
      "signature": "export const calculateTxHash = (txHex: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "txHex",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 56,
      "raw": "export const calculateTxHash = (txHex: string) => {\n  const result = csl.js_calculate_tx_hash(txHex);\n  return parseWasmResult(result);\n};",
      "source": "mesh-core-csl",
      "implementation": "export const calculateTxHash = (txHex: string) => {\n  const result = csl.js_calculate_tx_hash(txHex);\n  return parseWasmResult(result);\n};"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.signTransaction",
      "fullName": "mesh-core-csl:utils.transaction.ts.signTransaction",
      "name": "signTransaction",
      "signature": "export const signTransaction = (txHex: string, signingKeys: string[]) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "txHex",
          "type": "string",
          "optional": false
        },
        {
          "name": "signingKeys",
          "type": "string[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 61,
      "raw": "export const signTransaction = (txHex: string, signingKeys: string[]) => {\n  const cslSigningKeys = csl.JsVecString.new();\n  signingKeys.forEach((key) => {\n    cslSigningKeys.add(key);\n  });\n  const result = csl.js_sign_transaction(txHex, cslSigningKeys);\n  return parseWasmResult(result);\n};",
      "source": "mesh-core-csl",
      "implementation": "export const signTransaction = (txHex: string, signingKeys: string[]) => {\n  const cslSigningKeys = csl.JsVecString.new();\n  signingKeys.forEach((key) => {\n    cslSigningKeys.add(key);\n  });\n  const result = csl.js_sign_transaction(txHex, cslSigningKeys);\n  return parseWasmResult(result);\n};"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.evaluateTransaction",
      "fullName": "mesh-core-csl:utils.transaction.ts.evaluateTransaction",
      "name": "evaluateTransaction",
      "signature": "export const evaluateTransaction = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 70,
      "raw": "export const evaluateTransaction = (\n  txHex: string,\n  resolvedUtxos: UTxO[],\n  chainedTxs: string[],\n  network: Network,\n  slotConfig: Omit<Omit<SlotConfig, \"startEpoch\">, \"epochLength\">,\n): Omit<Action, \"data\">[] => {\n  const additionalTxs = csl.JsVecString.new();\n  for (const tx of chainedTxs) {\n    additionalTxs.add(tx);\n  }\n  const mappedUtxos = csl.JsVecString.new();\n  for (const utxo of resolvedUtxos) {\n    mappedUtxos.add(JSON.stringify(utxo));\n  }\n  const result = csl.js_evaluate_tx_scripts(\n    txHex,\n    mappedUtxos,\n    additionalTxs,\n    network,\n    JSON.stringify(slotConfig),\n  );\n  const unwrappedResult = parseWasmResult(result);\n\n  const actions = JSON.parse(unwrappedResult) as ActionWasm[];\n  let parsedSuccessActions: SuccessAction[] = [];\n  let parsedErrorActions: ErrorAction[] = [];\n  actions.map((action) => {\n    if (isSuccessAction(action)) {\n      parsedSuccessActions.push(action.success);\n    } else if (isErrorAction(action)) {\n      parsedErrorActions.push(action.error);\n    } else {\n      throw new Error(\"Invalid action type found\");\n    }\n  });\n  if (parsedErrorActions.length > 0) {\n    throw new Error(JSON.stringify(parsedErrorActions));\n  }\n  return parsedSuccessActions.map(mapAction);\n};",
      "source": "mesh-core-csl",
      "implementation": "export const evaluateTransaction = (\n  txHex: string,\n  resolvedUtxos: UTxO[],\n  chainedTxs: string[],\n  network: Network,\n  slotConfig: Omit<Omit<SlotConfig, \"startEpoch\">, \"epochLength\">,\n): Omit<Action, \"data\">[] => {\n  const additionalTxs = csl.JsVecString.new();\n  for (const tx of chainedTxs) {\n    additionalTxs.add(tx);\n  }\n  const mappedUtxos = csl.JsVecString.new();\n  for (const utxo of resolvedUtxos) {\n    mappedUtxos.add(JSON.stringify(utxo));\n  }\n  const result = csl.js_evaluate_tx_scripts(\n    txHex,\n    mappedUtxos,\n    additionalTxs,\n    network,\n    JSON.stringify(slotConfig),\n  );\n  const unwrappedResult = parseWasmResult(result);\n\n  const actions = JSON.parse(unwrappedResult) as ActionWasm[];\n  let parsedSuccessActions: SuccessAction[] = [];\n  let parsedErrorActions: ErrorAction[] = [];\n  actions.map((action) => {\n    if (isSuccessAction(action)) {\n      parsedSuccessActions.push(action.success);\n    } else if (isErrorAction(action)) {\n      parsedErrorActions.push(action.error);\n    } else {\n      throw new Error(\"Invalid action type found\");\n    }\n  });\n  if (parsedErrorActions.length > 0) {\n    throw new Error(JSON.stringify(parsedErrorActions));\n  }\n  return parsedSuccessActions.map(mapAction);\n};"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.mapAction",
      "fullName": "mesh-core-csl:utils.transaction.ts.mapAction",
      "name": "mapAction",
      "signature": "const mapAction = (action: SuccessAction): Omit<Action, \"data\"> => {",
      "documentation": "",
      "parameters": [
        {
          "name": "action",
          "type": "SuccessAction",
          "optional": false
        }
      ],
      "returnType": "Omit<Action, \"data\">",
      "isPublic": true,
      "line": 112,
      "raw": "const mapAction = (action: SuccessAction): Omit<Action, \"data\"> => {\n  return {\n    index: action.index,\n    budget: mapBudget(action.budget),\n    tag: mapRedeemerTag(action.tag),\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "const mapAction = (action: SuccessAction): Omit<Action, \"data\"> => {\n  return {\n    index: action.index,\n    budget: mapBudget(action.budget),\n    tag: mapRedeemerTag(action.tag),\n  };\n};"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.mapBudget",
      "fullName": "mesh-core-csl:utils.transaction.ts.mapBudget",
      "name": "mapBudget",
      "signature": "const mapBudget = (budget: BudgetWasm): Budget => {",
      "documentation": "",
      "parameters": [
        {
          "name": "budget",
          "type": "BudgetWasm",
          "optional": false
        }
      ],
      "returnType": "Budget",
      "isPublic": true,
      "line": 120,
      "raw": "const mapBudget = (budget: BudgetWasm): Budget => {\n  return {\n    mem: budget.mem,\n    steps: budget.steps,\n  };\n};",
      "source": "mesh-core-csl",
      "implementation": "const mapBudget = (budget: BudgetWasm): Budget => {\n  return {\n    mem: budget.mem,\n    steps: budget.steps,\n  };\n};"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.mapRedeemerTag",
      "fullName": "mesh-core-csl:utils.transaction.ts.mapRedeemerTag",
      "name": "mapRedeemerTag",
      "signature": "const mapRedeemerTag = (tag: RedeemerTagWasm): RedeemerTagType => {",
      "documentation": "",
      "parameters": [
        {
          "name": "tag",
          "type": "RedeemerTagWasm",
          "optional": false
        }
      ],
      "returnType": "RedeemerTagType",
      "isPublic": true,
      "line": 127,
      "raw": "const mapRedeemerTag = (tag: RedeemerTagWasm): RedeemerTagType => {\n  switch (tag) {\n    case \"cert\":\n      return \"CERT\";\n    case \"mint\":\n      return \"MINT\";\n    case \"reward\":\n      return \"REWARD\";\n    case \"spend\":\n      return \"SPEND\";\n    case \"vote\":\n      return \"VOTE\";\n    case \"propose\":\n      return \"PROPOSE\";\n    default:\n      throw new Error(`Unknown RedeemerTag: ${tag}`);\n  }\n};",
      "source": "mesh-core-csl",
      "implementation": "const mapRedeemerTag = (tag: RedeemerTagWasm): RedeemerTagType => {\n  switch (tag) {\n    case \"cert\":\n      return \"CERT\";\n    case \"mint\":\n      return \"MINT\";\n    case \"reward\":\n      return \"REWARD\";\n    case \"spend\":\n      return \"SPEND\";\n    case \"vote\":\n      return \"VOTE\";\n    case \"propose\":\n      return \"PROPOSE\";\n    default:\n      throw new Error(`Unknown RedeemerTag: ${tag}`);\n  }\n};"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.getTransactionInputs",
      "fullName": "mesh-core-csl:utils.transaction.ts.getTransactionInputs",
      "name": "getTransactionInputs",
      "signature": "export const getTransactionInputs = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 146,
      "raw": "export const getTransactionInputs = (\n  txHex: string,\n): {\n  txHash: string;\n  outputIndex: number;\n}[] => {\n  const inputs = [];\n  const deserializedTx = deserializeTx(txHex);\n  const body = deserializedTx.body();\n  const cslInputs = body.inputs();\n  for (let i = 0; i < cslInputs.len(); i++) {\n    const input = cslInputs.get(i);\n    inputs.push({\n      txHash: input.transaction_id().to_hex(),\n      outputIndex: input.index(),\n    });\n  }\n  const cslCollaterals = body.collateral();\n  if (cslCollaterals) {\n    for (let i = 0; i < cslCollaterals.len(); i++) {\n      const collateral = cslCollaterals.get(i);\n      inputs.push({\n        txHash: collateral.transaction_id().to_hex(),\n        outputIndex: collateral.index(),\n      });\n    }\n  }\n  const cslRefInputs = body.reference_inputs();\n  if (cslRefInputs) {\n    for (let i = 0; i < cslRefInputs.len(); i++) {\n      const refInput = cslRefInputs.get(i);\n      inputs.push({\n        txHash: refInput.transaction_id().to_hex(),\n        outputIndex: refInput.index(),\n      });\n    }\n  }\n\n  return inputs;\n};",
      "source": "mesh-core-csl",
      "implementation": "export const getTransactionInputs = (\n  txHex: string,\n): {\n  txHash: string;\n  outputIndex: number;\n}[] => {\n  const inputs = [];\n  const deserializedTx = deserializeTx(txHex);\n  const body = deserializedTx.body();\n  const cslInputs = body.inputs();\n  for (let i = 0; i < cslInputs.len(); i++) {\n    const input = cslInputs.get(i);\n    inputs.push({\n      txHash: input.transaction_id().to_hex(),\n      outputIndex: input.index(),\n    });\n  }\n  const cslCollaterals = body.collateral();\n  if (cslCollaterals) {\n    for (let i = 0; i < cslCollaterals.len(); i++) {\n      const collateral = cslCollaterals.get(i);\n      inputs.push({\n        txHash: collateral.transaction_id().to_hex(),\n        outputIndex: collateral.index(),\n      });\n    }\n  }\n  const cslRefInputs = body.reference_inputs();\n  if (cslRefInputs) {\n    for (let i = 0; i < cslRefInputs.len(); i++) {\n      const refInput = cslRefInputs.get(i);\n      inputs.push({\n        txHash: refInput.transaction_id().to_hex(),\n        outputIndex: refInput.index(),\n      });\n    }\n  }\n\n  return inputs;\n};"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.getTransactionOutputs",
      "fullName": "mesh-core-csl:utils.transaction.ts.getTransactionOutputs",
      "name": "getTransactionOutputs",
      "signature": "export const getTransactionOutputs = (txHex: string): UTxO[] => {",
      "documentation": "",
      "parameters": [
        {
          "name": "txHex",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "UTxO[]",
      "isPublic": true,
      "line": 187,
      "raw": "export const getTransactionOutputs = (txHex: string): UTxO[] => {\n  const outputs = js_get_tx_outs_utxo(txHex).get_data();\n  const utxos: UTxO[] = JSON.parse(outputs);\n  return utxos;\n};",
      "source": "mesh-core-csl",
      "implementation": "export const getTransactionOutputs = (txHex: string): UTxO[] => {\n  const outputs = js_get_tx_outs_utxo(txHex).get_data();\n  const utxos: UTxO[] = JSON.parse(outputs);\n  return utxos;\n};"
    },
    {
      "key": "mesh-core-csl:wasm.ts.parseWasmResult",
      "fullName": "mesh-core-csl:wasm.ts.parseWasmResult",
      "name": "parseWasmResult",
      "signature": "export const parseWasmResult = (result: csl.WasmResult): string => {",
      "documentation": "",
      "parameters": [
        {
          "name": "result",
          "type": "csl.WasmResult",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 3,
      "raw": "export const parseWasmResult = (result: csl.WasmResult): string => {\n  if (result.get_status() !== \"success\") {\n    throw new Error(result.get_error());\n  }\n  return result.get_data();\n};",
      "source": "mesh-core-csl",
      "implementation": "export const parseWasmResult = (result: csl.WasmResult): string => {\n  if (result.get_status() !== \"success\") {\n    throw new Error(result.get_error());\n  }\n  return result.get_data();\n};"
    },
    {
      "key": "mesh-core-cst:message-signing.check-signature.ts.if",
      "fullName": "mesh-core-cst:message-signing.check-signature.ts.if",
      "name": "if",
      "signature": "if (builder.getPayload() === null) {",
      "documentation": "",
      "parameters": [
        {
          "name": "builder.getPayload(",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 106,
      "raw": "  if (builder.getPayload() === null) {\n    return false;\n  }",
      "source": "mesh-core-cst",
      "implementation": "  if (builder.getPayload() === null) {\n    return false;\n  }"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.buildMessage",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.buildMessage",
      "name": "buildMessage",
      "signature": "buildMessage(signature: Buffer): Buffer {",
      "documentation": "",
      "parameters": [
        {
          "name": "signature",
          "type": "Buffer",
          "optional": false
        }
      ],
      "returnType": "Buffer",
      "isPublic": true,
      "line": 114,
      "raw": "  buildMessage(signature: Buffer): Buffer {\n    this.signature = new CborBytes(signature);\n\n    let protectedSerialized = new CborBytes(Buffer.alloc(0));\n    if (this.protectedMap.map.length !== 0) {\n      protectedSerialized = new CborBytes(\n        Cbor.encode(this.protectedMap).toBuffer(),\n      );\n    }\n\n    if (!this.payload) throw Error(\"Invalid payload\");\n\n    const coseSign1 = new CborArray([\n      protectedSerialized,\n      this.unProtectedMap,\n      this.payload,\n      this.signature,\n    ]);\n\n    return Buffer.from(Cbor.encode(coseSign1).toBuffer());\n  }",
      "source": "mesh-core-cst",
      "implementation": "  buildMessage(signature: Buffer): Buffer {\n    this.signature = new CborBytes(signature);\n\n    let protectedSerialized = new CborBytes(Buffer.alloc(0));\n    if (this.protectedMap.map.length !== 0) {\n      protectedSerialized = new CborBytes(\n        Cbor.encode(this.protectedMap).toBuffer(),\n      );\n    }\n\n    if (!this.payload) throw Error(\"Invalid payload\");\n\n    const coseSign1 = new CborArray([\n      protectedSerialized,\n      this.unProtectedMap,\n      this.payload,\n      this.signature,\n    ]);\n\n    return Buffer.from(Cbor.encode(coseSign1).toBuffer());\n  }"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.getAddress",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.getAddress",
      "name": "getAddress",
      "signature": "getAddress(): Buffer {",
      "documentation": "",
      "parameters": [],
      "returnType": "Buffer",
      "isPublic": true,
      "line": 190,
      "raw": "  getAddress(): Buffer {\n    const address = this.protectedMap.map.find((value) => {\n      return (\n        JSONBig.stringify(value.k) ===\n        JSONBig.stringify(new CborText(\"address\"))\n      );\n    });\n    if (!address) throw Error(\"Address not found\");\n    return Buffer.from((address.v as CborBytes).bytes);\n  }",
      "source": "mesh-core-cst",
      "implementation": "  getAddress(): Buffer {\n    const address = this.protectedMap.map.find((value) => {\n      return (\n        JSONBig.stringify(value.k) ===\n        JSONBig.stringify(new CborText(\"address\"))\n      );\n    });\n    if (!address) throw Error(\"Address not found\");\n    return Buffer.from((address.v as CborBytes).bytes);\n  }"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.getPublicKey",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.getPublicKey",
      "name": "getPublicKey",
      "signature": "getPublicKey(): Buffer {",
      "documentation": "",
      "parameters": [],
      "returnType": "Buffer",
      "isPublic": true,
      "line": 201,
      "raw": "  getPublicKey(): Buffer {\n    const publicKey = this.protectedMap.map.find((value) => {\n      return JSONBig.stringify(value.k) === JSONBig.stringify(new CborUInt(4));\n    });\n    if (!publicKey) throw Error(\"Public key not found\");\n    return Buffer.from((publicKey.v as CborBytes).bytes);\n  }",
      "source": "mesh-core-cst",
      "implementation": "  getPublicKey(): Buffer {\n    const publicKey = this.protectedMap.map.find((value) => {\n      return JSONBig.stringify(value.k) === JSONBig.stringify(new CborUInt(4));\n    });\n    if (!publicKey) throw Error(\"Public key not found\");\n    return Buffer.from((publicKey.v as CborBytes).bytes);\n  }"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.getSignature",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.getSignature",
      "name": "getSignature",
      "signature": "getSignature(): Buffer | undefined {",
      "documentation": "",
      "parameters": [],
      "returnType": "Buffer | undefined",
      "isPublic": true,
      "line": 209,
      "raw": "  getSignature(): Buffer | undefined {\n    return this.signature ? Buffer.from(this.signature.bytes) : this.signature;\n  }",
      "source": "mesh-core-cst",
      "implementation": "  getSignature(): Buffer | undefined {\n    return this.signature ? Buffer.from(this.signature.bytes) : this.signature;\n  }"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.getPayload",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.getPayload",
      "name": "getPayload",
      "signature": "getPayload(): Buffer | null {",
      "documentation": "",
      "parameters": [],
      "returnType": "Buffer | null",
      "isPublic": true,
      "line": 213,
      "raw": "  getPayload(): Buffer | null {\n    return this.payload ? Buffer.from(this.payload.bytes) : this.payload;\n  }",
      "source": "mesh-core-cst",
      "implementation": "  getPayload(): Buffer | null {\n    return this.payload ? Buffer.from(this.payload.bytes) : this.payload;\n  }"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.getPublicKeyFromCoseKey",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.getPublicKeyFromCoseKey",
      "name": "getPublicKeyFromCoseKey",
      "signature": "const getPublicKeyFromCoseKey = (cbor: string): Buffer => {",
      "documentation": "",
      "parameters": [
        {
          "name": "cbor",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Buffer",
      "isPublic": true,
      "line": 218,
      "raw": "const getPublicKeyFromCoseKey = (cbor: string): Buffer => {\n  const decodedCoseKey = Cbor.parse(cbor) as CborMap;\n  const publicKeyEntry = decodedCoseKey.map.find((value) => {\n    return (\n      JSONBig.stringify(value.k) ===\n      JSONBig.stringify(new CborNegInt(BigInt(-2)))\n    );\n  });\n\n  if (publicKeyEntry) {\n    return Buffer.from((publicKeyEntry.v as CborBytes).bytes);\n  }\n\n  throw Error(\"Public key not found\");\n};",
      "source": "mesh-core-cst",
      "implementation": "const getPublicKeyFromCoseKey = (cbor: string): Buffer => {\n  const decodedCoseKey = Cbor.parse(cbor) as CborMap;\n  const publicKeyEntry = decodedCoseKey.map.find((value) => {\n    return (\n      JSONBig.stringify(value.k) ===\n      JSONBig.stringify(new CborNegInt(BigInt(-2)))\n    );\n  });\n\n  if (publicKeyEntry) {\n    return Buffer.from((publicKeyEntry.v as CborBytes).bytes);\n  }\n\n  throw Error(\"Public key not found\");\n};"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.getCoseKeyFromPublicKey",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.getCoseKeyFromPublicKey",
      "name": "getCoseKeyFromPublicKey",
      "signature": "const getCoseKeyFromPublicKey = (cbor: string): Buffer => {",
      "documentation": "",
      "parameters": [
        {
          "name": "cbor",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Buffer",
      "isPublic": true,
      "line": 234,
      "raw": "const getCoseKeyFromPublicKey = (cbor: string): Buffer => {\n  const coseKeyMap: CborMapEntry[] = [];\n  coseKeyMap.push({ k: new CborUInt(1), v: new CborUInt(1) });\n  coseKeyMap.push({ k: new CborUInt(3), v: new CborNegInt(-8) });\n  coseKeyMap.push({ k: new CborUInt(6), v: new CborNegInt(-2) });\n  coseKeyMap.push({\n    k: new CborNegInt(-2),\n    v: new CborBytes(Buffer.from(cbor, \"hex\")),\n  });\n  return Buffer.from(Cbor.encode(new CborMap(coseKeyMap)).toBuffer());\n};",
      "source": "mesh-core-cst",
      "implementation": "const getCoseKeyFromPublicKey = (cbor: string): Buffer => {\n  const coseKeyMap: CborMapEntry[] = [];\n  coseKeyMap.push({ k: new CborUInt(1), v: new CborUInt(1) });\n  coseKeyMap.push({ k: new CborUInt(3), v: new CborNegInt(-8) });\n  coseKeyMap.push({ k: new CborUInt(6), v: new CborNegInt(-2) });\n  coseKeyMap.push({\n    k: new CborNegInt(-2),\n    v: new CborBytes(Buffer.from(cbor, \"hex\")),\n  });\n  return Buffer.from(Cbor.encode(new CborMap(coseKeyMap)).toBuffer());\n};"
    },
    {
      "key": "mesh-core-cst:message-signing.generate-nonce.ts.generateNonce",
      "fullName": "mesh-core-cst:message-signing.generate-nonce.ts.generateNonce",
      "name": "generateNonce",
      "signature": "export const generateNonce = (label = \"\", length = 32) => {",
      "documentation": "/**\n * Generate a nonce string\n * @param label The label to prepend to the nonce\n * @param length The length of the nonce\n * @returns The generated nonce in hex format\n */",
      "parameters": [
        {
          "name": "label",
          "type": "any",
          "optional": false
        },
        {
          "name": "length",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 11,
      "raw": "/**\n * Generate a nonce string\n * @param label The label to prepend to the nonce\n * @param length The length of the nonce\n * @returns The generated nonce in hex format\n */\nexport const generateNonce = (label = \"\", length = 32) => {\n  if (length <= 0 || length > 2048) {\n    throw new Error(\"Length must be bewteen 1 and 2048\");\n  }\n  const randomString = customAlphabet(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n  );\n  const payload = randomString(length);\n  return stringToHex(`${label}${payload}`);\n};",
      "source": "mesh-core-cst",
      "implementation": "export const generateNonce = (label = \"\", length = 32) => {\n  if (length <= 0 || length > 2048) {\n    throw new Error(\"Length must be bewteen 1 and 2048\");\n  }\n  const randomString = customAlphabet(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n  );\n  const payload = randomString(length);\n  return stringToHex(`${label}${payload}`);\n};"
    },
    {
      "key": "mesh-core-cst:message-signing.sign-data.ts.signData",
      "fullName": "mesh-core-cst:message-signing.sign-data.ts.signData",
      "name": "signData",
      "signature": "export const signData = (data: string, signer: Signer): DataSignature => {",
      "documentation": "/**\n * Sign the data string using the provided signer\n * @param data The data string to sign\n * @param signer The signer object containing the key and address\n * @returns DataSignature for verification\n */",
      "parameters": [
        {
          "name": "data",
          "type": "string",
          "optional": false
        },
        {
          "name": "signer",
          "type": "Signer",
          "optional": false
        }
      ],
      "returnType": "DataSignature",
      "isPublic": true,
      "line": 23,
      "raw": "/**\n * Sign the data string using the provided signer\n * @param data The data string to sign\n * @param signer The signer object containing the key and address\n * @returns DataSignature for verification\n */\nexport const signData = (data: string, signer: Signer): DataSignature => {\n  const hexData = isHexString(data) ? data : stringToHex(data);\n  const payload = Buffer.from(hexData, \"hex\");\n  const publicKey = Buffer.from(signer.key.toPublic().bytes());\n\n  const protectedMap: CborMapEntry[] = [];\n  // Set protected headers as per CIP08\n  // Set Algorthm used by Cardano keys\n  protectedMap.push({ k: new CborUInt(1), v: new CborNegInt(-8) });\n  // Set PublicKey\n  protectedMap.push({ k: new CborUInt(4), v: new CborBytes(publicKey) });\n  // Set Address\n  protectedMap.push({\n    k: new CborText(\"address\"),\n    v: new CborBytes(Buffer.from(signer.address.toBytes(), \"hex\")),\n  });\n\n  const coseSign1Builder = new CoseSign1({\n    protectedMap: new CborMap(protectedMap),\n    unProtectedMap: new CborMap([]),\n    payload: new CborBytes(payload),\n  });\n\n  const signature = signer.key.sign(\n    HexBlob(Buffer.from(coseSign1Builder.createSigStructure()).toString(\"hex\")),\n  );\n\n  const coseSignature = coseSign1Builder\n    .buildMessage(Buffer.from(signature.bytes()))\n    .toString(\"hex\");\n\n  return {\n    key: getCoseKeyFromPublicKey(publicKey.toString(\"hex\")).toString(\"hex\"),\n    signature: coseSignature,\n  };\n};",
      "source": "mesh-core-cst",
      "implementation": "export const signData = (data: string, signer: Signer): DataSignature => {\n  const hexData = isHexString(data) ? data : stringToHex(data);\n  const payload = Buffer.from(hexData, \"hex\");\n  const publicKey = Buffer.from(signer.key.toPublic().bytes());\n\n  const protectedMap: CborMapEntry[] = [];\n  // Set protected headers as per CIP08\n  // Set Algorthm used by Cardano keys\n  protectedMap.push({ k: new CborUInt(1), v: new CborNegInt(-8) });\n  // Set PublicKey\n  protectedMap.push({ k: new CborUInt(4), v: new CborBytes(publicKey) });\n  // Set Address\n  protectedMap.push({\n    k: new CborText(\"address\"),\n    v: new CborBytes(Buffer.from(signer.address.toBytes(), \"hex\")),\n  });\n\n  const coseSign1Builder = new CoseSign1({\n    protectedMap: new CborMap(protectedMap),\n    unProtectedMap: new CborMap([]),\n    payload: new CborBytes(payload),\n  });\n\n  const signature = signer.key.sign(\n    HexBlob(Buffer.from(coseSign1Builder.createSigStructure()).toString(\"hex\")),\n  );\n\n  const coseSignature = coseSign1Builder\n    .buildMessage(Buffer.from(signature.bytes()))\n    .toString(\"hex\");\n\n  return {\n    key: getCoseKeyFromPublicKey(publicKey.toString(\"hex\")).toString(\"hex\"),\n    signature: coseSignature,\n  };\n};"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.applyArgsToPlutusScript",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.applyArgsToPlutusScript",
      "name": "applyArgsToPlutusScript",
      "signature": "const applyArgsToPlutusScript = (",
      "documentation": "/**\n * Applies arguments to a Plutus script, effectively parameterizing the script with provided data.\n *\n * @param {Uint8Array[]} args - An array of arguments to be applied to the script, each as a Uint8Array.\n * @param {Uint8Array} program - The original Plutus script as a Uint8Array.\n * @param {OutputEncoding} outputEncoding - The desired encoding for the output.\n * @returns {Uint8Array} The modified Plutus script with applied arguments.\n *\n * @description\n * This function performs the following steps:\n * 1. Extracts the pure Plutus bytes from the input program.\n * 2. Parses the UPLC (Untyped Plutus Core) from the pure Plutus bytes.\n * 3. Decodes the provided arguments from CBOR format.\n * 4. Iterates through the decoded arguments, applying each as a term to the program body.\n * 5. Creates a new UPLC program with the modified body.\n * 6. Encodes the new program and applies the specified output encoding.\n *\n * @note\n * - This function modifies the structure of the Plutus script by applying arguments, which can change its behavior when executed.\n * - The function assumes that the input arguments are in a compatible format (CBOR-encoded) and that the program is a valid Plutus script.\n */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 85,
      "raw": "/**\n * Applies arguments to a Plutus script, effectively parameterizing the script with provided data.\n *\n * @param {Uint8Array[]} args - An array of arguments to be applied to the script, each as a Uint8Array.\n * @param {Uint8Array} program - The original Plutus script as a Uint8Array.\n * @param {OutputEncoding} outputEncoding - The desired encoding for the output.\n * @returns {Uint8Array} The modified Plutus script with applied arguments.\n *\n * @description\n * This function performs the following steps:\n * 1. Extracts the pure Plutus bytes from the input program.\n * 2. Parses the UPLC (Untyped Plutus Core) from the pure Plutus bytes.\n * 3. Decodes the provided arguments from CBOR format.\n * 4. Iterates through the decoded arguments, applying each as a term to the program body.\n * 5. Creates a new UPLC program with the modified body.\n * 6. Encodes the new program and applies the specified output encoding.\n *\n * @note\n * - This function modifies the structure of the Plutus script by applying arguments, which can change its behavior when executed.\n * - The function assumes that the input arguments are in a compatible format (CBOR-encoded) and that the program is a valid Plutus script.\n */\nconst applyArgsToPlutusScript = (\n  args: Uint8Array[],\n  program: Uint8Array,\n  outputEncoding: OutputEncoding,\n): Uint8Array => {\n  const purePlutusBytes = getPurePlutusBytes(program);\n  const parsedProgram = parseUPLC(purePlutusBytes, \"flat\");\n  const decodedArgs = args.map((arg) => dataFromCbor(arg));\n  let body = parsedProgram.body;\n\n  for (const plutusData of decodedArgs) {\n    const argTerm = UPLCConst.data(plutusData);\n    body = new Application(body, argTerm);\n  }\n\n  const encodedProgram = new UPLCProgram(parsedProgram.version, body);\n  const newPlutusScriptBytes = encodeUPLC(encodedProgram).toBuffer().buffer;\n  return applyEncoding(newPlutusScriptBytes, outputEncoding);\n};",
      "source": "mesh-core-cst",
      "implementation": "const applyArgsToPlutusScript = (\n  args: Uint8Array[],\n  program: Uint8Array,\n  outputEncoding: OutputEncoding,\n): Uint8Array => {\n  const purePlutusBytes = getPurePlutusBytes(program);\n  const parsedProgram = parseUPLC(purePlutusBytes, \"flat\");\n  const decodedArgs = args.map((arg) => dataFromCbor(arg));\n  let body = parsedProgram.body;\n\n  for (const plutusData of decodedArgs) {\n    const argTerm = UPLCConst.data(plutusData);\n    body = new Application(body, argTerm);\n  }\n\n  const encodedProgram = new UPLCProgram(parsedProgram.version, body);\n  const newPlutusScriptBytes = encodeUPLC(encodedProgram).toBuffer().buffer;\n  return applyEncoding(newPlutusScriptBytes, outputEncoding);\n};"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.normalizePlutusScript",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.normalizePlutusScript",
      "name": "normalizePlutusScript",
      "signature": "export const normalizePlutusScript = (",
      "documentation": "/**\n * Normalizes a Plutus script by extracting its pure Plutus bytes and applying a specified encoding.\n *\n * @param {Uint8Array} plutusScript - The Plutus script to be normalized as a Uint8Array.\n * @param {OutputEncoding} encoding - The desired encoding for the output.\n * @returns {Uint8Array} The normalized Plutus script.\n *\n * @description\n * This function performs the following steps:\n * 1. Extracts the pure Plutus bytes in hex from the input script.\n * 2. Applies the specified encoding to the pure Plutus bytes.\n *\n * @note\n * - This function is useful for standardizing the format of Plutus scripts, ensuring they are in a consistent state for further processing or comparison.\n * - The normalization process does not modify the logical content of the script, only its representation.\n */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 121,
      "raw": "/**\n * Normalizes a Plutus script by extracting its pure Plutus bytes and applying a specified encoding.\n *\n * @param {Uint8Array} plutusScript - The Plutus script to be normalized as a Uint8Array.\n * @param {OutputEncoding} encoding - The desired encoding for the output.\n * @returns {Uint8Array} The normalized Plutus script.\n *\n * @description\n * This function performs the following steps:\n * 1. Extracts the pure Plutus bytes in hex from the input script.\n * 2. Applies the specified encoding to the pure Plutus bytes.\n *\n * @note\n * - This function is useful for standardizing the format of Plutus scripts, ensuring they are in a consistent state for further processing or comparison.\n * - The normalization process does not modify the logical content of the script, only its representation.\n */\nexport const normalizePlutusScript = (\n  plutusScript: string,\n  encoding: OutputEncoding,\n): string => {\n  const bytes = Buffer.from(plutusScript, \"hex\");\n  const purePlutusBytes = getPurePlutusBytes(bytes);\n  const normalizedBytes = applyEncoding(purePlutusBytes, encoding);\n  return Buffer.from(normalizedBytes).toString(\"hex\");\n};",
      "source": "mesh-core-cst",
      "implementation": "export const normalizePlutusScript = (\n  plutusScript: string,\n  encoding: OutputEncoding,\n): string => {\n  const bytes = Buffer.from(plutusScript, \"hex\");\n  const purePlutusBytes = getPurePlutusBytes(bytes);\n  const normalizedBytes = applyEncoding(purePlutusBytes, encoding);\n  return Buffer.from(normalizedBytes).toString(\"hex\");\n};"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.hasSupportedPlutusVersion",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.hasSupportedPlutusVersion",
      "name": "hasSupportedPlutusVersion",
      "signature": "const hasSupportedPlutusVersion = (plutusScript: Uint8Array): boolean => {",
      "documentation": "",
      "parameters": [
        {
          "name": "plutusScript",
          "type": "Uint8Array",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "isPublic": true,
      "line": 131,
      "raw": "const hasSupportedPlutusVersion = (plutusScript: Uint8Array): boolean => {\n  if (plutusScript.length < 3) {\n    return false;\n  }\n  const version = [plutusScript[0], plutusScript[1], plutusScript[2]];\n  return supportedPlutusCoreVersions.some((supportedVersion) => {\n    return (\n      supportedVersion.version[0] === version[0] &&\n      supportedVersion.version[1] === version[1] &&\n      supportedVersion.version[2] === version[2]\n    );\n  });\n};",
      "source": "mesh-core-cst",
      "implementation": "const hasSupportedPlutusVersion = (plutusScript: Uint8Array): boolean => {\n  if (plutusScript.length < 3) {\n    return false;\n  }\n  const version = [plutusScript[0], plutusScript[1], plutusScript[2]];\n  return supportedPlutusCoreVersions.some((supportedVersion) => {\n    return (\n      supportedVersion.version[0] === version[0] &&\n      supportedVersion.version[1] === version[1] &&\n      supportedVersion.version[2] === version[2]\n    );\n  });\n};"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.getPurePlutusBytes",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.getPurePlutusBytes",
      "name": "getPurePlutusBytes",
      "signature": "const getPurePlutusBytes = (plutusScript: Uint8Array): Uint8Array => {",
      "documentation": "",
      "parameters": [
        {
          "name": "plutusScript",
          "type": "Uint8Array",
          "optional": false
        }
      ],
      "returnType": "Uint8Array",
      "isPublic": true,
      "line": 145,
      "raw": "const getPurePlutusBytes = (plutusScript: Uint8Array): Uint8Array => {\n  let unwrappedScript = plutusScript;\n  let length = 0;\n  try {\n    while (unwrappedScript.length >= 3 && length != unwrappedScript.length) {\n      length = unwrappedScript.length;\n      if (hasSupportedPlutusVersion(unwrappedScript)) {\n        return unwrappedScript;\n      }\n      const cbor = Cbor.parse(unwrappedScript);\n      if (cbor instanceof CborBytes) {\n        unwrappedScript = cbor.bytes;\n      } else {\n        break;\n      }\n    }\n  } catch (error) {\n    console.error(\"Error parsing Plutus script:\", error);\n  }\n  if (hasSupportedPlutusVersion(unwrappedScript)) {\n    return unwrappedScript;\n  }\n  throw new Error(\"Unsupported Plutus version or invalid Plutus script bytes\");\n};",
      "source": "mesh-core-cst",
      "implementation": "const getPurePlutusBytes = (plutusScript: Uint8Array): Uint8Array => {\n  let unwrappedScript = plutusScript;\n  let length = 0;\n  try {\n    while (unwrappedScript.length >= 3 && length != unwrappedScript.length) {\n      length = unwrappedScript.length;\n      if (hasSupportedPlutusVersion(unwrappedScript)) {\n        return unwrappedScript;\n      }\n      const cbor = Cbor.parse(unwrappedScript);\n      if (cbor instanceof CborBytes) {\n        unwrappedScript = cbor.bytes;\n      } else {\n        break;\n      }\n    }\n  } catch (error) {\n    console.error(\"Error parsing Plutus script:\", error);\n  }\n  if (hasSupportedPlutusVersion(unwrappedScript)) {\n    return unwrappedScript;\n  }\n  throw new Error(\"Unsupported Plutus version or invalid Plutus script bytes\");\n};"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.applyCborEncoding",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.applyCborEncoding",
      "name": "applyCborEncoding",
      "signature": "const applyCborEncoding = (plutusScript: Uint8Array): Uint8Array => {",
      "documentation": "",
      "parameters": [
        {
          "name": "plutusScript",
          "type": "Uint8Array",
          "optional": false
        }
      ],
      "returnType": "Uint8Array",
      "isPublic": true,
      "line": 170,
      "raw": "const applyCborEncoding = (plutusScript: Uint8Array): Uint8Array => {\n  return Cbor.encode(new CborBytes(plutusScript)).toBuffer();\n};",
      "source": "mesh-core-cst",
      "implementation": "const applyCborEncoding = (plutusScript: Uint8Array): Uint8Array => {\n  return Cbor.encode(new CborBytes(plutusScript)).toBuffer();\n};"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.applyEncoding",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.applyEncoding",
      "name": "applyEncoding",
      "signature": "export const applyEncoding = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 174,
      "raw": "export const applyEncoding = (\n  plutusScript: Uint8Array,\n  outputEncoding: OutputEncoding,\n): Uint8Array => {\n  switch (outputEncoding) {\n    case \"SingleCBOR\":\n      return applyCborEncoding(plutusScript);\n    case \"DoubleCBOR\":\n      return applyCborEncoding(applyCborEncoding(plutusScript));\n    case \"PurePlutusScriptBytes\":\n      return plutusScript;\n    default:\n      return applyCborEncoding(plutusScript);\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const applyEncoding = (\n  plutusScript: Uint8Array,\n  outputEncoding: OutputEncoding,\n): Uint8Array => {\n  switch (outputEncoding) {\n    case \"SingleCBOR\":\n      return applyCborEncoding(plutusScript);\n    case \"DoubleCBOR\":\n      return applyCborEncoding(applyCborEncoding(plutusScript));\n    case \"PurePlutusScriptBytes\":\n      return plutusScript;\n    default:\n      return applyCborEncoding(plutusScript);\n  }\n};"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.applyParamsToScript",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.applyParamsToScript",
      "name": "applyParamsToScript",
      "signature": "export const applyParamsToScript = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 190,
      "raw": "export const applyParamsToScript = (\n  rawScript: string,\n  params: object[] | Data[],\n  type: PlutusDataType = \"Mesh\",\n): string => {\n  let plutusParams: PlutusData[] = [];\n  switch (type) {\n    case \"JSON\":\n      params.forEach((param) => {\n        plutusParams.push(\n          fromBuilderToPlutusData({\n            type: \"JSON\",\n            content: param as string,\n          }),\n        );\n      });\n      break;\n    case \"CBOR\":\n      params.forEach((param) => {\n        plutusParams.push(\n          fromBuilderToPlutusData({\n            type: \"CBOR\",\n            content: param as string,\n          }),\n        );\n      });\n      break;\n    case \"Mesh\":\n      params.forEach((param) => {\n        plutusParams.push(\n          fromBuilderToPlutusData({\n            type: \"Mesh\",\n            content: param as Data,\n          }),\n        );\n      });\n      break;\n  }\n\n  const byteParams = plutusParams.map((param) => {\n    return Buffer.from(param.toCbor(), \"hex\");\n  });\n\n  const scriptHex = Buffer.from(\n    applyArgsToPlutusScript(\n      byteParams,\n      Buffer.from(rawScript, \"hex\"),\n      \"DoubleCBOR\",\n    ),\n  ).toString(\"hex\");\n\n  return scriptHex;\n};",
      "source": "mesh-core-cst",
      "implementation": "export const applyParamsToScript = (\n  rawScript: string,\n  params: object[] | Data[],\n  type: PlutusDataType = \"Mesh\",\n): string => {\n  let plutusParams: PlutusData[] = [];\n  switch (type) {\n    case \"JSON\":\n      params.forEach((param) => {\n        plutusParams.push(\n          fromBuilderToPlutusData({\n            type: \"JSON\",\n            content: param as string,\n          }),\n        );\n      });\n      break;\n    case \"CBOR\":\n      params.forEach((param) => {\n        plutusParams.push(\n          fromBuilderToPlutusData({\n            type: \"CBOR\",\n            content: param as string,\n          }),\n        );\n      });\n      break;\n    case \"Mesh\":\n      params.forEach((param) => {\n        plutusParams.push(\n          fromBuilderToPlutusData({\n            type: \"Mesh\",\n            content: param as Data,\n          }),\n        );\n      });\n      break;\n  }\n\n  const byteParams = plutusParams.map((param) => {\n    return Buffer.from(param.toCbor(), \"hex\");\n  });\n\n  const scriptHex = Buffer.from(\n    applyArgsToPlutusScript(\n      byteParams,\n      Buffer.from(rawScript, \"hex\"),\n      \"DoubleCBOR\",\n    ),\n  ).toString(\"hex\");\n\n  return scriptHex;\n};"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolveDataHash",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolveDataHash",
      "name": "resolveDataHash",
      "signature": "export const resolveDataHash = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 47,
      "raw": "export const resolveDataHash = (\n  rawData: BuilderData[\"content\"],\n  type: PlutusDataType = \"Mesh\",\n) => {\n  const plutusData = fromBuilderToPlutusData({\n    content: rawData,\n    type,\n  } as BuilderData);\n  return plutusData.hash().toString();\n};",
      "source": "mesh-core-cst",
      "implementation": "export const resolveDataHash = (\n  rawData: BuilderData[\"content\"],\n  type: PlutusDataType = \"Mesh\",\n) => {\n  const plutusData = fromBuilderToPlutusData({\n    content: rawData,\n    type,\n  } as BuilderData);\n  return plutusData.hash().toString();\n};"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolveNativeScriptAddress",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolveNativeScriptAddress",
      "name": "resolveNativeScriptAddress",
      "signature": "export const resolveNativeScriptAddress = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 58,
      "raw": "export const resolveNativeScriptAddress = (\n  script: NativeScript,\n  networkId = 0,\n) => {\n  const nativeScript = toNativeScript(script);\n\n  const enterpriseAddress = EnterpriseAddress.fromCredentials(networkId, {\n    hash: nativeScript.hash(),\n    type: Cardano.CredentialType.ScriptHash,\n  });\n\n  return enterpriseAddress.toAddress().toBech32().toString();\n};",
      "source": "mesh-core-cst",
      "implementation": "export const resolveNativeScriptAddress = (\n  script: NativeScript,\n  networkId = 0,\n) => {\n  const nativeScript = toNativeScript(script);\n\n  const enterpriseAddress = EnterpriseAddress.fromCredentials(networkId, {\n    hash: nativeScript.hash(),\n    type: Cardano.CredentialType.ScriptHash,\n  });\n\n  return enterpriseAddress.toAddress().toBech32().toString();\n};"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolveNativeScriptHash",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolveNativeScriptHash",
      "name": "resolveNativeScriptHash",
      "signature": "export const resolveNativeScriptHash = (script: NativeScript) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "script",
          "type": "NativeScript",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 72,
      "raw": "export const resolveNativeScriptHash = (script: NativeScript) => {\n  return toNativeScript(script).hash().toString();\n};",
      "source": "mesh-core-cst",
      "implementation": "export const resolveNativeScriptHash = (script: NativeScript) => {\n  return toNativeScript(script).hash().toString();\n};"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolvePaymentKeyHash",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolvePaymentKeyHash",
      "name": "resolvePaymentKeyHash",
      "signature": "export const resolvePaymentKeyHash = (bech32: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "bech32",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 76,
      "raw": "export const resolvePaymentKeyHash = (bech32: string) => {\n  try {\n    const paymentKeyHash = [\n      toBaseAddress(bech32)?.getPaymentCredential().hash,\n      toEnterpriseAddress(bech32)?.getPaymentCredential().hash,\n    ].find((kh) => kh !== undefined);\n\n    if (paymentKeyHash !== undefined) return paymentKeyHash.toString();\n\n    throw new Error(\n      `Couldn't resolve payment key hash from address: ${bech32}`,\n    );\n  } catch (error) {\n    throw new Error(\n      `An error occurred during resolvePaymentKeyHash: ${error}.`,\n    );\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const resolvePaymentKeyHash = (bech32: string) => {\n  try {\n    const paymentKeyHash = [\n      toBaseAddress(bech32)?.getPaymentCredential().hash,\n      toEnterpriseAddress(bech32)?.getPaymentCredential().hash,\n    ].find((kh) => kh !== undefined);\n\n    if (paymentKeyHash !== undefined) return paymentKeyHash.toString();\n\n    throw new Error(\n      `Couldn't resolve payment key hash from address: ${bech32}`,\n    );\n  } catch (error) {\n    throw new Error(\n      `An error occurred during resolvePaymentKeyHash: ${error}.`,\n    );\n  }\n};"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolvePlutusScriptAddress",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolvePlutusScriptAddress",
      "name": "resolvePlutusScriptAddress",
      "signature": "export const resolvePlutusScriptAddress = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 95,
      "raw": "export const resolvePlutusScriptAddress = (\n  script: PlutusScript,\n  networkId = 0,\n) => {\n  const plutusScript = deserializePlutusScript(script.code, script.version);\n\n  const enterpriseAddress = EnterpriseAddress.fromCredentials(networkId, {\n    hash: plutusScript.hash(),\n    type: Cardano.CredentialType.ScriptHash,\n  });\n\n  return enterpriseAddress.toAddress().toBech32().toString();\n};",
      "source": "mesh-core-cst",
      "implementation": "export const resolvePlutusScriptAddress = (\n  script: PlutusScript,\n  networkId = 0,\n) => {\n  const plutusScript = deserializePlutusScript(script.code, script.version);\n\n  const enterpriseAddress = EnterpriseAddress.fromCredentials(networkId, {\n    hash: plutusScript.hash(),\n    type: Cardano.CredentialType.ScriptHash,\n  });\n\n  return enterpriseAddress.toAddress().toBech32().toString();\n};"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolvePlutusScriptHash",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolvePlutusScriptHash",
      "name": "resolvePlutusScriptHash",
      "signature": "export const resolvePlutusScriptHash = (bech32: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "bech32",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 109,
      "raw": "export const resolvePlutusScriptHash = (bech32: string) => {\n  try {\n    const enterpriseAddress = toEnterpriseAddress(bech32);\n    const scriptHash = enterpriseAddress?.getPaymentCredential().hash;\n\n    if (scriptHash !== undefined) return scriptHash.toString();\n\n    throw new Error(`Couldn't resolve script hash from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveScriptHash: ${error}.`);\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const resolvePlutusScriptHash = (bech32: string) => {\n  try {\n    const enterpriseAddress = toEnterpriseAddress(bech32);\n    const scriptHash = enterpriseAddress?.getPaymentCredential().hash;\n\n    if (scriptHash !== undefined) return scriptHash.toString();\n\n    throw new Error(`Couldn't resolve script hash from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveScriptHash: ${error}.`);\n  }\n};"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolvePoolId",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolvePoolId",
      "name": "resolvePoolId",
      "signature": "export const resolvePoolId = (hash: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "hash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 122,
      "raw": "export const resolvePoolId = (hash: string) => {\n  return PoolId.fromKeyHash(Ed25519KeyHashHex(hash)).toString();\n};",
      "source": "mesh-core-cst",
      "implementation": "export const resolvePoolId = (hash: string) => {\n  return PoolId.fromKeyHash(Ed25519KeyHashHex(hash)).toString();\n};"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolvePrivateKey",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolvePrivateKey",
      "name": "resolvePrivateKey",
      "signature": "export const resolvePrivateKey = (words: string[]) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "words",
          "type": "string[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 126,
      "raw": "export const resolvePrivateKey = (words: string[]) => {\n  const buildBip32PrivateKey = (\n    entropy: string,\n    password = \"\",\n  ): Bip32PrivateKey => {\n    return Bip32PrivateKey.fromBip39Entropy(\n      Buffer.from(toBytes(entropy)),\n      fromUTF8(password),\n    );\n  };\n\n  const entropy = mnemonicToEntropy(words.join(\" \"));\n  const bip32PrivateKey = buildBip32PrivateKey(entropy);\n  const bytes = base32.encode(bip32PrivateKey.bytes());\n  const bech32PrivateKey = bech32.encode(\"xprv\", bytes, 1023);\n\n  return bech32PrivateKey;\n};",
      "source": "mesh-core-cst",
      "implementation": "export const resolvePrivateKey = (words: string[]) => {\n  const buildBip32PrivateKey = (\n    entropy: string,\n    password = \"\",\n  ): Bip32PrivateKey => {\n    return Bip32PrivateKey.fromBip39Entropy(\n      Buffer.from(toBytes(entropy)),\n      fromUTF8(password),\n    );\n  };\n\n  const entropy = mnemonicToEntropy(words.join(\" \"));\n  const bip32PrivateKey = buildBip32PrivateKey(entropy);\n  const bytes = base32.encode(bip32PrivateKey.bytes());\n  const bech32PrivateKey = bech32.encode(\"xprv\", bytes, 1023);\n\n  return bech32PrivateKey;\n};"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.buildBip32PrivateKey",
      "fullName": "mesh-core-cst:resolvers.index.ts.buildBip32PrivateKey",
      "name": "buildBip32PrivateKey",
      "signature": "const buildBip32PrivateKey = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 127,
      "raw": "  const buildBip32PrivateKey = (\n    entropy: string,\n    password = \"\",\n  ): Bip32PrivateKey => {\n    return Bip32PrivateKey.fromBip39Entropy(\n      Buffer.from(toBytes(entropy)),\n      fromUTF8(password),\n    );\n  };",
      "source": "mesh-core-cst",
      "implementation": "  const buildBip32PrivateKey = (\n    entropy: string,\n    password = \"\",\n  ): Bip32PrivateKey => {\n    return Bip32PrivateKey.fromBip39Entropy(\n      Buffer.from(toBytes(entropy)),\n      fromUTF8(password),\n    );\n  };"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolveScriptRef",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolveScriptRef",
      "name": "resolveScriptRef",
      "signature": "export const resolveScriptRef = (script: PlutusScript | NativeScript) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "script",
          "type": "PlutusScript | NativeScript",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 145,
      "raw": "export const resolveScriptRef = (script: PlutusScript | NativeScript) => {\n  return toScriptRef(script).toCbor().toString();\n};",
      "source": "mesh-core-cst",
      "implementation": "export const resolveScriptRef = (script: PlutusScript | NativeScript) => {\n  return toScriptRef(script).toCbor().toString();\n};"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolveRewardAddress",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolveRewardAddress",
      "name": "resolveRewardAddress",
      "signature": "export const resolveRewardAddress = (bech32: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "bech32",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 149,
      "raw": "export const resolveRewardAddress = (bech32: string) => {\n  try {\n    const address = toAddress(bech32);\n    const baseAddress = toBaseAddress(bech32);\n    const stakeKeyHash = baseAddress?.getStakeCredential().hash;\n\n    if (stakeKeyHash !== undefined)\n      return buildRewardAddress(address.getNetworkId(), stakeKeyHash)\n        .toAddress()\n        .toBech32()\n        .toString();\n\n    throw new Error(`Couldn't resolve reward address from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveRewardAddress: ${error}.`);\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const resolveRewardAddress = (bech32: string) => {\n  try {\n    const address = toAddress(bech32);\n    const baseAddress = toBaseAddress(bech32);\n    const stakeKeyHash = baseAddress?.getStakeCredential().hash;\n\n    if (stakeKeyHash !== undefined)\n      return buildRewardAddress(address.getNetworkId(), stakeKeyHash)\n        .toAddress()\n        .toBech32()\n        .toString();\n\n    throw new Error(`Couldn't resolve reward address from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveRewardAddress: ${error}.`);\n  }\n};"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolveStakeKeyHash",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolveStakeKeyHash",
      "name": "resolveStakeKeyHash",
      "signature": "export const resolveStakeKeyHash = (bech32: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "bech32",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 167,
      "raw": "export const resolveStakeKeyHash = (bech32: string) => {\n  try {\n    const stakeKeyHash = [\n      toBaseAddress(bech32)?.getStakeCredential().hash,\n      toRewardAddress(bech32)?.getPaymentCredential().hash,\n    ].find((kh) => kh !== undefined);\n\n    if (stakeKeyHash !== undefined) return stakeKeyHash.toString();\n\n    throw new Error(`Couldn't resolve stake key hash from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveStakeKeyHash: ${error}.`);\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const resolveStakeKeyHash = (bech32: string) => {\n  try {\n    const stakeKeyHash = [\n      toBaseAddress(bech32)?.getStakeCredential().hash,\n      toRewardAddress(bech32)?.getPaymentCredential().hash,\n    ].find((kh) => kh !== undefined);\n\n    if (stakeKeyHash !== undefined) return stakeKeyHash.toString();\n\n    throw new Error(`Couldn't resolve stake key hash from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(`An error occurred during resolveStakeKeyHash: ${error}.`);\n  }\n};"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolveTxHash",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolveTxHash",
      "name": "resolveTxHash",
      "signature": "export const resolveTxHash = (txHex: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "txHex",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 182,
      "raw": "export const resolveTxHash = (txHex: string) => {\n  const txBody = deserializeTx(txHex).body();\n  const hash = blake2b(blake2b.BYTES)\n    .update(hexToBytes(txBody.toCbor()))\n    .digest();\n  return Cardano.TransactionId.fromHexBlob(HexBlob.fromBytes(hash)).toString();\n};",
      "source": "mesh-core-cst",
      "implementation": "export const resolveTxHash = (txHex: string) => {\n  const txBody = deserializeTx(txHex).body();\n  const hash = blake2b(blake2b.BYTES)\n    .update(hexToBytes(txBody.toCbor()))\n    .digest();\n  return Cardano.TransactionId.fromHexBlob(HexBlob.fromBytes(hash)).toString();\n};"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolveScriptHashDRepId",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolveScriptHashDRepId",
      "name": "resolveScriptHashDRepId",
      "signature": "export const resolveScriptHashDRepId = (scriptHash: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "scriptHash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 190,
      "raw": "export const resolveScriptHashDRepId = (scriptHash: string) => {\n  return DRepID.cip129FromCredential({\n    type: Cardano.CredentialType.ScriptHash,\n    hash: Hash28ByteBase16(scriptHash),\n  }).toString();\n};",
      "source": "mesh-core-cst",
      "implementation": "export const resolveScriptHashDRepId = (scriptHash: string) => {\n  return DRepID.cip129FromCredential({\n    type: Cardano.CredentialType.ScriptHash,\n    hash: Hash28ByteBase16(scriptHash),\n  }).toString();\n};"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolveEd25519KeyHash",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolveEd25519KeyHash",
      "name": "resolveEd25519KeyHash",
      "signature": "export const resolveEd25519KeyHash = (bech32: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "bech32",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 197,
      "raw": "export const resolveEd25519KeyHash = (bech32: string) => {\n  try {\n    const keyHash = [\n      toBaseAddress(bech32)?.getPaymentCredential().hash,\n      toEnterpriseAddress(bech32)?.getPaymentCredential().hash,\n    ].find((kh) => kh !== undefined);\n\n    if (keyHash !== undefined) return keyHash.toString();\n\n    throw new Error(`Couldn't resolve key hash from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(\n      `An error occurred during resolveEd25519KeyHash: ${error}.`,\n    );\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const resolveEd25519KeyHash = (bech32: string) => {\n  try {\n    const keyHash = [\n      toBaseAddress(bech32)?.getPaymentCredential().hash,\n      toEnterpriseAddress(bech32)?.getPaymentCredential().hash,\n    ].find((kh) => kh !== undefined);\n\n    if (keyHash !== undefined) return keyHash.toString();\n\n    throw new Error(`Couldn't resolve key hash from address: ${bech32}`);\n  } catch (error) {\n    throw new Error(\n      `An error occurred during resolveEd25519KeyHash: ${error}.`,\n    );\n  }\n};"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.serializePoolId",
      "fullName": "mesh-core-cst:serializer.index.ts.serializePoolId",
      "name": "serializePoolId",
      "signature": "serializePoolId(hash: string): string {",
      "documentation": "",
      "parameters": [
        {
          "name": "hash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 156,
      "raw": "  serializePoolId(hash: string): string {\n    return PoolId.fromKeyHash(Ed25519KeyHashHex(hash)).toString();\n  }",
      "source": "mesh-core-cst",
      "implementation": "  serializePoolId(hash: string): string {\n    return PoolId.fromKeyHash(Ed25519KeyHashHex(hash)).toString();\n  }"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.serializeData",
      "fullName": "mesh-core-cst:serializer.index.ts.serializeData",
      "name": "serializeData",
      "signature": "serializeData(data: BuilderData): string {",
      "documentation": "",
      "parameters": [
        {
          "name": "data",
          "type": "BuilderData",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 237,
      "raw": "  serializeData(data: BuilderData): string {\n    const plutusData = fromBuilderToPlutusData(data);\n    return plutusData.toCbor().toString();\n  }",
      "source": "mesh-core-cst",
      "implementation": "  serializeData(data: BuilderData): string {\n    const plutusData = fromBuilderToPlutusData(data);\n    return plutusData.toCbor().toString();\n  }"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.buildBip32PrivateKey",
      "fullName": "mesh-core-cst:serializer.index.ts.buildBip32PrivateKey",
      "name": "buildBip32PrivateKey",
      "signature": "const buildBip32PrivateKey = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 323,
      "raw": "        const buildBip32PrivateKey = (\n          entropy: string,\n          password = \"\",\n        ): Bip32PrivateKey => {\n          return Bip32PrivateKey.fromBip39Entropy(\n            Buffer.from(toBytes(entropy)),\n            fromUTF8(password),\n          );\n        };",
      "source": "mesh-core-cst",
      "implementation": "        const buildBip32PrivateKey = (\n          entropy: string,\n          password = \"\",\n        ): Bip32PrivateKey => {\n          return Bip32PrivateKey.fromBip39Entropy(\n            Buffer.from(toBytes(entropy)),\n            fromUTF8(password),\n          );\n        };"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.if",
      "fullName": "mesh-core-cst:serializer.index.ts.if",
      "name": "if",
      "signature": "if (refInput.toCbor() === inputs[i]!.toCbor()) {",
      "documentation": "",
      "parameters": [
        {
          "name": "refInput.toCbor(",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1515,
      "raw": "          if (refInput.toCbor() === inputs[i]!.toCbor()) {\n            found = true;\n          }",
      "source": "mesh-core-cst",
      "implementation": "          if (refInput.toCbor() === inputs[i]!.toCbor()) {\n            found = true;\n          }"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.serializeValue",
      "fullName": "mesh-core-cst:serializer.index.ts.serializeValue",
      "name": "serializeValue",
      "signature": "serializeValue(value: Asset[]): string {",
      "documentation": "",
      "parameters": [
        {
          "name": "value",
          "type": "Asset[]",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 487,
      "raw": "  serializeValue(value: Asset[]): string {\n    return toValue(value).toCbor();\n  }",
      "source": "mesh-core-cst",
      "implementation": "  serializeValue(value: Asset[]): string {\n    return toValue(value).toCbor();\n  }"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.serializeOutput",
      "fullName": "mesh-core-cst:serializer.index.ts.serializeOutput",
      "name": "serializeOutput",
      "signature": "serializeOutput(output: Output): string {",
      "documentation": "",
      "parameters": [
        {
          "name": "output",
          "type": "Output",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 491,
      "raw": "  serializeOutput(output: Output): string {\n    let cardanoOutput = new TransactionOutput(\n      toCardanoAddress(output.address),\n      toValue(output.amount),\n    );\n    if (output.datum?.type === \"Hash\") {\n      cardanoOutput.setDatum(\n        Datum.newDataHash(fromBuilderToPlutusData(output.datum.data).hash()),\n      );\n    } else if (output.datum?.type === \"Inline\") {\n      cardanoOutput.setDatum(\n        Datum.newInlineData(fromBuilderToPlutusData(output.datum.data)),\n      );\n    } else if (output.datum?.type === \"Embedded\") {\n      throw new Error(\"Embedded datum not supported\");\n    }\n    if (output.referenceScript) {\n      switch (output.referenceScript.version) {\n        case \"V1\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV1Script(\n              PlutusV1Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        case \"V2\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV2Script(\n              PlutusV2Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        case \"V3\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV3Script(\n              PlutusV3Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        default: {\n          cardanoOutput.setScriptRef(\n            Script.newNativeScript(\n              NativeScript.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n      }\n    }\n    return cardanoOutput.toCbor();\n  }",
      "source": "mesh-core-cst",
      "implementation": "  serializeOutput(output: Output): string {\n    let cardanoOutput = new TransactionOutput(\n      toCardanoAddress(output.address),\n      toValue(output.amount),\n    );\n    if (output.datum?.type === \"Hash\") {\n      cardanoOutput.setDatum(\n        Datum.newDataHash(fromBuilderToPlutusData(output.datum.data).hash()),\n      );\n    } else if (output.datum?.type === \"Inline\") {\n      cardanoOutput.setDatum(\n        Datum.newInlineData(fromBuilderToPlutusData(output.datum.data)),\n      );\n    } else if (output.datum?.type === \"Embedded\") {\n      throw new Error(\"Embedded datum not supported\");\n    }\n    if (output.referenceScript) {\n      switch (output.referenceScript.version) {\n        case \"V1\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV1Script(\n              PlutusV1Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        case \"V2\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV2Script(\n              PlutusV2Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        case \"V3\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV3Script(\n              PlutusV3Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        default: {\n          cardanoOutput.setScriptRef(\n            Script.newNativeScript(\n              NativeScript.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n      }\n    }\n    return cardanoOutput.toCbor();\n  }"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.coreSerializeTx",
      "fullName": "mesh-core-cst:serializer.index.ts.coreSerializeTx",
      "name": "coreSerializeTx",
      "signature": "coreSerializeTx(txBuilderBody: MeshTxBuilderBody): string {",
      "documentation": "",
      "parameters": [
        {
          "name": "txBuilderBody",
          "type": "MeshTxBuilderBody",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 709,
      "raw": "  coreSerializeTx(txBuilderBody: MeshTxBuilderBody): string {\n    const bodyCore = this.coreSerializeTxBody(txBuilderBody);\n    if (txBuilderBody.fee !== undefined) {\n      this.txBody.setFee(BigInt(txBuilderBody.fee));\n    }\n    this.buildWitnessSet();\n    return new Transaction(\n      bodyCore,\n      this.txWitnessSet,\n      this.txAuxilliaryData,\n    ).toCbor();\n  }",
      "source": "mesh-core-cst",
      "implementation": "  coreSerializeTx(txBuilderBody: MeshTxBuilderBody): string {\n    const bodyCore = this.coreSerializeTxBody(txBuilderBody);\n    if (txBuilderBody.fee !== undefined) {\n      this.txBody.setFee(BigInt(txBuilderBody.fee));\n    }\n    this.buildWitnessSet();\n    return new Transaction(\n      bodyCore,\n      this.txWitnessSet,\n      this.txAuxilliaryData,\n    ).toCbor();\n  }"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.coreSerializeTxWithMockSignatures",
      "fullName": "mesh-core-cst:serializer.index.ts.coreSerializeTxWithMockSignatures",
      "name": "coreSerializeTxWithMockSignatures",
      "signature": "coreSerializeTxWithMockSignatures(txBuilderBody: MeshTxBuilderBody): string {",
      "documentation": "",
      "parameters": [
        {
          "name": "txBuilderBody",
          "type": "MeshTxBuilderBody",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 722,
      "raw": "  coreSerializeTxWithMockSignatures(txBuilderBody: MeshTxBuilderBody): string {\n    const bodyCore = this.coreSerializeTxBody(txBuilderBody);\n    const mockWitSet = this.createMockedWitnessSet(\n      txBuilderBody.expectedNumberKeyWitnesses,\n      txBuilderBody.expectedByronAddressWitnesses,\n    );\n    return new Transaction(\n      bodyCore,\n      mockWitSet,\n      this.txAuxilliaryData,\n    ).toCbor();\n  }",
      "source": "mesh-core-cst",
      "implementation": "  coreSerializeTxWithMockSignatures(txBuilderBody: MeshTxBuilderBody): string {\n    const bodyCore = this.coreSerializeTxBody(txBuilderBody);\n    const mockWitSet = this.createMockedWitnessSet(\n      txBuilderBody.expectedNumberKeyWitnesses,\n      txBuilderBody.expectedByronAddressWitnesses,\n    );\n    return new Transaction(\n      bodyCore,\n      mockWitSet,\n      this.txAuxilliaryData,\n    ).toCbor();\n  }"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.throwErrorWithOrigin",
      "fullName": "mesh-core-cst:serializer.index.ts.throwErrorWithOrigin",
      "name": "throwErrorWithOrigin",
      "signature": "const throwErrorWithOrigin = (origin: string, error: any) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "origin",
          "type": "string",
          "optional": false
        },
        {
          "name": "error",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 1819,
      "raw": "const throwErrorWithOrigin = (origin: string, error: any) => {\n  if (error instanceof Error) {\n    throw new Error(`${origin}: ${error.message}`);\n  } else if (typeof error === \"string\") {\n    throw new Error(`${origin}: ${error}`);\n  } else if (typeof error === \"object\") {\n    throw new Error(`${origin}: ${JSON.stringify(error)}`);\n  } else {\n    throw new Error(`${origin}: ${String(error)}`);\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "const throwErrorWithOrigin = (origin: string, error: any) => {\n  if (error instanceof Error) {\n    throw new Error(`${origin}: ${error.message}`);\n  } else if (typeof error === \"string\") {\n    throw new Error(`${origin}: ${error}`);\n  } else if (typeof error === \"object\") {\n    throw new Error(`${origin}: ${JSON.stringify(error)}`);\n  } else {\n    throw new Error(`${origin}: ${String(error)}`);\n  }\n};"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TransactionId",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TransactionId",
      "name": "TransactionId",
      "signature": "export const TransactionId = (value: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "value",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 17,
      "raw": "export const TransactionId = (value: string) => {\n  return Cardano.TransactionId(value);\n};",
      "source": "mesh-core-cst",
      "implementation": "export const TransactionId = (value: string) => {\n  return Cardano.TransactionId(value);\n};"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PrivateNormalKeyHex",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PrivateNormalKeyHex",
      "name": "Ed25519PrivateNormalKeyHex",
      "signature": "export const Ed25519PrivateNormalKeyHex = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 122,
      "raw": "export const Ed25519PrivateNormalKeyHex = (\n  value: string,\n): Ed25519PrivateNormalKeyHex => typedHex(value, 64);\n\nexport type Ed25519PrivateExtendedKeyHex = OpaqueString<\"Ed25519PrivateKeyHex\">;\nexport const Ed25519PrivateExtendedKeyHex = (\n  value: string,\n): Ed25519PrivateExtendedKeyHex => typedHex(value, 128);\n\nexport const Ed25519KeyHash = Crypto.Ed25519KeyHash;\nexport type Ed25519KeyHash = Crypto.Ed25519KeyHash;\n\nexport const Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;\nexport type Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;\n\nexport const Hash28ByteBase16 = Crypto.Hash28ByteBase16;\nexport type Hash28ByteBase16 = Crypto.Hash28ByteBase16;\n\nexport const Hash32ByteBase16 = (value: string) => {\n  return Crypto.Hash32ByteBase16(value);\n};",
      "source": "mesh-core-cst",
      "implementation": "export const Ed25519PrivateNormalKeyHex = (\n  value: string,\n): Ed25519PrivateNormalKeyHex => typedHex(value, 64);\n\nexport type Ed25519PrivateExtendedKeyHex = OpaqueString<\"Ed25519PrivateKeyHex\">;\nexport const Ed25519PrivateExtendedKeyHex = (\n  value: string,\n): Ed25519PrivateExtendedKeyHex => typedHex(value, 128);\n\nexport const Ed25519KeyHash = Crypto.Ed25519KeyHash;\nexport type Ed25519KeyHash = Crypto.Ed25519KeyHash;\n\nexport const Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;\nexport type Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;\n\nexport const Hash28ByteBase16 = Crypto.Hash28ByteBase16;\nexport type Hash28ByteBase16 = Crypto.Hash28ByteBase16;\n\nexport const Hash32ByteBase16 = (value: string) => {\n  return Crypto.Hash32ByteBase16(value);\n};"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PrivateExtendedKeyHex",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PrivateExtendedKeyHex",
      "name": "Ed25519PrivateExtendedKeyHex",
      "signature": "export const Ed25519PrivateExtendedKeyHex = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 127,
      "raw": "export const Ed25519PrivateExtendedKeyHex = (\n  value: string,\n): Ed25519PrivateExtendedKeyHex => typedHex(value, 128);\n\nexport const Ed25519KeyHash = Crypto.Ed25519KeyHash;\nexport type Ed25519KeyHash = Crypto.Ed25519KeyHash;\n\nexport const Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;\nexport type Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;\n\nexport const Hash28ByteBase16 = Crypto.Hash28ByteBase16;\nexport type Hash28ByteBase16 = Crypto.Hash28ByteBase16;\n\nexport const Hash32ByteBase16 = (value: string) => {\n  return Crypto.Hash32ByteBase16(value);\n};",
      "source": "mesh-core-cst",
      "implementation": "export const Ed25519PrivateExtendedKeyHex = (\n  value: string,\n): Ed25519PrivateExtendedKeyHex => typedHex(value, 128);\n\nexport const Ed25519KeyHash = Crypto.Ed25519KeyHash;\nexport type Ed25519KeyHash = Crypto.Ed25519KeyHash;\n\nexport const Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;\nexport type Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;\n\nexport const Hash28ByteBase16 = Crypto.Hash28ByteBase16;\nexport type Hash28ByteBase16 = Crypto.Hash28ByteBase16;\n\nexport const Hash32ByteBase16 = (value: string) => {\n  return Crypto.Hash32ByteBase16(value);\n};"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Hash32ByteBase16",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Hash32ByteBase16",
      "name": "Hash32ByteBase16",
      "signature": "export const Hash32ByteBase16 = (value: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "value",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 140,
      "raw": "export const Hash32ByteBase16 = (value: string) => {\n  return Crypto.Hash32ByteBase16(value);\n};",
      "source": "mesh-core-cst",
      "implementation": "export const Hash32ByteBase16 = (value: string) => {\n  return Crypto.Hash32ByteBase16(value);\n};"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.DatumHash",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.DatumHash",
      "name": "DatumHash",
      "signature": "export const DatumHash = (value: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "value",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 234,
      "raw": "export const DatumHash = (value: string) => {\n  return Crypto.Hash32ByteBase16(value);\n};",
      "source": "mesh-core-cst",
      "implementation": "export const DatumHash = (value: string) => {\n  return Crypto.Hash32ByteBase16(value);\n};"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.serialzeAddress",
      "fullName": "mesh-core-cst:utils.address.ts.serialzeAddress",
      "name": "serialzeAddress",
      "signature": "export const serialzeAddress = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 28,
      "raw": "export const serialzeAddress = (\n  deserializedAddress: Partial<DeserializedAddress>,\n  networkId = 0,\n) => {\n  const {\n    pubKeyHash,\n    scriptHash,\n    stakeCredentialHash,\n    stakeScriptCredentialHash,\n  } = deserializedAddress;\n\n  const isPaymentScript = !pubKeyHash;\n  const isStakeScript = !stakeCredentialHash;\n\n  const paymentHash = isPaymentScript ? scriptHash : pubKeyHash;\n\n  const stakeHash = isStakeScript\n    ? stakeScriptCredentialHash\n    : stakeCredentialHash;\n\n  if (!paymentHash)\n    throw new Error(\n      \"Error: serializeAddress: Address must contain a payment part\",\n    );\n\n  const addressObj = isPaymentScript\n    ? scriptAddress(paymentHash, stakeHash, isStakeScript)\n    : pubKeyAddress(paymentHash, stakeHash, isStakeScript);\n  return serializeAddressObj(addressObj, networkId);\n};",
      "source": "mesh-core-cst",
      "implementation": "export const serialzeAddress = (\n  deserializedAddress: Partial<DeserializedAddress>,\n  networkId = 0,\n) => {\n  const {\n    pubKeyHash,\n    scriptHash,\n    stakeCredentialHash,\n    stakeScriptCredentialHash,\n  } = deserializedAddress;\n\n  const isPaymentScript = !pubKeyHash;\n  const isStakeScript = !stakeCredentialHash;\n\n  const paymentHash = isPaymentScript ? scriptHash : pubKeyHash;\n\n  const stakeHash = isStakeScript\n    ? stakeScriptCredentialHash\n    : stakeCredentialHash;\n\n  if (!paymentHash)\n    throw new Error(\n      \"Error: serializeAddress: Address must contain a payment part\",\n    );\n\n  const addressObj = isPaymentScript\n    ? scriptAddress(paymentHash, stakeHash, isStakeScript)\n    : pubKeyAddress(paymentHash, stakeHash, isStakeScript);\n  return serializeAddressObj(addressObj, networkId);\n};"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.addrBech32ToPlutusData",
      "fullName": "mesh-core-cst:utils.address.ts.addrBech32ToPlutusData",
      "name": "addrBech32ToPlutusData",
      "signature": "const addrBech32ToPlutusData = (bech32: string): PlutusData => {",
      "documentation": "",
      "parameters": [
        {
          "name": "bech32",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "PlutusData",
      "isPublic": true,
      "line": 59,
      "raw": "const addrBech32ToPlutusData = (bech32: string): PlutusData => {\n  const cardanoAddress = Address.fromBech32(bech32);\n  const cardanoAddressProps = cardanoAddress.getProps();\n  const paymentPartList = new PlutusList();\n  if (!cardanoAddressProps.paymentPart) {\n    throw new Error(\n      \"Error: addrBech32ToPlutusDataHex: Address must contain a payment part\",\n    );\n  }\n  paymentPartList.add(\n    PlutusData.newBytes(\n      Buffer.from(cardanoAddressProps.paymentPart.hash, \"hex\"),\n    ),\n  );\n  const paymentPart = PlutusData.newConstrPlutusData(\n    new ConstrPlutusData(\n      BigInt(cardanoAddressProps.paymentPart.type),\n      paymentPartList,\n    ),\n  );\n  const delegationPartList = new PlutusList();\n  let delegationPart;\n  if (cardanoAddressProps.delegationPart) {\n    delegationPartList.add(\n      PlutusData.newBytes(\n        Buffer.from(cardanoAddressProps.delegationPart.hash, \"hex\"),\n      ),\n    );\n\n    // Inline(StakeCredential)\n    const inlineDelegationPart = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(0), delegationPartList),\n    );\n\n    // Some(Inline(StakeCredential))\n    const someList = new PlutusList();\n    someList.add(inlineDelegationPart);\n    delegationPart = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(0), someList),\n    );\n  } else if (cardanoAddressProps.pointer) {\n    // Pointer\n    const pointerList = new PlutusList();\n    pointerList.add(\n      PlutusData.newInteger(BigInt(cardanoAddressProps.pointer.slot)),\n    );\n    pointerList.add(\n      PlutusData.newInteger(BigInt(cardanoAddressProps.pointer.txIndex)),\n    );\n    pointerList.add(\n      PlutusData.newInteger(BigInt(cardanoAddressProps.pointer.certIndex)),\n    );\n    const pointer = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(1), pointerList),\n    );\n\n    // Some(Pointer)\n    const someList = new PlutusList();\n    someList.add(pointer);\n    delegationPart = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(0), someList),\n    );\n  } else {\n    delegationPart = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(1), new PlutusList()),\n    );\n  }\n\n  const addressList = new PlutusList();\n  addressList.add(paymentPart);\n  addressList.add(delegationPart);\n\n  return PlutusData.newConstrPlutusData(\n    new ConstrPlutusData(BigInt(0), addressList),\n  );\n};",
      "source": "mesh-core-cst",
      "implementation": "const addrBech32ToPlutusData = (bech32: string): PlutusData => {\n  const cardanoAddress = Address.fromBech32(bech32);\n  const cardanoAddressProps = cardanoAddress.getProps();\n  const paymentPartList = new PlutusList();\n  if (!cardanoAddressProps.paymentPart) {\n    throw new Error(\n      \"Error: addrBech32ToPlutusDataHex: Address must contain a payment part\",\n    );\n  }\n  paymentPartList.add(\n    PlutusData.newBytes(\n      Buffer.from(cardanoAddressProps.paymentPart.hash, \"hex\"),\n    ),\n  );\n  const paymentPart = PlutusData.newConstrPlutusData(\n    new ConstrPlutusData(\n      BigInt(cardanoAddressProps.paymentPart.type),\n      paymentPartList,\n    ),\n  );\n  const delegationPartList = new PlutusList();\n  let delegationPart;\n  if (cardanoAddressProps.delegationPart) {\n    delegationPartList.add(\n      PlutusData.newBytes(\n        Buffer.from(cardanoAddressProps.delegationPart.hash, \"hex\"),\n      ),\n    );\n\n    // Inline(StakeCredential)\n    const inlineDelegationPart = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(0), delegationPartList),\n    );\n\n    // Some(Inline(StakeCredential))\n    const someList = new PlutusList();\n    someList.add(inlineDelegationPart);\n    delegationPart = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(0), someList),\n    );\n  } else if (cardanoAddressProps.pointer) {\n    // Pointer\n    const pointerList = new PlutusList();\n    pointerList.add(\n      PlutusData.newInteger(BigInt(cardanoAddressProps.pointer.slot)),\n    );\n    pointerList.add(\n      PlutusData.newInteger(BigInt(cardanoAddressProps.pointer.txIndex)),\n    );\n    pointerList.add(\n      PlutusData.newInteger(BigInt(cardanoAddressProps.pointer.certIndex)),\n    );\n    const pointer = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(1), pointerList),\n    );\n\n    // Some(Pointer)\n    const someList = new PlutusList();\n    someList.add(pointer);\n    delegationPart = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(0), someList),\n    );\n  } else {\n    delegationPart = PlutusData.newConstrPlutusData(\n      new ConstrPlutusData(BigInt(1), new PlutusList()),\n    );\n  }\n\n  const addressList = new PlutusList();\n  addressList.add(paymentPart);\n  addressList.add(delegationPart);\n\n  return PlutusData.newConstrPlutusData(\n    new ConstrPlutusData(BigInt(0), addressList),\n  );\n};"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.addrBech32ToPlutusDataHex",
      "fullName": "mesh-core-cst:utils.address.ts.addrBech32ToPlutusDataHex",
      "name": "addrBech32ToPlutusDataHex",
      "signature": "export const addrBech32ToPlutusDataHex = (bech32: string): string => {",
      "documentation": "",
      "parameters": [
        {
          "name": "bech32",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 136,
      "raw": "export const addrBech32ToPlutusDataHex = (bech32: string): string => {\n  return addrBech32ToPlutusData(bech32).toCbor();\n};",
      "source": "mesh-core-cst",
      "implementation": "export const addrBech32ToPlutusDataHex = (bech32: string): string => {\n  return addrBech32ToPlutusData(bech32).toCbor();\n};"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.plutusDataToAddrBech32",
      "fullName": "mesh-core-cst:utils.address.ts.plutusDataToAddrBech32",
      "name": "plutusDataToAddrBech32",
      "signature": "const plutusDataToAddrBech32 = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 144,
      "raw": "const plutusDataToAddrBech32 = (\n  plutusData: PlutusData,\n  networkId = 0,\n): string => {\n  const constrPlutusData = plutusData.asConstrPlutusData();\n  if (!constrPlutusData || constrPlutusData.getAlternative() !== BigInt(0)) {\n    throw new Error(\n      \"Error: serializeAddressObj: Address must contain a constructor 0\",\n    );\n  }\n\n  const plutusDataList = constrPlutusData.getData();\n  if (plutusDataList.getLength() !== 2) {\n    throw new Error(\"Error: serializeAddressObj: Address must contain 2 parts\");\n  }\n\n  const paymentData = plutusDataList.get(0);\n  const paymentConstrData = paymentData.asConstrPlutusData();\n  if (!paymentConstrData) {\n    throw new Error(\n      \"Error: serializeAddressObj: Payment part must be a constructor\",\n    );\n  }\n\n  const paymentConstrDataList = paymentConstrData.getData();\n  if (paymentConstrDataList.getLength() !== 1) {\n    throw new Error(\n      \"Error: serializeAddressObj: Payment part must contain 1 element\",\n    );\n  }\n\n  const paymentBytes = paymentConstrDataList.get(0).asBoundedBytes();\n  if (!paymentBytes) {\n    throw new Error(\n      \"Error: serializeAddressObj: Payment inner part must be bytes\",\n    );\n  }\n\n  if (\n    paymentConstrData.getAlternative() !== BigInt(0) &&\n    paymentConstrData.getAlternative() !== BigInt(1)\n  ) {\n    throw new Error(\n      \"Error: serializeAddressObj: Payment part must be alternative 0 or 1\",\n    );\n  }\n  const cardanoPaymentCredential = {\n    hash: Hash28ByteBase16(Buffer.from(paymentBytes).toString(\"hex\")),\n    type: Number(paymentConstrData.getAlternative()),\n  };\n\n  const delegationData = plutusDataList.get(1);\n  // Option<Referenced<Credential>>\n  const delegationConstrData = delegationData.asConstrPlutusData();\n  if (!delegationConstrData) {\n    throw new Error(\n      \"Error: serializeAddressObj: Delegation part must be a constructor\",\n    );\n  }\n\n  if (delegationConstrData.getAlternative() === BigInt(1)) {\n    return EnterpriseAddress.fromCredentials(\n      networkId,\n      cardanoPaymentCredential,\n    )\n      .toAddress()\n      .toBech32()\n      .toString();\n  } else if (delegationConstrData.getAlternative() === BigInt(0)) {\n    const delegationDataList = delegationConstrData.getData();\n    if (delegationDataList.getLength() !== 1) {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation part must contain 1 element\",\n      );\n    }\n\n    const delegationDataInner = delegationDataList.get(0);\n    // Referenced<Credential>\n    const delegationDataInnerConstrData =\n      delegationDataInner.asConstrPlutusData();\n    if (!delegationDataInnerConstrData) {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation inner part must be a constructor\",\n      );\n    }\n\n    if (delegationDataInnerConstrData.getAlternative() === BigInt(0)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 1 element\",\n        );\n      }\n      // Credential\n      const delegationCredential = delegationDataInnerList\n        .get(0)\n        .asConstrPlutusData();\n      if (!delegationCredential) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must be a constructor\",\n        );\n      }\n\n      const delegationBytesList = delegationCredential.getData();\n      if (delegationBytesList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must contain 1 element\",\n        );\n      }\n\n      const delegationBytes = delegationBytesList.get(0).asBoundedBytes();\n      if (!delegationBytes) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must be of type bytes\",\n        );\n      }\n\n      const cardanoStakeCredential = {\n        hash: Hash28ByteBase16(Buffer.from(delegationBytes).toString(\"hex\")),\n        type: Number(delegationCredential.getAlternative()),\n      };\n\n      return BaseAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoStakeCredential,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else if (delegationDataInnerConstrData.getAlternative() === BigInt(1)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 3) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 3 elements\",\n        );\n      }\n\n      const slot = delegationDataInnerList.get(0).asInteger();\n      if (!slot) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part slot must be integer\",\n        );\n      }\n\n      const txIndex = delegationDataInnerList.get(1).asInteger();\n      if (!txIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part txIndex must be integer\",\n        );\n      }\n\n      const certIndex = delegationDataInnerList.get(2).asInteger();\n      if (!certIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part certIndex must be integer\",\n        );\n      }\n\n      const cardanoPointer = {\n        slot: slot,\n        txIndex: TxIndex(Number(txIndex)),\n        certIndex: CertIndex(Number(certIndex)),\n      };\n\n      return PointerAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoPointer,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation inner part must be alternative 0 or 1\",\n      );\n    }\n  } else {\n    throw new Error(\n      \"Error: serializeAddressObj: Delegation part must be alternative 0 or 1\",\n    );\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "const plutusDataToAddrBech32 = (\n  plutusData: PlutusData,\n  networkId = 0,\n): string => {\n  const constrPlutusData = plutusData.asConstrPlutusData();\n  if (!constrPlutusData || constrPlutusData.getAlternative() !== BigInt(0)) {\n    throw new Error(\n      \"Error: serializeAddressObj: Address must contain a constructor 0\",\n    );\n  }\n\n  const plutusDataList = constrPlutusData.getData();\n  if (plutusDataList.getLength() !== 2) {\n    throw new Error(\"Error: serializeAddressObj: Address must contain 2 parts\");\n  }\n\n  const paymentData = plutusDataList.get(0);\n  const paymentConstrData = paymentData.asConstrPlutusData();\n  if (!paymentConstrData) {\n    throw new Error(\n      \"Error: serializeAddressObj: Payment part must be a constructor\",\n    );\n  }\n\n  const paymentConstrDataList = paymentConstrData.getData();\n  if (paymentConstrDataList.getLength() !== 1) {\n    throw new Error(\n      \"Error: serializeAddressObj: Payment part must contain 1 element\",\n    );\n  }\n\n  const paymentBytes = paymentConstrDataList.get(0).asBoundedBytes();\n  if (!paymentBytes) {\n    throw new Error(\n      \"Error: serializeAddressObj: Payment inner part must be bytes\",\n    );\n  }\n\n  if (\n    paymentConstrData.getAlternative() !== BigInt(0) &&\n    paymentConstrData.getAlternative() !== BigInt(1)\n  ) {\n    throw new Error(\n      \"Error: serializeAddressObj: Payment part must be alternative 0 or 1\",\n    );\n  }\n  const cardanoPaymentCredential = {\n    hash: Hash28ByteBase16(Buffer.from(paymentBytes).toString(\"hex\")),\n    type: Number(paymentConstrData.getAlternative()),\n  };\n\n  const delegationData = plutusDataList.get(1);\n  // Option<Referenced<Credential>>\n  const delegationConstrData = delegationData.asConstrPlutusData();\n  if (!delegationConstrData) {\n    throw new Error(\n      \"Error: serializeAddressObj: Delegation part must be a constructor\",\n    );\n  }\n\n  if (delegationConstrData.getAlternative() === BigInt(1)) {\n    return EnterpriseAddress.fromCredentials(\n      networkId,\n      cardanoPaymentCredential,\n    )\n      .toAddress()\n      .toBech32()\n      .toString();\n  } else if (delegationConstrData.getAlternative() === BigInt(0)) {\n    const delegationDataList = delegationConstrData.getData();\n    if (delegationDataList.getLength() !== 1) {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation part must contain 1 element\",\n      );\n    }\n\n    const delegationDataInner = delegationDataList.get(0);\n    // Referenced<Credential>\n    const delegationDataInnerConstrData =\n      delegationDataInner.asConstrPlutusData();\n    if (!delegationDataInnerConstrData) {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation inner part must be a constructor\",\n      );\n    }\n\n    if (delegationDataInnerConstrData.getAlternative() === BigInt(0)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 1 element\",\n        );\n      }\n      // Credential\n      const delegationCredential = delegationDataInnerList\n        .get(0)\n        .asConstrPlutusData();\n      if (!delegationCredential) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must be a constructor\",\n        );\n      }\n\n      const delegationBytesList = delegationCredential.getData();\n      if (delegationBytesList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must contain 1 element\",\n        );\n      }\n\n      const delegationBytes = delegationBytesList.get(0).asBoundedBytes();\n      if (!delegationBytes) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must be of type bytes\",\n        );\n      }\n\n      const cardanoStakeCredential = {\n        hash: Hash28ByteBase16(Buffer.from(delegationBytes).toString(\"hex\")),\n        type: Number(delegationCredential.getAlternative()),\n      };\n\n      return BaseAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoStakeCredential,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else if (delegationDataInnerConstrData.getAlternative() === BigInt(1)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 3) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 3 elements\",\n        );\n      }\n\n      const slot = delegationDataInnerList.get(0).asInteger();\n      if (!slot) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part slot must be integer\",\n        );\n      }\n\n      const txIndex = delegationDataInnerList.get(1).asInteger();\n      if (!txIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part txIndex must be integer\",\n        );\n      }\n\n      const certIndex = delegationDataInnerList.get(2).asInteger();\n      if (!certIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part certIndex must be integer\",\n        );\n      }\n\n      const cardanoPointer = {\n        slot: slot,\n        txIndex: TxIndex(Number(txIndex)),\n        certIndex: CertIndex(Number(certIndex)),\n      };\n\n      return PointerAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoPointer,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation inner part must be alternative 0 or 1\",\n      );\n    }\n  } else {\n    throw new Error(\n      \"Error: serializeAddressObj: Delegation part must be alternative 0 or 1\",\n    );\n  }\n};"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.if",
      "fullName": "mesh-core-cst:utils.address.ts.if",
      "name": "if",
      "signature": "if (delegationDataInnerConstrData.getAlternative() === BigInt(0)) {",
      "documentation": "",
      "parameters": [
        {
          "name": "delegationDataInnerConstrData.getAlternative(",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 230,
      "raw": "    if (delegationDataInnerConstrData.getAlternative() === BigInt(0)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 1 element\",\n        );\n      }\n      // Credential\n      const delegationCredential = delegationDataInnerList\n        .get(0)\n        .asConstrPlutusData();\n      if (!delegationCredential) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must be a constructor\",\n        );\n      }\n\n      const delegationBytesList = delegationCredential.getData();\n      if (delegationBytesList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must contain 1 element\",\n        );\n      }\n\n      const delegationBytes = delegationBytesList.get(0).asBoundedBytes();\n      if (!delegationBytes) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must be of type bytes\",\n        );\n      }\n\n      const cardanoStakeCredential = {\n        hash: Hash28ByteBase16(Buffer.from(delegationBytes).toString(\"hex\")),\n        type: Number(delegationCredential.getAlternative()),\n      };\n\n      return BaseAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoStakeCredential,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else if (delegationDataInnerConstrData.getAlternative() === BigInt(1)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 3) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 3 elements\",\n        );\n      }\n\n      const slot = delegationDataInnerList.get(0).asInteger();\n      if (!slot) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part slot must be integer\",\n        );\n      }\n\n      const txIndex = delegationDataInnerList.get(1).asInteger();\n      if (!txIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part txIndex must be integer\",\n        );\n      }\n\n      const certIndex = delegationDataInnerList.get(2).asInteger();\n      if (!certIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part certIndex must be integer\",\n        );\n      }\n\n      const cardanoPointer = {\n        slot: slot,\n        txIndex: TxIndex(Number(txIndex)),\n        certIndex: CertIndex(Number(certIndex)),\n      };\n\n      return PointerAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoPointer,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation inner part must be alternative 0 or 1\",\n      );\n    }",
      "source": "mesh-core-cst",
      "implementation": "    if (delegationDataInnerConstrData.getAlternative() === BigInt(0)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 1 element\",\n        );\n      }\n      // Credential\n      const delegationCredential = delegationDataInnerList\n        .get(0)\n        .asConstrPlutusData();\n      if (!delegationCredential) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must be a constructor\",\n        );\n      }\n\n      const delegationBytesList = delegationCredential.getData();\n      if (delegationBytesList.getLength() !== 1) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must contain 1 element\",\n        );\n      }\n\n      const delegationBytes = delegationBytesList.get(0).asBoundedBytes();\n      if (!delegationBytes) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation bytes part must be of type bytes\",\n        );\n      }\n\n      const cardanoStakeCredential = {\n        hash: Hash28ByteBase16(Buffer.from(delegationBytes).toString(\"hex\")),\n        type: Number(delegationCredential.getAlternative()),\n      };\n\n      return BaseAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoStakeCredential,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else if (delegationDataInnerConstrData.getAlternative() === BigInt(1)) {\n      const delegationDataInnerList = delegationDataInnerConstrData.getData();\n      if (delegationDataInnerList.getLength() !== 3) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part must contain 3 elements\",\n        );\n      }\n\n      const slot = delegationDataInnerList.get(0).asInteger();\n      if (!slot) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part slot must be integer\",\n        );\n      }\n\n      const txIndex = delegationDataInnerList.get(1).asInteger();\n      if (!txIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part txIndex must be integer\",\n        );\n      }\n\n      const certIndex = delegationDataInnerList.get(2).asInteger();\n      if (!certIndex) {\n        throw new Error(\n          \"Error: serializeAddressObj: Delegation inner part certIndex must be integer\",\n        );\n      }\n\n      const cardanoPointer = {\n        slot: slot,\n        txIndex: TxIndex(Number(txIndex)),\n        certIndex: CertIndex(Number(certIndex)),\n      };\n\n      return PointerAddress.fromCredentials(\n        networkId,\n        cardanoPaymentCredential,\n        cardanoPointer,\n      )\n        .toAddress()\n        .toBech32()\n        .toString();\n    } else {\n      throw new Error(\n        \"Error: serializeAddressObj: Delegation inner part must be alternative 0 or 1\",\n      );\n    }"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.serializeAddressObj",
      "fullName": "mesh-core-cst:utils.address.ts.serializeAddressObj",
      "name": "serializeAddressObj",
      "signature": "export const serializeAddressObj = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 329,
      "raw": "export const serializeAddressObj = (\n  plutusDataAddressObject: PubKeyAddress | ScriptAddress,\n  networkId = 0,\n): string => {\n  const cardanoPlutusData = fromJsonToPlutusData(plutusDataAddressObject);\n  return plutusDataToAddrBech32(cardanoPlutusData, networkId);\n};",
      "source": "mesh-core-cst",
      "implementation": "export const serializeAddressObj = (\n  plutusDataAddressObject: PubKeyAddress | ScriptAddress,\n  networkId = 0,\n): string => {\n  const cardanoPlutusData = fromJsonToPlutusData(plutusDataAddressObject);\n  return plutusDataToAddrBech32(cardanoPlutusData, networkId);\n};"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.serializePlutusAddressToBech32",
      "fullName": "mesh-core-cst:utils.address.ts.serializePlutusAddressToBech32",
      "name": "serializePlutusAddressToBech32",
      "signature": "export const serializePlutusAddressToBech32 = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 337,
      "raw": "export const serializePlutusAddressToBech32 = (\n  plutusHex: string,\n  networkId = 0,\n) => {\n  const cardanoPlutusData = PlutusData.fromCbor(HexBlob(plutusHex));\n  return plutusDataToAddrBech32(cardanoPlutusData, networkId).toString();\n};",
      "source": "mesh-core-cst",
      "implementation": "export const serializePlutusAddressToBech32 = (\n  plutusHex: string,\n  networkId = 0,\n) => {\n  const cardanoPlutusData = PlutusData.fromCbor(HexBlob(plutusHex));\n  return plutusDataToAddrBech32(cardanoPlutusData, networkId).toString();\n};"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.deserializeBech32Address",
      "fullName": "mesh-core-cst:utils.address.ts.deserializeBech32Address",
      "name": "deserializeBech32Address",
      "signature": "export const deserializeBech32Address = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 345,
      "raw": "export const deserializeBech32Address = (\n  bech32Addr: string,\n): DeserializedAddress => {\n  const deserializedAddress = Address.fromBech32(bech32Addr).getProps();\n  return {\n    pubKeyHash:\n      deserializedAddress.paymentPart?.type === CredentialType.KeyHash\n        ? deserializedAddress.paymentPart?.hash\n        : \"\",\n    scriptHash:\n      deserializedAddress.paymentPart?.type === CredentialType.ScriptHash\n        ? deserializedAddress.paymentPart?.hash\n        : \"\",\n    stakeCredentialHash:\n      deserializedAddress.delegationPart?.type === CredentialType.KeyHash\n        ? deserializedAddress.delegationPart?.hash\n        : \"\",\n    stakeScriptCredentialHash:\n      deserializedAddress.delegationPart?.type === CredentialType.ScriptHash\n        ? deserializedAddress.delegationPart?.hash\n        : \"\",\n  };\n};",
      "source": "mesh-core-cst",
      "implementation": "export const deserializeBech32Address = (\n  bech32Addr: string,\n): DeserializedAddress => {\n  const deserializedAddress = Address.fromBech32(bech32Addr).getProps();\n  return {\n    pubKeyHash:\n      deserializedAddress.paymentPart?.type === CredentialType.KeyHash\n        ? deserializedAddress.paymentPart?.hash\n        : \"\",\n    scriptHash:\n      deserializedAddress.paymentPart?.type === CredentialType.ScriptHash\n        ? deserializedAddress.paymentPart?.hash\n        : \"\",\n    stakeCredentialHash:\n      deserializedAddress.delegationPart?.type === CredentialType.KeyHash\n        ? deserializedAddress.delegationPart?.hash\n        : \"\",\n    stakeScriptCredentialHash:\n      deserializedAddress.delegationPart?.type === CredentialType.ScriptHash\n        ? deserializedAddress.delegationPart?.hash\n        : \"\",\n  };\n};"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.deserializeAddress",
      "fullName": "mesh-core-cst:utils.address.ts.deserializeAddress",
      "name": "deserializeAddress",
      "signature": "export const deserializeAddress = (address: string): Address => {",
      "documentation": "",
      "parameters": [
        {
          "name": "address",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Address",
      "isPublic": true,
      "line": 369,
      "raw": "export const deserializeAddress = (address: string): Address => {\n  const _address = Address.fromString(address);\n  if (_address === null) throw new Error(\"Invalid address\");\n  return _address;\n};",
      "source": "mesh-core-cst",
      "implementation": "export const deserializeAddress = (address: string): Address => {\n  const _address = Address.fromString(address);\n  if (_address === null) throw new Error(\"Invalid address\");\n  return _address;\n};"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.scriptHashToBech32",
      "fullName": "mesh-core-cst:utils.address.ts.scriptHashToBech32",
      "name": "scriptHashToBech32",
      "signature": "export const scriptHashToBech32 = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 375,
      "raw": "export const scriptHashToBech32 = (\n  scriptHash: string,\n  stakeCredentialHash?: string,\n  networkId = 0,\n  isScriptStakeCredentialHash = false,\n) => {\n  if (stakeCredentialHash) {\n    return BaseAddress.fromCredentials(\n      networkId,\n      { hash: Hash28ByteBase16(scriptHash), type: CredentialType.ScriptHash },\n      {\n        hash: Hash28ByteBase16(stakeCredentialHash),\n        type: isScriptStakeCredentialHash\n          ? CredentialType.ScriptHash\n          : CredentialType.KeyHash,\n      },\n    )\n      .toAddress()\n      .toBech32()\n      .toString();\n  } else {\n    return EnterpriseAddress.fromCredentials(networkId, {\n      hash: Hash28ByteBase16(scriptHash),\n      type: CredentialType.ScriptHash,\n    })\n      .toAddress()\n      .toBech32()\n      .toString();\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const scriptHashToBech32 = (\n  scriptHash: string,\n  stakeCredentialHash?: string,\n  networkId = 0,\n  isScriptStakeCredentialHash = false,\n) => {\n  if (stakeCredentialHash) {\n    return BaseAddress.fromCredentials(\n      networkId,\n      { hash: Hash28ByteBase16(scriptHash), type: CredentialType.ScriptHash },\n      {\n        hash: Hash28ByteBase16(stakeCredentialHash),\n        type: isScriptStakeCredentialHash\n          ? CredentialType.ScriptHash\n          : CredentialType.KeyHash,\n      },\n    )\n      .toAddress()\n      .toBech32()\n      .toString();\n  } else {\n    return EnterpriseAddress.fromCredentials(networkId, {\n      hash: Hash28ByteBase16(scriptHash),\n      type: CredentialType.ScriptHash,\n    })\n      .toAddress()\n      .toBech32()\n      .toString();\n  }\n};"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.v2ScriptToBech32",
      "fullName": "mesh-core-cst:utils.address.ts.v2ScriptToBech32",
      "name": "v2ScriptToBech32",
      "signature": "export const v2ScriptToBech32 = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 406,
      "raw": "export const v2ScriptToBech32 = (\n  scriptCbor: string,\n  stakeCredential?: string,\n  networkId = 0,\n  isScriptStakeCredential = false,\n) =>\n  scriptHashToBech32(\n    Script.fromCbor(HexBlob(scriptCbor)).hash().toString(),\n    stakeCredential,\n    networkId,\n    isScriptStakeCredential,\n  );\n\nexport const scriptHashToRewardAddress = (hash: string, networkId = 0) => {\n  return RewardAddress.fromCredentials(networkId, {\n    hash: Hash28ByteBase16(hash),\n    type: CredentialType.ScriptHash,\n  })\n    .toAddress()\n    .toBech32()\n    .toString();\n};",
      "source": "mesh-core-cst",
      "implementation": "export const v2ScriptToBech32 = (\n  scriptCbor: string,\n  stakeCredential?: string,\n  networkId = 0,\n  isScriptStakeCredential = false,\n) =>\n  scriptHashToBech32(\n    Script.fromCbor(HexBlob(scriptCbor)).hash().toString(),\n    stakeCredential,\n    networkId,\n    isScriptStakeCredential,\n  );\n\nexport const scriptHashToRewardAddress = (hash: string, networkId = 0) => {\n  return RewardAddress.fromCredentials(networkId, {\n    hash: Hash28ByteBase16(hash),\n    type: CredentialType.ScriptHash,\n  })\n    .toAddress()\n    .toBech32()\n    .toString();\n};"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.scriptHashToRewardAddress",
      "fullName": "mesh-core-cst:utils.address.ts.scriptHashToRewardAddress",
      "name": "scriptHashToRewardAddress",
      "signature": "export const scriptHashToRewardAddress = (hash: string, networkId = 0) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "hash",
          "type": "string",
          "optional": false
        },
        {
          "name": "networkId",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 419,
      "raw": "export const scriptHashToRewardAddress = (hash: string, networkId = 0) => {\n  return RewardAddress.fromCredentials(networkId, {\n    hash: Hash28ByteBase16(hash),\n    type: CredentialType.ScriptHash,\n  })\n    .toAddress()\n    .toBech32()\n    .toString();\n};",
      "source": "mesh-core-cst",
      "implementation": "export const scriptHashToRewardAddress = (hash: string, networkId = 0) => {\n  return RewardAddress.fromCredentials(networkId, {\n    hash: Hash28ByteBase16(hash),\n    type: CredentialType.ScriptHash,\n  })\n    .toAddress()\n    .toBech32()\n    .toString();\n};"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.keyHashToRewardAddress",
      "fullName": "mesh-core-cst:utils.address.ts.keyHashToRewardAddress",
      "name": "keyHashToRewardAddress",
      "signature": "export const keyHashToRewardAddress = (hash: string, networkId = 0) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "hash",
          "type": "string",
          "optional": false
        },
        {
          "name": "networkId",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 429,
      "raw": "export const keyHashToRewardAddress = (hash: string, networkId = 0) => {\n  return RewardAddress.fromCredentials(networkId, {\n    hash: Hash28ByteBase16(hash),\n    type: CredentialType.KeyHash,\n  })\n    .toAddress()\n    .toBech32()\n    .toString();\n};",
      "source": "mesh-core-cst",
      "implementation": "export const keyHashToRewardAddress = (hash: string, networkId = 0) => {\n  return RewardAddress.fromCredentials(networkId, {\n    hash: Hash28ByteBase16(hash),\n    type: CredentialType.KeyHash,\n  })\n    .toAddress()\n    .toBech32()\n    .toString();\n};"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.buildBaseAddress",
      "fullName": "mesh-core-cst:utils.builder.ts.buildBaseAddress",
      "name": "buildBaseAddress",
      "signature": "export const buildBaseAddress = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 28,
      "raw": "export const buildBaseAddress = (\n  networkId: number,\n  paymentKeyHash: Hash28ByteBase16,\n  stakeKeyHash: Hash28ByteBase16,\n): BaseAddress => {\n  return BaseAddress.fromCredentials(\n    networkId,\n    {\n      hash: paymentKeyHash,\n      type: CredentialType.KeyHash,\n    },\n    {\n      hash: stakeKeyHash,\n      type: CredentialType.KeyHash,\n    },\n  );\n};",
      "source": "mesh-core-cst",
      "implementation": "export const buildBaseAddress = (\n  networkId: number,\n  paymentKeyHash: Hash28ByteBase16,\n  stakeKeyHash: Hash28ByteBase16,\n): BaseAddress => {\n  return BaseAddress.fromCredentials(\n    networkId,\n    {\n      hash: paymentKeyHash,\n      type: CredentialType.KeyHash,\n    },\n    {\n      hash: stakeKeyHash,\n      type: CredentialType.KeyHash,\n    },\n  );\n};"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.buildEnterpriseAddress",
      "fullName": "mesh-core-cst:utils.builder.ts.buildEnterpriseAddress",
      "name": "buildEnterpriseAddress",
      "signature": "export const buildEnterpriseAddress = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 46,
      "raw": "export const buildEnterpriseAddress = (\n  networkId: number,\n  paymentKeyHash: Hash28ByteBase16,\n): EnterpriseAddress => {\n  return EnterpriseAddress.fromCredentials(networkId, {\n    hash: paymentKeyHash,\n    type: CredentialType.KeyHash,\n  });\n};",
      "source": "mesh-core-cst",
      "implementation": "export const buildEnterpriseAddress = (\n  networkId: number,\n  paymentKeyHash: Hash28ByteBase16,\n): EnterpriseAddress => {\n  return EnterpriseAddress.fromCredentials(networkId, {\n    hash: paymentKeyHash,\n    type: CredentialType.KeyHash,\n  });\n};"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.clampScalar",
      "fullName": "mesh-core-cst:utils.builder.ts.clampScalar",
      "name": "clampScalar",
      "signature": "export const clampScalar = (scalar: Buffer): Buffer => {",
      "documentation": "",
      "parameters": [
        {
          "name": "scalar",
          "type": "Buffer",
          "optional": false
        }
      ],
      "returnType": "Buffer",
      "isPublic": true,
      "line": 56,
      "raw": "export const clampScalar = (scalar: Buffer): Buffer => {\n  if (scalar[0] !== undefined) {\n    scalar[0] &= 0b1111_1000;\n  }\n  if (scalar[31] !== undefined) {\n    scalar[31] &= 0b0001_1111;\n    scalar[31] |= 0b0100_0000;\n  }\n  return scalar;\n};",
      "source": "mesh-core-cst",
      "implementation": "export const clampScalar = (scalar: Buffer): Buffer => {\n  if (scalar[0] !== undefined) {\n    scalar[0] &= 0b1111_1000;\n  }\n  if (scalar[31] !== undefined) {\n    scalar[31] &= 0b0001_1111;\n    scalar[31] |= 0b0100_0000;\n  }\n  return scalar;\n};"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.buildBip32PrivateKey",
      "fullName": "mesh-core-cst:utils.builder.ts.buildBip32PrivateKey",
      "name": "buildBip32PrivateKey",
      "signature": "export const buildBip32PrivateKey = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 67,
      "raw": "export const buildBip32PrivateKey = (\n  entropy: string,\n  password = \"\",\n): Bip32PrivateKey => {\n  const PBKDF2_ITERATIONS = 4096;\n  const PBKDF2_KEY_SIZE = 96;\n  const PBKDF2_DIGEST_ALGORITHM = \"sha512\";\n\n  const _entropy = Buffer.from(entropy, \"hex\");\n\n  const xprv = pbkdf2Sync(\n    password,\n    _entropy,\n    PBKDF2_ITERATIONS,\n    PBKDF2_KEY_SIZE,\n    PBKDF2_DIGEST_ALGORITHM,\n  );\n  return Bip32PrivateKey.fromBytes(clampScalar(xprv));\n};",
      "source": "mesh-core-cst",
      "implementation": "export const buildBip32PrivateKey = (\n  entropy: string,\n  password = \"\",\n): Bip32PrivateKey => {\n  const PBKDF2_ITERATIONS = 4096;\n  const PBKDF2_KEY_SIZE = 96;\n  const PBKDF2_DIGEST_ALGORITHM = \"sha512\";\n\n  const _entropy = Buffer.from(entropy, \"hex\");\n\n  const xprv = pbkdf2Sync(\n    password,\n    _entropy,\n    PBKDF2_ITERATIONS,\n    PBKDF2_KEY_SIZE,\n    PBKDF2_DIGEST_ALGORITHM,\n  );\n  return Bip32PrivateKey.fromBytes(clampScalar(xprv));\n};"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.buildRewardAddress",
      "fullName": "mesh-core-cst:utils.builder.ts.buildRewardAddress",
      "name": "buildRewardAddress",
      "signature": "export const buildRewardAddress = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 87,
      "raw": "export const buildRewardAddress = (\n  networkId: number,\n  stakeKeyHash: Hash28ByteBase16,\n): RewardAddress => {\n  const cred = {\n    type: CredentialType.KeyHash,\n    hash: stakeKeyHash,\n  };\n  return RewardAddress.fromCredentials(networkId, cred);\n};",
      "source": "mesh-core-cst",
      "implementation": "export const buildRewardAddress = (\n  networkId: number,\n  stakeKeyHash: Hash28ByteBase16,\n): RewardAddress => {\n  const cred = {\n    type: CredentialType.KeyHash,\n    hash: stakeKeyHash,\n  };\n  return RewardAddress.fromCredentials(networkId, cred);\n};"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.buildKeys",
      "fullName": "mesh-core-cst:utils.builder.ts.buildKeys",
      "name": "buildKeys",
      "signature": "export const buildKeys = (",
      "documentation": "/**\n * Build a set of keys from a given private key\n *\n * NOTE - Must be called after `await Crypto.Ready()`\n *\n * @param privateKeyHex - The BIP32 private key hex to derive keys from\n * @param accountIndex - The account index to derive keys for\n * @param keyIndex - The key index to derive keys for\n * @returns The payment and stake keys, and optionally the dRep key if a Bip32PrivateKey is provided\n */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 108,
      "raw": "/**\n * Build a set of keys from a given private key\n *\n * NOTE - Must be called after `await Crypto.Ready()`\n *\n * @param privateKeyHex - The BIP32 private key hex to derive keys from\n * @param accountIndex - The account index to derive keys for\n * @param keyIndex - The key index to derive keys for\n * @returns The payment and stake keys, and optionally the dRep key if a Bip32PrivateKey is provided\n */\nexport const buildKeys = (\n  privateKeyHex: string | [string, string],\n  accountIndex: number,\n  keyIndex = 0,\n): {\n  paymentKey: Ed25519PrivateKey;\n  stakeKey: Ed25519PrivateKey;\n  dRepKey?: Ed25519PrivateKey;\n} => {\n  if (typeof privateKeyHex === \"string\") {\n    const privateKey = Bip32PrivateKey.fromHex(\n      Bip32PrivateKeyHex(privateKeyHex),\n    );\n\n    // hardened derivation\n    const accountKey = privateKey.derive([\n      HARDENED_KEY_START + 1852, // purpose\n      HARDENED_KEY_START + 1815, // coin type\n      HARDENED_KEY_START + accountIndex, // account index\n    ]);\n\n    const paymentKey = accountKey.derive([0, keyIndex]).toRawKey(); // external chain, payment key index\n    const stakeKey = accountKey.derive([2, 0]).toRawKey(); // staking key, index 0\n    const dRepKey = accountKey.derive([3, keyIndex]).toRawKey(); // dRep Keys, index\n\n    return { paymentKey, stakeKey, dRepKey };\n  } else {\n    const paymentKey = Ed25519PrivateKey.fromNormalHex(\n      Ed25519PrivateNormalKeyHex(privateKeyHex[0]),\n    );\n    const stakeKey = Ed25519PrivateKey.fromNormalHex(\n      Ed25519PrivateNormalKeyHex(privateKeyHex[1]),\n    );\n\n    return { paymentKey, stakeKey };\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const buildKeys = (\n  privateKeyHex: string | [string, string],\n  accountIndex: number,\n  keyIndex = 0,\n): {\n  paymentKey: Ed25519PrivateKey;\n  stakeKey: Ed25519PrivateKey;\n  dRepKey?: Ed25519PrivateKey;\n} => {\n  if (typeof privateKeyHex === \"string\") {\n    const privateKey = Bip32PrivateKey.fromHex(\n      Bip32PrivateKeyHex(privateKeyHex),\n    );\n\n    // hardened derivation\n    const accountKey = privateKey.derive([\n      HARDENED_KEY_START + 1852, // purpose\n      HARDENED_KEY_START + 1815, // coin type\n      HARDENED_KEY_START + accountIndex, // account index\n    ]);\n\n    const paymentKey = accountKey.derive([0, keyIndex]).toRawKey(); // external chain, payment key index\n    const stakeKey = accountKey.derive([2, 0]).toRawKey(); // staking key, index 0\n    const dRepKey = accountKey.derive([3, keyIndex]).toRawKey(); // dRep Keys, index\n\n    return { paymentKey, stakeKey, dRepKey };\n  } else {\n    const paymentKey = Ed25519PrivateKey.fromNormalHex(\n      Ed25519PrivateNormalKeyHex(privateKeyHex[0]),\n    );\n    const stakeKey = Ed25519PrivateKey.fromNormalHex(\n      Ed25519PrivateNormalKeyHex(privateKeyHex[1]),\n    );\n\n    return { paymentKey, stakeKey };\n  }\n};"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.buildEd25519PrivateKeyFromSecretKey",
      "fullName": "mesh-core-cst:utils.builder.ts.buildEd25519PrivateKeyFromSecretKey",
      "name": "buildEd25519PrivateKeyFromSecretKey",
      "signature": "export const buildEd25519PrivateKeyFromSecretKey = (secretKeyHex: string) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "secretKeyHex",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 146,
      "raw": "export const buildEd25519PrivateKeyFromSecretKey = (secretKeyHex: string) => {\n  return Ed25519PrivateKey.fromExtendedBytes(\n    new Uint8Array(\n      clampScalar(\n        Buffer.from(\n          hash.sha512().update(Buffer.from(secretKeyHex, \"hex\")).digest(),\n        ),\n      ),\n    ),\n  );\n};",
      "source": "mesh-core-cst",
      "implementation": "export const buildEd25519PrivateKeyFromSecretKey = (secretKeyHex: string) => {\n  return Ed25519PrivateKey.fromExtendedBytes(\n    new Uint8Array(\n      clampScalar(\n        Buffer.from(\n          hash.sha512().update(Buffer.from(secretKeyHex, \"hex\")).digest(),\n        ),\n      ),\n    ),\n  );\n};"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.buildScriptPubkey",
      "fullName": "mesh-core-cst:utils.builder.ts.buildScriptPubkey",
      "name": "buildScriptPubkey",
      "signature": "export const buildScriptPubkey = (keyHash: Ed25519KeyHash): NativeScript => {",
      "documentation": "",
      "parameters": [
        {
          "name": "keyHash",
          "type": "Ed25519KeyHash",
          "optional": false
        }
      ],
      "returnType": "NativeScript",
      "isPublic": true,
      "line": 158,
      "raw": "export const buildScriptPubkey = (keyHash: Ed25519KeyHash): NativeScript => {\n  const scriptPubkey = new ScriptPubkey(Ed25519KeyHashHex(keyHash.hex()));\n  return NativeScript.newScriptPubkey(scriptPubkey);\n};",
      "source": "mesh-core-cst",
      "implementation": "export const buildScriptPubkey = (keyHash: Ed25519KeyHash): NativeScript => {\n  const scriptPubkey = new ScriptPubkey(Ed25519KeyHashHex(keyHash.hex()));\n  return NativeScript.newScriptPubkey(scriptPubkey);\n};"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.buildDRepID",
      "fullName": "mesh-core-cst:utils.builder.ts.buildDRepID",
      "name": "buildDRepID",
      "signature": "export const buildDRepID = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 163,
      "raw": "export const buildDRepID = (\n  dRepKey: Ed25519PublicKeyHex,\n  networkId: NetworkId = NetworkId.Testnet,\n  addressType: AddressType = AddressType.EnterpriseKey,\n): DRepID => {\n  const dRepKeyBytes = Buffer.from(dRepKey, \"hex\");\n  const dRepIdHex = blake2b(28).update(dRepKeyBytes).digest(\"hex\");\n  const paymentAddress = EnterpriseAddress.packParts({\n    networkId,\n    paymentPart: {\n      hash: Hash28ByteBase16(dRepIdHex),\n      type: CredentialType.KeyHash,\n    },\n    type: addressType,\n  });\n  return HexBlob.toTypedBech32<DRepID>(\n    \"drep\",\n    HexBlob.fromBytes(paymentAddress),\n  );\n};",
      "source": "mesh-core-cst",
      "implementation": "export const buildDRepID = (\n  dRepKey: Ed25519PublicKeyHex,\n  networkId: NetworkId = NetworkId.Testnet,\n  addressType: AddressType = AddressType.EnterpriseKey,\n): DRepID => {\n  const dRepKeyBytes = Buffer.from(dRepKey, \"hex\");\n  const dRepIdHex = blake2b(28).update(dRepKeyBytes).digest(\"hex\");\n  const paymentAddress = EnterpriseAddress.packParts({\n    networkId,\n    paymentPart: {\n      hash: Hash28ByteBase16(dRepIdHex),\n      type: CredentialType.KeyHash,\n    },\n    type: addressType,\n  });\n  return HexBlob.toTypedBech32<DRepID>(\n    \"drep\",\n    HexBlob.fromBytes(paymentAddress),\n  );\n};"
    },
    {
      "key": "mesh-core-cst:utils.certificate.ts.toCardanoCert",
      "fullName": "mesh-core-cst:utils.certificate.ts.toCardanoCert",
      "name": "toCardanoCert",
      "signature": "export const toCardanoCert = (cert: CertificateType): CardanoCert => {",
      "documentation": "",
      "parameters": [
        {
          "name": "cert",
          "type": "CertificateType",
          "optional": false
        }
      ],
      "returnType": "CardanoCert",
      "isPublic": true,
      "line": 12,
      "raw": "export const toCardanoCert = (cert: CertificateType): CardanoCert => {\n  switch (cert.type) {\n    case \"RegisterPool\": {\n      let relays: Serialization.Relay[] = [];\n\n      for (const relay of cert.poolParams.relays) {\n        switch (relay.type) {\n          case \"SingleHostAddr\": {\n            relays.push(\n              Serialization.Relay.newSingleHostAddr(\n                new Serialization.SingleHostAddr(\n                  relay.port,\n                  relay.IPV4,\n                  relay.IPV6,\n                ),\n              ),\n            );\n            break;\n          }\n          case \"SingleHostName\": {\n            relays.push(\n              Serialization.Relay.newSingleHostName(\n                new Serialization.SingleHostName(relay.domainName, relay.port),\n              ),\n            );\n            break;\n          }\n          case \"MultiHostName\": {\n            relays.push(\n              Serialization.Relay.newMultiHostName(\n                new Serialization.MultiHostName(relay.domainName),\n              ),\n            );\n            break;\n          }\n        }\n      }\n\n      let poolOwners: Serialization.CborSet<\n        Crypto.Ed25519KeyHashHex,\n        Serialization.Hash<Crypto.Ed25519KeyHashHex>\n      > = Serialization.CborSet.fromCore([], Serialization.Hash.fromCore);\n\n      let poolOwnersValues = [...poolOwners.values()];\n      for (const poolOwner of cert.poolParams.owners) {\n        poolOwnersValues.push(\n          Serialization.Hash.fromCore(Ed25519KeyHashHex(poolOwner)),\n        );\n      }\n      poolOwners.setValues(poolOwnersValues);\n\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.poolParams.rewardAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      const metadata = cert.poolParams.metadata\n        ? new Serialization.PoolMetadata(\n            cert.poolParams.metadata.URL,\n            Crypto.Hash32ByteBase16(cert.poolParams.metadata.hash),\n          )\n        : undefined;\n\n      return CardanoCert.newPoolRegistration(\n        new Serialization.PoolRegistration(\n          new Serialization.PoolParams(\n            Ed25519KeyHashHex(cert.poolParams.operator),\n            Cardano.VrfVkHex(cert.poolParams.vrfKeyHash),\n            BigInt(cert.poolParams.pledge),\n            BigInt(cert.poolParams.cost),\n            new Serialization.UnitInterval(\n              BigInt(cert.poolParams.margin[0]),\n              BigInt(cert.poolParams.margin[1]),\n            ),\n            rewardAddress,\n            poolOwners,\n            relays,\n            metadata,\n          ),\n        ),\n      );\n    }\n    case \"RegisterStake\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      return CardanoCert.newStakeRegistration(\n        new Serialization.StakeRegistration(\n          rewardAddress.getPaymentCredential(),\n        ),\n      );\n    }\n    case \"DelegateStake\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      return CardanoCert.newStakeDelegation(\n        new Serialization.StakeDelegation(\n          rewardAddress.getPaymentCredential(),\n          cert.poolId.startsWith(\"pool1\")\n            ? Cardano.PoolId.toKeyHash(Cardano.PoolId(cert.poolId))\n            : Ed25519KeyHashHex(cert.poolId),\n        ),\n      );\n    }\n    case \"DeregisterStake\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      return CardanoCert.newStakeDeregistration(\n        new Serialization.StakeDeregistration(\n          rewardAddress.getPaymentCredential(),\n        ),\n      );\n    }\n    case \"RetirePool\": {\n      return CardanoCert.newPoolRetirement(\n        new Serialization.PoolRetirement(\n          cert.poolId.startsWith(\"pool1\")\n            ? Cardano.PoolId.toKeyHash(Cardano.PoolId(cert.poolId))\n            : Ed25519KeyHashHex(cert.poolId),\n          Cardano.EpochNo(cert.epoch),\n        ),\n      );\n    }\n    case \"VoteDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      if ((cert.drep as { dRepId: string }).dRepId !== undefined) {\n        return CardanoCert.newVoteDelegationCert(\n          new Serialization.VoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            toDRep((cert.drep as { dRepId: string }).dRepId),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysAbstain: null }).alwaysAbstain !== undefined\n      ) {\n        return CardanoCert.newVoteDelegationCert(\n          new Serialization.VoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysAbstain(),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysNoConfidence: null }).alwaysNoConfidence !==\n        undefined\n      ) {\n        return CardanoCert.newVoteDelegationCert(\n          new Serialization.VoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysNoConfidence(),\n          ),\n        );\n      } else {\n        throw new Error(\"Malformed DRep type\");\n      }\n    }\n    case \"StakeAndVoteDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      if ((cert.drep as { dRepId: string }).dRepId !== undefined) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            toDRep((cert.drep as { dRepId: string }).dRepId),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysAbstain: null }).alwaysAbstain !== undefined\n      ) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysAbstain(),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysNoConfidence: null }).alwaysNoConfidence !==\n        undefined\n      ) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysNoConfidence(),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else {\n        throw new Error(\"Malformed DRep type\");\n      }\n    }\n    case \"StakeRegistrationAndDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      return CardanoCert.newStakeRegistrationDelegationCert(\n        new Serialization.StakeRegistrationDelegation(\n          rewardAddress.getPaymentCredential(),\n          BigInt(cert.coin),\n          Ed25519KeyHashHex(cert.poolKeyHash),\n        ),\n      );\n    }\n    case \"VoteRegistrationAndDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      if ((cert.drep as { dRepId: string }).dRepId !== undefined) {\n        return CardanoCert.newVoteRegistrationDelegationCert(\n          new Serialization.VoteRegistrationDelegation(\n            rewardAddress.getPaymentCredential(),\n            BigInt(cert.coin),\n            toDRep((cert.drep as { dRepId: string }).dRepId),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysAbstain: null }).alwaysAbstain !== undefined\n      ) {\n        return CardanoCert.newVoteRegistrationDelegationCert(\n          new Serialization.VoteRegistrationDelegation(\n            rewardAddress.getPaymentCredential(),\n            BigInt(cert.coin),\n            Serialization.DRep.newAlwaysAbstain(),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysNoConfidence: null }).alwaysNoConfidence !==\n        undefined\n      ) {\n        return CardanoCert.newVoteRegistrationDelegationCert(\n          new Serialization.VoteRegistrationDelegation(\n            rewardAddress.getPaymentCredential(),\n            BigInt(cert.coin),\n            Serialization.DRep.newAlwaysNoConfidence(),\n          ),\n        );\n      } else {\n        throw new Error(\"Malformed DRep type\");\n      }\n    }\n    case \"StakeVoteRegistrationAndDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      if ((cert.drep as { dRepId: string }).dRepId !== undefined) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            toDRep((cert.drep as { dRepId: string }).dRepId),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysAbstain: null }).alwaysAbstain !== undefined\n      ) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysAbstain(),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysNoConfidence: null }).alwaysNoConfidence !==\n        undefined\n      ) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysNoConfidence(),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else {\n        throw new Error(\"Malformed DRep type\");\n      }\n    }\n    case \"CommitteeHotAuth\": {\n      const hotCred = Cardano.Address.fromBech32(\n        cert.committeeHotKeyAddress,\n      ).getProps().paymentPart;\n      const coldCred = Cardano.Address.fromBech32(\n        cert.committeeColdKeyAddress,\n      ).getProps().paymentPart;\n      if (!hotCred || !coldCred) {\n        throw new Error(\"Malformed hot/cold credential\");\n      }\n      return CardanoCert.newAuthCommitteeHotCert(\n        new Serialization.AuthCommitteeHot(coldCred, hotCred),\n      );\n    }\n    case \"CommitteeColdResign\": {\n      const coldCred = Cardano.Address.fromBech32(\n        cert.committeeColdKeyAddress,\n      ).getProps().paymentPart;\n      if (!coldCred) {\n        throw new Error(\"Malformed hot/cold credential\");\n      }\n      let anchor: Serialization.Anchor | undefined = undefined;\n      if (cert.anchor) {\n        anchor = new Serialization.Anchor(\n          cert.anchor.anchorUrl,\n          Hash32ByteBase16(cert.anchor.anchorDataHash),\n        );\n      }\n      return CardanoCert.newResignCommitteeColdCert(\n        new Serialization.ResignCommitteeCold(coldCred, anchor),\n      );\n    }\n    case \"DRepRegistration\": {\n      let anchor: Serialization.Anchor | undefined = undefined;\n      if (cert.anchor) {\n        anchor = new Serialization.Anchor(\n          cert.anchor.anchorUrl,\n          Hash32ByteBase16(cert.anchor.anchorDataHash),\n        );\n      }\n\n      const coreDRep = toDRep(cert.drepId).toCore();\n      if (Cardano.isDRepCredential(coreDRep)) {\n        return CardanoCert.newRegisterDelegateRepresentativeCert(\n          new Serialization.RegisterDelegateRepresentative(\n            coreDRep,\n            BigInt(cert.coin),\n            anchor,\n          ),\n        );\n      } else {\n        throw new Error(\"DRepId must be a Credential\");\n      }\n    }\n    case \"DRepDeregistration\": {\n      const coreDRep = toDRep(cert.drepId).toCore();\n      if (Cardano.isDRepCredential(coreDRep)) {\n        return CardanoCert.newUnregisterDelegateRepresentativeCert(\n          new Serialization.UnregisterDelegateRepresentative(\n            coreDRep,\n            BigInt(cert.coin),\n          ),\n        );\n      } else {\n        throw new Error(\"DRepId must be a Credential\");\n      }\n    }\n    case \"DRepUpdate\": {\n      let anchor: Serialization.Anchor | undefined = undefined;\n      if (cert.anchor) {\n        anchor = new Serialization.Anchor(\n          cert.anchor.anchorUrl,\n          Hash32ByteBase16(cert.anchor.anchorDataHash),\n        );\n      }\n\n      const coreDRep = toDRep(cert.drepId).toCore();\n      if (Cardano.isDRepCredential(coreDRep)) {\n        return CardanoCert.newUpdateDelegateRepresentativeCert(\n          new Serialization.UpdateDelegateRepresentative(coreDRep, anchor),\n        );\n      } else {\n        throw new Error(\"DRepId must be a Credential\");\n      }\n    }\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const toCardanoCert = (cert: CertificateType): CardanoCert => {\n  switch (cert.type) {\n    case \"RegisterPool\": {\n      let relays: Serialization.Relay[] = [];\n\n      for (const relay of cert.poolParams.relays) {\n        switch (relay.type) {\n          case \"SingleHostAddr\": {\n            relays.push(\n              Serialization.Relay.newSingleHostAddr(\n                new Serialization.SingleHostAddr(\n                  relay.port,\n                  relay.IPV4,\n                  relay.IPV6,\n                ),\n              ),\n            );\n            break;\n          }\n          case \"SingleHostName\": {\n            relays.push(\n              Serialization.Relay.newSingleHostName(\n                new Serialization.SingleHostName(relay.domainName, relay.port),\n              ),\n            );\n            break;\n          }\n          case \"MultiHostName\": {\n            relays.push(\n              Serialization.Relay.newMultiHostName(\n                new Serialization.MultiHostName(relay.domainName),\n              ),\n            );\n            break;\n          }\n        }\n      }\n\n      let poolOwners: Serialization.CborSet<\n        Crypto.Ed25519KeyHashHex,\n        Serialization.Hash<Crypto.Ed25519KeyHashHex>\n      > = Serialization.CborSet.fromCore([], Serialization.Hash.fromCore);\n\n      let poolOwnersValues = [...poolOwners.values()];\n      for (const poolOwner of cert.poolParams.owners) {\n        poolOwnersValues.push(\n          Serialization.Hash.fromCore(Ed25519KeyHashHex(poolOwner)),\n        );\n      }\n      poolOwners.setValues(poolOwnersValues);\n\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.poolParams.rewardAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      const metadata = cert.poolParams.metadata\n        ? new Serialization.PoolMetadata(\n            cert.poolParams.metadata.URL,\n            Crypto.Hash32ByteBase16(cert.poolParams.metadata.hash),\n          )\n        : undefined;\n\n      return CardanoCert.newPoolRegistration(\n        new Serialization.PoolRegistration(\n          new Serialization.PoolParams(\n            Ed25519KeyHashHex(cert.poolParams.operator),\n            Cardano.VrfVkHex(cert.poolParams.vrfKeyHash),\n            BigInt(cert.poolParams.pledge),\n            BigInt(cert.poolParams.cost),\n            new Serialization.UnitInterval(\n              BigInt(cert.poolParams.margin[0]),\n              BigInt(cert.poolParams.margin[1]),\n            ),\n            rewardAddress,\n            poolOwners,\n            relays,\n            metadata,\n          ),\n        ),\n      );\n    }\n    case \"RegisterStake\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      return CardanoCert.newStakeRegistration(\n        new Serialization.StakeRegistration(\n          rewardAddress.getPaymentCredential(),\n        ),\n      );\n    }\n    case \"DelegateStake\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      return CardanoCert.newStakeDelegation(\n        new Serialization.StakeDelegation(\n          rewardAddress.getPaymentCredential(),\n          cert.poolId.startsWith(\"pool1\")\n            ? Cardano.PoolId.toKeyHash(Cardano.PoolId(cert.poolId))\n            : Ed25519KeyHashHex(cert.poolId),\n        ),\n      );\n    }\n    case \"DeregisterStake\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      return CardanoCert.newStakeDeregistration(\n        new Serialization.StakeDeregistration(\n          rewardAddress.getPaymentCredential(),\n        ),\n      );\n    }\n    case \"RetirePool\": {\n      return CardanoCert.newPoolRetirement(\n        new Serialization.PoolRetirement(\n          cert.poolId.startsWith(\"pool1\")\n            ? Cardano.PoolId.toKeyHash(Cardano.PoolId(cert.poolId))\n            : Ed25519KeyHashHex(cert.poolId),\n          Cardano.EpochNo(cert.epoch),\n        ),\n      );\n    }\n    case \"VoteDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      if ((cert.drep as { dRepId: string }).dRepId !== undefined) {\n        return CardanoCert.newVoteDelegationCert(\n          new Serialization.VoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            toDRep((cert.drep as { dRepId: string }).dRepId),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysAbstain: null }).alwaysAbstain !== undefined\n      ) {\n        return CardanoCert.newVoteDelegationCert(\n          new Serialization.VoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysAbstain(),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysNoConfidence: null }).alwaysNoConfidence !==\n        undefined\n      ) {\n        return CardanoCert.newVoteDelegationCert(\n          new Serialization.VoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysNoConfidence(),\n          ),\n        );\n      } else {\n        throw new Error(\"Malformed DRep type\");\n      }\n    }\n    case \"StakeAndVoteDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      if ((cert.drep as { dRepId: string }).dRepId !== undefined) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            toDRep((cert.drep as { dRepId: string }).dRepId),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysAbstain: null }).alwaysAbstain !== undefined\n      ) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysAbstain(),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysNoConfidence: null }).alwaysNoConfidence !==\n        undefined\n      ) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysNoConfidence(),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else {\n        throw new Error(\"Malformed DRep type\");\n      }\n    }\n    case \"StakeRegistrationAndDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      return CardanoCert.newStakeRegistrationDelegationCert(\n        new Serialization.StakeRegistrationDelegation(\n          rewardAddress.getPaymentCredential(),\n          BigInt(cert.coin),\n          Ed25519KeyHashHex(cert.poolKeyHash),\n        ),\n      );\n    }\n    case \"VoteRegistrationAndDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      if ((cert.drep as { dRepId: string }).dRepId !== undefined) {\n        return CardanoCert.newVoteRegistrationDelegationCert(\n          new Serialization.VoteRegistrationDelegation(\n            rewardAddress.getPaymentCredential(),\n            BigInt(cert.coin),\n            toDRep((cert.drep as { dRepId: string }).dRepId),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysAbstain: null }).alwaysAbstain !== undefined\n      ) {\n        return CardanoCert.newVoteRegistrationDelegationCert(\n          new Serialization.VoteRegistrationDelegation(\n            rewardAddress.getPaymentCredential(),\n            BigInt(cert.coin),\n            Serialization.DRep.newAlwaysAbstain(),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysNoConfidence: null }).alwaysNoConfidence !==\n        undefined\n      ) {\n        return CardanoCert.newVoteRegistrationDelegationCert(\n          new Serialization.VoteRegistrationDelegation(\n            rewardAddress.getPaymentCredential(),\n            BigInt(cert.coin),\n            Serialization.DRep.newAlwaysNoConfidence(),\n          ),\n        );\n      } else {\n        throw new Error(\"Malformed DRep type\");\n      }\n    }\n    case \"StakeVoteRegistrationAndDelegation\": {\n      const rewardAddress = Cardano.RewardAddress.fromAddress(\n        Cardano.Address.fromBech32(cert.stakeKeyAddress),\n      );\n\n      if (rewardAddress === undefined) {\n        throw new Error(\n          \"Error parsing reward address, it is expected to be in bech32 format\",\n        );\n      }\n\n      if ((cert.drep as { dRepId: string }).dRepId !== undefined) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            toDRep((cert.drep as { dRepId: string }).dRepId),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysAbstain: null }).alwaysAbstain !== undefined\n      ) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysAbstain(),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else if (\n        (cert.drep as { alwaysNoConfidence: null }).alwaysNoConfidence !==\n        undefined\n      ) {\n        return CardanoCert.newStakeVoteDelegationCert(\n          new Serialization.StakeVoteDelegation(\n            rewardAddress.getPaymentCredential(),\n            Serialization.DRep.newAlwaysNoConfidence(),\n            Ed25519KeyHashHex(cert.poolKeyHash),\n          ),\n        );\n      } else {\n        throw new Error(\"Malformed DRep type\");\n      }\n    }\n    case \"CommitteeHotAuth\": {\n      const hotCred = Cardano.Address.fromBech32(\n        cert.committeeHotKeyAddress,\n      ).getProps().paymentPart;\n      const coldCred = Cardano.Address.fromBech32(\n        cert.committeeColdKeyAddress,\n      ).getProps().paymentPart;\n      if (!hotCred || !coldCred) {\n        throw new Error(\"Malformed hot/cold credential\");\n      }\n      return CardanoCert.newAuthCommitteeHotCert(\n        new Serialization.AuthCommitteeHot(coldCred, hotCred),\n      );\n    }\n    case \"CommitteeColdResign\": {\n      const coldCred = Cardano.Address.fromBech32(\n        cert.committeeColdKeyAddress,\n      ).getProps().paymentPart;\n      if (!coldCred) {\n        throw new Error(\"Malformed hot/cold credential\");\n      }\n      let anchor: Serialization.Anchor | undefined = undefined;\n      if (cert.anchor) {\n        anchor = new Serialization.Anchor(\n          cert.anchor.anchorUrl,\n          Hash32ByteBase16(cert.anchor.anchorDataHash),\n        );\n      }\n      return CardanoCert.newResignCommitteeColdCert(\n        new Serialization.ResignCommitteeCold(coldCred, anchor),\n      );\n    }\n    case \"DRepRegistration\": {\n      let anchor: Serialization.Anchor | undefined = undefined;\n      if (cert.anchor) {\n        anchor = new Serialization.Anchor(\n          cert.anchor.anchorUrl,\n          Hash32ByteBase16(cert.anchor.anchorDataHash),\n        );\n      }\n\n      const coreDRep = toDRep(cert.drepId).toCore();\n      if (Cardano.isDRepCredential(coreDRep)) {\n        return CardanoCert.newRegisterDelegateRepresentativeCert(\n          new Serialization.RegisterDelegateRepresentative(\n            coreDRep,\n            BigInt(cert.coin),\n            anchor,\n          ),\n        );\n      } else {\n        throw new Error(\"DRepId must be a Credential\");\n      }\n    }\n    case \"DRepDeregistration\": {\n      const coreDRep = toDRep(cert.drepId).toCore();\n      if (Cardano.isDRepCredential(coreDRep)) {\n        return CardanoCert.newUnregisterDelegateRepresentativeCert(\n          new Serialization.UnregisterDelegateRepresentative(\n            coreDRep,\n            BigInt(cert.coin),\n          ),\n        );\n      } else {\n        throw new Error(\"DRepId must be a Credential\");\n      }\n    }\n    case \"DRepUpdate\": {\n      let anchor: Serialization.Anchor | undefined = undefined;\n      if (cert.anchor) {\n        anchor = new Serialization.Anchor(\n          cert.anchor.anchorUrl,\n          Hash32ByteBase16(cert.anchor.anchorDataHash),\n        );\n      }\n\n      const coreDRep = toDRep(cert.drepId).toCore();\n      if (Cardano.isDRepCredential(coreDRep)) {\n        return CardanoCert.newUpdateDelegateRepresentativeCert(\n          new Serialization.UpdateDelegateRepresentative(coreDRep, anchor),\n        );\n      } else {\n        throw new Error(\"DRepId must be a Credential\");\n      }\n    }\n  }\n};"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toAddress",
      "fullName": "mesh-core-cst:utils.converter.ts.toAddress",
      "name": "toAddress",
      "signature": "export const toAddress = (bech32: string): Address =>",
      "documentation": "",
      "parameters": [
        {
          "name": "bech32",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Address",
      "isPublic": true,
      "line": 51,
      "raw": "export const toAddress = (bech32: string): Address =>\n  Address.fromBech32(bech32);\n\nexport const toCardanoAddress = (address: string): Address => {\n  try {\n    return Address.fromBech32(address);\n  } catch {\n    try {\n      return Address.fromBase58(address);\n    } catch {\n      throw new Error(`Invalid address format, ${address}`);\n    }\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const toAddress = (bech32: string): Address =>\n  Address.fromBech32(bech32);\n\nexport const toCardanoAddress = (address: string): Address => {\n  try {\n    return Address.fromBech32(address);\n  } catch {\n    try {\n      return Address.fromBase58(address);\n    } catch {\n      throw new Error(`Invalid address format, ${address}`);\n    }\n  }\n};"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toCardanoAddress",
      "fullName": "mesh-core-cst:utils.converter.ts.toCardanoAddress",
      "name": "toCardanoAddress",
      "signature": "export const toCardanoAddress = (address: string): Address => {",
      "documentation": "",
      "parameters": [
        {
          "name": "address",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Address",
      "isPublic": true,
      "line": 54,
      "raw": "export const toCardanoAddress = (address: string): Address => {\n  try {\n    return Address.fromBech32(address);\n  } catch {\n    try {\n      return Address.fromBase58(address);\n    } catch {\n      throw new Error(`Invalid address format, ${address}`);\n    }\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const toCardanoAddress = (address: string): Address => {\n  try {\n    return Address.fromBech32(address);\n  } catch {\n    try {\n      return Address.fromBase58(address);\n    } catch {\n      throw new Error(`Invalid address format, ${address}`);\n    }\n  }\n};"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toBaseAddress",
      "fullName": "mesh-core-cst:utils.converter.ts.toBaseAddress",
      "name": "toBaseAddress",
      "signature": "export const toBaseAddress = (bech32: string): BaseAddress | undefined => {",
      "documentation": "",
      "parameters": [
        {
          "name": "bech32",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "BaseAddress | undefined",
      "isPublic": true,
      "line": 66,
      "raw": "export const toBaseAddress = (bech32: string): BaseAddress | undefined => {\n  return BaseAddress.fromAddress(toAddress(bech32));\n};",
      "source": "mesh-core-cst",
      "implementation": "export const toBaseAddress = (bech32: string): BaseAddress | undefined => {\n  return BaseAddress.fromAddress(toAddress(bech32));\n};"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toEnterpriseAddress",
      "fullName": "mesh-core-cst:utils.converter.ts.toEnterpriseAddress",
      "name": "toEnterpriseAddress",
      "signature": "export const toEnterpriseAddress = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 70,
      "raw": "export const toEnterpriseAddress = (\n  bech32: string,\n): EnterpriseAddress | undefined => {\n  return EnterpriseAddress.fromAddress(toAddress(bech32));\n};",
      "source": "mesh-core-cst",
      "implementation": "export const toEnterpriseAddress = (\n  bech32: string,\n): EnterpriseAddress | undefined => {\n  return EnterpriseAddress.fromAddress(toAddress(bech32));\n};"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toRewardAddress",
      "fullName": "mesh-core-cst:utils.converter.ts.toRewardAddress",
      "name": "toRewardAddress",
      "signature": "export const toRewardAddress = (bech32: string): RewardAddress | undefined =>",
      "documentation": "",
      "parameters": [
        {
          "name": "bech32",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "RewardAddress | undefined",
      "isPublic": true,
      "line": 76,
      "raw": "export const toRewardAddress = (bech32: string): RewardAddress | undefined =>\n  RewardAddress.fromAddress(toAddress(bech32));\n\nexport const fromTxUnspentOutput = (\n  txUnspentOutput: TransactionUnspentOutput,\n): UTxO => {\n  const dataHash = txUnspentOutput.output().datum()\n    ? txUnspentOutput.output().datum()?.toCbor().toString()\n    : undefined;\n\n  const scriptRef = txUnspentOutput.output().scriptRef()\n    ? txUnspentOutput.output().scriptRef()?.toCbor().toString()\n    : undefined;\n\n  const plutusData = txUnspentOutput.output().datum()?.asInlineData()\n    ? txUnspentOutput.output().datum()?.asInlineData()?.toCbor().toString()\n    : undefined;\n\n  return <UTxO>{\n    input: {\n      outputIndex: Number(txUnspentOutput.input().index()),\n      txHash: txUnspentOutput.input().transactionId(),\n    },\n    output: {\n      address: txUnspentOutput.output().address().toBech32(),\n      amount: fromValue(txUnspentOutput.output().amount()),\n      dataHash: dataHash, // todo not sure if correct\n      plutusData: plutusData, // todo not sure if correct\n      scriptRef: scriptRef, // todo not sure if correct\n    },\n  };\n};",
      "source": "mesh-core-cst",
      "implementation": "export const toRewardAddress = (bech32: string): RewardAddress | undefined =>\n  RewardAddress.fromAddress(toAddress(bech32));\n\nexport const fromTxUnspentOutput = (\n  txUnspentOutput: TransactionUnspentOutput,\n): UTxO => {\n  const dataHash = txUnspentOutput.output().datum()\n    ? txUnspentOutput.output().datum()?.toCbor().toString()\n    : undefined;\n\n  const scriptRef = txUnspentOutput.output().scriptRef()\n    ? txUnspentOutput.output().scriptRef()?.toCbor().toString()\n    : undefined;\n\n  const plutusData = txUnspentOutput.output().datum()?.asInlineData()\n    ? txUnspentOutput.output().datum()?.asInlineData()?.toCbor().toString()\n    : undefined;\n\n  return <UTxO>{\n    input: {\n      outputIndex: Number(txUnspentOutput.input().index()),\n      txHash: txUnspentOutput.input().transactionId(),\n    },\n    output: {\n      address: txUnspentOutput.output().address().toBech32(),\n      amount: fromValue(txUnspentOutput.output().amount()),\n      dataHash: dataHash, // todo not sure if correct\n      plutusData: plutusData, // todo not sure if correct\n      scriptRef: scriptRef, // todo not sure if correct\n    },\n  };\n};"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.fromTxUnspentOutput",
      "fullName": "mesh-core-cst:utils.converter.ts.fromTxUnspentOutput",
      "name": "fromTxUnspentOutput",
      "signature": "export const fromTxUnspentOutput = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 79,
      "raw": "export const fromTxUnspentOutput = (\n  txUnspentOutput: TransactionUnspentOutput,\n): UTxO => {\n  const dataHash = txUnspentOutput.output().datum()\n    ? txUnspentOutput.output().datum()?.toCbor().toString()\n    : undefined;\n\n  const scriptRef = txUnspentOutput.output().scriptRef()\n    ? txUnspentOutput.output().scriptRef()?.toCbor().toString()\n    : undefined;\n\n  const plutusData = txUnspentOutput.output().datum()?.asInlineData()\n    ? txUnspentOutput.output().datum()?.asInlineData()?.toCbor().toString()\n    : undefined;\n\n  return <UTxO>{\n    input: {\n      outputIndex: Number(txUnspentOutput.input().index()),\n      txHash: txUnspentOutput.input().transactionId(),\n    },\n    output: {\n      address: txUnspentOutput.output().address().toBech32(),\n      amount: fromValue(txUnspentOutput.output().amount()),\n      dataHash: dataHash, // todo not sure if correct\n      plutusData: plutusData, // todo not sure if correct\n      scriptRef: scriptRef, // todo not sure if correct\n    },\n  };\n};",
      "source": "mesh-core-cst",
      "implementation": "export const fromTxUnspentOutput = (\n  txUnspentOutput: TransactionUnspentOutput,\n): UTxO => {\n  const dataHash = txUnspentOutput.output().datum()\n    ? txUnspentOutput.output().datum()?.toCbor().toString()\n    : undefined;\n\n  const scriptRef = txUnspentOutput.output().scriptRef()\n    ? txUnspentOutput.output().scriptRef()?.toCbor().toString()\n    : undefined;\n\n  const plutusData = txUnspentOutput.output().datum()?.asInlineData()\n    ? txUnspentOutput.output().datum()?.asInlineData()?.toCbor().toString()\n    : undefined;\n\n  return <UTxO>{\n    input: {\n      outputIndex: Number(txUnspentOutput.input().index()),\n      txHash: txUnspentOutput.input().transactionId(),\n    },\n    output: {\n      address: txUnspentOutput.output().address().toBech32(),\n      amount: fromValue(txUnspentOutput.output().amount()),\n      dataHash: dataHash, // todo not sure if correct\n      plutusData: plutusData, // todo not sure if correct\n      scriptRef: scriptRef, // todo not sure if correct\n    },\n  };\n};"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toTxUnspentOutput",
      "fullName": "mesh-core-cst:utils.converter.ts.toTxUnspentOutput",
      "name": "toTxUnspentOutput",
      "signature": "export const toTxUnspentOutput = (utxo: UTxO) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "utxo",
          "type": "UTxO",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 109,
      "raw": "export const toTxUnspentOutput = (utxo: UTxO) => {\n  const txInput = new TransactionInput(\n    deserializeTxHash(utxo.input.txHash),\n    BigInt(utxo.input.outputIndex),\n  );\n\n  const txOutput = new TransactionOutput(\n    toAddress(utxo.output.address),\n    toValue(utxo.output.amount),\n  );\n\n  if (utxo.output.dataHash !== undefined) {\n    txOutput.setDatum(\n      Datum.fromCore(deserializeDataHash(utxo.output.dataHash)),\n    );\n  }\n\n  if (utxo.output.plutusData !== undefined) {\n    const plutusData = deserializePlutusData(utxo.output.plutusData);\n    const datum = new Serialization.Datum(undefined, plutusData);\n    txOutput.setDatum(datum);\n  }\n\n  if (utxo.output.scriptRef !== undefined) {\n    txOutput.setScriptRef(deserializeScriptRef(utxo.output.scriptRef));\n  }\n\n  return new TransactionUnspentOutput(txInput, txOutput);\n};",
      "source": "mesh-core-cst",
      "implementation": "export const toTxUnspentOutput = (utxo: UTxO) => {\n  const txInput = new TransactionInput(\n    deserializeTxHash(utxo.input.txHash),\n    BigInt(utxo.input.outputIndex),\n  );\n\n  const txOutput = new TransactionOutput(\n    toAddress(utxo.output.address),\n    toValue(utxo.output.amount),\n  );\n\n  if (utxo.output.dataHash !== undefined) {\n    txOutput.setDatum(\n      Datum.fromCore(deserializeDataHash(utxo.output.dataHash)),\n    );\n  }\n\n  if (utxo.output.plutusData !== undefined) {\n    const plutusData = deserializePlutusData(utxo.output.plutusData);\n    const datum = new Serialization.Datum(undefined, plutusData);\n    txOutput.setDatum(datum);\n  }\n\n  if (utxo.output.scriptRef !== undefined) {\n    txOutput.setScriptRef(deserializeScriptRef(utxo.output.scriptRef));\n  }\n\n  return new TransactionUnspentOutput(txInput, txOutput);\n};"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.addressToBech32",
      "fullName": "mesh-core-cst:utils.converter.ts.addressToBech32",
      "name": "addressToBech32",
      "signature": "export const addressToBech32 = (address: Address): string => {",
      "documentation": "",
      "parameters": [
        {
          "name": "address",
          "type": "Address",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 139,
      "raw": "export const addressToBech32 = (address: Address): string => {\n  return address.toBech32();\n};",
      "source": "mesh-core-cst",
      "implementation": "export const addressToBech32 = (address: Address): string => {\n  return address.toBech32();\n};"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.fromValue",
      "fullName": "mesh-core-cst:utils.converter.ts.fromValue",
      "name": "fromValue",
      "signature": "export const fromValue = (value: Value) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "value",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 143,
      "raw": "export const fromValue = (value: Value) => {\n  const assets: Asset[] = [\n    { unit: \"lovelace\", quantity: value.coin().toString() },\n  ];\n\n  const multiAsset = value.multiasset();\n  if (multiAsset !== undefined) {\n    const _assets = Array.from(multiAsset.keys());\n    for (let i = 0; i < _assets.length; i += 1) {\n      const assetId = _assets[i];\n      if (assetId !== undefined) {\n        const assetQuantity = multiAsset.get(assetId);\n        if (assetQuantity !== undefined) {\n          assets.push({\n            unit: assetId as Unit,\n            quantity: assetQuantity.toString() as Quantity,\n          });\n        }\n      }\n    }\n  }\n\n  return assets;\n};",
      "source": "mesh-core-cst",
      "implementation": "export const fromValue = (value: Value) => {\n  const assets: Asset[] = [\n    { unit: \"lovelace\", quantity: value.coin().toString() },\n  ];\n\n  const multiAsset = value.multiasset();\n  if (multiAsset !== undefined) {\n    const _assets = Array.from(multiAsset.keys());\n    for (let i = 0; i < _assets.length; i += 1) {\n      const assetId = _assets[i];\n      if (assetId !== undefined) {\n        const assetQuantity = multiAsset.get(assetId);\n        if (assetQuantity !== undefined) {\n          assets.push({\n            unit: assetId as Unit,\n            quantity: assetQuantity.toString() as Quantity,\n          });\n        }\n      }\n    }\n  }\n\n  return assets;\n};"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toScriptRef",
      "fullName": "mesh-core-cst:utils.converter.ts.toScriptRef",
      "name": "toScriptRef",
      "signature": "export const toScriptRef = (script: PlutusScript | NativeScript): Script => {",
      "documentation": "",
      "parameters": [
        {
          "name": "script",
          "type": "PlutusScript | NativeScript",
          "optional": false
        }
      ],
      "returnType": "Script",
      "isPublic": true,
      "line": 168,
      "raw": "export const toScriptRef = (script: PlutusScript | NativeScript): Script => {\n  if (\"code\" in script) {\n    const plutusScript = deserializePlutusScript(script.code, script.version);\n    if (plutusScript instanceof PlutusV1Script)\n      return Script.newPlutusV1Script(plutusScript);\n    if (plutusScript instanceof PlutusV2Script)\n      return Script.newPlutusV2Script(plutusScript);\n    if (plutusScript instanceof PlutusV3Script)\n      return Script.newPlutusV3Script(plutusScript);\n  }\n  return Script.newNativeScript(toNativeScript(script as NativeScript));\n};",
      "source": "mesh-core-cst",
      "implementation": "export const toScriptRef = (script: PlutusScript | NativeScript): Script => {\n  if (\"code\" in script) {\n    const plutusScript = deserializePlutusScript(script.code, script.version);\n    if (plutusScript instanceof PlutusV1Script)\n      return Script.newPlutusV1Script(plutusScript);\n    if (plutusScript instanceof PlutusV2Script)\n      return Script.newPlutusV2Script(plutusScript);\n    if (plutusScript instanceof PlutusV3Script)\n      return Script.newPlutusV3Script(plutusScript);\n  }\n  return Script.newNativeScript(toNativeScript(script as NativeScript));\n};"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.fromScriptRef",
      "fullName": "mesh-core-cst:utils.converter.ts.fromScriptRef",
      "name": "fromScriptRef",
      "signature": "export const fromScriptRef = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 181,
      "raw": "export const fromScriptRef = (\n  scriptRef: string,\n): PlutusScript | NativeScript | undefined => {\n  const script = Script.fromCbor(HexBlob(scriptRef));\n\n  const plutusScriptCodeV3 = script.asPlutusV3()?.toCbor().toString();\n  if (plutusScriptCodeV3) {\n    return {\n      code: plutusScriptCodeV3,\n      version: \"V3\",\n    };\n  }\n\n  const plutusScriptCodeV2 = script.asPlutusV2()?.toCbor().toString();\n  if (plutusScriptCodeV2) {\n    return {\n      code: plutusScriptCodeV2,\n      version: \"V2\",\n    };\n  }\n\n  const plutusScriptCodeV1 = script.asPlutusV1()?.toCbor().toString();\n  if (plutusScriptCodeV1) {\n    return {\n      code: plutusScriptCodeV1,\n      version: \"V1\",\n    };\n  }\n\n  // TODO: implement from native script\n  const nativeScript = script.asNative();\n  if (!nativeScript) {\n    throw new Error(\"Invalid script\");\n  }\n\n  return fromNativeScript(nativeScript);\n};",
      "source": "mesh-core-cst",
      "implementation": "export const fromScriptRef = (\n  scriptRef: string,\n): PlutusScript | NativeScript | undefined => {\n  const script = Script.fromCbor(HexBlob(scriptRef));\n\n  const plutusScriptCodeV3 = script.asPlutusV3()?.toCbor().toString();\n  if (plutusScriptCodeV3) {\n    return {\n      code: plutusScriptCodeV3,\n      version: \"V3\",\n    };\n  }\n\n  const plutusScriptCodeV2 = script.asPlutusV2()?.toCbor().toString();\n  if (plutusScriptCodeV2) {\n    return {\n      code: plutusScriptCodeV2,\n      version: \"V2\",\n    };\n  }\n\n  const plutusScriptCodeV1 = script.asPlutusV1()?.toCbor().toString();\n  if (plutusScriptCodeV1) {\n    return {\n      code: plutusScriptCodeV1,\n      version: \"V1\",\n    };\n  }\n\n  // TODO: implement from native script\n  const nativeScript = script.asNative();\n  if (!nativeScript) {\n    throw new Error(\"Invalid script\");\n  }\n\n  return fromNativeScript(nativeScript);\n};"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.fromNativeScript",
      "fullName": "mesh-core-cst:utils.converter.ts.fromNativeScript",
      "name": "fromNativeScript",
      "signature": "export const fromNativeScript = (script: CstNativeScript) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "script",
          "type": "CstNativeScript",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 219,
      "raw": "export const fromNativeScript = (script: CstNativeScript) => {\n  const fromNativeScripts = (scripts: CstNativeScript[]) => {\n    const nativeScripts = new Array<NativeScript>();\n\n    for (let index = 0; index < scripts.length; index += 1) {\n      const script = scripts[index];\n      if (script) {\n        nativeScripts.push(fromNativeScript(script));\n      }\n    }\n\n    return nativeScripts;\n  };\n\n  switch (script.kind()) {\n    case RequireAllOf: {\n      const scriptAll = script.asScriptAll()!;\n      return <NativeScript>{\n        type: \"all\",\n        scripts: fromNativeScripts(scriptAll.nativeScripts()),\n      };\n    }\n    case RequireAnyOf: {\n      const scriptAny = script.asScriptAny()!;\n      return <NativeScript>{\n        type: \"any\",\n        scripts: fromNativeScripts(scriptAny.nativeScripts()),\n      };\n    }\n    case RequireNOf: {\n      const scriptNOfK = script.asScriptNOfK()!;\n      return <NativeScript>{\n        type: \"atLeast\",\n        required: scriptNOfK.required(),\n        scripts: fromNativeScripts(scriptNOfK.nativeScripts()),\n      };\n    }\n    case RequireTimeAfter: {\n      const timelockStart = script.asTimelockStart()!;\n      return <NativeScript>{\n        type: \"after\",\n        slot: timelockStart.slot().toString(),\n      };\n    }\n    case RequireTimeBefore: {\n      const timelockExpiry = script.asTimelockExpiry()!;\n      return <NativeScript>{\n        type: \"before\",\n        slot: timelockExpiry.slot().toString(),\n      };\n    }\n    case RequireSignature: {\n      const scriptPubkey = script.asScriptPubkey()!;\n      return <NativeScript>{\n        type: \"sig\",\n        keyHash: scriptPubkey.keyHash().toString(),\n      };\n    }\n    default:\n      throw new Error(`Script Kind: ${script.kind()}, is not supported`);\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const fromNativeScript = (script: CstNativeScript) => {\n  const fromNativeScripts = (scripts: CstNativeScript[]) => {\n    const nativeScripts = new Array<NativeScript>();\n\n    for (let index = 0; index < scripts.length; index += 1) {\n      const script = scripts[index];\n      if (script) {\n        nativeScripts.push(fromNativeScript(script));\n      }\n    }\n\n    return nativeScripts;\n  };\n\n  switch (script.kind()) {\n    case RequireAllOf: {\n      const scriptAll = script.asScriptAll()!;\n      return <NativeScript>{\n        type: \"all\",\n        scripts: fromNativeScripts(scriptAll.nativeScripts()),\n      };\n    }\n    case RequireAnyOf: {\n      const scriptAny = script.asScriptAny()!;\n      return <NativeScript>{\n        type: \"any\",\n        scripts: fromNativeScripts(scriptAny.nativeScripts()),\n      };\n    }\n    case RequireNOf: {\n      const scriptNOfK = script.asScriptNOfK()!;\n      return <NativeScript>{\n        type: \"atLeast\",\n        required: scriptNOfK.required(),\n        scripts: fromNativeScripts(scriptNOfK.nativeScripts()),\n      };\n    }\n    case RequireTimeAfter: {\n      const timelockStart = script.asTimelockStart()!;\n      return <NativeScript>{\n        type: \"after\",\n        slot: timelockStart.slot().toString(),\n      };\n    }\n    case RequireTimeBefore: {\n      const timelockExpiry = script.asTimelockExpiry()!;\n      return <NativeScript>{\n        type: \"before\",\n        slot: timelockExpiry.slot().toString(),\n      };\n    }\n    case RequireSignature: {\n      const scriptPubkey = script.asScriptPubkey()!;\n      return <NativeScript>{\n        type: \"sig\",\n        keyHash: scriptPubkey.keyHash().toString(),\n      };\n    }\n    default:\n      throw new Error(`Script Kind: ${script.kind()}, is not supported`);\n  }\n};"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.fromNativeScripts",
      "fullName": "mesh-core-cst:utils.converter.ts.fromNativeScripts",
      "name": "fromNativeScripts",
      "signature": "const fromNativeScripts = (scripts: CstNativeScript[]) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "scripts",
          "type": "CstNativeScript[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 220,
      "raw": "  const fromNativeScripts = (scripts: CstNativeScript[]) => {\n    const nativeScripts = new Array<NativeScript>();\n\n    for (let index = 0; index < scripts.length; index += 1) {\n      const script = scripts[index];\n      if (script) {\n        nativeScripts.push(fromNativeScript(script));\n      }\n    }\n\n    return nativeScripts;\n  };",
      "source": "mesh-core-cst",
      "implementation": "  const fromNativeScripts = (scripts: CstNativeScript[]) => {\n    const nativeScripts = new Array<NativeScript>();\n\n    for (let index = 0; index < scripts.length; index += 1) {\n      const script = scripts[index];\n      if (script) {\n        nativeScripts.push(fromNativeScript(script));\n      }\n    }\n\n    return nativeScripts;\n  };"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toNativeScript",
      "fullName": "mesh-core-cst:utils.converter.ts.toNativeScript",
      "name": "toNativeScript",
      "signature": "export const toNativeScript = (script: NativeScript) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "script",
          "type": "NativeScript",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 282,
      "raw": "export const toNativeScript = (script: NativeScript) => {\n  const toNativeScripts = (scripts: NativeScript[]) => {\n    const nativeScripts: CstNativeScript[] = [];\n\n    scripts.forEach((script) => {\n      nativeScripts.push(toNativeScript(script));\n    });\n\n    return nativeScripts;\n  };\n\n  switch (script.type) {\n    case \"all\":\n      return CstNativeScript.newScriptAll(\n        new Serialization.ScriptAll(toNativeScripts(script.scripts)),\n      );\n    case \"any\":\n      return CstNativeScript.newScriptAny(\n        new Serialization.ScriptAny(toNativeScripts(script.scripts)),\n      );\n    case \"atLeast\":\n      return CstNativeScript.newScriptNOfK(\n        new Serialization.ScriptNOfK(\n          toNativeScripts(script.scripts),\n          script.required,\n        ),\n      );\n    case \"after\":\n      return CstNativeScript.newTimelockStart(\n        new Serialization.TimelockStart(Slot(parseInt(script.slot))),\n      );\n    case \"before\":\n      return CstNativeScript.newTimelockExpiry(\n        new Serialization.TimelockExpiry(Slot(parseInt(script.slot))),\n      );\n    case \"sig\":\n      return CstNativeScript.newScriptPubkey(\n        new Serialization.ScriptPubkey(\n          Ed25519KeyHash.fromBytes(toBytes(script.keyHash)).hex(),\n        ),\n      );\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const toNativeScript = (script: NativeScript) => {\n  const toNativeScripts = (scripts: NativeScript[]) => {\n    const nativeScripts: CstNativeScript[] = [];\n\n    scripts.forEach((script) => {\n      nativeScripts.push(toNativeScript(script));\n    });\n\n    return nativeScripts;\n  };\n\n  switch (script.type) {\n    case \"all\":\n      return CstNativeScript.newScriptAll(\n        new Serialization.ScriptAll(toNativeScripts(script.scripts)),\n      );\n    case \"any\":\n      return CstNativeScript.newScriptAny(\n        new Serialization.ScriptAny(toNativeScripts(script.scripts)),\n      );\n    case \"atLeast\":\n      return CstNativeScript.newScriptNOfK(\n        new Serialization.ScriptNOfK(\n          toNativeScripts(script.scripts),\n          script.required,\n        ),\n      );\n    case \"after\":\n      return CstNativeScript.newTimelockStart(\n        new Serialization.TimelockStart(Slot(parseInt(script.slot))),\n      );\n    case \"before\":\n      return CstNativeScript.newTimelockExpiry(\n        new Serialization.TimelockExpiry(Slot(parseInt(script.slot))),\n      );\n    case \"sig\":\n      return CstNativeScript.newScriptPubkey(\n        new Serialization.ScriptPubkey(\n          Ed25519KeyHash.fromBytes(toBytes(script.keyHash)).hex(),\n        ),\n      );\n  }\n};"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toNativeScripts",
      "fullName": "mesh-core-cst:utils.converter.ts.toNativeScripts",
      "name": "toNativeScripts",
      "signature": "const toNativeScripts = (scripts: NativeScript[]) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "scripts",
          "type": "NativeScript[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 283,
      "raw": "  const toNativeScripts = (scripts: NativeScript[]) => {\n    const nativeScripts: CstNativeScript[] = [];\n\n    scripts.forEach((script) => {\n      nativeScripts.push(toNativeScript(script));\n    });\n\n    return nativeScripts;\n  };",
      "source": "mesh-core-cst",
      "implementation": "  const toNativeScripts = (scripts: NativeScript[]) => {\n    const nativeScripts: CstNativeScript[] = [];\n\n    scripts.forEach((script) => {\n      nativeScripts.push(toNativeScript(script));\n    });\n\n    return nativeScripts;\n  };"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toValue",
      "fullName": "mesh-core-cst:utils.converter.ts.toValue",
      "name": "toValue",
      "signature": "export const toValue = (assets: Asset[]) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "assets",
          "type": "Asset[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 326,
      "raw": "export const toValue = (assets: Asset[]) => {\n  const multiAsset: TokenMap = new Map();\n  assets\n    .filter((asset) => asset.unit !== \"lovelace\" && asset.unit !== \"\")\n    .forEach((asset) => {\n      multiAsset.set(AssetId(asset.unit), BigInt(asset.quantity));\n    });\n\n  const lovelace = assets.find((asset) => asset.unit === \"lovelace\" || asset.unit === \"\");\n  const value = new Value(BigInt(lovelace ? lovelace.quantity : 0));\n\n  if (assets.length > 1 || !lovelace) {\n    value.setMultiasset(multiAsset);\n  }\n\n  return value;\n};",
      "source": "mesh-core-cst",
      "implementation": "export const toValue = (assets: Asset[]) => {\n  const multiAsset: TokenMap = new Map();\n  assets\n    .filter((asset) => asset.unit !== \"lovelace\" && asset.unit !== \"\")\n    .forEach((asset) => {\n      multiAsset.set(AssetId(asset.unit), BigInt(asset.quantity));\n    });\n\n  const lovelace = assets.find((asset) => asset.unit === \"lovelace\" || asset.unit === \"\");\n  const value = new Value(BigInt(lovelace ? lovelace.quantity : 0));\n\n  if (assets.length > 1 || !lovelace) {\n    value.setMultiasset(multiAsset);\n  }\n\n  return value;\n};"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toDRep",
      "fullName": "mesh-core-cst:utils.converter.ts.toDRep",
      "name": "toDRep",
      "signature": "export const toDRep = (dRepId: string): Serialization.DRep => {",
      "documentation": "",
      "parameters": [
        {
          "name": "dRepId",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Serialization.DRep",
      "isPublic": true,
      "line": 344,
      "raw": "export const toDRep = (dRepId: string): Serialization.DRep => {\n  if (dRepId.length === 58) {\n    // CIP-129 DRepIds have length of 58\n    const { prefix, words } = bech32.decode(dRepId);\n    if (prefix !== \"drep\") {\n      throw new Error(\"Invalid DRepId prefix\");\n    }\n    const bytes = base32.decode(new Uint8Array(words));\n    if (bytes[0] === 0x22) {\n      return Serialization.DRep.newKeyHash(\n        Ed25519KeyHashHex(bytes.subarray(1).toString(\"hex\")),\n      );\n    } else if (bytes[0] === 0x23) {\n      return Serialization.DRep.newScriptHash(\n        Hash28ByteBase16(bytes.subarray(1).toString(\"hex\")),\n      );\n    } else {\n      throw new Error(\"Malformed CIP129 DRepId\");\n    }\n  } else {\n    // CIP-105 DRepIds have length of 56 or 63 depending on vkey or script prefix\n    const { prefix, words } = bech32.decode(dRepId);\n    switch (prefix) {\n      case \"drep\": {\n        return Serialization.DRep.newKeyHash(\n          Ed25519KeyHashHex(\n            base32.decode(new Uint8Array(words)).toString(\"hex\"),\n          ),\n        );\n      }\n      case \"drep_script\": {\n        return Serialization.DRep.newScriptHash(\n          Hash28ByteBase16(\n            base32.decode(new Uint8Array(words)).toString(\"hex\"),\n          ),\n        );\n      }\n      default: {\n        throw new Error(\"Malformed DRepId prefix\");\n      }\n    }\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const toDRep = (dRepId: string): Serialization.DRep => {\n  if (dRepId.length === 58) {\n    // CIP-129 DRepIds have length of 58\n    const { prefix, words } = bech32.decode(dRepId);\n    if (prefix !== \"drep\") {\n      throw new Error(\"Invalid DRepId prefix\");\n    }\n    const bytes = base32.decode(new Uint8Array(words));\n    if (bytes[0] === 0x22) {\n      return Serialization.DRep.newKeyHash(\n        Ed25519KeyHashHex(bytes.subarray(1).toString(\"hex\")),\n      );\n    } else if (bytes[0] === 0x23) {\n      return Serialization.DRep.newScriptHash(\n        Hash28ByteBase16(bytes.subarray(1).toString(\"hex\")),\n      );\n    } else {\n      throw new Error(\"Malformed CIP129 DRepId\");\n    }\n  } else {\n    // CIP-105 DRepIds have length of 56 or 63 depending on vkey or script prefix\n    const { prefix, words } = bech32.decode(dRepId);\n    switch (prefix) {\n      case \"drep\": {\n        return Serialization.DRep.newKeyHash(\n          Ed25519KeyHashHex(\n            base32.decode(new Uint8Array(words)).toString(\"hex\"),\n          ),\n        );\n      }\n      case \"drep_script\": {\n        return Serialization.DRep.newScriptHash(\n          Hash28ByteBase16(\n            base32.decode(new Uint8Array(words)).toString(\"hex\"),\n          ),\n        );\n      }\n      default: {\n        throw new Error(\"Malformed DRepId prefix\");\n      }\n    }\n  }\n};"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.getDRepIds",
      "fullName": "mesh-core-cst:utils.converter.ts.getDRepIds",
      "name": "getDRepIds",
      "signature": "export const getDRepIds = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 388,
      "raw": "export const getDRepIds = (\n  dRepId: string,\n): {\n  cip105: string;\n  cip129: string;\n} => {\n  let result = {\n    cip105: \"\",\n    cip129: \"\",\n  };\n  if (dRepId.length === 58) {\n    result.cip129 = dRepId;\n    const { prefix, words } = bech32.decode(dRepId);\n    if (prefix !== \"drep\") {\n      throw new Error(\"Malformed CIP129 DRepId\");\n    }\n    const bytes = base32.decode(new Uint8Array(words));\n    if (bytes[0] === 0x22) {\n      result.cip105 = bech32.encode(\"drep\", base32.encode(bytes.subarray(1)));\n    } else if (bytes[0] === 0x23) {\n      result.cip105 = bech32.encode(\n        \"drep_script\",\n        base32.encode(bytes.subarray(1)),\n      );\n    } else {\n      throw new Error(\"Malformed CIP129 DRepId\");\n    }\n  } else {\n    result.cip105 = dRepId;\n    try {\n      const { prefix, words } = bech32.decode(dRepId);\n      let rawBytes = base32.decode(new Uint8Array(words));\n      if (prefix === \"drep\") {\n        if (!rawBytes) {\n          throw new Error(\"Malformed key hash in DRepId\");\n        }\n        let rawBytesWithPrefix = new Uint8Array(rawBytes.length + 1);\n        rawBytesWithPrefix.set([0x22]);\n        rawBytesWithPrefix.set(rawBytes, 1);\n        let base32RawBytes = base32.encode(rawBytesWithPrefix);\n        result.cip129 = bech32.encode(\"drep\", base32RawBytes);\n      } else if (prefix === \"drep_script\") {\n        if (!rawBytes) {\n          throw new Error(\"Malformed script hash in DRepId\");\n        }\n        let rawBytesWithPrefix = new Uint8Array(rawBytes.length + 1);\n        rawBytesWithPrefix.set([0x23]);\n        rawBytesWithPrefix.set(rawBytes, 1);\n        let base32RawBytes = base32.encode(rawBytesWithPrefix);\n        result.cip129 = bech32.encode(\"drep\", base32RawBytes);\n      } else {\n        throw new Error(\"Can only calculate DRepIds for script/key DReps\");\n      }\n    } catch (e) {\n      console.error(e);\n      throw new Error(\"Malformed DRepId\");\n    }\n  }\n  return result;\n};",
      "source": "mesh-core-cst",
      "implementation": "export const getDRepIds = (\n  dRepId: string,\n): {\n  cip105: string;\n  cip129: string;\n} => {\n  let result = {\n    cip105: \"\",\n    cip129: \"\",\n  };\n  if (dRepId.length === 58) {\n    result.cip129 = dRepId;\n    const { prefix, words } = bech32.decode(dRepId);\n    if (prefix !== \"drep\") {\n      throw new Error(\"Malformed CIP129 DRepId\");\n    }\n    const bytes = base32.decode(new Uint8Array(words));\n    if (bytes[0] === 0x22) {\n      result.cip105 = bech32.encode(\"drep\", base32.encode(bytes.subarray(1)));\n    } else if (bytes[0] === 0x23) {\n      result.cip105 = bech32.encode(\n        \"drep_script\",\n        base32.encode(bytes.subarray(1)),\n      );\n    } else {\n      throw new Error(\"Malformed CIP129 DRepId\");\n    }\n  } else {\n    result.cip105 = dRepId;\n    try {\n      const { prefix, words } = bech32.decode(dRepId);\n      let rawBytes = base32.decode(new Uint8Array(words));\n      if (prefix === \"drep\") {\n        if (!rawBytes) {\n          throw new Error(\"Malformed key hash in DRepId\");\n        }\n        let rawBytesWithPrefix = new Uint8Array(rawBytes.length + 1);\n        rawBytesWithPrefix.set([0x22]);\n        rawBytesWithPrefix.set(rawBytes, 1);\n        let base32RawBytes = base32.encode(rawBytesWithPrefix);\n        result.cip129 = bech32.encode(\"drep\", base32RawBytes);\n      } else if (prefix === \"drep_script\") {\n        if (!rawBytes) {\n          throw new Error(\"Malformed script hash in DRepId\");\n        }\n        let rawBytesWithPrefix = new Uint8Array(rawBytes.length + 1);\n        rawBytesWithPrefix.set([0x23]);\n        rawBytesWithPrefix.set(rawBytes, 1);\n        let base32RawBytes = base32.encode(rawBytesWithPrefix);\n        result.cip129 = bech32.encode(\"drep\", base32RawBytes);\n      } else {\n        throw new Error(\"Can only calculate DRepIds for script/key DReps\");\n      }\n    } catch (e) {\n      console.error(e);\n      throw new Error(\"Malformed DRepId\");\n    }\n  }\n  return result;\n};"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.toPlutusData",
      "fullName": "mesh-core-cst:utils.data.ts.toPlutusData",
      "name": "toPlutusData",
      "signature": "export const toPlutusData = (data: Data): PlutusData => {",
      "documentation": "",
      "parameters": [
        {
          "name": "data",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "PlutusData",
      "isPublic": true,
      "line": 14,
      "raw": "export const toPlutusData = (data: Data): PlutusData => {\n  const toPlutusList = (data: Data[]) => {\n    const plutusList = new PlutusList();\n    data.forEach((element) => {\n      plutusList.add(toPlutusData(element));\n    });\n    return plutusList;\n  };\n\n  switch (typeof data) {\n    case \"string\":\n      return PlutusData.newBytes(toBytes(data));\n    case \"number\":\n      return PlutusData.newInteger(BigInt(data));\n    case \"bigint\":\n      return PlutusData.newInteger(BigInt(data));\n    case \"object\":\n      if (data instanceof Array) {\n        const plutusList = toPlutusList(data);\n        return PlutusData.newList(plutusList);\n      } else if (data instanceof Map) {\n        const plutusMap = new PlutusMap();\n        data.forEach((value, key) => {\n          plutusMap.insert(toPlutusData(key), toPlutusData(value));\n        });\n        return PlutusData.newMap(plutusMap);\n      } else {\n        return PlutusData.newConstrPlutusData(\n          new ConstrPlutusData(\n            BigInt(data.alternative),\n            toPlutusList(data.fields),\n          ),\n        );\n      }\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const toPlutusData = (data: Data): PlutusData => {\n  const toPlutusList = (data: Data[]) => {\n    const plutusList = new PlutusList();\n    data.forEach((element) => {\n      plutusList.add(toPlutusData(element));\n    });\n    return plutusList;\n  };\n\n  switch (typeof data) {\n    case \"string\":\n      return PlutusData.newBytes(toBytes(data));\n    case \"number\":\n      return PlutusData.newInteger(BigInt(data));\n    case \"bigint\":\n      return PlutusData.newInteger(BigInt(data));\n    case \"object\":\n      if (data instanceof Array) {\n        const plutusList = toPlutusList(data);\n        return PlutusData.newList(plutusList);\n      } else if (data instanceof Map) {\n        const plutusMap = new PlutusMap();\n        data.forEach((value, key) => {\n          plutusMap.insert(toPlutusData(key), toPlutusData(value));\n        });\n        return PlutusData.newMap(plutusMap);\n      } else {\n        return PlutusData.newConstrPlutusData(\n          new ConstrPlutusData(\n            BigInt(data.alternative),\n            toPlutusList(data.fields),\n          ),\n        );\n      }\n  }\n};"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.toPlutusList",
      "fullName": "mesh-core-cst:utils.data.ts.toPlutusList",
      "name": "toPlutusList",
      "signature": "const toPlutusList = (data: Data[]) => {",
      "documentation": "",
      "parameters": [
        {
          "name": "data",
          "type": "Data[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 15,
      "raw": "  const toPlutusList = (data: Data[]) => {\n    const plutusList = new PlutusList();\n    data.forEach((element) => {\n      plutusList.add(toPlutusData(element));\n    });\n    return plutusList;\n  };",
      "source": "mesh-core-cst",
      "implementation": "  const toPlutusList = (data: Data[]) => {\n    const plutusList = new PlutusList();\n    data.forEach((element) => {\n      plutusList.add(toPlutusData(element));\n    });\n    return plutusList;\n  };"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.isConstrPlutusDataJson",
      "fullName": "mesh-core-cst:utils.data.ts.isConstrPlutusDataJson",
      "name": "isConstrPlutusDataJson",
      "signature": "const isConstrPlutusDataJson = (data: object): data is ConstrPlutusDataJson => {",
      "documentation": "",
      "parameters": [
        {
          "name": "data",
          "type": "object",
          "optional": false
        }
      ],
      "returnType": "data is ConstrPlutusDataJson",
      "isPublic": true,
      "line": 56,
      "raw": "const isConstrPlutusDataJson = (data: object): data is ConstrPlutusDataJson => {\n  return (\n    typeof data === \"object\" &&\n    \"constructor\" in data &&\n    (typeof data.constructor === \"number\" ||\n      typeof data.constructor === \"bigint\" ||\n      typeof data.constructor === \"string\") &&\n    \"fields\" in data &&\n    Array.isArray(data.fields)\n  );\n};",
      "source": "mesh-core-cst",
      "implementation": "const isConstrPlutusDataJson = (data: object): data is ConstrPlutusDataJson => {\n  return (\n    typeof data === \"object\" &&\n    \"constructor\" in data &&\n    (typeof data.constructor === \"number\" ||\n      typeof data.constructor === \"bigint\" ||\n      typeof data.constructor === \"string\") &&\n    \"fields\" in data &&\n    Array.isArray(data.fields)\n  );\n};"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.isMapPlutusDataJson",
      "fullName": "mesh-core-cst:utils.data.ts.isMapPlutusDataJson",
      "name": "isMapPlutusDataJson",
      "signature": "function isMapPlutusDataJson(data: any) {",
      "documentation": "",
      "parameters": [
        {
          "name": "data",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 73,
      "raw": "function isMapPlutusDataJson(data: any) {\n  return typeof data === \"object\" && Array.isArray(data);\n}",
      "source": "mesh-core-cst",
      "implementation": "function isMapPlutusDataJson(data: any) {\n  return typeof data === \"object\" && Array.isArray(data);\n}"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.isKeyValuePlutusDataJson",
      "fullName": "mesh-core-cst:utils.data.ts.isKeyValuePlutusDataJson",
      "name": "isKeyValuePlutusDataJson",
      "signature": "function isKeyValuePlutusDataJson(data: any): data is KeyValuePlutusDataJson {",
      "documentation": "",
      "parameters": [
        {
          "name": "data",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "data is KeyValuePlutusDataJson",
      "isPublic": true,
      "line": 77,
      "raw": "function isKeyValuePlutusDataJson(data: any): data is KeyValuePlutusDataJson {\n  return (\n    typeof data === \"object\" &&\n    \"k\" in data &&\n    typeof data.k === \"object\" &&\n    \"v\" in data &&\n    typeof data.v === \"object\"\n  );\n}",
      "source": "mesh-core-cst",
      "implementation": "function isKeyValuePlutusDataJson(data: any): data is KeyValuePlutusDataJson {\n  return (\n    typeof data === \"object\" &&\n    \"k\" in data &&\n    typeof data.k === \"object\" &&\n    \"v\" in data &&\n    typeof data.v === \"object\"\n  );\n}"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.fromJsonToPlutusData",
      "fullName": "mesh-core-cst:utils.data.ts.fromJsonToPlutusData",
      "name": "fromJsonToPlutusData",
      "signature": "export const fromJsonToPlutusData = (data: object): PlutusData => {",
      "documentation": "",
      "parameters": [
        {
          "name": "data",
          "type": "object",
          "optional": false
        }
      ],
      "returnType": "PlutusData",
      "isPublic": true,
      "line": 87,
      "raw": "export const fromJsonToPlutusData = (data: object): PlutusData => {\n  if (isConstrPlutusDataJson(data)) {\n    const plutusList = new PlutusList();\n    data.fields.map((val) => {\n      plutusList.add(fromJsonToPlutusData(val));\n    });\n    const plutusConstrData = new ConstrPlutusData(\n      BigInt(data.constructor),\n      plutusList,\n    );\n    return PlutusData.newConstrPlutusData(plutusConstrData);\n  } else if (\"int\" in data && Object.keys(data).length === 1) {\n    if (\n      typeof data.int === \"bigint\" ||\n      typeof data.int === \"number\" ||\n      typeof data.int === \"string\"\n    ) {\n      return PlutusData.newInteger(BigInt(data.int));\n    } else {\n      throw new Error(\n        \"Malformed int field in Plutus data, expected one of bigint, number or string\",\n      );\n    }\n  } else if (\"bytes\" in data && Object.keys(data).length === 1) {\n    if (typeof data.bytes === \"string\") {\n      return PlutusData.newBytes(Buffer.from(data.bytes, \"hex\"));\n    } else {\n      throw new Error(\"Malformed bytes field in Plutus data, expected string\");\n    }\n  } else if (\"list\" in data && Object.keys(data).length === 1) {\n    if (Array.isArray(data.list)) {\n      const plutusList = new PlutusList();\n      data.list.map((val) => {\n        plutusList.add(fromJsonToPlutusData(val));\n      });\n      return PlutusData.newList(plutusList);\n    } else {\n      throw new Error(\"Malformed list field in Plutus data, expected list\");\n    }\n  } else if (\"map\" in data && Object.keys(data).length === 1) {\n    if (isMapPlutusDataJson(data.map)) {\n      const plutusMap = new PlutusMap();\n      data.map.forEach((val) => {\n        if (isKeyValuePlutusDataJson(val)) {\n          plutusMap.insert(\n            fromJsonToPlutusData(val.k),\n            fromJsonToPlutusData(val.v),\n          );\n        } else {\n          throw new Error(\"Malformed key value pair in Plutus data map\");\n        }\n      });\n      return PlutusData.newMap(plutusMap);\n    } else {\n      console.log(data);\n      throw new Error(\"Malformed map field in Plutus data\");\n    }\n  } else {\n    throw new Error(\"Malformed Plutus data json\");\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const fromJsonToPlutusData = (data: object): PlutusData => {\n  if (isConstrPlutusDataJson(data)) {\n    const plutusList = new PlutusList();\n    data.fields.map((val) => {\n      plutusList.add(fromJsonToPlutusData(val));\n    });\n    const plutusConstrData = new ConstrPlutusData(\n      BigInt(data.constructor),\n      plutusList,\n    );\n    return PlutusData.newConstrPlutusData(plutusConstrData);\n  } else if (\"int\" in data && Object.keys(data).length === 1) {\n    if (\n      typeof data.int === \"bigint\" ||\n      typeof data.int === \"number\" ||\n      typeof data.int === \"string\"\n    ) {\n      return PlutusData.newInteger(BigInt(data.int));\n    } else {\n      throw new Error(\n        \"Malformed int field in Plutus data, expected one of bigint, number or string\",\n      );\n    }\n  } else if (\"bytes\" in data && Object.keys(data).length === 1) {\n    if (typeof data.bytes === \"string\") {\n      return PlutusData.newBytes(Buffer.from(data.bytes, \"hex\"));\n    } else {\n      throw new Error(\"Malformed bytes field in Plutus data, expected string\");\n    }\n  } else if (\"list\" in data && Object.keys(data).length === 1) {\n    if (Array.isArray(data.list)) {\n      const plutusList = new PlutusList();\n      data.list.map((val) => {\n        plutusList.add(fromJsonToPlutusData(val));\n      });\n      return PlutusData.newList(plutusList);\n    } else {\n      throw new Error(\"Malformed list field in Plutus data, expected list\");\n    }\n  } else if (\"map\" in data && Object.keys(data).length === 1) {\n    if (isMapPlutusDataJson(data.map)) {\n      const plutusMap = new PlutusMap();\n      data.map.forEach((val) => {\n        if (isKeyValuePlutusDataJson(val)) {\n          plutusMap.insert(\n            fromJsonToPlutusData(val.k),\n            fromJsonToPlutusData(val.v),\n          );\n        } else {\n          throw new Error(\"Malformed key value pair in Plutus data map\");\n        }\n      });\n      return PlutusData.newMap(plutusMap);\n    } else {\n      console.log(data);\n      throw new Error(\"Malformed map field in Plutus data\");\n    }\n  } else {\n    throw new Error(\"Malformed Plutus data json\");\n  }\n};"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.fromBuilderToPlutusData",
      "fullName": "mesh-core-cst:utils.data.ts.fromBuilderToPlutusData",
      "name": "fromBuilderToPlutusData",
      "signature": "export const fromBuilderToPlutusData = (data: BuilderData): PlutusData => {",
      "documentation": "",
      "parameters": [
        {
          "name": "data",
          "type": "BuilderData",
          "optional": false
        }
      ],
      "returnType": "PlutusData",
      "isPublic": true,
      "line": 149,
      "raw": "export const fromBuilderToPlutusData = (data: BuilderData): PlutusData => {\n  if (data.type === \"Mesh\") {\n    return toPlutusData(data.content);\n  } else if (data.type === \"CBOR\") {\n    return PlutusData.fromCbor(HexBlob(data.content));\n  } else if (data.type === \"JSON\") {\n    let content: object;\n    if (typeof data.content === \"string\") {\n      content = JSON.parse(data.content);\n    } else {\n      content = data.content;\n    }\n    return fromJsonToPlutusData(content);\n  } else {\n    throw new Error(\n      \"Malformed builder data, expected types of, Mesh, CBOR or JSON\",\n    );\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const fromBuilderToPlutusData = (data: BuilderData): PlutusData => {\n  if (data.type === \"Mesh\") {\n    return toPlutusData(data.content);\n  } else if (data.type === \"CBOR\") {\n    return PlutusData.fromCbor(HexBlob(data.content));\n  } else if (data.type === \"JSON\") {\n    let content: object;\n    if (typeof data.content === \"string\") {\n      content = JSON.parse(data.content);\n    } else {\n      content = data.content;\n    }\n    return fromJsonToPlutusData(content);\n  } else {\n    throw new Error(\n      \"Malformed builder data, expected types of, Mesh, CBOR or JSON\",\n    );\n  }\n};"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.fromPlutusDataToJson",
      "fullName": "mesh-core-cst:utils.data.ts.fromPlutusDataToJson",
      "name": "fromPlutusDataToJson",
      "signature": "export const fromPlutusDataToJson = (data: PlutusData): object => {",
      "documentation": "",
      "parameters": [
        {
          "name": "data",
          "type": "PlutusData",
          "optional": false
        }
      ],
      "returnType": "object",
      "isPublic": true,
      "line": 169,
      "raw": "export const fromPlutusDataToJson = (data: PlutusData): object => {\n  if (data.getKind() === PlutusDataKind.ConstrPlutusData) {\n    const plutusData = data.asConstrPlutusData();\n    if (plutusData !== undefined) {\n      const fields = plutusData.getData();\n      const list: object[] = [];\n      for (let i = 0; i < fields.getLength(); i++) {\n        const element = fields.get(i);\n        list.push(fromPlutusDataToJson(element));\n      }\n      return {\n        constructor: plutusData.getAlternative(),\n        fields: list,\n      };\n    } else {\n      throw new Error(\"Invalid constructor data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Map) {\n    const plutusMap = data.asMap();\n    const mapList: {\n      k: object;\n      v: object;\n    }[] = [];\n    if (plutusMap !== undefined) {\n      const keys = plutusMap.getKeys();\n      for (let i = 0; i < keys.getLength(); i++) {\n        const key = keys.get(i);\n        const value = plutusMap.get(key);\n        if (value) {\n          mapList.push({\n            k: fromPlutusDataToJson(key),\n            v: fromPlutusDataToJson(value),\n          });\n        }\n      }\n      return {\n        map: mapList,\n      };\n    } else {\n      throw new Error(\"Invalid map data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.List) {\n    const plutusList = data.asList();\n    if (plutusList !== undefined) {\n      const list: object[] = [];\n      for (let i = 0; i < plutusList.getLength(); i++) {\n        const element = plutusList.get(i);\n        list.push(fromPlutusDataToJson(element));\n      }\n      return { list: list };\n    } else {\n      throw new Error(\"Invalid list data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Integer) {\n    const plutusInt = data.asInteger();\n    if (plutusInt !== undefined) {\n      return {\n        int: plutusInt,\n      };\n    } else {\n      throw new Error(\"Invalid integer data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Bytes) {\n    const plutusBytes = data.asBoundedBytes();\n    if (plutusBytes !== undefined) {\n      return {\n        bytes: Buffer.from(plutusBytes).toString(\"hex\"),\n      };\n    } else {\n      throw new Error(\"Invalid bytes data found\");\n    }\n  } else {\n    throw new Error(\"Invalid Plutus data found\");\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const fromPlutusDataToJson = (data: PlutusData): object => {\n  if (data.getKind() === PlutusDataKind.ConstrPlutusData) {\n    const plutusData = data.asConstrPlutusData();\n    if (plutusData !== undefined) {\n      const fields = plutusData.getData();\n      const list: object[] = [];\n      for (let i = 0; i < fields.getLength(); i++) {\n        const element = fields.get(i);\n        list.push(fromPlutusDataToJson(element));\n      }\n      return {\n        constructor: plutusData.getAlternative(),\n        fields: list,\n      };\n    } else {\n      throw new Error(\"Invalid constructor data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Map) {\n    const plutusMap = data.asMap();\n    const mapList: {\n      k: object;\n      v: object;\n    }[] = [];\n    if (plutusMap !== undefined) {\n      const keys = plutusMap.getKeys();\n      for (let i = 0; i < keys.getLength(); i++) {\n        const key = keys.get(i);\n        const value = plutusMap.get(key);\n        if (value) {\n          mapList.push({\n            k: fromPlutusDataToJson(key),\n            v: fromPlutusDataToJson(value),\n          });\n        }\n      }\n      return {\n        map: mapList,\n      };\n    } else {\n      throw new Error(\"Invalid map data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.List) {\n    const plutusList = data.asList();\n    if (plutusList !== undefined) {\n      const list: object[] = [];\n      for (let i = 0; i < plutusList.getLength(); i++) {\n        const element = plutusList.get(i);\n        list.push(fromPlutusDataToJson(element));\n      }\n      return { list: list };\n    } else {\n      throw new Error(\"Invalid list data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Integer) {\n    const plutusInt = data.asInteger();\n    if (plutusInt !== undefined) {\n      return {\n        int: plutusInt,\n      };\n    } else {\n      throw new Error(\"Invalid integer data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Bytes) {\n    const plutusBytes = data.asBoundedBytes();\n    if (plutusBytes !== undefined) {\n      return {\n        bytes: Buffer.from(plutusBytes).toString(\"hex\"),\n      };\n    } else {\n      throw new Error(\"Invalid bytes data found\");\n    }\n  } else {\n    throw new Error(\"Invalid Plutus data found\");\n  }\n};"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.if",
      "fullName": "mesh-core-cst:utils.data.ts.if",
      "name": "if",
      "signature": "if (data.getKind() === PlutusDataKind.ConstrPlutusData) {",
      "documentation": "",
      "parameters": [
        {
          "name": "data.getKind(",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 170,
      "raw": "  if (data.getKind() === PlutusDataKind.ConstrPlutusData) {\n    const plutusData = data.asConstrPlutusData();\n    if (plutusData !== undefined) {\n      const fields = plutusData.getData();\n      const list: object[] = [];\n      for (let i = 0; i < fields.getLength(); i++) {\n        const element = fields.get(i);\n        list.push(fromPlutusDataToJson(element));\n      }\n      return {\n        constructor: plutusData.getAlternative(),\n        fields: list,\n      };\n    } else {\n      throw new Error(\"Invalid constructor data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Map) {\n    const plutusMap = data.asMap();\n    const mapList: {\n      k: object;\n      v: object;\n    }[] = [];\n    if (plutusMap !== undefined) {\n      const keys = plutusMap.getKeys();\n      for (let i = 0; i < keys.getLength(); i++) {\n        const key = keys.get(i);\n        const value = plutusMap.get(key);\n        if (value) {\n          mapList.push({\n            k: fromPlutusDataToJson(key),\n            v: fromPlutusDataToJson(value),\n          });\n        }\n      }\n      return {\n        map: mapList,\n      };\n    } else {\n      throw new Error(\"Invalid map data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.List) {\n    const plutusList = data.asList();\n    if (plutusList !== undefined) {\n      const list: object[] = [];\n      for (let i = 0; i < plutusList.getLength(); i++) {\n        const element = plutusList.get(i);\n        list.push(fromPlutusDataToJson(element));\n      }\n      return { list: list };\n    } else {\n      throw new Error(\"Invalid list data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Integer) {\n    const plutusInt = data.asInteger();\n    if (plutusInt !== undefined) {\n      return {\n        int: plutusInt,\n      };\n    } else {\n      throw new Error(\"Invalid integer data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Bytes) {\n    const plutusBytes = data.asBoundedBytes();\n    if (plutusBytes !== undefined) {\n      return {\n        bytes: Buffer.from(plutusBytes).toString(\"hex\"),\n      };\n    } else {\n      throw new Error(\"Invalid bytes data found\");\n    }\n  } else {\n    throw new Error(\"Invalid Plutus data found\");\n  }",
      "source": "mesh-core-cst",
      "implementation": "  if (data.getKind() === PlutusDataKind.ConstrPlutusData) {\n    const plutusData = data.asConstrPlutusData();\n    if (plutusData !== undefined) {\n      const fields = plutusData.getData();\n      const list: object[] = [];\n      for (let i = 0; i < fields.getLength(); i++) {\n        const element = fields.get(i);\n        list.push(fromPlutusDataToJson(element));\n      }\n      return {\n        constructor: plutusData.getAlternative(),\n        fields: list,\n      };\n    } else {\n      throw new Error(\"Invalid constructor data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Map) {\n    const plutusMap = data.asMap();\n    const mapList: {\n      k: object;\n      v: object;\n    }[] = [];\n    if (plutusMap !== undefined) {\n      const keys = plutusMap.getKeys();\n      for (let i = 0; i < keys.getLength(); i++) {\n        const key = keys.get(i);\n        const value = plutusMap.get(key);\n        if (value) {\n          mapList.push({\n            k: fromPlutusDataToJson(key),\n            v: fromPlutusDataToJson(value),\n          });\n        }\n      }\n      return {\n        map: mapList,\n      };\n    } else {\n      throw new Error(\"Invalid map data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.List) {\n    const plutusList = data.asList();\n    if (plutusList !== undefined) {\n      const list: object[] = [];\n      for (let i = 0; i < plutusList.getLength(); i++) {\n        const element = plutusList.get(i);\n        list.push(fromPlutusDataToJson(element));\n      }\n      return { list: list };\n    } else {\n      throw new Error(\"Invalid list data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Integer) {\n    const plutusInt = data.asInteger();\n    if (plutusInt !== undefined) {\n      return {\n        int: plutusInt,\n      };\n    } else {\n      throw new Error(\"Invalid integer data found\");\n    }\n  } else if (data.getKind() === PlutusDataKind.Bytes) {\n    const plutusBytes = data.asBoundedBytes();\n    if (plutusBytes !== undefined) {\n      return {\n        bytes: Buffer.from(plutusBytes).toString(\"hex\"),\n      };\n    } else {\n      throw new Error(\"Invalid bytes data found\");\n    }\n  } else {\n    throw new Error(\"Invalid Plutus data found\");\n  }"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.deserializeDataHash",
      "fullName": "mesh-core-cst:utils.data.ts.deserializeDataHash",
      "name": "deserializeDataHash",
      "signature": "export const deserializeDataHash = (dataHash: string): DatumHash =>",
      "documentation": "",
      "parameters": [
        {
          "name": "dataHash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "DatumHash",
      "isPublic": true,
      "line": 260,
      "raw": "export const deserializeDataHash = (dataHash: string): DatumHash =>",
      "source": "mesh-core-cst",
      "implementation": "export const deserializeDataHash = (dataHash: string): DatumHash =>"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.deserializePlutusData",
      "fullName": "mesh-core-cst:utils.data.ts.deserializePlutusData",
      "name": "deserializePlutusData",
      "signature": "export const deserializePlutusData = (plutusData: string): PlutusData =>",
      "documentation": "",
      "parameters": [
        {
          "name": "plutusData",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "PlutusData",
      "isPublic": true,
      "line": 263,
      "raw": "export const deserializePlutusData = (plutusData: string): PlutusData =>",
      "source": "mesh-core-cst",
      "implementation": "export const deserializePlutusData = (plutusData: string): PlutusData =>"
    },
    {
      "key": "mesh-core-cst:utils.deserializer.ts.deserializeEd25519KeyHash",
      "fullName": "mesh-core-cst:utils.deserializer.ts.deserializeEd25519KeyHash",
      "name": "deserializeEd25519KeyHash",
      "signature": "export const deserializeEd25519KeyHash = (ed25519KeyHash: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "ed25519KeyHash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 21,
      "raw": "export const deserializeEd25519KeyHash = (ed25519KeyHash: string) =>\n  Ed25519KeyHash.fromBytes(toBytes(ed25519KeyHash));\n\nexport const deserializePlutusScript = (\n  plutusScript: string,\n  version: LanguageVersion,\n): PlutusV1Script | PlutusV2Script | PlutusV3Script => {\n  switch (version) {\n    case \"V1\":\n      return PlutusV1Script.fromCbor(HexBlob(plutusScript));\n    case \"V2\":\n      return PlutusV2Script.fromCbor(HexBlob(plutusScript));\n    case \"V3\":\n      return PlutusV3Script.fromCbor(HexBlob(plutusScript));\n    default:\n      throw new Error(\"Invalid Plutus script version\");\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const deserializeEd25519KeyHash = (ed25519KeyHash: string) =>\n  Ed25519KeyHash.fromBytes(toBytes(ed25519KeyHash));\n\nexport const deserializePlutusScript = (\n  plutusScript: string,\n  version: LanguageVersion,\n): PlutusV1Script | PlutusV2Script | PlutusV3Script => {\n  switch (version) {\n    case \"V1\":\n      return PlutusV1Script.fromCbor(HexBlob(plutusScript));\n    case \"V2\":\n      return PlutusV2Script.fromCbor(HexBlob(plutusScript));\n    case \"V3\":\n      return PlutusV3Script.fromCbor(HexBlob(plutusScript));\n    default:\n      throw new Error(\"Invalid Plutus script version\");\n  }\n};"
    },
    {
      "key": "mesh-core-cst:utils.deserializer.ts.deserializePlutusScript",
      "fullName": "mesh-core-cst:utils.deserializer.ts.deserializePlutusScript",
      "name": "deserializePlutusScript",
      "signature": "export const deserializePlutusScript = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 24,
      "raw": "export const deserializePlutusScript = (\n  plutusScript: string,\n  version: LanguageVersion,\n): PlutusV1Script | PlutusV2Script | PlutusV3Script => {\n  switch (version) {\n    case \"V1\":\n      return PlutusV1Script.fromCbor(HexBlob(plutusScript));\n    case \"V2\":\n      return PlutusV2Script.fromCbor(HexBlob(plutusScript));\n    case \"V3\":\n      return PlutusV3Script.fromCbor(HexBlob(plutusScript));\n    default:\n      throw new Error(\"Invalid Plutus script version\");\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const deserializePlutusScript = (\n  plutusScript: string,\n  version: LanguageVersion,\n): PlutusV1Script | PlutusV2Script | PlutusV3Script => {\n  switch (version) {\n    case \"V1\":\n      return PlutusV1Script.fromCbor(HexBlob(plutusScript));\n    case \"V2\":\n      return PlutusV2Script.fromCbor(HexBlob(plutusScript));\n    case \"V3\":\n      return PlutusV3Script.fromCbor(HexBlob(plutusScript));\n    default:\n      throw new Error(\"Invalid Plutus script version\");\n  }\n};"
    },
    {
      "key": "mesh-core-cst:utils.deserializer.ts.deserializeNativeScript",
      "fullName": "mesh-core-cst:utils.deserializer.ts.deserializeNativeScript",
      "name": "deserializeNativeScript",
      "signature": "export const deserializeNativeScript = (nativeScript: string): NativeScript =>",
      "documentation": "",
      "parameters": [
        {
          "name": "nativeScript",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "NativeScript",
      "isPublic": true,
      "line": 40,
      "raw": "export const deserializeNativeScript = (nativeScript: string): NativeScript =>",
      "source": "mesh-core-cst",
      "implementation": "export const deserializeNativeScript = (nativeScript: string): NativeScript =>"
    },
    {
      "key": "mesh-core-cst:utils.deserializer.ts.deserializeScriptHash",
      "fullName": "mesh-core-cst:utils.deserializer.ts.deserializeScriptHash",
      "name": "deserializeScriptHash",
      "signature": "export const deserializeScriptHash = (scriptHash: string) =>",
      "documentation": "",
      "parameters": [
        {
          "name": "scriptHash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 43,
      "raw": "export const deserializeScriptHash = (scriptHash: string) =>",
      "source": "mesh-core-cst",
      "implementation": "export const deserializeScriptHash = (scriptHash: string) =>"
    },
    {
      "key": "mesh-core-cst:utils.deserializer.ts.deserializeScriptRef",
      "fullName": "mesh-core-cst:utils.deserializer.ts.deserializeScriptRef",
      "name": "deserializeScriptRef",
      "signature": "export const deserializeScriptRef = (scriptRef: string): Script =>",
      "documentation": "",
      "parameters": [
        {
          "name": "scriptRef",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Script",
      "isPublic": true,
      "line": 46,
      "raw": "export const deserializeScriptRef = (scriptRef: string): Script =>",
      "source": "mesh-core-cst",
      "implementation": "export const deserializeScriptRef = (scriptRef: string): Script =>"
    },
    {
      "key": "mesh-core-cst:utils.deserializer.ts.deserializeTxUnspentOutput",
      "fullName": "mesh-core-cst:utils.deserializer.ts.deserializeTxUnspentOutput",
      "name": "deserializeTxUnspentOutput",
      "signature": "export const deserializeTxUnspentOutput = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 49,
      "raw": "export const deserializeTxUnspentOutput = (",
      "source": "mesh-core-cst",
      "implementation": "export const deserializeTxUnspentOutput = ("
    },
    {
      "key": "mesh-core-cst:utils.deserializer.ts.deserializeValue",
      "fullName": "mesh-core-cst:utils.deserializer.ts.deserializeValue",
      "name": "deserializeValue",
      "signature": "export const deserializeValue = (value: string): Value =>",
      "documentation": "",
      "parameters": [
        {
          "name": "value",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Value",
      "isPublic": true,
      "line": 54,
      "raw": "export const deserializeValue = (value: string): Value =>",
      "source": "mesh-core-cst",
      "implementation": "export const deserializeValue = (value: string): Value =>"
    },
    {
      "key": "mesh-core-cst:utils.deserializer.ts.deserializeTx",
      "fullName": "mesh-core-cst:utils.deserializer.ts.deserializeTx",
      "name": "deserializeTx",
      "signature": "export const deserializeTx = (tx: string): Transaction =>",
      "documentation": "",
      "parameters": [
        {
          "name": "tx",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "isPublic": true,
      "line": 57,
      "raw": "export const deserializeTx = (tx: string): Transaction =>",
      "source": "mesh-core-cst",
      "implementation": "export const deserializeTx = (tx: string): Transaction =>"
    },
    {
      "key": "mesh-core-cst:utils.deserializer.ts.deserializeTxHash",
      "fullName": "mesh-core-cst:utils.deserializer.ts.deserializeTxHash",
      "name": "deserializeTxHash",
      "signature": "export const deserializeTxHash = (txHash: string): TransactionId =>",
      "documentation": "",
      "parameters": [
        {
          "name": "txHash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "TransactionId",
      "isPublic": true,
      "line": 60,
      "raw": "export const deserializeTxHash = (txHash: string): TransactionId =>",
      "source": "mesh-core-cst",
      "implementation": "export const deserializeTxHash = (txHash: string): TransactionId =>"
    },
    {
      "key": "mesh-core-cst:utils.encoding.ts.bytesToHex",
      "fullName": "mesh-core-cst:utils.encoding.ts.bytesToHex",
      "name": "bytesToHex",
      "signature": "export const bytesToHex = (bytes: Uint8Array): HexBlob =>",
      "documentation": "",
      "parameters": [
        {
          "name": "bytes",
          "type": "Uint8Array",
          "optional": false
        }
      ],
      "returnType": "HexBlob",
      "isPublic": true,
      "line": 5,
      "raw": "export const bytesToHex = (bytes: Uint8Array): HexBlob =>\n  Buffer.from(bytes).toString(\"hex\") as HexBlob;\n\nexport const hexToBytes = (hex: HexBlob): Uint8Array => Buffer.from(hex, \"hex\");\n\nexport const utf8ToBytes = (str: string): Uint8Array =>\n  Buffer.from(str, \"utf8\");\n\nexport const utf8ToHex = (str: string): HexBlob =>\n  Buffer.from(str, \"utf8\").toString(\"hex\") as HexBlob;\n\nexport const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};",
      "source": "mesh-core-cst",
      "implementation": "export const bytesToHex = (bytes: Uint8Array): HexBlob =>\n  Buffer.from(bytes).toString(\"hex\") as HexBlob;\n\nexport const hexToBytes = (hex: HexBlob): Uint8Array => Buffer.from(hex, \"hex\");\n\nexport const utf8ToBytes = (str: string): Uint8Array =>\n  Buffer.from(str, \"utf8\");\n\nexport const utf8ToHex = (str: string): HexBlob =>\n  Buffer.from(str, \"utf8\").toString(\"hex\") as HexBlob;\n\nexport const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};"
    },
    {
      "key": "mesh-core-cst:utils.encoding.ts.hexToBytes",
      "fullName": "mesh-core-cst:utils.encoding.ts.hexToBytes",
      "name": "hexToBytes",
      "signature": "export const hexToBytes = (hex: HexBlob): Uint8Array => Buffer.from(hex, \"hex\");",
      "documentation": "",
      "parameters": [
        {
          "name": "hex",
          "type": "HexBlob",
          "optional": false
        }
      ],
      "returnType": "Uint8Array",
      "isPublic": true,
      "line": 8,
      "raw": "export const hexToBytes = (hex: HexBlob): Uint8Array => Buffer.from(hex, \"hex\");\n\nexport const utf8ToBytes = (str: string): Uint8Array =>\n  Buffer.from(str, \"utf8\");\n\nexport const utf8ToHex = (str: string): HexBlob =>\n  Buffer.from(str, \"utf8\").toString(\"hex\") as HexBlob;\n\nexport const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};",
      "source": "mesh-core-cst",
      "implementation": "export const hexToBytes = (hex: HexBlob): Uint8Array => Buffer.from(hex, \"hex\");\n\nexport const utf8ToBytes = (str: string): Uint8Array =>\n  Buffer.from(str, \"utf8\");\n\nexport const utf8ToHex = (str: string): HexBlob =>\n  Buffer.from(str, \"utf8\").toString(\"hex\") as HexBlob;\n\nexport const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};"
    },
    {
      "key": "mesh-core-cst:utils.encoding.ts.utf8ToBytes",
      "fullName": "mesh-core-cst:utils.encoding.ts.utf8ToBytes",
      "name": "utf8ToBytes",
      "signature": "export const utf8ToBytes = (str: string): Uint8Array =>",
      "documentation": "",
      "parameters": [
        {
          "name": "str",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Uint8Array",
      "isPublic": true,
      "line": 10,
      "raw": "export const utf8ToBytes = (str: string): Uint8Array =>\n  Buffer.from(str, \"utf8\");\n\nexport const utf8ToHex = (str: string): HexBlob =>\n  Buffer.from(str, \"utf8\").toString(\"hex\") as HexBlob;\n\nexport const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};",
      "source": "mesh-core-cst",
      "implementation": "export const utf8ToBytes = (str: string): Uint8Array =>\n  Buffer.from(str, \"utf8\");\n\nexport const utf8ToHex = (str: string): HexBlob =>\n  Buffer.from(str, \"utf8\").toString(\"hex\") as HexBlob;\n\nexport const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};"
    },
    {
      "key": "mesh-core-cst:utils.encoding.ts.utf8ToHex",
      "fullName": "mesh-core-cst:utils.encoding.ts.utf8ToHex",
      "name": "utf8ToHex",
      "signature": "export const utf8ToHex = (str: string): HexBlob =>",
      "documentation": "",
      "parameters": [
        {
          "name": "str",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "HexBlob",
      "isPublic": true,
      "line": 13,
      "raw": "export const utf8ToHex = (str: string): HexBlob =>\n  Buffer.from(str, \"utf8\").toString(\"hex\") as HexBlob;\n\nexport const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};",
      "source": "mesh-core-cst",
      "implementation": "export const utf8ToHex = (str: string): HexBlob =>\n  Buffer.from(str, \"utf8\").toString(\"hex\") as HexBlob;\n\nexport const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};"
    },
    {
      "key": "mesh-core-cst:utils.encoding.ts.hexToBech32",
      "fullName": "mesh-core-cst:utils.encoding.ts.hexToBech32",
      "name": "hexToBech32",
      "signature": "export const hexToBech32 = (prefix: string, hex: string): string => {",
      "documentation": "",
      "parameters": [
        {
          "name": "prefix",
          "type": "string",
          "optional": false
        },
        {
          "name": "hex",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 16,
      "raw": "export const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};",
      "source": "mesh-core-cst",
      "implementation": "export const hexToBech32 = (prefix: string, hex: string): string => {\n  const buf = Buffer.from(hex, \"hex\");\n  const base32RawBytes = base32.encode(buf);\n  return bech32.encode(prefix, base32RawBytes);\n};"
    },
    {
      "key": "mesh-core-cst:utils.fee.ts.calculateFees",
      "fullName": "mesh-core-cst:utils.fee.ts.calculateFees",
      "name": "calculateFees",
      "signature": "export const calculateFees = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 3,
      "raw": "export const calculateFees = (\n  minFeeA: number,\n  minFeeB: number,\n  minFeeRefScriptCostPerByte: number,\n  priceMem: number,\n  priceStep: number,\n  tx: Transaction,\n  refScriptSize: number,\n): bigint => {\n  let fee = minFeeB + (tx.toCbor().length / 2) * minFeeA;\n  fee += calculateRefScriptFees(refScriptSize, minFeeRefScriptCostPerByte);\n  let scriptFee = BigInt(0);\n  let priceMemNumerator = priceMem;\n  let priceMemDenominator = 1;\n  while (priceMemNumerator % 1) {\n    priceMemNumerator *= 10;\n    priceMemDenominator *= 10;\n  }\n  let priceStepNumerator = priceStep;\n  let priceStepDenominator = 1;\n  while (priceStepNumerator % 1) {\n    priceStepNumerator *= 10;\n    priceStepDenominator *= 10;\n  }\n  if (tx.witnessSet().redeemers()) {\n    for (const redeemer of tx.witnessSet().redeemers()!.values()) {\n      scriptFee +=\n        (redeemer.exUnits().mem() * BigInt(priceMemNumerator.toString())) /\n        BigInt(priceMemDenominator.toString());\n      scriptFee +=\n        (redeemer.exUnits().steps() * BigInt(priceStepNumerator.toString())) /\n        BigInt(priceStepDenominator.toString());\n      if (priceMemNumerator % priceMemDenominator !== 0) {\n        scriptFee += BigInt(1);\n      }\n      if (priceStepNumerator % priceStepDenominator !== 0) {\n        scriptFee += BigInt(1);\n      }\n    }\n  }\n  return BigInt(fee) + scriptFee;\n};",
      "source": "mesh-core-cst",
      "implementation": "export const calculateFees = (\n  minFeeA: number,\n  minFeeB: number,\n  minFeeRefScriptCostPerByte: number,\n  priceMem: number,\n  priceStep: number,\n  tx: Transaction,\n  refScriptSize: number,\n): bigint => {\n  let fee = minFeeB + (tx.toCbor().length / 2) * minFeeA;\n  fee += calculateRefScriptFees(refScriptSize, minFeeRefScriptCostPerByte);\n  let scriptFee = BigInt(0);\n  let priceMemNumerator = priceMem;\n  let priceMemDenominator = 1;\n  while (priceMemNumerator % 1) {\n    priceMemNumerator *= 10;\n    priceMemDenominator *= 10;\n  }\n  let priceStepNumerator = priceStep;\n  let priceStepDenominator = 1;\n  while (priceStepNumerator % 1) {\n    priceStepNumerator *= 10;\n    priceStepDenominator *= 10;\n  }\n  if (tx.witnessSet().redeemers()) {\n    for (const redeemer of tx.witnessSet().redeemers()!.values()) {\n      scriptFee +=\n        (redeemer.exUnits().mem() * BigInt(priceMemNumerator.toString())) /\n        BigInt(priceMemDenominator.toString());\n      scriptFee +=\n        (redeemer.exUnits().steps() * BigInt(priceStepNumerator.toString())) /\n        BigInt(priceStepDenominator.toString());\n      if (priceMemNumerator % priceMemDenominator !== 0) {\n        scriptFee += BigInt(1);\n      }\n      if (priceStepNumerator % priceStepDenominator !== 0) {\n        scriptFee += BigInt(1);\n      }\n    }\n  }\n  return BigInt(fee) + scriptFee;\n};"
    },
    {
      "key": "mesh-core-cst:utils.fee.ts.calculateRefScriptFees",
      "fullName": "mesh-core-cst:utils.fee.ts.calculateRefScriptFees",
      "name": "calculateRefScriptFees",
      "signature": "const calculateRefScriptFees = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 46,
      "raw": "const calculateRefScriptFees = (\n  refScriptSize: number,\n  minFeeRefScriptCostPerByte: number,\n  tierMultiplier = 1.2,\n): number => {\n  let fee = 0;\n  const tierSize = 25600;\n  let currentRefScriptSize = refScriptSize;\n  let multiplier = 1;\n  while (currentRefScriptSize >= tierSize) {\n    fee += tierSize * multiplier * minFeeRefScriptCostPerByte;\n    currentRefScriptSize -= tierSize;\n    multiplier *= tierMultiplier;\n  }\n  if (currentRefScriptSize > 0) {\n    fee += currentRefScriptSize * multiplier * minFeeRefScriptCostPerByte;\n  }\n  fee = Math.ceil(fee);\n  return fee;\n};",
      "source": "mesh-core-cst",
      "implementation": "const calculateRefScriptFees = (\n  refScriptSize: number,\n  minFeeRefScriptCostPerByte: number,\n  tierMultiplier = 1.2,\n): number => {\n  let fee = 0;\n  const tierSize = 25600;\n  let currentRefScriptSize = refScriptSize;\n  let multiplier = 1;\n  while (currentRefScriptSize >= tierSize) {\n    fee += tierSize * multiplier * minFeeRefScriptCostPerByte;\n    currentRefScriptSize -= tierSize;\n    multiplier *= tierMultiplier;\n  }\n  if (currentRefScriptSize > 0) {\n    fee += currentRefScriptSize * multiplier * minFeeRefScriptCostPerByte;\n  }\n  fee = Math.ceil(fee);\n  return fee;\n};"
    },
    {
      "key": "mesh-core-cst:utils.metadata.ts.toCardanoMetadataMap",
      "fullName": "mesh-core-cst:utils.metadata.ts.toCardanoMetadataMap",
      "name": "toCardanoMetadataMap",
      "signature": "export const toCardanoMetadataMap = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 5,
      "raw": "export const toCardanoMetadataMap = (\n  metadata: TxMetadata,\n): Map<bigint, TransactionMetadatum> => {\n  let cardanoMetadataMap = new Map<bigint, TransactionMetadatum>();\n  metadata.forEach((val, key) => {\n    cardanoMetadataMap.set(key, toCardanoMetadatum(val));\n  });\n  return cardanoMetadataMap;\n};",
      "source": "mesh-core-cst",
      "implementation": "export const toCardanoMetadataMap = (\n  metadata: TxMetadata,\n): Map<bigint, TransactionMetadatum> => {\n  let cardanoMetadataMap = new Map<bigint, TransactionMetadatum>();\n  metadata.forEach((val, key) => {\n    cardanoMetadataMap.set(key, toCardanoMetadatum(val));\n  });\n  return cardanoMetadataMap;\n};"
    },
    {
      "key": "mesh-core-cst:utils.metadata.ts.toCardanoMetadatum",
      "fullName": "mesh-core-cst:utils.metadata.ts.toCardanoMetadatum",
      "name": "toCardanoMetadatum",
      "signature": "export const toCardanoMetadatum = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 15,
      "raw": "export const toCardanoMetadatum = (\n  metadatum: Metadatum,\n): TransactionMetadatum => {\n  if (typeof metadatum === \"number\") {\n    return TransactionMetadatum.newInteger(BigInt(metadatum));\n  } else if (typeof metadatum === \"string\") {\n    return TransactionMetadatum.newText(metadatum);\n  } else if (typeof metadatum === \"bigint\") {\n    return TransactionMetadatum.newInteger(metadatum);\n  } else if (metadatum instanceof Uint8Array) {\n    return TransactionMetadatum.newBytes(metadatum);\n  } else if (metadatum instanceof Map) {\n    const result: MetadatumMap = new MetadatumMap();\n    metadatum.forEach((value, key) => {\n      result.insert(toCardanoMetadatum(key), toCardanoMetadatum(value));\n    });\n    return TransactionMetadatum.newMap(result);\n  } else if (Array.isArray(metadatum)) {\n    const result: MetadatumList = new MetadatumList();\n    metadatum.forEach((val) => {\n      result.add(toCardanoMetadatum(val));\n    });\n    return TransactionMetadatum.newList(result);\n  } else {\n    throw new Error(\"metadatumToObj: Unsupported Metadatum type\");\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const toCardanoMetadatum = (\n  metadatum: Metadatum,\n): TransactionMetadatum => {\n  if (typeof metadatum === \"number\") {\n    return TransactionMetadatum.newInteger(BigInt(metadatum));\n  } else if (typeof metadatum === \"string\") {\n    return TransactionMetadatum.newText(metadatum);\n  } else if (typeof metadatum === \"bigint\") {\n    return TransactionMetadatum.newInteger(metadatum);\n  } else if (metadatum instanceof Uint8Array) {\n    return TransactionMetadatum.newBytes(metadatum);\n  } else if (metadatum instanceof Map) {\n    const result: MetadatumMap = new MetadatumMap();\n    metadatum.forEach((value, key) => {\n      result.insert(toCardanoMetadatum(key), toCardanoMetadatum(value));\n    });\n    return TransactionMetadatum.newMap(result);\n  } else if (Array.isArray(metadatum)) {\n    const result: MetadatumList = new MetadatumList();\n    metadatum.forEach((val) => {\n      result.add(toCardanoMetadatum(val));\n    });\n    return TransactionMetadatum.newList(result);\n  } else {\n    throw new Error(\"metadatumToObj: Unsupported Metadatum type\");\n  }\n};"
    },
    {
      "key": "mesh-core-cst:utils.script-data-hash.ts.hashScriptData",
      "fullName": "mesh-core-cst:utils.script-data-hash.ts.hashScriptData",
      "name": "hashScriptData",
      "signature": "export const hashScriptData = (",
      "documentation": "/**\n * Computes the hash of script data in a transaction, including redeemers, datums, and cost models.\n *\n * This function takes arrays of redeemers and datums, along with cost models, and encodes\n * them in a CBOR (Concise Binary Object Representation) format. The encoded data is then\n * hashed using the Blake2b hashing algorithm to produce a 32-byte hash. This hash is\n * representative of the script data in a transaction on the Cardano blockchain.\n *\n * @param costModels The cost models for script execution.\n * @param redemeers The redeemers in the transaction. If not present or empty, the function may return undefined.\n * @param datums The datums in the transaction.\n * @returns The hashed script data, or undefined if no redeemers are provided.\n */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 24,
      "raw": "/**\n * Computes the hash of script data in a transaction, including redeemers, datums, and cost models.\n *\n * This function takes arrays of redeemers and datums, along with cost models, and encodes\n * them in a CBOR (Concise Binary Object Representation) format. The encoded data is then\n * hashed using the Blake2b hashing algorithm to produce a 32-byte hash. This hash is\n * representative of the script data in a transaction on the Cardano blockchain.\n *\n * @param costModels The cost models for script execution.\n * @param redemeers The redeemers in the transaction. If not present or empty, the function may return undefined.\n * @param datums The datums in the transaction.\n * @returns The hashed script data, or undefined if no redeemers are provided.\n */\nexport const hashScriptData = (\n  costModels: Serialization.Costmdls,\n  redemeers?: Serialization.Redeemers,\n  datums?: Serialization.CborSet<Cardano.PlutusData, PlutusData>,\n): Crypto.Hash32ByteBase16 | undefined => {\n  const writer = new Serialization.CborWriter();\n  if (datums && datums.size() > 0 && (!redemeers || redemeers.size() === 0)) {\n    /*\n     ; Note that in the case that a transaction includes datums but does not\n     ; include any redeemers, the script data format becomes (in hex):\n     ; [ A0 | datums | A0 ]\n     ; corresponding to a CBOR empty list and an empty map).\n    */\n    writer.writeEncodedValue(CBOR_EMPTY_MAP);\n    writer.writeEncodedValue(Buffer.from(datums.toCbor(), \"hex\"));\n    writer.writeEncodedValue(CBOR_EMPTY_MAP);\n  } else {\n    if (!redemeers || redemeers.size() === 0) return undefined;\n    /*\n     ; script data format:\n     ; [ redeemers | datums | language views ]\n     ; The redeemers are exactly the data present in the transaction witness set.\n     ; Similarly for the datums, if present. If no datums are provided, the middle\n     ; field is an empty string.\n    */\n    writer.writeEncodedValue(Buffer.from(redemeers.toCbor(), \"hex\"));\n    if (datums && datums.size() > 0) {\n      writer.writeEncodedValue(Buffer.from(datums.toCbor(), \"hex\"));\n    }\n    writer.writeEncodedValue(\n      Buffer.from(costModels.languageViewsEncoding(), \"hex\"),\n    );\n  }\n\n  return Hash32ByteBase16.fromHexBlob(\n    HexBlob.fromBytes(\n      Crypto.blake2b(Crypto.blake2b.BYTES).update(writer.encode()).digest(),\n    ),\n  );\n};",
      "source": "mesh-core-cst",
      "implementation": "export const hashScriptData = (\n  costModels: Serialization.Costmdls,\n  redemeers?: Serialization.Redeemers,\n  datums?: Serialization.CborSet<Cardano.PlutusData, PlutusData>,\n): Crypto.Hash32ByteBase16 | undefined => {\n  const writer = new Serialization.CborWriter();\n  if (datums && datums.size() > 0 && (!redemeers || redemeers.size() === 0)) {\n    /*\n     ; Note that in the case that a transaction includes datums but does not\n     ; include any redeemers, the script data format becomes (in hex):\n     ; [ A0 | datums | A0 ]\n     ; corresponding to a CBOR empty list and an empty map).\n    */\n    writer.writeEncodedValue(CBOR_EMPTY_MAP);\n    writer.writeEncodedValue(Buffer.from(datums.toCbor(), \"hex\"));\n    writer.writeEncodedValue(CBOR_EMPTY_MAP);\n  } else {\n    if (!redemeers || redemeers.size() === 0) return undefined;\n    /*\n     ; script data format:\n     ; [ redeemers | datums | language views ]\n     ; The redeemers are exactly the data present in the transaction witness set.\n     ; Similarly for the datums, if present. If no datums are provided, the middle\n     ; field is an empty string.\n    */\n    writer.writeEncodedValue(Buffer.from(redemeers.toCbor(), \"hex\"));\n    if (datums && datums.size() > 0) {\n      writer.writeEncodedValue(Buffer.from(datums.toCbor(), \"hex\"));\n    }\n    writer.writeEncodedValue(\n      Buffer.from(costModels.languageViewsEncoding(), \"hex\"),\n    );\n  }\n\n  return Hash32ByteBase16.fromHexBlob(\n    HexBlob.fromBytes(\n      Crypto.blake2b(Crypto.blake2b.BYTES).update(writer.encode()).digest(),\n    ),\n  );\n};"
    },
    {
      "key": "mesh-core-cst:utils.script-data-hash.ts.if",
      "fullName": "mesh-core-cst:utils.script-data-hash.ts.if",
      "name": "if",
      "signature": "if (!redemeers || redemeers.size() === 0) return undefined;",
      "documentation": "",
      "parameters": [
        {
          "name": "!redemeers || redemeers.size(",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 41,
      "raw": "    if (!redemeers || redemeers.size() === 0) return undefined;\n    /*\n     ; script data format:\n     ; [ redeemers | datums | language views ]\n     ; The redeemers are exactly the data present in the transaction witness set.\n     ; Similarly for the datums, if present. If no datums are provided, the middle\n     ; field is an empty string.\n    */\n    writer.writeEncodedValue(Buffer.from(redemeers.toCbor(), \"hex\"));\n    if (datums && datums.size() > 0) {\n      writer.writeEncodedValue(Buffer.from(datums.toCbor(), \"hex\"));\n    }",
      "source": "mesh-core-cst",
      "implementation": "    if (!redemeers || redemeers.size() === 0) return undefined;\n    /*\n     ; script data format:\n     ; [ redeemers | datums | language views ]\n     ; The redeemers are exactly the data present in the transaction witness set.\n     ; Similarly for the datums, if present. If no datums are provided, the middle\n     ; field is an empty string.\n    */\n    writer.writeEncodedValue(Buffer.from(redemeers.toCbor(), \"hex\"));\n    if (datums && datums.size() > 0) {\n      writer.writeEncodedValue(Buffer.from(datums.toCbor(), \"hex\"));\n    }"
    },
    {
      "key": "mesh-core-cst:utils.value.ts.mergeValue",
      "fullName": "mesh-core-cst:utils.value.ts.mergeValue",
      "name": "mergeValue",
      "signature": "export function mergeValue(a: Value, b: Value): Value {",
      "documentation": "",
      "parameters": [
        {
          "name": "a",
          "type": "Value",
          "optional": false
        },
        {
          "name": "b",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "Value",
      "isPublic": true,
      "line": 3,
      "raw": "export function mergeValue(a: Value, b: Value): Value {\n  const ma = a.multiasset() ?? new Map();\n  b.multiasset()?.forEach((v, k) => {\n    const newVal = (ma.get(k) ?? 0n) + v;\n    if (newVal == 0n) {\n      ma.delete(k);\n    } else {\n      ma.set(k, newVal);\n    }\n  });\n  return new Value(\n    BigInt(a.coin()) + BigInt(b.coin()),\n    ma.size > 0 ? ma : undefined,\n  );\n}",
      "source": "mesh-core-cst",
      "implementation": "export function mergeValue(a: Value, b: Value): Value {\n  const ma = a.multiasset() ?? new Map();\n  b.multiasset()?.forEach((v, k) => {\n    const newVal = (ma.get(k) ?? 0n) + v;\n    if (newVal == 0n) {\n      ma.delete(k);\n    } else {\n      ma.set(k, newVal);\n    }\n  });\n  return new Value(\n    BigInt(a.coin()) + BigInt(b.coin()),\n    ma.size > 0 ? ma : undefined,\n  );\n}"
    },
    {
      "key": "mesh-core-cst:utils.value.ts.newVal",
      "fullName": "mesh-core-cst:utils.value.ts.newVal",
      "name": "newVal",
      "signature": "const newVal = (ma.get(k) ?? 0n) + v;",
      "documentation": "",
      "parameters": [
        {
          "name": "ma.get(k",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "any",
      "isPublic": true,
      "line": 6,
      "raw": "    const newVal = (ma.get(k) ?? 0n) + v;\n    if (newVal == 0n) {\n      ma.delete(k);\n    } else {\n      ma.set(k, newVal);\n    }",
      "source": "mesh-core-cst",
      "implementation": "    const newVal = (ma.get(k) ?? 0n) + v;\n    if (newVal == 0n) {\n      ma.delete(k);\n    } else {\n      ma.set(k, newVal);\n    }"
    },
    {
      "key": "mesh-core-cst:utils.value.ts.negateValue",
      "fullName": "mesh-core-cst:utils.value.ts.negateValue",
      "name": "negateValue",
      "signature": "export function negateValue(v: Value): Value {",
      "documentation": "",
      "parameters": [
        {
          "name": "v",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "Value",
      "isPublic": true,
      "line": 19,
      "raw": "export function negateValue(v: Value): Value {\n  const entries = v.multiasset()?.entries();\n  const tokenMap: TokenMap = new Map();\n  if (entries) {\n    for (const entry of entries) {\n      tokenMap.set(entry[0], -entry[1]);\n    }\n  }\n  return new Value(-v.coin(), tokenMap);\n}",
      "source": "mesh-core-cst",
      "implementation": "export function negateValue(v: Value): Value {\n  const entries = v.multiasset()?.entries();\n  const tokenMap: TokenMap = new Map();\n  if (entries) {\n    for (const entry of entries) {\n      tokenMap.set(entry[0], -entry[1]);\n    }\n  }\n  return new Value(-v.coin(), tokenMap);\n}"
    },
    {
      "key": "mesh-core-cst:utils.value.ts.subValue",
      "fullName": "mesh-core-cst:utils.value.ts.subValue",
      "name": "subValue",
      "signature": "export function subValue(a: Value, b: Value): Value {",
      "documentation": "",
      "parameters": [
        {
          "name": "a",
          "type": "Value",
          "optional": false
        },
        {
          "name": "b",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "Value",
      "isPublic": true,
      "line": 30,
      "raw": "export function subValue(a: Value, b: Value): Value {\n  return mergeValue(a, negateValue(b));\n}",
      "source": "mesh-core-cst",
      "implementation": "export function subValue(a: Value, b: Value): Value {\n  return mergeValue(a, negateValue(b));\n}"
    },
    {
      "key": "mesh-core-cst:utils.value.ts.negatives",
      "fullName": "mesh-core-cst:utils.value.ts.negatives",
      "name": "negatives",
      "signature": "export function negatives(v: Value): Value {",
      "documentation": "",
      "parameters": [
        {
          "name": "v",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "Value",
      "isPublic": true,
      "line": 34,
      "raw": "export function negatives(v: Value): Value {\n  const entries = v.multiasset()?.entries();\n  const coin = v.coin() < 0n ? v.coin() : 0n;\n  const tokenMap: TokenMap = new Map();\n  if (entries) {\n    for (const entry of entries) {\n      if (entry[1] < 0n) {\n        tokenMap.set(entry[0], entry[1]);\n      }\n    }\n  }\n  return new Value(coin, tokenMap);\n}",
      "source": "mesh-core-cst",
      "implementation": "export function negatives(v: Value): Value {\n  const entries = v.multiasset()?.entries();\n  const coin = v.coin() < 0n ? v.coin() : 0n;\n  const tokenMap: TokenMap = new Map();\n  if (entries) {\n    for (const entry of entries) {\n      if (entry[1] < 0n) {\n        tokenMap.set(entry[0], entry[1]);\n      }\n    }\n  }\n  return new Value(coin, tokenMap);\n}"
    },
    {
      "key": "mesh-core-cst:utils.value.ts.assetTypes",
      "fullName": "mesh-core-cst:utils.value.ts.assetTypes",
      "name": "assetTypes",
      "signature": "export function assetTypes(v: Value): number {",
      "documentation": "",
      "parameters": [
        {
          "name": "v",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "number",
      "isPublic": true,
      "line": 48,
      "raw": "export function assetTypes(v: Value): number {\n  let count = v.coin() == 0n ? 0 : 1;\n  const entries = v.multiasset();\n  if (entries) {\n    entries.forEach(() => {\n      count += 1;\n    });\n  }\n  return count;\n}",
      "source": "mesh-core-cst",
      "implementation": "export function assetTypes(v: Value): number {\n  let count = v.coin() == 0n ? 0 : 1;\n  const entries = v.multiasset();\n  if (entries) {\n    entries.forEach(() => {\n      count += 1;\n    });\n  }\n  return count;\n}"
    },
    {
      "key": "mesh-core-cst:utils.value.ts.empty",
      "fullName": "mesh-core-cst:utils.value.ts.empty",
      "name": "empty",
      "signature": "export function empty(v: Value): boolean {",
      "documentation": "",
      "parameters": [
        {
          "name": "v",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "isPublic": true,
      "line": 59,
      "raw": "export function empty(v: Value): boolean {\n  return assetTypes(v) == 0;\n}",
      "source": "mesh-core-cst",
      "implementation": "export function empty(v: Value): boolean {\n  return assetTypes(v) == 0;\n}"
    },
    {
      "key": "mesh-core-cst:utils.vote.ts.toCardanoVoter",
      "fullName": "mesh-core-cst:utils.vote.ts.toCardanoVoter",
      "name": "toCardanoVoter",
      "signature": "export const toCardanoVoter = (voter: Voter): Serialization.Voter => {",
      "documentation": "",
      "parameters": [
        {
          "name": "voter",
          "type": "Voter",
          "optional": false
        }
      ],
      "returnType": "Serialization.Voter",
      "isPublic": true,
      "line": 18,
      "raw": "export const toCardanoVoter = (voter: Voter): Serialization.Voter => {\n  switch (voter.type) {\n    case \"ConstitutionalCommittee\": {\n      switch (voter.hotCred.type) {\n        case \"KeyHash\": {\n          return Serialization.Voter.newConstitutionalCommitteeHotKey({\n            type: 0,\n            hash: Hash28ByteBase16(voter.hotCred.keyHash),\n          });\n        }\n        case \"ScriptHash\": {\n          return Serialization.Voter.newConstitutionalCommitteeHotKey({\n            type: 1,\n            hash: Hash28ByteBase16(voter.hotCred.scriptHash),\n          });\n        }\n      }\n    }\n    case \"DRep\": {\n      const cardanoDrep = toDRep(voter.drepId);\n      if (cardanoDrep.toKeyHash() !== undefined) {\n        return Serialization.Voter.newDrep({\n          type: 0,\n          hash: Hash28ByteBase16(cardanoDrep.toKeyHash()!),\n        });\n      } else if (cardanoDrep.toScriptHash() !== undefined) {\n        return Serialization.Voter.newDrep({\n          type: 1,\n          hash: Hash28ByteBase16(cardanoDrep.toScriptHash()!),\n        });\n      } else {\n        throw new Error(\"Invalid DRep provided\");\n      }\n    }\n    case \"StakingPool\": {\n      return Serialization.Voter.newStakingPool(\n        Ed25519KeyHashHex(voter.keyHash),\n      );\n    }\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "export const toCardanoVoter = (voter: Voter): Serialization.Voter => {\n  switch (voter.type) {\n    case \"ConstitutionalCommittee\": {\n      switch (voter.hotCred.type) {\n        case \"KeyHash\": {\n          return Serialization.Voter.newConstitutionalCommitteeHotKey({\n            type: 0,\n            hash: Hash28ByteBase16(voter.hotCred.keyHash),\n          });\n        }\n        case \"ScriptHash\": {\n          return Serialization.Voter.newConstitutionalCommitteeHotKey({\n            type: 1,\n            hash: Hash28ByteBase16(voter.hotCred.scriptHash),\n          });\n        }\n      }\n    }\n    case \"DRep\": {\n      const cardanoDrep = toDRep(voter.drepId);\n      if (cardanoDrep.toKeyHash() !== undefined) {\n        return Serialization.Voter.newDrep({\n          type: 0,\n          hash: Hash28ByteBase16(cardanoDrep.toKeyHash()!),\n        });\n      } else if (cardanoDrep.toScriptHash() !== undefined) {\n        return Serialization.Voter.newDrep({\n          type: 1,\n          hash: Hash28ByteBase16(cardanoDrep.toScriptHash()!),\n        });\n      } else {\n        throw new Error(\"Invalid DRep provided\");\n      }\n    }\n    case \"StakingPool\": {\n      return Serialization.Voter.newStakingPool(\n        Ed25519KeyHashHex(voter.keyHash),\n      );\n    }\n  }\n};"
    },
    {
      "key": "mesh-core-cst:utils.vote.ts.toCardanoVotingProcedure",
      "fullName": "mesh-core-cst:utils.vote.ts.toCardanoVotingProcedure",
      "name": "toCardanoVotingProcedure",
      "signature": "export const toCardanoVotingProcedure = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 60,
      "raw": "export const toCardanoVotingProcedure = (\n  votingProcedure: VotingProcedure,\n): Serialization.VotingProcedure => {\n  return new Serialization.VotingProcedure(\n    toCardanoVoteKind(votingProcedure.voteKind),\n    votingProcedure.anchor\n      ? toCardanoAnchor(votingProcedure.anchor)\n      : undefined,\n  );\n};",
      "source": "mesh-core-cst",
      "implementation": "export const toCardanoVotingProcedure = (\n  votingProcedure: VotingProcedure,\n): Serialization.VotingProcedure => {\n  return new Serialization.VotingProcedure(\n    toCardanoVoteKind(votingProcedure.voteKind),\n    votingProcedure.anchor\n      ? toCardanoAnchor(votingProcedure.anchor)\n      : undefined,\n  );\n};"
    },
    {
      "key": "mesh-core-cst:utils.vote.ts.toCardanoAnchor",
      "fullName": "mesh-core-cst:utils.vote.ts.toCardanoAnchor",
      "name": "toCardanoAnchor",
      "signature": "const toCardanoAnchor = (anchor: Anchor): Serialization.Anchor => {",
      "documentation": "",
      "parameters": [
        {
          "name": "anchor",
          "type": "Anchor",
          "optional": false
        }
      ],
      "returnType": "Serialization.Anchor",
      "isPublic": true,
      "line": 71,
      "raw": "const toCardanoAnchor = (anchor: Anchor): Serialization.Anchor => {\n  return new Serialization.Anchor(\n    anchor.anchorUrl,\n    Hash32ByteBase16(anchor.anchorDataHash),\n  );\n};",
      "source": "mesh-core-cst",
      "implementation": "const toCardanoAnchor = (anchor: Anchor): Serialization.Anchor => {\n  return new Serialization.Anchor(\n    anchor.anchorUrl,\n    Hash32ByteBase16(anchor.anchorDataHash),\n  );\n};"
    },
    {
      "key": "mesh-core-cst:utils.vote.ts.toCardanoVoteKind",
      "fullName": "mesh-core-cst:utils.vote.ts.toCardanoVoteKind",
      "name": "toCardanoVoteKind",
      "signature": "const toCardanoVoteKind = (voteType: VoteKind): Cardano.Vote => {",
      "documentation": "",
      "parameters": [
        {
          "name": "voteType",
          "type": "VoteKind",
          "optional": false
        }
      ],
      "returnType": "Cardano.Vote",
      "isPublic": true,
      "line": 78,
      "raw": "const toCardanoVoteKind = (voteType: VoteKind): Cardano.Vote => {\n  switch (voteType) {\n    case \"Yes\": {\n      return 1;\n    }\n    case \"No\": {\n      return 0;\n    }\n    case \"Abstain\": {\n      return 2;\n    }\n  }\n};",
      "source": "mesh-core-cst",
      "implementation": "const toCardanoVoteKind = (voteType: VoteKind): Cardano.Vote => {\n  switch (voteType) {\n    case \"Yes\": {\n      return 1;\n    }\n    case \"No\": {\n      return 0;\n    }\n    case \"Abstain\": {\n      return 2;\n    }\n  }\n};"
    },
    {
      "key": "mesh-core-cst:utils.vote.ts.toCardanoGovernanceActionId",
      "fullName": "mesh-core-cst:utils.vote.ts.toCardanoGovernanceActionId",
      "name": "toCardanoGovernanceActionId",
      "signature": "export const toCardanoGovernanceActionId = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 92,
      "raw": "export const toCardanoGovernanceActionId = (\n  govActionId: RefTxIn,\n): Serialization.GovernanceActionId => {\n  return new Serialization.GovernanceActionId(\n    Cardano.TransactionId(govActionId.txHash),\n    BigInt(govActionId.txIndex),\n  );\n};",
      "source": "mesh-core-cst",
      "implementation": "export const toCardanoGovernanceActionId = (\n  govActionId: RefTxIn,\n): Serialization.GovernanceActionId => {\n  return new Serialization.GovernanceActionId(\n    Cardano.TransactionId(govActionId.txHash),\n    BigInt(govActionId.txIndex),\n  );\n};"
    },
    {
      "key": "mesh-core-cst:utils.witness-set.ts.addVKeyWitnessSetToTransaction",
      "fullName": "mesh-core-cst:utils.witness-set.ts.addVKeyWitnessSetToTransaction",
      "name": "addVKeyWitnessSetToTransaction",
      "signature": "export const addVKeyWitnessSetToTransaction = (",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 10,
      "raw": "export const addVKeyWitnessSetToTransaction = (\n  txHex: string,\n  vkeyWitnessSet: string,\n): string => {\n  const tx = Transaction.fromCbor(TxCBOR(txHex));\n  const currentWitnessSet = tx.witnessSet();\n  const newVkeyWitnessSet = TransactionWitnessSet.fromCbor(\n    HexBlob(vkeyWitnessSet),\n  );\n\n  const currentVkeyWitnesses = currentWitnessSet.vkeys();\n  const newVkeyWitnesses = newVkeyWitnessSet.vkeys();\n  const allVkeyWitnesses = [\n    ...(currentVkeyWitnesses?.values() ?? []),\n    ...(newVkeyWitnesses?.values() ?? []),\n  ];\n\n  currentWitnessSet.setVkeys(\n    CborSet.fromCore(\n      allVkeyWitnesses.map((vkw) => vkw.toCore()),\n      VkeyWitness.fromCore,\n    ),\n  );\n  tx.setWitnessSet(currentWitnessSet);\n  return tx.toCbor();\n};",
      "source": "mesh-core-cst",
      "implementation": "export const addVKeyWitnessSetToTransaction = (\n  txHex: string,\n  vkeyWitnessSet: string,\n): string => {\n  const tx = Transaction.fromCbor(TxCBOR(txHex));\n  const currentWitnessSet = tx.witnessSet();\n  const newVkeyWitnessSet = TransactionWitnessSet.fromCbor(\n    HexBlob(vkeyWitnessSet),\n  );\n\n  const currentVkeyWitnesses = currentWitnessSet.vkeys();\n  const newVkeyWitnesses = newVkeyWitnessSet.vkeys();\n  const allVkeyWitnesses = [\n    ...(currentVkeyWitnesses?.values() ?? []),\n    ...(newVkeyWitnesses?.values() ?? []),\n  ];\n\n  currentWitnessSet.setVkeys(\n    CborSet.fromCore(\n      allVkeyWitnesses.map((vkw) => vkw.toCore()),\n      VkeyWitness.fromCore,\n    ),\n  );\n  tx.setWitnessSet(currentWitnessSet);\n  return tx.toCbor();\n};"
    },
    {
      "key": "bitcoin:interfaces.provider.ts.fetchAddress",
      "fullName": "bitcoin:interfaces.provider.ts.fetchAddress",
      "name": "fetchAddress",
      "signature": "fetchAddress(address: string): Promise<AddressInfo>;",
      "documentation": "",
      "parameters": [
        {
          "name": "address",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Promise<AddressInfo>;",
      "isPublic": true,
      "line": 8,
      "raw": "  fetchAddress(address: string): Promise<AddressInfo>;",
      "source": "bitcoin",
      "implementation": "  fetchAddress(address: string): Promise<AddressInfo>;"
    },
    {
      "key": "bitcoin:interfaces.provider.ts.fetchAddressUTxOs",
      "fullName": "bitcoin:interfaces.provider.ts.fetchAddressUTxOs",
      "name": "fetchAddressUTxOs",
      "signature": "fetchAddressUTxOs(address: string): Promise<UTxO[]>;",
      "documentation": "",
      "parameters": [
        {
          "name": "address",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Promise<UTxO[]>;",
      "isPublic": true,
      "line": 13,
      "raw": "  fetchAddressUTxOs(address: string): Promise<UTxO[]>;",
      "source": "bitcoin",
      "implementation": "  fetchAddressUTxOs(address: string): Promise<UTxO[]>;"
    },
    {
      "key": "bitcoin:interfaces.provider.ts.fetchScript",
      "fullName": "bitcoin:interfaces.provider.ts.fetchScript",
      "name": "fetchScript",
      "signature": "fetchScript(hash: string): Promise<ScriptInfo>;",
      "documentation": "",
      "parameters": [
        {
          "name": "hash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Promise<ScriptInfo>;",
      "isPublic": true,
      "line": 14,
      "raw": "  fetchScript(hash: string): Promise<ScriptInfo>;",
      "source": "bitcoin",
      "implementation": "  fetchScript(hash: string): Promise<ScriptInfo>;"
    },
    {
      "key": "bitcoin:interfaces.provider.ts.fetchScriptUTxOs",
      "fullName": "bitcoin:interfaces.provider.ts.fetchScriptUTxOs",
      "name": "fetchScriptUTxOs",
      "signature": "fetchScriptUTxOs(hash: string): Promise<UTxO[]>;",
      "documentation": "",
      "parameters": [
        {
          "name": "hash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Promise<UTxO[]>;",
      "isPublic": true,
      "line": 19,
      "raw": "  fetchScriptUTxOs(hash: string): Promise<UTxO[]>;",
      "source": "bitcoin",
      "implementation": "  fetchScriptUTxOs(hash: string): Promise<UTxO[]>;"
    },
    {
      "key": "bitcoin:interfaces.provider.ts.fetchTransactionStatus",
      "fullName": "bitcoin:interfaces.provider.ts.fetchTransactionStatus",
      "name": "fetchTransactionStatus",
      "signature": "fetchTransactionStatus(txid: string): Promise<TransactionsStatus>;",
      "documentation": "",
      "parameters": [
        {
          "name": "txid",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Promise<TransactionsStatus>;",
      "isPublic": true,
      "line": 20,
      "raw": "  fetchTransactionStatus(txid: string): Promise<TransactionsStatus>;",
      "source": "bitcoin",
      "implementation": "  fetchTransactionStatus(txid: string): Promise<TransactionsStatus>;"
    },
    {
      "key": "bitcoin:interfaces.provider.ts.submitTx",
      "fullName": "bitcoin:interfaces.provider.ts.submitTx",
      "name": "submitTx",
      "signature": "submitTx(tx: string): Promise<string>;",
      "documentation": "",
      "parameters": [
        {
          "name": "tx",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Promise<string>;",
      "isPublic": true,
      "line": 21,
      "raw": "  submitTx(tx: string): Promise<string>;",
      "source": "bitcoin",
      "implementation": "  submitTx(tx: string): Promise<string>;"
    },
    {
      "key": "bitcoin:interfaces.wallet.ts.getChangeAddress",
      "fullName": "bitcoin:interfaces.wallet.ts.getChangeAddress",
      "name": "getChangeAddress",
      "signature": "getChangeAddress(): Promise<string>;",
      "documentation": "",
      "parameters": [],
      "returnType": "Promise<string>;",
      "isPublic": true,
      "line": 2,
      "raw": "  getChangeAddress(): Promise<string>;",
      "source": "bitcoin",
      "implementation": "  getChangeAddress(): Promise<string>;"
    },
    {
      "key": "bitcoin:interfaces.wallet.ts.getNetworkId",
      "fullName": "bitcoin:interfaces.wallet.ts.getNetworkId",
      "name": "getNetworkId",
      "signature": "getNetworkId(): Promise<0 | 1>;",
      "documentation": "",
      "parameters": [],
      "returnType": "Promise<0 | 1>;",
      "isPublic": true,
      "line": 3,
      "raw": "  getNetworkId(): Promise<0 | 1>;",
      "source": "bitcoin",
      "implementation": "  getNetworkId(): Promise<0 | 1>;"
    },
    {
      "key": "bitcoin:interfaces.wallet.ts.signTx",
      "fullName": "bitcoin:interfaces.wallet.ts.signTx",
      "name": "signTx",
      "signature": "signTx(signedTx: string): Promise<string>;",
      "documentation": "",
      "parameters": [
        {
          "name": "signedTx",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Promise<string>;",
      "isPublic": true,
      "line": 4,
      "raw": "  signTx(signedTx: string): Promise<string>;",
      "source": "bitcoin",
      "implementation": "  signTx(signedTx: string): Promise<string>;"
    },
    {
      "key": "bitcoin:interfaces.wallet.ts.submitTx",
      "fullName": "bitcoin:interfaces.wallet.ts.submitTx",
      "name": "submitTx",
      "signature": "submitTx(tx: string): Promise<string>;",
      "documentation": "",
      "parameters": [
        {
          "name": "tx",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Promise<string>;",
      "isPublic": true,
      "line": 5,
      "raw": "  submitTx(tx: string): Promise<string>;",
      "source": "bitcoin",
      "implementation": "  submitTx(tx: string): Promise<string>;"
    },
    {
      "key": "bitcoin:providers.common.ts.parseHttpError",
      "fullName": "bitcoin:providers.common.ts.parseHttpError",
      "name": "parseHttpError",
      "signature": "export const parseHttpError = (error: unknown): string => {",
      "documentation": "",
      "parameters": [
        {
          "name": "error",
          "type": "unknown",
          "optional": false
        }
      ],
      "returnType": "string",
      "isPublic": true,
      "line": 3,
      "raw": "export const parseHttpError = (error: unknown): string => {\n  if (!axios.isAxiosError(error)) {\n    return JSON.stringify(error);\n  }\n\n  if (error.response) {\n    return JSON.stringify({\n      data: error.response.data,\n      headers: error.response.headers,\n      status: error.response.status,\n    });\n  }\n\n  if (error.request && !(error.request instanceof XMLHttpRequest)) {\n    return JSON.stringify(error.request);\n  }\n\n  return JSON.stringify({ code: error.code, message: error.message });\n};",
      "source": "bitcoin",
      "implementation": "export const parseHttpError = (error: unknown): string => {\n  if (!axios.isAxiosError(error)) {\n    return JSON.stringify(error);\n  }\n\n  if (error.response) {\n    return JSON.stringify({\n      data: error.response.data,\n      headers: error.response.headers,\n      status: error.response.status,\n    });\n  }\n\n  if (error.request && !(error.request instanceof XMLHttpRequest)) {\n    return JSON.stringify(error.request);\n  }\n\n  return JSON.stringify({ code: error.code, message: error.message });\n};"
    },
    {
      "key": "bitcoin:utils.address.ts.resolveAddress",
      "fullName": "bitcoin:utils.address.ts.resolveAddress",
      "name": "resolveAddress",
      "signature": "export function resolveAddress(",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 4,
      "raw": "export function resolveAddress(\n  publicKey: string | Buffer,\n  network: \"mainnet\" | \"testnet\" | bitcoin.networks.Network\n): Address {\n  const p2wpkh = bitcoin.payments.p2wpkh({\n    pubkey:\n      typeof publicKey === \"string\" ? Buffer.from(publicKey, \"hex\") : publicKey,\n    network:\n      network === \"mainnet\"\n        ? bitcoin.networks.bitcoin\n        : network === \"testnet\"\n          ? bitcoin.networks.testnet\n          : network,\n  });\n\n  if (!p2wpkh?.address) {\n    throw new Error(\"Address is not initialized.\");\n  }\n\n  const pubKeyHex = Buffer.isBuffer(publicKey)\n    ? publicKey.toString(\"hex\")\n    : publicKey;\n\n  return {\n    address: p2wpkh.address,\n    publicKey: pubKeyHex,\n    purpose: \"payment\",\n    addressType: \"p2wpkh\",\n  };\n}",
      "source": "bitcoin",
      "implementation": "export function resolveAddress(\n  publicKey: string | Buffer,\n  network: \"mainnet\" | \"testnet\" | bitcoin.networks.Network\n): Address {\n  const p2wpkh = bitcoin.payments.p2wpkh({\n    pubkey:\n      typeof publicKey === \"string\" ? Buffer.from(publicKey, \"hex\") : publicKey,\n    network:\n      network === \"mainnet\"\n        ? bitcoin.networks.bitcoin\n        : network === \"testnet\"\n          ? bitcoin.networks.testnet\n          : network,\n  });\n\n  if (!p2wpkh?.address) {\n    throw new Error(\"Address is not initialized.\");\n  }\n\n  const pubKeyHex = Buffer.isBuffer(publicKey)\n    ? publicKey.toString(\"hex\")\n    : publicKey;\n\n  return {\n    address: p2wpkh.address,\n    publicKey: pubKeyHex,\n    purpose: \"payment\",\n    addressType: \"p2wpkh\",\n  };\n}"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.getAddress",
      "fullName": "bitcoin:wallets.embedded.index.ts.getAddress",
      "name": "getAddress",
      "signature": "getAddress(): Address {",
      "documentation": "  /**\n   * Returns the wallet's SegWit (P2WPKH) address and associated public key.\n   *\n   * @returns {Address} The wallet address object including address, public key, and metadata.\n   * @throws {Error} If internal address or public key is not properly initialized.\n   */",
      "parameters": [],
      "returnType": "Address",
      "isPublic": true,
      "line": 74,
      "raw": "  /**\n   * Returns the wallet's SegWit (P2WPKH) address and associated public key.\n   *\n   * @returns {Address} The wallet address object including address, public key, and metadata.\n   * @throws {Error} If internal address or public key is not properly initialized.\n   */\n  getAddress(): Address {\n    if (this._isReadOnly && this._address) {\n      return {\n        address: this._address,\n        purpose: \"payment\",\n        addressType: \"p2wpkh\",\n      };\n    }\n\n    if (!this._wallet) {\n      throw new Error(\"Wallet not initialized properly.\");\n    }\n\n    return resolveAddress(this._wallet.publicKey, this._network);\n\n    // const p2wpkh = bitcoin.payments.p2wpkh({\n    //   pubkey: this._wallet.publicKey,\n    //   network: this._network,\n    // });\n\n    // if (!p2wpkh?.address) {\n    //   throw new Error(\"Address is not initialized.\");\n    // }\n\n    // return {\n    //   address: p2wpkh.address,\n    //   publicKey: this._wallet.publicKey.toString(\"hex\"),\n    //   purpose: \"payment\",\n    //   addressType: \"p2wpkh\",\n    // };\n  }",
      "source": "bitcoin",
      "implementation": "  getAddress(): Address {\n    if (this._isReadOnly && this._address) {\n      return {\n        address: this._address,\n        purpose: \"payment\",\n        addressType: \"p2wpkh\",\n      };\n    }\n\n    if (!this._wallet) {\n      throw new Error(\"Wallet not initialized properly.\");\n    }\n\n    return resolveAddress(this._wallet.publicKey, this._network);\n\n    // const p2wpkh = bitcoin.payments.p2wpkh({\n    //   pubkey: this._wallet.publicKey,\n    //   network: this._network,\n    // });\n\n    // if (!p2wpkh?.address) {\n    //   throw new Error(\"Address is not initialized.\");\n    // }\n\n    // return {\n    //   address: p2wpkh.address,\n    //   publicKey: this._wallet.publicKey.toString(\"hex\"),\n    //   purpose: \"payment\",\n    //   addressType: \"p2wpkh\",\n    // };\n  }"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.getPublicKey",
      "fullName": "bitcoin:wallets.embedded.index.ts.getPublicKey",
      "name": "getPublicKey",
      "signature": "getPublicKey(): string {",
      "documentation": "  /**\n   * Returns the hex-encoded public key of the wallet.\n   *\n   * @returns {string} The public key in hexadecimal format.\n   * @throws {Error} If the wallet is read-only and public key is not available.\n   */",
      "parameters": [],
      "returnType": "string",
      "isPublic": true,
      "line": 112,
      "raw": "  /**\n   * Returns the hex-encoded public key of the wallet.\n   *\n   * @returns {string} The public key in hexadecimal format.\n   * @throws {Error} If the wallet is read-only and public key is not available.\n   */\n  getPublicKey(): string {\n    if (this._isReadOnly) {\n      throw new Error(\"Public key is not available for read-only wallets.\");\n    }\n\n    if (!this._wallet) {\n      throw new Error(\"Wallet not initialized properly.\");\n    }\n\n    return this._wallet.publicKey.toString(\"hex\");\n  }",
      "source": "bitcoin",
      "implementation": "  getPublicKey(): string {\n    if (this._isReadOnly) {\n      throw new Error(\"Public key is not available for read-only wallets.\");\n    }\n\n    if (!this._wallet) {\n      throw new Error(\"Wallet not initialized properly.\");\n    }\n\n    return this._wallet.publicKey.toString(\"hex\");\n  }"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.getNetworkId",
      "fullName": "bitcoin:wallets.embedded.index.ts.getNetworkId",
      "name": "getNetworkId",
      "signature": "getNetworkId(): 0 | 1 {",
      "documentation": "  /**\n   * Returns the network identifier of the wallet.\n   * 0': Indicates the Bitcoin mainnet.\n   * 1': Indicates the Bitcoin testnet.\n   *\n   * @returns {0 | 1} The Bitcoin network ID.\n   */",
      "parameters": [],
      "returnType": "0 | 1",
      "isPublic": true,
      "line": 131,
      "raw": "  /**\n   * Returns the network identifier of the wallet.\n   * 0': Indicates the Bitcoin mainnet.\n   * 1': Indicates the Bitcoin testnet.\n   *\n   * @returns {0 | 1} The Bitcoin network ID.\n   */\n  getNetworkId(): 0 | 1 {\n    return this._network === bitcoin.networks.testnet ? 1 : 0;\n  }",
      "source": "bitcoin",
      "implementation": "  getNetworkId(): 0 | 1 {\n    return this._network === bitcoin.networks.testnet ? 1 : 0;\n  }"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts._derive",
      "fullName": "bitcoin:wallets.embedded.index.ts._derive",
      "name": "_derive",
      "signature": "function _derive(",
      "documentation": "",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 257,
      "raw": "function _derive(\n  words: string[],\n  path: string = \"m/84'/0'/0'/0/0\",\n  network?: Network\n): BIP32Interface {\n  const mnemonic = words.join(\" \");\n\n  if (!validateMnemonic(mnemonic)) {\n    throw new Error(\"Invalid mnemonic provided.\");\n  }\n\n  const seed = mnemonicToSeedSync(mnemonic);\n  const root = bip32.fromSeed(seed, network);\n  const child = root.derivePath(path);\n\n  return child;\n}",
      "source": "bitcoin",
      "implementation": "function _derive(\n  words: string[],\n  path: string = \"m/84'/0'/0'/0/0\",\n  network?: Network\n): BIP32Interface {\n  const mnemonic = words.join(\" \");\n\n  if (!validateMnemonic(mnemonic)) {\n    throw new Error(\"Invalid mnemonic provided.\");\n  }\n\n  const seed = mnemonicToSeedSync(mnemonic);\n  const root = bip32.fromSeed(seed, network);\n  const child = root.derivePath(path);\n\n  return child;\n}"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.varIntBuffer",
      "fullName": "bitcoin:wallets.embedded.index.ts.varIntBuffer",
      "name": "varIntBuffer",
      "signature": "function varIntBuffer(n: number): Buffer {",
      "documentation": "",
      "parameters": [
        {
          "name": "n",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "Buffer",
      "isPublic": true,
      "line": 275,
      "raw": "function varIntBuffer(n: number): Buffer {\n  if (n < 0xfd) return Buffer.from([n]);\n  if (n <= 0xffff) return Buffer.from([0xfd, n & 0xff, n >> 8]);\n  if (n <= 0xffffffff)\n    return Buffer.from([\n      0xfe,\n      n & 0xff,\n      (n >> 8) & 0xff,\n      (n >> 16) & 0xff,\n      (n >> 24) & 0xff,\n    ]);\n  throw new Error(\"Message too long\");\n}",
      "source": "bitcoin",
      "implementation": "function varIntBuffer(n: number): Buffer {\n  if (n < 0xfd) return Buffer.from([n]);\n  if (n <= 0xffff) return Buffer.from([0xfd, n & 0xff, n >> 8]);\n  if (n <= 0xffffffff)\n    return Buffer.from([\n      0xfe,\n      n & 0xff,\n      (n >> 8) & 0xff,\n      (n >> 16) & 0xff,\n      (n >> 24) & 0xff,\n    ]);\n  throw new Error(\"Message too long\");\n}"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.verifySignature",
      "fullName": "bitcoin:wallets.embedded.index.ts.verifySignature",
      "name": "verifySignature",
      "signature": "export function verifySignature(",
      "documentation": "/**\n * Verifies if a signature is valid for a given message and public key.\n * @param message - The original message that was signed.\n * @param signatureBase64 - The base64-encoded signature to verify.\n * @param publicKeyHex - The hex-encoded public key to verify against.\n * @returns {boolean} True if the signature is valid and matches the public key.\n */",
      "parameters": [],
      "returnType": "any",
      "isPublic": true,
      "line": 296,
      "raw": "/**\n * Verifies if a signature is valid for a given message and public key.\n * @param message - The original message that was signed.\n * @param signatureBase64 - The base64-encoded signature to verify.\n * @param publicKeyHex - The hex-encoded public key to verify against.\n * @returns {boolean} True if the signature is valid and matches the public key.\n */\nexport function verifySignature(\n  message: string,\n  signatureBase64: string,\n  publicKeyHex: string\n): boolean {\n  try {\n    const messageBuffer = Buffer.from(message, \"utf8\");\n    const bufferToHash = Buffer.concat([\n      varIntBuffer(messageBuffer.length),\n      messageBuffer,\n    ]);\n    const hash = bitcoin.crypto.hash256(bufferToHash);\n    const signature = Buffer.from(signatureBase64, \"base64\");\n    const publicKey = Buffer.from(publicKeyHex, \"hex\");\n\n    return ECPair.fromPublicKey(publicKey).verify(hash, signature);\n  } catch (e) {\n    return false;\n  }\n}",
      "source": "bitcoin",
      "implementation": "export function verifySignature(\n  message: string,\n  signatureBase64: string,\n  publicKeyHex: string\n): boolean {\n  try {\n    const messageBuffer = Buffer.from(message, \"utf8\");\n    const bufferToHash = Buffer.concat([\n      varIntBuffer(messageBuffer.length),\n      messageBuffer,\n    ]);\n    const hash = bitcoin.crypto.hash256(bufferToHash);\n    const signature = Buffer.from(signatureBase64, \"base64\");\n    const publicKey = Buffer.from(publicKeyHex, \"hex\");\n\n    return ECPair.fromPublicKey(publicKey).verify(hash, signature);\n  } catch (e) {\n    return false;\n  }\n}"
    }
  ],
  "atoms": [],
  "types": [
    {
      "key": "mesh-contract:common.ts.MeshTxInitiatorInput",
      "fullName": "mesh-contract:common.ts.MeshTxInitiatorInput",
      "name": "MeshTxInitiatorInput",
      "definition": "export type MeshTxInitiatorInput = {\n  mesh: MeshTxBuilder;\n  fetcher?: IFetcher;",
      "isPublic": true,
      "line": 12,
      "raw": "export type MeshTxInitiatorInput = {",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.common.ts.InputUTxO",
      "fullName": "mesh-contract:content-ownership.offchain.common.ts.InputUTxO",
      "name": "InputUTxO",
      "definition": "export type InputUTxO = UTxO[\"input\"];",
      "isPublic": true,
      "line": 14,
      "raw": "export type InputUTxO = UTxO[\"input\"];",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.common.ts.ScriptIndex",
      "fullName": "mesh-contract:content-ownership.offchain.common.ts.ScriptIndex",
      "name": "ScriptIndex",
      "definition": "export type ScriptIndex =\n  | \"OracleNFT\"\n  | \"OracleValidator\"\n  | \"ContentRegistry\"\n  | \"ContentRefToken\"\n  | \"OwnershipRegistry\"\n  | \"OwnershipRefToken\";",
      "isPublic": true,
      "line": 16,
      "raw": "export type ScriptIndex =",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.type.ts.OracleDatum",
      "fullName": "mesh-contract:content-ownership.offchain.type.ts.OracleDatum",
      "name": "OracleDatum",
      "definition": "export type OracleDatum = ConStr0<\n  [\n    BuiltinByteString, // oracle_nft: PolicyId,\n    ScriptAddress, // oracle_address: Address,\n    BuiltinByteString, // content_registry_ref_token: PolicyId,\n    ScriptAddress, // content_registry_address: Address,\n    Integer, // content_registry_count: Int,\n    BuiltinByteString, // ownership_registry_ref_token: PolicyId,\n    ScriptAddress, // ownership_registry_address: Address,\n    Integer, // ownership_registry_count: Int,\n    BuiltinByteString, // operation_key: ByteArray,\n    BuiltinByteString, // stop_key: ByteArray,\n  ]\n>;",
      "isPublic": true,
      "line": 10,
      "raw": "export type OracleDatum = ConStr0<",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.type.ts.ContentRegistryDatum",
      "fullName": "mesh-contract:content-ownership.offchain.type.ts.ContentRegistryDatum",
      "name": "ContentRegistryDatum",
      "definition": "export type ContentRegistryDatum = ConStr0<[Integer, List<BuiltinByteString>]>;",
      "isPublic": true,
      "line": 25,
      "raw": "export type ContentRegistryDatum = ConStr0<[Integer, List<BuiltinByteString>]>;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.type.ts.OwnershipRegistryDatum",
      "fullName": "mesh-contract:content-ownership.offchain.type.ts.OwnershipRegistryDatum",
      "name": "OwnershipRegistryDatum",
      "definition": "export type OwnershipRegistryDatum = ConStr0<\n  [Integer, List<{ list: [BuiltinByteString, BuiltinByteString] }>]\n>;",
      "isPublic": true,
      "line": 27,
      "raw": "export type OwnershipRegistryDatum = ConStr0<",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.type.ts.UpdateContent",
      "fullName": "mesh-contract:content-ownership.offchain.type.ts.UpdateContent",
      "name": "UpdateContent",
      "definition": "export type UpdateContent = {\n  ownerTokenUtxo: UTxO;\n  registryNumber: number;",
      "isPublic": true,
      "line": 31,
      "raw": "export type UpdateContent = {",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.type.ts.TransferContent",
      "fullName": "mesh-contract:content-ownership.offchain.type.ts.TransferContent",
      "name": "TransferContent",
      "definition": "export type TransferContent = {\n  ownerTokenUtxo: UTxO;\n  registryNumber: number;",
      "isPublic": true,
      "line": 38,
      "raw": "export type TransferContent = {",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:escrow.offchain.ts.InitiationDatum",
      "fullName": "mesh-contract:escrow.offchain.ts.InitiationDatum",
      "name": "InitiationDatum",
      "definition": "export type InitiationDatum = ConStr0<[PubKeyAddress, Value]>;",
      "isPublic": true,
      "line": 30,
      "raw": "export type InitiationDatum = ConStr0<[PubKeyAddress, Value]>;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:escrow.offchain.ts.ActiveEscrowDatum",
      "fullName": "mesh-contract:escrow.offchain.ts.ActiveEscrowDatum",
      "name": "ActiveEscrowDatum",
      "definition": "export type ActiveEscrowDatum = ConStr1<\n  [PubKeyAddress, Value, PubKeyAddress, Value]\n>;",
      "isPublic": true,
      "line": 42,
      "raw": "export type ActiveEscrowDatum = ConStr1<",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:escrow.offchain.ts.RecipientDepositRedeemer",
      "fullName": "mesh-contract:escrow.offchain.ts.RecipientDepositRedeemer",
      "name": "RecipientDepositRedeemer",
      "definition": "export type RecipientDepositRedeemer = ConStr0<[PubKeyAddress, Value]>;",
      "isPublic": true,
      "line": 60,
      "raw": "export type RecipientDepositRedeemer = ConStr0<[PubKeyAddress, Value]>;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:hello-world.offchain.ts.HelloWorldDatum",
      "fullName": "mesh-contract:hello-world.offchain.ts.HelloWorldDatum",
      "name": "HelloWorldDatum",
      "definition": "export type HelloWorldDatum = ConStr0<\n  [Integer, BuiltinByteString, BuiltinByteString]\n>;",
      "isPublic": true,
      "line": 17,
      "raw": "export type HelloWorldDatum = ConStr0<",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:marketplace.offchain.ts.MarketplaceDatum",
      "fullName": "mesh-contract:marketplace.offchain.ts.MarketplaceDatum",
      "name": "MarketplaceDatum",
      "definition": "export type MarketplaceDatum = ConStr0<\n  [PubKeyAddress, Integer, CurrencySymbol, TokenName]\n>;",
      "isPublic": true,
      "line": 30,
      "raw": "export type MarketplaceDatum = ConStr0<",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:plutus-nft.type.ts.OracleDatum",
      "fullName": "mesh-contract:plutus-nft.type.ts.OracleDatum",
      "name": "OracleDatum",
      "definition": "export type OracleDatum = ConStr0<[Integer, Integer, PubKeyAddress]>;",
      "isPublic": true,
      "line": 3,
      "raw": "export type OracleDatum = ConStr0<[Integer, Integer, PubKeyAddress]>;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:swap.offchain.ts.SwapDatum",
      "fullName": "mesh-contract:swap.offchain.ts.SwapDatum",
      "name": "SwapDatum",
      "definition": "export type SwapDatum = ConStr0<[PubKeyAddress, Value, Value]>;",
      "isPublic": true,
      "line": 25,
      "raw": "export type SwapDatum = ConStr0<[PubKeyAddress, Value, Value]>;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:vesting.offchain.ts.VestingDatum",
      "fullName": "mesh-contract:vesting.offchain.ts.VestingDatum",
      "name": "VestingDatum",
      "definition": "export type VestingDatum = ConStr0<\n  [Integer, BuiltinByteString, BuiltinByteString]\n>;",
      "isPublic": true,
      "line": 21,
      "raw": "export type VestingDatum = ConStr0<",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.coin-selection-interface.ts.TransactionPrototype",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.coin-selection-interface.ts.TransactionPrototype",
      "name": "TransactionPrototype",
      "definition": "export interface TransactionPrototype {\n  newInputs: Set<UTxO>;",
      "isPublic": true,
      "line": 10,
      "raw": "export interface TransactionPrototype {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.coin-selection-interface.ts.ImplicitValue",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.coin-selection-interface.ts.ImplicitValue",
      "name": "ImplicitValue",
      "definition": "export interface ImplicitValue {\n  withdrawals: bigint;",
      "isPublic": true,
      "line": 18,
      "raw": "export interface ImplicitValue {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.coin-selection-interface.ts.TransactionCost",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.coin-selection-interface.ts.TransactionCost",
      "name": "TransactionCost",
      "definition": "export interface TransactionCost {\n  fee: bigint;",
      "isPublic": true,
      "line": 25,
      "raw": "export interface TransactionCost {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.coin-selection-interface.ts.BuilderCallbacks",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.coin-selection-interface.ts.BuilderCallbacks",
      "name": "BuilderCallbacks",
      "definition": "export interface BuilderCallbacks {\n  computeMinimumCost: EstimateTxCosts;",
      "isPublic": true,
      "line": 41,
      "raw": "export interface BuilderCallbacks {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.coin-selection-interface.ts.IInputSelector",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.coin-selection-interface.ts.IInputSelector",
      "name": "IInputSelector",
      "definition": "export interface IInputSelector {\n  select: (\n    preselectedUtoxs: TxIn[],\n    outputs: Output[],\n    implicitValue: ImplicitValue,\n    utxos: UTxO[],\n    changeAddress: string,\n  ) => Promise<TransactionPrototype>;\n}",
      "isPublic": true,
      "line": 48,
      "raw": "export interface IInputSelector {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.MeshTxBuilderOptions",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.MeshTxBuilderOptions",
      "name": "MeshTxBuilderOptions",
      "definition": "export interface MeshTxBuilderOptions {\n  fetcher?: IFetcher;",
      "isPublic": true,
      "line": 49,
      "raw": "export interface MeshTxBuilderOptions {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.TransactionOptions",
      "fullName": "mesh-transaction:transaction.index.ts.TransactionOptions",
      "name": "TransactionOptions",
      "definition": "export interface TransactionOptions extends MeshTxBuilderOptions {\n  initiator: IInitiator;",
      "isPublic": true,
      "line": 39,
      "raw": "export interface TransactionOptions extends MeshTxBuilderOptions {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.transaction-v2.ts.TransactionV2",
      "fullName": "mesh-transaction:transaction.transaction-v2.ts.TransactionV2",
      "name": "TransactionV2",
      "definition": "export interface TransactionV2 {\n  sendAssets(\n    receiver: string,\n    assets: Asset[],\n    datum?: Data,\n    inlineScript?: string,\n    isInline?: boolean,\n  ): this;",
      "isPublic": true,
      "line": 17,
      "raw": "export interface TransactionV2 {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:utils.metadata.ts.MetadataMergeLevel",
      "fullName": "mesh-transaction:utils.metadata.ts.MetadataMergeLevel",
      "name": "MetadataMergeLevel",
      "definition": "export type MetadataMergeLevel = boolean | number;",
      "isPublic": true,
      "line": 5,
      "raw": "export type MetadataMergeLevel = boolean | number;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-wallet:app.index.ts.AppWalletKeyType",
      "fullName": "mesh-wallet:app.index.ts.AppWalletKeyType",
      "name": "AppWalletKeyType",
      "definition": "export type AppWalletKeyType =\n  | {\n      type: \"root\";\n      bech32: string;",
      "isPublic": true,
      "line": 13,
      "raw": "export type AppWalletKeyType =",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:app.index.ts.CreateAppWalletOptions",
      "fullName": "mesh-wallet:app.index.ts.CreateAppWalletOptions",
      "name": "CreateAppWalletOptions",
      "definition": "export type CreateAppWalletOptions = {\n  networkId: number;\n  fetcher?: IFetcher;",
      "isPublic": true,
      "line": 28,
      "raw": "export type CreateAppWalletOptions = {",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.Window",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.Window",
      "name": "Window",
      "definition": "interface Window {\n    cardano: Cardano;",
      "isPublic": true,
      "line": 43,
      "raw": "interface Window {",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.AccountType",
      "fullName": "mesh-wallet:embedded.index.ts.AccountType",
      "name": "AccountType",
      "definition": "export type AccountType = \"payment\" | \"stake\" | \"drep\";",
      "isPublic": true,
      "line": 36,
      "raw": "export type AccountType = \"payment\" | \"stake\" | \"drep\";",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.Account",
      "fullName": "mesh-wallet:embedded.index.ts.Account",
      "name": "Account",
      "definition": "export type Account = {\n  baseAddress: Address;\n  enterpriseAddress: Address;",
      "isPublic": true,
      "line": 38,
      "raw": "export type Account = {",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.EmbeddedWalletKeyType",
      "fullName": "mesh-wallet:embedded.index.ts.EmbeddedWalletKeyType",
      "name": "EmbeddedWalletKeyType",
      "definition": "export type EmbeddedWalletKeyType =\n  | {\n      type: \"root\";\n      bech32: string;",
      "isPublic": true,
      "line": 57,
      "raw": "export type EmbeddedWalletKeyType =",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.CreateEmbeddedWalletOptions",
      "fullName": "mesh-wallet:embedded.index.ts.CreateEmbeddedWalletOptions",
      "name": "CreateEmbeddedWalletOptions",
      "definition": "export type CreateEmbeddedWalletOptions = {\n  networkId: number;\n  key: EmbeddedWalletKeyType;",
      "isPublic": true,
      "line": 76,
      "raw": "export type CreateEmbeddedWalletOptions = {",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.CreateMeshWalletOptions",
      "fullName": "mesh-wallet:mesh.index.ts.CreateMeshWalletOptions",
      "name": "CreateMeshWalletOptions",
      "definition": "export type CreateMeshWalletOptions = {\n  networkId: 0 | 1;\n  fetcher?: IFetcher;",
      "isPublic": true,
      "line": 35,
      "raw": "export type CreateMeshWalletOptions = {",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:types.index.ts.Cardano",
      "fullName": "mesh-wallet:types.index.ts.Cardano",
      "name": "Cardano",
      "definition": "export type Cardano = {\n  [key: string]: {\n    name: string;\n    icon: string;\n    apiVersion: string;",
      "isPublic": true,
      "line": 4,
      "raw": "export type Cardano = {",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:types.index.ts.TransactionSignatureRequest",
      "fullName": "mesh-wallet:types.index.ts.TransactionSignatureRequest",
      "name": "TransactionSignatureRequest",
      "definition": "type TransactionSignatureRequest = {\n  cbor: string;\n  partialSign: boolean;",
      "isPublic": true,
      "line": 16,
      "raw": "type TransactionSignatureRequest = {",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:types.index.ts.Cip30WalletApi",
      "fullName": "mesh-wallet:types.index.ts.Cip30WalletApi",
      "name": "Cip30WalletApi",
      "definition": "export interface Cip30WalletApi {\n  experimental: ExperimentalFeatures;",
      "isPublic": true,
      "line": 21,
      "raw": "export interface Cip30WalletApi {",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:types.index.ts.Cip95WalletApi",
      "fullName": "mesh-wallet:types.index.ts.Cip95WalletApi",
      "name": "Cip95WalletApi",
      "definition": "export interface Cip95WalletApi {\n  getRegisteredPubStakeKeys: () => Promise<Ed25519PublicKeyHex[]>;\n  getUnregisteredPubStakeKeys: () => Promise<Ed25519PublicKeyHex[]>;\n  getPubDRepKey: () => Promise<Ed25519PublicKeyHex>;\n  signData(address: string, payload: string): Promise<DataSignature>;",
      "isPublic": true,
      "line": 40,
      "raw": "export interface Cip95WalletApi {",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:types.index.ts.WalletInstance",
      "fullName": "mesh-wallet:types.index.ts.WalletInstance",
      "name": "WalletInstance",
      "definition": "export type WalletInstance = Cip30WalletApi & Cip95WalletApi;",
      "isPublic": true,
      "line": 47,
      "raw": "export type WalletInstance = Cip30WalletApi & Cip95WalletApi;",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:types.index.ts.ExperimentalFeatures",
      "fullName": "mesh-wallet:types.index.ts.ExperimentalFeatures",
      "name": "ExperimentalFeatures",
      "definition": "type ExperimentalFeatures = {\n  getCollateral(): Promise<string[] | undefined>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard",
      "isPublic": true,
      "line": 49,
      "raw": "type ExperimentalFeatures = {",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:types.index.ts.GetAddressType",
      "fullName": "mesh-wallet:types.index.ts.GetAddressType",
      "name": "GetAddressType",
      "definition": "export type GetAddressType = \"enterprise\" | \"payment\";",
      "isPublic": true,
      "line": 55,
      "raw": "export type GetAddressType = \"enterprise\" | \"payment\";",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-hydra:types.events.ts.Greetings",
      "fullName": "mesh-hydra:types.events.ts.Greetings",
      "name": "Greetings",
      "definition": "export type Greetings = {\n  tag: \"Greetings\";\n  me: {\n    vkey: string;\n  };\n  headStatus:\n    | \"Idle\"\n    | \"Initializing\"\n    | \"Open\"\n    | \"Closed\"\n    | \"FanoutPossible\"\n    | \"Final\";\n  hydraHeadId: string;\n  snapshotUtxo: hUTxOs;\n  timestamp: string;\n  hydraNodeVersion: string;\n};\n\nexport type PeerConnected = {\n  tag: \"PeerConnected\";\n  peer: string;\n  seq: number;\n  timestamp: string;\n};\n\nexport type PeerDisconnected = {\n  tag: \"PeerDisconnected\";\n  peer: string;\n  seq: number;\n  timestamp: string;\n};\n\nexport type PeerHandshakeFailure = {\n  tag: \"PeerHandshakeFailure\";\n  remoteHost:\n    | {\n        tag: \"IPv4\";\n        ipv4: string;\n      }\n    | {\n        tag: \"IPv6\";\n        ipv6: string;\n      };\n  ourVersion: number;\n  theirVersions: number[];\n  seq: number;\n  timestamp: string;\n};\n\nexport type HeadIsInitializing = {\n  tag: \"HeadIsInitializing\";\n  headId: string;\n  parties: HydraParty[];\n  seq: number;\n  timestamp: string;\n};\n\nexport type Committed = {\n  tag: \"Committed\";\n  parties: HydraParty[];\n  utxo: hUTxOs;\n  seq: number;\n  timestamp: string;\n};\n\nexport type HeadIsOpen = {\n  tag: \"HeadIsOpen\";\n  headId: string;\n  utxo: hUTxOs;\n  seq: number;\n  timestamp: string;\n};\n\nexport type HeadIsClosed = {\n  tag: \"HeadIsClosed\";\n  headId: string;\n  snapshotNumber: number;\n  contestationDeadline: string;\n  seq: number;\n  timestamp: string;\n};\n\nexport type HeadIsContested = {\n  tag: \"HeadIsContested\";\n  headId: string;\n  snapshotNumber: number;\n  contestationDeadline: string;\n  seq: number;\n  timestamp: string;\n};\n\nexport type ReadyToFanout = {\n  tag: \"ReadyToFanout\";\n  headId: string;\n  seq: number;\n  timestamp: string;\n};\n\nexport type HeadIsAborted = {\n  tag: \"HeadIsAborted\";\n  headId: string;\n  utxo: hUTxOs;\n  seq: number;\n  timestamp: string;\n};\n\nexport type HeadIsFinalized = {\n  tag: \"HeadIsFinalized\";\n  headId: string;\n  utxo: hUTxOs;\n  seq: number;\n  timestamp: string;\n};\n\nexport type TxValid = {\n  headId: string;\n  tag: \"TxValid\";\n  seq: number;\n  timestamp: string;\n  transaction: hTransaction;\n};\n\nexport type TxInvalid = {\n  tag: \"TxInvalid\";\n  headId: string;\n  utxo: hUTxOs;\n  transaction: hTransaction;\n  validationError: { reason: string };\n  seq: number;\n  timestamp: string;\n};\n\nexport type SnapshotConfirmed = {\n  tag: \"SnapshotConfirmed\";\n  headId: string;\n  snapshot: HydraSnapshot;\n  seq: number;\n  timestamp: string;\n};\n\nexport type GetUTxOResponse = {\n  tag: \"GetUTxOResponse\";\n  headId: string;\n  utxo: hUTxOs;\n  seq: number;\n  timestamp: string;\n};\n\nexport type InvalidInput = {\n  tag: \"InvalidInput\";\n  reason: string;\n  input: string;\n  seq: number;\n  timestamp: string;\n};\n\nexport type PostTxOnChainFailed = {\n  tag: \"PostTxOnChainFailed\";\n  postChainTx: PostChainTx;\n  postTxError: unknown;\n  seq: number;\n  timestamp: string;\n};\n\nexport type CommandFailed = {\n  tag: \"CommandFailed\";\n  clientInput:\n    | {\n        tag: \"Abort\";\n      }\n    | { tag: \"NewTx\"; transaction: hTransaction }\n    | { tag: \"GetUTxO\" }\n    | { tag: \"Decommit\"; decommitTx: hTransaction }\n    | { tag: \"Close\" }\n    | { tag: \"Contest\" }\n    | { tag: \"Fanout\" };\n  seq: number;\n  timestamp: string;\n};\n\nexport type IgnoredHeadInitializing = {\n  tag: \"IgnoredHeadInitializing\";\n  headId: string;\n  contestationPeriod: number;\n  parties: HydraParty[];\n  participants: string[];\n  seq: number;\n  timestamp: string;\n};\n\nexport type DecommitInvalid = {\n  tag: \"DecommitInvalid\";\n  headId: string;\n  decommitTx: hTransaction;\n  decommitInvalidReason:\n    | {\n        tag: \"DecommitTxInvalid\";\n        localUtxo: hUTxOs;\n        validationError: { reason: string };\n      }\n    | { tag: \"DecommitAlreadyInFlight\"; otherDecommitTxId: string };\n};\n\nexport type DecommitRequested = {\n  tag: \"DecommitRequested\";\n  headId: string;\n  decommitTx: hTransaction;\n  utxoToDecommit: hUTxOs;\n  seq: number;\n  timestmap: string;\n};\n\nexport type DecommitApproved = {\n  tag: \"DecommitApproved\";\n  headId: string;\n  decommitTxId: string;\n  utxoToDecommit: hUTxOs;\n  seq: number;\n  timestamp: string;\n};\n\nexport type DecommitFinalized = {\n  tag: \"DecommitFinalized\";\n  headId: string;\n  decommitTxId: string;\n  seq: number;\n  timestamp: string;\n};",
      "isPublic": true,
      "line": 9,
      "raw": "export type Greetings = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.PeerConnected",
      "fullName": "mesh-hydra:types.events.ts.PeerConnected",
      "name": "PeerConnected",
      "definition": "export type PeerConnected = {\n  tag: \"PeerConnected\";\n  peer: string;",
      "isPublic": true,
      "line": 27,
      "raw": "export type PeerConnected = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.PeerDisconnected",
      "fullName": "mesh-hydra:types.events.ts.PeerDisconnected",
      "name": "PeerDisconnected",
      "definition": "export type PeerDisconnected = {\n  tag: \"PeerDisconnected\";\n  peer: string;",
      "isPublic": true,
      "line": 34,
      "raw": "export type PeerDisconnected = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.PeerHandshakeFailure",
      "fullName": "mesh-hydra:types.events.ts.PeerHandshakeFailure",
      "name": "PeerHandshakeFailure",
      "definition": "export type PeerHandshakeFailure = {\n  tag: \"PeerHandshakeFailure\";\n  remoteHost:\n    | {\n        tag: \"IPv4\";\n        ipv4: string;",
      "isPublic": true,
      "line": 41,
      "raw": "export type PeerHandshakeFailure = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.HeadIsInitializing",
      "fullName": "mesh-hydra:types.events.ts.HeadIsInitializing",
      "name": "HeadIsInitializing",
      "definition": "export type HeadIsInitializing = {\n  tag: \"HeadIsInitializing\";\n  headId: string;",
      "isPublic": true,
      "line": 58,
      "raw": "export type HeadIsInitializing = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.Committed",
      "fullName": "mesh-hydra:types.events.ts.Committed",
      "name": "Committed",
      "definition": "export type Committed = {\n  tag: \"Committed\";\n  parties: HydraParty[];",
      "isPublic": true,
      "line": 66,
      "raw": "export type Committed = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.HeadIsOpen",
      "fullName": "mesh-hydra:types.events.ts.HeadIsOpen",
      "name": "HeadIsOpen",
      "definition": "export type HeadIsOpen = {\n  tag: \"HeadIsOpen\";\n  headId: string;",
      "isPublic": true,
      "line": 74,
      "raw": "export type HeadIsOpen = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.HeadIsClosed",
      "fullName": "mesh-hydra:types.events.ts.HeadIsClosed",
      "name": "HeadIsClosed",
      "definition": "export type HeadIsClosed = {\n  tag: \"HeadIsClosed\";\n  headId: string;",
      "isPublic": true,
      "line": 82,
      "raw": "export type HeadIsClosed = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.HeadIsContested",
      "fullName": "mesh-hydra:types.events.ts.HeadIsContested",
      "name": "HeadIsContested",
      "definition": "export type HeadIsContested = {\n  tag: \"HeadIsContested\";\n  headId: string;",
      "isPublic": true,
      "line": 91,
      "raw": "export type HeadIsContested = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.ReadyToFanout",
      "fullName": "mesh-hydra:types.events.ts.ReadyToFanout",
      "name": "ReadyToFanout",
      "definition": "export type ReadyToFanout = {\n  tag: \"ReadyToFanout\";\n  headId: string;",
      "isPublic": true,
      "line": 100,
      "raw": "export type ReadyToFanout = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.HeadIsAborted",
      "fullName": "mesh-hydra:types.events.ts.HeadIsAborted",
      "name": "HeadIsAborted",
      "definition": "export type HeadIsAborted = {\n  tag: \"HeadIsAborted\";\n  headId: string;",
      "isPublic": true,
      "line": 107,
      "raw": "export type HeadIsAborted = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.HeadIsFinalized",
      "fullName": "mesh-hydra:types.events.ts.HeadIsFinalized",
      "name": "HeadIsFinalized",
      "definition": "export type HeadIsFinalized = {\n  tag: \"HeadIsFinalized\";\n  headId: string;",
      "isPublic": true,
      "line": 115,
      "raw": "export type HeadIsFinalized = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.TxValid",
      "fullName": "mesh-hydra:types.events.ts.TxValid",
      "name": "TxValid",
      "definition": "export type TxValid = {\n  headId: string;\n  tag: \"TxValid\";",
      "isPublic": true,
      "line": 123,
      "raw": "export type TxValid = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.TxInvalid",
      "fullName": "mesh-hydra:types.events.ts.TxInvalid",
      "name": "TxInvalid",
      "definition": "export type TxInvalid = {\n  tag: \"TxInvalid\";\n  headId: string;",
      "isPublic": true,
      "line": 131,
      "raw": "export type TxInvalid = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.SnapshotConfirmed",
      "fullName": "mesh-hydra:types.events.ts.SnapshotConfirmed",
      "name": "SnapshotConfirmed",
      "definition": "export type SnapshotConfirmed = {\n  tag: \"SnapshotConfirmed\";\n  headId: string;",
      "isPublic": true,
      "line": 141,
      "raw": "export type SnapshotConfirmed = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.GetUTxOResponse",
      "fullName": "mesh-hydra:types.events.ts.GetUTxOResponse",
      "name": "GetUTxOResponse",
      "definition": "export type GetUTxOResponse = {\n  tag: \"GetUTxOResponse\";\n  headId: string;",
      "isPublic": true,
      "line": 149,
      "raw": "export type GetUTxOResponse = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.InvalidInput",
      "fullName": "mesh-hydra:types.events.ts.InvalidInput",
      "name": "InvalidInput",
      "definition": "export type InvalidInput = {\n  tag: \"InvalidInput\";\n  reason: string;",
      "isPublic": true,
      "line": 157,
      "raw": "export type InvalidInput = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.PostTxOnChainFailed",
      "fullName": "mesh-hydra:types.events.ts.PostTxOnChainFailed",
      "name": "PostTxOnChainFailed",
      "definition": "export type PostTxOnChainFailed = {\n  tag: \"PostTxOnChainFailed\";\n  postChainTx: PostChainTx;",
      "isPublic": true,
      "line": 165,
      "raw": "export type PostTxOnChainFailed = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.CommandFailed",
      "fullName": "mesh-hydra:types.events.ts.CommandFailed",
      "name": "CommandFailed",
      "definition": "export type CommandFailed = {\n  tag: \"CommandFailed\";\n  clientInput:\n    | {\n        tag: \"Abort\";\n      }",
      "isPublic": true,
      "line": 173,
      "raw": "export type CommandFailed = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.IgnoredHeadInitializing",
      "fullName": "mesh-hydra:types.events.ts.IgnoredHeadInitializing",
      "name": "IgnoredHeadInitializing",
      "definition": "export type IgnoredHeadInitializing = {\n  tag: \"IgnoredHeadInitializing\";\n  headId: string;",
      "isPublic": true,
      "line": 189,
      "raw": "export type IgnoredHeadInitializing = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.DecommitInvalid",
      "fullName": "mesh-hydra:types.events.ts.DecommitInvalid",
      "name": "DecommitInvalid",
      "definition": "export type DecommitInvalid = {\n  tag: \"DecommitInvalid\";\n  headId: string;",
      "isPublic": true,
      "line": 199,
      "raw": "export type DecommitInvalid = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.DecommitRequested",
      "fullName": "mesh-hydra:types.events.ts.DecommitRequested",
      "name": "DecommitRequested",
      "definition": "export type DecommitRequested = {\n  tag: \"DecommitRequested\";\n  headId: string;",
      "isPublic": true,
      "line": 212,
      "raw": "export type DecommitRequested = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.DecommitApproved",
      "fullName": "mesh-hydra:types.events.ts.DecommitApproved",
      "name": "DecommitApproved",
      "definition": "export type DecommitApproved = {\n  tag: \"DecommitApproved\";\n  headId: string;",
      "isPublic": true,
      "line": 221,
      "raw": "export type DecommitApproved = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.events.ts.DecommitFinalized",
      "fullName": "mesh-hydra:types.events.ts.DecommitFinalized",
      "name": "DecommitFinalized",
      "definition": "export type DecommitFinalized = {\n  tag: \"DecommitFinalized\";\n  headId: string;",
      "isPublic": true,
      "line": 230,
      "raw": "export type DecommitFinalized = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hAssets.ts.hAssets",
      "fullName": "mesh-hydra:types.hAssets.ts.hAssets",
      "name": "hAssets",
      "definition": "export type hAssets = {\n  lovelace: bigint;\n} & {\n  [policyId: string]: {\n    [assetName: string]: bigint;\n  };\n};\n\nexport function hAssets(assets: Asset[]): hAssets {\n  return assets.reduce((p, asset) => {",
      "isPublic": true,
      "line": 3,
      "raw": "export type hAssets = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hReferenceScript.ts.hReferenceScript",
      "fullName": "mesh-hydra:types.hReferenceScript.ts.hReferenceScript",
      "name": "hReferenceScript",
      "definition": "export type hReferenceScript = {\n  scriptLanguage: string;\n  script: {\n    cborHex: string;\n    description: string;",
      "isPublic": true,
      "line": 1,
      "raw": "export type hReferenceScript = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hStatus.ts.hStatus",
      "fullName": "mesh-hydra:types.hStatus.ts.hStatus",
      "name": "hStatus",
      "definition": "export type hStatus = typeof status[number];",
      "isPublic": true,
      "line": 1,
      "raw": "export type hStatus = typeof status[number];",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hTransaction.ts.hTransaction",
      "fullName": "mesh-hydra:types.hTransaction.ts.hTransaction",
      "name": "hTransaction",
      "definition": "export type hTransaction = {\n  type: \"Tx ConwayEra\" | \"Unwitnessed Tx ConwayEra\" | \"Witnessed Tx ConwayEra\";\n  description: string;",
      "isPublic": true,
      "line": 1,
      "raw": "export type hTransaction = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hUTxOs.ts.hUTxOs",
      "fullName": "mesh-hydra:types.hUTxOs.ts.hUTxOs",
      "name": "hUTxOs",
      "definition": "export type hUTxOs = {\n  [txRef: string]: hUTxO;\n};\n\nexport function hUTxOs(utxos: UTxO[]): hUTxOs {",
      "isPublic": true,
      "line": 5,
      "raw": "export type hUTxOs = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hUTxOs.ts.hUTxO",
      "fullName": "mesh-hydra:types.hUTxOs.ts.hUTxO",
      "name": "hUTxO",
      "definition": "export type hUTxO = {\n  address: string;\n  value: hAssets;",
      "isPublic": true,
      "line": 15,
      "raw": "export type hUTxO = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hydra-post-chain-tx.ts.PostChainTx",
      "fullName": "mesh-hydra:types.hydra-post-chain-tx.ts.PostChainTx",
      "name": "PostChainTx",
      "definition": "export type PostChainTx =\n  | InitTx\n  | AbortTx\n  | CollectComTx\n  | DecrementTx\n  | CloseTx\n  | ContestTx\n  | FanoutTx;",
      "isPublic": true,
      "line": 4,
      "raw": "export type PostChainTx =",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hydra-post-chain-tx.ts.InitTx",
      "fullName": "mesh-hydra:types.hydra-post-chain-tx.ts.InitTx",
      "name": "InitTx",
      "definition": "export type InitTx = {\n  tag: \"InitTx\";\n  participants: string[];",
      "isPublic": true,
      "line": 13,
      "raw": "export type InitTx = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hydra-post-chain-tx.ts.AbortTx",
      "fullName": "mesh-hydra:types.hydra-post-chain-tx.ts.AbortTx",
      "name": "AbortTx",
      "definition": "export type AbortTx = {\n  tag: \"AbortTx\";\n  utxo: { [txRef: string]: hUTxO };",
      "isPublic": true,
      "line": 19,
      "raw": "export type AbortTx = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hydra-post-chain-tx.ts.CollectComTx",
      "fullName": "mesh-hydra:types.hydra-post-chain-tx.ts.CollectComTx",
      "name": "CollectComTx",
      "definition": "export type CollectComTx = {\n  tag: \"CollectComTx\";\n  utxo: { [txRef: string]: hUTxO };",
      "isPublic": true,
      "line": 25,
      "raw": "export type CollectComTx = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hydra-post-chain-tx.ts.InitialSnapshot",
      "fullName": "mesh-hydra:types.hydra-post-chain-tx.ts.InitialSnapshot",
      "name": "InitialSnapshot",
      "definition": "export type InitialSnapshot = {\n  headId: string;\n  initialUtxo: { [txRef: string]: hUTxO };",
      "isPublic": true,
      "line": 32,
      "raw": "export type InitialSnapshot = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hydra-post-chain-tx.ts.ConfirmedSnapshot",
      "fullName": "mesh-hydra:types.hydra-post-chain-tx.ts.ConfirmedSnapshot",
      "name": "ConfirmedSnapshot",
      "definition": "export type ConfirmedSnapshot = {\n  snapshot: HydraSnapshot;\n  signatures: {\n    mutliSignature: string[];\n  };\n  tag: \"ConfirmedSnapshot\";\n};\nexport type DecrementTx = {\n  tag: \"DecrementTx\";\n  headId: string;\n  headParameters: HydraHeadParameters;\n  decerementingSnapshot: InitialSnapshot | ConfirmedSnapshot;\n};\n\nexport type CloseTx = {\n  tag: \"CloseTx\";\n  headId: string;\n  headParameters: HydraHeadParameters;\n  closingSnapshot: InitialSnapshot | ConfirmedSnapshot;\n  openVersion: number;\n};\n\nexport type ContestTx = {\n  tag: \"ContestTx\";\n  headId: string;\n  headParameters: HydraHeadParameters;\n  contestingSnapshot: InitialSnapshot | ConfirmedSnapshot;\n  openVersion: number;\n};\n\nexport type FanoutTx = {\n  tag: \"FanoutTx\";\n  utxo: { [txRef: string]: hUTxO };\n  utxoToDecommit: { [txRef: string]: hUTxO };\n  headSeed: string;\n  contestationDeadline: string;\n};",
      "isPublic": true,
      "line": 38,
      "raw": "export type ConfirmedSnapshot = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hydra-post-chain-tx.ts.DecrementTx",
      "fullName": "mesh-hydra:types.hydra-post-chain-tx.ts.DecrementTx",
      "name": "DecrementTx",
      "definition": "export type DecrementTx = {\n  tag: \"DecrementTx\";\n  headId: string;",
      "isPublic": true,
      "line": 45,
      "raw": "export type DecrementTx = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hydra-post-chain-tx.ts.CloseTx",
      "fullName": "mesh-hydra:types.hydra-post-chain-tx.ts.CloseTx",
      "name": "CloseTx",
      "definition": "export type CloseTx = {\n  tag: \"CloseTx\";\n  headId: string;",
      "isPublic": true,
      "line": 52,
      "raw": "export type CloseTx = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hydra-post-chain-tx.ts.ContestTx",
      "fullName": "mesh-hydra:types.hydra-post-chain-tx.ts.ContestTx",
      "name": "ContestTx",
      "definition": "export type ContestTx = {\n  tag: \"ContestTx\";\n  headId: string;",
      "isPublic": true,
      "line": 60,
      "raw": "export type ContestTx = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hydra-post-chain-tx.ts.FanoutTx",
      "fullName": "mesh-hydra:types.hydra-post-chain-tx.ts.FanoutTx",
      "name": "FanoutTx",
      "definition": "export type FanoutTx = {\n  tag: \"FanoutTx\";\n  utxo: { [txRef: string]: hUTxO };",
      "isPublic": true,
      "line": 68,
      "raw": "export type FanoutTx = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hydra.ts.HydraCommitTransaction",
      "fullName": "mesh-hydra:types.hydra.ts.HydraCommitTransaction",
      "name": "HydraCommitTransaction",
      "definition": "export type HydraCommitTransaction = {\n  cborHex: string;\n  description: string;",
      "isPublic": true,
      "line": 3,
      "raw": "export type HydraCommitTransaction = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hydra.ts.HydraHeadParameters",
      "fullName": "mesh-hydra:types.hydra.ts.HydraHeadParameters",
      "name": "HydraHeadParameters",
      "definition": "export interface HydraHeadParameters {\n  contestationPeriod: number;",
      "isPublic": true,
      "line": 10,
      "raw": "export interface HydraHeadParameters {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hydra.ts.HydraParty",
      "fullName": "mesh-hydra:types.hydra.ts.HydraParty",
      "name": "HydraParty",
      "definition": "export type HydraParty = {\n  vkey: string;\n};\n\nexport type HydraSnapshot = {\n  headId: string;",
      "isPublic": true,
      "line": 15,
      "raw": "export type HydraParty = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hydra.ts.HydraSnapshot",
      "fullName": "mesh-hydra:types.hydra.ts.HydraSnapshot",
      "name": "HydraSnapshot",
      "definition": "export type HydraSnapshot = {\n  headId: string;\n  snapshotNumber: string;",
      "isPublic": true,
      "line": 19,
      "raw": "export type HydraSnapshot = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.RedeemerTagWasm",
      "fullName": "mesh-core-csl:utils.transaction.ts.RedeemerTagWasm",
      "name": "RedeemerTagWasm",
      "definition": "type RedeemerTagWasm =\n  | \"cert\"\n  | \"mint\"\n  | \"reward\"\n  | \"spend\"\n  | \"vote\"\n  | \"propose\";",
      "isPublic": true,
      "line": 15,
      "raw": "type RedeemerTagWasm =",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.ActionWasm",
      "fullName": "mesh-core-csl:utils.transaction.ts.ActionWasm",
      "name": "ActionWasm",
      "definition": "type ActionWasm =\n  | {\n      success: SuccessAction;\n    }",
      "isPublic": true,
      "line": 22,
      "raw": "type ActionWasm =",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.SuccessAction",
      "fullName": "mesh-core-csl:utils.transaction.ts.SuccessAction",
      "name": "SuccessAction",
      "definition": "type SuccessAction = {\n  index: number;\n  budget: BudgetWasm;",
      "isPublic": true,
      "line": 29,
      "raw": "type SuccessAction = {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.ErrorAction",
      "fullName": "mesh-core-csl:utils.transaction.ts.ErrorAction",
      "name": "ErrorAction",
      "definition": "type ErrorAction = {\n  index: number;\n  budget: BudgetWasm;",
      "isPublic": true,
      "line": 34,
      "raw": "type ErrorAction = {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.BudgetWasm",
      "fullName": "mesh-core-csl:utils.transaction.ts.BudgetWasm",
      "name": "BudgetWasm",
      "definition": "type BudgetWasm = {\n  mem: number;\n  steps: number;",
      "isPublic": true,
      "line": 51,
      "raw": "type BudgetWasm = {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.OutputEncoding",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.OutputEncoding",
      "name": "OutputEncoding",
      "definition": "export type OutputEncoding =\n  | \"SingleCBOR\"\n  | \"DoubleCBOR\"\n  | \"PurePlutusScriptBytes\";",
      "isPublic": true,
      "line": 59,
      "raw": "export type OutputEncoding =",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Slot",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Slot",
      "name": "Slot",
      "definition": "export type Slot = Cardano.Slot;",
      "isPublic": true,
      "line": 7,
      "raw": "export type Slot = Cardano.Slot;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Value",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Value",
      "name": "Value",
      "definition": "export type Value = Serialization.Value;",
      "isPublic": true,
      "line": 10,
      "raw": "export type Value = Serialization.Value;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TokenMap",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TokenMap",
      "name": "TokenMap",
      "definition": "export type TokenMap = Cardano.TokenMap;",
      "isPublic": true,
      "line": 12,
      "raw": "export type TokenMap = Cardano.TokenMap;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Transaction",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Transaction",
      "name": "Transaction",
      "definition": "export type Transaction = Serialization.Transaction;",
      "isPublic": true,
      "line": 15,
      "raw": "export type Transaction = Serialization.Transaction;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TransactionId",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TransactionId",
      "name": "TransactionId",
      "definition": "export type TransactionId = Cardano.TransactionId;",
      "isPublic": true,
      "line": 20,
      "raw": "export type TransactionId = Cardano.TransactionId;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TransactionBody",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TransactionBody",
      "name": "TransactionBody",
      "definition": "export type TransactionBody = Serialization.TransactionBody;",
      "isPublic": true,
      "line": 23,
      "raw": "export type TransactionBody = Serialization.TransactionBody;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TransactionWitnessSet",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TransactionWitnessSet",
      "name": "TransactionWitnessSet",
      "definition": "export type TransactionWitnessSet = Serialization.TransactionWitnessSet;",
      "isPublic": true,
      "line": 26,
      "raw": "export type TransactionWitnessSet = Serialization.TransactionWitnessSet;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.AuxiliaryData",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.AuxiliaryData",
      "name": "AuxiliaryData",
      "definition": "export type AuxiliaryData = Serialization.AuxiliaryData;",
      "isPublic": true,
      "line": 29,
      "raw": "export type AuxiliaryData = Serialization.AuxiliaryData;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TransactionMetadatum",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TransactionMetadatum",
      "name": "TransactionMetadatum",
      "definition": "export type TransactionMetadatum = Serialization.TransactionMetadatum;",
      "isPublic": true,
      "line": 32,
      "raw": "export type TransactionMetadatum = Serialization.TransactionMetadatum;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.MetadatumMap",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.MetadatumMap",
      "name": "MetadatumMap",
      "definition": "export type MetadatumMap = Serialization.MetadatumMap;",
      "isPublic": true,
      "line": 35,
      "raw": "export type MetadatumMap = Serialization.MetadatumMap;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.MetadatumList",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.MetadatumList",
      "name": "MetadatumList",
      "definition": "export type MetadatumList = Serialization.MetadatumList;",
      "isPublic": true,
      "line": 38,
      "raw": "export type MetadatumList = Serialization.MetadatumList;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TransactionUnspentOutput",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TransactionUnspentOutput",
      "name": "TransactionUnspentOutput",
      "definition": "export type TransactionUnspentOutput = Serialization.TransactionUnspentOutput;",
      "isPublic": true,
      "line": 41,
      "raw": "export type TransactionUnspentOutput = Serialization.TransactionUnspentOutput;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TransactionInput",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TransactionInput",
      "name": "TransactionInput",
      "definition": "export type TransactionInput = Serialization.TransactionInput;",
      "isPublic": true,
      "line": 44,
      "raw": "export type TransactionInput = Serialization.TransactionInput;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TransactionOutput",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TransactionOutput",
      "name": "TransactionOutput",
      "definition": "export type TransactionOutput = Serialization.TransactionOutput;",
      "isPublic": true,
      "line": 47,
      "raw": "export type TransactionOutput = Serialization.TransactionOutput;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TransactionInputSet",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TransactionInputSet",
      "name": "TransactionInputSet",
      "definition": "export type TransactionInputSet = Serialization.CborSet<\n  ReturnType<TransactionInput[\"toCore\"]>,\n  TransactionInput\n>;",
      "isPublic": true,
      "line": 49,
      "raw": "export type TransactionInputSet = Serialization.CborSet<",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TransactionWitnessPlutusData",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TransactionWitnessPlutusData",
      "name": "TransactionWitnessPlutusData",
      "definition": "export type TransactionWitnessPlutusData = Set<PlutusData>;",
      "isPublic": true,
      "line": 54,
      "raw": "export type TransactionWitnessPlutusData = Set<PlutusData>;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PlutusData",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PlutusData",
      "name": "PlutusData",
      "definition": "export type PlutusData = Serialization.PlutusData;",
      "isPublic": true,
      "line": 57,
      "raw": "export type PlutusData = Serialization.PlutusData;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PlutusList",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PlutusList",
      "name": "PlutusList",
      "definition": "export type PlutusList = Serialization.PlutusList;",
      "isPublic": true,
      "line": 60,
      "raw": "export type PlutusList = Serialization.PlutusList;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PlutusMap",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PlutusMap",
      "name": "PlutusMap",
      "definition": "export type PlutusMap = Serialization.PlutusMap;",
      "isPublic": true,
      "line": 63,
      "raw": "export type PlutusMap = Serialization.PlutusMap;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Redeemers",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Redeemers",
      "name": "Redeemers",
      "definition": "export type Redeemers = Serialization.Redeemers;",
      "isPublic": true,
      "line": 66,
      "raw": "export type Redeemers = Serialization.Redeemers;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Redeemer",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Redeemer",
      "name": "Redeemer",
      "definition": "export type Redeemer = Serialization.Redeemer;",
      "isPublic": true,
      "line": 69,
      "raw": "export type Redeemer = Serialization.Redeemer;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.RedeemerPurpose",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.RedeemerPurpose",
      "name": "RedeemerPurpose",
      "definition": "export type RedeemerPurpose = Cardano.RedeemerPurpose;",
      "isPublic": true,
      "line": 72,
      "raw": "export type RedeemerPurpose = Cardano.RedeemerPurpose;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.RedeemerTag",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.RedeemerTag",
      "name": "RedeemerTag",
      "definition": "export type RedeemerTag = Serialization.RedeemerTag;",
      "isPublic": true,
      "line": 75,
      "raw": "export type RedeemerTag = Serialization.RedeemerTag;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Script",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Script",
      "name": "Script",
      "definition": "export type Script = Serialization.Script;",
      "isPublic": true,
      "line": 78,
      "raw": "export type Script = Serialization.Script;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PolicyId",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PolicyId",
      "name": "PolicyId",
      "definition": "export type PolicyId = Cardano.PolicyId;",
      "isPublic": true,
      "line": 81,
      "raw": "export type PolicyId = Cardano.PolicyId;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.AssetName",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.AssetName",
      "name": "AssetName",
      "definition": "export type AssetName = Cardano.AssetName;",
      "isPublic": true,
      "line": 84,
      "raw": "export type AssetName = Cardano.AssetName;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.AssetId",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.AssetId",
      "name": "AssetId",
      "definition": "export type AssetId = Cardano.AssetId;",
      "isPublic": true,
      "line": 87,
      "raw": "export type AssetId = Cardano.AssetId;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.ScriptHash",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.ScriptHash",
      "name": "ScriptHash",
      "definition": "export type ScriptHash = Crypto.Hash28ByteBase16;",
      "isPublic": true,
      "line": 90,
      "raw": "export type ScriptHash = Crypto.Hash28ByteBase16;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Address",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Address",
      "name": "Address",
      "definition": "export type Address = Cardano.Address;",
      "isPublic": true,
      "line": 93,
      "raw": "export type Address = Cardano.Address;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.RewardAddress",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.RewardAddress",
      "name": "RewardAddress",
      "definition": "export type RewardAddress = Cardano.RewardAddress;",
      "isPublic": true,
      "line": 96,
      "raw": "export type RewardAddress = Cardano.RewardAddress;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.AddressType",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.AddressType",
      "name": "AddressType",
      "definition": "export type AddressType = Cardano.AddressType;",
      "isPublic": true,
      "line": 99,
      "raw": "export type AddressType = Cardano.AddressType;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.BaseAddress",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.BaseAddress",
      "name": "BaseAddress",
      "definition": "export type BaseAddress = Cardano.BaseAddress;",
      "isPublic": true,
      "line": 102,
      "raw": "export type BaseAddress = Cardano.BaseAddress;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.EnterpriseAddress",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.EnterpriseAddress",
      "name": "EnterpriseAddress",
      "definition": "export type EnterpriseAddress = Cardano.EnterpriseAddress;",
      "isPublic": true,
      "line": 105,
      "raw": "export type EnterpriseAddress = Cardano.EnterpriseAddress;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PaymentAddress",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PaymentAddress",
      "name": "PaymentAddress",
      "definition": "export type PaymentAddress = Cardano.PaymentAddress;",
      "isPublic": true,
      "line": 108,
      "raw": "export type PaymentAddress = Cardano.PaymentAddress;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.AssetFingerprint",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.AssetFingerprint",
      "name": "AssetFingerprint",
      "definition": "export type AssetFingerprint = Cardano.AssetFingerprint;",
      "isPublic": true,
      "line": 111,
      "raw": "export type AssetFingerprint = Cardano.AssetFingerprint;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Credential",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Credential",
      "name": "Credential",
      "definition": "export type Credential = Serialization.Credential;",
      "isPublic": true,
      "line": 114,
      "raw": "export type Credential = Serialization.Credential;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.CredentialCore",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.CredentialCore",
      "name": "CredentialCore",
      "definition": "export type CredentialCore = Cardano.Credential;",
      "isPublic": true,
      "line": 116,
      "raw": "export type CredentialCore = Cardano.Credential;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PublicKeyHex",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PublicKeyHex",
      "name": "Ed25519PublicKeyHex",
      "definition": "export type Ed25519PublicKeyHex = Crypto.Ed25519PublicKeyHex;",
      "isPublic": true,
      "line": 119,
      "raw": "export type Ed25519PublicKeyHex = Crypto.Ed25519PublicKeyHex;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PrivateNormalKeyHex",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PrivateNormalKeyHex",
      "name": "Ed25519PrivateNormalKeyHex",
      "definition": "export type Ed25519PrivateNormalKeyHex = OpaqueString<\"Ed25519PrivateKeyHex\">;",
      "isPublic": true,
      "line": 121,
      "raw": "export type Ed25519PrivateNormalKeyHex = OpaqueString<\"Ed25519PrivateKeyHex\">;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PrivateExtendedKeyHex",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PrivateExtendedKeyHex",
      "name": "Ed25519PrivateExtendedKeyHex",
      "definition": "export type Ed25519PrivateExtendedKeyHex = OpaqueString<\"Ed25519PrivateKeyHex\">;",
      "isPublic": true,
      "line": 126,
      "raw": "export type Ed25519PrivateExtendedKeyHex = OpaqueString<\"Ed25519PrivateKeyHex\">;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Ed25519KeyHash",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Ed25519KeyHash",
      "name": "Ed25519KeyHash",
      "definition": "export type Ed25519KeyHash = Crypto.Ed25519KeyHash;",
      "isPublic": true,
      "line": 132,
      "raw": "export type Ed25519KeyHash = Crypto.Ed25519KeyHash;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Ed25519KeyHashHex",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Ed25519KeyHashHex",
      "name": "Ed25519KeyHashHex",
      "definition": "export type Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;",
      "isPublic": true,
      "line": 135,
      "raw": "export type Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Hash28ByteBase16",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Hash28ByteBase16",
      "name": "Hash28ByteBase16",
      "definition": "export type Hash28ByteBase16 = Crypto.Hash28ByteBase16;",
      "isPublic": true,
      "line": 138,
      "raw": "export type Hash28ByteBase16 = Crypto.Hash28ByteBase16;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Hash32ByteBase16",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Hash32ByteBase16",
      "name": "Hash32ByteBase16",
      "definition": "export type Hash32ByteBase16 = Crypto.Hash32ByteBase16;",
      "isPublic": true,
      "line": 143,
      "raw": "export type Hash32ByteBase16 = Crypto.Hash32ByteBase16;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.CredentialType",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.CredentialType",
      "name": "CredentialType",
      "definition": "export type CredentialType = Cardano.CredentialType;",
      "isPublic": true,
      "line": 146,
      "raw": "export type CredentialType = Cardano.CredentialType;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Certificate",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Certificate",
      "name": "Certificate",
      "definition": "export type Certificate = Serialization.Certificate;",
      "isPublic": true,
      "line": 149,
      "raw": "export type Certificate = Serialization.Certificate;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PoolId",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PoolId",
      "name": "PoolId",
      "definition": "export type PoolId = Cardano.PoolId;",
      "isPublic": true,
      "line": 152,
      "raw": "export type PoolId = Cardano.PoolId;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.StakeRegistration",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.StakeRegistration",
      "name": "StakeRegistration",
      "definition": "export type StakeRegistration = Serialization.StakeRegistration;",
      "isPublic": true,
      "line": 155,
      "raw": "export type StakeRegistration = Serialization.StakeRegistration;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.StakeDelegation",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.StakeDelegation",
      "name": "StakeDelegation",
      "definition": "export type StakeDelegation = Serialization.StakeDelegation;",
      "isPublic": true,
      "line": 158,
      "raw": "export type StakeDelegation = Serialization.StakeDelegation;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.StakeDelegationCertificate",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.StakeDelegationCertificate",
      "name": "StakeDelegationCertificate",
      "definition": "export type StakeDelegationCertificate = Cardano.StakeDelegationCertificate;",
      "isPublic": true,
      "line": 160,
      "raw": "export type StakeDelegationCertificate = Cardano.StakeDelegationCertificate;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.CertificateType",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.CertificateType",
      "name": "CertificateType",
      "definition": "export type CertificateType = Cardano.CertificateType;",
      "isPublic": true,
      "line": 163,
      "raw": "export type CertificateType = Cardano.CertificateType;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.VkeyWitness",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.VkeyWitness",
      "name": "VkeyWitness",
      "definition": "export type VkeyWitness = Serialization.VkeyWitness;",
      "isPublic": true,
      "line": 166,
      "raw": "export type VkeyWitness = Serialization.VkeyWitness;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Ed25519SignatureHex",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Ed25519SignatureHex",
      "name": "Ed25519SignatureHex",
      "definition": "export type Ed25519SignatureHex = Crypto.Ed25519SignatureHex;",
      "isPublic": true,
      "line": 169,
      "raw": "export type Ed25519SignatureHex = Crypto.Ed25519SignatureHex;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PublicKey",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PublicKey",
      "name": "Ed25519PublicKey",
      "definition": "export type Ed25519PublicKey = Crypto.Ed25519PublicKey;",
      "isPublic": true,
      "line": 172,
      "raw": "export type Ed25519PublicKey = Crypto.Ed25519PublicKey;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Ed25519Signature",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Ed25519Signature",
      "name": "Ed25519Signature",
      "definition": "export type Ed25519Signature = Crypto.Ed25519Signature;",
      "isPublic": true,
      "line": 175,
      "raw": "export type Ed25519Signature = Crypto.Ed25519Signature;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Bip32PrivateKey",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Bip32PrivateKey",
      "name": "Bip32PrivateKey",
      "definition": "export type Bip32PrivateKey = Crypto.Bip32PrivateKey;",
      "isPublic": true,
      "line": 178,
      "raw": "export type Bip32PrivateKey = Crypto.Bip32PrivateKey;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Bip32PrivateKeyHex",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Bip32PrivateKeyHex",
      "name": "Bip32PrivateKeyHex",
      "definition": "export type Bip32PrivateKeyHex = Crypto.Bip32PrivateKeyHex;",
      "isPublic": true,
      "line": 181,
      "raw": "export type Bip32PrivateKeyHex = Crypto.Bip32PrivateKeyHex;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Bip32PublicKey",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Bip32PublicKey",
      "name": "Bip32PublicKey",
      "definition": "export type Bip32PublicKey = Crypto.Bip32PublicKey;",
      "isPublic": true,
      "line": 184,
      "raw": "export type Bip32PublicKey = Crypto.Bip32PublicKey;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Bip32PublicKeyHex",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Bip32PublicKeyHex",
      "name": "Bip32PublicKeyHex",
      "definition": "export type Bip32PublicKeyHex = Crypto.Bip32PublicKeyHex;",
      "isPublic": true,
      "line": 187,
      "raw": "export type Bip32PublicKeyHex = Crypto.Bip32PublicKeyHex;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PlutusLanguageVersion",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PlutusLanguageVersion",
      "name": "PlutusLanguageVersion",
      "definition": "export type PlutusLanguageVersion = Cardano.PlutusLanguageVersion;",
      "isPublic": true,
      "line": 190,
      "raw": "export type PlutusLanguageVersion = Cardano.PlutusLanguageVersion;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.NativeScript",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.NativeScript",
      "name": "NativeScript",
      "definition": "export type NativeScript = Serialization.NativeScript;",
      "isPublic": true,
      "line": 193,
      "raw": "export type NativeScript = Serialization.NativeScript;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PlutusV1Script",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PlutusV1Script",
      "name": "PlutusV1Script",
      "definition": "export type PlutusV1Script = Serialization.PlutusV1Script;",
      "isPublic": true,
      "line": 196,
      "raw": "export type PlutusV1Script = Serialization.PlutusV1Script;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PlutusV2Script",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PlutusV2Script",
      "name": "PlutusV2Script",
      "definition": "export type PlutusV2Script = Serialization.PlutusV2Script;",
      "isPublic": true,
      "line": 199,
      "raw": "export type PlutusV2Script = Serialization.PlutusV2Script;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PlutusV3Script",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PlutusV3Script",
      "name": "PlutusV3Script",
      "definition": "export type PlutusV3Script = Serialization.PlutusV3Script;",
      "isPublic": true,
      "line": 202,
      "raw": "export type PlutusV3Script = Serialization.PlutusV3Script;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PlutusDataKind",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PlutusDataKind",
      "name": "PlutusDataKind",
      "definition": "export type PlutusDataKind = Serialization.PlutusDataKind;",
      "isPublic": true,
      "line": 205,
      "raw": "export type PlutusDataKind = Serialization.PlutusDataKind;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PointerAddress",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PointerAddress",
      "name": "PointerAddress",
      "definition": "export type PointerAddress = Cardano.PointerAddress;",
      "isPublic": true,
      "line": 208,
      "raw": "export type PointerAddress = Cardano.PointerAddress;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.CertIndex",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.CertIndex",
      "name": "CertIndex",
      "definition": "export type CertIndex = Cardano.CertIndex;",
      "isPublic": true,
      "line": 211,
      "raw": "export type CertIndex = Cardano.CertIndex;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TxIndex",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TxIndex",
      "name": "TxIndex",
      "definition": "export type TxIndex = Cardano.TxIndex;",
      "isPublic": true,
      "line": 214,
      "raw": "export type TxIndex = Cardano.TxIndex;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Costmdls",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Costmdls",
      "name": "Costmdls",
      "definition": "export type Costmdls = Serialization.Costmdls;",
      "isPublic": true,
      "line": 217,
      "raw": "export type Costmdls = Serialization.Costmdls;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.CostModel",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.CostModel",
      "name": "CostModel",
      "definition": "export type CostModel = Serialization.CostModel;",
      "isPublic": true,
      "line": 220,
      "raw": "export type CostModel = Serialization.CostModel;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.CborWriter",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.CborWriter",
      "name": "CborWriter",
      "definition": "export type CborWriter = Serialization.CborWriter;",
      "isPublic": true,
      "line": 223,
      "raw": "export type CborWriter = Serialization.CborWriter;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.ConstrPlutusData",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.ConstrPlutusData",
      "name": "ConstrPlutusData",
      "definition": "export type ConstrPlutusData = Serialization.ConstrPlutusData;",
      "isPublic": true,
      "line": 226,
      "raw": "export type ConstrPlutusData = Serialization.ConstrPlutusData;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.RewardAccount",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.RewardAccount",
      "name": "RewardAccount",
      "definition": "export type RewardAccount = Cardano.RewardAccount;",
      "isPublic": true,
      "line": 229,
      "raw": "export type RewardAccount = Cardano.RewardAccount;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.DatumHash",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.DatumHash",
      "name": "DatumHash",
      "definition": "export type DatumHash = Crypto.Hash32ByteBase16;",
      "isPublic": true,
      "line": 237,
      "raw": "export type DatumHash = Crypto.Hash32ByteBase16;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Datum",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Datum",
      "name": "Datum",
      "definition": "export type Datum = PlutusData | DatumHash;",
      "isPublic": true,
      "line": 240,
      "raw": "export type Datum = PlutusData | DatumHash;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.CostModels",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.CostModels",
      "name": "CostModels",
      "definition": "export type CostModels = Cardano.CostModels;",
      "isPublic": true,
      "line": 242,
      "raw": "export type CostModels = Cardano.CostModels;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.ExUnits",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.ExUnits",
      "name": "ExUnits",
      "definition": "export type ExUnits = Serialization.ExUnits;",
      "isPublic": true,
      "line": 244,
      "raw": "export type ExUnits = Serialization.ExUnits;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.NetworkId",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.NetworkId",
      "name": "NetworkId",
      "definition": "export type NetworkId = Cardano.ChainId[\"networkId\"];",
      "isPublic": true,
      "line": 248,
      "raw": "export type NetworkId = Cardano.ChainId[\"networkId\"];",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Witness",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Witness",
      "name": "Witness",
      "definition": "export type Witness = Cardano.Witness;",
      "isPublic": true,
      "line": 254,
      "raw": "export type Witness = Cardano.Witness;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Signatures",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Signatures",
      "name": "Signatures",
      "definition": "export type Signatures = Cardano.Signatures;",
      "isPublic": true,
      "line": 255,
      "raw": "export type Signatures = Cardano.Signatures;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.RequireAllOf",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.RequireAllOf",
      "name": "RequireAllOf",
      "definition": "export type RequireAllOf = Cardano.NativeScriptKind.RequireAllOf;",
      "isPublic": true,
      "line": 257,
      "raw": "export type RequireAllOf = Cardano.NativeScriptKind.RequireAllOf;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.RequireAnyOf",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.RequireAnyOf",
      "name": "RequireAnyOf",
      "definition": "export type RequireAnyOf = Cardano.NativeScriptKind.RequireAnyOf;",
      "isPublic": true,
      "line": 260,
      "raw": "export type RequireAnyOf = Cardano.NativeScriptKind.RequireAnyOf;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.RequireNOf",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.RequireNOf",
      "name": "RequireNOf",
      "definition": "export type RequireNOf = Cardano.NativeScriptKind.RequireNOf;",
      "isPublic": true,
      "line": 263,
      "raw": "export type RequireNOf = Cardano.NativeScriptKind.RequireNOf;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.RequireSignature",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.RequireSignature",
      "name": "RequireSignature",
      "definition": "export type RequireSignature = Cardano.NativeScriptKind.RequireSignature;",
      "isPublic": true,
      "line": 266,
      "raw": "export type RequireSignature = Cardano.NativeScriptKind.RequireSignature;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.RequireTimeAfter",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.RequireTimeAfter",
      "name": "RequireTimeAfter",
      "definition": "export type RequireTimeAfter = Cardano.NativeScriptKind.RequireTimeAfter;",
      "isPublic": true,
      "line": 269,
      "raw": "export type RequireTimeAfter = Cardano.NativeScriptKind.RequireTimeAfter;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.RequireTimeBefore",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.RequireTimeBefore",
      "name": "RequireTimeBefore",
      "definition": "export type RequireTimeBefore = Cardano.NativeScriptKind.RequireTimeBefore;",
      "isPublic": true,
      "line": 272,
      "raw": "export type RequireTimeBefore = Cardano.NativeScriptKind.RequireTimeBefore;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.VrfVkBech32",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.VrfVkBech32",
      "name": "VrfVkBech32",
      "definition": "export type VrfVkBech32 = Cardano.VrfVkBech32;",
      "isPublic": true,
      "line": 275,
      "raw": "export type VrfVkBech32 = Cardano.VrfVkBech32;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.ScriptPubkey",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.ScriptPubkey",
      "name": "ScriptPubkey",
      "definition": "export type ScriptPubkey = Serialization.ScriptPubkey;",
      "isPublic": true,
      "line": 278,
      "raw": "export type ScriptPubkey = Serialization.ScriptPubkey;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.DRepID",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.DRepID",
      "name": "DRepID",
      "definition": "export type DRepID = Cardano.DRepID;",
      "isPublic": true,
      "line": 281,
      "raw": "export type DRepID = Cardano.DRepID;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.DRep",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.DRep",
      "name": "DRep",
      "definition": "export type DRep = Serialization.DRep;",
      "isPublic": true,
      "line": 284,
      "raw": "export type DRep = Serialization.DRep;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.StakeCredentialStatus",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.StakeCredentialStatus",
      "name": "StakeCredentialStatus",
      "definition": "export type StakeCredentialStatus = Cardano.StakeCredentialStatus;",
      "isPublic": true,
      "line": 287,
      "raw": "export type StakeCredentialStatus = Cardano.StakeCredentialStatus;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Metadatum",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Metadatum",
      "name": "Metadatum",
      "definition": "export type Metadatum = Cardano.Metadatum;",
      "isPublic": true,
      "line": 290,
      "raw": "export type Metadatum = Cardano.Metadatum;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.HexBlob",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.HexBlob",
      "name": "HexBlob",
      "definition": "export type HexBlob = CardanoHexBlob;",
      "isPublic": true,
      "line": 292,
      "raw": "export type HexBlob = CardanoHexBlob;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TxCBOR",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TxCBOR",
      "name": "TxCBOR",
      "definition": "export type TxCBOR = Serialization.TxCBOR;",
      "isPublic": true,
      "line": 295,
      "raw": "export type TxCBOR = Serialization.TxCBOR;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PrivateKey",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PrivateKey",
      "name": "Ed25519PrivateKey",
      "definition": "export type Ed25519PrivateKey = Crypto.Ed25519PrivateKey;",
      "isPublic": true,
      "line": 298,
      "raw": "export type Ed25519PrivateKey = Crypto.Ed25519PrivateKey;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.BootstrapWitness",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.BootstrapWitness",
      "name": "BootstrapWitness",
      "definition": "export type BootstrapWitness = Serialization.BootstrapWitness;",
      "isPublic": true,
      "line": 304,
      "raw": "export type BootstrapWitness = Serialization.BootstrapWitness;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.ByronAttributes",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.ByronAttributes",
      "name": "ByronAttributes",
      "definition": "export type ByronAttributes = Cardano.ByronAttributes;",
      "isPublic": true,
      "line": 307,
      "raw": "export type ByronAttributes = Cardano.ByronAttributes;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.signer.ts.Signer",
      "fullName": "mesh-core-cst:types.signer.ts.Signer",
      "name": "Signer",
      "definition": "export type Signer = {\n  address: Address;\n  key: Ed25519PrivateKey;",
      "isPublic": true,
      "line": 4,
      "raw": "export type Signer = {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.ConstrPlutusDataJson",
      "fullName": "mesh-core-cst:utils.data.ts.ConstrPlutusDataJson",
      "name": "ConstrPlutusDataJson",
      "definition": "type ConstrPlutusDataJson = {\n  constructor: number | bigint | string;\n  fields: object[];",
      "isPublic": true,
      "line": 51,
      "raw": "type ConstrPlutusDataJson = {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.KeyValuePlutusDataJson",
      "fullName": "mesh-core-cst:utils.data.ts.KeyValuePlutusDataJson",
      "name": "KeyValuePlutusDataJson",
      "definition": "type KeyValuePlutusDataJson = {\n  k: object;\n  v: object;",
      "isPublic": true,
      "line": 68,
      "raw": "type KeyValuePlutusDataJson = {",
      "source": "mesh-core-cst"
    },
    {
      "key": "bitcoin:interfaces.provider.ts.IBitcoinProvider",
      "fullName": "bitcoin:interfaces.provider.ts.IBitcoinProvider",
      "name": "IBitcoinProvider",
      "definition": "export interface IBitcoinProvider {\n  fetchAddress(address: string): Promise<AddressInfo>;",
      "isPublic": true,
      "line": 7,
      "raw": "export interface IBitcoinProvider {",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:interfaces.wallet.ts.IBitcoinWallet",
      "fullName": "bitcoin:interfaces.wallet.ts.IBitcoinWallet",
      "name": "IBitcoinWallet",
      "definition": "export interface IBitcoinWallet {\n  getChangeAddress(): Promise<string>;",
      "isPublic": true,
      "line": 1,
      "raw": "export interface IBitcoinWallet {",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:types.address-info.ts.AddressInfo",
      "fullName": "bitcoin:types.address-info.ts.AddressInfo",
      "name": "AddressInfo",
      "definition": "export type AddressInfo = {\n  address: string;\n  chain_stats: ChainStats;",
      "isPublic": true,
      "line": 4,
      "raw": "export type AddressInfo = {",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:types.address.ts.Address",
      "fullName": "bitcoin:types.address.ts.Address",
      "name": "Address",
      "definition": "export type Address = {\n  address: string;\n  publicKey?: string;",
      "isPublic": true,
      "line": 1,
      "raw": "export type Address = {",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:types.chain-stats.ts.ChainStats",
      "fullName": "bitcoin:types.chain-stats.ts.ChainStats",
      "name": "ChainStats",
      "definition": "export type ChainStats = {\n  funded_txo_count: number;\n  funded_txo_sum: number;",
      "isPublic": true,
      "line": 1,
      "raw": "export type ChainStats = {",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:types.mempool-stats.ts.MempoolStats",
      "fullName": "bitcoin:types.mempool-stats.ts.MempoolStats",
      "name": "MempoolStats",
      "definition": "export type MempoolStats = {\n  funded_txo_count: number;\n  funded_txo_sum: number;",
      "isPublic": true,
      "line": 1,
      "raw": "export type MempoolStats = {",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:types.script-info.ts.ScriptInfo",
      "fullName": "bitcoin:types.script-info.ts.ScriptInfo",
      "name": "ScriptInfo",
      "definition": "export type ScriptInfo = {\n  scripthash: string;\n  chain_stats: ChainStats;",
      "isPublic": true,
      "line": 4,
      "raw": "export type ScriptInfo = {",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:types.transactions-info.ts.TransactionsInfo",
      "fullName": "bitcoin:types.transactions-info.ts.TransactionsInfo",
      "name": "TransactionsInfo",
      "definition": "export type TransactionsInfo = {\n  txid: string;\n  version: number;",
      "isPublic": true,
      "line": 3,
      "raw": "export type TransactionsInfo = {",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:types.transactions-status.ts.TransactionsStatus",
      "fullName": "bitcoin:types.transactions-status.ts.TransactionsStatus",
      "name": "TransactionsStatus",
      "definition": "export type TransactionsStatus = {\n  confirmed: boolean;\n  block_height: number;",
      "isPublic": true,
      "line": 1,
      "raw": "export type TransactionsStatus = {",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:types.utxo.ts.UTxO",
      "fullName": "bitcoin:types.utxo.ts.UTxO",
      "name": "UTxO",
      "definition": "export type UTxO = {\n  status: {\n    block_hash: string;\n    block_height: number;\n    block_time: number;",
      "isPublic": true,
      "line": 1,
      "raw": "export type UTxO = {",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.CreateWalletOptions",
      "fullName": "bitcoin:wallets.embedded.index.ts.CreateWalletOptions",
      "name": "CreateWalletOptions",
      "definition": "export type CreateWalletOptions = {\n  testnet: boolean;\n  key:\n    | {\n        type: \"mnemonic\";\n        words: string[];",
      "isPublic": true,
      "line": 10,
      "raw": "export type CreateWalletOptions = {",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.TransactionPayload",
      "fullName": "bitcoin:wallets.embedded.index.ts.TransactionPayload",
      "name": "TransactionPayload",
      "definition": "export type TransactionPayload = {\n  inputs: {\n    txid: string;\n    vout: number;\n    value: number;",
      "isPublic": true,
      "line": 25,
      "raw": "export type TransactionPayload = {",
      "source": "bitcoin"
    }
  ],
  "privateTypes": [],
  "constants": [
    {
      "key": "mesh-contract:common.ts.signedTx",
      "fullName": "mesh-contract:common.ts.signedTx",
      "name": "signedTx",
      "type": "any",
      "value": "this.mesh.completeSigning();",
      "isPublic": true,
      "line": 79,
      "raw": "const signedTx = this.mesh.completeSigning();",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:common.ts.txHash",
      "fullName": "mesh-contract:common.ts.txHash",
      "name": "txHash",
      "type": "any",
      "value": "await this.mesh.submitTx(signedTx);",
      "isPublic": true,
      "line": 80,
      "raw": "const txHash = await this.mesh.submitTx(signedTx);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:common.ts.utxos",
      "fullName": "mesh-contract:common.ts.utxos",
      "name": "utxos",
      "type": "any",
      "value": "await this.fetcher?.fetchUTxOs(txHash);",
      "isPublic": true,
      "line": 202,
      "raw": "const utxos = await this.fetcher?.fetchUTxOs(txHash);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:common.ts.usedAddresses",
      "fullName": "mesh-contract:common.ts.usedAddresses",
      "name": "usedAddresses",
      "type": "any",
      "value": "await this.wallet.getUsedAddresses();",
      "isPublic": true,
      "line": 95,
      "raw": "const usedAddresses = await this.wallet.getUsedAddresses();",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:common.ts.unusedAddresses",
      "fullName": "mesh-contract:common.ts.unusedAddresses",
      "name": "unusedAddresses",
      "type": "any",
      "value": "await this.wallet.getUnusedAddresses();",
      "isPublic": true,
      "line": 99,
      "raw": "const unusedAddresses = await this.wallet.getUnusedAddresses();",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:common.ts.lovelaceAmount",
      "fullName": "mesh-contract:common.ts.lovelaceAmount",
      "name": "lovelaceAmount",
      "type": "any",
      "value": "u.output.amount.find(",
      "isPublic": true,
      "line": 157,
      "raw": "const lovelaceAmount = u.output.amount.find(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:common.ts.assetAmount",
      "fullName": "mesh-contract:common.ts.assetAmount",
      "name": "assetAmount",
      "type": "any",
      "value": "u.output.amount.find(",
      "isPublic": true,
      "line": 174,
      "raw": "const assetAmount = u.output.amount.find(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:common.ts.collateral",
      "fullName": "mesh-contract:common.ts.collateral",
      "name": "collateral",
      "type": "any",
      "value": "await this.getWalletCollateral();",
      "isPublic": true,
      "line": 183,
      "raw": "const collateral = await this.getWalletCollateral();",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:common.ts.walletAddress",
      "fullName": "mesh-contract:common.ts.walletAddress",
      "name": "walletAddress",
      "type": "any",
      "value": "await this.getWalletDappAddress();",
      "isPublic": true,
      "line": 184,
      "raw": "const walletAddress = await this.getWalletDappAddress();",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:common.ts.scriptAddr",
      "fullName": "mesh-contract:common.ts.scriptAddr",
      "name": "scriptAddr",
      "type": "any",
      "value": "serializePlutusScript(",
      "isPublic": true,
      "line": 206,
      "raw": "const scriptAddr = serializePlutusScript(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.common.ts.getScriptCbor",
      "fullName": "mesh-contract:content-ownership.offchain.common.ts.getScriptCbor",
      "name": "getScriptCbor",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 24,
      "raw": "export const getScriptCbor = (",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.common.ts.validators",
      "fullName": "mesh-contract:content-ownership.offchain.common.ts.validators",
      "name": "validators",
      "type": "any",
      "value": "blueprint.validators;",
      "isPublic": true,
      "line": 28,
      "raw": "const validators = blueprint.validators;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.common.ts.oracleNFTCbor",
      "fullName": "mesh-contract:content-ownership.offchain.common.ts.oracleNFTCbor",
      "name": "oracleNFTCbor",
      "type": "any",
      "value": "applyParamsToScript(",
      "isPublic": true,
      "line": 29,
      "raw": "const oracleNFTCbor = applyParamsToScript(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.common.ts.oracleNFTToParam",
      "fullName": "mesh-contract:content-ownership.offchain.common.ts.oracleNFTToParam",
      "name": "oracleNFTToParam",
      "type": "any",
      "value": "builtinByteString(",
      "isPublic": true,
      "line": 34,
      "raw": "const oracleNFTToParam = builtinByteString(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.common.ts.getScriptHash",
      "fullName": "mesh-contract:content-ownership.offchain.common.ts.getScriptHash",
      "name": "getScriptHash",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 69,
      "raw": "export const getScriptHash = (",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.common.ts.scriptCbor",
      "fullName": "mesh-contract:content-ownership.offchain.common.ts.scriptCbor",
      "name": "scriptCbor",
      "type": "any",
      "value": "getScriptCbor(oracleParamUtxo, scriptIndex);",
      "isPublic": true,
      "line": 73,
      "raw": "const scriptCbor = getScriptCbor(oracleParamUtxo, scriptIndex);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.common.ts.getScriptInfo",
      "fullName": "mesh-contract:content-ownership.offchain.common.ts.getScriptInfo",
      "name": "getScriptInfo",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 77,
      "raw": "export const getScriptInfo = (",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.common.ts.info",
      "fullName": "mesh-contract:content-ownership.offchain.common.ts.info",
      "name": "info",
      "type": "any",
      "value": "{",
      "isPublic": true,
      "line": 82,
      "raw": "const info = {",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.common.ts.oracleAddress",
      "fullName": "mesh-contract:content-ownership.offchain.common.ts.oracleAddress",
      "name": "oracleAddress",
      "type": "any",
      "value": "serializePlutusScript(",
      "isPublic": true,
      "line": 112,
      "raw": "const oracleAddress = serializePlutusScript(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.common.ts.contentRegistryAddress",
      "fullName": "mesh-contract:content-ownership.offchain.common.ts.contentRegistryAddress",
      "name": "contentRegistryAddress",
      "type": "any",
      "value": "serializePlutusScript(",
      "isPublic": true,
      "line": 117,
      "raw": "const contentRegistryAddress = serializePlutusScript(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.common.ts.ownershipRegistryAddress",
      "fullName": "mesh-contract:content-ownership.offchain.common.ts.ownershipRegistryAddress",
      "name": "ownershipRegistryAddress",
      "type": "any",
      "value": "serializePlutusScript(",
      "isPublic": true,
      "line": 122,
      "raw": "const ownershipRegistryAddress = serializePlutusScript(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.serializedOpsPlutusAddr",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.serializedOpsPlutusAddr",
      "name": "serializedOpsPlutusAddr",
      "type": "any",
      "value": "deserializeAddress(this.operationAddress);",
      "isPublic": true,
      "line": 131,
      "raw": "const serializedOpsPlutusAddr = deserializeAddress(this.operationAddress);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.nativeScript",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.nativeScript",
      "name": "nativeScript",
      "type": "NativeScript",
      "value": "{",
      "isPublic": true,
      "line": 509,
      "raw": "const nativeScript: NativeScript = {",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.paramUtxo",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.paramUtxo",
      "name": "paramUtxo",
      "type": "any",
      "value": "utxos[0]!;",
      "isPublic": true,
      "line": 183,
      "raw": "const paramUtxo = utxos[0]!;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.script",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.script",
      "name": "script",
      "type": "any",
      "value": "blueprint.validators[4]!.compiledCode;",
      "isPublic": true,
      "line": 184,
      "raw": "const script = blueprint.validators[4]!.compiledCode;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.param",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.param",
      "name": "param",
      "type": "Data",
      "value": "mOutputReference(",
      "isPublic": true,
      "line": 185,
      "raw": "const param: Data = mOutputReference(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.paramScript",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.paramScript",
      "name": "paramScript",
      "type": "any",
      "value": "applyParamsToScript(script, [param]);",
      "isPublic": true,
      "line": 189,
      "raw": "const paramScript = applyParamsToScript(script, [param]);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.policyId",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.policyId",
      "name": "policyId",
      "type": "any",
      "value": "resolveScriptHash(forgingScript);",
      "isPublic": true,
      "line": 521,
      "raw": "const policyId = resolveScriptHash(forgingScript);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.tokenName",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.tokenName",
      "name": "tokenName",
      "type": "any",
      "value": "\"\";",
      "isPublic": true,
      "line": 191,
      "raw": "const tokenName = \"\";",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.txHex",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.txHex",
      "name": "txHex",
      "type": "any",
      "value": "await this.mesh",
      "isPublic": true,
      "line": 906,
      "raw": "const txHex = await this.mesh",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.datumValue",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.datumValue",
      "name": "datumValue",
      "type": "any",
      "value": "this.getOracleDatum(0, 0);",
      "isPublic": true,
      "line": 245,
      "raw": "const datumValue = this.getOracleDatum(0, 0);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.scriptUtxo",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.scriptUtxo",
      "name": "scriptUtxo",
      "type": "any",
      "value": "await this.fetcher!.fetchAddressUTxOs(",
      "isPublic": true,
      "line": 472,
      "raw": "const scriptUtxo = await this.fetcher!.fetchAddressUTxOs(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.currentOracleDatum",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.currentOracleDatum",
      "name": "currentOracleDatum",
      "type": "any",
      "value": "await this.getCurrentOracleDatum(scriptUtxo);",
      "isPublic": true,
      "line": 476,
      "raw": "const currentOracleDatum = await this.getCurrentOracleDatum(scriptUtxo);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.contentNumber",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.contentNumber",
      "name": "contentNumber",
      "type": "any",
      "value": "currentOracleDatum.fields[4].int as number;",
      "isPublic": true,
      "line": 478,
      "raw": "const contentNumber = currentOracleDatum.fields[4].int as number;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.ownershipNumber",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.ownershipNumber",
      "name": "ownershipNumber",
      "type": "any",
      "value": "currentOracleDatum.fields[7].int as number;",
      "isPublic": true,
      "line": 479,
      "raw": "const ownershipNumber = currentOracleDatum.fields[7].int as number;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.contentTokenName",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.contentTokenName",
      "name": "contentTokenName",
      "type": "any",
      "value": "stringToHex(`Registry (${contentNumber})`);",
      "isPublic": true,
      "line": 327,
      "raw": "const contentTokenName = stringToHex(`Registry (${contentNumber})`);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.oracleDatumValue",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.oracleDatumValue",
      "name": "oracleDatumValue",
      "type": "any",
      "value": "this.getOracleDatum(",
      "isPublic": true,
      "line": 413,
      "raw": "const oracleDatumValue = this.getOracleDatum(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.ownershipTokenName",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.ownershipTokenName",
      "name": "ownershipTokenName",
      "type": "any",
      "value": "stringToHex(`Registry (${ownershipNumber})`);",
      "isPublic": true,
      "line": 408,
      "raw": "const ownershipTokenName = stringToHex(`Registry (${ownershipNumber})`);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.forgingScript",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.forgingScript",
      "name": "forgingScript",
      "type": "any",
      "value": "ForgeScript.fromNativeScript(nativeScript);",
      "isPublic": true,
      "line": 519,
      "raw": "const forgingScript = ForgeScript.fromNativeScript(nativeScript);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.tokenNameHex",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.tokenNameHex",
      "name": "tokenNameHex",
      "type": "any",
      "value": "stringToHex(tokenName);",
      "isPublic": true,
      "line": 522,
      "raw": "const tokenNameHex = stringToHex(tokenName);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.metadata",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.metadata",
      "name": "metadata",
      "type": "any",
      "value": "{ [policyId]: { [tokenName]: { ...tokenMetadata } } };",
      "isPublic": true,
      "line": 523,
      "raw": "const metadata = { [policyId]: { [tokenName]: { ...tokenMetadata } } };",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.registryName",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.registryName",
      "name": "registryName",
      "type": "any",
      "value": "stringToHex(`Registry (${registryNumber})`);",
      "isPublic": true,
      "line": 550,
      "raw": "const registryName = stringToHex(`Registry (${registryNumber})`);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.oracleUtxo",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.oracleUtxo",
      "name": "oracleUtxo",
      "type": "any",
      "value": "await this.fetcher!.fetchAddressUTxOs(",
      "isPublic": true,
      "line": 900,
      "raw": "const oracleUtxo = await this.fetcher!.fetchAddressUTxOs(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.contentUtxo",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.contentUtxo",
      "name": "contentUtxo",
      "type": "UTxO[]",
      "value": "await this.fetcher!.fetchAddressUTxOs(",
      "isPublic": true,
      "line": 555,
      "raw": "const contentUtxo: UTxO[] = await this.fetcher!.fetchAddressUTxOs(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.ownershipUtxo",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.ownershipUtxo",
      "name": "ownershipUtxo",
      "type": "UTxO[]",
      "value": "await this.fetcher!.fetchAddressUTxOs(",
      "isPublic": true,
      "line": 559,
      "raw": "const ownershipUtxo: UTxO[] = await this.fetcher!.fetchAddressUTxOs(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.ownerAssetClass",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.ownerAssetClass",
      "name": "ownerAssetClass",
      "type": "[string, string]",
      "value": "[",
      "isPublic": true,
      "line": 574,
      "raw": "const ownerAssetClass: [string, string] = [",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.newContentRegistry",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.newContentRegistry",
      "name": "newContentRegistry",
      "type": "any",
      "value": "this.getOwnershipDatum(ownershipRegistry);",
      "isPublic": true,
      "line": 1084,
      "raw": "const newContentRegistry = this.getOwnershipDatum(ownershipRegistry);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.newOwnershipRegistry",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.newOwnershipRegistry",
      "name": "newOwnershipRegistry",
      "type": "any",
      "value": "this.updateOwnershipRegistry(",
      "isPublic": true,
      "line": 747,
      "raw": "const newOwnershipRegistry = this.updateOwnershipRegistry(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.contentDatam",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.contentDatam",
      "name": "contentDatam",
      "type": "ContentRegistryDatum",
      "value": "parseDatumCbor(",
      "isPublic": true,
      "line": 652,
      "raw": "const contentDatam: ContentRegistryDatum = parseDatumCbor(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.contentAtRegistry",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.contentAtRegistry",
      "name": "contentAtRegistry",
      "type": "any",
      "value": "contentDatam.fields[1].list;",
      "isPublic": true,
      "line": 656,
      "raw": "const contentAtRegistry = contentDatam.fields[1].list;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.decoded",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.decoded",
      "name": "decoded",
      "type": "any",
      "value": "toUTF8(contentAtRegistry[contentNumber]?.bytes!);",
      "isPublic": true,
      "line": 661,
      "raw": "const decoded = toUTF8(contentAtRegistry[contentNumber]?.bytes!);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.registryTokenNameHex",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.registryTokenNameHex",
      "name": "registryTokenNameHex",
      "type": "any",
      "value": "stringToHex(`Registry (${registryNumber})`);",
      "isPublic": true,
      "line": 995,
      "raw": "const registryTokenNameHex = stringToHex(`Registry (${registryNumber})`);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.txBody",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.txBody",
      "name": "txBody",
      "type": "any",
      "value": "this.mesh.completeSigning();",
      "isPublic": true,
      "line": 792,
      "raw": "const txBody = this.mesh.completeSigning();",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.newOwnerAssetClass",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.newOwnerAssetClass",
      "name": "newOwnerAssetClass",
      "type": "[string, string]",
      "value": "[",
      "isPublic": true,
      "line": 743,
      "raw": "const newOwnerAssetClass: [string, string] = [",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.scriptUtxos",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.scriptUtxos",
      "name": "scriptUtxos",
      "type": "any",
      "value": "await this.fetcher!.fetchAddressUTxOs(",
      "isPublic": true,
      "line": 851,
      "raw": "const scriptUtxos = await this.fetcher!.fetchAddressUTxOs(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.oracleDatum",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.oracleDatum",
      "name": "oracleDatum",
      "type": "any",
      "value": "parseInlineDatum<any, OracleDatum>({",
      "isPublic": true,
      "line": 942,
      "raw": "const oracleDatum = parseInlineDatum<any, OracleDatum>({",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.oracleAddr",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.oracleAddr",
      "name": "oracleAddr",
      "type": "any",
      "value": "mScriptAddress(",
      "isPublic": true,
      "line": 952,
      "raw": "const oracleAddr = mScriptAddress(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.contentRegistryAddr",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.contentRegistryAddr",
      "name": "contentRegistryAddr",
      "type": "any",
      "value": "mScriptAddress(",
      "isPublic": true,
      "line": 956,
      "raw": "const contentRegistryAddr = mScriptAddress(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.ownershipRegistryAddr",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.ownershipRegistryAddr",
      "name": "ownershipRegistryAddr",
      "type": "any",
      "value": "mScriptAddress(",
      "isPublic": true,
      "line": 960,
      "raw": "const ownershipRegistryAddr = mScriptAddress(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.promises",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.promises",
      "name": "promises",
      "type": "Promise<UTxO[]>[]",
      "value": "[];",
      "isPublic": true,
      "line": 996,
      "raw": "const promises: Promise<UTxO[]>[] = [];",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.scriptsInput",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.scriptsInput",
      "name": "scriptsInput",
      "type": "any",
      "value": "await Promise.all(promises);",
      "isPublic": true,
      "line": 1024,
      "raw": "const scriptsInput = await Promise.all(promises);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.contentRegistry",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.contentRegistry",
      "name": "contentRegistry",
      "type": "any",
      "value": "parseInlineDatum<any, ContentRegistryDatum>({",
      "isPublic": true,
      "line": 1064,
      "raw": "const contentRegistry = parseInlineDatum<any, ContentRegistryDatum>({",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:content-ownership.offchain.offchain.ts.ownershipRegistry",
      "fullName": "mesh-contract:content-ownership.offchain.offchain.ts.ownershipRegistry",
      "name": "ownershipRegistry",
      "type": "any",
      "value": "parseInlineDatum<any, OwnershipRegistryDatum>({",
      "isPublic": true,
      "line": 1077,
      "raw": "const ownershipRegistry = parseInlineDatum<any, OwnershipRegistryDatum>({",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:escrow.offchain.ts.initiateEscrowDatum",
      "fullName": "mesh-contract:escrow.offchain.ts.initiateEscrowDatum",
      "name": "initiateEscrowDatum",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 31,
      "raw": "export const initiateEscrowDatum = (",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:escrow.offchain.ts.activeEscrowDatum",
      "fullName": "mesh-contract:escrow.offchain.ts.activeEscrowDatum",
      "name": "activeEscrowDatum",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 45,
      "raw": "export const activeEscrowDatum = (",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:escrow.offchain.ts.recipientDepositRedeemer",
      "fullName": "mesh-contract:escrow.offchain.ts.recipientDepositRedeemer",
      "name": "recipientDepositRedeemer",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 61,
      "raw": "export const recipientDepositRedeemer = (",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:escrow.offchain.ts.inputDatum",
      "fullName": "mesh-contract:escrow.offchain.ts.inputDatum",
      "name": "inputDatum",
      "type": "any",
      "value": "deserializeDatum<ActiveEscrowDatum>(",
      "isPublic": true,
      "line": 212,
      "raw": "const inputDatum = deserializeDatum<ActiveEscrowDatum>(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:escrow.offchain.ts.initiatorAddress",
      "fullName": "mesh-contract:escrow.offchain.ts.initiatorAddress",
      "name": "initiatorAddress",
      "type": "any",
      "value": "serializeAddressObj(",
      "isPublic": true,
      "line": 221,
      "raw": "const initiatorAddress = serializeAddressObj(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:escrow.offchain.ts.recipientAddress",
      "fullName": "mesh-contract:escrow.offchain.ts.recipientAddress",
      "name": "recipientAddress",
      "type": "any",
      "value": "serializeAddressObj(",
      "isPublic": true,
      "line": 225,
      "raw": "const recipientAddress = serializeAddressObj(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:escrow.offchain.ts.recipientToReceive",
      "fullName": "mesh-contract:escrow.offchain.ts.recipientToReceive",
      "name": "recipientToReceive",
      "type": "any",
      "value": "MeshValue.fromValue(initiatorAmount).toAssets();",
      "isPublic": true,
      "line": 230,
      "raw": "const recipientToReceive = MeshValue.fromValue(initiatorAmount).toAssets();",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:escrow.offchain.ts.outputDatum",
      "fullName": "mesh-contract:escrow.offchain.ts.outputDatum",
      "name": "outputDatum",
      "type": "any",
      "value": "activeEscrowDatum(",
      "isPublic": true,
      "line": 170,
      "raw": "const outputDatum = activeEscrowDatum(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:escrow.offchain.ts.inputAssets",
      "fullName": "mesh-contract:escrow.offchain.ts.inputAssets",
      "name": "inputAssets",
      "type": "any",
      "value": "MeshValue.fromValue(inputDatum.fields[1]).toAssets();",
      "isPublic": true,
      "line": 176,
      "raw": "const inputAssets = MeshValue.fromValue(inputDatum.fields[1]).toAssets();",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:escrow.offchain.ts.escrowAmount",
      "fullName": "mesh-contract:escrow.offchain.ts.escrowAmount",
      "name": "escrowAmount",
      "type": "any",
      "value": "mergeAssets([...depositAmount, ...inputAssets]);",
      "isPublic": true,
      "line": 177,
      "raw": "const escrowAmount = mergeAssets([...depositAmount, ...inputAssets]);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:escrow.offchain.ts.initiatorToReceive",
      "fullName": "mesh-contract:escrow.offchain.ts.initiatorToReceive",
      "name": "initiatorToReceive",
      "type": "any",
      "value": "MeshValue.fromValue(recipientAmount).toAssets();",
      "isPublic": true,
      "line": 229,
      "raw": "const initiatorToReceive = MeshValue.fromValue(recipientAmount).toAssets();",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:giftcard.offchain.ts.tokenNameHex",
      "fullName": "mesh-contract:giftcard.offchain.ts.tokenNameHex",
      "name": "tokenNameHex",
      "type": "any",
      "value": "(inlineDatum[2] as BuiltinByteString).bytes;",
      "isPublic": true,
      "line": 154,
      "raw": "const tokenNameHex = (inlineDatum[2] as BuiltinByteString).bytes;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:giftcard.offchain.ts.firstUtxo",
      "fullName": "mesh-contract:giftcard.offchain.ts.firstUtxo",
      "name": "firstUtxo",
      "type": "any",
      "value": "utxos[0];",
      "isPublic": true,
      "line": 88,
      "raw": "const firstUtxo = utxos[0];",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:giftcard.offchain.ts.remainingUtxos",
      "fullName": "mesh-contract:giftcard.offchain.ts.remainingUtxos",
      "name": "remainingUtxos",
      "type": "any",
      "value": "utxos.slice(1);",
      "isPublic": true,
      "line": 90,
      "raw": "const remainingUtxos = utxos.slice(1);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:giftcard.offchain.ts.giftCardScript",
      "fullName": "mesh-contract:giftcard.offchain.ts.giftCardScript",
      "name": "giftCardScript",
      "type": "any",
      "value": "this.giftCardCbor(",
      "isPublic": true,
      "line": 155,
      "raw": "const giftCardScript = this.giftCardCbor(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:giftcard.offchain.ts.giftCardPolicy",
      "fullName": "mesh-contract:giftcard.offchain.ts.giftCardPolicy",
      "name": "giftCardPolicy",
      "type": "any",
      "value": "resolveScriptHash(",
      "isPublic": true,
      "line": 161,
      "raw": "const giftCardPolicy = resolveScriptHash(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:giftcard.offchain.ts.redeemScript",
      "fullName": "mesh-contract:giftcard.offchain.ts.redeemScript",
      "name": "redeemScript",
      "type": "any",
      "value": "this.redeemCbor(tokenNameHex, giftCardPolicy);",
      "isPublic": true,
      "line": 166,
      "raw": "const redeemScript = this.redeemCbor(tokenNameHex, giftCardPolicy);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:giftcard.offchain.ts.redeemAddr",
      "fullName": "mesh-contract:giftcard.offchain.ts.redeemAddr",
      "name": "redeemAddr",
      "type": "any",
      "value": "this.getScriptAddress(redeemScript.code);",
      "isPublic": true,
      "line": 107,
      "raw": "const redeemAddr = this.getScriptAddress(redeemScript.code);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:giftcard.offchain.ts.inlineDatum",
      "fullName": "mesh-contract:giftcard.offchain.ts.inlineDatum",
      "name": "inlineDatum",
      "type": "any",
      "value": "deserializeDatum<List>(",
      "isPublic": true,
      "line": 149,
      "raw": "const inlineDatum = deserializeDatum<List>(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:giftcard.offchain.ts.paramTxHash",
      "fullName": "mesh-contract:giftcard.offchain.ts.paramTxHash",
      "name": "paramTxHash",
      "type": "any",
      "value": "(inlineDatum[0] as BuiltinByteString).bytes;",
      "isPublic": true,
      "line": 152,
      "raw": "const paramTxHash = (inlineDatum[0] as BuiltinByteString).bytes;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:giftcard.offchain.ts.paramTxId",
      "fullName": "mesh-contract:giftcard.offchain.ts.paramTxId",
      "name": "paramTxId",
      "type": "any",
      "value": "(inlineDatum[1] as Integer).int as number;",
      "isPublic": true,
      "line": 153,
      "raw": "const paramTxId = (inlineDatum[1] as Integer).int as number;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:hello-world.offchain.ts.signerHash",
      "fullName": "mesh-contract:hello-world.offchain.ts.signerHash",
      "name": "signerHash",
      "type": "any",
      "value": "deserializeAddress(walletAddress).pubKeyHash;",
      "isPublic": true,
      "line": 57,
      "raw": "const signerHash = deserializeAddress(walletAddress).pubKeyHash;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:marketplace.offchain.ts.marketplaceDatum",
      "fullName": "mesh-contract:marketplace.offchain.ts.marketplaceDatum",
      "name": "marketplaceDatum",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 33,
      "raw": "export const marketplaceDatum = (",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:marketplace.offchain.ts.assetMap",
      "fullName": "mesh-contract:marketplace.offchain.ts.assetMap",
      "name": "assetMap",
      "type": "any",
      "value": "new Map<Unit, Quantity>();",
      "isPublic": true,
      "line": 104,
      "raw": "const assetMap = new Map<Unit, Quantity>();",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:marketplace.offchain.ts.tokenForSale",
      "fullName": "mesh-contract:marketplace.offchain.ts.tokenForSale",
      "name": "tokenForSale",
      "type": "any",
      "value": "[{ unit: inputAsset, quantity: \"1\" }];",
      "isPublic": true,
      "line": 226,
      "raw": "const tokenForSale = [{ unit: inputAsset, quantity: \"1\" }];",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:marketplace.offchain.ts.outputDatum",
      "fullName": "mesh-contract:marketplace.offchain.ts.outputDatum",
      "name": "outputDatum",
      "type": "any",
      "value": "marketplaceDatum(walletAddress, newPrice, inputAsset);",
      "isPublic": true,
      "line": 227,
      "raw": "const outputDatum = marketplaceDatum(walletAddress, newPrice, inputAsset);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:marketplace.offchain.ts.inputDatum",
      "fullName": "mesh-contract:marketplace.offchain.ts.inputDatum",
      "name": "inputDatum",
      "type": "any",
      "value": "deserializeDatum<MarketplaceDatum>(",
      "isPublic": true,
      "line": 153,
      "raw": "const inputDatum = deserializeDatum<MarketplaceDatum>(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:marketplace.offchain.ts.inputLovelace",
      "fullName": "mesh-contract:marketplace.offchain.ts.inputLovelace",
      "name": "inputLovelace",
      "type": "any",
      "value": "marketplaceUtxo.output.amount.find(",
      "isPublic": true,
      "line": 157,
      "raw": "const inputLovelace = marketplaceUtxo.output.amount.find(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:marketplace.offchain.ts.tx",
      "fullName": "mesh-contract:marketplace.offchain.ts.tx",
      "name": "tx",
      "type": "any",
      "value": "this.mesh",
      "isPublic": true,
      "line": 161,
      "raw": "const tx = this.mesh",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:marketplace.offchain.ts.ownerToReceive",
      "fullName": "mesh-contract:marketplace.offchain.ts.ownerToReceive",
      "name": "ownerToReceive",
      "type": "any",
      "value": "[",
      "isPublic": true,
      "line": 189,
      "raw": "const ownerToReceive = [",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:marketplace.offchain.ts.sellerAddress",
      "fullName": "mesh-contract:marketplace.offchain.ts.sellerAddress",
      "name": "sellerAddress",
      "type": "any",
      "value": "serializeAddressObj(",
      "isPublic": true,
      "line": 202,
      "raw": "const sellerAddress = serializeAddressObj(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:marketplace.offchain.ts.sellerToReceive",
      "fullName": "mesh-contract:marketplace.offchain.ts.sellerToReceive",
      "name": "sellerToReceive",
      "type": "any",
      "value": "[",
      "isPublic": true,
      "line": 206,
      "raw": "const sellerToReceive = [",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:marketplace.offchain.ts.inputAsset",
      "fullName": "mesh-contract:marketplace.offchain.ts.inputAsset",
      "name": "inputAsset",
      "type": "any",
      "value": "marketplaceUtxo.output.amount.find(",
      "isPublic": true,
      "line": 222,
      "raw": "const inputAsset = marketplaceUtxo.output.amount.find(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:payment-splitter.offchain.ts.datum",
      "fullName": "mesh-contract:payment-splitter.offchain.ts.datum",
      "name": "datum",
      "type": "any",
      "value": "{",
      "isPublic": true,
      "line": 102,
      "raw": "const datum = {",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:payment-splitter.offchain.ts.tx",
      "fullName": "mesh-contract:payment-splitter.offchain.ts.tx",
      "name": "tx",
      "type": "any",
      "value": "new Transaction({ initiator: this.wallet }).sendLovelace(",
      "isPublic": true,
      "line": 75,
      "raw": "const tx = new Transaction({ initiator: this.wallet }).sendLovelace(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:payment-splitter.offchain.ts.unsignedTx",
      "fullName": "mesh-contract:payment-splitter.offchain.ts.unsignedTx",
      "name": "unsignedTx",
      "type": "any",
      "value": "await tx.build();",
      "isPublic": true,
      "line": 135,
      "raw": "const unsignedTx = await tx.build();",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:payment-splitter.offchain.ts.script",
      "fullName": "mesh-contract:payment-splitter.offchain.ts.script",
      "name": "script",
      "type": "PlutusScript",
      "value": "{",
      "isPublic": true,
      "line": 94,
      "raw": "const script: PlutusScript = {",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:payment-splitter.offchain.ts.redeemerData",
      "fullName": "mesh-contract:payment-splitter.offchain.ts.redeemerData",
      "name": "redeemerData",
      "type": "any",
      "value": "\"Hello, World!\";",
      "isPublic": true,
      "line": 107,
      "raw": "const redeemerData = \"Hello, World!\";",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:payment-splitter.offchain.ts.redeemer",
      "fullName": "mesh-contract:payment-splitter.offchain.ts.redeemer",
      "name": "redeemer",
      "type": "any",
      "value": "{ data: { alternative: 0, fields: [redeemerData] } };",
      "isPublic": true,
      "line": 108,
      "raw": "const redeemer = { data: { alternative: 0, fields: [redeemerData] } };",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:payment-splitter.offchain.ts.amount",
      "fullName": "mesh-contract:payment-splitter.offchain.ts.amount",
      "name": "amount",
      "type": "any",
      "value": "utxo.output?.amount;",
      "isPublic": true,
      "line": 113,
      "raw": "const amount = utxo.output?.amount;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.oracleNftPolicyId",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.oracleNftPolicyId",
      "name": "oracleNftPolicyId",
      "type": "any",
      "value": "resolveScriptHash(this.getOracleNFTCbor(), \"V3\");",
      "isPublic": true,
      "line": 234,
      "raw": "const oracleNftPolicyId = resolveScriptHash(this.getOracleNFTCbor(), \"V3\");",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.paramUtxo",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.paramUtxo",
      "name": "paramUtxo",
      "type": "any",
      "value": "utxos[0]!;",
      "isPublic": true,
      "line": 98,
      "raw": "const paramUtxo = utxos[0]!;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.script",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.script",
      "name": "script",
      "type": "any",
      "value": "blueprint.validators[2]!.compiledCode;",
      "isPublic": true,
      "line": 99,
      "raw": "const script = blueprint.validators[2]!.compiledCode;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.param",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.param",
      "name": "param",
      "type": "Data",
      "value": "mOutputReference(",
      "isPublic": true,
      "line": 100,
      "raw": "const param: Data = mOutputReference(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.paramScript",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.paramScript",
      "name": "paramScript",
      "type": "any",
      "value": "applyParamsToScript(script, [param]);",
      "isPublic": true,
      "line": 104,
      "raw": "const paramScript = applyParamsToScript(script, [param]);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.policyId",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.policyId",
      "name": "policyId",
      "type": "any",
      "value": "resolveScriptHash(this.getNFTCbor(), \"V3\");",
      "isPublic": true,
      "line": 250,
      "raw": "const policyId = resolveScriptHash(this.getNFTCbor(), \"V3\");",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.tokenName",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.tokenName",
      "name": "tokenName",
      "type": "any",
      "value": "`${this.collectionName} (${nftIndex})`;",
      "isPublic": true,
      "line": 175,
      "raw": "const tokenName = `${this.collectionName} (${nftIndex})`;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.txHex",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.txHex",
      "name": "txHex",
      "type": "any",
      "value": "await tx.complete();",
      "isPublic": true,
      "line": 219,
      "raw": "const txHex = await tx.complete();",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.tokenNameHex",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.tokenNameHex",
      "name": "tokenNameHex",
      "type": "any",
      "value": "stringToHex(tokenName);",
      "isPublic": true,
      "line": 176,
      "raw": "const tokenNameHex = stringToHex(tokenName);",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.updatedOracleDatum",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.updatedOracleDatum",
      "name": "updatedOracleDatum",
      "type": "OracleDatum",
      "value": "conStr0([",
      "isPublic": true,
      "line": 178,
      "raw": "const updatedOracleDatum: OracleDatum = conStr0([",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.tx",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.tx",
      "name": "tx",
      "type": "any",
      "value": "this.mesh",
      "isPublic": true,
      "line": 184,
      "raw": "const tx = this.mesh",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.metadata",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.metadata",
      "name": "metadata",
      "type": "any",
      "value": "{ [policyId]: { [tokenName]: { ...assetMetadata } } };",
      "isPublic": true,
      "line": 202,
      "raw": "const metadata = { [policyId]: { [tokenName]: { ...assetMetadata } } };",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.oracleUtxo",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.oracleUtxo",
      "name": "oracleUtxo",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 235,
      "raw": "const oracleUtxo = (",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.oracleDatum",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.oracleDatum",
      "name": "oracleDatum",
      "type": "OracleDatum",
      "value": "parseDatumCbor(",
      "isPublic": true,
      "line": 238,
      "raw": "const oracleDatum: OracleDatum = parseDatumCbor(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.nftIndex",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.nftIndex",
      "name": "nftIndex",
      "type": "any",
      "value": "oracleDatum.fields[0].int;",
      "isPublic": true,
      "line": 242,
      "raw": "const nftIndex = oracleDatum.fields[0].int;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.lovelacePrice",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.lovelacePrice",
      "name": "lovelacePrice",
      "type": "any",
      "value": "oracleDatum.fields[1].int;",
      "isPublic": true,
      "line": 243,
      "raw": "const lovelacePrice = oracleDatum.fields[1].int;",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.feeCollectorAddressObj",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.feeCollectorAddressObj",
      "name": "feeCollectorAddressObj",
      "type": "any",
      "value": "oracleDatum.fields[2];",
      "isPublic": true,
      "line": 244,
      "raw": "const feeCollectorAddressObj = oracleDatum.fields[2];",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:plutus-nft.offchain.ts.feeCollectorAddress",
      "fullName": "mesh-contract:plutus-nft.offchain.ts.feeCollectorAddress",
      "name": "feeCollectorAddress",
      "type": "any",
      "value": "serializeAddressObj(",
      "isPublic": true,
      "line": 245,
      "raw": "const feeCollectorAddress = serializeAddressObj(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:swap.offchain.ts.swapDatum",
      "fullName": "mesh-contract:swap.offchain.ts.swapDatum",
      "name": "swapDatum",
      "type": "SwapDatum",
      "value": "conStr0([",
      "isPublic": true,
      "line": 54,
      "raw": "const swapDatum: SwapDatum = conStr0([",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:swap.offchain.ts.inlineDatum",
      "fullName": "mesh-contract:swap.offchain.ts.inlineDatum",
      "name": "inlineDatum",
      "type": "any",
      "value": "deserializeDatum<SwapDatum>(",
      "isPublic": true,
      "line": 118,
      "raw": "const inlineDatum = deserializeDatum<SwapDatum>(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:swap.offchain.ts.initiatorAddress",
      "fullName": "mesh-contract:swap.offchain.ts.initiatorAddress",
      "name": "initiatorAddress",
      "type": "any",
      "value": "serializeAddressObj(",
      "isPublic": true,
      "line": 121,
      "raw": "const initiatorAddress = serializeAddressObj(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:swap.offchain.ts.initiatorToReceive",
      "fullName": "mesh-contract:swap.offchain.ts.initiatorToReceive",
      "name": "initiatorToReceive",
      "type": "any",
      "value": "inlineDatum.fields[2];",
      "isPublic": true,
      "line": 86,
      "raw": "const initiatorToReceive = inlineDatum.fields[2];",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-contract:vesting.offchain.ts.datum",
      "fullName": "mesh-contract:vesting.offchain.ts.datum",
      "name": "datum",
      "type": "any",
      "value": "deserializeDatum<VestingDatum>(",
      "isPublic": true,
      "line": 77,
      "raw": "const datum = deserializeDatum<VestingDatum>(",
      "source": "mesh-contract"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.costs",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.costs",
      "name": "costs",
      "type": "any",
      "value": "await this.builderCallback.computeMinimumCost({",
      "isPublic": true,
      "line": 60,
      "raw": "const costs = await this.builderCallback.computeMinimumCost({",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.maxSizeExceed",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.maxSizeExceed",
      "name": "maxSizeExceed",
      "type": "any",
      "value": "await this.builderCallback.maxSizeExceed({",
      "isPublic": true,
      "line": 78,
      "raw": "const maxSizeExceed = await this.builderCallback.maxSizeExceed({",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.newInputs",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.newInputs",
      "name": "newInputs",
      "type": "any",
      "value": "new Set<UTxO>();",
      "isPublic": true,
      "line": 182,
      "raw": "const newInputs = new Set<UTxO>();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.utxoId",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.utxoId",
      "name": "utxoId",
      "type": "any",
      "value": "`${input[0].txId}#${input[0].index}`;",
      "isPublic": true,
      "line": 184,
      "raw": "const utxoId = `${input[0].txId}#${input[0].index}`;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.originalUtxo",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.originalUtxo",
      "name": "originalUtxo",
      "type": "any",
      "value": "utxoMap.get(utxoId);",
      "isPublic": true,
      "line": 186,
      "raw": "const originalUtxo = utxoMap.get(utxoId);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.utxoMap",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.utxoMap",
      "name": "utxoMap",
      "type": "any",
      "value": "new Map<string, UTxO>();",
      "isPublic": true,
      "line": 139,
      "raw": "const utxoMap = new Map<string, UTxO>();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.aggregatedTxOut",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.aggregatedTxOut",
      "name": "aggregatedTxOut",
      "type": "any",
      "value": "makeAggregatedCSDKOOutput(outputs);",
      "isPublic": true,
      "line": 145,
      "raw": "const aggregatedTxOut = makeAggregatedCSDKOOutput(outputs);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.aggregatedOuts",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.aggregatedOuts",
      "name": "aggregatedOuts",
      "type": "any",
      "value": "new Set<CSDK.TxOut>();",
      "isPublic": true,
      "line": 146,
      "raw": "const aggregatedOuts = new Set<CSDK.TxOut>();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.preselectedUtoxsCSDK",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.preselectedUtoxsCSDK",
      "name": "preselectedUtoxsCSDK",
      "type": "any",
      "value": "new Set(",
      "isPublic": true,
      "line": 151,
      "raw": "const preselectedUtoxsCSDK = new Set(",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.utxoxCSDK",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.utxoxCSDK",
      "name": "utxoxCSDK",
      "type": "any",
      "value": "utxos.map(meshUtxoToCSDKUtxo);",
      "isPublic": true,
      "line": 154,
      "raw": "const utxoxCSDK = utxos.map(meshUtxoToCSDKUtxo);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.selector",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.selector",
      "name": "selector",
      "type": "any",
      "value": "CardanoSelection.roundRobinRandomImprove({",
      "isPublic": true,
      "line": 157,
      "raw": "const selector = CardanoSelection.roundRobinRandomImprove({",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.usedUtxos",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.usedUtxos",
      "name": "usedUtxos",
      "type": "any",
      "value": "new Set<string>();",
      "isPublic": true,
      "line": 162,
      "raw": "const usedUtxos = new Set<string>();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.builderCallbacksBridge",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.builderCallbacksBridge",
      "name": "builderCallbacksBridge",
      "type": "any",
      "value": "new BuilderCallbacksSdkBridge(",
      "isPublic": true,
      "line": 167,
      "raw": "const builderCallbacksBridge = new BuilderCallbacksSdkBridge(",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.selectResult",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.selectResult",
      "name": "selectResult",
      "type": "any",
      "value": "await selector.select({",
      "isPublic": true,
      "line": 174,
      "raw": "const selectResult = await selector.select({",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshTxInToCSDKUtxo",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshTxInToCSDKUtxo",
      "name": "meshTxInToCSDKUtxo",
      "type": "any",
      "value": "(txIn: TxIn): CSDK.Utxo => {",
      "isPublic": true,
      "line": 224,
      "raw": "const meshTxInToCSDKUtxo = (txIn: TxIn): CSDK.Utxo => {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshUtxoToCSDKUtxo",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshUtxoToCSDKUtxo",
      "name": "meshUtxoToCSDKUtxo",
      "type": "any",
      "value": "(utxo: UTxO): CSDK.Utxo => {",
      "isPublic": true,
      "line": 238,
      "raw": "const meshUtxoToCSDKUtxo = (utxo: UTxO): CSDK.Utxo => {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshScriptReferenceToCSDKScriptReference",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshScriptReferenceToCSDKScriptReference",
      "name": "meshScriptReferenceToCSDKScriptReference",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 257,
      "raw": "const meshScriptReferenceToCSDKScriptReference = (",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshDatumToCSDKDatum",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshDatumToCSDKDatum",
      "name": "meshDatumToCSDKDatum",
      "type": "any",
      "value": "(datum?: string): CSDK.PlutusData | undefined => {",
      "isPublic": true,
      "line": 267,
      "raw": "const meshDatumToCSDKDatum = (datum?: string): CSDK.PlutusData | undefined => {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshDataHashToCSDKDataHash",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshDataHashToCSDKDataHash",
      "name": "meshDataHashToCSDKDataHash",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 275,
      "raw": "const meshDataHashToCSDKDataHash = (",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshAssetsToCSDKValue",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshAssetsToCSDKValue",
      "name": "meshAssetsToCSDKValue",
      "type": "any",
      "value": "(assets?: Asset[]): CSDK.Value => {",
      "isPublic": true,
      "line": 284,
      "raw": "const meshAssetsToCSDKValue = (assets?: Asset[]): CSDK.Value => {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.sdkAssets",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.sdkAssets",
      "name": "sdkAssets",
      "type": "any",
      "value": "new Map<CSDK.AssetId, bigint>();",
      "isPublic": true,
      "line": 475,
      "raw": "const sdkAssets = new Map<CSDK.AssetId, bigint>();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.assetId",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.assetId",
      "name": "assetId",
      "type": "any",
      "value": "<CSDK.AssetId>unit;",
      "isPublic": true,
      "line": 481,
      "raw": "const assetId = <CSDK.AssetId>unit;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshAssetsToCSDKAssets",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshAssetsToCSDKAssets",
      "name": "meshAssetsToCSDKAssets",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 313,
      "raw": "const meshAssetsToCSDKAssets = (",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSDKOutputToMeshOutput",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSDKOutputToMeshOutput",
      "name": "CSDKOutputToMeshOutput",
      "type": "any",
      "value": "(output: CSDK.TxOut): TxOutput => {",
      "isPublic": true,
      "line": 334,
      "raw": "const CSDKOutputToMeshOutput = (output: CSDK.TxOut): TxOutput => {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.amount",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.amount",
      "name": "amount",
      "type": "any",
      "value": "CSDKValueToMeshAssets(output.value);",
      "isPublic": true,
      "line": 335,
      "raw": "const amount = CSDKValueToMeshAssets(output.value);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSDKValueToMeshAssets",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSDKValueToMeshAssets",
      "name": "CSDKValueToMeshAssets",
      "type": "any",
      "value": "(value: CSDK.Value): Asset[] => {",
      "isPublic": true,
      "line": 342,
      "raw": "const CSDKValueToMeshAssets = (value: CSDK.Value): Asset[] => {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.assets",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.assets",
      "name": "assets",
      "type": "Asset[]",
      "value": "[];",
      "isPublic": true,
      "line": 371,
      "raw": "const assets: Asset[] = [];",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSDKTokenMapToMeshAssets",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSDKTokenMapToMeshAssets",
      "name": "CSDKTokenMapToMeshAssets",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 364,
      "raw": "const CSDKTokenMapToMeshAssets = (",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshOutputToCSDKOutput",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshOutputToCSDKOutput",
      "name": "meshOutputToCSDKOutput",
      "type": "any",
      "value": "(output: Output): CSDK.TxOut => {",
      "isPublic": true,
      "line": 383,
      "raw": "const meshOutputToCSDKOutput = (output: Output): CSDK.TxOut => {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.makeAggregatedCSDKOOutput",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.makeAggregatedCSDKOOutput",
      "name": "makeAggregatedCSDKOOutput",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 396,
      "raw": "const makeAggregatedCSDKOOutput = (",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshOutputToCSDKOutputsScriptData",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshOutputToCSDKOutputsScriptData",
      "name": "meshOutputToCSDKOutputsScriptData",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 415,
      "raw": "const meshOutputToCSDKOutputsScriptData = (",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.assetsMapToCSDKValue",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.assetsMapToCSDKValue",
      "name": "assetsMapToCSDKValue",
      "type": "any",
      "value": "(assets: Map<string, bigint>): CSDK.Value => {",
      "isPublic": true,
      "line": 473,
      "raw": "const assetsMapToCSDKValue = (assets: Map<string, bigint>): CSDK.Value => {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.sumAssets",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.sumAssets",
      "name": "sumAssets",
      "type": "any",
      "value": "(a: Map<string, bigint>, b: Asset[]): Map<string, bigint> => {",
      "isPublic": true,
      "line": 496,
      "raw": "const sumAssets = (a: Map<string, bigint>, b: Asset[]): Map<string, bigint> => {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.currentAmount",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.currentAmount",
      "name": "currentAmount",
      "type": "any",
      "value": "a.get(asset.unit) ?? 0n;",
      "isPublic": true,
      "line": 498,
      "raw": "const currentAmount = a.get(asset.unit) ?? 0n;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshImplicitCoinToCSDKImplicitCoins",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshImplicitCoinToCSDKImplicitCoins",
      "name": "meshImplicitCoinToCSDKImplicitCoins",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 504,
      "raw": "const meshImplicitCoinToCSDKImplicitCoins = (",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.mint",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.mint",
      "name": "mint",
      "type": "any",
      "value": "meshAssetsToCSDKAssets(implicitCoins.mint);",
      "isPublic": true,
      "line": 510,
      "raw": "const mint = meshAssetsToCSDKAssets(implicitCoins.mint);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.totalInput",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.totalInput",
      "name": "totalInput",
      "type": "any",
      "value": "implicitCoins.reclaimDeposit + implicitCoins.withdrawals;",
      "isPublic": true,
      "line": 511,
      "raw": "const totalInput = implicitCoins.reclaimDeposit + implicitCoins.withdrawals;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSKDImplicitCoin",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSKDImplicitCoin",
      "name": "CSKDImplicitCoin",
      "type": "any",
      "value": "{",
      "isPublic": true,
      "line": 512,
      "raw": "const CSKDImplicitCoin = {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshActionToCSDKRedeemer",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshActionToCSDKRedeemer",
      "name": "meshActionToCSDKRedeemer",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 525,
      "raw": "const meshActionToCSDKRedeemer = (",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSDKRedeemerToMeshAction",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSDKRedeemerToMeshAction",
      "name": "CSDKRedeemerToMeshAction",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 539,
      "raw": "const CSDKRedeemerToMeshAction = (",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshRedeemerTagToCSDKRedeemerTag",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.meshRedeemerTagToCSDKRedeemerTag",
      "name": "meshRedeemerTagToCSDKRedeemerTag",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 552,
      "raw": "const meshRedeemerTagToCSDKRedeemerTag = (",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSDKRedeemerTagToMeshRedeemerTag",
      "fullName": "mesh-transaction:mesh-tx-builder.coin-selection.cardano-sdk-adapter.ts.CSDKRedeemerTagToMeshRedeemerTag",
      "name": "CSDKRedeemerTagToMeshRedeemerTag",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 571,
      "raw": "const CSDKRedeemerTagToMeshRedeemerTag = (",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.builderBody",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.builderBody",
      "name": "builderBody",
      "type": "any",
      "value": "this.meshTxBuilderBody;",
      "isPublic": true,
      "line": 102,
      "raw": "const builderBody = this.meshTxBuilderBody;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.txPrototype",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.txPrototype",
      "name": "txPrototype",
      "type": "any",
      "value": "await this.selectUtxos();",
      "isPublic": true,
      "line": 182,
      "raw": "const txPrototype = await this.selectUtxos();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.txHex",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.txHex",
      "name": "txHex",
      "type": "any",
      "value": "this.serializer.serializeTxBody(",
      "isPublic": true,
      "line": 195,
      "raw": "const txHex = this.serializer.serializeTxBody(",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.callbacks",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.callbacks",
      "name": "callbacks",
      "type": "CoinSelectionInterface.BuilderCallbacks",
      "value": "{",
      "isPublic": true,
      "line": 206,
      "raw": "const callbacks: CoinSelectionInterface.BuilderCallbacks = {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.clonedBuilder",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.clonedBuilder",
      "name": "clonedBuilder",
      "type": "any",
      "value": "this.clone();",
      "isPublic": true,
      "line": 248,
      "raw": "const clonedBuilder = this.clone();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.fee",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.fee",
      "name": "fee",
      "type": "any",
      "value": "clonedBuilder.getActualFee();",
      "isPublic": true,
      "line": 228,
      "raw": "const fee = clonedBuilder.getActualFee();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.redeemers",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.redeemers",
      "name": "redeemers",
      "type": "Omit<Action, \"data\">[]",
      "value": "[];",
      "isPublic": true,
      "line": 499,
      "raw": "const redeemers: Omit<Action, \"data\">[] = [];",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.maxValueSize",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.maxValueSize",
      "name": "maxValueSize",
      "type": "any",
      "value": "this._protocolParams.maxValSize;",
      "isPublic": true,
      "line": 236,
      "raw": "const maxValueSize = this._protocolParams.maxValSize;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.maxTxSize",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.maxTxSize",
      "name": "maxTxSize",
      "type": "any",
      "value": "this._protocolParams.maxTxSize;",
      "isPublic": true,
      "line": 250,
      "raw": "const maxTxSize = this._protocolParams.maxTxSize;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.txSize",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.txSize",
      "name": "txSize",
      "type": "any",
      "value": "this.getSerializedSize();",
      "isPublic": true,
      "line": 1693,
      "raw": "const txSize = this.getSerializedSize();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.currentInputs",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.currentInputs",
      "name": "currentInputs",
      "type": "any",
      "value": "this.meshTxBuilderBody.inputs;",
      "isPublic": true,
      "line": 256,
      "raw": "const currentInputs = this.meshTxBuilderBody.inputs;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.currentOutputs",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.currentOutputs",
      "name": "currentOutputs",
      "type": "any",
      "value": "this.meshTxBuilderBody.outputs;",
      "isPublic": true,
      "line": 257,
      "raw": "const currentOutputs = this.meshTxBuilderBody.outputs;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.changeAddress",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.changeAddress",
      "name": "changeAddress",
      "type": "any",
      "value": "this.meshTxBuilderBody.changeAddress;",
      "isPublic": true,
      "line": 258,
      "raw": "const changeAddress = this.meshTxBuilderBody.changeAddress;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.utxosForSelection",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.utxosForSelection",
      "name": "utxosForSelection",
      "type": "any",
      "value": "await this.getUtxosForSelection();",
      "isPublic": true,
      "line": 259,
      "raw": "const utxosForSelection = await this.getUtxosForSelection();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.implicitValue",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.implicitValue",
      "name": "implicitValue",
      "type": "any",
      "value": "{",
      "isPublic": true,
      "line": 260,
      "raw": "const implicitValue = {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.inputSelector",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.inputSelector",
      "name": "inputSelector",
      "type": "any",
      "value": "new CardanoSdkInputSelector(callbacks);",
      "isPublic": true,
      "line": 267,
      "raw": "const inputSelector = new CardanoSdkInputSelector(callbacks);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.utxos",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.utxos",
      "name": "utxos",
      "type": "any",
      "value": "this.queriedUTxOs[txHash];",
      "isPublic": true,
      "line": 1455,
      "raw": "const utxos = this.queriedUTxOs[txHash];",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.usedUtxos",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.usedUtxos",
      "name": "usedUtxos",
      "type": "any",
      "value": "new Set(",
      "isPublic": true,
      "line": 312,
      "raw": "const usedUtxos = new Set(",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.credentialA",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.credentialA",
      "name": "credentialA",
      "type": "any",
      "value": "CstAddress.fromString(a.address)",
      "isPublic": true,
      "line": 377,
      "raw": "const credentialA = CstAddress.fromString(a.address)",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.credentialB",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.credentialB",
      "name": "credentialB",
      "type": "any",
      "value": "CstAddress.fromString(b.address)",
      "isPublic": true,
      "line": 380,
      "raw": "const credentialB = CstAddress.fromString(b.address)",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.variantOrder",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.variantOrder",
      "name": "variantOrder",
      "type": "Record<Voter[\"type\"], number>",
      "value": "{",
      "isPublic": true,
      "line": 391,
      "raw": "const variantOrder: Record<Voter[\"type\"], number> = {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.voterA",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.voterA",
      "name": "voterA",
      "type": "any",
      "value": "a.vote.voter;",
      "isPublic": true,
      "line": 397,
      "raw": "const voterA = a.vote.voter;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.voterB",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.voterB",
      "name": "voterB",
      "type": "any",
      "value": "b.vote.voter;",
      "isPublic": true,
      "line": 398,
      "raw": "const voterB = b.vote.voter;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.orderA",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.orderA",
      "name": "orderA",
      "type": "any",
      "value": "variantOrder[voterA.type];",
      "isPublic": true,
      "line": 399,
      "raw": "const orderA = variantOrder[voterA.type];",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.orderB",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.orderB",
      "name": "orderB",
      "type": "any",
      "value": "variantOrder[voterB.type];",
      "isPublic": true,
      "line": 400,
      "raw": "const orderB = variantOrder[voterB.type];",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.credA",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.credA",
      "name": "credA",
      "type": "any",
      "value": "voterA.hotCred;",
      "isPublic": true,
      "line": 408,
      "raw": "const credA = voterA.hotCred;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.credB",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.credB",
      "name": "credB",
      "type": "any",
      "value": "voterB.hotCred;",
      "isPublic": true,
      "line": 409,
      "raw": "const credB = voterB.hotCred;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.drepA",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.drepA",
      "name": "drepA",
      "type": "any",
      "value": "coreToCstDRep(voterA.drepId);",
      "isPublic": true,
      "line": 430,
      "raw": "const drepA = coreToCstDRep(voterA.drepId);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.drepB",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.drepB",
      "name": "drepB",
      "type": "any",
      "value": "coreToCstDRep(voterB.drepId);",
      "isPublic": true,
      "line": 431,
      "raw": "const drepB = coreToCstDRep(voterB.drepId);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.scriptHashA",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.scriptHashA",
      "name": "scriptHashA",
      "type": "any",
      "value": "drepA.toScriptHash();",
      "isPublic": true,
      "line": 432,
      "raw": "const scriptHashA = drepA.toScriptHash();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.scriptHashB",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.scriptHashB",
      "name": "scriptHashB",
      "type": "any",
      "value": "drepB.toScriptHash();",
      "isPublic": true,
      "line": 433,
      "raw": "const scriptHashB = drepB.toScriptHash();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.keyHashA",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.keyHashA",
      "name": "keyHashA",
      "type": "any",
      "value": "drepA.toKeyHash();",
      "isPublic": true,
      "line": 434,
      "raw": "const keyHashA = drepA.toKeyHash();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.keyHashB",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.keyHashB",
      "name": "keyHashB",
      "type": "any",
      "value": "drepB.toKeyHash();",
      "isPublic": true,
      "line": 435,
      "raw": "const keyHashB = drepB.toKeyHash();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.txEvaluation",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.txEvaluation",
      "name": "txEvaluation",
      "type": "any",
      "value": "await this.evaluator",
      "isPublic": true,
      "line": 790,
      "raw": "const txEvaluation = await this.evaluator",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.meshTxBuilderBody",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.meshTxBuilderBody",
      "name": "meshTxBuilderBody",
      "type": "any",
      "value": "this.meshTxBuilderBody;",
      "isPublic": true,
      "line": 498,
      "raw": "const meshTxBuilderBody = this.meshTxBuilderBody;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.input",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.input",
      "name": "input",
      "type": "any",
      "value": "meshTxBuilderBody.inputs[i]!;",
      "isPublic": true,
      "line": 501,
      "raw": "const input = meshTxBuilderBody.inputs[i]!;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.mint",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.mint",
      "name": "mint",
      "type": "any",
      "value": "meshTxBuilderBody.mints[i]!;",
      "isPublic": true,
      "line": 511,
      "raw": "const mint = meshTxBuilderBody.mints[i]!;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.cert",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.cert",
      "name": "cert",
      "type": "any",
      "value": "meshTxBuilderBody.certificates[i]!;",
      "isPublic": true,
      "line": 521,
      "raw": "const cert = meshTxBuilderBody.certificates[i]!;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.withdrawal",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.withdrawal",
      "name": "withdrawal",
      "type": "any",
      "value": "meshTxBuilderBody.withdrawals[i]!;",
      "isPublic": true,
      "line": 531,
      "raw": "const withdrawal = meshTxBuilderBody.withdrawals[i]!;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.vote",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.vote",
      "name": "vote",
      "type": "any",
      "value": "meshTxBuilderBody.votes[i]!;",
      "isPublic": true,
      "line": 541,
      "raw": "const vote = meshTxBuilderBody.votes[i]!;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.signedTxHex",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.signedTxHex",
      "name": "signedTxHex",
      "type": "any",
      "value": "this.serializer.addSigningKeys(",
      "isPublic": true,
      "line": 580,
      "raw": "const signedTxHex = this.serializer.addSigningKeys(",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.txHash",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.txHash",
      "name": "txHash",
      "type": "any",
      "value": "await this.submitter?.submitTx(txHex);",
      "isPublic": true,
      "line": 594,
      "raw": "const txHash = await this.submitter?.submitTx(txHex);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.queryUTxOPromises",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.queryUTxOPromises",
      "name": "queryUTxOPromises",
      "type": "Promise<void>[]",
      "value": "[];",
      "isPublic": true,
      "line": 616,
      "raw": "const queryUTxOPromises: Promise<void>[] = [];",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.currentTxIn",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.currentTxIn",
      "name": "currentTxIn",
      "type": "any",
      "value": "incompleteTxIns[i]!;",
      "isPublic": true,
      "line": 627,
      "raw": "const currentTxIn = incompleteTxIns[i]!;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.scriptSource",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.scriptSource",
      "name": "scriptSource",
      "type": "any",
      "value": "cert.scriptSource;",
      "isPublic": true,
      "line": 1620,
      "raw": "const scriptSource = cert.scriptSource;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.utxo",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.utxo",
      "name": "utxo",
      "type": "any",
      "value": "utxos.find((utxo) => utxo.input.outputIndex === index);",
      "isPublic": true,
      "line": 1460,
      "raw": "const utxo = utxos.find((utxo) => utxo.input.outputIndex === index);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.amount",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.amount",
      "name": "amount",
      "type": "any",
      "value": "utxo?.output.amount;",
      "isPublic": true,
      "line": 661,
      "raw": "const amount = utxo?.output.amount;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.address",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.address",
      "name": "address",
      "type": "any",
      "value": "CstAddress.fromString(",
      "isPublic": true,
      "line": 1151,
      "raw": "const address = CstAddress.fromString(",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.refUtxos",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.refUtxos",
      "name": "refUtxos",
      "type": "any",
      "value": "this.queriedUTxOs[simpleScript.txHash]!;",
      "isPublic": true,
      "line": 702,
      "raw": "const refUtxos = this.queriedUTxOs[simpleScript.txHash]!;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.scriptRefUtxo",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.scriptRefUtxo",
      "name": "scriptRefUtxo",
      "type": "any",
      "value": "refUtxos.find(",
      "isPublic": true,
      "line": 703,
      "raw": "const scriptRefUtxo = refUtxos.find(",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.incompleteTxIns",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.incompleteTxIns",
      "name": "incompleteTxIns",
      "type": "any",
      "value": "[...inputs, ...collaterals].filter(",
      "isPublic": true,
      "line": 816,
      "raw": "const incompleteTxIns = [...inputs, ...collaterals].filter(",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.minAda",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.minAda",
      "name": "minAda",
      "type": "any",
      "value": "this.calculateMinLovelaceForOutput(output);",
      "isPublic": true,
      "line": 960,
      "raw": "const minAda = this.calculateMinLovelaceForOutput(output);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.withdrawalCreds",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.withdrawalCreds",
      "name": "withdrawalCreds",
      "type": "any",
      "value": "new Set<string>();",
      "isPublic": true,
      "line": 1060,
      "raw": "const withdrawalCreds = new Set<string>();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.certCreds",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.certCreds",
      "name": "certCreds",
      "type": "any",
      "value": "new Set<string>();",
      "isPublic": true,
      "line": 1084,
      "raw": "const certCreds = new Set<string>();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.voteCreds",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.voteCreds",
      "name": "voteCreds",
      "type": "any",
      "value": "new Set<string>();",
      "isPublic": true,
      "line": 1173,
      "raw": "const voteCreds = new Set<string>();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.mintCreds",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.mintCreds",
      "name": "mintCreds",
      "type": "any",
      "value": "new Set<string>();",
      "isPublic": true,
      "line": 1205,
      "raw": "const mintCreds = new Set<string>();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.requiredSignatures",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.requiredSignatures",
      "name": "requiredSignatures",
      "type": "any",
      "value": "this.meshTxBuilderBody.requiredSignatures;",
      "isPublic": true,
      "line": 980,
      "raw": "const requiredSignatures = this.meshTxBuilderBody.requiredSignatures;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.allCreds",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.allCreds",
      "name": "allCreds",
      "type": "any",
      "value": "new Set([",
      "isPublic": true,
      "line": 981,
      "raw": "const allCreds = new Set([",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.allByronAddresses",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.allByronAddresses",
      "name": "allByronAddresses",
      "type": "any",
      "value": "new Set([",
      "isPublic": true,
      "line": 990,
      "raw": "const allByronAddresses = new Set([",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.byronAddresses",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.byronAddresses",
      "name": "byronAddresses",
      "type": "any",
      "value": "new Set<string>();",
      "isPublic": true,
      "line": 1001,
      "raw": "const byronAddresses = new Set<string>();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.paymentCreds",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.paymentCreds",
      "name": "paymentCreds",
      "type": "any",
      "value": "new Set<string>();",
      "isPublic": true,
      "line": 1002,
      "raw": "const paymentCreds = new Set<string>();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.addressDetails",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.addressDetails",
      "name": "addressDetails",
      "type": "any",
      "value": "address.getProps();",
      "isPublic": true,
      "line": 1155,
      "raw": "const addressDetails = address.getProps();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.paymentCred",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.paymentCred",
      "name": "paymentCred",
      "type": "any",
      "value": "addressDetails.paymentPart;",
      "isPublic": true,
      "line": 1156,
      "raw": "const paymentCred = addressDetails.paymentPart;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.nativeScript",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.nativeScript",
      "name": "nativeScript",
      "type": "any",
      "value": "this.getMintNativeScript(mint);",
      "isPublic": true,
      "line": 1208,
      "raw": "const nativeScript = this.getMintNativeScript(mint);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.collateralByronAddresses",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.collateralByronAddresses",
      "name": "collateralByronAddresses",
      "type": "any",
      "value": "new Set<string>();",
      "isPublic": true,
      "line": 1036,
      "raw": "const collateralByronAddresses = new Set<string>();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.collateralPaymentCreds",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.collateralPaymentCreds",
      "name": "collateralPaymentCreds",
      "type": "any",
      "value": "new Set<string>();",
      "isPublic": true,
      "line": 1037,
      "raw": "const collateralPaymentCreds = new Set<string>();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.certNativeScript",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.certNativeScript",
      "name": "certNativeScript",
      "type": "any",
      "value": "this.getCertificateNativeScript(cert);",
      "isPublic": true,
      "line": 1093,
      "raw": "const certNativeScript = this.getCertificateNativeScript(cert);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.certType",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.certType",
      "name": "certType",
      "type": "any",
      "value": "cert.certType;",
      "isPublic": true,
      "line": 1254,
      "raw": "const certType = cert.certType;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.cstDrep",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.cstDrep",
      "name": "cstDrep",
      "type": "any",
      "value": "coreToCstDRep(certType.drepId);",
      "isPublic": true,
      "line": 1110,
      "raw": "const cstDrep = coreToCstDRep(certType.drepId);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.keyHash",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.keyHash",
      "name": "keyHash",
      "type": "any",
      "value": "drep.toKeyHash();",
      "isPublic": true,
      "line": 1186,
      "raw": "const keyHash = drep.toKeyHash();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.voter",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.voter",
      "name": "voter",
      "type": "any",
      "value": "vote.vote.voter;",
      "isPublic": true,
      "line": 1183,
      "raw": "const voter = vote.vote.voter;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.drep",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.drep",
      "name": "drep",
      "type": "any",
      "value": "coreToCstDRep(voter.drepId);",
      "isPublic": true,
      "line": 1185,
      "raw": "const drep = coreToCstDRep(voter.drepId);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.hotCred",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.hotCred",
      "name": "hotCred",
      "type": "any",
      "value": "voter.hotCred;",
      "isPublic": true,
      "line": 1193,
      "raw": "const hotCred = voter.hotCred;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.assets",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.assets",
      "name": "assets",
      "type": "any",
      "value": "new Map<string, bigint>();",
      "isPublic": true,
      "line": 1267,
      "raw": "const assets = new Map<string, bigint>();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.assetId",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.assetId",
      "name": "assetId",
      "type": "any",
      "value": "`${mint.policyId}${assetValue.assetName}`;",
      "isPublic": true,
      "line": 1270,
      "raw": "const assetId = `${mint.policyId}${assetValue.assetName}`;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.pubKeys",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.pubKeys",
      "name": "pubKeys",
      "type": "any",
      "value": "new Set<string>();",
      "isPublic": true,
      "line": 1285,
      "raw": "const pubKeys = new Set<string>();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.nativeScriptStack",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.nativeScriptStack",
      "name": "nativeScriptStack",
      "type": "any",
      "value": "[];",
      "isPublic": true,
      "line": 1286,
      "raw": "const nativeScriptStack = [];",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.script",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.script",
      "name": "script",
      "type": "any",
      "value": "CstScript.fromCbor(",
      "isPublic": true,
      "line": 1462,
      "raw": "const script = CstScript.fromCbor(",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.nOfK",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.nOfK",
      "name": "nOfK",
      "type": "any",
      "value": "script.asScriptNOfK();",
      "isPublic": true,
      "line": 1293,
      "raw": "const nOfK = script.asScriptNOfK();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.scriptAll",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.scriptAll",
      "name": "scriptAll",
      "type": "any",
      "value": "script.asScriptAll();",
      "isPublic": true,
      "line": 1299,
      "raw": "const scriptAll = script.asScriptAll();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.scriptAny",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.scriptAny",
      "name": "scriptAny",
      "type": "any",
      "value": "script.asScriptAny();",
      "isPublic": true,
      "line": 1305,
      "raw": "const scriptAny = script.asScriptAny();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.scriptPubkey",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.scriptPubkey",
      "name": "scriptPubkey",
      "type": "any",
      "value": "script.asScriptPubkey();",
      "isPublic": true,
      "line": 1311,
      "raw": "const scriptPubkey = script.asScriptPubkey();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.scriptSourceAlternative",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.scriptSourceAlternative",
      "name": "scriptSourceAlternative",
      "type": "any",
      "value": "mint.scriptSource as ScriptSource;",
      "isPublic": true,
      "line": 1375,
      "raw": "const scriptSourceAlternative = mint.scriptSource as ScriptSource;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.allReferenceInputs",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.allReferenceInputs",
      "name": "allReferenceInputs",
      "type": "any",
      "value": "this.getAllReferenceInputsSizes();",
      "isPublic": true,
      "line": 1476,
      "raw": "const allReferenceInputs = this.getAllReferenceInputsSizes();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.referenceInputs",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.referenceInputs",
      "name": "referenceInputs",
      "type": "[string, bigint][]",
      "value": "[];",
      "isPublic": true,
      "line": 1609,
      "raw": "const referenceInputs: [string, bigint][] = [];",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.bodyReferenceInputs",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.bodyReferenceInputs",
      "name": "bodyReferenceInputs",
      "type": "any",
      "value": "this.getBodyReferenceInputsSizes();",
      "isPublic": true,
      "line": 1485,
      "raw": "const bodyReferenceInputs = this.getBodyReferenceInputsSizes();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.inputsReferenceInputs",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.inputsReferenceInputs",
      "name": "inputsReferenceInputs",
      "type": "any",
      "value": "this.getInputsReferenceInputsSizes();",
      "isPublic": true,
      "line": 1489,
      "raw": "const inputsReferenceInputs = this.getInputsReferenceInputsSizes();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.mintsReferenceInputs",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.mintsReferenceInputs",
      "name": "mintsReferenceInputs",
      "type": "any",
      "value": "this.getMintsReferenceInputsSizes();",
      "isPublic": true,
      "line": 1493,
      "raw": "const mintsReferenceInputs = this.getMintsReferenceInputsSizes();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.votesReferenceInputs",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.votesReferenceInputs",
      "name": "votesReferenceInputs",
      "type": "any",
      "value": "this.getVotesReferenceInputsSizes();",
      "isPublic": true,
      "line": 1502,
      "raw": "const votesReferenceInputs = this.getVotesReferenceInputsSizes();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.refScriptFee",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.refScriptFee",
      "name": "refScriptFee",
      "type": "any",
      "value": "this._protocolParams.minFeeRefScriptCostPerByte;",
      "isPublic": true,
      "line": 1708,
      "raw": "const refScriptFee = this._protocolParams.minFeeRefScriptCostPerByte;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.redeemersFee",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.redeemersFee",
      "name": "redeemersFee",
      "type": "any",
      "value": "this.calculateRedeemersFee();",
      "isPublic": true,
      "line": 1699,
      "raw": "const redeemersFee = this.calculateRedeemersFee();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.minFeeCoeff",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.minFeeCoeff",
      "name": "minFeeCoeff",
      "type": "any",
      "value": "BigInt(this._protocolParams.minFeeA);",
      "isPublic": true,
      "line": 1700,
      "raw": "const minFeeCoeff = BigInt(this._protocolParams.minFeeA);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.minFeeConstant",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.minFeeConstant",
      "name": "minFeeConstant",
      "type": "any",
      "value": "BigInt(this._protocolParams.minFeeB);",
      "isPublic": true,
      "line": 1701,
      "raw": "const minFeeConstant = BigInt(this._protocolParams.minFeeB);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.minFee",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.minFee",
      "name": "minFee",
      "type": "any",
      "value": "minFeeCoeff * BigInt(txSize) + minFeeConstant;",
      "isPublic": true,
      "line": 1702,
      "raw": "const minFee = minFeeCoeff * BigInt(txSize) + minFeeConstant;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.refSize",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.refSize",
      "name": "refSize",
      "type": "any",
      "value": "this.getTotalReferenceInputsSize();",
      "isPublic": true,
      "line": 1707,
      "raw": "const refSize = this.getTotalReferenceInputsSize();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.stepPrice",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.stepPrice",
      "name": "stepPrice",
      "type": "any",
      "value": "BigNumber(this._protocolParams.priceStep);",
      "isPublic": true,
      "line": 1714,
      "raw": "const stepPrice = BigNumber(this._protocolParams.priceStep);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.memPrice",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.memPrice",
      "name": "memPrice",
      "type": "any",
      "value": "BigNumber(this._protocolParams.priceMem);",
      "isPublic": true,
      "line": 1715,
      "raw": "const memPrice = BigNumber(this._protocolParams.priceMem);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.stepFee",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.stepFee",
      "name": "stepFee",
      "type": "any",
      "value": "stepPrice.multipliedBy(BigNumber(stepUnits.toString()));",
      "isPublic": true,
      "line": 1716,
      "raw": "const stepFee = stepPrice.multipliedBy(BigNumber(stepUnits.toString()));",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.memFee",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.memFee",
      "name": "memFee",
      "type": "any",
      "value": "memPrice.multipliedBy(BigNumber(memUnits.toString()));",
      "isPublic": true,
      "line": 1717,
      "raw": "const memFee = memPrice.multipliedBy(BigNumber(memUnits.toString()));",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.newBuilder",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.newBuilder",
      "name": "newBuilder",
      "type": "any",
      "value": "super._cloneCore<MeshTxBuilder>(() => {",
      "isPublic": true,
      "line": 1728,
      "raw": "const newBuilder = super._cloneCore<MeshTxBuilder>(() => {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.multiplier",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.multiplier",
      "name": "multiplier",
      "type": "any",
      "value": "new BigNumber(12).dividedBy(new BigNumber(10)); // 1.2",
      "isPublic": true,
      "line": 1754,
      "raw": "const multiplier = new BigNumber(12).dividedBy(new BigNumber(10)); // 1.2",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.sizeIncrement",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.sizeIncrement",
      "name": "sizeIncrement",
      "type": "any",
      "value": "new BigNumber(25600);",
      "isPublic": true,
      "line": 1755,
      "raw": "const sizeIncrement = new BigNumber(25600);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.baseFee",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.baseFee",
      "name": "baseFee",
      "type": "any",
      "value": "new BigNumber(refScriptCoinsPerByte);",
      "isPublic": true,
      "line": 1756,
      "raw": "const baseFee = new BigNumber(refScriptCoinsPerByte);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.totalSize",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.totalSize",
      "name": "totalSize",
      "type": "any",
      "value": "new BigNumber(totalRefScriptsSize.toString());",
      "isPublic": true,
      "line": 1758,
      "raw": "const totalSize = new BigNumber(totalRefScriptsSize.toString());",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.fullTiers",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.fullTiers",
      "name": "fullTiers",
      "type": "any",
      "value": "totalSize.dividedToIntegerBy(sizeIncrement);",
      "isPublic": true,
      "line": 1773,
      "raw": "const fullTiers = totalSize.dividedToIntegerBy(sizeIncrement);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.partialTierSize",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.partialTierSize",
      "name": "partialTierSize",
      "type": "any",
      "value": "totalSize.mod(sizeIncrement);",
      "isPublic": true,
      "line": 1774,
      "raw": "const partialTierSize = totalSize.mod(sizeIncrement);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.tierPrice",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.tierPrice",
      "name": "tierPrice",
      "type": "any",
      "value": "baseFee.multipliedBy(sizeIncrement);",
      "isPublic": true,
      "line": 1776,
      "raw": "const tierPrice = baseFee.multipliedBy(sizeIncrement);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.one",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.one",
      "name": "one",
      "type": "any",
      "value": "new BigNumber(1);",
      "isPublic": true,
      "line": 1778,
      "raw": "const one = new BigNumber(1);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.multiplierPow",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.multiplierPow",
      "name": "multiplierPow",
      "type": "any",
      "value": "multiplier.pow(fullTiers.toNumber());",
      "isPublic": true,
      "line": 1790,
      "raw": "const multiplierPow = multiplier.pow(fullTiers.toNumber());",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.progressionEnumerator",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.progressionEnumerator",
      "name": "progressionEnumerator",
      "type": "any",
      "value": "one.minus(multiplierPow);",
      "isPublic": true,
      "line": 1782,
      "raw": "const progressionEnumerator = one.minus(multiplierPow);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.progressionDenom",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.progressionDenom",
      "name": "progressionDenom",
      "type": "any",
      "value": "one.minus(multiplier);",
      "isPublic": true,
      "line": 1783,
      "raw": "const progressionDenom = one.minus(multiplier);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.lastTierPrice",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.lastTierPrice",
      "name": "lastTierPrice",
      "type": "any",
      "value": "baseFee.multipliedBy(multiplierPow);",
      "isPublic": true,
      "line": 1791,
      "raw": "const lastTierPrice = baseFee.multipliedBy(multiplierPow);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.partialTierFee",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.partialTierFee",
      "name": "partialTierFee",
      "type": "any",
      "value": "lastTierPrice.multipliedBy(partialTierSize);",
      "isPublic": true,
      "line": 1792,
      "raw": "const partialTierFee = lastTierPrice.multipliedBy(partialTierSize);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.cloneOutput",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.cloneOutput",
      "name": "cloneOutput",
      "type": "any",
      "value": "(output: Output): Output => {",
      "isPublic": true,
      "line": 1799,
      "raw": "export const cloneOutput = (output: Output): Output => {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.setLoveLace",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.setLoveLace",
      "name": "setLoveLace",
      "type": "any",
      "value": "(output: Output, lovelace: bigint): Output => {",
      "isPublic": true,
      "line": 1803,
      "raw": "export const setLoveLace = (output: Output, lovelace: bigint): Output => {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.getLovelace",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.getLovelace",
      "name": "getLovelace",
      "type": "any",
      "value": "(output: Output): bigint => {",
      "isPublic": true,
      "line": 1822,
      "raw": "export const getLovelace = (output: Output): bigint => {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.getOutputMinLovelace",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.getOutputMinLovelace",
      "name": "getOutputMinLovelace",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 1831,
      "raw": "export const getOutputMinLovelace = (",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.serializer",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.serializer",
      "name": "serializer",
      "type": "any",
      "value": "new CardanoSDKSerializer();",
      "isPublic": true,
      "line": 1835,
      "raw": "const serializer = new CardanoSDKSerializer();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.txOutSize",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.txOutSize",
      "name": "txOutSize",
      "type": "any",
      "value": "BigInt(",
      "isPublic": true,
      "line": 1840,
      "raw": "const txOutSize = BigInt(",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.txOutByteCost",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.txOutByteCost",
      "name": "txOutByteCost",
      "type": "any",
      "value": "BigInt(coinsPerUtxoSize);",
      "isPublic": true,
      "line": 1843,
      "raw": "const txOutByteCost = BigInt(coinsPerUtxoSize);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.index.ts.totalOutCost",
      "fullName": "mesh-transaction:mesh-tx-builder.index.ts.totalOutCost",
      "name": "totalOutCost",
      "type": "any",
      "value": "(160n + BigInt(txOutSize)) * txOutByteCost;",
      "isPublic": true,
      "line": 1844,
      "raw": "const totalOutCost = (160n + BigInt(txOutSize)) * txOutByteCost;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.withdrawal",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.withdrawal",
      "name": "withdrawal",
      "type": "Withdrawal",
      "value": "{",
      "isPublic": true,
      "line": 838,
      "raw": "const withdrawal: Withdrawal = {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.vote",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.vote",
      "name": "vote",
      "type": "any",
      "value": "meshTxBuilderBody.votes[redeemerEvaluation.index];",
      "isPublic": true,
      "line": 1834,
      "raw": "const vote = meshTxBuilderBody.votes[redeemerEvaluation.index];",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.currentCert",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.currentCert",
      "name": "currentCert",
      "type": "any",
      "value": "this.meshTxBuilderBody.certificates.pop();",
      "isPublic": true,
      "line": 1373,
      "raw": "const currentCert = this.meshTxBuilderBody.certificates.pop();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.address",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.address",
      "name": "address",
      "type": "any",
      "value": "input.output.address;",
      "isPublic": true,
      "line": 1459,
      "raw": "const address = input.output.address;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.decodedAddress",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.decodedAddress",
      "name": "decodedAddress",
      "type": "any",
      "value": "Address.fromString(<HexBlob>address);",
      "isPublic": true,
      "line": 1463,
      "raw": "const decodedAddress = Address.fromString(<HexBlob>address);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.updatedParams",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.updatedParams",
      "name": "updatedParams",
      "type": "any",
      "value": "{ ...DEFAULT_PROTOCOL_PARAMETERS, ...params };",
      "isPublic": true,
      "line": 1483,
      "raw": "const updatedParams = { ...DEFAULT_PROTOCOL_PARAMETERS, ...params };",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.utxoId",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.utxoId",
      "name": "utxoId",
      "type": "any",
      "value": "`${input.input.txHash}${input.input.outputIndex}`;",
      "isPublic": true,
      "line": 1546,
      "raw": "const utxoId = `${input.input.txHash}${input.input.outputIndex}`;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.currentUtxo",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.currentUtxo",
      "name": "currentUtxo",
      "type": "any",
      "value": "this.meshTxBuilderBody.inputsForEvaluation[utxoId];",
      "isPublic": true,
      "line": 1547,
      "raw": "const currentUtxo = this.meshTxBuilderBody.inputsForEvaluation[utxoId];",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.updatedUtxo",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.updatedUtxo",
      "name": "updatedUtxo",
      "type": "UTxO",
      "value": "{ ...currentUtxo };",
      "isPublic": true,
      "line": 1557,
      "raw": "const updatedUtxo: UTxO = { ...currentUtxo };",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.currentMint",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.currentMint",
      "name": "currentMint",
      "type": "MintItem",
      "value": "this.mintItem;",
      "isPublic": true,
      "line": 1623,
      "raw": "const currentMint: MintItem = this.mintItem;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.txEvaluationMultiplier",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.txEvaluationMultiplier",
      "name": "txEvaluationMultiplier",
      "type": "any",
      "value": "doNotUseMultiplier",
      "isPublic": true,
      "line": 1748,
      "raw": "const txEvaluationMultiplier = doNotUseMultiplier",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.input",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.input",
      "name": "input",
      "type": "any",
      "value": "meshTxBuilderBody.inputs[redeemerEvaluation.index];",
      "isPublic": true,
      "line": 1754,
      "raw": "const input = meshTxBuilderBody.inputs[redeemerEvaluation.index];",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.mint",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.mint",
      "name": "mint",
      "type": "any",
      "value": "meshTxBuilderBody.mints[redeemerEvaluation.index];",
      "isPublic": true,
      "line": 1771,
      "raw": "const mint = meshTxBuilderBody.mints[redeemerEvaluation.index];",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.cert",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.cert",
      "name": "cert",
      "type": "any",
      "value": "meshTxBuilderBody.certificates[redeemerEvaluation.index];",
      "isPublic": true,
      "line": 1801,
      "raw": "const cert = meshTxBuilderBody.certificates[redeemerEvaluation.index];",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.requiredAssets",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.requiredAssets",
      "name": "requiredAssets",
      "type": "any",
      "value": "this.meshTxBuilderBody.outputs.reduce(",
      "isPublic": true,
      "line": 1854,
      "raw": "const requiredAssets = this.meshTxBuilderBody.outputs.reduce(",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.outputAmount",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.outputAmount",
      "name": "outputAmount",
      "type": "any",
      "value": "output.amount;",
      "isPublic": true,
      "line": 1856,
      "raw": "const outputAmount = output.amount;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.existingQuantity",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.existingQuantity",
      "name": "existingQuantity",
      "type": "any",
      "value": "Number(map.get(mintAmount.unit)) || 0;",
      "isPublic": true,
      "line": 1881,
      "raw": "const existingQuantity = Number(map.get(mintAmount.unit)) || 0;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.inputAmount",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.inputAmount",
      "name": "inputAmount",
      "type": "any",
      "value": "input.txIn.amount;",
      "isPublic": true,
      "line": 1867,
      "raw": "const inputAmount = input.txIn.amount;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.mintAmount",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.mintAmount",
      "name": "mintAmount",
      "type": "Asset",
      "value": "{",
      "isPublic": true,
      "line": 1877,
      "raw": "const mintAmount: Asset = {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.selectionConfig",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.selectionConfig",
      "name": "selectionConfig",
      "type": "any",
      "value": "this.meshTxBuilderBody.selectionConfig;",
      "isPublic": true,
      "line": 1889,
      "raw": "const selectionConfig = this.meshTxBuilderBody.selectionConfig;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.utxoSelection",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.utxoSelection",
      "name": "utxoSelection",
      "type": "any",
      "value": "new UtxoSelection(",
      "isPublic": true,
      "line": 1891,
      "raw": "const utxoSelection = new UtxoSelection(",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.pubKeyTxIn",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.pubKeyTxIn",
      "name": "pubKeyTxIn",
      "type": "PubKeyTxIn",
      "value": "{",
      "isPublic": true,
      "line": 1926,
      "raw": "const pubKeyTxIn: PubKeyTxIn = {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.getTxInId",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.getTxInId",
      "name": "getTxInId",
      "type": "any",
      "value": "(txIn: RefTxIn): string =>",
      "isPublic": true,
      "line": 1970,
      "raw": "const getTxInId = (txIn: RefTxIn): string =>",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.currentTxInIds",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.currentTxInIds",
      "name": "currentTxInIds",
      "type": "string[]",
      "value": "[];",
      "isPublic": true,
      "line": 1972,
      "raw": "const currentTxInIds: string[] = [];",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.addedInputs",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.addedInputs",
      "name": "addedInputs",
      "type": "RefTxIn[]",
      "value": "[];",
      "isPublic": true,
      "line": 1973,
      "raw": "const addedInputs: RefTxIn[] = [];",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.currentInput",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.currentInput",
      "name": "currentInput",
      "type": "any",
      "value": "referenceInputs[i]!;",
      "isPublic": true,
      "line": 1975,
      "raw": "const currentInput = referenceInputs[i]!;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.currentTxInId",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.currentTxInId",
      "name": "currentTxInId",
      "type": "any",
      "value": "getTxInId(currentInput);",
      "isPublic": true,
      "line": 1976,
      "raw": "const currentTxInId = getTxInId(currentInput);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.newBuilder",
      "fullName": "mesh-transaction:mesh-tx-builder.tx-builder-core.ts.newBuilder",
      "name": "newBuilder",
      "type": "any",
      "value": "createInstance();",
      "isPublic": true,
      "line": 2017,
      "raw": "const newBuilder = createInstance();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.utils.ts.utxoToTxIn",
      "fullName": "mesh-transaction:mesh-tx-builder.utils.ts.utxoToTxIn",
      "name": "utxoToTxIn",
      "type": "any",
      "value": "(utxo: UTxO): [string, number, Asset[], string] => {",
      "isPublic": true,
      "line": 19,
      "raw": "export const utxoToTxIn = (utxo: UTxO): [string, number, Asset[], string] => {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.utils.ts.getUtxoMinLovelace",
      "fullName": "mesh-transaction:mesh-tx-builder.utils.ts.getUtxoMinLovelace",
      "name": "getUtxoMinLovelace",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 34,
      "raw": "export const getUtxoMinLovelace = (",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.utils.ts.referenceScript",
      "fullName": "mesh-transaction:mesh-tx-builder.utils.ts.referenceScript",
      "name": "referenceScript",
      "type": "PlutusScript | undefined",
      "value": "utxo.scriptRef",
      "isPublic": true,
      "line": 38,
      "raw": "const referenceScript: PlutusScript | undefined = utxo.scriptRef",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.utils.ts.output",
      "fullName": "mesh-transaction:mesh-tx-builder.utils.ts.output",
      "name": "output",
      "type": "Output",
      "value": "{",
      "isPublic": true,
      "line": 67,
      "raw": "const output: Output = {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:mesh-tx-builder.utils.ts.minLovelace",
      "fullName": "mesh-transaction:mesh-tx-builder.utils.ts.minLovelace",
      "name": "minLovelace",
      "type": "any",
      "value": "getOutputMinLovelace(output, coinsPerUtxoSize);",
      "isPublic": true,
      "line": 73,
      "raw": "const minLovelace = getOutputMinLovelace(output, coinsPerUtxoSize);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:scripts.forge.script.ts.keyHash",
      "fullName": "mesh-transaction:scripts.forge.script.ts.keyHash",
      "name": "keyHash",
      "type": "any",
      "value": "deserializeEd25519KeyHash(resolvePaymentKeyHash(address));",
      "isPublic": true,
      "line": 12,
      "raw": "const keyHash = deserializeEd25519KeyHash(resolvePaymentKeyHash(address));",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.tx",
      "fullName": "mesh-transaction:transaction.index.ts.tx",
      "name": "tx",
      "type": "any",
      "value": "deserializeTx(cborTx);",
      "isPublic": true,
      "line": 112,
      "raw": "const tx = deserializeTx(cborTx);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.txAuxData",
      "fullName": "mesh-transaction:transaction.index.ts.txAuxData",
      "name": "txAuxData",
      "type": "any",
      "value": "tx.auxiliaryData() ?? new Serialization.AuxiliaryData();",
      "isPublic": true,
      "line": 113,
      "raw": "const txAuxData = tx.auxiliaryData() ?? new Serialization.AuxiliaryData();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.txMetadata",
      "fullName": "mesh-transaction:transaction.index.ts.txMetadata",
      "name": "txMetadata",
      "type": "any",
      "value": "tx.auxiliaryData()?.metadata();",
      "isPublic": true,
      "line": 85,
      "raw": "const txMetadata = tx.auxiliaryData()?.metadata();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.mockMetadata",
      "fullName": "mesh-transaction:transaction.index.ts.mockMetadata",
      "name": "mockMetadata",
      "type": "any",
      "value": "new Map<",
      "isPublic": true,
      "line": 88,
      "raw": "const mockMetadata = new Map<",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.assets",
      "fullName": "mesh-transaction:transaction.index.ts.assets",
      "name": "assets",
      "type": "any",
      "value": "value.output.amount;",
      "isPublic": true,
      "line": 217,
      "raw": "const assets = value.output.amount;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.red",
      "fullName": "mesh-transaction:transaction.index.ts.red",
      "name": "red",
      "type": "any",
      "value": "redeemer || {",
      "isPublic": true,
      "line": 298,
      "raw": "const red = redeemer || {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.scriptRef",
      "fullName": "mesh-transaction:transaction.index.ts.scriptRef",
      "name": "scriptRef",
      "type": "any",
      "value": "fromScriptRef(script.output.scriptRef);",
      "isPublic": true,
      "line": 323,
      "raw": "const scriptRef = fromScriptRef(script.output.scriptRef);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.assetQuantity",
      "fullName": "mesh-transaction:transaction.index.ts.assetQuantity",
      "name": "assetQuantity",
      "type": "any",
      "value": "\"-\" + asset.quantity;",
      "isPublic": true,
      "line": 529,
      "raw": "const assetQuantity = \"-\" + asset.quantity;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.referenceAssetNameHex",
      "fullName": "mesh-transaction:transaction.index.ts.referenceAssetNameHex",
      "name": "referenceAssetNameHex",
      "type": "any",
      "value": "CIP68_100(assetNameHex);",
      "isPublic": true,
      "line": 374,
      "raw": "const referenceAssetNameHex = CIP68_100(assetNameHex);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.script",
      "fullName": "mesh-transaction:transaction.index.ts.script",
      "name": "script",
      "type": "any",
      "value": "fromScriptRef(forgeScript.output.scriptRef);",
      "isPublic": true,
      "line": 425,
      "raw": "const script = fromScriptRef(forgeScript.output.scriptRef);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.mint",
      "fullName": "mesh-transaction:transaction.index.ts.mint",
      "name": "mint",
      "type": "Mint",
      "value": "{",
      "isPublic": true,
      "line": 530,
      "raw": "const mint: Mint = {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.collaterals",
      "fullName": "mesh-transaction:transaction.index.ts.collaterals",
      "name": "collaterals",
      "type": "any",
      "value": "await this.initiator.getCollateral();",
      "isPublic": true,
      "line": 763,
      "raw": "const collaterals = await this.initiator.getCollateral();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.utxos",
      "fullName": "mesh-transaction:transaction.index.ts.utxos",
      "name": "utxos",
      "type": "any",
      "value": "await this.initiator.getUtxos();",
      "isPublic": true,
      "line": 795,
      "raw": "const utxos = await this.initiator.getUtxos();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.pureLovelaceUtxos",
      "fullName": "mesh-transaction:transaction.index.ts.pureLovelaceUtxos",
      "name": "pureLovelaceUtxos",
      "type": "any",
      "value": "utxos.filter(",
      "isPublic": true,
      "line": 769,
      "raw": "const pureLovelaceUtxos = utxos.filter(",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.changeAddress",
      "fullName": "mesh-transaction:transaction.index.ts.changeAddress",
      "name": "changeAddress",
      "type": "any",
      "value": "await this.initiator.getChangeAddress();",
      "isPublic": true,
      "line": 802,
      "raw": "const changeAddress = await this.initiator.getChangeAddress();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.list",
      "fullName": "mesh-transaction:transaction.index.ts.list",
      "name": "list",
      "type": "any",
      "value": "new Serialization.MetadatumList();",
      "isPublic": true,
      "line": 820,
      "raw": "const list = new Serialization.MetadatumList();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.map",
      "fullName": "mesh-transaction:transaction.index.ts.map",
      "name": "map",
      "type": "any",
      "value": "new Serialization.MetadatumMap();",
      "isPublic": true,
      "line": 826,
      "raw": "const map = new Serialization.MetadatumMap();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.key",
      "fullName": "mesh-transaction:transaction.index.ts.key",
      "name": "key",
      "type": "any",
      "value": "metadatum.asMap()?.getKeys().get(i)!;",
      "isPublic": true,
      "line": 828,
      "raw": "const key = metadatum.asMap()?.getKeys().get(i)!;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:transaction.index.ts.value",
      "fullName": "mesh-transaction:transaction.index.ts.value",
      "name": "value",
      "type": "any",
      "value": "metadatum.asMap()?.get(key)!;",
      "isPublic": true,
      "line": 829,
      "raw": "const value = metadatum.asMap()?.get(key)!;",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:tx-parser.index.ts.resolvedUtxos",
      "fullName": "mesh-transaction:tx-parser.index.ts.resolvedUtxos",
      "name": "resolvedUtxos",
      "type": "UTxO[]",
      "value": "[...providedUtxos];",
      "isPublic": true,
      "line": 15,
      "raw": "const resolvedUtxos: UTxO[] = [...providedUtxos];",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:tx-parser.index.ts.resolvedUtxosSet",
      "fullName": "mesh-transaction:tx-parser.index.ts.resolvedUtxosSet",
      "name": "resolvedUtxosSet",
      "type": "Set<string>",
      "value": "new Set(",
      "isPublic": true,
      "line": 17,
      "raw": "const resolvedUtxosSet: Set<string> = new Set(",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:tx-parser.index.ts.toResolveUtxos",
      "fullName": "mesh-transaction:tx-parser.index.ts.toResolveUtxos",
      "name": "toResolveUtxos",
      "type": "Record<string, number[]>",
      "value": "{};",
      "isPublic": true,
      "line": 22,
      "raw": "const toResolveUtxos: Record<string, number[]> = {};",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:tx-parser.index.ts.fetchResult",
      "fullName": "mesh-transaction:tx-parser.index.ts.fetchResult",
      "name": "fetchResult",
      "type": "Record<string, UTxO[]>",
      "value": "{};",
      "isPublic": true,
      "line": 23,
      "raw": "const fetchResult: Record<string, UTxO[]> = {};",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:tx-parser.index.ts.outputIndices",
      "fullName": "mesh-transaction:tx-parser.index.ts.outputIndices",
      "name": "outputIndices",
      "type": "any",
      "value": "toResolveUtxos[txHash];",
      "isPublic": true,
      "line": 37,
      "raw": "const outputIndices = toResolveUtxos[txHash];",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:tx-parser.index.ts.utxos",
      "fullName": "mesh-transaction:tx-parser.index.ts.utxos",
      "name": "utxos",
      "type": "any",
      "value": "await this.fetcher.fetchUTxOs(txHash);",
      "isPublic": true,
      "line": 43,
      "raw": "const utxos = await this.fetcher.fetchUTxOs(txHash);",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:tx-parser.index.ts.utxoData",
      "fullName": "mesh-transaction:tx-parser.index.ts.utxoData",
      "name": "utxoData",
      "type": "any",
      "value": "utxos.find(",
      "isPublic": true,
      "line": 45,
      "raw": "const utxoData = utxos.find(",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:utils.metadata.ts.metadataObjToMap",
      "fullName": "mesh-transaction:utils.metadata.ts.metadataObjToMap",
      "name": "metadataObjToMap",
      "type": "any",
      "value": "(metadata: any): Metadatum => {",
      "isPublic": true,
      "line": 7,
      "raw": "export const metadataObjToMap = (metadata: any): Metadatum => {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:utils.metadata.ts.map",
      "fullName": "mesh-transaction:utils.metadata.ts.map",
      "name": "map",
      "type": "MetadatumMap",
      "value": "new Map();",
      "isPublic": true,
      "line": 21,
      "raw": "const map: MetadatumMap = new Map();",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:utils.metadata.ts.mergeContents",
      "fullName": "mesh-transaction:utils.metadata.ts.mergeContents",
      "name": "mergeContents",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 62,
      "raw": "export const mergeContents = (",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:utils.metadata.ts.getMergeDepth",
      "fullName": "mesh-transaction:utils.metadata.ts.getMergeDepth",
      "name": "getMergeDepth",
      "type": "any",
      "value": "(mergeOption: MetadataMergeLevel): number => {",
      "isPublic": true,
      "line": 126,
      "raw": "const getMergeDepth = (mergeOption: MetadataMergeLevel): number => {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:utils.metadata.ts.getMetadatumType",
      "fullName": "mesh-transaction:utils.metadata.ts.getMetadatumType",
      "name": "getMetadatumType",
      "type": "any",
      "value": "(a: Metadatum): string => {",
      "isPublic": true,
      "line": 134,
      "raw": "const getMetadatumType = (a: Metadatum): string => {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-transaction:utils.metadata.ts.areUint8ArraysEqual",
      "fullName": "mesh-transaction:utils.metadata.ts.areUint8ArraysEqual",
      "name": "areUint8ArraysEqual",
      "type": "any",
      "value": "(a: Uint8Array, b: Uint8Array): boolean => {",
      "isPublic": true,
      "line": 140,
      "raw": "const areUint8ArraysEqual = (a: Uint8Array, b: Uint8Array): boolean => {",
      "source": "mesh-transaction"
    },
    {
      "key": "mesh-wallet:app.index.ts.utxos",
      "fullName": "mesh-wallet:app.index.ts.utxos",
      "name": "utxos",
      "type": "any",
      "value": "await this._fetcher.fetchAddressUTxOs(",
      "isPublic": true,
      "line": 162,
      "raw": "const utxos = await this._fetcher.fetchAddressUTxOs(",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:app.index.ts.pureAdaUtxos",
      "fullName": "mesh-wallet:app.index.ts.pureAdaUtxos",
      "name": "pureAdaUtxos",
      "type": "any",
      "value": "utxos.filter((utxo) => {",
      "isPublic": true,
      "line": 99,
      "raw": "const pureAdaUtxos = utxos.filter((utxo) => {",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:app.index.ts.account",
      "fullName": "mesh-wallet:app.index.ts.account",
      "name": "account",
      "type": "any",
      "value": "this._wallet.getAccount(accountIndex);",
      "isPublic": true,
      "line": 160,
      "raw": "const account = this._wallet.getAccount(accountIndex);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:app.index.ts.tx",
      "fullName": "mesh-wallet:app.index.ts.tx",
      "name": "tx",
      "type": "any",
      "value": "deserializeTx(unsignedTx);",
      "isPublic": true,
      "line": 193,
      "raw": "const tx = deserializeTx(unsignedTx);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:app.index.ts.newSignatures",
      "fullName": "mesh-wallet:app.index.ts.newSignatures",
      "name": "newSignatures",
      "type": "any",
      "value": "this._wallet.signTx(",
      "isPublic": true,
      "line": 203,
      "raw": "const newSignatures = this._wallet.signTx(",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts._wallet",
      "fullName": "mesh-wallet:browser.browser-wallet.ts._wallet",
      "name": "_wallet",
      "type": "any",
      "value": "window.cardano[key];",
      "isPublic": true,
      "line": 103,
      "raw": "const _wallet = window.cardano[key];",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.walletInstance",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.walletInstance",
      "name": "walletInstance",
      "type": "any",
      "value": "await BrowserWallet.resolveInstance(",
      "isPublic": true,
      "line": 134,
      "raw": "const walletInstance = await BrowserWallet.resolveInstance(",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.balance",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.balance",
      "name": "balance",
      "type": "any",
      "value": "await this.getBalance();",
      "isPublic": true,
      "line": 471,
      "raw": "const balance = await this.getBalance();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.changeAddress",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.changeAddress",
      "name": "changeAddress",
      "type": "any",
      "value": "await this._walletInstance.getChangeAddress();",
      "isPublic": true,
      "line": 170,
      "raw": "const changeAddress = await this._walletInstance.getChangeAddress();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.deserializedCollateral",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.deserializedCollateral",
      "name": "deserializedCollateral",
      "type": "any",
      "value": "await this.getCollateralUnspentOutput();",
      "isPublic": true,
      "line": 183,
      "raw": "const deserializedCollateral = await this.getCollateralUnspentOutput();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.rewardAddresses",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.rewardAddresses",
      "name": "rewardAddresses",
      "type": "any",
      "value": "await this._walletInstance.getRewardAddresses();",
      "isPublic": true,
      "line": 217,
      "raw": "const rewardAddresses = await this._walletInstance.getRewardAddresses();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.unusedAddresses",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.unusedAddresses",
      "name": "unusedAddresses",
      "type": "any",
      "value": "await this._walletInstance.getUnusedAddresses();",
      "isPublic": true,
      "line": 227,
      "raw": "const unusedAddresses = await this._walletInstance.getUnusedAddresses();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.usedAddresses",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.usedAddresses",
      "name": "usedAddresses",
      "type": "any",
      "value": "await this._walletInstance.getUsedAddresses();",
      "isPublic": true,
      "line": 377,
      "raw": "const usedAddresses = await this._walletInstance.getUsedAddresses();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.deserializedUTxOs",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.deserializedUTxOs",
      "name": "deserializedUTxOs",
      "type": "any",
      "value": "await this.getUsedUTxOs();",
      "isPublic": true,
      "line": 249,
      "raw": "const deserializedUTxOs = await this.getUsedUTxOs();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts._payload",
      "fullName": "mesh-wallet:browser.browser-wallet.ts._payload",
      "name": "_payload",
      "type": "any",
      "value": "convertFromUTF8 ? fromUTF8(payload) : payload;",
      "isPublic": true,
      "line": 272,
      "raw": "const _payload = convertFromUTF8 ? fromUTF8(payload) : payload;",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.signerAddress",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.signerAddress",
      "name": "signerAddress",
      "type": "any",
      "value": "toAddress(address).toBytes().toString();",
      "isPublic": true,
      "line": 278,
      "raw": "const signerAddress = toAddress(address).toBytes().toString();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.witness",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.witness",
      "name": "witness",
      "type": "any",
      "value": "await this._walletInstance.signTx(unsignedTx, partialSign);",
      "isPublic": true,
      "line": 290,
      "raw": "const witness = await this._walletInstance.signTx(unsignedTx, partialSign);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.signedTxs",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.signedTxs",
      "name": "signedTxs",
      "type": "string[]",
      "value": "[];",
      "isPublic": true,
      "line": 337,
      "raw": "const signedTxs: string[] = [];",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.unsignedTx",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.unsignedTx",
      "name": "unsignedTx",
      "type": "any",
      "value": "unsignedTxs[i]!;",
      "isPublic": true,
      "line": 339,
      "raw": "const unsignedTx = unsignedTxs[i]!;",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.cWitness",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.cWitness",
      "name": "cWitness",
      "type": "any",
      "value": "Serialization.TransactionWitnessSet.fromCbor(",
      "isPublic": true,
      "line": 625,
      "raw": "const cWitness = Serialization.TransactionWitnessSet.fromCbor(",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.signedTx",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.signedTx",
      "name": "signedTx",
      "type": "any",
      "value": "BrowserWallet.addBrowserWitnesses(",
      "isPublic": true,
      "line": 346,
      "raw": "const signedTx = BrowserWallet.addBrowserWitnesses(",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.utxos",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.utxos",
      "name": "utxos",
      "type": "any",
      "value": "(await this._walletInstance.getUtxos()) ?? [];",
      "isPublic": true,
      "line": 414,
      "raw": "const utxos = (await this._walletInstance.getUtxos()) ?? [];",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.policyId",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.policyId",
      "name": "policyId",
      "type": "any",
      "value": "v.unit.slice(0, POLICY_ID_LENGTH);",
      "isPublic": true,
      "line": 428,
      "raw": "const policyId = v.unit.slice(0, POLICY_ID_LENGTH);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.assetName",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.assetName",
      "name": "assetName",
      "type": "any",
      "value": "v.unit.slice(POLICY_ID_LENGTH);",
      "isPublic": true,
      "line": 429,
      "raw": "const assetName = v.unit.slice(POLICY_ID_LENGTH);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.fingerprint",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.fingerprint",
      "name": "fingerprint",
      "type": "any",
      "value": "resolveFingerprint(policyId, assetName);",
      "isPublic": true,
      "line": 430,
      "raw": "const fingerprint = resolveFingerprint(policyId, assetName);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.nativeAsset",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.nativeAsset",
      "name": "nativeAsset",
      "type": "any",
      "value": "balance.find((v) => v.unit === \"lovelace\");",
      "isPublic": true,
      "line": 449,
      "raw": "const nativeAsset = balance.find((v) => v.unit === \"lovelace\");",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.assets",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.assets",
      "name": "assets",
      "type": "any",
      "value": "await this.getAssets();",
      "isPublic": true,
      "line": 461,
      "raw": "const assets = await this.getAssets();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.pubDRepKey",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.pubDRepKey",
      "name": "pubDRepKey",
      "type": "any",
      "value": "await this._walletInstance.cip95.getPubDRepKey();",
      "isPublic": true,
      "line": 523,
      "raw": "const pubDRepKey = await this._walletInstance.cip95.getPubDRepKey();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.dRepIDCip105",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.dRepIDCip105",
      "name": "dRepIDCip105",
      "type": "any",
      "value": "hexToBech32(\"drep\", dRepIDHash);",
      "isPublic": true,
      "line": 497,
      "raw": "const dRepIDCip105 = hexToBech32(\"drep\", dRepIDHash);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.pubStakeKeyHashes",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.pubStakeKeyHashes",
      "name": "pubStakeKeyHashes",
      "type": "any",
      "value": "await Promise.all(",
      "isPublic": true,
      "line": 575,
      "raw": "const pubStakeKeyHashes = await Promise.all(",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.dRepKeyHex",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.dRepKeyHex",
      "name": "dRepKeyHex",
      "type": "any",
      "value": "Ed25519PublicKeyHex(dRepKey);",
      "isPublic": true,
      "line": 598,
      "raw": "const dRepKeyHex = Ed25519PublicKeyHex(dRepKey);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.dRepID",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.dRepID",
      "name": "dRepID",
      "type": "any",
      "value": "Ed25519PublicKey.fromHex(dRepKeyHex);",
      "isPublic": true,
      "line": 599,
      "raw": "const dRepID = Ed25519PublicKey.fromHex(dRepKeyHex);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.dRepIDHash",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.dRepIDHash",
      "name": "dRepIDHash",
      "type": "any",
      "value": "(await dRepID.hash()).hex();",
      "isPublic": true,
      "line": 600,
      "raw": "const dRepIDHash = (await dRepID.hash()).hex();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts.wallet",
      "fullName": "mesh-wallet:browser.browser-wallet.ts.wallet",
      "name": "wallet",
      "type": "any",
      "value": "window.cardano[walletName];",
      "isPublic": true,
      "line": 615,
      "raw": "const wallet = window.cardano[walletName];",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.browser-wallet.ts._supportedExtensions",
      "fullName": "mesh-wallet:browser.browser-wallet.ts._supportedExtensions",
      "name": "_supportedExtensions",
      "type": "any",
      "value": "window?.cardano?.[wallet]?.supportedExtensions;",
      "isPublic": true,
      "line": 653,
      "raw": "const _supportedExtensions = window?.cardano?.[wallet]?.supportedExtensions;",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.connect.ts.responseRegister",
      "fullName": "mesh-wallet:browser.webauthn.auth.connect.ts.responseRegister",
      "name": "responseRegister",
      "type": "any",
      "value": "await register({ serverUrl, username });",
      "isPublic": true,
      "line": 15,
      "raw": "const responseRegister = await register({ serverUrl, username });",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.connect.ts.loginRes",
      "fullName": "mesh-wallet:browser.webauthn.auth.connect.ts.loginRes",
      "name": "loginRes",
      "type": "any",
      "value": "await handleLogin({ serverUrl, username });",
      "isPublic": true,
      "line": 20,
      "raw": "const loginRes = await handleLogin({ serverUrl, username });",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.connect.ts.wallet",
      "fullName": "mesh-wallet:browser.webauthn.auth.connect.ts.wallet",
      "name": "wallet",
      "type": "any",
      "value": "await buildWalletFromPasskey(",
      "isPublic": true,
      "line": 22,
      "raw": "const wallet = await buildWalletFromPasskey(",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.connect.ts.responseLogin",
      "fullName": "mesh-wallet:browser.webauthn.auth.connect.ts.responseLogin",
      "name": "responseLogin",
      "type": "any",
      "value": "await login({ serverUrl, username });",
      "isPublic": true,
      "line": 41,
      "raw": "const responseLogin = await login({ serverUrl, username });",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.connect.ts.authJSON",
      "fullName": "mesh-wallet:browser.webauthn.auth.connect.ts.authJSON",
      "name": "authJSON",
      "type": "any",
      "value": "responseLogin.authJSON;",
      "isPublic": true,
      "line": 43,
      "raw": "const authJSON = responseLogin.authJSON;",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.login.ts.initAuthRes",
      "fullName": "mesh-wallet:browser.webauthn.auth.login.ts.initAuthRes",
      "name": "initAuthRes",
      "type": "any",
      "value": "await fetch(`${serverUrl}/auth-init`, {",
      "isPublic": true,
      "line": 11,
      "raw": "const initAuthRes = await fetch(`${serverUrl}/auth-init`, {",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.login.ts.initAuth",
      "fullName": "mesh-wallet:browser.webauthn.auth.login.ts.initAuth",
      "name": "initAuth",
      "type": "any",
      "value": "await initAuthRes.json();",
      "isPublic": true,
      "line": 22,
      "raw": "const initAuth = await initAuthRes.json();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.login.ts.optionsJSON",
      "fullName": "mesh-wallet:browser.webauthn.auth.login.ts.optionsJSON",
      "name": "optionsJSON",
      "type": "any",
      "value": "initAuth.data.optionsJSON;",
      "isPublic": true,
      "line": 31,
      "raw": "const optionsJSON = initAuth.data.optionsJSON;",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.login.ts.authJSON",
      "fullName": "mesh-wallet:browser.webauthn.auth.login.ts.authJSON",
      "name": "authJSON",
      "type": "any",
      "value": "await startAuthentication({ optionsJSON });",
      "isPublic": true,
      "line": 34,
      "raw": "const authJSON = await startAuthentication({ optionsJSON });",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.login.ts.verifyAuthRes",
      "fullName": "mesh-wallet:browser.webauthn.auth.login.ts.verifyAuthRes",
      "name": "verifyAuthRes",
      "type": "any",
      "value": "await fetch(`${serverUrl}/auth-verify`, {",
      "isPublic": true,
      "line": 37,
      "raw": "const verifyAuthRes = await fetch(`${serverUrl}/auth-verify`, {",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.login.ts.verifyAuth",
      "fullName": "mesh-wallet:browser.webauthn.auth.login.ts.verifyAuth",
      "name": "verifyAuth",
      "type": "any",
      "value": "await verifyAuthRes.json();",
      "isPublic": true,
      "line": 46,
      "raw": "const verifyAuth = await verifyAuthRes.json();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.register.ts.initRegisterRes",
      "fullName": "mesh-wallet:browser.webauthn.auth.register.ts.initRegisterRes",
      "name": "initRegisterRes",
      "type": "any",
      "value": "await fetch(`${serverUrl}/register-init`, {",
      "isPublic": true,
      "line": 11,
      "raw": "const initRegisterRes = await fetch(`${serverUrl}/register-init`, {",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.register.ts.initRegister",
      "fullName": "mesh-wallet:browser.webauthn.auth.register.ts.initRegister",
      "name": "initRegister",
      "type": "any",
      "value": "await initRegisterRes.json();",
      "isPublic": true,
      "line": 21,
      "raw": "const initRegister = await initRegisterRes.json();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.register.ts.optionsJSON",
      "fullName": "mesh-wallet:browser.webauthn.auth.register.ts.optionsJSON",
      "name": "optionsJSON",
      "type": "any",
      "value": "initRegister.data.optionsJSON;",
      "isPublic": true,
      "line": 31,
      "raw": "const optionsJSON = initRegister.data.optionsJSON;",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.register.ts.registrationJSON",
      "fullName": "mesh-wallet:browser.webauthn.auth.register.ts.registrationJSON",
      "name": "registrationJSON",
      "type": "any",
      "value": "await startRegistration({ optionsJSON });",
      "isPublic": true,
      "line": 32,
      "raw": "const registrationJSON = await startRegistration({ optionsJSON });",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.register.ts.verifyResponse",
      "fullName": "mesh-wallet:browser.webauthn.auth.register.ts.verifyResponse",
      "name": "verifyResponse",
      "type": "any",
      "value": "await fetch(`${serverUrl}/register-verify`, {",
      "isPublic": true,
      "line": 35,
      "raw": "const verifyResponse = await fetch(`${serverUrl}/register-verify`, {",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.auth.register.ts.verifyData",
      "fullName": "mesh-wallet:browser.webauthn.auth.register.ts.verifyData",
      "name": "verifyData",
      "type": "any",
      "value": "await verifyResponse.json();",
      "isPublic": true,
      "line": 44,
      "raw": "const verifyData = await verifyResponse.json();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.cardano.build-wallet-from-passkey.ts.entropy",
      "fullName": "mesh-wallet:browser.webauthn.cardano.build-wallet-from-passkey.ts.entropy",
      "name": "entropy",
      "type": "any",
      "value": "await crypto.subtle.digest(\"SHA-256\", entropyBuffer);",
      "isPublic": true,
      "line": 36,
      "raw": "const entropy = await crypto.subtle.digest(\"SHA-256\", entropyBuffer);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.cardano.build-wallet-from-passkey.ts.bip32Key",
      "fullName": "mesh-wallet:browser.webauthn.cardano.build-wallet-from-passkey.ts.bip32Key",
      "name": "bip32Key",
      "type": "any",
      "value": "Crypto.Bip32PrivateKey.fromBip39Entropy(entropy, password);",
      "isPublic": true,
      "line": 16,
      "raw": "const bip32Key = Crypto.Bip32PrivateKey.fromBip39Entropy(entropy, password);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.cardano.build-wallet-from-passkey.ts.bytes",
      "fullName": "mesh-wallet:browser.webauthn.cardano.build-wallet-from-passkey.ts.bytes",
      "name": "bytes",
      "type": "any",
      "value": "base32.encode(bip32Key.bytes());",
      "isPublic": true,
      "line": 18,
      "raw": "const bytes = base32.encode(bip32Key.bytes());",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.cardano.build-wallet-from-passkey.ts.bech32PrivateKey",
      "fullName": "mesh-wallet:browser.webauthn.cardano.build-wallet-from-passkey.ts.bech32PrivateKey",
      "name": "bech32PrivateKey",
      "type": "any",
      "value": "bech32.encode(\"xprv\", bytes, 1023);",
      "isPublic": true,
      "line": 19,
      "raw": "const bech32PrivateKey = bech32.encode(\"xprv\", bytes, 1023);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.cardano.build-wallet-from-passkey.ts.rawIdBytes",
      "fullName": "mesh-wallet:browser.webauthn.cardano.build-wallet-from-passkey.ts.rawIdBytes",
      "name": "rawIdBytes",
      "type": "any",
      "value": "new Uint8Array(new TextEncoder().encode(rawId));",
      "isPublic": true,
      "line": 28,
      "raw": "const rawIdBytes = new Uint8Array(new TextEncoder().encode(rawId));",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.cardano.build-wallet-from-passkey.ts.saltBytes",
      "fullName": "mesh-wallet:browser.webauthn.cardano.build-wallet-from-passkey.ts.saltBytes",
      "name": "saltBytes",
      "type": "any",
      "value": "new TextEncoder().encode(appSalt);",
      "isPublic": true,
      "line": 31,
      "raw": "const saltBytes = new TextEncoder().encode(appSalt);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.cardano.build-wallet-from-passkey.ts.entropyBuffer",
      "fullName": "mesh-wallet:browser.webauthn.cardano.build-wallet-from-passkey.ts.entropyBuffer",
      "name": "entropyBuffer",
      "type": "any",
      "value": "new Uint8Array([...rawIdBytes, ...saltBytes]);",
      "isPublic": true,
      "line": 33,
      "raw": "const entropyBuffer = new Uint8Array([...rawIdBytes, ...saltBytes]);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:browser.webauthn.common.error-codes.index.ts.ERRORCODES",
      "fullName": "mesh-wallet:browser.webauthn.common.error-codes.index.ts.ERRORCODES",
      "name": "ERRORCODES",
      "type": "any",
      "value": "{",
      "isPublic": true,
      "line": 1,
      "raw": "export const ERRORCODES = {",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.bech32DecodedBytes",
      "fullName": "mesh-wallet:embedded.index.ts.bech32DecodedBytes",
      "name": "bech32DecodedBytes",
      "type": "any",
      "value": "BaseEncoding.bech32.decodeToBytes(_bech32).bytes;",
      "isPublic": true,
      "line": 83,
      "raw": "const bech32DecodedBytes = BaseEncoding.bech32.decodeToBytes(_bech32).bytes;",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.bip32PrivateKey",
      "fullName": "mesh-wallet:embedded.index.ts.bip32PrivateKey",
      "name": "bip32PrivateKey",
      "type": "any",
      "value": "Bip32PrivateKey.fromBytes(bip32Bytes);",
      "isPublic": true,
      "line": 105,
      "raw": "const bip32PrivateKey = Bip32PrivateKey.fromBytes(bip32Bytes);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.entropy",
      "fullName": "mesh-wallet:embedded.index.ts.entropy",
      "name": "entropy",
      "type": "any",
      "value": "mnemonicToEntropy(words.join(\" \"));",
      "isPublic": true,
      "line": 89,
      "raw": "const entropy = mnemonicToEntropy(words.join(\" \"));",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.baseAddress",
      "fullName": "mesh-wallet:embedded.index.ts.baseAddress",
      "name": "baseAddress",
      "type": "any",
      "value": "buildBaseAddress(",
      "isPublic": true,
      "line": 118,
      "raw": "const baseAddress = buildBaseAddress(",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.enterpriseAddress",
      "fullName": "mesh-wallet:embedded.index.ts.enterpriseAddress",
      "name": "enterpriseAddress",
      "type": "any",
      "value": "buildEnterpriseAddress(",
      "isPublic": true,
      "line": 128,
      "raw": "const enterpriseAddress = buildEnterpriseAddress(",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.rewardAddress",
      "fullName": "mesh-wallet:embedded.index.ts.rewardAddress",
      "name": "rewardAddress",
      "type": "any",
      "value": "buildRewardAddress(",
      "isPublic": true,
      "line": 135,
      "raw": "const rewardAddress = buildRewardAddress(",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.pubDRepKey",
      "fullName": "mesh-wallet:embedded.index.ts.pubDRepKey",
      "name": "pubDRepKey",
      "type": "any",
      "value": "dRepKey.toPublic().hex().toString();",
      "isPublic": true,
      "line": 158,
      "raw": "const pubDRepKey = dRepKey.toPublic().hex().toString();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.dRepIDBech32",
      "fullName": "mesh-wallet:embedded.index.ts.dRepIDBech32",
      "name": "dRepIDBech32",
      "type": "any",
      "value": "buildDRepID(",
      "isPublic": true,
      "line": 160,
      "raw": "const dRepIDBech32 = buildDRepID(",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.dRep",
      "fullName": "mesh-wallet:embedded.index.ts.dRep",
      "name": "dRep",
      "type": "any",
      "value": "DRep.newKeyHash(dRepKey.toPublic().hash().hex());",
      "isPublic": true,
      "line": 164,
      "raw": "const dRep = DRep.newKeyHash(dRepKey.toPublic().hash().hex());",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.dRepIDHash",
      "fullName": "mesh-wallet:embedded.index.ts.dRepIDHash",
      "name": "dRepIDHash",
      "type": "any",
      "value": "dRep.toKeyHash()!;",
      "isPublic": true,
      "line": 165,
      "raw": "const dRepIDHash = dRep.toKeyHash()!;",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.dRepIDCip105",
      "fullName": "mesh-wallet:embedded.index.ts.dRepIDCip105",
      "name": "dRepIDCip105",
      "type": "any",
      "value": "hexToBech32(\"drep\", dRepIDHash);",
      "isPublic": true,
      "line": 167,
      "raw": "const dRepIDCip105 = hexToBech32(\"drep\", dRepIDHash);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.mnemonic",
      "fullName": "mesh-wallet:embedded.index.ts.mnemonic",
      "name": "mnemonic",
      "type": "any",
      "value": "generateMnemonic(strength);",
      "isPublic": true,
      "line": 178,
      "raw": "const mnemonic = generateMnemonic(strength);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.foundAddress",
      "fullName": "mesh-wallet:embedded.index.ts.foundAddress",
      "name": "foundAddress",
      "type": "any",
      "value": "[baseAddress, enterpriseAddress, rewardAddress].find(",
      "isPublic": true,
      "line": 307,
      "raw": "const foundAddress = [baseAddress, enterpriseAddress, rewardAddress].find(",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.txHash",
      "fullName": "mesh-wallet:embedded.index.ts.txHash",
      "name": "txHash",
      "type": "any",
      "value": "deserializeTxHash(resolveTxHash(unsignedTx));",
      "isPublic": true,
      "line": 344,
      "raw": "const txHash = deserializeTxHash(resolveTxHash(unsignedTx));",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:embedded.index.ts.vKeyWitness",
      "fullName": "mesh-wallet:embedded.index.ts.vKeyWitness",
      "name": "vKeyWitness",
      "type": "any",
      "value": "new VkeyWitness(",
      "isPublic": true,
      "line": 359,
      "raw": "const vKeyWitness = new VkeyWitness(",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.utxos",
      "fullName": "mesh-wallet:mesh.index.ts.utxos",
      "name": "utxos",
      "type": "any",
      "value": "await this._fetcher.fetchAddressUTxOs(",
      "isPublic": true,
      "line": 536,
      "raw": "const utxos = await this._fetcher.fetchAddressUTxOs(",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.assets",
      "fullName": "mesh-wallet:mesh.index.ts.assets",
      "name": "assets",
      "type": "any",
      "value": "await this.getAssets();",
      "isPublic": true,
      "line": 588,
      "raw": "const assets = await this.getAssets();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts._utxo",
      "fullName": "mesh-wallet:mesh.index.ts._utxo",
      "name": "_utxo",
      "type": "any",
      "value": "fromTxUnspentOutput(utxo);",
      "isPublic": true,
      "line": 203,
      "raw": "const _utxo = fromTxUnspentOutput(utxo);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.assetId",
      "fullName": "mesh-wallet:mesh.index.ts.assetId",
      "name": "assetId",
      "type": "any",
      "value": "asset.unit;",
      "isPublic": true,
      "line": 205,
      "raw": "const assetId = asset.unit;",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.amount",
      "fullName": "mesh-wallet:mesh.index.ts.amount",
      "name": "amount",
      "type": "any",
      "value": "Number(asset.quantity);",
      "isPublic": true,
      "line": 206,
      "raw": "const amount = Number(asset.quantity);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.quantity",
      "fullName": "mesh-wallet:mesh.index.ts.quantity",
      "name": "quantity",
      "type": "any",
      "value": "assets.get(assetId)!;",
      "isPublic": true,
      "line": 208,
      "raw": "const quantity = assets.get(assetId)!;",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.arrayAssets",
      "fullName": "mesh-wallet:mesh.index.ts.arrayAssets",
      "name": "arrayAssets",
      "type": "Asset[]",
      "value": "Array.from(assets, ([unit, quantity]) => ({",
      "isPublic": true,
      "line": 216,
      "raw": "const arrayAssets: Asset[] = Array.from(assets, ([unit, quantity]) => ({",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.pureAdaUtxos",
      "fullName": "mesh-wallet:mesh.index.ts.pureAdaUtxos",
      "name": "pureAdaUtxos",
      "type": "any",
      "value": "utxos.filter((utxo) => {",
      "isPublic": true,
      "line": 285,
      "raw": "const pureAdaUtxos = utxos.filter((utxo) => {",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.tx",
      "fullName": "mesh-wallet:mesh.index.ts.tx",
      "name": "tx",
      "type": "any",
      "value": "new Transaction({ initiator: this });",
      "isPublic": true,
      "line": 632,
      "raw": "const tx = new Transaction({ initiator: this });",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.newSignatures",
      "fullName": "mesh-wallet:mesh.index.ts.newSignatures",
      "name": "newSignatures",
      "type": "any",
      "value": "this._wallet.signTx(",
      "isPublic": true,
      "line": 449,
      "raw": "const newSignatures = this._wallet.signTx(",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.signedTxs",
      "fullName": "mesh-wallet:mesh.index.ts.signedTxs",
      "name": "signedTxs",
      "type": "string[]",
      "value": "[];",
      "isPublic": true,
      "line": 476,
      "raw": "const signedTxs: string[] = [];",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.signedTx",
      "fullName": "mesh-wallet:mesh.index.ts.signedTx",
      "name": "signedTx",
      "type": "any",
      "value": "await this.signTx(unsignedTx);",
      "isPublic": true,
      "line": 635,
      "raw": "const signedTx = await this.signTx(unsignedTx);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.balance",
      "fullName": "mesh-wallet:mesh.index.ts.balance",
      "name": "balance",
      "type": "any",
      "value": "await this.getBalance();",
      "isPublic": true,
      "line": 598,
      "raw": "const balance = await this.getBalance();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.policyId",
      "fullName": "mesh-wallet:mesh.index.ts.policyId",
      "name": "policyId",
      "type": "any",
      "value": "v.unit.slice(0, POLICY_ID_LENGTH);",
      "isPublic": true,
      "line": 555,
      "raw": "const policyId = v.unit.slice(0, POLICY_ID_LENGTH);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.assetName",
      "fullName": "mesh-wallet:mesh.index.ts.assetName",
      "name": "assetName",
      "type": "any",
      "value": "v.unit.slice(POLICY_ID_LENGTH);",
      "isPublic": true,
      "line": 556,
      "raw": "const assetName = v.unit.slice(POLICY_ID_LENGTH);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.fingerprint",
      "fullName": "mesh-wallet:mesh.index.ts.fingerprint",
      "name": "fingerprint",
      "type": "any",
      "value": "resolveFingerprint(policyId, assetName);",
      "isPublic": true,
      "line": 557,
      "raw": "const fingerprint = resolveFingerprint(policyId, assetName);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.nativeAsset",
      "fullName": "mesh-wallet:mesh.index.ts.nativeAsset",
      "name": "nativeAsset",
      "type": "any",
      "value": "balance.find((v) => v.unit === \"lovelace\");",
      "isPublic": true,
      "line": 576,
      "raw": "const nativeAsset = balance.find((v) => v.unit === \"lovelace\");",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.unsignedTx",
      "fullName": "mesh-wallet:mesh.index.ts.unsignedTx",
      "name": "unsignedTx",
      "type": "any",
      "value": "await tx.build();",
      "isPublic": true,
      "line": 634,
      "raw": "const unsignedTx = await tx.build();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.txHash",
      "fullName": "mesh-wallet:mesh.index.ts.txHash",
      "name": "txHash",
      "type": "any",
      "value": "await this.submitTx(signedTx);",
      "isPublic": true,
      "line": 636,
      "raw": "const txHash = await this.submitTx(signedTx);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.mnemonic",
      "fullName": "mesh-wallet:mesh.index.ts.mnemonic",
      "name": "mnemonic",
      "type": "any",
      "value": "EmbeddedWallet.generateMnemonic(strength);",
      "isPublic": true,
      "line": 661,
      "raw": "const mnemonic = EmbeddedWallet.generateMnemonic(strength);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.account",
      "fullName": "mesh-wallet:mesh.index.ts.account",
      "name": "account",
      "type": "any",
      "value": "wallet.getAccount(this._accountIndex, this._keyIndex);",
      "isPublic": true,
      "line": 671,
      "raw": "const account = wallet.getAccount(this._accountIndex, this._keyIndex);",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.baseAddress",
      "fullName": "mesh-wallet:mesh.index.ts.baseAddress",
      "name": "baseAddress",
      "type": "any",
      "value": "Address.fromBech32(address).asBase();",
      "isPublic": true,
      "line": 692,
      "raw": "const baseAddress = Address.fromBech32(address).asBase();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.enterpriseAddress",
      "fullName": "mesh-wallet:mesh.index.ts.enterpriseAddress",
      "name": "enterpriseAddress",
      "type": "any",
      "value": "Address.fromBech32(address).asEnterprise();",
      "isPublic": true,
      "line": 697,
      "raw": "const enterpriseAddress = Address.fromBech32(address).asEnterprise();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-wallet:mesh.index.ts.rewardAddress",
      "fullName": "mesh-wallet:mesh.index.ts.rewardAddress",
      "name": "rewardAddress",
      "type": "any",
      "value": "Address.fromBech32(address).asReward();",
      "isPublic": true,
      "line": 702,
      "raw": "const rewardAddress = Address.fromBech32(address).asReward();",
      "source": "mesh-wallet"
    },
    {
      "key": "mesh-hydra:hydra-connection.ts._wsUrl",
      "fullName": "mesh-hydra:hydra-connection.ts._wsUrl",
      "name": "_wsUrl",
      "type": "any",
      "value": "wsUrl ? wsUrl : url.replace(\"http\", \"ws\");",
      "isPublic": true,
      "line": 20,
      "raw": "const _wsUrl = wsUrl ? wsUrl : url.replace(\"http\", \"ws\");",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:hydra-connection.ts._history",
      "fullName": "mesh-hydra:hydra-connection.ts._history",
      "name": "_history",
      "type": "any",
      "value": "`history=${history ? \"yes\" : \"no\"}`;",
      "isPublic": true,
      "line": 21,
      "raw": "const _history = `history=${history ? \"yes\" : \"no\"}`;",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:hydra-connection.ts._address",
      "fullName": "mesh-hydra:hydra-connection.ts._address",
      "name": "_address",
      "type": "any",
      "value": "address ? `&address=${address}` : \"\";",
      "isPublic": true,
      "line": 22,
      "raw": "const _address = address ? `&address=${address}` : \"\";",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:hydra-connection.ts.message",
      "fullName": "mesh-hydra:hydra-connection.ts.message",
      "name": "message",
      "type": "any",
      "value": "JSON.parse(data.data as string);",
      "isPublic": true,
      "line": 52,
      "raw": "const message = JSON.parse(data.data as string);",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:hydra-connection.ts.sendData",
      "fullName": "mesh-hydra:hydra-connection.ts.sendData",
      "name": "sendData",
      "type": "any",
      "value": "() => {",
      "isPublic": true,
      "line": 60,
      "raw": "const sendData = () => {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:hydra-connection.ts.interval",
      "fullName": "mesh-hydra:hydra-connection.ts.interval",
      "name": "interval",
      "type": "any",
      "value": "setInterval(() => {",
      "isPublic": true,
      "line": 68,
      "raw": "const interval = setInterval(() => {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:hydra-instance.ts.utxo",
      "fullName": "mesh-hydra:hydra-instance.ts.utxo",
      "name": "utxo",
      "type": "any",
      "value": "(await this.fetcher.fetchUTxOs(txHash, txIndex))[0];",
      "isPublic": true,
      "line": 36,
      "raw": "const utxo = (await this.fetcher.fetchUTxOs(txHash, txIndex))[0];",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:hydra-instance.ts.hydraUtxo",
      "fullName": "mesh-hydra:hydra-instance.ts.hydraUtxo",
      "name": "hydraUtxo",
      "type": "any",
      "value": "{",
      "isPublic": true,
      "line": 40,
      "raw": "const hydraUtxo = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:hydra-instance.ts.commit",
      "fullName": "mesh-hydra:hydra-instance.ts.commit",
      "name": "commit",
      "type": "any",
      "value": "await this.provider.buildCommit(",
      "isPublic": true,
      "line": 52,
      "raw": "const commit = await this.provider.buildCommit(",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:hydra-provider.ts.utxos",
      "fullName": "mesh-hydra:hydra-provider.ts.utxos",
      "name": "utxos",
      "type": "UTxO[]",
      "value": "[];",
      "isPublic": true,
      "line": 340,
      "raw": "const utxos: UTxO[] = [];",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:hydra-provider.ts.snapshotUTxOs",
      "fullName": "mesh-hydra:hydra-provider.ts.snapshotUTxOs",
      "name": "snapshotUTxOs",
      "type": "any",
      "value": "await this.subscribeSnapshotUtxo();",
      "isPublic": true,
      "line": 131,
      "raw": "const snapshotUTxOs = await this.subscribeSnapshotUtxo();",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:hydra-provider.ts.outputsPromises",
      "fullName": "mesh-hydra:hydra-provider.ts.outputsPromises",
      "name": "outputsPromises",
      "type": "Promise<UTxO>[]",
      "value": "[];",
      "isPublic": true,
      "line": 133,
      "raw": "const outputsPromises: Promise<UTxO>[] = [];",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:hydra-provider.ts.outputs",
      "fullName": "mesh-hydra:hydra-provider.ts.outputs",
      "name": "outputs",
      "type": "any",
      "value": "await Promise.all(outputsPromises);",
      "isPublic": true,
      "line": 139,
      "raw": "const outputs = await Promise.all(outputsPromises);",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:hydra-provider.ts.txId",
      "fullName": "mesh-hydra:hydra-provider.ts.txId",
      "name": "txId",
      "type": "any",
      "value": "await new Promise<string>((resolve) => {",
      "isPublic": true,
      "line": 155,
      "raw": "const txId = await new Promise<string>((resolve) => {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:hydra-provider.ts.transaction",
      "fullName": "mesh-hydra:hydra-provider.ts.transaction",
      "name": "transaction",
      "type": "hTransaction",
      "value": "{",
      "isPublic": true,
      "line": 218,
      "raw": "const transaction: hTransaction = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:hydra-provider.ts.payload",
      "fullName": "mesh-hydra:hydra-provider.ts.payload",
      "name": "payload",
      "type": "any",
      "value": "{",
      "isPublic": true,
      "line": 246,
      "raw": "const payload = {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:hydra-provider.ts.txHex",
      "fullName": "mesh-hydra:hydra-provider.ts.txHex",
      "name": "txHex",
      "type": "any",
      "value": "await this.post(\"/commit\", payload, headers);",
      "isPublic": true,
      "line": 296,
      "raw": "const txHex = await this.post(\"/commit\", payload, headers);",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:hydra-provider.ts.commits",
      "fullName": "mesh-hydra:hydra-provider.ts.commits",
      "name": "commits",
      "type": "any",
      "value": "await this.get(\"/commits\");",
      "isPublic": true,
      "line": 312,
      "raw": "const commits = await this.get(\"/commits\");",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:hydra-provider.ts.data",
      "fullName": "mesh-hydra:hydra-provider.ts.data",
      "name": "data",
      "type": "any",
      "value": "await this.get(\"protocol-parameters\");",
      "isPublic": true,
      "line": 369,
      "raw": "const data = await this.get(\"protocol-parameters\");",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:hydra-provider.ts.utxo",
      "fullName": "mesh-hydra:hydra-provider.ts.utxo",
      "name": "utxo",
      "type": "any",
      "value": "hUTxO.toUTxO(value as hUTxO, key);",
      "isPublic": true,
      "line": 342,
      "raw": "const utxo = hUTxO.toUTxO(value as hUTxO, key);",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:hydra-provider.ts.protocolParams",
      "fullName": "mesh-hydra:hydra-provider.ts.protocolParams",
      "name": "protocolParams",
      "type": "any",
      "value": "castProtocol({",
      "isPublic": true,
      "line": 371,
      "raw": "const protocolParams = castProtocol({",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hAssets.ts.policyId",
      "fullName": "mesh-hydra:types.hAssets.ts.policyId",
      "name": "policyId",
      "type": "any",
      "value": "asset.unit.slice(0, 56);",
      "isPublic": true,
      "line": 16,
      "raw": "const policyId = asset.unit.slice(0, 56);",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hAssets.ts.assetName",
      "fullName": "mesh-hydra:types.hAssets.ts.assetName",
      "name": "assetName",
      "type": "any",
      "value": "asset.unit.slice(56);",
      "isPublic": true,
      "line": 17,
      "raw": "const assetName = asset.unit.slice(56);",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hAssets.ts.assets",
      "fullName": "mesh-hydra:types.hAssets.ts.assets",
      "name": "assets",
      "type": "Asset[]",
      "value": "[];",
      "isPublic": true,
      "line": 27,
      "raw": "const assets: Asset[] = [];",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:types.hStatus.ts.status",
      "fullName": "mesh-hydra:types.hStatus.ts.status",
      "name": "status",
      "type": "any",
      "value": "[",
      "isPublic": true,
      "line": 22,
      "raw": "const status = [",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-hydra:utils.parse-http-error.ts.parseHttpError",
      "fullName": "mesh-hydra:utils.parse-http-error.ts.parseHttpError",
      "name": "parseHttpError",
      "type": "any",
      "value": "(error: unknown): string => {",
      "isPublic": true,
      "line": 3,
      "raw": "export const parseHttpError = (error: unknown): string => {",
      "source": "mesh-hydra"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.certificateFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.certificateFromObj",
      "name": "certificateFromObj",
      "type": "any",
      "value": "(obj: any): Certificate => {",
      "isPublic": true,
      "line": 12,
      "raw": "export const certificateFromObj = (obj: any): Certificate => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.certificate",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.certificate",
      "name": "certificate",
      "type": "Certificate",
      "value": "{",
      "isPublic": true,
      "line": 36,
      "raw": "const certificate: Certificate = {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.baseCertFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.baseCertFromObj",
      "name": "baseCertFromObj",
      "type": "any",
      "value": "(obj: any): CertificateType => {",
      "isPublic": true,
      "line": 55,
      "raw": "export const baseCertFromObj = (obj: any): CertificateType => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.poolParamsFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.poolParamsFromObj",
      "name": "poolParamsFromObj",
      "type": "any",
      "value": "(obj: any): PoolParams => {",
      "isPublic": true,
      "line": 157,
      "raw": "export const poolParamsFromObj = (obj: any): PoolParams => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.poolMetadataFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.poolMetadataFromObj",
      "name": "poolMetadataFromObj",
      "type": "any",
      "value": "(obj: any): PoolMetadata => {",
      "isPublic": true,
      "line": 171,
      "raw": "export const poolMetadataFromObj = (obj: any): PoolMetadata => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.relayFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.certificate.ts.relayFromObj",
      "name": "relayFromObj",
      "type": "any",
      "value": "(obj: any): Relay => {",
      "isPublic": true,
      "line": 178,
      "raw": "export const relayFromObj = (obj: any): Relay => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.data.ts.cborToBuilderData",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.data.ts.cborToBuilderData",
      "name": "cborToBuilderData",
      "type": "any",
      "value": "(cborHex: string): BuilderData => {",
      "isPublic": true,
      "line": 10,
      "raw": "export const cborToBuilderData = (cborHex: string): BuilderData => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.data.ts.redeemerFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.data.ts.redeemerFromObj",
      "name": "redeemerFromObj",
      "type": "any",
      "value": "(obj: any): Redeemer => {",
      "isPublic": true,
      "line": 22,
      "raw": "export const redeemerFromObj = (obj: any): Redeemer => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.data.ts.dataFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.data.ts.dataFromObj",
      "name": "dataFromObj",
      "type": "any",
      "value": "(obj: any): any => {",
      "isPublic": true,
      "line": 34,
      "raw": "export const dataFromObj = (obj: any): any => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.index.ts.txBuilderBodyFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.index.ts.txBuilderBodyFromObj",
      "name": "txBuilderBodyFromObj",
      "type": "any",
      "value": "(objJson: any): MeshTxBuilderBody => {",
      "isPublic": true,
      "line": 23,
      "raw": "export const txBuilderBodyFromObj = (objJson: any): MeshTxBuilderBody => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.index.ts.txBuilderBody",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.index.ts.txBuilderBody",
      "name": "txBuilderBody",
      "type": "MeshTxBuilderBody",
      "value": "emptyTxBuilderBody();",
      "isPublic": true,
      "line": 24,
      "raw": "const txBuilderBody: MeshTxBuilderBody = emptyTxBuilderBody();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.index.ts.obj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.index.ts.obj",
      "name": "obj",
      "type": "any",
      "value": "JSON.parse(objJson);",
      "isPublic": true,
      "line": 25,
      "raw": "const obj = JSON.parse(objJson);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.index.ts.mintItems",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.index.ts.mintItems",
      "name": "mintItems",
      "type": "MintItem[]",
      "value": "obj.mints.map(mintItemFromObj);",
      "isPublic": true,
      "line": 44,
      "raw": "const mintItems: MintItem[] = obj.mints.map(mintItemFromObj);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.index.ts.visitedPolicyId",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.index.ts.visitedPolicyId",
      "name": "visitedPolicyId",
      "type": "any",
      "value": "new Set<string>();",
      "isPublic": true,
      "line": 46,
      "raw": "const visitedPolicyId = new Set<string>();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.index.ts.mintParams",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.index.ts.mintParams",
      "name": "mintParams",
      "type": "Record<string, MintParam>",
      "value": "{};",
      "isPublic": true,
      "line": 47,
      "raw": "const mintParams: Record<string, MintParam> = {};",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.index.ts.mintValueItem",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.index.ts.mintValueItem",
      "name": "mintValueItem",
      "type": "any",
      "value": "{",
      "isPublic": true,
      "line": 50,
      "raw": "const mintValueItem = {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.index.ts.mintParam",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.index.ts.mintParam",
      "name": "mintParam",
      "type": "any",
      "value": "mintParams[mintItem.policyId]!;",
      "isPublic": true,
      "line": 64,
      "raw": "const mintParam = mintParams[mintItem.policyId]!;",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.metadata.ts.JSONBigParser",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.metadata.ts.JSONBigParser",
      "name": "JSONBigParser",
      "type": "any",
      "value": "JSONbig({",
      "isPublic": true,
      "line": 6,
      "raw": "const JSONBigParser = JSONbig({",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.metadata.ts.metadataFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.metadata.ts.metadataFromObj",
      "name": "metadataFromObj",
      "type": "any",
      "value": "(metadataArray: Metadata[]): TxMetadata => {",
      "isPublic": true,
      "line": 12,
      "raw": "export const metadataFromObj = (metadataArray: Metadata[]): TxMetadata => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.metadata.ts.result",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.metadata.ts.result",
      "name": "result",
      "type": "any",
      "value": "new Map<Metadatum, Metadatum>();",
      "isPublic": true,
      "line": 44,
      "raw": "const result = new Map<Metadatum, Metadatum>();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.metadata.ts.key",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.metadata.ts.key",
      "name": "key",
      "type": "any",
      "value": "BigInt(metadata.tag);",
      "isPublic": true,
      "line": 16,
      "raw": "const key = BigInt(metadata.tag);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.metadata.ts.value",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.metadata.ts.value",
      "name": "value",
      "type": "any",
      "value": "objToMetadatum(JSONBigParser.parse(metadata.metadata));",
      "isPublic": true,
      "line": 17,
      "raw": "const value = objToMetadatum(JSONBigParser.parse(metadata.metadata));",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.metadata.ts.objToMetadatum",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.metadata.ts.objToMetadatum",
      "name": "objToMetadatum",
      "type": "any",
      "value": "(obj: any): Metadatum => {",
      "isPublic": true,
      "line": 24,
      "raw": "const objToMetadatum = (obj: any): Metadatum => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.mint.ts.mintItemFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.mint.ts.mintItemFromObj",
      "name": "mintItemFromObj",
      "type": "any",
      "value": "(obj: any): MintItem => {",
      "isPublic": true,
      "line": 11,
      "raw": "export const mintItemFromObj = (obj: any): MintItem => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.mint.ts.plutusMintItemFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.mint.ts.plutusMintItemFromObj",
      "name": "plutusMintItemFromObj",
      "type": "any",
      "value": "(obj: any): MintItem => {",
      "isPublic": true,
      "line": 30,
      "raw": "export const plutusMintItemFromObj = (obj: any): MintItem => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.mint.ts.mintParams",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.mint.ts.mintParams",
      "name": "mintParams",
      "type": "any",
      "value": "mintParametersFromObj(obj.mint);",
      "isPublic": true,
      "line": 46,
      "raw": "const mintParams = mintParametersFromObj(obj.mint);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.mint.ts.nativeMintItemFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.mint.ts.nativeMintItemFromObj",
      "name": "nativeMintItemFromObj",
      "type": "any",
      "value": "(obj: any): MintItem => {",
      "isPublic": true,
      "line": 45,
      "raw": "export const nativeMintItemFromObj = (obj: any): MintItem => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.mint.ts.mintParametersFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.mint.ts.mintParametersFromObj",
      "name": "mintParametersFromObj",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 59,
      "raw": "export const mintParametersFromObj = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.network.ts.networkFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.network.ts.networkFromObj",
      "name": "networkFromObj",
      "type": "any",
      "value": "(obj: any): Network | number[][] => {",
      "isPublic": true,
      "line": 3,
      "raw": "export const networkFromObj = (obj: any): Network | number[][] => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.output.ts.outputFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.output.ts.outputFromObj",
      "name": "outputFromObj",
      "type": "any",
      "value": "(obj: any): Output => {",
      "isPublic": true,
      "line": 10,
      "raw": "export const outputFromObj = (obj: any): Output => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.output.ts.output",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.output.ts.output",
      "name": "output",
      "type": "Output",
      "value": "{",
      "isPublic": true,
      "line": 11,
      "raw": "const output: Output = {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.output.ts.scriptSource",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.output.ts.scriptSource",
      "name": "scriptSource",
      "type": "any",
      "value": "obj.referenceScript.providedScriptSource;",
      "isPublic": true,
      "line": 38,
      "raw": "const scriptSource = obj.referenceScript.providedScriptSource;",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.script.ts.scriptSourceFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.script.ts.scriptSourceFromObj",
      "name": "scriptSourceFromObj",
      "type": "any",
      "value": "(obj: any): ScriptSource => {",
      "isPublic": true,
      "line": 12,
      "raw": "export const scriptSourceFromObj = (obj: any): ScriptSource => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.script.ts.simpleScriptSourceFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.script.ts.simpleScriptSourceFromObj",
      "name": "simpleScriptSourceFromObj",
      "type": "any",
      "value": "(obj: any): SimpleScriptSourceInfo => {",
      "isPublic": true,
      "line": 48,
      "raw": "export const simpleScriptSourceFromObj = (obj: any): SimpleScriptSourceInfo => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.txInFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.txInFromObj",
      "name": "txInFromObj",
      "type": "any",
      "value": "(obj: any): TxIn => {",
      "isPublic": true,
      "line": 11,
      "raw": "export const txInFromObj = (obj: any): TxIn => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.txInParameterFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.txInParameterFromObj",
      "name": "txInParameterFromObj",
      "type": "any",
      "value": "(obj: any): TxInParameter => {",
      "isPublic": true,
      "line": 40,
      "raw": "export const txInParameterFromObj = (obj: any): TxInParameter => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.scriptTxInParameterFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.scriptTxInParameterFromObj",
      "name": "scriptTxInParameterFromObj",
      "type": "any",
      "value": "(obj: any): ScriptTxInParameter => {",
      "isPublic": true,
      "line": 49,
      "raw": "export const scriptTxInParameterFromObj = (obj: any): ScriptTxInParameter => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.result",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.result",
      "name": "result",
      "type": "SimpleScriptTxInParameter",
      "value": "{};",
      "isPublic": true,
      "line": 81,
      "raw": "const result: SimpleScriptTxInParameter = {};",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.simpleScriptTxInParameterFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.simpleScriptTxInParameterFromObj",
      "name": "simpleScriptTxInParameterFromObj",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 78,
      "raw": "export const simpleScriptTxInParameterFromObj = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.collateralTxInFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.txIn.ts.collateralTxInFromObj",
      "name": "collateralTxInFromObj",
      "type": "any",
      "value": "(obj: any): TxIn => {",
      "isPublic": true,
      "line": 101,
      "raw": "export const collateralTxInFromObj = (obj: any): TxIn => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.utxo.ts.utxoFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.utxo.ts.utxoFromObj",
      "name": "utxoFromObj",
      "type": "any",
      "value": "(obj: any): UTxO => {",
      "isPublic": true,
      "line": 8,
      "raw": "export const utxoFromObj = (obj: any): UTxO => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.vote.ts.voteFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.vote.ts.voteFromObj",
      "name": "voteFromObj",
      "type": "any",
      "value": "(obj: any): Vote => {",
      "isPublic": true,
      "line": 6,
      "raw": "export const voteFromObj = (obj: any): Vote => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.vote.ts.voteTypeFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.vote.ts.voteTypeFromObj",
      "name": "voteTypeFromObj",
      "type": "any",
      "value": "(obj: any): VoteType => {",
      "isPublic": true,
      "line": 31,
      "raw": "const voteTypeFromObj = (obj: any): VoteType => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.vote.ts.voter",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.vote.ts.voter",
      "name": "voter",
      "type": "any",
      "value": "voterFromObj(obj);",
      "isPublic": true,
      "line": 32,
      "raw": "const voter = voterFromObj(obj);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.vote.ts.votingProcedure",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.vote.ts.votingProcedure",
      "name": "votingProcedure",
      "type": "any",
      "value": "{",
      "isPublic": true,
      "line": 33,
      "raw": "const votingProcedure = {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.vote.ts.voterFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.vote.ts.voterFromObj",
      "name": "voterFromObj",
      "type": "any",
      "value": "(obj: any) => {",
      "isPublic": true,
      "line": 48,
      "raw": "const voterFromObj = (obj: any) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.vote.ts.cred",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.vote.ts.cred",
      "name": "cred",
      "type": "any",
      "value": "obj.voter.constitutionalCommitteeHotCred;",
      "isPublic": true,
      "line": 50,
      "raw": "const cred = obj.voter.constitutionalCommitteeHotCred;",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.vote.ts.voteKindFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.vote.ts.voteKindFromObj",
      "name": "voteKindFromObj",
      "type": "any",
      "value": "(voteKind: string): VoteKind => {",
      "isPublic": true,
      "line": 72,
      "raw": "const voteKindFromObj = (voteKind: string): VoteKind => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.fromObj.withdrawal.ts.withdrawalFromObj",
      "fullName": "mesh-core-csl:core.adaptor.fromObj.withdrawal.ts.withdrawalFromObj",
      "name": "withdrawalFromObj",
      "type": "any",
      "value": "(obj: any): Withdrawal => {",
      "isPublic": true,
      "line": 6,
      "raw": "export const withdrawalFromObj = (obj: any): Withdrawal => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.certificate.ts.certificateToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.certificate.ts.certificateToObj",
      "name": "certificateToObj",
      "type": "any",
      "value": "(certificate: Certificate): object => {",
      "isPublic": true,
      "line": 12,
      "raw": "export const certificateToObj = (certificate: Certificate): object => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.certificate.ts.baseCert",
      "fullName": "mesh-core-csl:core.adaptor.toObj.certificate.ts.baseCert",
      "name": "baseCert",
      "type": "any",
      "value": "certificate.certType;",
      "isPublic": true,
      "line": 13,
      "raw": "const baseCert = certificate.certType;",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.certificate.ts.baseCertToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.certificate.ts.baseCertToObj",
      "name": "baseCertToObj",
      "type": "any",
      "value": "(baseCert: CertificateType): object => {",
      "isPublic": true,
      "line": 43,
      "raw": "export const baseCertToObj = (baseCert: CertificateType): object => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.certificate.ts.poolParamsToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.certificate.ts.poolParamsToObj",
      "name": "poolParamsToObj",
      "type": "any",
      "value": "(poolParams: PoolParams): object => {",
      "isPublic": true,
      "line": 158,
      "raw": "export const poolParamsToObj = (poolParams: PoolParams): object => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.certificate.ts.poolMetadataToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.certificate.ts.poolMetadataToObj",
      "name": "poolMetadataToObj",
      "type": "any",
      "value": "(poolMetadata: PoolMetadata): object => {",
      "isPublic": true,
      "line": 174,
      "raw": "export const poolMetadataToObj = (poolMetadata: PoolMetadata): object => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.certificate.ts.relayToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.certificate.ts.relayToObj",
      "name": "relayToObj",
      "type": "any",
      "value": "(relay: Relay): object => {",
      "isPublic": true,
      "line": 181,
      "raw": "export const relayToObj = (relay: Relay): object => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.data.ts.builderDataToCbor",
      "fullName": "mesh-core-csl:core.adaptor.toObj.data.ts.builderDataToCbor",
      "name": "builderDataToCbor",
      "type": "any",
      "value": "({ type, content }: BuilderData): string => {",
      "isPublic": true,
      "line": 5,
      "raw": "export const builderDataToCbor = ({ type, content }: BuilderData): string => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.data.ts.redeemerToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.data.ts.redeemerToObj",
      "name": "redeemerToObj",
      "type": "any",
      "value": "(redeemer: Redeemer): object => {",
      "isPublic": true,
      "line": 18,
      "raw": "export const redeemerToObj = (redeemer: Redeemer): object => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.index.ts.meshTxBuilderBodyToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.index.ts.meshTxBuilderBodyToObj",
      "name": "meshTxBuilderBodyToObj",
      "type": "any",
      "value": "({",
      "isPublic": true,
      "line": 16,
      "raw": "export const meshTxBuilderBodyToObj = ({",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.metadata.ts.txMetadataToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.metadata.ts.txMetadataToObj",
      "name": "txMetadataToObj",
      "type": "any",
      "value": "(metadata: TxMetadata): Metadata[] => {",
      "isPublic": true,
      "line": 5,
      "raw": "export const txMetadataToObj = (metadata: TxMetadata): Metadata[] => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.metadata.ts.result",
      "fullName": "mesh-core-csl:core.adaptor.toObj.metadata.ts.result",
      "name": "result",
      "type": "Record<string | number, any>",
      "value": "{};",
      "isPublic": true,
      "line": 24,
      "raw": "const result: Record<string | number, any> = {};",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.metadata.ts.metadatumToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.metadata.ts.metadatumToObj",
      "name": "metadatumToObj",
      "type": "any",
      "value": "(metadatum: Metadatum): any => {",
      "isPublic": true,
      "line": 16,
      "raw": "const metadatumToObj = (metadatum: Metadatum): any => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.metadata.ts.uint8ArrayToHex",
      "fullName": "mesh-core-csl:core.adaptor.toObj.metadata.ts.uint8ArrayToHex",
      "name": "uint8ArrayToHex",
      "type": "any",
      "value": "(bytes: Uint8Array): string => {",
      "isPublic": true,
      "line": 36,
      "raw": "const uint8ArrayToHex = (bytes: Uint8Array): string => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.mint.ts.mintItemToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.mint.ts.mintItemToObj",
      "name": "mintItemToObj",
      "type": "any",
      "value": "(mintItem: MintItem): object => {",
      "isPublic": true,
      "line": 10,
      "raw": "export const mintItemToObj = (mintItem: MintItem): object => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.mint.ts.plutusMintItemToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.mint.ts.plutusMintItemToObj",
      "name": "plutusMintItemToObj",
      "type": "any",
      "value": "(mintItem: Required<MintItem>): object => {",
      "isPublic": true,
      "line": 25,
      "raw": "export const plutusMintItemToObj = (mintItem: Required<MintItem>): object => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.mint.ts.nativeMintItemToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.mint.ts.nativeMintItemToObj",
      "name": "nativeMintItemToObj",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 37,
      "raw": "export const nativeMintItemToObj = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.mint.ts.mintParametersObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.mint.ts.mintParametersObj",
      "name": "mintParametersObj",
      "type": "any",
      "value": "(mintItem: MintItem): object => {",
      "isPublic": true,
      "line": 48,
      "raw": "export const mintParametersObj = (mintItem: MintItem): object => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.network.ts.networkToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.network.ts.networkToObj",
      "name": "networkToObj",
      "type": "any",
      "value": "(network: Network | number[][]) => {",
      "isPublic": true,
      "line": 3,
      "raw": "export const networkToObj = (network: Network | number[][]) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.output.ts.outputToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.output.ts.outputToObj",
      "name": "outputToObj",
      "type": "any",
      "value": "(output: Output): object => {",
      "isPublic": true,
      "line": 5,
      "raw": "export const outputToObj = (output: Output): object => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.output.ts.refScript",
      "fullName": "mesh-core-csl:core.adaptor.toObj.output.ts.refScript",
      "name": "refScript",
      "type": "any",
      "value": "output.referenceScript as PlutusScript;",
      "isPublic": true,
      "line": 22,
      "raw": "const refScript = output.referenceScript as PlutusScript;",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.script.ts.scriptSourceToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.script.ts.scriptSourceToObj",
      "name": "scriptSourceToObj",
      "type": "any",
      "value": "(scriptSource: ScriptSource): object => {",
      "isPublic": true,
      "line": 7,
      "raw": "export const scriptSourceToObj = (scriptSource: ScriptSource): object => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.script.ts.simpleScriptSourceToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.script.ts.simpleScriptSourceToObj",
      "name": "simpleScriptSourceToObj",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 32,
      "raw": "export const simpleScriptSourceToObj = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.txIn.ts.txInToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.txIn.ts.txInToObj",
      "name": "txInToObj",
      "type": "any",
      "value": "(txIn: TxIn): object => {",
      "isPublic": true,
      "line": 11,
      "raw": "export const txInToObj = (txIn: TxIn): object => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.txIn.ts.collateralTxInToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.txIn.ts.collateralTxInToObj",
      "name": "collateralTxInToObj",
      "type": "any",
      "value": "(txIn: TxIn): object => {",
      "isPublic": true,
      "line": 40,
      "raw": "export const collateralTxInToObj = (txIn: TxIn): object => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.txIn.ts.txInParameterToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.txIn.ts.txInParameterToObj",
      "name": "txInParameterToObj",
      "type": "any",
      "value": "(txInParameter: TxInParameter): object => {",
      "isPublic": true,
      "line": 46,
      "raw": "export const txInParameterToObj = (txInParameter: TxInParameter): object => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.txIn.ts.scriptTxInParameterToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.txIn.ts.scriptTxInParameterToObj",
      "name": "scriptTxInParameterToObj",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 55,
      "raw": "export const scriptTxInParameterToObj = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.txIn.ts.simpleScriptTxInParameterToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.txIn.ts.simpleScriptTxInParameterToObj",
      "name": "simpleScriptTxInParameterToObj",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 94,
      "raw": "export const simpleScriptTxInParameterToObj = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.utxo.ts.utxoToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.utxo.ts.utxoToObj",
      "name": "utxoToObj",
      "type": "any",
      "value": "({",
      "isPublic": true,
      "line": 3,
      "raw": "export const utxoToObj = ({",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.vote.ts.voteToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.vote.ts.voteToObj",
      "name": "voteToObj",
      "type": "any",
      "value": "(vote: Vote): object => {",
      "isPublic": true,
      "line": 6,
      "raw": "export const voteToObj = (vote: Vote): object => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.vote.ts.voteTypeToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.vote.ts.voteTypeToObj",
      "name": "voteTypeToObj",
      "type": "any",
      "value": "(voteType: VoteType) => {",
      "isPublic": true,
      "line": 40,
      "raw": "const voteTypeToObj = (voteType: VoteType) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.adaptor.toObj.withdrawal.ts.withdrawalToObj",
      "fullName": "mesh-core-csl:core.adaptor.toObj.withdrawal.ts.withdrawalToObj",
      "name": "withdrawalToObj",
      "type": "any",
      "value": "(withdrawal: Withdrawal): object => {",
      "isPublic": true,
      "line": 6,
      "raw": "export const withdrawalToObj = (withdrawal: Withdrawal): object => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.VKEY_PUBKEY_SIZE_BYTES",
      "fullName": "mesh-core-csl:core.serializer.ts.VKEY_PUBKEY_SIZE_BYTES",
      "name": "VKEY_PUBKEY_SIZE_BYTES",
      "type": "any",
      "value": "32;",
      "isPublic": true,
      "line": 56,
      "raw": "const VKEY_PUBKEY_SIZE_BYTES = 32;",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.VKEY_SIGNATURE_SIZE_BYTES",
      "fullName": "mesh-core-csl:core.serializer.ts.VKEY_SIGNATURE_SIZE_BYTES",
      "name": "VKEY_SIGNATURE_SIZE_BYTES",
      "type": "any",
      "value": "64;",
      "isPublic": true,
      "line": 57,
      "raw": "const VKEY_SIGNATURE_SIZE_BYTES = 64;",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.CHAIN_CODE_SIZE_BYTES",
      "fullName": "mesh-core-csl:core.serializer.ts.CHAIN_CODE_SIZE_BYTES",
      "name": "CHAIN_CODE_SIZE_BYTES",
      "type": "any",
      "value": "32;",
      "isPublic": true,
      "line": 58,
      "raw": "const CHAIN_CODE_SIZE_BYTES = 32;",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.txBodyJson",
      "fullName": "mesh-core-csl:core.serializer.ts.txBodyJson",
      "name": "txBodyJson",
      "type": "any",
      "value": "JSONbig.stringify(meshTxBuilderBodyToObj(txBody));",
      "isPublic": true,
      "line": 78,
      "raw": "const txBodyJson = JSONbig.stringify(meshTxBuilderBodyToObj(txBody));",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.params",
      "fullName": "mesh-core-csl:core.serializer.ts.params",
      "name": "params",
      "type": "any",
      "value": "JSONbig.stringify(protocolParams || this.protocolParams);",
      "isPublic": true,
      "line": 79,
      "raw": "const params = JSONbig.stringify(protocolParams || this.protocolParams);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.txBuildResult",
      "fullName": "mesh-core-csl:core.serializer.ts.txBuildResult",
      "name": "txBuildResult",
      "type": "any",
      "value": "csl.js_serialize_tx_body(txBodyJson, params);",
      "isPublic": true,
      "line": 81,
      "raw": "const txBuildResult = csl.js_serialize_tx_body(txBodyJson, params);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.nativeScript",
      "fullName": "mesh-core-csl:core.serializer.ts.nativeScript",
      "name": "nativeScript",
      "type": "any",
      "value": "toNativeScript(script);",
      "isPublic": true,
      "line": 130,
      "raw": "const nativeScript = toNativeScript(script);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.scriptCbor",
      "fullName": "mesh-core-csl:core.serializer.ts.scriptCbor",
      "name": "scriptCbor",
      "type": "any",
      "value": "nativeScript.to_hex();",
      "isPublic": true,
      "line": 131,
      "raw": "const scriptCbor = nativeScript.to_hex();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.scriptHash",
      "fullName": "mesh-core-csl:core.serializer.ts.scriptHash",
      "name": "scriptHash",
      "type": "any",
      "value": "deserializePlutusScript(script.code, script.version)",
      "isPublic": true,
      "line": 141,
      "raw": "const scriptHash = deserializePlutusScript(script.code, script.version)",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.txHex",
      "fullName": "mesh-core-csl:core.serializer.ts.txHex",
      "name": "txHex",
      "type": "any",
      "value": "this.serializeTxBody(txBuilderBody, protocolParams);",
      "isPublic": true,
      "line": 264,
      "raw": "const txHex = this.serializeTxBody(txBuilderBody, protocolParams);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.cslTx",
      "fullName": "mesh-core-csl:core.serializer.ts.cslTx",
      "name": "cslTx",
      "type": "any",
      "value": "csl.Transaction.from_hex(txHex);",
      "isPublic": true,
      "line": 265,
      "raw": "const cslTx = csl.Transaction.from_hex(txHex);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.mockWitnessSet",
      "fullName": "mesh-core-csl:core.serializer.ts.mockWitnessSet",
      "name": "mockWitnessSet",
      "type": "any",
      "value": "cslTx.witness_set();",
      "isPublic": true,
      "line": 266,
      "raw": "const mockWitnessSet = cslTx.witness_set();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.mockVkeyWitnesses",
      "fullName": "mesh-core-csl:core.serializer.ts.mockVkeyWitnesses",
      "name": "mockVkeyWitnesses",
      "type": "any",
      "value": "mockWitnessSet.vkeys() ?? csl.Vkeywitnesses.new();",
      "isPublic": true,
      "line": 267,
      "raw": "const mockVkeyWitnesses = mockWitnessSet.vkeys() ?? csl.Vkeywitnesses.new();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.numberInHex",
      "fullName": "mesh-core-csl:core.serializer.ts.numberInHex",
      "name": "numberInHex",
      "type": "any",
      "value": "this.numberToIntegerHex(i);",
      "isPublic": true,
      "line": 284,
      "raw": "const numberInHex = this.numberToIntegerHex(i);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.mockVkey",
      "fullName": "mesh-core-csl:core.serializer.ts.mockVkey",
      "name": "mockVkey",
      "type": "any",
      "value": "csl.Vkey.new(csl.PublicKey.from_hex(pubKeyHex));",
      "isPublic": true,
      "line": 286,
      "raw": "const mockVkey = csl.Vkey.new(csl.PublicKey.from_hex(pubKeyHex));",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.mockSignature",
      "fullName": "mesh-core-csl:core.serializer.ts.mockSignature",
      "name": "mockSignature",
      "type": "any",
      "value": "csl.Ed25519Signature.from_hex(",
      "isPublic": true,
      "line": 276,
      "raw": "const mockSignature = csl.Ed25519Signature.from_hex(",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.address",
      "fullName": "mesh-core-csl:core.serializer.ts.address",
      "name": "address",
      "type": "any",
      "value": "csl.ByronAddress.from_base58(bootstrapWitness);",
      "isPublic": true,
      "line": 283,
      "raw": "const address = csl.ByronAddress.from_base58(bootstrapWitness);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.pubKeyHex",
      "fullName": "mesh-core-csl:core.serializer.ts.pubKeyHex",
      "name": "pubKeyHex",
      "type": "any",
      "value": "this.mockPubkey(numberInHex);",
      "isPublic": true,
      "line": 285,
      "raw": "const pubKeyHex = this.mockPubkey(numberInHex);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.signature",
      "fullName": "mesh-core-csl:core.serializer.ts.signature",
      "name": "signature",
      "type": "any",
      "value": "this.mockSignature(numberInHex);",
      "isPublic": true,
      "line": 287,
      "raw": "const signature = this.mockSignature(numberInHex);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.chainCode",
      "fullName": "mesh-core-csl:core.serializer.ts.chainCode",
      "name": "chainCode",
      "type": "any",
      "value": "this.mockChainCode(numberInHex);",
      "isPublic": true,
      "line": 288,
      "raw": "const chainCode = this.mockChainCode(numberInHex);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.parser",
      "fullName": "mesh-core-csl:core.serializer.ts.parser",
      "name": "parser",
      "type": "any",
      "value": "new CSLParser(txHex, resolvedUtxos);",
      "isPublic": true,
      "line": 317,
      "raw": "const parser = new CSLParser(txHex, resolvedUtxos);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:core.serializer.ts.txBuilderBody",
      "fullName": "mesh-core-csl:core.serializer.ts.txBuilderBody",
      "name": "txBuilderBody",
      "type": "any",
      "value": "{ ...this.parserTxBody };",
      "isPublic": true,
      "line": 327,
      "raw": "const txBuilderBody = { ...this.parserTxBody };",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.constants.ts.LANGUAGE_VERSIONS",
      "fullName": "mesh-core-csl:deser.constants.ts.LANGUAGE_VERSIONS",
      "name": "LANGUAGE_VERSIONS",
      "type": "any",
      "value": "{",
      "isPublic": true,
      "line": 3,
      "raw": "export const LANGUAGE_VERSIONS = {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.constants.ts.REDEEMER_TAGS",
      "fullName": "mesh-core-csl:deser.constants.ts.REDEEMER_TAGS",
      "name": "REDEEMER_TAGS",
      "type": "any",
      "value": "{",
      "isPublic": true,
      "line": 9,
      "raw": "export const REDEEMER_TAGS = {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.constants.ts.POLICY_ID_LENGTH",
      "fullName": "mesh-core-csl:deser.constants.ts.POLICY_ID_LENGTH",
      "name": "POLICY_ID_LENGTH",
      "type": "any",
      "value": "56;",
      "isPublic": true,
      "line": 16,
      "raw": "export const POLICY_ID_LENGTH = 56;",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toAddress",
      "fullName": "mesh-core-csl:deser.converter.ts.toAddress",
      "name": "toAddress",
      "type": "any",
      "value": "(bech32: string) => csl.Address.from_bech32(bech32);",
      "isPublic": true,
      "line": 23,
      "raw": "export const toAddress = (bech32: string) => csl.Address.from_bech32(bech32);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toBaseAddress",
      "fullName": "mesh-core-csl:deser.converter.ts.toBaseAddress",
      "name": "toBaseAddress",
      "type": "any",
      "value": "(bech32: string) =>",
      "isPublic": true,
      "line": 25,
      "raw": "export const toBaseAddress = (bech32: string) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toEnterpriseAddress",
      "fullName": "mesh-core-csl:deser.converter.ts.toEnterpriseAddress",
      "name": "toEnterpriseAddress",
      "type": "any",
      "value": "(bech32: string) =>",
      "isPublic": true,
      "line": 28,
      "raw": "export const toEnterpriseAddress = (bech32: string) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toRewardAddress",
      "fullName": "mesh-core-csl:deser.converter.ts.toRewardAddress",
      "name": "toRewardAddress",
      "type": "any",
      "value": "(bech32: string) =>",
      "isPublic": true,
      "line": 31,
      "raw": "export const toRewardAddress = (bech32: string) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.fromBytes",
      "fullName": "mesh-core-csl:deser.converter.ts.fromBytes",
      "name": "fromBytes",
      "type": "any",
      "value": "(bytes: Uint8Array) =>",
      "isPublic": true,
      "line": 36,
      "raw": "export const fromBytes = (bytes: Uint8Array) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toBytes",
      "fullName": "mesh-core-csl:deser.converter.ts.toBytes",
      "name": "toBytes",
      "type": "any",
      "value": "(hex: string): Uint8Array => {",
      "isPublic": true,
      "line": 39,
      "raw": "export const toBytes = (hex: string): Uint8Array => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.fromUTF8",
      "fullName": "mesh-core-csl:deser.converter.ts.fromUTF8",
      "name": "fromUTF8",
      "type": "any",
      "value": "(utf8: string) => {",
      "isPublic": true,
      "line": 48,
      "raw": "export const fromUTF8 = (utf8: string) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toUTF8",
      "fullName": "mesh-core-csl:deser.converter.ts.toUTF8",
      "name": "toUTF8",
      "type": "any",
      "value": "(hex: string) =>",
      "isPublic": true,
      "line": 54,
      "raw": "export const toUTF8 = (hex: string) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.fromLovelace",
      "fullName": "mesh-core-csl:deser.converter.ts.fromLovelace",
      "name": "fromLovelace",
      "type": "any",
      "value": "(lovelace: number) => lovelace / 1_000_000;",
      "isPublic": true,
      "line": 59,
      "raw": "export const fromLovelace = (lovelace: number) => lovelace / 1_000_000;",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toLovelace",
      "fullName": "mesh-core-csl:deser.converter.ts.toLovelace",
      "name": "toLovelace",
      "type": "any",
      "value": "(ada: number) => ada * 1_000_000;",
      "isPublic": true,
      "line": 61,
      "raw": "export const toLovelace = (ada: number) => ada * 1_000_000;",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toScriptRef",
      "fullName": "mesh-core-csl:deser.converter.ts.toScriptRef",
      "name": "toScriptRef",
      "type": "any",
      "value": "(script: PlutusScript | NativeScript) => {",
      "isPublic": true,
      "line": 148,
      "raw": "export const toScriptRef = (script: PlutusScript | NativeScript) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.plutusScript",
      "fullName": "mesh-core-csl:deser.converter.ts.plutusScript",
      "name": "plutusScript",
      "type": "any",
      "value": "deserializePlutusScript(script.code, script.version);",
      "isPublic": true,
      "line": 150,
      "raw": "const plutusScript = deserializePlutusScript(script.code, script.version);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toPlutusData",
      "fullName": "mesh-core-csl:deser.converter.ts.toPlutusData",
      "name": "toPlutusData",
      "type": "any",
      "value": "(data: Data): csl.PlutusData => {",
      "isPublic": true,
      "line": 160,
      "raw": "export const toPlutusData = (data: Data): csl.PlutusData => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toPlutusList",
      "fullName": "mesh-core-csl:deser.converter.ts.toPlutusList",
      "name": "toPlutusList",
      "type": "any",
      "value": "(dataArray: Data[]) => {",
      "isPublic": true,
      "line": 161,
      "raw": "const toPlutusList = (dataArray: Data[]) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.plutusList",
      "fullName": "mesh-core-csl:deser.converter.ts.plutusList",
      "name": "plutusList",
      "type": "any",
      "value": "toPlutusList(data);",
      "isPublic": true,
      "line": 179,
      "raw": "const plutusList = toPlutusList(data);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.plutusMap",
      "fullName": "mesh-core-csl:deser.converter.ts.plutusMap",
      "name": "plutusMap",
      "type": "any",
      "value": "csl.PlutusMap.new();",
      "isPublic": true,
      "line": 183,
      "raw": "const plutusMap = csl.PlutusMap.new();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.plutusMapValue",
      "fullName": "mesh-core-csl:deser.converter.ts.plutusMapValue",
      "name": "plutusMapValue",
      "type": "any",
      "value": "csl.PlutusMapValues.new();",
      "isPublic": true,
      "line": 185,
      "raw": "const plutusMapValue = csl.PlutusMapValues.new();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.castRawDataToJsonString",
      "fullName": "mesh-core-csl:deser.converter.ts.castRawDataToJsonString",
      "name": "castRawDataToJsonString",
      "type": "any",
      "value": "(rawData: object | string) => {",
      "isPublic": true,
      "line": 200,
      "raw": "export const castRawDataToJsonString = (rawData: object | string) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.castDataToPlutusData",
      "fullName": "mesh-core-csl:deser.converter.ts.castDataToPlutusData",
      "name": "castDataToPlutusData",
      "type": "any",
      "value": "({",
      "isPublic": true,
      "line": 207,
      "raw": "export const castDataToPlutusData = ({",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toNativeScript",
      "fullName": "mesh-core-csl:deser.converter.ts.toNativeScript",
      "name": "toNativeScript",
      "type": "any",
      "value": "(script: NativeScript) => {",
      "isPublic": true,
      "line": 223,
      "raw": "export const toNativeScript = (script: NativeScript) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toNativeScripts",
      "fullName": "mesh-core-csl:deser.converter.ts.toNativeScripts",
      "name": "toNativeScripts",
      "type": "any",
      "value": "(scripts: NativeScript[]) => {",
      "isPublic": true,
      "line": 224,
      "raw": "const toNativeScripts = (scripts: NativeScript[]) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.nativeScripts",
      "fullName": "mesh-core-csl:deser.converter.ts.nativeScripts",
      "name": "nativeScripts",
      "type": "any",
      "value": "csl.NativeScripts.new();",
      "isPublic": true,
      "line": 225,
      "raw": "const nativeScripts = csl.NativeScripts.new();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.toCslValue",
      "fullName": "mesh-core-csl:deser.converter.ts.toCslValue",
      "name": "toCslValue",
      "type": "any",
      "value": "(assets: Asset[]): csl.Value => {",
      "isPublic": true,
      "line": 262,
      "raw": "export const toCslValue = (assets: Asset[]): csl.Value => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.policyId",
      "fullName": "mesh-core-csl:deser.converter.ts.policyId",
      "name": "policyId",
      "type": "any",
      "value": "csl.ScriptHash.from_hex(asset.unit.slice(0, 56));",
      "isPublic": true,
      "line": 269,
      "raw": "const policyId = csl.ScriptHash.from_hex(asset.unit.slice(0, 56));",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.assetName",
      "fullName": "mesh-core-csl:deser.converter.ts.assetName",
      "name": "assetName",
      "type": "any",
      "value": "csl.AssetName.new(",
      "isPublic": true,
      "line": 270,
      "raw": "const assetName = csl.AssetName.new(",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.converter.ts.quantity",
      "fullName": "mesh-core-csl:deser.converter.ts.quantity",
      "name": "quantity",
      "type": "any",
      "value": "csl.BigNum.from_str(asset.quantity);",
      "isPublic": true,
      "line": 273,
      "raw": "const quantity = csl.BigNum.from_str(asset.quantity);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeAddress",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeAddress",
      "name": "deserializeAddress",
      "type": "any",
      "value": "(address: string) =>",
      "isPublic": true,
      "line": 8,
      "raw": "export const deserializeAddress = (address: string) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeBip32PrivateKey",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeBip32PrivateKey",
      "name": "deserializeBip32PrivateKey",
      "type": "any",
      "value": "(bip32PrivateKey: string) =>",
      "isPublic": true,
      "line": 11,
      "raw": "export const deserializeBip32PrivateKey = (bip32PrivateKey: string) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeDataHash",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeDataHash",
      "name": "deserializeDataHash",
      "type": "any",
      "value": "(dataHash: string) =>",
      "isPublic": true,
      "line": 14,
      "raw": "export const deserializeDataHash = (dataHash: string) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeEd25519KeyHash",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeEd25519KeyHash",
      "name": "deserializeEd25519KeyHash",
      "type": "any",
      "value": "(ed25519KeyHash: string) =>",
      "isPublic": true,
      "line": 17,
      "raw": "export const deserializeEd25519KeyHash = (ed25519KeyHash: string) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeEd25519Signature",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeEd25519Signature",
      "name": "deserializeEd25519Signature",
      "type": "any",
      "value": "(ed25519Signature: string) =>",
      "isPublic": true,
      "line": 20,
      "raw": "export const deserializeEd25519Signature = (ed25519Signature: string) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeNativeScript",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeNativeScript",
      "name": "deserializeNativeScript",
      "type": "any",
      "value": "(nativeScript: string) =>",
      "isPublic": true,
      "line": 23,
      "raw": "export const deserializeNativeScript = (nativeScript: string) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializePublicKey",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializePublicKey",
      "name": "deserializePublicKey",
      "type": "any",
      "value": "(publicKey: string) =>",
      "isPublic": true,
      "line": 26,
      "raw": "export const deserializePublicKey = (publicKey: string) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializePlutusData",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializePlutusData",
      "name": "deserializePlutusData",
      "type": "any",
      "value": "(plutusData: string) =>",
      "isPublic": true,
      "line": 29,
      "raw": "export const deserializePlutusData = (plutusData: string) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializePlutusScript",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializePlutusScript",
      "name": "deserializePlutusScript",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 32,
      "raw": "export const deserializePlutusScript = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeScriptRef",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeScriptRef",
      "name": "deserializeScriptRef",
      "type": "any",
      "value": "(scriptRef: string) =>",
      "isPublic": true,
      "line": 41,
      "raw": "export const deserializeScriptRef = (scriptRef: string) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeScriptHash",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeScriptHash",
      "name": "deserializeScriptHash",
      "type": "any",
      "value": "(scriptHash: string) =>",
      "isPublic": true,
      "line": 44,
      "raw": "export const deserializeScriptHash = (scriptHash: string) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeTx",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeTx",
      "name": "deserializeTx",
      "type": "any",
      "value": "(tx: string) =>",
      "isPublic": true,
      "line": 47,
      "raw": "export const deserializeTx = (tx: string) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeTxBody",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeTxBody",
      "name": "deserializeTxBody",
      "type": "any",
      "value": "(txBody: string) =>",
      "isPublic": true,
      "line": 50,
      "raw": "export const deserializeTxBody = (txBody: string) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeTxHash",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeTxHash",
      "name": "deserializeTxHash",
      "type": "any",
      "value": "(txHash: string) =>",
      "isPublic": true,
      "line": 53,
      "raw": "export const deserializeTxHash = (txHash: string) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeTxUnspentOutput",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeTxUnspentOutput",
      "name": "deserializeTxUnspentOutput",
      "type": "any",
      "value": "(txUnspentOutput: string) =>",
      "isPublic": true,
      "line": 56,
      "raw": "export const deserializeTxUnspentOutput = (txUnspentOutput: string) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeTxWitnessSet",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeTxWitnessSet",
      "name": "deserializeTxWitnessSet",
      "type": "any",
      "value": "(txWitnessSet: string) =>",
      "isPublic": true,
      "line": 59,
      "raw": "export const deserializeTxWitnessSet = (txWitnessSet: string) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.deserializer.ts.deserializeValue",
      "fullName": "mesh-core-csl:deser.deserializer.ts.deserializeValue",
      "name": "deserializeValue",
      "type": "any",
      "value": "(value: string) =>",
      "isPublic": true,
      "line": 62,
      "raw": "export const deserializeValue = (value: string) =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolveStakeKeyHash",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolveStakeKeyHash",
      "name": "resolveStakeKeyHash",
      "type": "any",
      "value": "(bech32: string) => {",
      "isPublic": true,
      "line": 22,
      "raw": "export const resolveStakeKeyHash = (bech32: string) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.stakeKeyHash",
      "fullName": "mesh-core-csl:deser.resolver.ts.stakeKeyHash",
      "name": "stakeKeyHash",
      "type": "any",
      "value": "baseAddress?.stake_cred().to_keyhash();",
      "isPublic": true,
      "line": 109,
      "raw": "const stakeKeyHash = baseAddress?.stake_cred().to_keyhash();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolvePrivateKey",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolvePrivateKey",
      "name": "resolvePrivateKey",
      "type": "any",
      "value": "(words: string[]) => {",
      "isPublic": true,
      "line": 37,
      "raw": "export const resolvePrivateKey = (words: string[]) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.buildBip32PrivateKey",
      "fullName": "mesh-core-csl:deser.resolver.ts.buildBip32PrivateKey",
      "name": "buildBip32PrivateKey",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 38,
      "raw": "const buildBip32PrivateKey = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.entropy",
      "fullName": "mesh-core-csl:deser.resolver.ts.entropy",
      "name": "entropy",
      "type": "any",
      "value": "mnemonicToEntropy(words.join(\" \"));",
      "isPublic": true,
      "line": 48,
      "raw": "const entropy = mnemonicToEntropy(words.join(\" \"));",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.bip32PrivateKey",
      "fullName": "mesh-core-csl:deser.resolver.ts.bip32PrivateKey",
      "name": "bip32PrivateKey",
      "type": "any",
      "value": "buildBip32PrivateKey(entropy);",
      "isPublic": true,
      "line": 49,
      "raw": "const bip32PrivateKey = buildBip32PrivateKey(entropy);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.bech32PrivateKey",
      "fullName": "mesh-core-csl:deser.resolver.ts.bech32PrivateKey",
      "name": "bech32PrivateKey",
      "type": "any",
      "value": "bip32PrivateKey.to_bech32();",
      "isPublic": true,
      "line": 50,
      "raw": "const bech32PrivateKey = bip32PrivateKey.to_bech32();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolveNativeScriptAddress",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolveNativeScriptAddress",
      "name": "resolveNativeScriptAddress",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 57,
      "raw": "export const resolveNativeScriptAddress = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.nativeScript",
      "fullName": "mesh-core-csl:deser.resolver.ts.nativeScript",
      "name": "nativeScript",
      "type": "any",
      "value": "toNativeScript(script);",
      "isPublic": true,
      "line": 61,
      "raw": "const nativeScript = toNativeScript(script);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.enterpriseAddress",
      "fullName": "mesh-core-csl:deser.resolver.ts.enterpriseAddress",
      "name": "enterpriseAddress",
      "type": "any",
      "value": "csl.EnterpriseAddress.new(",
      "isPublic": true,
      "line": 77,
      "raw": "const enterpriseAddress = csl.EnterpriseAddress.new(",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolvePlutusScriptAddress",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolvePlutusScriptAddress",
      "name": "resolvePlutusScriptAddress",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 71,
      "raw": "export const resolvePlutusScriptAddress = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.plutusScript",
      "fullName": "mesh-core-csl:deser.resolver.ts.plutusScript",
      "name": "plutusScript",
      "type": "any",
      "value": "deserializePlutusScript(script.code, script.version);",
      "isPublic": true,
      "line": 75,
      "raw": "const plutusScript = deserializePlutusScript(script.code, script.version);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolveNativeScriptHash",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolveNativeScriptHash",
      "name": "resolveNativeScriptHash",
      "type": "any",
      "value": "(script: NativeScript) => {",
      "isPublic": true,
      "line": 85,
      "raw": "export const resolveNativeScriptHash = (script: NativeScript) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolveScriptHashDRepId",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolveScriptHashDRepId",
      "name": "resolveScriptHashDRepId",
      "type": "any",
      "value": "(scriptHash: string) => {",
      "isPublic": true,
      "line": 89,
      "raw": "export const resolveScriptHashDRepId = (scriptHash: string) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolveRewardAddress",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolveRewardAddress",
      "name": "resolveRewardAddress",
      "type": "any",
      "value": "(bech32: string) => {",
      "isPublic": true,
      "line": 95,
      "raw": "export const resolveRewardAddress = (bech32: string) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.buildRewardAddress",
      "fullName": "mesh-core-csl:deser.resolver.ts.buildRewardAddress",
      "name": "buildRewardAddress",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 96,
      "raw": "const buildRewardAddress = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.address",
      "fullName": "mesh-core-csl:deser.resolver.ts.address",
      "name": "address",
      "type": "any",
      "value": "toAddress(bech32);",
      "isPublic": true,
      "line": 107,
      "raw": "const address = toAddress(bech32);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.baseAddress",
      "fullName": "mesh-core-csl:deser.resolver.ts.baseAddress",
      "name": "baseAddress",
      "type": "any",
      "value": "toBaseAddress(bech32);",
      "isPublic": true,
      "line": 108,
      "raw": "const baseAddress = toBaseAddress(bech32);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolveDataHash",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolveDataHash",
      "name": "resolveDataHash",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 122,
      "raw": "export const resolveDataHash = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.plutusData",
      "fullName": "mesh-core-csl:deser.resolver.ts.plutusData",
      "name": "plutusData",
      "type": "any",
      "value": "castDataToPlutusData({",
      "isPublic": true,
      "line": 126,
      "raw": "const plutusData = castDataToPlutusData({",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.dataHash",
      "fullName": "mesh-core-csl:deser.resolver.ts.dataHash",
      "name": "dataHash",
      "type": "any",
      "value": "csl.hash_plutus_data(plutusData);",
      "isPublic": true,
      "line": 130,
      "raw": "const dataHash = csl.hash_plutus_data(plutusData);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolveNativeScriptHex",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolveNativeScriptHex",
      "name": "resolveNativeScriptHex",
      "type": "any",
      "value": "(script: NativeScript) => {",
      "isPublic": true,
      "line": 134,
      "raw": "export const resolveNativeScriptHex = (script: NativeScript) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.serializePoolId",
      "fullName": "mesh-core-csl:deser.resolver.ts.serializePoolId",
      "name": "serializePoolId",
      "type": "any",
      "value": "(hash: string) => {",
      "isPublic": true,
      "line": 138,
      "raw": "export const serializePoolId = (hash: string) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolveScriptRef",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolveScriptRef",
      "name": "resolveScriptRef",
      "type": "any",
      "value": "(script: PlutusScript | NativeScript) => {",
      "isPublic": true,
      "line": 142,
      "raw": "export const resolveScriptRef = (script: PlutusScript | NativeScript) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:deser.resolver.ts.resolveEd25519KeyHash",
      "fullName": "mesh-core-csl:deser.resolver.ts.resolveEd25519KeyHash",
      "name": "resolveEd25519KeyHash",
      "type": "any",
      "value": "(bech32: string) => {",
      "isPublic": true,
      "line": 146,
      "raw": "export const resolveEd25519KeyHash = (bech32: string) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:offline-providers.offline-evaluator.ts.foundUtxos",
      "fullName": "mesh-core-csl:offline-providers.offline-evaluator.ts.foundUtxos",
      "name": "foundUtxos",
      "type": "any",
      "value": "new Set<string>();",
      "isPublic": true,
      "line": 116,
      "raw": "const foundUtxos = new Set<string>();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:offline-providers.offline-evaluator.ts.outputs",
      "fullName": "mesh-core-csl:offline-providers.offline-evaluator.ts.outputs",
      "name": "outputs",
      "type": "any",
      "value": "getTransactionOutputs(tx);",
      "isPublic": true,
      "line": 122,
      "raw": "const outputs = getTransactionOutputs(tx);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:offline-providers.offline-evaluator.ts.inputsToResolve",
      "fullName": "mesh-core-csl:offline-providers.offline-evaluator.ts.inputsToResolve",
      "name": "inputsToResolve",
      "type": "any",
      "value": "getTransactionInputs(tx).filter(",
      "isPublic": true,
      "line": 127,
      "raw": "const inputsToResolve = getTransactionInputs(tx).filter(",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:offline-providers.offline-evaluator.ts.txHashesSet",
      "fullName": "mesh-core-csl:offline-providers.offline-evaluator.ts.txHashesSet",
      "name": "txHashesSet",
      "type": "any",
      "value": "new Set(inputsToResolve.map((input) => input.txHash));",
      "isPublic": true,
      "line": 130,
      "raw": "const txHashesSet = new Set(inputsToResolve.map((input) => input.txHash));",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:offline-providers.offline-evaluator.ts.utxos",
      "fullName": "mesh-core-csl:offline-providers.offline-evaluator.ts.utxos",
      "name": "utxos",
      "type": "any",
      "value": "await this.fetcher.fetchUTxOs(txHash);",
      "isPublic": true,
      "line": 132,
      "raw": "const utxos = await this.fetcher.fetchUTxOs(txHash);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:offline-providers.offline-evaluator.ts.missing",
      "fullName": "mesh-core-csl:offline-providers.offline-evaluator.ts.missing",
      "name": "missing",
      "type": "any",
      "value": "inputsToResolve.filter(",
      "isPublic": true,
      "line": 147,
      "raw": "const missing = inputsToResolve.filter(",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:offline-providers.offline-evaluator.ts.missingList",
      "fullName": "mesh-core-csl:offline-providers.offline-evaluator.ts.missingList",
      "name": "missingList",
      "type": "any",
      "value": "missing",
      "isPublic": true,
      "line": 151,
      "raw": "const missingList = missing",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:parser.index.ts.jsUtxos",
      "fullName": "mesh-core-csl:parser.index.ts.jsUtxos",
      "name": "jsUtxos",
      "type": "any",
      "value": "JsVecString.new();",
      "isPublic": true,
      "line": 18,
      "raw": "const jsUtxos = JsVecString.new();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:parser.index.ts.wasmResult",
      "fullName": "mesh-core-csl:parser.index.ts.wasmResult",
      "name": "wasmResult",
      "type": "any",
      "value": "js_parse_tx_body(txHex, jsUtxos);",
      "isPublic": true,
      "line": 23,
      "raw": "const wasmResult = js_parse_tx_body(txHex, jsUtxos);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:parser.index.ts.txBodyJson",
      "fullName": "mesh-core-csl:parser.index.ts.txBodyJson",
      "name": "txBodyJson",
      "type": "any",
      "value": "wasmResult.get_data();",
      "isPublic": true,
      "line": 27,
      "raw": "const txBodyJson = wasmResult.get_data();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:parser.index.ts.txBodyObj",
      "fullName": "mesh-core-csl:parser.index.ts.txBodyObj",
      "name": "txBodyObj",
      "type": "any",
      "value": "txBuilderBodyFromObj(txBodyJson);",
      "isPublic": true,
      "line": 30,
      "raw": "const txBodyObj = txBuilderBodyFromObj(txBodyJson);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.serialzeAddress",
      "fullName": "mesh-core-csl:utils.address.ts.serialzeAddress",
      "name": "serialzeAddress",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 12,
      "raw": "export const serialzeAddress = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.isPaymentScript",
      "fullName": "mesh-core-csl:utils.address.ts.isPaymentScript",
      "name": "isPaymentScript",
      "type": "any",
      "value": "!pubKeyHash;",
      "isPublic": true,
      "line": 23,
      "raw": "const isPaymentScript = !pubKeyHash;",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.isStakeScript",
      "fullName": "mesh-core-csl:utils.address.ts.isStakeScript",
      "name": "isStakeScript",
      "type": "any",
      "value": "!stakeCredentialHash;",
      "isPublic": true,
      "line": 24,
      "raw": "const isStakeScript = !stakeCredentialHash;",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.paymentHash",
      "fullName": "mesh-core-csl:utils.address.ts.paymentHash",
      "name": "paymentHash",
      "type": "any",
      "value": "isPaymentScript ? scriptHash : pubKeyHash;",
      "isPublic": true,
      "line": 26,
      "raw": "const paymentHash = isPaymentScript ? scriptHash : pubKeyHash;",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.stakeHash",
      "fullName": "mesh-core-csl:utils.address.ts.stakeHash",
      "name": "stakeHash",
      "type": "any",
      "value": "isStakeScript",
      "isPublic": true,
      "line": 28,
      "raw": "const stakeHash = isStakeScript",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.addressObj",
      "fullName": "mesh-core-csl:utils.address.ts.addressObj",
      "name": "addressObj",
      "type": "any",
      "value": "isPaymentScript",
      "isPublic": true,
      "line": 37,
      "raw": "const addressObj = isPaymentScript",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.addrBech32ToPlutusDataHex",
      "fullName": "mesh-core-csl:utils.address.ts.addrBech32ToPlutusDataHex",
      "name": "addrBech32ToPlutusDataHex",
      "type": "any",
      "value": "(bech32: string): string => {",
      "isPublic": true,
      "line": 43,
      "raw": "export const addrBech32ToPlutusDataHex = (bech32: string): string => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.hexAddress",
      "fullName": "mesh-core-csl:utils.address.ts.hexAddress",
      "name": "hexAddress",
      "type": "any",
      "value": "csl.Address.from_bech32(bech32).to_hex();",
      "isPublic": true,
      "line": 51,
      "raw": "const hexAddress = csl.Address.from_bech32(bech32).to_hex();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.cslAddress",
      "fullName": "mesh-core-csl:utils.address.ts.cslAddress",
      "name": "cslAddress",
      "type": "any",
      "value": "csl.Address.from_hex(hexAddress);",
      "isPublic": true,
      "line": 52,
      "raw": "const cslAddress = csl.Address.from_hex(hexAddress);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.hex",
      "fullName": "mesh-core-csl:utils.address.ts.hex",
      "name": "hex",
      "type": "any",
      "value": "csl.PlutusData.from_address(cslAddress).to_hex();",
      "isPublic": true,
      "line": 46,
      "raw": "const hex = csl.PlutusData.from_address(cslAddress).to_hex();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.addrBech32ToPlutusDataObj",
      "fullName": "mesh-core-csl:utils.address.ts.addrBech32ToPlutusDataObj",
      "name": "addrBech32ToPlutusDataObj",
      "type": "any",
      "value": "<T>(bech32: string): T => {",
      "isPublic": true,
      "line": 50,
      "raw": "export const addrBech32ToPlutusDataObj = <T>(bech32: string): T => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.json",
      "fullName": "mesh-core-csl:utils.address.ts.json",
      "name": "json",
      "type": "any",
      "value": "JSON.parse(csl.PlutusData.from_address(cslAddress).to_json(1));",
      "isPublic": true,
      "line": 53,
      "raw": "const json = JSON.parse(csl.PlutusData.from_address(cslAddress).to_json(1));",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.serializeAddressObj",
      "fullName": "mesh-core-csl:utils.address.ts.serializeAddressObj",
      "name": "serializeAddressObj",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 57,
      "raw": "export const serializeAddressObj = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.bech32Addr",
      "fullName": "mesh-core-csl:utils.address.ts.bech32Addr",
      "name": "bech32Addr",
      "type": "any",
      "value": "csl.parse_plutus_address_obj_to_bech32(",
      "isPublic": true,
      "line": 61,
      "raw": "const bech32Addr = csl.parse_plutus_address_obj_to_bech32(",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.serializePlutusAddressToBech32",
      "fullName": "mesh-core-csl:utils.address.ts.serializePlutusAddressToBech32",
      "name": "serializePlutusAddressToBech32",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 68,
      "raw": "export const serializePlutusAddressToBech32 = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.cslPlutusDataAddress",
      "fullName": "mesh-core-csl:utils.address.ts.cslPlutusDataAddress",
      "name": "cslPlutusDataAddress",
      "type": "any",
      "value": "csl.PlutusData.from_hex(plutusHex);",
      "isPublic": true,
      "line": 72,
      "raw": "const cslPlutusDataAddress = csl.PlutusData.from_hex(plutusHex);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.plutusDataAddressObject",
      "fullName": "mesh-core-csl:utils.address.ts.plutusDataAddressObject",
      "name": "plutusDataAddressObject",
      "type": "any",
      "value": "JSON.parse(",
      "isPublic": true,
      "line": 73,
      "raw": "const plutusDataAddressObject = JSON.parse(",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.deserializeBech32Address",
      "fullName": "mesh-core-csl:utils.address.ts.deserializeBech32Address",
      "name": "deserializeBech32Address",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 79,
      "raw": "export const deserializeBech32Address = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.deserializedAddress",
      "fullName": "mesh-core-csl:utils.address.ts.deserializedAddress",
      "name": "deserializedAddress",
      "type": "any",
      "value": "csl.deserialize_bech32_address(bech32Addr);",
      "isPublic": true,
      "line": 82,
      "raw": "const deserializedAddress = csl.deserialize_bech32_address(bech32Addr);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.scriptHashToBech32",
      "fullName": "mesh-core-csl:utils.address.ts.scriptHashToBech32",
      "name": "scriptHashToBech32",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 91,
      "raw": "export const scriptHashToBech32 = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.address.ts.v2ScriptToBech32",
      "fullName": "mesh-core-csl:utils.address.ts.v2ScriptToBech32",
      "name": "v2ScriptToBech32",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 104,
      "raw": "export const v2ScriptToBech32 = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.aiken.ts.applyParamsToScript",
      "fullName": "mesh-core-csl:utils.aiken.ts.applyParamsToScript",
      "name": "applyParamsToScript",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 13,
      "raw": "export const applyParamsToScript = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.aiken.ts.cslParams",
      "fullName": "mesh-core-csl:utils.aiken.ts.cslParams",
      "name": "cslParams",
      "type": "any",
      "value": "csl.JsVecString.new();",
      "isPublic": true,
      "line": 18,
      "raw": "const cslParams = csl.JsVecString.new();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.aiken.ts.paramCbor",
      "fullName": "mesh-core-csl:utils.aiken.ts.paramCbor",
      "name": "paramCbor",
      "type": "any",
      "value": "toPlutusData(param as Data);",
      "isPublic": true,
      "line": 35,
      "raw": "const paramCbor = toPlutusData(param as Data);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.aiken.ts.applyCborEncoding",
      "fullName": "mesh-core-csl:utils.aiken.ts.applyCborEncoding",
      "name": "applyCborEncoding",
      "type": "any",
      "value": "(rawScript: string): string => {",
      "isPublic": true,
      "line": 56,
      "raw": "export const applyCborEncoding = (rawScript: string): string => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.credentials.ts.skeyToPubKeyHash",
      "fullName": "mesh-core-csl:utils.credentials.ts.skeyToPubKeyHash",
      "name": "skeyToPubKeyHash",
      "type": "any",
      "value": "(skeyHex: string): string => {",
      "isPublic": true,
      "line": 3,
      "raw": "export const skeyToPubKeyHash = (skeyHex: string): string => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.credentials.ts.isHexUnclean",
      "fullName": "mesh-core-csl:utils.credentials.ts.isHexUnclean",
      "name": "isHexUnclean",
      "type": "any",
      "value": "skeyHex.slice(0, 4) === \"5820\" && skeyHex.length === 68;",
      "isPublic": true,
      "line": 4,
      "raw": "const isHexUnclean = skeyHex.slice(0, 4) === \"5820\" && skeyHex.length === 68;",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.credentials.ts.cleanHex",
      "fullName": "mesh-core-csl:utils.credentials.ts.cleanHex",
      "name": "cleanHex",
      "type": "any",
      "value": "isHexUnclean ? skeyHex.slice(4) : skeyHex;",
      "isPublic": true,
      "line": 5,
      "raw": "const cleanHex = isHexUnclean ? skeyHex.slice(4) : skeyHex;",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.datum.ts.parseInlineDatum",
      "fullName": "mesh-core-csl:utils.datum.ts.parseInlineDatum",
      "name": "parseInlineDatum",
      "type": "any",
      "value": "<T extends { inline_datum?: string }, X>(",
      "isPublic": true,
      "line": 4,
      "raw": "export const parseInlineDatum = <T extends { inline_datum?: string }, X>(",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.datum.ts.datumCbor",
      "fullName": "mesh-core-csl:utils.datum.ts.datumCbor",
      "name": "datumCbor",
      "type": "string",
      "value": "utxo.inline_datum || \"\";",
      "isPublic": true,
      "line": 7,
      "raw": "const datumCbor: string = utxo.inline_datum || \"\";",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.datum.ts.parsedDatum",
      "fullName": "mesh-core-csl:utils.datum.ts.parsedDatum",
      "name": "parsedDatum",
      "type": "any",
      "value": "csl.PlutusData.from_hex(datumCbor);",
      "isPublic": true,
      "line": 14,
      "raw": "const parsedDatum = csl.PlutusData.from_hex(datumCbor);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.datum.ts.datum",
      "fullName": "mesh-core-csl:utils.datum.ts.datum",
      "name": "datum",
      "type": "T",
      "value": "JSON.parse(parsedDatum.to_json(1));",
      "isPublic": true,
      "line": 15,
      "raw": "const datum: T = JSON.parse(parsedDatum.to_json(1));",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.datum.ts.parseDatumCbor",
      "fullName": "mesh-core-csl:utils.datum.ts.parseDatumCbor",
      "name": "parseDatumCbor",
      "type": "any",
      "value": "<T = any>(datumCbor: string): T => {",
      "isPublic": true,
      "line": 13,
      "raw": "export const parseDatumCbor = <T = any>(datumCbor: string): T => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.drep.ts.getDRepIds",
      "fullName": "mesh-core-csl:utils.drep.ts.getDRepIds",
      "name": "getDRepIds",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 5,
      "raw": "export const getDRepIds = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.drep.ts.cslDrep",
      "fullName": "mesh-core-csl:utils.drep.ts.cslDrep",
      "name": "cslDrep",
      "type": "any",
      "value": "csl.DRep.from_bech32(dRepId);",
      "isPublic": true,
      "line": 11,
      "raw": "const cslDrep = csl.DRep.from_bech32(dRepId);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.scripts.ts.getV2ScriptHash",
      "fullName": "mesh-core-csl:utils.scripts.ts.getV2ScriptHash",
      "name": "getV2ScriptHash",
      "type": "any",
      "value": "(script: string): string =>",
      "isPublic": true,
      "line": 3,
      "raw": "export const getV2ScriptHash = (script: string): string =>",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.staking.ts.poolIdHexToBech32",
      "fullName": "mesh-core-csl:utils.staking.ts.poolIdHexToBech32",
      "name": "poolIdHexToBech32",
      "type": "any",
      "value": "(poolIdHash: string) => {",
      "isPublic": true,
      "line": 3,
      "raw": "export const poolIdHexToBech32 = (poolIdHash: string) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.staking.ts.cslPoolIdHash",
      "fullName": "mesh-core-csl:utils.staking.ts.cslPoolIdHash",
      "name": "cslPoolIdHash",
      "type": "any",
      "value": "csl.Ed25519KeyHash.from_bech32(poolIdBech32);",
      "isPublic": true,
      "line": 9,
      "raw": "const cslPoolIdHash = csl.Ed25519KeyHash.from_bech32(poolIdBech32);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.staking.ts.poolIdBech32ToHex",
      "fullName": "mesh-core-csl:utils.staking.ts.poolIdBech32ToHex",
      "name": "poolIdBech32ToHex",
      "type": "any",
      "value": "(poolIdBech32: string) => {",
      "isPublic": true,
      "line": 8,
      "raw": "export const poolIdBech32ToHex = (poolIdBech32: string) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.staking.ts.baseAddressToStakeAddress",
      "fullName": "mesh-core-csl:utils.staking.ts.baseAddressToStakeAddress",
      "name": "baseAddressToStakeAddress",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 13,
      "raw": "export const baseAddressToStakeAddress = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.staking.ts.stakeCred",
      "fullName": "mesh-core-csl:utils.staking.ts.stakeCred",
      "name": "stakeCred",
      "type": "any",
      "value": "csl.BaseAddress.from_address(",
      "isPublic": true,
      "line": 21,
      "raw": "const stakeCred = csl.BaseAddress.from_address(",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.staking.ts.stakeAddress",
      "fullName": "mesh-core-csl:utils.staking.ts.stakeAddress",
      "name": "stakeAddress",
      "type": "any",
      "value": "csl.RewardAddress.new(networkId, stakeCred)",
      "isPublic": true,
      "line": 25,
      "raw": "const stakeAddress = csl.RewardAddress.new(networkId, stakeCred)",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.staking.ts.rewardAddressToKeyHash",
      "fullName": "mesh-core-csl:utils.staking.ts.rewardAddressToKeyHash",
      "name": "rewardAddressToKeyHash",
      "type": "any",
      "value": "(rewardBech32: string) => {",
      "isPublic": true,
      "line": 33,
      "raw": "export const rewardAddressToKeyHash = (rewardBech32: string) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.staking.ts.scriptHashToRewardAddress",
      "fullName": "mesh-core-csl:utils.staking.ts.scriptHashToRewardAddress",
      "name": "scriptHashToRewardAddress",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 37,
      "raw": "export const scriptHashToRewardAddress = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.staking.ts.scriptHash",
      "fullName": "mesh-core-csl:utils.staking.ts.scriptHash",
      "name": "scriptHash",
      "type": "any",
      "value": "csl.ScriptHash.from_hex(scriptHashHex);",
      "isPublic": true,
      "line": 45,
      "raw": "const scriptHash = csl.ScriptHash.from_hex(scriptHashHex);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.staking.ts.credential",
      "fullName": "mesh-core-csl:utils.staking.ts.credential",
      "name": "credential",
      "type": "any",
      "value": "csl.Credential.from_scripthash(keyHash);",
      "isPublic": true,
      "line": 59,
      "raw": "const credential = csl.Credential.from_scripthash(keyHash);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.staking.ts.rewardAddress",
      "fullName": "mesh-core-csl:utils.staking.ts.rewardAddress",
      "name": "rewardAddress",
      "type": "any",
      "value": "csl.RewardAddress.new(networkId, credential)",
      "isPublic": true,
      "line": 60,
      "raw": "const rewardAddress = csl.RewardAddress.new(networkId, credential)",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.staking.ts.keyHashToRewardAddress",
      "fullName": "mesh-core-csl:utils.staking.ts.keyHashToRewardAddress",
      "name": "keyHashToRewardAddress",
      "type": "any",
      "value": "(keyHashHex: string, network = 1) => {",
      "isPublic": true,
      "line": 53,
      "raw": "export const keyHashToRewardAddress = (keyHashHex: string, network = 1) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.staking.ts.keyHash",
      "fullName": "mesh-core-csl:utils.staking.ts.keyHash",
      "name": "keyHash",
      "type": "any",
      "value": "csl.Ed25519KeyHash.from_hex(keyHashHex);",
      "isPublic": true,
      "line": 58,
      "raw": "const keyHash = csl.Ed25519KeyHash.from_hex(keyHashHex);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction-parser.ts.getRequiredInputs",
      "fullName": "mesh-core-csl:utils.transaction-parser.ts.getRequiredInputs",
      "name": "getRequiredInputs",
      "type": "any",
      "value": "(transactionHex: string): TxInput[] => {",
      "isPublic": true,
      "line": 5,
      "raw": "export const getRequiredInputs = (transactionHex: string): TxInput[] => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction-parser.ts.result",
      "fullName": "mesh-core-csl:utils.transaction-parser.ts.result",
      "name": "result",
      "type": "any",
      "value": "js_get_required_inputs_to_resolve(transactionHex);",
      "isPublic": true,
      "line": 6,
      "raw": "const result = js_get_required_inputs_to_resolve(transactionHex);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction-parser.ts.utxosStr",
      "fullName": "mesh-core-csl:utils.transaction-parser.ts.utxosStr",
      "name": "utxosStr",
      "type": "string[]",
      "value": "JSON.parse(result.get_data());",
      "isPublic": true,
      "line": 10,
      "raw": "const utxosStr: string[] = JSON.parse(result.get_data());",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction-parser.ts.parts",
      "fullName": "mesh-core-csl:utils.transaction-parser.ts.parts",
      "name": "parts",
      "type": "any",
      "value": "utxoStr.split(\"#\");",
      "isPublic": true,
      "line": 13,
      "raw": "const parts = utxoStr.split(\"#\");",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.calculateTxHash",
      "fullName": "mesh-core-csl:utils.transaction.ts.calculateTxHash",
      "name": "calculateTxHash",
      "type": "any",
      "value": "(txHex: string) => {",
      "isPublic": true,
      "line": 56,
      "raw": "export const calculateTxHash = (txHex: string) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.result",
      "fullName": "mesh-core-csl:utils.transaction.ts.result",
      "name": "result",
      "type": "any",
      "value": "csl.js_evaluate_tx_scripts(",
      "isPublic": true,
      "line": 85,
      "raw": "const result = csl.js_evaluate_tx_scripts(",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.signTransaction",
      "fullName": "mesh-core-csl:utils.transaction.ts.signTransaction",
      "name": "signTransaction",
      "type": "any",
      "value": "(txHex: string, signingKeys: string[]) => {",
      "isPublic": true,
      "line": 61,
      "raw": "export const signTransaction = (txHex: string, signingKeys: string[]) => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.cslSigningKeys",
      "fullName": "mesh-core-csl:utils.transaction.ts.cslSigningKeys",
      "name": "cslSigningKeys",
      "type": "any",
      "value": "csl.JsVecString.new();",
      "isPublic": true,
      "line": 62,
      "raw": "const cslSigningKeys = csl.JsVecString.new();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.evaluateTransaction",
      "fullName": "mesh-core-csl:utils.transaction.ts.evaluateTransaction",
      "name": "evaluateTransaction",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 70,
      "raw": "export const evaluateTransaction = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.additionalTxs",
      "fullName": "mesh-core-csl:utils.transaction.ts.additionalTxs",
      "name": "additionalTxs",
      "type": "any",
      "value": "csl.JsVecString.new();",
      "isPublic": true,
      "line": 77,
      "raw": "const additionalTxs = csl.JsVecString.new();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.mappedUtxos",
      "fullName": "mesh-core-csl:utils.transaction.ts.mappedUtxos",
      "name": "mappedUtxos",
      "type": "any",
      "value": "csl.JsVecString.new();",
      "isPublic": true,
      "line": 81,
      "raw": "const mappedUtxos = csl.JsVecString.new();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.unwrappedResult",
      "fullName": "mesh-core-csl:utils.transaction.ts.unwrappedResult",
      "name": "unwrappedResult",
      "type": "any",
      "value": "parseWasmResult(result);",
      "isPublic": true,
      "line": 92,
      "raw": "const unwrappedResult = parseWasmResult(result);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.actions",
      "fullName": "mesh-core-csl:utils.transaction.ts.actions",
      "name": "actions",
      "type": "any",
      "value": "JSON.parse(unwrappedResult) as ActionWasm[];",
      "isPublic": true,
      "line": 94,
      "raw": "const actions = JSON.parse(unwrappedResult) as ActionWasm[];",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.mapAction",
      "fullName": "mesh-core-csl:utils.transaction.ts.mapAction",
      "name": "mapAction",
      "type": "any",
      "value": "(action: SuccessAction): Omit<Action, \"data\"> => {",
      "isPublic": true,
      "line": 112,
      "raw": "const mapAction = (action: SuccessAction): Omit<Action, \"data\"> => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.mapBudget",
      "fullName": "mesh-core-csl:utils.transaction.ts.mapBudget",
      "name": "mapBudget",
      "type": "any",
      "value": "(budget: BudgetWasm): Budget => {",
      "isPublic": true,
      "line": 120,
      "raw": "const mapBudget = (budget: BudgetWasm): Budget => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.mapRedeemerTag",
      "fullName": "mesh-core-csl:utils.transaction.ts.mapRedeemerTag",
      "name": "mapRedeemerTag",
      "type": "any",
      "value": "(tag: RedeemerTagWasm): RedeemerTagType => {",
      "isPublic": true,
      "line": 127,
      "raw": "const mapRedeemerTag = (tag: RedeemerTagWasm): RedeemerTagType => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.getTransactionInputs",
      "fullName": "mesh-core-csl:utils.transaction.ts.getTransactionInputs",
      "name": "getTransactionInputs",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 146,
      "raw": "export const getTransactionInputs = (",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.inputs",
      "fullName": "mesh-core-csl:utils.transaction.ts.inputs",
      "name": "inputs",
      "type": "any",
      "value": "[];",
      "isPublic": true,
      "line": 152,
      "raw": "const inputs = [];",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.deserializedTx",
      "fullName": "mesh-core-csl:utils.transaction.ts.deserializedTx",
      "name": "deserializedTx",
      "type": "any",
      "value": "deserializeTx(txHex);",
      "isPublic": true,
      "line": 153,
      "raw": "const deserializedTx = deserializeTx(txHex);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.body",
      "fullName": "mesh-core-csl:utils.transaction.ts.body",
      "name": "body",
      "type": "any",
      "value": "deserializedTx.body();",
      "isPublic": true,
      "line": 154,
      "raw": "const body = deserializedTx.body();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.cslInputs",
      "fullName": "mesh-core-csl:utils.transaction.ts.cslInputs",
      "name": "cslInputs",
      "type": "any",
      "value": "body.inputs();",
      "isPublic": true,
      "line": 155,
      "raw": "const cslInputs = body.inputs();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.input",
      "fullName": "mesh-core-csl:utils.transaction.ts.input",
      "name": "input",
      "type": "any",
      "value": "cslInputs.get(i);",
      "isPublic": true,
      "line": 157,
      "raw": "const input = cslInputs.get(i);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.cslCollaterals",
      "fullName": "mesh-core-csl:utils.transaction.ts.cslCollaterals",
      "name": "cslCollaterals",
      "type": "any",
      "value": "body.collateral();",
      "isPublic": true,
      "line": 163,
      "raw": "const cslCollaterals = body.collateral();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.collateral",
      "fullName": "mesh-core-csl:utils.transaction.ts.collateral",
      "name": "collateral",
      "type": "any",
      "value": "cslCollaterals.get(i);",
      "isPublic": true,
      "line": 166,
      "raw": "const collateral = cslCollaterals.get(i);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.cslRefInputs",
      "fullName": "mesh-core-csl:utils.transaction.ts.cslRefInputs",
      "name": "cslRefInputs",
      "type": "any",
      "value": "body.reference_inputs();",
      "isPublic": true,
      "line": 173,
      "raw": "const cslRefInputs = body.reference_inputs();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.refInput",
      "fullName": "mesh-core-csl:utils.transaction.ts.refInput",
      "name": "refInput",
      "type": "any",
      "value": "cslRefInputs.get(i);",
      "isPublic": true,
      "line": 176,
      "raw": "const refInput = cslRefInputs.get(i);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.getTransactionOutputs",
      "fullName": "mesh-core-csl:utils.transaction.ts.getTransactionOutputs",
      "name": "getTransactionOutputs",
      "type": "any",
      "value": "(txHex: string): UTxO[] => {",
      "isPublic": true,
      "line": 187,
      "raw": "export const getTransactionOutputs = (txHex: string): UTxO[] => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.outputs",
      "fullName": "mesh-core-csl:utils.transaction.ts.outputs",
      "name": "outputs",
      "type": "any",
      "value": "js_get_tx_outs_utxo(txHex).get_data();",
      "isPublic": true,
      "line": 188,
      "raw": "const outputs = js_get_tx_outs_utxo(txHex).get_data();",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:utils.transaction.ts.utxos",
      "fullName": "mesh-core-csl:utils.transaction.ts.utxos",
      "name": "utxos",
      "type": "UTxO[]",
      "value": "JSON.parse(outputs);",
      "isPublic": true,
      "line": 189,
      "raw": "const utxos: UTxO[] = JSON.parse(outputs);",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-csl:wasm.ts.parseWasmResult",
      "fullName": "mesh-core-csl:wasm.ts.parseWasmResult",
      "name": "parseWasmResult",
      "type": "any",
      "value": "(result: csl.WasmResult): string => {",
      "isPublic": true,
      "line": 3,
      "raw": "export const parseWasmResult = (result: csl.WasmResult): string => {",
      "source": "mesh-core-csl"
    },
    {
      "key": "mesh-core-cst:message-signing.check-signature.ts.checkSignature",
      "fullName": "mesh-core-cst:message-signing.check-signature.ts.checkSignature",
      "name": "checkSignature",
      "type": "any",
      "value": "async (",
      "isPublic": true,
      "line": 24,
      "raw": "export const checkSignature = async (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.check-signature.ts.builder",
      "fullName": "mesh-core-cst:message-signing.check-signature.ts.builder",
      "name": "builder",
      "type": "any",
      "value": "CoseSign1.fromCbor(signature);",
      "isPublic": true,
      "line": 30,
      "raw": "const builder = CoseSign1.fromCbor(signature);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.check-signature.ts.publicKeyBuffer",
      "fullName": "mesh-core-cst:message-signing.check-signature.ts.publicKeyBuffer",
      "name": "publicKeyBuffer",
      "type": "any",
      "value": "getPublicKeyFromCoseKey(key);",
      "isPublic": true,
      "line": 31,
      "raw": "const publicKeyBuffer = getPublicKeyFromCoseKey(key);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.check-signature.ts.paymentAddress",
      "fullName": "mesh-core-cst:message-signing.check-signature.ts.paymentAddress",
      "name": "paymentAddress",
      "type": "any",
      "value": "BaseAddress.fromAddress(Address.fromBech32(address));",
      "isPublic": true,
      "line": 35,
      "raw": "const paymentAddress = BaseAddress.fromAddress(Address.fromBech32(address));",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.check-signature.ts.coseSign1PublicKey",
      "fullName": "mesh-core-cst:message-signing.check-signature.ts.coseSign1PublicKey",
      "name": "coseSign1PublicKey",
      "type": "any",
      "value": "Ed25519PublicKey.fromBytes(publicKeyBuffer);",
      "isPublic": true,
      "line": 36,
      "raw": "const coseSign1PublicKey = Ed25519PublicKey.fromBytes(publicKeyBuffer);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.check-signature.ts.credential",
      "fullName": "mesh-core-cst:message-signing.check-signature.ts.credential",
      "name": "credential",
      "type": "CredentialCore",
      "value": "{",
      "isPublic": true,
      "line": 38,
      "raw": "const credential: CredentialCore = {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.check-signature.ts.stakeCredential",
      "fullName": "mesh-core-cst:message-signing.check-signature.ts.stakeCredential",
      "name": "stakeCredential",
      "type": "any",
      "value": "paymentAddress?.getStakeCredential();",
      "isPublic": true,
      "line": 50,
      "raw": "const stakeCredential = paymentAddress?.getStakeCredential();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.check-signature.ts.paymentAddressBech32",
      "fullName": "mesh-core-cst:message-signing.check-signature.ts.paymentAddressBech32",
      "name": "paymentAddressBech32",
      "type": "any",
      "value": "BaseAddress.fromCredentials(",
      "isPublic": true,
      "line": 52,
      "raw": "const paymentAddressBech32 = BaseAddress.fromCredentials(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.check-signature.ts.extractedRewardAddress",
      "fullName": "mesh-core-cst:message-signing.check-signature.ts.extractedRewardAddress",
      "name": "extractedRewardAddress",
      "type": "any",
      "value": "RewardAddress.fromCredentials(",
      "isPublic": true,
      "line": 61,
      "raw": "const extractedRewardAddress = RewardAddress.fromCredentials(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.check-signature.ts.rewardAddress",
      "fullName": "mesh-core-cst:message-signing.check-signature.ts.rewardAddress",
      "name": "rewardAddress",
      "type": "any",
      "value": "RewardAddress.fromCredentials(network, credential)",
      "isPublic": true,
      "line": 94,
      "raw": "const rewardAddress = RewardAddress.fromCredentials(network, credential)",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.check-signature.ts.enterpriseAddress",
      "fullName": "mesh-core-cst:message-signing.check-signature.ts.enterpriseAddress",
      "name": "enterpriseAddress",
      "type": "any",
      "value": "EnterpriseAddress.fromCredentials(",
      "isPublic": true,
      "line": 80,
      "raw": "const enterpriseAddress = EnterpriseAddress.fromCredentials(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.check-signature.ts.hexData",
      "fullName": "mesh-core-cst:message-signing.check-signature.ts.hexData",
      "name": "hexData",
      "type": "any",
      "value": "isHexString(data) ? data : stringToHex(data);",
      "isPublic": true,
      "line": 109,
      "raw": "const hexData = isHexString(data) ? data : stringToHex(data);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.decoded",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.decoded",
      "name": "decoded",
      "type": "any",
      "value": "Cbor.parse(cbor) as CborArray;",
      "isPublic": true,
      "line": 59,
      "raw": "const decoded = Cbor.parse(cbor) as CborArray;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.protectedSerialized",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.protectedSerialized",
      "name": "protectedSerialized",
      "type": "any",
      "value": "decoded.array[0] as CborBytes;",
      "isPublic": true,
      "line": 66,
      "raw": "const protectedSerialized = decoded.array[0] as CborBytes;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.payload",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.payload",
      "name": "payload",
      "type": "any",
      "value": "decoded.array[2] as CborBytes;",
      "isPublic": true,
      "line": 80,
      "raw": "const payload = decoded.array[2] as CborBytes;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.signature",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.signature",
      "name": "signature",
      "type": "any",
      "value": "decoded.array[3] as CborBytes;",
      "isPublic": true,
      "line": 83,
      "raw": "const signature = decoded.array[3] as CborBytes;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.structure",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.structure",
      "name": "structure",
      "type": "any",
      "value": "new CborArray([",
      "isPublic": true,
      "line": 104,
      "raw": "const structure = new CborArray([",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.coseSign1",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.coseSign1",
      "name": "coseSign1",
      "type": "any",
      "value": "new CborArray([",
      "isPublic": true,
      "line": 126,
      "raw": "const coseSign1 = new CborArray([",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.publicKey",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.publicKey",
      "name": "publicKey",
      "type": "any",
      "value": "this.protectedMap.map.find((value) => {",
      "isPublic": true,
      "line": 202,
      "raw": "const publicKey = this.protectedMap.map.find((value) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.hashedIndex",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.hashedIndex",
      "name": "hashedIndex",
      "type": "any",
      "value": "this.unProtectedMap.map.findIndex((value) => {",
      "isPublic": true,
      "line": 164,
      "raw": "const hashedIndex = this.unProtectedMap.map.findIndex((value) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.hashed",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.hashed",
      "name": "hashed",
      "type": "any",
      "value": "this.unProtectedMap.map[hashedIndex];",
      "isPublic": true,
      "line": 170,
      "raw": "const hashed = this.unProtectedMap.map[hashedIndex];",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.hash",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.hash",
      "name": "hash",
      "type": "any",
      "value": "blake2b(this.payload.bytes, undefined, 24);",
      "isPublic": true,
      "line": 186,
      "raw": "const hash = blake2b(this.payload.bytes, undefined, 24);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.address",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.address",
      "name": "address",
      "type": "any",
      "value": "this.protectedMap.map.find((value) => {",
      "isPublic": true,
      "line": 191,
      "raw": "const address = this.protectedMap.map.find((value) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.getPublicKeyFromCoseKey",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.getPublicKeyFromCoseKey",
      "name": "getPublicKeyFromCoseKey",
      "type": "any",
      "value": "(cbor: string): Buffer => {",
      "isPublic": true,
      "line": 218,
      "raw": "const getPublicKeyFromCoseKey = (cbor: string): Buffer => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.decodedCoseKey",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.decodedCoseKey",
      "name": "decodedCoseKey",
      "type": "any",
      "value": "Cbor.parse(cbor) as CborMap;",
      "isPublic": true,
      "line": 219,
      "raw": "const decodedCoseKey = Cbor.parse(cbor) as CborMap;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.publicKeyEntry",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.publicKeyEntry",
      "name": "publicKeyEntry",
      "type": "any",
      "value": "decodedCoseKey.map.find((value) => {",
      "isPublic": true,
      "line": 220,
      "raw": "const publicKeyEntry = decodedCoseKey.map.find((value) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.getCoseKeyFromPublicKey",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.getCoseKeyFromPublicKey",
      "name": "getCoseKeyFromPublicKey",
      "type": "any",
      "value": "(cbor: string): Buffer => {",
      "isPublic": true,
      "line": 234,
      "raw": "const getCoseKeyFromPublicKey = (cbor: string): Buffer => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.cose-sign1.ts.coseKeyMap",
      "fullName": "mesh-core-cst:message-signing.cose-sign1.ts.coseKeyMap",
      "name": "coseKeyMap",
      "type": "CborMapEntry[]",
      "value": "[];",
      "isPublic": true,
      "line": 235,
      "raw": "const coseKeyMap: CborMapEntry[] = [];",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.generate-nonce.ts.generateNonce",
      "fullName": "mesh-core-cst:message-signing.generate-nonce.ts.generateNonce",
      "name": "generateNonce",
      "type": "any",
      "value": "(label = \"\", length = 32) => {",
      "isPublic": true,
      "line": 11,
      "raw": "export const generateNonce = (label = \"\", length = 32) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.generate-nonce.ts.randomString",
      "fullName": "mesh-core-cst:message-signing.generate-nonce.ts.randomString",
      "name": "randomString",
      "type": "any",
      "value": "customAlphabet(",
      "isPublic": true,
      "line": 15,
      "raw": "const randomString = customAlphabet(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.generate-nonce.ts.payload",
      "fullName": "mesh-core-cst:message-signing.generate-nonce.ts.payload",
      "name": "payload",
      "type": "any",
      "value": "randomString(length);",
      "isPublic": true,
      "line": 18,
      "raw": "const payload = randomString(length);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.sign-data.ts.signData",
      "fullName": "mesh-core-cst:message-signing.sign-data.ts.signData",
      "name": "signData",
      "type": "any",
      "value": "(data: string, signer: Signer): DataSignature => {",
      "isPublic": true,
      "line": 23,
      "raw": "export const signData = (data: string, signer: Signer): DataSignature => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.sign-data.ts.hexData",
      "fullName": "mesh-core-cst:message-signing.sign-data.ts.hexData",
      "name": "hexData",
      "type": "any",
      "value": "isHexString(data) ? data : stringToHex(data);",
      "isPublic": true,
      "line": 24,
      "raw": "const hexData = isHexString(data) ? data : stringToHex(data);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.sign-data.ts.payload",
      "fullName": "mesh-core-cst:message-signing.sign-data.ts.payload",
      "name": "payload",
      "type": "any",
      "value": "Buffer.from(hexData, \"hex\");",
      "isPublic": true,
      "line": 25,
      "raw": "const payload = Buffer.from(hexData, \"hex\");",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.sign-data.ts.publicKey",
      "fullName": "mesh-core-cst:message-signing.sign-data.ts.publicKey",
      "name": "publicKey",
      "type": "any",
      "value": "Buffer.from(signer.key.toPublic().bytes());",
      "isPublic": true,
      "line": 26,
      "raw": "const publicKey = Buffer.from(signer.key.toPublic().bytes());",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.sign-data.ts.protectedMap",
      "fullName": "mesh-core-cst:message-signing.sign-data.ts.protectedMap",
      "name": "protectedMap",
      "type": "CborMapEntry[]",
      "value": "[];",
      "isPublic": true,
      "line": 28,
      "raw": "const protectedMap: CborMapEntry[] = [];",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.sign-data.ts.coseSign1Builder",
      "fullName": "mesh-core-cst:message-signing.sign-data.ts.coseSign1Builder",
      "name": "coseSign1Builder",
      "type": "any",
      "value": "new CoseSign1({",
      "isPublic": true,
      "line": 40,
      "raw": "const coseSign1Builder = new CoseSign1({",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.sign-data.ts.signature",
      "fullName": "mesh-core-cst:message-signing.sign-data.ts.signature",
      "name": "signature",
      "type": "any",
      "value": "signer.key.sign(",
      "isPublic": true,
      "line": 46,
      "raw": "const signature = signer.key.sign(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:message-signing.sign-data.ts.coseSignature",
      "fullName": "mesh-core-cst:message-signing.sign-data.ts.coseSignature",
      "name": "coseSignature",
      "type": "any",
      "value": "coseSign1Builder",
      "isPublic": true,
      "line": 50,
      "raw": "const coseSignature = coseSign1Builder",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.supportedPlutusCoreVersions",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.supportedPlutusCoreVersions",
      "name": "supportedPlutusCoreVersions",
      "type": "any",
      "value": "[",
      "isPublic": true,
      "line": 48,
      "raw": "const supportedPlutusCoreVersions = [",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.applyArgsToPlutusScript",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.applyArgsToPlutusScript",
      "name": "applyArgsToPlutusScript",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 85,
      "raw": "const applyArgsToPlutusScript = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.purePlutusBytes",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.purePlutusBytes",
      "name": "purePlutusBytes",
      "type": "any",
      "value": "getPurePlutusBytes(bytes);",
      "isPublic": true,
      "line": 126,
      "raw": "const purePlutusBytes = getPurePlutusBytes(bytes);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.parsedProgram",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.parsedProgram",
      "name": "parsedProgram",
      "type": "any",
      "value": "parseUPLC(purePlutusBytes, \"flat\");",
      "isPublic": true,
      "line": 91,
      "raw": "const parsedProgram = parseUPLC(purePlutusBytes, \"flat\");",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.decodedArgs",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.decodedArgs",
      "name": "decodedArgs",
      "type": "any",
      "value": "args.map((arg) => dataFromCbor(arg));",
      "isPublic": true,
      "line": 92,
      "raw": "const decodedArgs = args.map((arg) => dataFromCbor(arg));",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.argTerm",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.argTerm",
      "name": "argTerm",
      "type": "any",
      "value": "UPLCConst.data(plutusData);",
      "isPublic": true,
      "line": 96,
      "raw": "const argTerm = UPLCConst.data(plutusData);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.encodedProgram",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.encodedProgram",
      "name": "encodedProgram",
      "type": "any",
      "value": "new UPLCProgram(parsedProgram.version, body);",
      "isPublic": true,
      "line": 100,
      "raw": "const encodedProgram = new UPLCProgram(parsedProgram.version, body);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.newPlutusScriptBytes",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.newPlutusScriptBytes",
      "name": "newPlutusScriptBytes",
      "type": "any",
      "value": "encodeUPLC(encodedProgram).toBuffer().buffer;",
      "isPublic": true,
      "line": 101,
      "raw": "const newPlutusScriptBytes = encodeUPLC(encodedProgram).toBuffer().buffer;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.normalizePlutusScript",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.normalizePlutusScript",
      "name": "normalizePlutusScript",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 121,
      "raw": "export const normalizePlutusScript = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.bytes",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.bytes",
      "name": "bytes",
      "type": "any",
      "value": "Buffer.from(plutusScript, \"hex\");",
      "isPublic": true,
      "line": 125,
      "raw": "const bytes = Buffer.from(plutusScript, \"hex\");",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.normalizedBytes",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.normalizedBytes",
      "name": "normalizedBytes",
      "type": "any",
      "value": "applyEncoding(purePlutusBytes, encoding);",
      "isPublic": true,
      "line": 127,
      "raw": "const normalizedBytes = applyEncoding(purePlutusBytes, encoding);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.hasSupportedPlutusVersion",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.hasSupportedPlutusVersion",
      "name": "hasSupportedPlutusVersion",
      "type": "any",
      "value": "(plutusScript: Uint8Array): boolean => {",
      "isPublic": true,
      "line": 131,
      "raw": "const hasSupportedPlutusVersion = (plutusScript: Uint8Array): boolean => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.version",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.version",
      "name": "version",
      "type": "any",
      "value": "[plutusScript[0], plutusScript[1], plutusScript[2]];",
      "isPublic": true,
      "line": 135,
      "raw": "const version = [plutusScript[0], plutusScript[1], plutusScript[2]];",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.getPurePlutusBytes",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.getPurePlutusBytes",
      "name": "getPurePlutusBytes",
      "type": "any",
      "value": "(plutusScript: Uint8Array): Uint8Array => {",
      "isPublic": true,
      "line": 145,
      "raw": "const getPurePlutusBytes = (plutusScript: Uint8Array): Uint8Array => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.cbor",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.cbor",
      "name": "cbor",
      "type": "any",
      "value": "Cbor.parse(unwrappedScript);",
      "isPublic": true,
      "line": 154,
      "raw": "const cbor = Cbor.parse(unwrappedScript);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.applyCborEncoding",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.applyCborEncoding",
      "name": "applyCborEncoding",
      "type": "any",
      "value": "(plutusScript: Uint8Array): Uint8Array => {",
      "isPublic": true,
      "line": 170,
      "raw": "const applyCborEncoding = (plutusScript: Uint8Array): Uint8Array => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.applyEncoding",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.applyEncoding",
      "name": "applyEncoding",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 174,
      "raw": "export const applyEncoding = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.applyParamsToScript",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.applyParamsToScript",
      "name": "applyParamsToScript",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 190,
      "raw": "export const applyParamsToScript = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.byteParams",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.byteParams",
      "name": "byteParams",
      "type": "any",
      "value": "plutusParams.map((param) => {",
      "isPublic": true,
      "line": 229,
      "raw": "const byteParams = plutusParams.map((param) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:plutus-tools.index.ts.scriptHex",
      "fullName": "mesh-core-cst:plutus-tools.index.ts.scriptHex",
      "name": "scriptHex",
      "type": "any",
      "value": "Buffer.from(",
      "isPublic": true,
      "line": 233,
      "raw": "const scriptHex = Buffer.from(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolveDataHash",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolveDataHash",
      "name": "resolveDataHash",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 47,
      "raw": "export const resolveDataHash = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.plutusData",
      "fullName": "mesh-core-cst:resolvers.index.ts.plutusData",
      "name": "plutusData",
      "type": "any",
      "value": "fromBuilderToPlutusData({",
      "isPublic": true,
      "line": 51,
      "raw": "const plutusData = fromBuilderToPlutusData({",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolveNativeScriptAddress",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolveNativeScriptAddress",
      "name": "resolveNativeScriptAddress",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 58,
      "raw": "export const resolveNativeScriptAddress = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.nativeScript",
      "fullName": "mesh-core-cst:resolvers.index.ts.nativeScript",
      "name": "nativeScript",
      "type": "any",
      "value": "toNativeScript(script);",
      "isPublic": true,
      "line": 62,
      "raw": "const nativeScript = toNativeScript(script);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.enterpriseAddress",
      "fullName": "mesh-core-cst:resolvers.index.ts.enterpriseAddress",
      "name": "enterpriseAddress",
      "type": "any",
      "value": "toEnterpriseAddress(bech32);",
      "isPublic": true,
      "line": 111,
      "raw": "const enterpriseAddress = toEnterpriseAddress(bech32);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolveNativeScriptHash",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolveNativeScriptHash",
      "name": "resolveNativeScriptHash",
      "type": "any",
      "value": "(script: NativeScript) => {",
      "isPublic": true,
      "line": 72,
      "raw": "export const resolveNativeScriptHash = (script: NativeScript) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolvePaymentKeyHash",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolvePaymentKeyHash",
      "name": "resolvePaymentKeyHash",
      "type": "any",
      "value": "(bech32: string) => {",
      "isPublic": true,
      "line": 76,
      "raw": "export const resolvePaymentKeyHash = (bech32: string) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.paymentKeyHash",
      "fullName": "mesh-core-cst:resolvers.index.ts.paymentKeyHash",
      "name": "paymentKeyHash",
      "type": "any",
      "value": "[",
      "isPublic": true,
      "line": 78,
      "raw": "const paymentKeyHash = [",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolvePlutusScriptAddress",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolvePlutusScriptAddress",
      "name": "resolvePlutusScriptAddress",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 95,
      "raw": "export const resolvePlutusScriptAddress = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.plutusScript",
      "fullName": "mesh-core-cst:resolvers.index.ts.plutusScript",
      "name": "plutusScript",
      "type": "any",
      "value": "deserializePlutusScript(script.code, script.version);",
      "isPublic": true,
      "line": 99,
      "raw": "const plutusScript = deserializePlutusScript(script.code, script.version);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolvePlutusScriptHash",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolvePlutusScriptHash",
      "name": "resolvePlutusScriptHash",
      "type": "any",
      "value": "(bech32: string) => {",
      "isPublic": true,
      "line": 109,
      "raw": "export const resolvePlutusScriptHash = (bech32: string) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.scriptHash",
      "fullName": "mesh-core-cst:resolvers.index.ts.scriptHash",
      "name": "scriptHash",
      "type": "any",
      "value": "enterpriseAddress?.getPaymentCredential().hash;",
      "isPublic": true,
      "line": 112,
      "raw": "const scriptHash = enterpriseAddress?.getPaymentCredential().hash;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolvePoolId",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolvePoolId",
      "name": "resolvePoolId",
      "type": "any",
      "value": "(hash: string) => {",
      "isPublic": true,
      "line": 122,
      "raw": "export const resolvePoolId = (hash: string) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolvePrivateKey",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolvePrivateKey",
      "name": "resolvePrivateKey",
      "type": "any",
      "value": "(words: string[]) => {",
      "isPublic": true,
      "line": 126,
      "raw": "export const resolvePrivateKey = (words: string[]) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.buildBip32PrivateKey",
      "fullName": "mesh-core-cst:resolvers.index.ts.buildBip32PrivateKey",
      "name": "buildBip32PrivateKey",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 127,
      "raw": "const buildBip32PrivateKey = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.entropy",
      "fullName": "mesh-core-cst:resolvers.index.ts.entropy",
      "name": "entropy",
      "type": "any",
      "value": "mnemonicToEntropy(words.join(\" \"));",
      "isPublic": true,
      "line": 137,
      "raw": "const entropy = mnemonicToEntropy(words.join(\" \"));",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.bip32PrivateKey",
      "fullName": "mesh-core-cst:resolvers.index.ts.bip32PrivateKey",
      "name": "bip32PrivateKey",
      "type": "any",
      "value": "buildBip32PrivateKey(entropy);",
      "isPublic": true,
      "line": 138,
      "raw": "const bip32PrivateKey = buildBip32PrivateKey(entropy);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.bytes",
      "fullName": "mesh-core-cst:resolvers.index.ts.bytes",
      "name": "bytes",
      "type": "any",
      "value": "base32.encode(bip32PrivateKey.bytes());",
      "isPublic": true,
      "line": 139,
      "raw": "const bytes = base32.encode(bip32PrivateKey.bytes());",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.bech32PrivateKey",
      "fullName": "mesh-core-cst:resolvers.index.ts.bech32PrivateKey",
      "name": "bech32PrivateKey",
      "type": "any",
      "value": "bech32.encode(\"xprv\", bytes, 1023);",
      "isPublic": true,
      "line": 140,
      "raw": "const bech32PrivateKey = bech32.encode(\"xprv\", bytes, 1023);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolveScriptRef",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolveScriptRef",
      "name": "resolveScriptRef",
      "type": "any",
      "value": "(script: PlutusScript | NativeScript) => {",
      "isPublic": true,
      "line": 145,
      "raw": "export const resolveScriptRef = (script: PlutusScript | NativeScript) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolveRewardAddress",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolveRewardAddress",
      "name": "resolveRewardAddress",
      "type": "any",
      "value": "(bech32: string) => {",
      "isPublic": true,
      "line": 149,
      "raw": "export const resolveRewardAddress = (bech32: string) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.address",
      "fullName": "mesh-core-cst:resolvers.index.ts.address",
      "name": "address",
      "type": "any",
      "value": "toAddress(bech32);",
      "isPublic": true,
      "line": 151,
      "raw": "const address = toAddress(bech32);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.baseAddress",
      "fullName": "mesh-core-cst:resolvers.index.ts.baseAddress",
      "name": "baseAddress",
      "type": "any",
      "value": "toBaseAddress(bech32);",
      "isPublic": true,
      "line": 152,
      "raw": "const baseAddress = toBaseAddress(bech32);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.stakeKeyHash",
      "fullName": "mesh-core-cst:resolvers.index.ts.stakeKeyHash",
      "name": "stakeKeyHash",
      "type": "any",
      "value": "[",
      "isPublic": true,
      "line": 169,
      "raw": "const stakeKeyHash = [",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolveStakeKeyHash",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolveStakeKeyHash",
      "name": "resolveStakeKeyHash",
      "type": "any",
      "value": "(bech32: string) => {",
      "isPublic": true,
      "line": 167,
      "raw": "export const resolveStakeKeyHash = (bech32: string) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolveTxHash",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolveTxHash",
      "name": "resolveTxHash",
      "type": "any",
      "value": "(txHex: string) => {",
      "isPublic": true,
      "line": 182,
      "raw": "export const resolveTxHash = (txHex: string) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.txBody",
      "fullName": "mesh-core-cst:resolvers.index.ts.txBody",
      "name": "txBody",
      "type": "any",
      "value": "deserializeTx(txHex).body();",
      "isPublic": true,
      "line": 183,
      "raw": "const txBody = deserializeTx(txHex).body();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.hash",
      "fullName": "mesh-core-cst:resolvers.index.ts.hash",
      "name": "hash",
      "type": "any",
      "value": "blake2b(blake2b.BYTES)",
      "isPublic": true,
      "line": 184,
      "raw": "const hash = blake2b(blake2b.BYTES)",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolveScriptHashDRepId",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolveScriptHashDRepId",
      "name": "resolveScriptHashDRepId",
      "type": "any",
      "value": "(scriptHash: string) => {",
      "isPublic": true,
      "line": 190,
      "raw": "export const resolveScriptHashDRepId = (scriptHash: string) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.resolveEd25519KeyHash",
      "fullName": "mesh-core-cst:resolvers.index.ts.resolveEd25519KeyHash",
      "name": "resolveEd25519KeyHash",
      "type": "any",
      "value": "(bech32: string) => {",
      "isPublic": true,
      "line": 197,
      "raw": "export const resolveEd25519KeyHash = (bech32: string) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:resolvers.index.ts.keyHash",
      "fullName": "mesh-core-cst:resolvers.index.ts.keyHash",
      "name": "keyHash",
      "type": "any",
      "value": "[",
      "isPublic": true,
      "line": 199,
      "raw": "const keyHash = [",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.VKEY_PUBKEY_SIZE_BYTES",
      "fullName": "mesh-core-cst:serializer.index.ts.VKEY_PUBKEY_SIZE_BYTES",
      "name": "VKEY_PUBKEY_SIZE_BYTES",
      "type": "any",
      "value": "32;",
      "isPublic": true,
      "line": 132,
      "raw": "const VKEY_PUBKEY_SIZE_BYTES = 32;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.VKEY_SIGNATURE_SIZE_BYTES",
      "fullName": "mesh-core-cst:serializer.index.ts.VKEY_SIGNATURE_SIZE_BYTES",
      "name": "VKEY_SIGNATURE_SIZE_BYTES",
      "type": "any",
      "value": "64;",
      "isPublic": true,
      "line": 133,
      "raw": "const VKEY_SIGNATURE_SIZE_BYTES = 64;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.CHAIN_CODE_SIZE_BYTES",
      "fullName": "mesh-core-cst:serializer.index.ts.CHAIN_CODE_SIZE_BYTES",
      "name": "CHAIN_CODE_SIZE_BYTES",
      "type": "any",
      "value": "32;",
      "isPublic": true,
      "line": 134,
      "raw": "const CHAIN_CODE_SIZE_BYTES = 32;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.plutusData",
      "fullName": "mesh-core-cst:serializer.index.ts.plutusData",
      "name": "plutusData",
      "type": "any",
      "value": "fromBuilderToPlutusData(data);",
      "isPublic": true,
      "line": 238,
      "raw": "const plutusData = fromBuilderToPlutusData(data);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.address",
      "fullName": "mesh-core-cst:serializer.index.ts.address",
      "name": "address",
      "type": "any",
      "value": "Address.fromBytes(<HexBlob>byronAddresses[i]).asByron();",
      "isPublic": true,
      "line": 1769,
      "raw": "const address = Address.fromBytes(<HexBlob>byronAddresses[i]).asByron();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.addressProps",
      "fullName": "mesh-core-cst:serializer.index.ts.addressProps",
      "name": "addressProps",
      "type": "any",
      "value": "cardanoAddress.getProps();",
      "isPublic": true,
      "line": 357,
      "raw": "const addressProps = cardanoAddress.getProps();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.cardanoNativeScript",
      "fullName": "mesh-core-cst:serializer.index.ts.cardanoNativeScript",
      "name": "cardanoNativeScript",
      "type": "any",
      "value": "toNativeScript(script);",
      "isPublic": true,
      "line": 272,
      "raw": "const cardanoNativeScript = toNativeScript(script);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.cardanoPoolId",
      "fullName": "mesh-core-cst:serializer.index.ts.cardanoPoolId",
      "name": "cardanoPoolId",
      "type": "PoolId",
      "value": "PoolId(poolId);",
      "isPublic": true,
      "line": 307,
      "raw": "const cardanoPoolId: PoolId = PoolId(poolId);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.cardanoAddress",
      "fullName": "mesh-core-cst:serializer.index.ts.cardanoAddress",
      "name": "cardanoAddress",
      "type": "any",
      "value": "toAddress(bech32);",
      "isPublic": true,
      "line": 356,
      "raw": "const cardanoAddress = toAddress(bech32);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.buildBip32PrivateKey",
      "fullName": "mesh-core-cst:serializer.index.ts.buildBip32PrivateKey",
      "name": "buildBip32PrivateKey",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 323,
      "raw": "const buildBip32PrivateKey = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.entropy",
      "fullName": "mesh-core-cst:serializer.index.ts.entropy",
      "name": "entropy",
      "type": "any",
      "value": "mnemonicToEntropy(words.join(\" \"));",
      "isPublic": true,
      "line": 333,
      "raw": "const entropy = mnemonicToEntropy(words.join(\" \"));",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.bip32PrivateKey",
      "fullName": "mesh-core-cst:serializer.index.ts.bip32PrivateKey",
      "name": "bip32PrivateKey",
      "type": "any",
      "value": "buildBip32PrivateKey(entropy);",
      "isPublic": true,
      "line": 334,
      "raw": "const bip32PrivateKey = buildBip32PrivateKey(entropy);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.bytes",
      "fullName": "mesh-core-cst:serializer.index.ts.bytes",
      "name": "bytes",
      "type": "any",
      "value": "base32.encode(bip32PrivateKey.bytes());",
      "isPublic": true,
      "line": 335,
      "raw": "const bytes = base32.encode(bip32PrivateKey.bytes());",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.bech32PrivateKey",
      "fullName": "mesh-core-cst:serializer.index.ts.bech32PrivateKey",
      "name": "bech32PrivateKey",
      "type": "any",
      "value": "bech32.encode(\"xprv\", bytes, 1023);",
      "isPublic": true,
      "line": 336,
      "raw": "const bech32PrivateKey = bech32.encode(\"xprv\", bytes, 1023);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.nativeScript",
      "fullName": "mesh-core-cst:serializer.index.ts.nativeScript",
      "name": "nativeScript",
      "type": "any",
      "value": "toNativeScript(script);",
      "isPublic": true,
      "line": 414,
      "raw": "const nativeScript = toNativeScript(script);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.serializerCore",
      "fullName": "mesh-core-cst:serializer.index.ts.serializerCore",
      "name": "serializerCore",
      "type": "any",
      "value": "new CardanoSDKSerializerCore(protocolParams);",
      "isPublic": true,
      "line": 451,
      "raw": "const serializerCore = new CardanoSDKSerializerCore(protocolParams);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.cardanoSigner",
      "fullName": "mesh-core-cst:serializer.index.ts.cardanoSigner",
      "name": "cardanoSigner",
      "type": "any",
      "value": "buildEd25519PrivateKeyFromSecretKey(keyHex);",
      "isPublic": true,
      "line": 467,
      "raw": "const cardanoSigner = buildEd25519PrivateKeyFromSecretKey(keyHex);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.signature",
      "fullName": "mesh-core-cst:serializer.index.ts.signature",
      "name": "signature",
      "type": "any",
      "value": "this.mockSignature(numberInHex);",
      "isPublic": true,
      "line": 1775,
      "raw": "const signature = this.mockSignature(numberInHex);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.uniqueRefInputs",
      "fullName": "mesh-core-cst:serializer.index.ts.uniqueRefInputs",
      "name": "uniqueRefInputs",
      "type": "any",
      "value": "this.removeBodyInputRefInputOverlap(",
      "isPublic": true,
      "line": 618,
      "raw": "const uniqueRefInputs = this.removeBodyInputRefInputOverlap(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.bodyCore",
      "fullName": "mesh-core-cst:serializer.index.ts.bodyCore",
      "name": "bodyCore",
      "type": "any",
      "value": "this.coreSerializeTxBody(txBuilderBody);",
      "isPublic": true,
      "line": 723,
      "raw": "const bodyCore = this.coreSerializeTxBody(txBuilderBody);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.mockWitSet",
      "fullName": "mesh-core-cst:serializer.index.ts.mockWitSet",
      "name": "mockWitSet",
      "type": "any",
      "value": "this.createMockedWitnessSet(",
      "isPublic": true,
      "line": 724,
      "raw": "const mockWitSet = this.createMockedWitnessSet(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.currentTxIn",
      "fullName": "mesh-core-cst:serializer.index.ts.currentTxIn",
      "name": "currentTxIn",
      "type": "any",
      "value": "inputs[i];",
      "isPublic": true,
      "line": 792,
      "raw": "const currentTxIn = inputs[i];",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.inputs",
      "fullName": "mesh-core-cst:serializer.index.ts.inputs",
      "name": "inputs",
      "type": "any",
      "value": "this.txBody.inputs()?.values();",
      "isPublic": true,
      "line": 1509,
      "raw": "const inputs = this.txBody.inputs()?.values();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.txInputsList",
      "fullName": "mesh-core-cst:serializer.index.ts.txInputsList",
      "name": "txInputsList",
      "type": "TransactionInput[]",
      "value": "[...inputs.values()];",
      "isPublic": true,
      "line": 822,
      "raw": "const txInputsList: TransactionInput[] = [...inputs.values()];",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.cardanoTxOut",
      "fullName": "mesh-core-cst:serializer.index.ts.cardanoTxOut",
      "name": "cardanoTxOut",
      "type": "any",
      "value": "new TransactionOutput(",
      "isPublic": true,
      "line": 1321,
      "raw": "const cardanoTxOut = new TransactionOutput(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.currentOutputs",
      "fullName": "mesh-core-cst:serializer.index.ts.currentOutputs",
      "name": "currentOutputs",
      "type": "any",
      "value": "this.txBody.outputs();",
      "isPublic": true,
      "line": 929,
      "raw": "const currentOutputs = this.txBody.outputs();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.currentWitnessDatumValues",
      "fullName": "mesh-core-cst:serializer.index.ts.currentWitnessDatumValues",
      "name": "currentWitnessDatumValues",
      "type": "any",
      "value": "[...currentWitnessDatum.values()];",
      "isPublic": true,
      "line": 954,
      "raw": "const currentWitnessDatumValues = [...currentWitnessDatum.values()];",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.newRedeemer",
      "fullName": "mesh-core-cst:serializer.index.ts.newRedeemer",
      "name": "newRedeemer",
      "type": "any",
      "value": "new Redeemer(",
      "isPublic": true,
      "line": 1037,
      "raw": "const newRedeemer = new Redeemer(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.currentMint",
      "fullName": "mesh-core-cst:serializer.index.ts.currentMint",
      "name": "currentMint",
      "type": "TokenMap",
      "value": "this.txBody.mint() ?? new Map();",
      "isPublic": true,
      "line": 1051,
      "raw": "const currentMint: TokenMap = this.txBody.mint() ?? new Map();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.mintAssetId",
      "fullName": "mesh-core-cst:serializer.index.ts.mintAssetId",
      "name": "mintAssetId",
      "type": "any",
      "value": "`${mint.policyId}${assetValue.assetName}`;",
      "isPublic": true,
      "line": 1054,
      "raw": "const mintAssetId = `${mint.policyId}${assetValue.assetName}`;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.plutusScriptSource",
      "fullName": "mesh-core-cst:serializer.index.ts.plutusScriptSource",
      "name": "plutusScriptSource",
      "type": "any",
      "value": "vote.scriptSource as ScriptSource;",
      "isPublic": true,
      "line": 1668,
      "raw": "const plutusScriptSource = vote.scriptSource as ScriptSource;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.currentRedeemer",
      "fullName": "mesh-core-cst:serializer.index.ts.currentRedeemer",
      "name": "currentRedeemer",
      "type": "any",
      "value": "new Redeemer(",
      "isPublic": true,
      "line": 1103,
      "raw": "const currentRedeemer = new Redeemer(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.rewardAddress",
      "fullName": "mesh-core-cst:serializer.index.ts.rewardAddress",
      "name": "rewardAddress",
      "type": "any",
      "value": "address.asReward();",
      "isPublic": true,
      "line": 1216,
      "raw": "const rewardAddress = address.asReward();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.collateralInputsList",
      "fullName": "mesh-core-cst:serializer.index.ts.collateralInputsList",
      "name": "collateralInputsList",
      "type": "TransactionInput[]",
      "value": "[",
      "isPublic": true,
      "line": 1306,
      "raw": "const collateralInputsList: TransactionInput[] = [",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.collateralReturn",
      "fullName": "mesh-core-cst:serializer.index.ts.collateralReturn",
      "name": "collateralReturn",
      "type": "any",
      "value": "new TransactionOutput(",
      "isPublic": true,
      "line": 1343,
      "raw": "const collateralReturn = new TransactionOutput(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.clonedWitnessSet",
      "fullName": "mesh-core-cst:serializer.index.ts.clonedWitnessSet",
      "name": "clonedWitnessSet",
      "type": "any",
      "value": "TransactionWitnessSet.fromCbor(",
      "isPublic": true,
      "line": 1393,
      "raw": "const clonedWitnessSet = TransactionWitnessSet.fromCbor(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.bootstrapWitnesses",
      "fullName": "mesh-core-cst:serializer.index.ts.bootstrapWitnesses",
      "name": "bootstrapWitnesses",
      "type": "any",
      "value": "this.mockBootstrapWitnesses(",
      "isPublic": true,
      "line": 1396,
      "raw": "const bootstrapWitnesses = this.mockBootstrapWitnesses(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.vkeyWitnesses",
      "fullName": "mesh-core-cst:serializer.index.ts.vkeyWitnesses",
      "name": "vkeyWitnesses",
      "type": "any",
      "value": "this.mockVkeyWitnesses(requiredSignaturesCount);",
      "isPublic": true,
      "line": 1399,
      "raw": "const vkeyWitnesses = this.mockVkeyWitnesses(requiredSignaturesCount);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.bootstrapsSet",
      "fullName": "mesh-core-cst:serializer.index.ts.bootstrapsSet",
      "name": "bootstrapsSet",
      "type": "any",
      "value": "CborSet.fromCore([], BootstrapWitness.fromCore);",
      "isPublic": true,
      "line": 1401,
      "raw": "const bootstrapsSet = CborSet.fromCore([], BootstrapWitness.fromCore);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.vkeysSet",
      "fullName": "mesh-core-cst:serializer.index.ts.vkeysSet",
      "name": "vkeysSet",
      "type": "any",
      "value": "CborSet.fromCore([], VkeyWitness.fromCore);",
      "isPublic": true,
      "line": 1405,
      "raw": "const vkeysSet = CborSet.fromCore([], VkeyWitness.fromCore);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.script",
      "fullName": "mesh-core-cst:serializer.index.ts.script",
      "name": "script",
      "type": "any",
      "value": "Script.fromCbor(HexBlob(scriptHex));",
      "isPublic": true,
      "line": 1431,
      "raw": "const script = Script.fromCbor(HexBlob(scriptHex));",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.redeemers",
      "fullName": "mesh-core-cst:serializer.index.ts.redeemers",
      "name": "redeemers",
      "type": "any",
      "value": "this.txWitnessSet.redeemers() ?? Redeemers.fromCore([]);",
      "isPublic": true,
      "line": 1490,
      "raw": "const redeemers = this.txWitnessSet.redeemers() ?? Redeemers.fromCore([]);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.currentRefInputValues",
      "fullName": "mesh-core-cst:serializer.index.ts.currentRefInputValues",
      "name": "currentRefInputValues",
      "type": "any",
      "value": "this.txBody.referenceInputs()!.values();",
      "isPublic": true,
      "line": 1511,
      "raw": "const currentRefInputValues = this.txBody.referenceInputs()!.values();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.vote",
      "fullName": "mesh-core-cst:serializer.index.ts.vote",
      "name": "vote",
      "type": "any",
      "value": "votes[i];",
      "isPublic": true,
      "line": 1634,
      "raw": "const vote = votes[i];",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.numberInHex",
      "fullName": "mesh-core-cst:serializer.index.ts.numberInHex",
      "name": "numberInHex",
      "type": "any",
      "value": "this.numberToIntegerHex(i);",
      "isPublic": true,
      "line": 1773,
      "raw": "const numberInHex = this.numberToIntegerHex(i);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.pubKeyHex",
      "fullName": "mesh-core-cst:serializer.index.ts.pubKeyHex",
      "name": "pubKeyHex",
      "type": "any",
      "value": "this.mockPubkey(numberInHex);",
      "isPublic": true,
      "line": 1774,
      "raw": "const pubKeyHex = this.mockPubkey(numberInHex);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.chainCode",
      "fullName": "mesh-core-cst:serializer.index.ts.chainCode",
      "name": "chainCode",
      "type": "any",
      "value": "this.mockChainCode(numberInHex);",
      "isPublic": true,
      "line": 1776,
      "raw": "const chainCode = this.mockChainCode(numberInHex);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.attributes",
      "fullName": "mesh-core-cst:serializer.index.ts.attributes",
      "name": "attributes",
      "type": "any",
      "value": "address.getAttributes();",
      "isPublic": true,
      "line": 1777,
      "raw": "const attributes = address.getAttributes();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.writer",
      "fullName": "mesh-core-cst:serializer.index.ts.writer",
      "name": "writer",
      "type": "any",
      "value": "new CborWriter();",
      "isPublic": true,
      "line": 1791,
      "raw": "const writer = new CborWriter();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.encodedPathCbor",
      "fullName": "mesh-core-cst:serializer.index.ts.encodedPathCbor",
      "name": "encodedPathCbor",
      "type": "any",
      "value": "new CborWriter()",
      "isPublic": true,
      "line": 1803,
      "raw": "const encodedPathCbor = new CborWriter()",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.encodedMagicCbor",
      "fullName": "mesh-core-cst:serializer.index.ts.encodedMagicCbor",
      "name": "encodedMagicCbor",
      "type": "any",
      "value": "new CborWriter()",
      "isPublic": true,
      "line": 1810,
      "raw": "const encodedMagicCbor = new CborWriter()",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:serializer.index.ts.throwErrorWithOrigin",
      "fullName": "mesh-core-cst:serializer.index.ts.throwErrorWithOrigin",
      "name": "throwErrorWithOrigin",
      "type": "any",
      "value": "(origin: string, error: any) => {",
      "isPublic": true,
      "line": 1819,
      "raw": "const throwErrorWithOrigin = (origin: string, error: any) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Slot",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Slot",
      "name": "Slot",
      "type": "any",
      "value": "Cardano.Slot;",
      "isPublic": true,
      "line": 6,
      "raw": "export const Slot = Cardano.Slot;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Value",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Value",
      "name": "Value",
      "type": "any",
      "value": "Serialization.Value;",
      "isPublic": true,
      "line": 9,
      "raw": "export const Value = Serialization.Value;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Transaction",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Transaction",
      "name": "Transaction",
      "type": "any",
      "value": "Serialization.Transaction;",
      "isPublic": true,
      "line": 14,
      "raw": "export const Transaction = Serialization.Transaction;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TransactionId",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TransactionId",
      "name": "TransactionId",
      "type": "any",
      "value": "(value: string) => {",
      "isPublic": true,
      "line": 17,
      "raw": "export const TransactionId = (value: string) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TransactionBody",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TransactionBody",
      "name": "TransactionBody",
      "type": "any",
      "value": "Serialization.TransactionBody;",
      "isPublic": true,
      "line": 22,
      "raw": "export const TransactionBody = Serialization.TransactionBody;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TransactionWitnessSet",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TransactionWitnessSet",
      "name": "TransactionWitnessSet",
      "type": "any",
      "value": "Serialization.TransactionWitnessSet;",
      "isPublic": true,
      "line": 25,
      "raw": "export const TransactionWitnessSet = Serialization.TransactionWitnessSet;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.AuxilliaryData",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.AuxilliaryData",
      "name": "AuxilliaryData",
      "type": "any",
      "value": "Serialization.AuxiliaryData;",
      "isPublic": true,
      "line": 28,
      "raw": "export const AuxilliaryData = Serialization.AuxiliaryData;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TransactionMetadatum",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TransactionMetadatum",
      "name": "TransactionMetadatum",
      "type": "any",
      "value": "Serialization.TransactionMetadatum;",
      "isPublic": true,
      "line": 31,
      "raw": "export const TransactionMetadatum = Serialization.TransactionMetadatum;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.MetadatumMap",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.MetadatumMap",
      "name": "MetadatumMap",
      "type": "any",
      "value": "Serialization.MetadatumMap;",
      "isPublic": true,
      "line": 34,
      "raw": "export const MetadatumMap = Serialization.MetadatumMap;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.MetadatumList",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.MetadatumList",
      "name": "MetadatumList",
      "type": "any",
      "value": "Serialization.MetadatumList;",
      "isPublic": true,
      "line": 37,
      "raw": "export const MetadatumList = Serialization.MetadatumList;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TransactionUnspentOutput",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TransactionUnspentOutput",
      "name": "TransactionUnspentOutput",
      "type": "any",
      "value": "Serialization.TransactionUnspentOutput;",
      "isPublic": true,
      "line": 40,
      "raw": "export const TransactionUnspentOutput = Serialization.TransactionUnspentOutput;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TransactionInput",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TransactionInput",
      "name": "TransactionInput",
      "type": "any",
      "value": "Serialization.TransactionInput;",
      "isPublic": true,
      "line": 43,
      "raw": "export const TransactionInput = Serialization.TransactionInput;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TransactionOutput",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TransactionOutput",
      "name": "TransactionOutput",
      "type": "any",
      "value": "Serialization.TransactionOutput;",
      "isPublic": true,
      "line": 46,
      "raw": "export const TransactionOutput = Serialization.TransactionOutput;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PlutusData",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PlutusData",
      "name": "PlutusData",
      "type": "any",
      "value": "Serialization.PlutusData;",
      "isPublic": true,
      "line": 56,
      "raw": "export const PlutusData = Serialization.PlutusData;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PlutusList",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PlutusList",
      "name": "PlutusList",
      "type": "any",
      "value": "Serialization.PlutusList;",
      "isPublic": true,
      "line": 59,
      "raw": "export const PlutusList = Serialization.PlutusList;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PlutusMap",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PlutusMap",
      "name": "PlutusMap",
      "type": "any",
      "value": "Serialization.PlutusMap;",
      "isPublic": true,
      "line": 62,
      "raw": "export const PlutusMap = Serialization.PlutusMap;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Redeemers",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Redeemers",
      "name": "Redeemers",
      "type": "any",
      "value": "Serialization.Redeemers;",
      "isPublic": true,
      "line": 65,
      "raw": "export const Redeemers = Serialization.Redeemers;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Redeemer",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Redeemer",
      "name": "Redeemer",
      "type": "any",
      "value": "Serialization.Redeemer;",
      "isPublic": true,
      "line": 68,
      "raw": "export const Redeemer = Serialization.Redeemer;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.RedeemerPurpose",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.RedeemerPurpose",
      "name": "RedeemerPurpose",
      "type": "any",
      "value": "Cardano.RedeemerPurpose;",
      "isPublic": true,
      "line": 71,
      "raw": "export const RedeemerPurpose = Cardano.RedeemerPurpose;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.RedeemerTag",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.RedeemerTag",
      "name": "RedeemerTag",
      "type": "any",
      "value": "Serialization.RedeemerTag;",
      "isPublic": true,
      "line": 74,
      "raw": "export const RedeemerTag = Serialization.RedeemerTag;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Script",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Script",
      "name": "Script",
      "type": "any",
      "value": "Serialization.Script;",
      "isPublic": true,
      "line": 77,
      "raw": "export const Script = Serialization.Script;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PolicyId",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PolicyId",
      "name": "PolicyId",
      "type": "any",
      "value": "Cardano.PolicyId;",
      "isPublic": true,
      "line": 80,
      "raw": "export const PolicyId = Cardano.PolicyId;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.AssetName",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.AssetName",
      "name": "AssetName",
      "type": "any",
      "value": "Cardano.AssetName;",
      "isPublic": true,
      "line": 83,
      "raw": "export const AssetName = Cardano.AssetName;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.AssetId",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.AssetId",
      "name": "AssetId",
      "type": "any",
      "value": "Cardano.AssetId;",
      "isPublic": true,
      "line": 86,
      "raw": "export const AssetId = Cardano.AssetId;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.ScriptHash",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.ScriptHash",
      "name": "ScriptHash",
      "type": "any",
      "value": "Crypto.Hash28ByteBase16;",
      "isPublic": true,
      "line": 89,
      "raw": "export const ScriptHash = Crypto.Hash28ByteBase16;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Address",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Address",
      "name": "Address",
      "type": "any",
      "value": "Cardano.Address;",
      "isPublic": true,
      "line": 92,
      "raw": "export const Address = Cardano.Address;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.RewardAddress",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.RewardAddress",
      "name": "RewardAddress",
      "type": "any",
      "value": "Cardano.RewardAddress;",
      "isPublic": true,
      "line": 95,
      "raw": "export const RewardAddress = Cardano.RewardAddress;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.AddressType",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.AddressType",
      "name": "AddressType",
      "type": "any",
      "value": "Cardano.AddressType;",
      "isPublic": true,
      "line": 98,
      "raw": "export const AddressType = Cardano.AddressType;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.BaseAddress",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.BaseAddress",
      "name": "BaseAddress",
      "type": "any",
      "value": "Cardano.BaseAddress;",
      "isPublic": true,
      "line": 101,
      "raw": "export const BaseAddress = Cardano.BaseAddress;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.EnterpriseAddress",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.EnterpriseAddress",
      "name": "EnterpriseAddress",
      "type": "any",
      "value": "Cardano.EnterpriseAddress;",
      "isPublic": true,
      "line": 104,
      "raw": "export const EnterpriseAddress = Cardano.EnterpriseAddress;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PaymentAddress",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PaymentAddress",
      "name": "PaymentAddress",
      "type": "any",
      "value": "Cardano.PaymentAddress;",
      "isPublic": true,
      "line": 107,
      "raw": "export const PaymentAddress = Cardano.PaymentAddress;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.AssetFingerprint",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.AssetFingerprint",
      "name": "AssetFingerprint",
      "type": "any",
      "value": "Cardano.AssetFingerprint;",
      "isPublic": true,
      "line": 110,
      "raw": "export const AssetFingerprint = Cardano.AssetFingerprint;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Credential",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Credential",
      "name": "Credential",
      "type": "any",
      "value": "Serialization.Credential;",
      "isPublic": true,
      "line": 113,
      "raw": "export const Credential = Serialization.Credential;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PublicKeyHex",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PublicKeyHex",
      "name": "Ed25519PublicKeyHex",
      "type": "any",
      "value": "Crypto.Ed25519PublicKeyHex;",
      "isPublic": true,
      "line": 118,
      "raw": "export const Ed25519PublicKeyHex = Crypto.Ed25519PublicKeyHex;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PrivateNormalKeyHex",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PrivateNormalKeyHex",
      "name": "Ed25519PrivateNormalKeyHex",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 122,
      "raw": "export const Ed25519PrivateNormalKeyHex = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PrivateExtendedKeyHex",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PrivateExtendedKeyHex",
      "name": "Ed25519PrivateExtendedKeyHex",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 127,
      "raw": "export const Ed25519PrivateExtendedKeyHex = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Ed25519KeyHash",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Ed25519KeyHash",
      "name": "Ed25519KeyHash",
      "type": "any",
      "value": "Crypto.Ed25519KeyHash;",
      "isPublic": true,
      "line": 131,
      "raw": "export const Ed25519KeyHash = Crypto.Ed25519KeyHash;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Ed25519KeyHashHex",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Ed25519KeyHashHex",
      "name": "Ed25519KeyHashHex",
      "type": "any",
      "value": "Crypto.Ed25519KeyHashHex;",
      "isPublic": true,
      "line": 134,
      "raw": "export const Ed25519KeyHashHex = Crypto.Ed25519KeyHashHex;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Hash28ByteBase16",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Hash28ByteBase16",
      "name": "Hash28ByteBase16",
      "type": "any",
      "value": "Crypto.Hash28ByteBase16;",
      "isPublic": true,
      "line": 137,
      "raw": "export const Hash28ByteBase16 = Crypto.Hash28ByteBase16;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Hash32ByteBase16",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Hash32ByteBase16",
      "name": "Hash32ByteBase16",
      "type": "any",
      "value": "(value: string) => {",
      "isPublic": true,
      "line": 140,
      "raw": "export const Hash32ByteBase16 = (value: string) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.CredentialType",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.CredentialType",
      "name": "CredentialType",
      "type": "any",
      "value": "Cardano.CredentialType;",
      "isPublic": true,
      "line": 145,
      "raw": "export const CredentialType = Cardano.CredentialType;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Certificate",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Certificate",
      "name": "Certificate",
      "type": "any",
      "value": "Serialization.Certificate;",
      "isPublic": true,
      "line": 148,
      "raw": "export const Certificate = Serialization.Certificate;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PoolId",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PoolId",
      "name": "PoolId",
      "type": "any",
      "value": "Cardano.PoolId;",
      "isPublic": true,
      "line": 151,
      "raw": "export const PoolId = Cardano.PoolId;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.StakeRegistration",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.StakeRegistration",
      "name": "StakeRegistration",
      "type": "any",
      "value": "Serialization.StakeRegistration;",
      "isPublic": true,
      "line": 154,
      "raw": "export const StakeRegistration = Serialization.StakeRegistration;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.StakeDelegation",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.StakeDelegation",
      "name": "StakeDelegation",
      "type": "any",
      "value": "Serialization.StakeDelegation;",
      "isPublic": true,
      "line": 157,
      "raw": "export const StakeDelegation = Serialization.StakeDelegation;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.CertificateType",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.CertificateType",
      "name": "CertificateType",
      "type": "any",
      "value": "Cardano.CertificateType;",
      "isPublic": true,
      "line": 162,
      "raw": "export const CertificateType = Cardano.CertificateType;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.VkeyWitness",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.VkeyWitness",
      "name": "VkeyWitness",
      "type": "any",
      "value": "Serialization.VkeyWitness;",
      "isPublic": true,
      "line": 165,
      "raw": "export const VkeyWitness = Serialization.VkeyWitness;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Ed25519SignatureHex",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Ed25519SignatureHex",
      "name": "Ed25519SignatureHex",
      "type": "any",
      "value": "Crypto.Ed25519SignatureHex;",
      "isPublic": true,
      "line": 168,
      "raw": "export const Ed25519SignatureHex = Crypto.Ed25519SignatureHex;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PublicKey",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PublicKey",
      "name": "Ed25519PublicKey",
      "type": "any",
      "value": "Crypto.Ed25519PublicKey;",
      "isPublic": true,
      "line": 171,
      "raw": "export const Ed25519PublicKey = Crypto.Ed25519PublicKey;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Ed25519Signature",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Ed25519Signature",
      "name": "Ed25519Signature",
      "type": "any",
      "value": "Crypto.Ed25519Signature;",
      "isPublic": true,
      "line": 174,
      "raw": "export const Ed25519Signature = Crypto.Ed25519Signature;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Bip32PrivateKey",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Bip32PrivateKey",
      "name": "Bip32PrivateKey",
      "type": "any",
      "value": "Crypto.Bip32PrivateKey;",
      "isPublic": true,
      "line": 177,
      "raw": "export const Bip32PrivateKey = Crypto.Bip32PrivateKey;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Bip32PrivateKeyHex",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Bip32PrivateKeyHex",
      "name": "Bip32PrivateKeyHex",
      "type": "any",
      "value": "Crypto.Bip32PrivateKeyHex;",
      "isPublic": true,
      "line": 180,
      "raw": "export const Bip32PrivateKeyHex = Crypto.Bip32PrivateKeyHex;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Bip32PublicKey",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Bip32PublicKey",
      "name": "Bip32PublicKey",
      "type": "any",
      "value": "Crypto.Bip32PublicKey;",
      "isPublic": true,
      "line": 183,
      "raw": "export const Bip32PublicKey = Crypto.Bip32PublicKey;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Bip32PublicKeyHex",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Bip32PublicKeyHex",
      "name": "Bip32PublicKeyHex",
      "type": "any",
      "value": "Crypto.Bip32PublicKeyHex;",
      "isPublic": true,
      "line": 186,
      "raw": "export const Bip32PublicKeyHex = Crypto.Bip32PublicKeyHex;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PlutusLanguageVersion",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PlutusLanguageVersion",
      "name": "PlutusLanguageVersion",
      "type": "any",
      "value": "Cardano.PlutusLanguageVersion;",
      "isPublic": true,
      "line": 189,
      "raw": "export const PlutusLanguageVersion = Cardano.PlutusLanguageVersion;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.NativeScript",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.NativeScript",
      "name": "NativeScript",
      "type": "any",
      "value": "Serialization.NativeScript;",
      "isPublic": true,
      "line": 192,
      "raw": "export const NativeScript = Serialization.NativeScript;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PlutusV1Script",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PlutusV1Script",
      "name": "PlutusV1Script",
      "type": "any",
      "value": "Serialization.PlutusV1Script;",
      "isPublic": true,
      "line": 195,
      "raw": "export const PlutusV1Script = Serialization.PlutusV1Script;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PlutusV2Script",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PlutusV2Script",
      "name": "PlutusV2Script",
      "type": "any",
      "value": "Serialization.PlutusV2Script;",
      "isPublic": true,
      "line": 198,
      "raw": "export const PlutusV2Script = Serialization.PlutusV2Script;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PlutusV3Script",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PlutusV3Script",
      "name": "PlutusV3Script",
      "type": "any",
      "value": "Serialization.PlutusV3Script;",
      "isPublic": true,
      "line": 201,
      "raw": "export const PlutusV3Script = Serialization.PlutusV3Script;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PlutusDataKind",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PlutusDataKind",
      "name": "PlutusDataKind",
      "type": "any",
      "value": "Serialization.PlutusDataKind;",
      "isPublic": true,
      "line": 204,
      "raw": "export const PlutusDataKind = Serialization.PlutusDataKind;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.PointerAddress",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.PointerAddress",
      "name": "PointerAddress",
      "type": "any",
      "value": "Cardano.PointerAddress;",
      "isPublic": true,
      "line": 207,
      "raw": "export const PointerAddress = Cardano.PointerAddress;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.CertIndex",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.CertIndex",
      "name": "CertIndex",
      "type": "any",
      "value": "Cardano.CertIndex;",
      "isPublic": true,
      "line": 210,
      "raw": "export const CertIndex = Cardano.CertIndex;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TxIndex",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TxIndex",
      "name": "TxIndex",
      "type": "any",
      "value": "Cardano.TxIndex;",
      "isPublic": true,
      "line": 213,
      "raw": "export const TxIndex = Cardano.TxIndex;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Costmdls",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Costmdls",
      "name": "Costmdls",
      "type": "any",
      "value": "Serialization.Costmdls;",
      "isPublic": true,
      "line": 216,
      "raw": "export const Costmdls = Serialization.Costmdls;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.CostModel",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.CostModel",
      "name": "CostModel",
      "type": "any",
      "value": "Serialization.CostModel;",
      "isPublic": true,
      "line": 219,
      "raw": "export const CostModel = Serialization.CostModel;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.CborWriter",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.CborWriter",
      "name": "CborWriter",
      "type": "any",
      "value": "Serialization.CborWriter;",
      "isPublic": true,
      "line": 222,
      "raw": "export const CborWriter = Serialization.CborWriter;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.ConstrPlutusData",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.ConstrPlutusData",
      "name": "ConstrPlutusData",
      "type": "any",
      "value": "Serialization.ConstrPlutusData;",
      "isPublic": true,
      "line": 225,
      "raw": "export const ConstrPlutusData = Serialization.ConstrPlutusData;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.RewardAccount",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.RewardAccount",
      "name": "RewardAccount",
      "type": "any",
      "value": "Cardano.RewardAccount;",
      "isPublic": true,
      "line": 228,
      "raw": "export const RewardAccount = Cardano.RewardAccount;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Hash",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Hash",
      "name": "Hash",
      "type": "any",
      "value": "Serialization.Hash;",
      "isPublic": true,
      "line": 231,
      "raw": "export const Hash = Serialization.Hash;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.DatumHash",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.DatumHash",
      "name": "DatumHash",
      "type": "any",
      "value": "(value: string) => {",
      "isPublic": true,
      "line": 234,
      "raw": "export const DatumHash = (value: string) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Datum",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Datum",
      "name": "Datum",
      "type": "any",
      "value": "Serialization.Datum;",
      "isPublic": true,
      "line": 239,
      "raw": "export const Datum = Serialization.Datum;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.ExUnits",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.ExUnits",
      "name": "ExUnits",
      "type": "any",
      "value": "Serialization.ExUnits;",
      "isPublic": true,
      "line": 245,
      "raw": "export const ExUnits = Serialization.ExUnits;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.NetworkId",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.NetworkId",
      "name": "NetworkId",
      "type": "any",
      "value": "Cardano.NetworkId;",
      "isPublic": true,
      "line": 247,
      "raw": "export const NetworkId = Cardano.NetworkId;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.DatumKind",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.DatumKind",
      "name": "DatumKind",
      "type": "any",
      "value": "Serialization.DatumKind;",
      "isPublic": true,
      "line": 250,
      "raw": "export const DatumKind = Serialization.DatumKind;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.CborSet",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.CborSet",
      "name": "CborSet",
      "type": "any",
      "value": "Serialization.CborSet;",
      "isPublic": true,
      "line": 252,
      "raw": "export const CborSet = Serialization.CborSet;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.RequireAllOf",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.RequireAllOf",
      "name": "RequireAllOf",
      "type": "any",
      "value": "Cardano.NativeScriptKind.RequireAllOf;",
      "isPublic": true,
      "line": 258,
      "raw": "export const RequireAllOf = Cardano.NativeScriptKind.RequireAllOf;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.RequireAnyOf",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.RequireAnyOf",
      "name": "RequireAnyOf",
      "type": "any",
      "value": "Cardano.NativeScriptKind.RequireAnyOf;",
      "isPublic": true,
      "line": 261,
      "raw": "export const RequireAnyOf = Cardano.NativeScriptKind.RequireAnyOf;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.RequireNOf",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.RequireNOf",
      "name": "RequireNOf",
      "type": "any",
      "value": "Cardano.NativeScriptKind.RequireNOf;",
      "isPublic": true,
      "line": 264,
      "raw": "export const RequireNOf = Cardano.NativeScriptKind.RequireNOf;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.RequireSignature",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.RequireSignature",
      "name": "RequireSignature",
      "type": "any",
      "value": "Cardano.NativeScriptKind.RequireSignature;",
      "isPublic": true,
      "line": 267,
      "raw": "export const RequireSignature = Cardano.NativeScriptKind.RequireSignature;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.RequireTimeAfter",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.RequireTimeAfter",
      "name": "RequireTimeAfter",
      "type": "any",
      "value": "Cardano.NativeScriptKind.RequireTimeAfter;",
      "isPublic": true,
      "line": 270,
      "raw": "export const RequireTimeAfter = Cardano.NativeScriptKind.RequireTimeAfter;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.RequireTimeBefore",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.RequireTimeBefore",
      "name": "RequireTimeBefore",
      "type": "any",
      "value": "Cardano.NativeScriptKind.RequireTimeBefore;",
      "isPublic": true,
      "line": 273,
      "raw": "export const RequireTimeBefore = Cardano.NativeScriptKind.RequireTimeBefore;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.VrfVkBech32",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.VrfVkBech32",
      "name": "VrfVkBech32",
      "type": "any",
      "value": "Cardano.VrfVkBech32;",
      "isPublic": true,
      "line": 276,
      "raw": "export const VrfVkBech32 = Cardano.VrfVkBech32;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.ScriptPubkey",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.ScriptPubkey",
      "name": "ScriptPubkey",
      "type": "any",
      "value": "Serialization.ScriptPubkey;",
      "isPublic": true,
      "line": 279,
      "raw": "export const ScriptPubkey = Serialization.ScriptPubkey;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.DRepID",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.DRepID",
      "name": "DRepID",
      "type": "any",
      "value": "Cardano.DRepID;",
      "isPublic": true,
      "line": 282,
      "raw": "export const DRepID = Cardano.DRepID;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.DRep",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.DRep",
      "name": "DRep",
      "type": "any",
      "value": "Serialization.DRep;",
      "isPublic": true,
      "line": 285,
      "raw": "export const DRep = Serialization.DRep;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.StakeCredentialStatus",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.StakeCredentialStatus",
      "name": "StakeCredentialStatus",
      "type": "any",
      "value": "Cardano.StakeCredentialStatus;",
      "isPublic": true,
      "line": 288,
      "raw": "export const StakeCredentialStatus = Cardano.StakeCredentialStatus;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.HexBlob",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.HexBlob",
      "name": "HexBlob",
      "type": "any",
      "value": "CardanoHexBlob;",
      "isPublic": true,
      "line": 293,
      "raw": "export const HexBlob = CardanoHexBlob;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.TxCBOR",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.TxCBOR",
      "name": "TxCBOR",
      "type": "any",
      "value": "Serialization.TxCBOR;",
      "isPublic": true,
      "line": 296,
      "raw": "export const TxCBOR = Serialization.TxCBOR;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PrivateKey",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.Ed25519PrivateKey",
      "name": "Ed25519PrivateKey",
      "type": "any",
      "value": "Crypto.Ed25519PrivateKey;",
      "isPublic": true,
      "line": 299,
      "raw": "export const Ed25519PrivateKey = Crypto.Ed25519PrivateKey;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.computeAuxiliaryDataHash",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.computeAuxiliaryDataHash",
      "name": "computeAuxiliaryDataHash",
      "type": "any",
      "value": "Cardano.computeAuxiliaryDataHash;",
      "isPublic": true,
      "line": 301,
      "raw": "export const computeAuxiliaryDataHash = Cardano.computeAuxiliaryDataHash;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.blake2b",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.blake2b",
      "name": "blake2b",
      "type": "any",
      "value": "Crypto.blake2b;",
      "isPublic": true,
      "line": 302,
      "raw": "export const blake2b = Crypto.blake2b;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:types.cardano-sdk.ts.BootstrapWitness",
      "fullName": "mesh-core-cst:types.cardano-sdk.ts.BootstrapWitness",
      "name": "BootstrapWitness",
      "type": "any",
      "value": "Serialization.BootstrapWitness;",
      "isPublic": true,
      "line": 305,
      "raw": "export const BootstrapWitness = Serialization.BootstrapWitness;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.serialzeAddress",
      "fullName": "mesh-core-cst:utils.address.ts.serialzeAddress",
      "name": "serialzeAddress",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 28,
      "raw": "export const serialzeAddress = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.isPaymentScript",
      "fullName": "mesh-core-cst:utils.address.ts.isPaymentScript",
      "name": "isPaymentScript",
      "type": "any",
      "value": "!pubKeyHash;",
      "isPublic": true,
      "line": 39,
      "raw": "const isPaymentScript = !pubKeyHash;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.isStakeScript",
      "fullName": "mesh-core-cst:utils.address.ts.isStakeScript",
      "name": "isStakeScript",
      "type": "any",
      "value": "!stakeCredentialHash;",
      "isPublic": true,
      "line": 40,
      "raw": "const isStakeScript = !stakeCredentialHash;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.paymentHash",
      "fullName": "mesh-core-cst:utils.address.ts.paymentHash",
      "name": "paymentHash",
      "type": "any",
      "value": "isPaymentScript ? scriptHash : pubKeyHash;",
      "isPublic": true,
      "line": 42,
      "raw": "const paymentHash = isPaymentScript ? scriptHash : pubKeyHash;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.stakeHash",
      "fullName": "mesh-core-cst:utils.address.ts.stakeHash",
      "name": "stakeHash",
      "type": "any",
      "value": "isStakeScript",
      "isPublic": true,
      "line": 44,
      "raw": "const stakeHash = isStakeScript",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.addressObj",
      "fullName": "mesh-core-cst:utils.address.ts.addressObj",
      "name": "addressObj",
      "type": "any",
      "value": "isPaymentScript",
      "isPublic": true,
      "line": 53,
      "raw": "const addressObj = isPaymentScript",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.addrBech32ToPlutusData",
      "fullName": "mesh-core-cst:utils.address.ts.addrBech32ToPlutusData",
      "name": "addrBech32ToPlutusData",
      "type": "any",
      "value": "(bech32: string): PlutusData => {",
      "isPublic": true,
      "line": 59,
      "raw": "const addrBech32ToPlutusData = (bech32: string): PlutusData => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.cardanoAddress",
      "fullName": "mesh-core-cst:utils.address.ts.cardanoAddress",
      "name": "cardanoAddress",
      "type": "any",
      "value": "Address.fromBech32(bech32);",
      "isPublic": true,
      "line": 60,
      "raw": "const cardanoAddress = Address.fromBech32(bech32);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.cardanoAddressProps",
      "fullName": "mesh-core-cst:utils.address.ts.cardanoAddressProps",
      "name": "cardanoAddressProps",
      "type": "any",
      "value": "cardanoAddress.getProps();",
      "isPublic": true,
      "line": 61,
      "raw": "const cardanoAddressProps = cardanoAddress.getProps();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.paymentPartList",
      "fullName": "mesh-core-cst:utils.address.ts.paymentPartList",
      "name": "paymentPartList",
      "type": "any",
      "value": "new PlutusList();",
      "isPublic": true,
      "line": 62,
      "raw": "const paymentPartList = new PlutusList();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.paymentPart",
      "fullName": "mesh-core-cst:utils.address.ts.paymentPart",
      "name": "paymentPart",
      "type": "any",
      "value": "PlutusData.newConstrPlutusData(",
      "isPublic": true,
      "line": 73,
      "raw": "const paymentPart = PlutusData.newConstrPlutusData(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.delegationPartList",
      "fullName": "mesh-core-cst:utils.address.ts.delegationPartList",
      "name": "delegationPartList",
      "type": "any",
      "value": "new PlutusList();",
      "isPublic": true,
      "line": 79,
      "raw": "const delegationPartList = new PlutusList();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.inlineDelegationPart",
      "fullName": "mesh-core-cst:utils.address.ts.inlineDelegationPart",
      "name": "inlineDelegationPart",
      "type": "any",
      "value": "PlutusData.newConstrPlutusData(",
      "isPublic": true,
      "line": 89,
      "raw": "const inlineDelegationPart = PlutusData.newConstrPlutusData(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.someList",
      "fullName": "mesh-core-cst:utils.address.ts.someList",
      "name": "someList",
      "type": "any",
      "value": "new PlutusList();",
      "isPublic": true,
      "line": 116,
      "raw": "const someList = new PlutusList();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.pointerList",
      "fullName": "mesh-core-cst:utils.address.ts.pointerList",
      "name": "pointerList",
      "type": "any",
      "value": "new PlutusList();",
      "isPublic": true,
      "line": 101,
      "raw": "const pointerList = new PlutusList();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.pointer",
      "fullName": "mesh-core-cst:utils.address.ts.pointer",
      "name": "pointer",
      "type": "any",
      "value": "PlutusData.newConstrPlutusData(",
      "isPublic": true,
      "line": 111,
      "raw": "const pointer = PlutusData.newConstrPlutusData(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.addressList",
      "fullName": "mesh-core-cst:utils.address.ts.addressList",
      "name": "addressList",
      "type": "any",
      "value": "new PlutusList();",
      "isPublic": true,
      "line": 127,
      "raw": "const addressList = new PlutusList();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.addrBech32ToPlutusDataHex",
      "fullName": "mesh-core-cst:utils.address.ts.addrBech32ToPlutusDataHex",
      "name": "addrBech32ToPlutusDataHex",
      "type": "any",
      "value": "(bech32: string): string => {",
      "isPublic": true,
      "line": 136,
      "raw": "export const addrBech32ToPlutusDataHex = (bech32: string): string => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.addrBech32ToPlutusDataObj",
      "fullName": "mesh-core-cst:utils.address.ts.addrBech32ToPlutusDataObj",
      "name": "addrBech32ToPlutusDataObj",
      "type": "any",
      "value": "<T>(bech32: string): T => {",
      "isPublic": true,
      "line": 140,
      "raw": "export const addrBech32ToPlutusDataObj = <T>(bech32: string): T => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.plutusDataToAddrBech32",
      "fullName": "mesh-core-cst:utils.address.ts.plutusDataToAddrBech32",
      "name": "plutusDataToAddrBech32",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 144,
      "raw": "const plutusDataToAddrBech32 = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.constrPlutusData",
      "fullName": "mesh-core-cst:utils.address.ts.constrPlutusData",
      "name": "constrPlutusData",
      "type": "any",
      "value": "plutusData.asConstrPlutusData();",
      "isPublic": true,
      "line": 148,
      "raw": "const constrPlutusData = plutusData.asConstrPlutusData();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.plutusDataList",
      "fullName": "mesh-core-cst:utils.address.ts.plutusDataList",
      "name": "plutusDataList",
      "type": "any",
      "value": "constrPlutusData.getData();",
      "isPublic": true,
      "line": 155,
      "raw": "const plutusDataList = constrPlutusData.getData();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.paymentData",
      "fullName": "mesh-core-cst:utils.address.ts.paymentData",
      "name": "paymentData",
      "type": "any",
      "value": "plutusDataList.get(0);",
      "isPublic": true,
      "line": 160,
      "raw": "const paymentData = plutusDataList.get(0);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.paymentConstrData",
      "fullName": "mesh-core-cst:utils.address.ts.paymentConstrData",
      "name": "paymentConstrData",
      "type": "any",
      "value": "paymentData.asConstrPlutusData();",
      "isPublic": true,
      "line": 161,
      "raw": "const paymentConstrData = paymentData.asConstrPlutusData();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.paymentConstrDataList",
      "fullName": "mesh-core-cst:utils.address.ts.paymentConstrDataList",
      "name": "paymentConstrDataList",
      "type": "any",
      "value": "paymentConstrData.getData();",
      "isPublic": true,
      "line": 168,
      "raw": "const paymentConstrDataList = paymentConstrData.getData();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.paymentBytes",
      "fullName": "mesh-core-cst:utils.address.ts.paymentBytes",
      "name": "paymentBytes",
      "type": "any",
      "value": "paymentConstrDataList.get(0).asBoundedBytes();",
      "isPublic": true,
      "line": 175,
      "raw": "const paymentBytes = paymentConstrDataList.get(0).asBoundedBytes();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.cardanoPaymentCredential",
      "fullName": "mesh-core-cst:utils.address.ts.cardanoPaymentCredential",
      "name": "cardanoPaymentCredential",
      "type": "any",
      "value": "{",
      "isPublic": true,
      "line": 190,
      "raw": "const cardanoPaymentCredential = {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.delegationData",
      "fullName": "mesh-core-cst:utils.address.ts.delegationData",
      "name": "delegationData",
      "type": "any",
      "value": "plutusDataList.get(1);",
      "isPublic": true,
      "line": 195,
      "raw": "const delegationData = plutusDataList.get(1);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.delegationConstrData",
      "fullName": "mesh-core-cst:utils.address.ts.delegationConstrData",
      "name": "delegationConstrData",
      "type": "any",
      "value": "delegationData.asConstrPlutusData();",
      "isPublic": true,
      "line": 197,
      "raw": "const delegationConstrData = delegationData.asConstrPlutusData();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.delegationDataList",
      "fullName": "mesh-core-cst:utils.address.ts.delegationDataList",
      "name": "delegationDataList",
      "type": "any",
      "value": "delegationConstrData.getData();",
      "isPublic": true,
      "line": 213,
      "raw": "const delegationDataList = delegationConstrData.getData();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.delegationDataInner",
      "fullName": "mesh-core-cst:utils.address.ts.delegationDataInner",
      "name": "delegationDataInner",
      "type": "any",
      "value": "delegationDataList.get(0);",
      "isPublic": true,
      "line": 220,
      "raw": "const delegationDataInner = delegationDataList.get(0);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.delegationDataInnerList",
      "fullName": "mesh-core-cst:utils.address.ts.delegationDataInnerList",
      "name": "delegationDataInnerList",
      "type": "any",
      "value": "delegationDataInnerConstrData.getData();",
      "isPublic": true,
      "line": 275,
      "raw": "const delegationDataInnerList = delegationDataInnerConstrData.getData();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.delegationCredential",
      "fullName": "mesh-core-cst:utils.address.ts.delegationCredential",
      "name": "delegationCredential",
      "type": "any",
      "value": "delegationDataInnerList",
      "isPublic": true,
      "line": 238,
      "raw": "const delegationCredential = delegationDataInnerList",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.delegationBytesList",
      "fullName": "mesh-core-cst:utils.address.ts.delegationBytesList",
      "name": "delegationBytesList",
      "type": "any",
      "value": "delegationCredential.getData();",
      "isPublic": true,
      "line": 247,
      "raw": "const delegationBytesList = delegationCredential.getData();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.delegationBytes",
      "fullName": "mesh-core-cst:utils.address.ts.delegationBytes",
      "name": "delegationBytes",
      "type": "any",
      "value": "delegationBytesList.get(0).asBoundedBytes();",
      "isPublic": true,
      "line": 254,
      "raw": "const delegationBytes = delegationBytesList.get(0).asBoundedBytes();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.cardanoStakeCredential",
      "fullName": "mesh-core-cst:utils.address.ts.cardanoStakeCredential",
      "name": "cardanoStakeCredential",
      "type": "any",
      "value": "{",
      "isPublic": true,
      "line": 261,
      "raw": "const cardanoStakeCredential = {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.slot",
      "fullName": "mesh-core-cst:utils.address.ts.slot",
      "name": "slot",
      "type": "any",
      "value": "delegationDataInnerList.get(0).asInteger();",
      "isPublic": true,
      "line": 282,
      "raw": "const slot = delegationDataInnerList.get(0).asInteger();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.txIndex",
      "fullName": "mesh-core-cst:utils.address.ts.txIndex",
      "name": "txIndex",
      "type": "any",
      "value": "delegationDataInnerList.get(1).asInteger();",
      "isPublic": true,
      "line": 289,
      "raw": "const txIndex = delegationDataInnerList.get(1).asInteger();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.certIndex",
      "fullName": "mesh-core-cst:utils.address.ts.certIndex",
      "name": "certIndex",
      "type": "any",
      "value": "delegationDataInnerList.get(2).asInteger();",
      "isPublic": true,
      "line": 296,
      "raw": "const certIndex = delegationDataInnerList.get(2).asInteger();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.cardanoPointer",
      "fullName": "mesh-core-cst:utils.address.ts.cardanoPointer",
      "name": "cardanoPointer",
      "type": "any",
      "value": "{",
      "isPublic": true,
      "line": 303,
      "raw": "const cardanoPointer = {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.serializeAddressObj",
      "fullName": "mesh-core-cst:utils.address.ts.serializeAddressObj",
      "name": "serializeAddressObj",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 329,
      "raw": "export const serializeAddressObj = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.cardanoPlutusData",
      "fullName": "mesh-core-cst:utils.address.ts.cardanoPlutusData",
      "name": "cardanoPlutusData",
      "type": "any",
      "value": "PlutusData.fromCbor(HexBlob(plutusHex));",
      "isPublic": true,
      "line": 341,
      "raw": "const cardanoPlutusData = PlutusData.fromCbor(HexBlob(plutusHex));",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.serializePlutusAddressToBech32",
      "fullName": "mesh-core-cst:utils.address.ts.serializePlutusAddressToBech32",
      "name": "serializePlutusAddressToBech32",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 337,
      "raw": "export const serializePlutusAddressToBech32 = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.deserializeBech32Address",
      "fullName": "mesh-core-cst:utils.address.ts.deserializeBech32Address",
      "name": "deserializeBech32Address",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 345,
      "raw": "export const deserializeBech32Address = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.deserializedAddress",
      "fullName": "mesh-core-cst:utils.address.ts.deserializedAddress",
      "name": "deserializedAddress",
      "type": "any",
      "value": "Address.fromBech32(bech32Addr).getProps();",
      "isPublic": true,
      "line": 348,
      "raw": "const deserializedAddress = Address.fromBech32(bech32Addr).getProps();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.deserializeAddress",
      "fullName": "mesh-core-cst:utils.address.ts.deserializeAddress",
      "name": "deserializeAddress",
      "type": "any",
      "value": "(address: string): Address => {",
      "isPublic": true,
      "line": 369,
      "raw": "export const deserializeAddress = (address: string): Address => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts._address",
      "fullName": "mesh-core-cst:utils.address.ts._address",
      "name": "_address",
      "type": "any",
      "value": "Address.fromString(address);",
      "isPublic": true,
      "line": 370,
      "raw": "const _address = Address.fromString(address);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.scriptHashToBech32",
      "fullName": "mesh-core-cst:utils.address.ts.scriptHashToBech32",
      "name": "scriptHashToBech32",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 375,
      "raw": "export const scriptHashToBech32 = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.v2ScriptToBech32",
      "fullName": "mesh-core-cst:utils.address.ts.v2ScriptToBech32",
      "name": "v2ScriptToBech32",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 406,
      "raw": "export const v2ScriptToBech32 = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.scriptHashToRewardAddress",
      "fullName": "mesh-core-cst:utils.address.ts.scriptHashToRewardAddress",
      "name": "scriptHashToRewardAddress",
      "type": "any",
      "value": "(hash: string, networkId = 0) => {",
      "isPublic": true,
      "line": 419,
      "raw": "export const scriptHashToRewardAddress = (hash: string, networkId = 0) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.address.ts.keyHashToRewardAddress",
      "fullName": "mesh-core-cst:utils.address.ts.keyHashToRewardAddress",
      "name": "keyHashToRewardAddress",
      "type": "any",
      "value": "(hash: string, networkId = 0) => {",
      "isPublic": true,
      "line": 429,
      "raw": "export const keyHashToRewardAddress = (hash: string, networkId = 0) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.buildBaseAddress",
      "fullName": "mesh-core-cst:utils.builder.ts.buildBaseAddress",
      "name": "buildBaseAddress",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 28,
      "raw": "export const buildBaseAddress = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.buildEnterpriseAddress",
      "fullName": "mesh-core-cst:utils.builder.ts.buildEnterpriseAddress",
      "name": "buildEnterpriseAddress",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 46,
      "raw": "export const buildEnterpriseAddress = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.clampScalar",
      "fullName": "mesh-core-cst:utils.builder.ts.clampScalar",
      "name": "clampScalar",
      "type": "any",
      "value": "(scalar: Buffer): Buffer => {",
      "isPublic": true,
      "line": 56,
      "raw": "export const clampScalar = (scalar: Buffer): Buffer => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.buildBip32PrivateKey",
      "fullName": "mesh-core-cst:utils.builder.ts.buildBip32PrivateKey",
      "name": "buildBip32PrivateKey",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 67,
      "raw": "export const buildBip32PrivateKey = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.PBKDF2_ITERATIONS",
      "fullName": "mesh-core-cst:utils.builder.ts.PBKDF2_ITERATIONS",
      "name": "PBKDF2_ITERATIONS",
      "type": "any",
      "value": "4096;",
      "isPublic": true,
      "line": 71,
      "raw": "const PBKDF2_ITERATIONS = 4096;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.PBKDF2_KEY_SIZE",
      "fullName": "mesh-core-cst:utils.builder.ts.PBKDF2_KEY_SIZE",
      "name": "PBKDF2_KEY_SIZE",
      "type": "any",
      "value": "96;",
      "isPublic": true,
      "line": 72,
      "raw": "const PBKDF2_KEY_SIZE = 96;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.PBKDF2_DIGEST_ALGORITHM",
      "fullName": "mesh-core-cst:utils.builder.ts.PBKDF2_DIGEST_ALGORITHM",
      "name": "PBKDF2_DIGEST_ALGORITHM",
      "type": "any",
      "value": "\"sha512\";",
      "isPublic": true,
      "line": 73,
      "raw": "const PBKDF2_DIGEST_ALGORITHM = \"sha512\";",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts._entropy",
      "fullName": "mesh-core-cst:utils.builder.ts._entropy",
      "name": "_entropy",
      "type": "any",
      "value": "Buffer.from(entropy, \"hex\");",
      "isPublic": true,
      "line": 75,
      "raw": "const _entropy = Buffer.from(entropy, \"hex\");",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.xprv",
      "fullName": "mesh-core-cst:utils.builder.ts.xprv",
      "name": "xprv",
      "type": "any",
      "value": "pbkdf2Sync(",
      "isPublic": true,
      "line": 77,
      "raw": "const xprv = pbkdf2Sync(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.buildRewardAddress",
      "fullName": "mesh-core-cst:utils.builder.ts.buildRewardAddress",
      "name": "buildRewardAddress",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 87,
      "raw": "export const buildRewardAddress = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.cred",
      "fullName": "mesh-core-cst:utils.builder.ts.cred",
      "name": "cred",
      "type": "any",
      "value": "{",
      "isPublic": true,
      "line": 91,
      "raw": "const cred = {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.buildKeys",
      "fullName": "mesh-core-cst:utils.builder.ts.buildKeys",
      "name": "buildKeys",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 108,
      "raw": "export const buildKeys = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.privateKey",
      "fullName": "mesh-core-cst:utils.builder.ts.privateKey",
      "name": "privateKey",
      "type": "any",
      "value": "Bip32PrivateKey.fromHex(",
      "isPublic": true,
      "line": 118,
      "raw": "const privateKey = Bip32PrivateKey.fromHex(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.accountKey",
      "fullName": "mesh-core-cst:utils.builder.ts.accountKey",
      "name": "accountKey",
      "type": "any",
      "value": "privateKey.derive([",
      "isPublic": true,
      "line": 123,
      "raw": "const accountKey = privateKey.derive([",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.paymentKey",
      "fullName": "mesh-core-cst:utils.builder.ts.paymentKey",
      "name": "paymentKey",
      "type": "any",
      "value": "Ed25519PrivateKey.fromNormalHex(",
      "isPublic": true,
      "line": 135,
      "raw": "const paymentKey = Ed25519PrivateKey.fromNormalHex(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.stakeKey",
      "fullName": "mesh-core-cst:utils.builder.ts.stakeKey",
      "name": "stakeKey",
      "type": "any",
      "value": "Ed25519PrivateKey.fromNormalHex(",
      "isPublic": true,
      "line": 138,
      "raw": "const stakeKey = Ed25519PrivateKey.fromNormalHex(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.dRepKey",
      "fullName": "mesh-core-cst:utils.builder.ts.dRepKey",
      "name": "dRepKey",
      "type": "any",
      "value": "accountKey.derive([3, keyIndex]).toRawKey(); // dRep Keys, index",
      "isPublic": true,
      "line": 131,
      "raw": "const dRepKey = accountKey.derive([3, keyIndex]).toRawKey(); // dRep Keys, index",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.buildEd25519PrivateKeyFromSecretKey",
      "fullName": "mesh-core-cst:utils.builder.ts.buildEd25519PrivateKeyFromSecretKey",
      "name": "buildEd25519PrivateKeyFromSecretKey",
      "type": "any",
      "value": "(secretKeyHex: string) => {",
      "isPublic": true,
      "line": 146,
      "raw": "export const buildEd25519PrivateKeyFromSecretKey = (secretKeyHex: string) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.buildScriptPubkey",
      "fullName": "mesh-core-cst:utils.builder.ts.buildScriptPubkey",
      "name": "buildScriptPubkey",
      "type": "any",
      "value": "(keyHash: Ed25519KeyHash): NativeScript => {",
      "isPublic": true,
      "line": 158,
      "raw": "export const buildScriptPubkey = (keyHash: Ed25519KeyHash): NativeScript => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.scriptPubkey",
      "fullName": "mesh-core-cst:utils.builder.ts.scriptPubkey",
      "name": "scriptPubkey",
      "type": "any",
      "value": "new ScriptPubkey(Ed25519KeyHashHex(keyHash.hex()));",
      "isPublic": true,
      "line": 159,
      "raw": "const scriptPubkey = new ScriptPubkey(Ed25519KeyHashHex(keyHash.hex()));",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.buildDRepID",
      "fullName": "mesh-core-cst:utils.builder.ts.buildDRepID",
      "name": "buildDRepID",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 163,
      "raw": "export const buildDRepID = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.dRepKeyBytes",
      "fullName": "mesh-core-cst:utils.builder.ts.dRepKeyBytes",
      "name": "dRepKeyBytes",
      "type": "any",
      "value": "Buffer.from(dRepKey, \"hex\");",
      "isPublic": true,
      "line": 168,
      "raw": "const dRepKeyBytes = Buffer.from(dRepKey, \"hex\");",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.dRepIdHex",
      "fullName": "mesh-core-cst:utils.builder.ts.dRepIdHex",
      "name": "dRepIdHex",
      "type": "any",
      "value": "blake2b(28).update(dRepKeyBytes).digest(\"hex\");",
      "isPublic": true,
      "line": 169,
      "raw": "const dRepIdHex = blake2b(28).update(dRepKeyBytes).digest(\"hex\");",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.builder.ts.paymentAddress",
      "fullName": "mesh-core-cst:utils.builder.ts.paymentAddress",
      "name": "paymentAddress",
      "type": "any",
      "value": "EnterpriseAddress.packParts({",
      "isPublic": true,
      "line": 170,
      "raw": "const paymentAddress = EnterpriseAddress.packParts({",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.certificate.ts.toCardanoCert",
      "fullName": "mesh-core-cst:utils.certificate.ts.toCardanoCert",
      "name": "toCardanoCert",
      "type": "any",
      "value": "(cert: CertificateType): CardanoCert => {",
      "isPublic": true,
      "line": 12,
      "raw": "export const toCardanoCert = (cert: CertificateType): CardanoCert => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.certificate.ts.rewardAddress",
      "fullName": "mesh-core-cst:utils.certificate.ts.rewardAddress",
      "name": "rewardAddress",
      "type": "any",
      "value": "Cardano.RewardAddress.fromAddress(",
      "isPublic": true,
      "line": 312,
      "raw": "const rewardAddress = Cardano.RewardAddress.fromAddress(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.certificate.ts.metadata",
      "fullName": "mesh-core-cst:utils.certificate.ts.metadata",
      "name": "metadata",
      "type": "any",
      "value": "cert.poolParams.metadata",
      "isPublic": true,
      "line": 73,
      "raw": "const metadata = cert.poolParams.metadata",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.certificate.ts.hotCred",
      "fullName": "mesh-core-cst:utils.certificate.ts.hotCred",
      "name": "hotCred",
      "type": "any",
      "value": "Cardano.Address.fromBech32(",
      "isPublic": true,
      "line": 356,
      "raw": "const hotCred = Cardano.Address.fromBech32(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.certificate.ts.coldCred",
      "fullName": "mesh-core-cst:utils.certificate.ts.coldCred",
      "name": "coldCred",
      "type": "any",
      "value": "Cardano.Address.fromBech32(",
      "isPublic": true,
      "line": 370,
      "raw": "const coldCred = Cardano.Address.fromBech32(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.certificate.ts.coreDRep",
      "fullName": "mesh-core-cst:utils.certificate.ts.coreDRep",
      "name": "coreDRep",
      "type": "any",
      "value": "toDRep(cert.drepId).toCore();",
      "isPublic": true,
      "line": 431,
      "raw": "const coreDRep = toDRep(cert.drepId).toCore();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toAddress",
      "fullName": "mesh-core-cst:utils.converter.ts.toAddress",
      "name": "toAddress",
      "type": "any",
      "value": "(bech32: string): Address =>",
      "isPublic": true,
      "line": 51,
      "raw": "export const toAddress = (bech32: string): Address =>",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toCardanoAddress",
      "fullName": "mesh-core-cst:utils.converter.ts.toCardanoAddress",
      "name": "toCardanoAddress",
      "type": "any",
      "value": "(address: string): Address => {",
      "isPublic": true,
      "line": 54,
      "raw": "export const toCardanoAddress = (address: string): Address => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toBaseAddress",
      "fullName": "mesh-core-cst:utils.converter.ts.toBaseAddress",
      "name": "toBaseAddress",
      "type": "any",
      "value": "(bech32: string): BaseAddress | undefined => {",
      "isPublic": true,
      "line": 66,
      "raw": "export const toBaseAddress = (bech32: string): BaseAddress | undefined => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toEnterpriseAddress",
      "fullName": "mesh-core-cst:utils.converter.ts.toEnterpriseAddress",
      "name": "toEnterpriseAddress",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 70,
      "raw": "export const toEnterpriseAddress = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toRewardAddress",
      "fullName": "mesh-core-cst:utils.converter.ts.toRewardAddress",
      "name": "toRewardAddress",
      "type": "any",
      "value": "(bech32: string): RewardAddress | undefined =>",
      "isPublic": true,
      "line": 76,
      "raw": "export const toRewardAddress = (bech32: string): RewardAddress | undefined =>",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.fromTxUnspentOutput",
      "fullName": "mesh-core-cst:utils.converter.ts.fromTxUnspentOutput",
      "name": "fromTxUnspentOutput",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 79,
      "raw": "export const fromTxUnspentOutput = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.dataHash",
      "fullName": "mesh-core-cst:utils.converter.ts.dataHash",
      "name": "dataHash",
      "type": "any",
      "value": "txUnspentOutput.output().datum()",
      "isPublic": true,
      "line": 82,
      "raw": "const dataHash = txUnspentOutput.output().datum()",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.scriptRef",
      "fullName": "mesh-core-cst:utils.converter.ts.scriptRef",
      "name": "scriptRef",
      "type": "any",
      "value": "txUnspentOutput.output().scriptRef()",
      "isPublic": true,
      "line": 86,
      "raw": "const scriptRef = txUnspentOutput.output().scriptRef()",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.plutusData",
      "fullName": "mesh-core-cst:utils.converter.ts.plutusData",
      "name": "plutusData",
      "type": "any",
      "value": "deserializePlutusData(utxo.output.plutusData);",
      "isPublic": true,
      "line": 127,
      "raw": "const plutusData = deserializePlutusData(utxo.output.plutusData);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toTxUnspentOutput",
      "fullName": "mesh-core-cst:utils.converter.ts.toTxUnspentOutput",
      "name": "toTxUnspentOutput",
      "type": "any",
      "value": "(utxo: UTxO) => {",
      "isPublic": true,
      "line": 109,
      "raw": "export const toTxUnspentOutput = (utxo: UTxO) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.txInput",
      "fullName": "mesh-core-cst:utils.converter.ts.txInput",
      "name": "txInput",
      "type": "any",
      "value": "new TransactionInput(",
      "isPublic": true,
      "line": 110,
      "raw": "const txInput = new TransactionInput(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.txOutput",
      "fullName": "mesh-core-cst:utils.converter.ts.txOutput",
      "name": "txOutput",
      "type": "any",
      "value": "new TransactionOutput(",
      "isPublic": true,
      "line": 115,
      "raw": "const txOutput = new TransactionOutput(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.datum",
      "fullName": "mesh-core-cst:utils.converter.ts.datum",
      "name": "datum",
      "type": "any",
      "value": "new Serialization.Datum(undefined, plutusData);",
      "isPublic": true,
      "line": 128,
      "raw": "const datum = new Serialization.Datum(undefined, plutusData);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.addressToBech32",
      "fullName": "mesh-core-cst:utils.converter.ts.addressToBech32",
      "name": "addressToBech32",
      "type": "any",
      "value": "(address: Address): string => {",
      "isPublic": true,
      "line": 139,
      "raw": "export const addressToBech32 = (address: Address): string => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.fromValue",
      "fullName": "mesh-core-cst:utils.converter.ts.fromValue",
      "name": "fromValue",
      "type": "any",
      "value": "(value: Value) => {",
      "isPublic": true,
      "line": 143,
      "raw": "export const fromValue = (value: Value) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.assets",
      "fullName": "mesh-core-cst:utils.converter.ts.assets",
      "name": "assets",
      "type": "Asset[]",
      "value": "[",
      "isPublic": true,
      "line": 144,
      "raw": "const assets: Asset[] = [",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.multiAsset",
      "fullName": "mesh-core-cst:utils.converter.ts.multiAsset",
      "name": "multiAsset",
      "type": "TokenMap",
      "value": "new Map();",
      "isPublic": true,
      "line": 327,
      "raw": "const multiAsset: TokenMap = new Map();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts._assets",
      "fullName": "mesh-core-cst:utils.converter.ts._assets",
      "name": "_assets",
      "type": "any",
      "value": "Array.from(multiAsset.keys());",
      "isPublic": true,
      "line": 150,
      "raw": "const _assets = Array.from(multiAsset.keys());",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.assetId",
      "fullName": "mesh-core-cst:utils.converter.ts.assetId",
      "name": "assetId",
      "type": "any",
      "value": "_assets[i];",
      "isPublic": true,
      "line": 152,
      "raw": "const assetId = _assets[i];",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.assetQuantity",
      "fullName": "mesh-core-cst:utils.converter.ts.assetQuantity",
      "name": "assetQuantity",
      "type": "any",
      "value": "multiAsset.get(assetId);",
      "isPublic": true,
      "line": 154,
      "raw": "const assetQuantity = multiAsset.get(assetId);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toScriptRef",
      "fullName": "mesh-core-cst:utils.converter.ts.toScriptRef",
      "name": "toScriptRef",
      "type": "any",
      "value": "(script: PlutusScript | NativeScript): Script => {",
      "isPublic": true,
      "line": 168,
      "raw": "export const toScriptRef = (script: PlutusScript | NativeScript): Script => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.plutusScript",
      "fullName": "mesh-core-cst:utils.converter.ts.plutusScript",
      "name": "plutusScript",
      "type": "any",
      "value": "deserializePlutusScript(script.code, script.version);",
      "isPublic": true,
      "line": 170,
      "raw": "const plutusScript = deserializePlutusScript(script.code, script.version);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.fromScriptRef",
      "fullName": "mesh-core-cst:utils.converter.ts.fromScriptRef",
      "name": "fromScriptRef",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 181,
      "raw": "export const fromScriptRef = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.script",
      "fullName": "mesh-core-cst:utils.converter.ts.script",
      "name": "script",
      "type": "any",
      "value": "scripts[index];",
      "isPublic": true,
      "line": 224,
      "raw": "const script = scripts[index];",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.plutusScriptCodeV3",
      "fullName": "mesh-core-cst:utils.converter.ts.plutusScriptCodeV3",
      "name": "plutusScriptCodeV3",
      "type": "any",
      "value": "script.asPlutusV3()?.toCbor().toString();",
      "isPublic": true,
      "line": 186,
      "raw": "const plutusScriptCodeV3 = script.asPlutusV3()?.toCbor().toString();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.plutusScriptCodeV2",
      "fullName": "mesh-core-cst:utils.converter.ts.plutusScriptCodeV2",
      "name": "plutusScriptCodeV2",
      "type": "any",
      "value": "script.asPlutusV2()?.toCbor().toString();",
      "isPublic": true,
      "line": 194,
      "raw": "const plutusScriptCodeV2 = script.asPlutusV2()?.toCbor().toString();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.plutusScriptCodeV1",
      "fullName": "mesh-core-cst:utils.converter.ts.plutusScriptCodeV1",
      "name": "plutusScriptCodeV1",
      "type": "any",
      "value": "script.asPlutusV1()?.toCbor().toString();",
      "isPublic": true,
      "line": 202,
      "raw": "const plutusScriptCodeV1 = script.asPlutusV1()?.toCbor().toString();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.nativeScript",
      "fullName": "mesh-core-cst:utils.converter.ts.nativeScript",
      "name": "nativeScript",
      "type": "any",
      "value": "script.asNative();",
      "isPublic": true,
      "line": 211,
      "raw": "const nativeScript = script.asNative();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.fromNativeScript",
      "fullName": "mesh-core-cst:utils.converter.ts.fromNativeScript",
      "name": "fromNativeScript",
      "type": "any",
      "value": "(script: CstNativeScript) => {",
      "isPublic": true,
      "line": 219,
      "raw": "export const fromNativeScript = (script: CstNativeScript) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.fromNativeScripts",
      "fullName": "mesh-core-cst:utils.converter.ts.fromNativeScripts",
      "name": "fromNativeScripts",
      "type": "any",
      "value": "(scripts: CstNativeScript[]) => {",
      "isPublic": true,
      "line": 220,
      "raw": "const fromNativeScripts = (scripts: CstNativeScript[]) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.nativeScripts",
      "fullName": "mesh-core-cst:utils.converter.ts.nativeScripts",
      "name": "nativeScripts",
      "type": "CstNativeScript[]",
      "value": "[];",
      "isPublic": true,
      "line": 284,
      "raw": "const nativeScripts: CstNativeScript[] = [];",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.scriptAll",
      "fullName": "mesh-core-cst:utils.converter.ts.scriptAll",
      "name": "scriptAll",
      "type": "any",
      "value": "script.asScriptAll()!;",
      "isPublic": true,
      "line": 235,
      "raw": "const scriptAll = script.asScriptAll()!;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.scriptAny",
      "fullName": "mesh-core-cst:utils.converter.ts.scriptAny",
      "name": "scriptAny",
      "type": "any",
      "value": "script.asScriptAny()!;",
      "isPublic": true,
      "line": 242,
      "raw": "const scriptAny = script.asScriptAny()!;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.scriptNOfK",
      "fullName": "mesh-core-cst:utils.converter.ts.scriptNOfK",
      "name": "scriptNOfK",
      "type": "any",
      "value": "script.asScriptNOfK()!;",
      "isPublic": true,
      "line": 249,
      "raw": "const scriptNOfK = script.asScriptNOfK()!;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.timelockStart",
      "fullName": "mesh-core-cst:utils.converter.ts.timelockStart",
      "name": "timelockStart",
      "type": "any",
      "value": "script.asTimelockStart()!;",
      "isPublic": true,
      "line": 257,
      "raw": "const timelockStart = script.asTimelockStart()!;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.timelockExpiry",
      "fullName": "mesh-core-cst:utils.converter.ts.timelockExpiry",
      "name": "timelockExpiry",
      "type": "any",
      "value": "script.asTimelockExpiry()!;",
      "isPublic": true,
      "line": 264,
      "raw": "const timelockExpiry = script.asTimelockExpiry()!;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.scriptPubkey",
      "fullName": "mesh-core-cst:utils.converter.ts.scriptPubkey",
      "name": "scriptPubkey",
      "type": "any",
      "value": "script.asScriptPubkey()!;",
      "isPublic": true,
      "line": 271,
      "raw": "const scriptPubkey = script.asScriptPubkey()!;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toNativeScript",
      "fullName": "mesh-core-cst:utils.converter.ts.toNativeScript",
      "name": "toNativeScript",
      "type": "any",
      "value": "(script: NativeScript) => {",
      "isPublic": true,
      "line": 282,
      "raw": "export const toNativeScript = (script: NativeScript) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toNativeScripts",
      "fullName": "mesh-core-cst:utils.converter.ts.toNativeScripts",
      "name": "toNativeScripts",
      "type": "any",
      "value": "(scripts: NativeScript[]) => {",
      "isPublic": true,
      "line": 283,
      "raw": "const toNativeScripts = (scripts: NativeScript[]) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toValue",
      "fullName": "mesh-core-cst:utils.converter.ts.toValue",
      "name": "toValue",
      "type": "any",
      "value": "(assets: Asset[]) => {",
      "isPublic": true,
      "line": 326,
      "raw": "export const toValue = (assets: Asset[]) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.lovelace",
      "fullName": "mesh-core-cst:utils.converter.ts.lovelace",
      "name": "lovelace",
      "type": "any",
      "value": "assets.find((asset) => asset.unit === \"lovelace\" || asset.unit === \"\");",
      "isPublic": true,
      "line": 334,
      "raw": "const lovelace = assets.find((asset) => asset.unit === \"lovelace\" || asset.unit === \"\");",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.value",
      "fullName": "mesh-core-cst:utils.converter.ts.value",
      "name": "value",
      "type": "any",
      "value": "new Value(BigInt(lovelace ? lovelace.quantity : 0));",
      "isPublic": true,
      "line": 335,
      "raw": "const value = new Value(BigInt(lovelace ? lovelace.quantity : 0));",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.toDRep",
      "fullName": "mesh-core-cst:utils.converter.ts.toDRep",
      "name": "toDRep",
      "type": "any",
      "value": "(dRepId: string): Serialization.DRep => {",
      "isPublic": true,
      "line": 344,
      "raw": "export const toDRep = (dRepId: string): Serialization.DRep => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.bytes",
      "fullName": "mesh-core-cst:utils.converter.ts.bytes",
      "name": "bytes",
      "type": "any",
      "value": "base32.decode(new Uint8Array(words));",
      "isPublic": true,
      "line": 404,
      "raw": "const bytes = base32.decode(new Uint8Array(words));",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.converter.ts.getDRepIds",
      "fullName": "mesh-core-cst:utils.converter.ts.getDRepIds",
      "name": "getDRepIds",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 388,
      "raw": "export const getDRepIds = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.toPlutusData",
      "fullName": "mesh-core-cst:utils.data.ts.toPlutusData",
      "name": "toPlutusData",
      "type": "any",
      "value": "(data: Data): PlutusData => {",
      "isPublic": true,
      "line": 14,
      "raw": "export const toPlutusData = (data: Data): PlutusData => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.toPlutusList",
      "fullName": "mesh-core-cst:utils.data.ts.toPlutusList",
      "name": "toPlutusList",
      "type": "any",
      "value": "(data: Data[]) => {",
      "isPublic": true,
      "line": 15,
      "raw": "const toPlutusList = (data: Data[]) => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.plutusList",
      "fullName": "mesh-core-cst:utils.data.ts.plutusList",
      "name": "plutusList",
      "type": "any",
      "value": "data.asList();",
      "isPublic": true,
      "line": 211,
      "raw": "const plutusList = data.asList();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.plutusMap",
      "fullName": "mesh-core-cst:utils.data.ts.plutusMap",
      "name": "plutusMap",
      "type": "any",
      "value": "data.asMap();",
      "isPublic": true,
      "line": 187,
      "raw": "const plutusMap = data.asMap();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.isConstrPlutusDataJson",
      "fullName": "mesh-core-cst:utils.data.ts.isConstrPlutusDataJson",
      "name": "isConstrPlutusDataJson",
      "type": "any",
      "value": "(data: object): data is ConstrPlutusDataJson => {",
      "isPublic": true,
      "line": 56,
      "raw": "const isConstrPlutusDataJson = (data: object): data is ConstrPlutusDataJson => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.fromJsonToPlutusData",
      "fullName": "mesh-core-cst:utils.data.ts.fromJsonToPlutusData",
      "name": "fromJsonToPlutusData",
      "type": "any",
      "value": "(data: object): PlutusData => {",
      "isPublic": true,
      "line": 87,
      "raw": "export const fromJsonToPlutusData = (data: object): PlutusData => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.plutusConstrData",
      "fullName": "mesh-core-cst:utils.data.ts.plutusConstrData",
      "name": "plutusConstrData",
      "type": "any",
      "value": "new ConstrPlutusData(",
      "isPublic": true,
      "line": 93,
      "raw": "const plutusConstrData = new ConstrPlutusData(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.fromBuilderToPlutusData",
      "fullName": "mesh-core-cst:utils.data.ts.fromBuilderToPlutusData",
      "name": "fromBuilderToPlutusData",
      "type": "any",
      "value": "(data: BuilderData): PlutusData => {",
      "isPublic": true,
      "line": 149,
      "raw": "export const fromBuilderToPlutusData = (data: BuilderData): PlutusData => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.fromPlutusDataToJson",
      "fullName": "mesh-core-cst:utils.data.ts.fromPlutusDataToJson",
      "name": "fromPlutusDataToJson",
      "type": "any",
      "value": "(data: PlutusData): object => {",
      "isPublic": true,
      "line": 169,
      "raw": "export const fromPlutusDataToJson = (data: PlutusData): object => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.plutusData",
      "fullName": "mesh-core-cst:utils.data.ts.plutusData",
      "name": "plutusData",
      "type": "any",
      "value": "data.asConstrPlutusData();",
      "isPublic": true,
      "line": 171,
      "raw": "const plutusData = data.asConstrPlutusData();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.fields",
      "fullName": "mesh-core-cst:utils.data.ts.fields",
      "name": "fields",
      "type": "any",
      "value": "plutusData.getData();",
      "isPublic": true,
      "line": 173,
      "raw": "const fields = plutusData.getData();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.list",
      "fullName": "mesh-core-cst:utils.data.ts.list",
      "name": "list",
      "type": "object[]",
      "value": "[];",
      "isPublic": true,
      "line": 213,
      "raw": "const list: object[] = [];",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.element",
      "fullName": "mesh-core-cst:utils.data.ts.element",
      "name": "element",
      "type": "any",
      "value": "plutusList.get(i);",
      "isPublic": true,
      "line": 215,
      "raw": "const element = plutusList.get(i);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.keys",
      "fullName": "mesh-core-cst:utils.data.ts.keys",
      "name": "keys",
      "type": "any",
      "value": "plutusMap.getKeys();",
      "isPublic": true,
      "line": 193,
      "raw": "const keys = plutusMap.getKeys();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.key",
      "fullName": "mesh-core-cst:utils.data.ts.key",
      "name": "key",
      "type": "any",
      "value": "keys.get(i);",
      "isPublic": true,
      "line": 195,
      "raw": "const key = keys.get(i);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.value",
      "fullName": "mesh-core-cst:utils.data.ts.value",
      "name": "value",
      "type": "any",
      "value": "plutusMap.get(key);",
      "isPublic": true,
      "line": 196,
      "raw": "const value = plutusMap.get(key);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.plutusInt",
      "fullName": "mesh-core-cst:utils.data.ts.plutusInt",
      "name": "plutusInt",
      "type": "any",
      "value": "data.asInteger();",
      "isPublic": true,
      "line": 223,
      "raw": "const plutusInt = data.asInteger();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.plutusBytes",
      "fullName": "mesh-core-cst:utils.data.ts.plutusBytes",
      "name": "plutusBytes",
      "type": "any",
      "value": "data.asBoundedBytes();",
      "isPublic": true,
      "line": 232,
      "raw": "const plutusBytes = data.asBoundedBytes();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.datumCborToJson",
      "fullName": "mesh-core-cst:utils.data.ts.datumCborToJson",
      "name": "datumCborToJson",
      "type": "any",
      "value": "<T = any>(datumCbor: string): T => {",
      "isPublic": true,
      "line": 245,
      "raw": "const datumCborToJson = <T = any>(datumCbor: string): T => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.parsedDatum",
      "fullName": "mesh-core-cst:utils.data.ts.parsedDatum",
      "name": "parsedDatum",
      "type": "any",
      "value": "PlutusData.fromCbor(HexBlob(datumCbor));",
      "isPublic": true,
      "line": 246,
      "raw": "const parsedDatum = PlutusData.fromCbor(HexBlob(datumCbor));",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.parseDatumCbor",
      "fullName": "mesh-core-cst:utils.data.ts.parseDatumCbor",
      "name": "parseDatumCbor",
      "type": "any",
      "value": "<T = any>(datumCbor: string): T => {",
      "isPublic": true,
      "line": 249,
      "raw": "export const parseDatumCbor = <T = any>(datumCbor: string): T => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.parseInlineDatum",
      "fullName": "mesh-core-cst:utils.data.ts.parseInlineDatum",
      "name": "parseInlineDatum",
      "type": "any",
      "value": "<T extends { inline_datum?: string }, X>(",
      "isPublic": true,
      "line": 253,
      "raw": "export const parseInlineDatum = <T extends { inline_datum?: string }, X>(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.datumCbor",
      "fullName": "mesh-core-cst:utils.data.ts.datumCbor",
      "name": "datumCbor",
      "type": "string",
      "value": "utxo.inline_datum || \"\";",
      "isPublic": true,
      "line": 256,
      "raw": "const datumCbor: string = utxo.inline_datum || \"\";",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.deserializeDataHash",
      "fullName": "mesh-core-cst:utils.data.ts.deserializeDataHash",
      "name": "deserializeDataHash",
      "type": "any",
      "value": "(dataHash: string): DatumHash =>",
      "isPublic": true,
      "line": 260,
      "raw": "export const deserializeDataHash = (dataHash: string): DatumHash =>",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.data.ts.deserializePlutusData",
      "fullName": "mesh-core-cst:utils.data.ts.deserializePlutusData",
      "name": "deserializePlutusData",
      "type": "any",
      "value": "(plutusData: string): PlutusData =>",
      "isPublic": true,
      "line": 263,
      "raw": "export const deserializePlutusData = (plutusData: string): PlutusData =>",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.deserializer.ts.deserializeEd25519KeyHash",
      "fullName": "mesh-core-cst:utils.deserializer.ts.deserializeEd25519KeyHash",
      "name": "deserializeEd25519KeyHash",
      "type": "any",
      "value": "(ed25519KeyHash: string) =>",
      "isPublic": true,
      "line": 21,
      "raw": "export const deserializeEd25519KeyHash = (ed25519KeyHash: string) =>",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.deserializer.ts.deserializePlutusScript",
      "fullName": "mesh-core-cst:utils.deserializer.ts.deserializePlutusScript",
      "name": "deserializePlutusScript",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 24,
      "raw": "export const deserializePlutusScript = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.deserializer.ts.deserializeNativeScript",
      "fullName": "mesh-core-cst:utils.deserializer.ts.deserializeNativeScript",
      "name": "deserializeNativeScript",
      "type": "any",
      "value": "(nativeScript: string): NativeScript =>",
      "isPublic": true,
      "line": 40,
      "raw": "export const deserializeNativeScript = (nativeScript: string): NativeScript =>",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.deserializer.ts.deserializeScriptHash",
      "fullName": "mesh-core-cst:utils.deserializer.ts.deserializeScriptHash",
      "name": "deserializeScriptHash",
      "type": "any",
      "value": "(scriptHash: string) =>",
      "isPublic": true,
      "line": 43,
      "raw": "export const deserializeScriptHash = (scriptHash: string) =>",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.deserializer.ts.deserializeScriptRef",
      "fullName": "mesh-core-cst:utils.deserializer.ts.deserializeScriptRef",
      "name": "deserializeScriptRef",
      "type": "any",
      "value": "(scriptRef: string): Script =>",
      "isPublic": true,
      "line": 46,
      "raw": "export const deserializeScriptRef = (scriptRef: string): Script =>",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.deserializer.ts.deserializeTxUnspentOutput",
      "fullName": "mesh-core-cst:utils.deserializer.ts.deserializeTxUnspentOutput",
      "name": "deserializeTxUnspentOutput",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 49,
      "raw": "export const deserializeTxUnspentOutput = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.deserializer.ts.deserializeValue",
      "fullName": "mesh-core-cst:utils.deserializer.ts.deserializeValue",
      "name": "deserializeValue",
      "type": "any",
      "value": "(value: string): Value =>",
      "isPublic": true,
      "line": 54,
      "raw": "export const deserializeValue = (value: string): Value =>",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.deserializer.ts.deserializeTx",
      "fullName": "mesh-core-cst:utils.deserializer.ts.deserializeTx",
      "name": "deserializeTx",
      "type": "any",
      "value": "(tx: string): Transaction =>",
      "isPublic": true,
      "line": 57,
      "raw": "export const deserializeTx = (tx: string): Transaction =>",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.deserializer.ts.deserializeTxHash",
      "fullName": "mesh-core-cst:utils.deserializer.ts.deserializeTxHash",
      "name": "deserializeTxHash",
      "type": "any",
      "value": "(txHash: string): TransactionId =>",
      "isPublic": true,
      "line": 60,
      "raw": "export const deserializeTxHash = (txHash: string): TransactionId =>",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.encoding.ts.bytesToHex",
      "fullName": "mesh-core-cst:utils.encoding.ts.bytesToHex",
      "name": "bytesToHex",
      "type": "any",
      "value": "(bytes: Uint8Array): HexBlob =>",
      "isPublic": true,
      "line": 5,
      "raw": "export const bytesToHex = (bytes: Uint8Array): HexBlob =>",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.encoding.ts.hexToBytes",
      "fullName": "mesh-core-cst:utils.encoding.ts.hexToBytes",
      "name": "hexToBytes",
      "type": "any",
      "value": "(hex: HexBlob): Uint8Array => Buffer.from(hex, \"hex\");",
      "isPublic": true,
      "line": 8,
      "raw": "export const hexToBytes = (hex: HexBlob): Uint8Array => Buffer.from(hex, \"hex\");",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.encoding.ts.utf8ToBytes",
      "fullName": "mesh-core-cst:utils.encoding.ts.utf8ToBytes",
      "name": "utf8ToBytes",
      "type": "any",
      "value": "(str: string): Uint8Array =>",
      "isPublic": true,
      "line": 10,
      "raw": "export const utf8ToBytes = (str: string): Uint8Array =>",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.encoding.ts.utf8ToHex",
      "fullName": "mesh-core-cst:utils.encoding.ts.utf8ToHex",
      "name": "utf8ToHex",
      "type": "any",
      "value": "(str: string): HexBlob =>",
      "isPublic": true,
      "line": 13,
      "raw": "export const utf8ToHex = (str: string): HexBlob =>",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.encoding.ts.hexToBech32",
      "fullName": "mesh-core-cst:utils.encoding.ts.hexToBech32",
      "name": "hexToBech32",
      "type": "any",
      "value": "(prefix: string, hex: string): string => {",
      "isPublic": true,
      "line": 16,
      "raw": "export const hexToBech32 = (prefix: string, hex: string): string => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.encoding.ts.buf",
      "fullName": "mesh-core-cst:utils.encoding.ts.buf",
      "name": "buf",
      "type": "any",
      "value": "Buffer.from(hex, \"hex\");",
      "isPublic": true,
      "line": 17,
      "raw": "const buf = Buffer.from(hex, \"hex\");",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.encoding.ts.base32RawBytes",
      "fullName": "mesh-core-cst:utils.encoding.ts.base32RawBytes",
      "name": "base32RawBytes",
      "type": "any",
      "value": "base32.encode(buf);",
      "isPublic": true,
      "line": 18,
      "raw": "const base32RawBytes = base32.encode(buf);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.fee.ts.calculateFees",
      "fullName": "mesh-core-cst:utils.fee.ts.calculateFees",
      "name": "calculateFees",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 3,
      "raw": "export const calculateFees = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.fee.ts.calculateRefScriptFees",
      "fullName": "mesh-core-cst:utils.fee.ts.calculateRefScriptFees",
      "name": "calculateRefScriptFees",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 46,
      "raw": "const calculateRefScriptFees = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.fee.ts.tierSize",
      "fullName": "mesh-core-cst:utils.fee.ts.tierSize",
      "name": "tierSize",
      "type": "any",
      "value": "25600;",
      "isPublic": true,
      "line": 52,
      "raw": "const tierSize = 25600;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.metadata.ts.toCardanoMetadataMap",
      "fullName": "mesh-core-cst:utils.metadata.ts.toCardanoMetadataMap",
      "name": "toCardanoMetadataMap",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 5,
      "raw": "export const toCardanoMetadataMap = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.metadata.ts.toCardanoMetadatum",
      "fullName": "mesh-core-cst:utils.metadata.ts.toCardanoMetadatum",
      "name": "toCardanoMetadatum",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 15,
      "raw": "export const toCardanoMetadatum = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.metadata.ts.result",
      "fullName": "mesh-core-cst:utils.metadata.ts.result",
      "name": "result",
      "type": "MetadatumList",
      "value": "new MetadatumList();",
      "isPublic": true,
      "line": 33,
      "raw": "const result: MetadatumList = new MetadatumList();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.script-data-hash.ts.CBOR_EMPTY_MAP",
      "fullName": "mesh-core-cst:utils.script-data-hash.ts.CBOR_EMPTY_MAP",
      "name": "CBOR_EMPTY_MAP",
      "type": "any",
      "value": "new Uint8Array([0xa0]);",
      "isPublic": true,
      "line": 9,
      "raw": "const CBOR_EMPTY_MAP = new Uint8Array([0xa0]);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.script-data-hash.ts.hashScriptData",
      "fullName": "mesh-core-cst:utils.script-data-hash.ts.hashScriptData",
      "name": "hashScriptData",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 24,
      "raw": "export const hashScriptData = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.script-data-hash.ts.writer",
      "fullName": "mesh-core-cst:utils.script-data-hash.ts.writer",
      "name": "writer",
      "type": "any",
      "value": "new Serialization.CborWriter();",
      "isPublic": true,
      "line": 29,
      "raw": "const writer = new Serialization.CborWriter();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.value.ts.ma",
      "fullName": "mesh-core-cst:utils.value.ts.ma",
      "name": "ma",
      "type": "any",
      "value": "a.multiasset() ?? new Map();",
      "isPublic": true,
      "line": 4,
      "raw": "const ma = a.multiasset() ?? new Map();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.value.ts.newVal",
      "fullName": "mesh-core-cst:utils.value.ts.newVal",
      "name": "newVal",
      "type": "any",
      "value": "(ma.get(k) ?? 0n) + v;",
      "isPublic": true,
      "line": 6,
      "raw": "const newVal = (ma.get(k) ?? 0n) + v;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.value.ts.entries",
      "fullName": "mesh-core-cst:utils.value.ts.entries",
      "name": "entries",
      "type": "any",
      "value": "v.multiasset();",
      "isPublic": true,
      "line": 50,
      "raw": "const entries = v.multiasset();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.value.ts.tokenMap",
      "fullName": "mesh-core-cst:utils.value.ts.tokenMap",
      "name": "tokenMap",
      "type": "TokenMap",
      "value": "new Map();",
      "isPublic": true,
      "line": 37,
      "raw": "const tokenMap: TokenMap = new Map();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.value.ts.coin",
      "fullName": "mesh-core-cst:utils.value.ts.coin",
      "name": "coin",
      "type": "any",
      "value": "v.coin() < 0n ? v.coin() : 0n;",
      "isPublic": true,
      "line": 36,
      "raw": "const coin = v.coin() < 0n ? v.coin() : 0n;",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.vote.ts.toCardanoVoter",
      "fullName": "mesh-core-cst:utils.vote.ts.toCardanoVoter",
      "name": "toCardanoVoter",
      "type": "any",
      "value": "(voter: Voter): Serialization.Voter => {",
      "isPublic": true,
      "line": 18,
      "raw": "export const toCardanoVoter = (voter: Voter): Serialization.Voter => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.vote.ts.cardanoDrep",
      "fullName": "mesh-core-cst:utils.vote.ts.cardanoDrep",
      "name": "cardanoDrep",
      "type": "any",
      "value": "toDRep(voter.drepId);",
      "isPublic": true,
      "line": 37,
      "raw": "const cardanoDrep = toDRep(voter.drepId);",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.vote.ts.toCardanoVotingProcedure",
      "fullName": "mesh-core-cst:utils.vote.ts.toCardanoVotingProcedure",
      "name": "toCardanoVotingProcedure",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 60,
      "raw": "export const toCardanoVotingProcedure = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.vote.ts.toCardanoAnchor",
      "fullName": "mesh-core-cst:utils.vote.ts.toCardanoAnchor",
      "name": "toCardanoAnchor",
      "type": "any",
      "value": "(anchor: Anchor): Serialization.Anchor => {",
      "isPublic": true,
      "line": 71,
      "raw": "const toCardanoAnchor = (anchor: Anchor): Serialization.Anchor => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.vote.ts.toCardanoVoteKind",
      "fullName": "mesh-core-cst:utils.vote.ts.toCardanoVoteKind",
      "name": "toCardanoVoteKind",
      "type": "any",
      "value": "(voteType: VoteKind): Cardano.Vote => {",
      "isPublic": true,
      "line": 78,
      "raw": "const toCardanoVoteKind = (voteType: VoteKind): Cardano.Vote => {",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.vote.ts.toCardanoGovernanceActionId",
      "fullName": "mesh-core-cst:utils.vote.ts.toCardanoGovernanceActionId",
      "name": "toCardanoGovernanceActionId",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 92,
      "raw": "export const toCardanoGovernanceActionId = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.witness-set.ts.addVKeyWitnessSetToTransaction",
      "fullName": "mesh-core-cst:utils.witness-set.ts.addVKeyWitnessSetToTransaction",
      "name": "addVKeyWitnessSetToTransaction",
      "type": "any",
      "value": "(",
      "isPublic": true,
      "line": 10,
      "raw": "export const addVKeyWitnessSetToTransaction = (",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.witness-set.ts.tx",
      "fullName": "mesh-core-cst:utils.witness-set.ts.tx",
      "name": "tx",
      "type": "any",
      "value": "Transaction.fromCbor(TxCBOR(txHex));",
      "isPublic": true,
      "line": 14,
      "raw": "const tx = Transaction.fromCbor(TxCBOR(txHex));",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.witness-set.ts.currentWitnessSet",
      "fullName": "mesh-core-cst:utils.witness-set.ts.currentWitnessSet",
      "name": "currentWitnessSet",
      "type": "any",
      "value": "tx.witnessSet();",
      "isPublic": true,
      "line": 15,
      "raw": "const currentWitnessSet = tx.witnessSet();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.witness-set.ts.newVkeyWitnessSet",
      "fullName": "mesh-core-cst:utils.witness-set.ts.newVkeyWitnessSet",
      "name": "newVkeyWitnessSet",
      "type": "any",
      "value": "TransactionWitnessSet.fromCbor(",
      "isPublic": true,
      "line": 16,
      "raw": "const newVkeyWitnessSet = TransactionWitnessSet.fromCbor(",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.witness-set.ts.currentVkeyWitnesses",
      "fullName": "mesh-core-cst:utils.witness-set.ts.currentVkeyWitnesses",
      "name": "currentVkeyWitnesses",
      "type": "any",
      "value": "currentWitnessSet.vkeys();",
      "isPublic": true,
      "line": 20,
      "raw": "const currentVkeyWitnesses = currentWitnessSet.vkeys();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.witness-set.ts.newVkeyWitnesses",
      "fullName": "mesh-core-cst:utils.witness-set.ts.newVkeyWitnesses",
      "name": "newVkeyWitnesses",
      "type": "any",
      "value": "newVkeyWitnessSet.vkeys();",
      "isPublic": true,
      "line": 21,
      "raw": "const newVkeyWitnesses = newVkeyWitnessSet.vkeys();",
      "source": "mesh-core-cst"
    },
    {
      "key": "mesh-core-cst:utils.witness-set.ts.allVkeyWitnesses",
      "fullName": "mesh-core-cst:utils.witness-set.ts.allVkeyWitnesses",
      "name": "allVkeyWitnesses",
      "type": "any",
      "value": "[",
      "isPublic": true,
      "line": 22,
      "raw": "const allVkeyWitnesses = [",
      "source": "mesh-core-cst"
    },
    {
      "key": "bitcoin:core.ts.bip32",
      "fullName": "bitcoin:core.ts.bip32",
      "name": "bip32",
      "type": "any",
      "value": "BIP32Factory(ecc);",
      "isPublic": true,
      "line": 7,
      "raw": "const bip32 = BIP32Factory(ecc);",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:core.ts.ECPair",
      "fullName": "bitcoin:core.ts.ECPair",
      "name": "ECPair",
      "type": "any",
      "value": "ECPairFactory(ecc);",
      "isPublic": true,
      "line": 8,
      "raw": "const ECPair = ECPairFactory(ecc);",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:providers.blockstream.ts.url",
      "fullName": "bitcoin:providers.blockstream.ts.url",
      "name": "url",
      "type": "any",
      "value": "last_seen_txid",
      "isPublic": true,
      "line": 117,
      "raw": "const url = last_seen_txid",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:providers.common.ts.parseHttpError",
      "fullName": "bitcoin:providers.common.ts.parseHttpError",
      "name": "parseHttpError",
      "type": "any",
      "value": "(error: unknown): string => {",
      "isPublic": true,
      "line": 3,
      "raw": "export const parseHttpError = (error: unknown): string => {",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:utils.address.ts.p2wpkh",
      "fullName": "bitcoin:utils.address.ts.p2wpkh",
      "name": "p2wpkh",
      "type": "any",
      "value": "bitcoin.payments.p2wpkh({",
      "isPublic": true,
      "line": 8,
      "raw": "const p2wpkh = bitcoin.payments.p2wpkh({",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:utils.address.ts.pubKeyHex",
      "fullName": "bitcoin:utils.address.ts.pubKeyHex",
      "name": "pubKeyHex",
      "type": "any",
      "value": "Buffer.isBuffer(publicKey)",
      "isPublic": true,
      "line": 23,
      "raw": "const pubKeyHex = Buffer.isBuffer(publicKey)",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:wallets.browser.index.ts.response",
      "fullName": "bitcoin:wallets.browser.index.ts.response",
      "name": "response",
      "type": "any",
      "value": "await provider.request(method, params);",
      "isPublic": true,
      "line": 134,
      "raw": "const response = await provider.request(method, params);",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:wallets.browser.index.ts.addresses",
      "fullName": "bitcoin:wallets.browser.index.ts.addresses",
      "name": "addresses",
      "type": "any",
      "value": "await this.getAddresses();",
      "isPublic": true,
      "line": 51,
      "raw": "const addresses = await this.getAddresses();",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:wallets.browser.index.ts.address",
      "fullName": "bitcoin:wallets.browser.index.ts.address",
      "name": "address",
      "type": "any",
      "value": "addresses?.find(",
      "isPublic": true,
      "line": 86,
      "raw": "const address = addresses?.find(",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.address",
      "fullName": "bitcoin:wallets.embedded.index.ts.address",
      "name": "address",
      "type": "any",
      "value": "this.getAddress();",
      "isPublic": true,
      "line": 140,
      "raw": "const address = this.getAddress();",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.keyPair",
      "fullName": "bitcoin:wallets.embedded.index.ts.keyPair",
      "name": "keyPair",
      "type": "any",
      "value": "ECPair.fromPrivateKey(this._wallet.privateKey, {",
      "isPublic": true,
      "line": 165,
      "raw": "const keyPair = ECPair.fromPrivateKey(this._wallet.privateKey, {",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.messageBuffer",
      "fullName": "bitcoin:wallets.embedded.index.ts.messageBuffer",
      "name": "messageBuffer",
      "type": "any",
      "value": "Buffer.from(message, \"utf8\");",
      "isPublic": true,
      "line": 302,
      "raw": "const messageBuffer = Buffer.from(message, \"utf8\");",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.bufferToHash",
      "fullName": "bitcoin:wallets.embedded.index.ts.bufferToHash",
      "name": "bufferToHash",
      "type": "any",
      "value": "Buffer.concat([",
      "isPublic": true,
      "line": 303,
      "raw": "const bufferToHash = Buffer.concat([",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.hash",
      "fullName": "bitcoin:wallets.embedded.index.ts.hash",
      "name": "hash",
      "type": "any",
      "value": "bitcoin.crypto.hash256(bufferToHash);",
      "isPublic": true,
      "line": 307,
      "raw": "const hash = bitcoin.crypto.hash256(bufferToHash);",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.signature",
      "fullName": "bitcoin:wallets.embedded.index.ts.signature",
      "name": "signature",
      "type": "any",
      "value": "Buffer.from(signatureBase64, \"base64\");",
      "isPublic": true,
      "line": 308,
      "raw": "const signature = Buffer.from(signatureBase64, \"base64\");",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.psbt",
      "fullName": "bitcoin:wallets.embedded.index.ts.psbt",
      "name": "psbt",
      "type": "any",
      "value": "new bitcoin.Psbt({ network: this._network });",
      "isPublic": true,
      "line": 198,
      "raw": "const psbt = new bitcoin.Psbt({ network: this._network });",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.p2wpkh",
      "fullName": "bitcoin:wallets.embedded.index.ts.p2wpkh",
      "name": "p2wpkh",
      "type": "any",
      "value": "bitcoin.payments.p2wpkh({",
      "isPublic": true,
      "line": 199,
      "raw": "const p2wpkh = bitcoin.payments.p2wpkh({",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.ecPair",
      "fullName": "bitcoin:wallets.embedded.index.ts.ecPair",
      "name": "ecPair",
      "type": "any",
      "value": "ECPair.fromPrivateKey(this._wallet.privateKey, {",
      "isPublic": true,
      "line": 203,
      "raw": "const ecPair = ECPair.fromPrivateKey(this._wallet.privateKey, {",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.mnemonic",
      "fullName": "bitcoin:wallets.embedded.index.ts.mnemonic",
      "name": "mnemonic",
      "type": "any",
      "value": "words.join(\" \");",
      "isPublic": true,
      "line": 262,
      "raw": "const mnemonic = words.join(\" \");",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.seed",
      "fullName": "bitcoin:wallets.embedded.index.ts.seed",
      "name": "seed",
      "type": "any",
      "value": "mnemonicToSeedSync(mnemonic);",
      "isPublic": true,
      "line": 268,
      "raw": "const seed = mnemonicToSeedSync(mnemonic);",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.root",
      "fullName": "bitcoin:wallets.embedded.index.ts.root",
      "name": "root",
      "type": "any",
      "value": "bip32.fromSeed(seed, network);",
      "isPublic": true,
      "line": 269,
      "raw": "const root = bip32.fromSeed(seed, network);",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.child",
      "fullName": "bitcoin:wallets.embedded.index.ts.child",
      "name": "child",
      "type": "any",
      "value": "root.derivePath(path);",
      "isPublic": true,
      "line": 270,
      "raw": "const child = root.derivePath(path);",
      "source": "bitcoin"
    },
    {
      "key": "bitcoin:wallets.embedded.index.ts.publicKey",
      "fullName": "bitcoin:wallets.embedded.index.ts.publicKey",
      "name": "publicKey",
      "type": "any",
      "value": "Buffer.from(publicKeyHex, \"hex\");",
      "isPublic": true,
      "line": 309,
      "raw": "const publicKey = Buffer.from(publicKeyHex, \"hex\");",
      "source": "bitcoin"
    }
  ],
  "privateConstants": [],
  "stats": {
    "totalModules": 168,
    "totalFunctions": 492,
    "totalAtoms": 0,
    "totalTypes": 202,
    "totalPrivateTypes": 0,
    "totalConstants": 1194,
    "totalPrivateConstants": 0,
    "totalDependencies": 168,
    "sourceStats": {
      "mesh-core": {
        "modules": 0,
        "functions": 0,
        "atoms": 0,
        "types": 0,
        "privateTypes": 0,
        "constants": 0,
        "privateConstants": 0
      },
      "mesh-common": {
        "modules": 0,
        "functions": 0,
        "atoms": 0,
        "types": 0,
        "privateTypes": 0,
        "constants": 0,
        "privateConstants": 0
      },
      "mesh-provider": {
        "modules": 0,
        "functions": 0,
        "atoms": 0,
        "types": 0,
        "privateTypes": 0,
        "constants": 0,
        "privateConstants": 0
      },
      "mesh-contract": {
        "modules": 28,
        "functions": 23,
        "atoms": 0,
        "types": 16,
        "privateTypes": 0,
        "constants": 188,
        "privateConstants": 0
      },
      "mesh-transaction": {
        "modules": 14,
        "functions": 138,
        "atoms": 0,
        "types": 9,
        "privateTypes": 0,
        "constants": 322,
        "privateConstants": 0
      },
      "mesh-wallet": {
        "modules": 15,
        "functions": 28,
        "atoms": 0,
        "types": 15,
        "privateTypes": 0,
        "constants": 122,
        "privateConstants": 0
      },
      "mesh-hydra": {
        "modules": 15,
        "functions": 14,
        "atoms": 0,
        "types": 44,
        "privateTypes": 0,
        "constants": 29,
        "privateConstants": 0
      },
      "mesh-core-csl": {
        "modules": 48,
        "functions": 143,
        "atoms": 0,
        "types": 5,
        "privateTypes": 0,
        "constants": 284,
        "privateConstants": 0
      },
      "mesh-core-cst": {
        "modules": 26,
        "functions": 134,
        "atoms": 0,
        "types": 101,
        "privateTypes": 0,
        "constants": 484,
        "privateConstants": 0
      },
      "bitcoin": {
        "modules": 22,
        "functions": 18,
        "atoms": 0,
        "types": 12,
        "privateTypes": 0,
        "constants": 33,
        "privateConstants": 0
      },
      "stdlib": {
        "modules": 0,
        "functions": 0,
        "atoms": 0,
        "types": 0,
        "privateTypes": 0,
        "constants": 0,
        "privateConstants": 0
      },
      "prelude": {
        "modules": 0,
        "functions": 0,
        "atoms": 0,
        "types": 0,
        "privateTypes": 0,
        "constants": 0,
        "privateConstants": 0
      },
      "vodka": {
        "modules": 0,
        "functions": 0,
        "atoms": 0,
        "types": 0,
        "privateTypes": 0,
        "constants": 0,
        "privateConstants": 0
      },
      "anastasia": {
        "modules": 0,
        "functions": 0,
        "atoms": 0,
        "types": 0,
        "privateTypes": 0,
        "constants": 0,
        "privateConstants": 0
      }
    }
  }
}