{
  "modules": [
    {
      "key": "offchain:bitcoin.src.core",
      "name": "core",
      "source": "bitcoin",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:bitcoin.src.index",
      "name": "index",
      "source": "bitcoin",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.index",
      "name": "index",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-contract.src.common",
      "name": "common",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "MeshTxInitiatorInput",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/common\").MeshTxInitiatorInput",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/common.ts",
          "documentation": ""
        }
      ],
      "classes": [
        {
          "name": "MeshTxInitiator",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/common.ts",
          "extends": null,
          "implements": [],
          "methods": [],
          "properties": [
            {
              "name": "mesh",
              "type": "MeshTxBuilder",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetcher",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "wallet",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "stakeCredential",
              "type": "string | undefined",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "networkId",
              "type": "number",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "version",
              "type": "number",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "languageVersion",
              "type": "LanguageVersion",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getScriptAddress",
              "type": "(scriptCbor: string) => any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "signSubmitReset",
              "type": "() => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "queryUtxos",
              "type": "(walletAddress: string) => Promise<UTxO[]>",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getWalletDappAddress",
              "type": "() => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getWalletCollateral",
              "type": "() => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getWalletUtxosWithMinLovelace",
              "type": "(lovelace: number, providedUtxos?: UTxO[]) => Promise<UTxO[]>",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getWalletUtxosWithToken",
              "type": "(assetHex: string, userUtxos?: UTxO[]) => Promise<UTxO[]>",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getAddressUtxosWithMinLovelace",
              "type": "(walletAddress: string, lovelace: number, providedUtxos?: UTxO[]) => Promise<UTxO[]>",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getAddressUtxosWithToken",
              "type": "(walletAddress: string, assetHex: string, userUtxos?: UTxO[]) => Promise<UTxO[]>",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getWalletInfoForTx",
              "type": "() => Promise<{ utxos: any; collateral: any; walletAddress: any; }>",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "_getUtxoByTxHash",
              "type": "(txHash: string, scriptCbor?: string | undefined) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-contract.src.index",
      "name": "index",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core.src.core",
      "name": "core",
      "source": "mesh-core",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core.src.index",
      "name": "index",
      "source": "mesh-core",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.index",
      "name": "index",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.wasm",
      "name": "wasm",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.index",
      "name": "index",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-hydra.src.hydra-connection",
      "name": "hydra-connection",
      "source": "mesh-hydra",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "HydraConnection",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/hydra-connection.ts",
          "extends": "EventEmitter",
          "implements": [],
          "methods": [
            {
              "name": "connect",
              "signature": "async connect(): Promise<void> {\n    this._websocket = new WebSocket(this._websocketUrl);\n    if (!this._websocket) {\n      throw new Error(\"invalid url, websocket failed to connect\");\n    }\n    this._status = \"CONNECTING\";\n\n    this._websocket.onopen = () => {\n      this._connected = true;\n      this._status = \"CONNECTED\";\n      console.log(\"WebSocket connected successfully\");\n    };\n\n    this._websocket.onerror = (error) => {\n      console.error(\"Hydra error:\", error);\n      this._connected = false;\n    };\n\n    this._websocket.onclose = (code) => {\n      console.error(\"Hydra websocket closed\", code.code, code.reason);\n      this._status = \"CLOSED\";\n      this._connected = false;\n    };\n\n    this._websocket.onmessage = (data: MessageEvent) => {\n      const message = JSON.parse(data.data as string);\n      console.log(\"Received message from Hydra:\", message);\n      this._eventEmitter.emit(\"onmessage\", message);\n      this.processStatus(message);\n    };\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "send",
              "signature": "send(data: unknown): void {\n    const sendData = () => {\n      if (this._websocket?.readyState === WebSocket.OPEN) {\n        this._websocket.send(JSON.stringify(data));\n        return true;\n      }\n      return false;\n    };\n\n    const interval = setInterval(() => {\n      if (sendData()) {\n        clearInterval(interval);\n      }\n    }, 1000);\n\n    setTimeout(() => {\n      if (!sendData()) {\n        console.error(\"Failed to send data: WebSocket connection timeout.\");\n        clearInterval(interval);\n      }\n    }, 5000);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "disconnect",
              "signature": "async disconnect() {\n    if (this._status === \"IDLE\") {\n      return;\n    }\n    if (this._websocket && this._websocket.readyState === WebSocket.OPEN) {\n      this._websocket.close(1007);\n    }\n    this._status = \"IDLE\";\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "processStatus",
              "signature": "async processStatus(message: {}) {\n    let status: hStatus | null = null;\n    if ((status = hStatus(message)) && status !== null) {\n      this._status = status;\n      this._eventEmitter.emit(\"onstatuschange\", status);\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "_websocket",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "_status",
              "type": "\"IDLE\" | \"DISCONNECTED\" | \"CONNECTING\" | \"CONNECTED\" | \"INITIALIZING\" | \"OPEN\" | \"CLOSED\" | \"FANOUT_POSSIBLE\" | \"FINAL\"",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "_websocketUrl",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "_eventEmitter",
              "type": "import(\"events\")<DefaultEventMap>",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_connected",
              "type": "boolean",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-hydra.src.hydra-instance",
      "name": "hydra-instance",
      "source": "mesh-hydra",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "HydraInstance",
          "documentation": "todo: implement https://hydra.family/head-protocol/docs/tutorial/",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/hydra-instance.ts",
          "extends": null,
          "implements": [],
          "methods": [
            {
              "name": "commitFunds",
              "signature": "async commitFunds(txHash: string, txIndex: number): Promise<string> {\n    const utxo = (await this.fetcher.fetchUTxOs(txHash, txIndex))[0];\n    if (!utxo) {\n      throw new Error(\"UTxO not found\");\n    }\n    const hydraUtxo = {\n      address: utxo.output.address,\n      datum: null,\n      datumhash: null, // TODO: Handle datumHash case\n      referenceScript:\n        utxo.output.scriptRef === \"\" || !utxo.output.scriptRef\n          ? null\n          : utxo.output.scriptRef,\n      value: hAssets(utxo.output.amount),\n      inlineDatum: utxo.output.plutusData ? parseDatumCbor(utxo.output.plutusData) : null,\n      inlineDatumRaw: utxo.output.plutusData ?? null,\n    };\n    const commit = await this.provider.buildCommit(\n      {\n        [txHash + \"#\" + txIndex]: hydraUtxo,\n      },\n      {\n        \"Content-Type\": \"text/plain\",\n      }\n    );\n    console.log(commit);\n    return commit.cborHex;\n  }",
              "documentation": "To commit funds to the head, choose which UTxO you would like to make available on layer 2.\nThe function returns the transaction, ready to be signed by the user.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "commitBlueprint",
              "signature": "async commitBlueprint() {\n    return \"txhash\";\n  }",
              "documentation": "https://hydra.family/head-protocol/docs/how-to/commit-blueprint/.\nA Cardano transaction in the text envelope format. \nThat is, a JSON object wrapper with some 'type' around a 'cborHex' encoded transaction.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "incrementalCommit",
              "signature": "async incrementalCommit() {\n    return \"txHash\";\n  }",
              "documentation": "TO DO\nhttps://hydra.family/head-protocol/unstable/docs/how-to/incremental-commit\n\nIf you don't want to commit any funds and only want to receive on layer two, you can request an empty commit transaction.:",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "incrementalDecommit",
              "signature": "async incrementalDecommit() {\n    return \"txHash\";\n  }",
              "documentation": "https://hydra.family/head-protocol/docs/how-to/incremental-decommit",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "provider",
              "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/hydra-provider\").HydraProvider",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetcher",
              "type": "IFetcher",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "submitter",
              "type": "ISubmitter",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-hydra.src.hydra-provider.test",
      "name": "hydra-provider.test",
      "source": "mesh-hydra",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-hydra.src.hydra-provider",
      "name": "hydra-provider",
      "source": "mesh-hydra",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "HydraProvider",
          "documentation": "HydraProvider is a tool for administrating & interacting with Hydra Heads.\n\nUsage:\n```\nimport { HydraProvider } from \"@meshsdk/hydra\";\n\nconst hydraProvider = new HydraProvider({url:'http://123.45.67.890:4001'});",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/hydra-provider.ts",
          "extends": null,
          "implements": [
            "IFetcher",
            "ISubmitter"
          ],
          "methods": [
            {
              "name": "connect",
              "signature": "async connect() {\n    if (this._status !== \"DISCONNECTED\") {\n      return;\n    }\n    this._connection.connect();\n    this._status = \"CONNECTED\";\n  }",
              "documentation": "Connects to the Hydra Head. This command is a no-op when a Head is already open.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressUTxOs",
              "signature": "async fetchAddressUTxOs(address: string): Promise<UTxO[]> {\n    const utxos = await this.fetchUTxOs();\n    return utxos.filter((utxo) => utxo.output.address === address);\n  }",
              "documentation": "FETCHERS and SUBMITTERS\nUTXOs of the address.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchProtocolParameters",
              "signature": "async fetchProtocolParameters(epoch = Number.NaN): Promise<Protocol> {\n    return await this.subscribeProtocolParameters();\n  }",
              "documentation": "Fetch the latest protocol parameters.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchUTxOs",
              "signature": "async fetchUTxOs(hash?: string, index?: number): Promise<UTxO[]> {\n    const snapshotUTxOs = await this.subscribeSnapshotUtxo();\n\n    const outputsPromises: Promise<UTxO>[] = [];\n    snapshotUTxOs.forEach((utxo) => {\n      if (hash === undefined || utxo.input.txHash === hash) {\n        outputsPromises.push(Promise.resolve(utxo));\n      }\n    });\n    const outputs = await Promise.all(outputsPromises);\n\n    if (index !== undefined) {\n      return outputs.filter((utxo) => utxo.input.outputIndex === index);\n    }\n\n    return outputs;\n  }",
              "documentation": "Get UTxOs for a given hash.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "submitTx",
              "signature": "async submitTx(tx: string): Promise<string> {\n    try {\n      await this.newTx(tx, \"Witnessed Tx ConwayEra\");\n      const txId = await new Promise<string>((resolve) => {\n        this.onMessage((message) => {\n          if (message.tag === \"TxValid\") {\n            if (message.transaction && message.transaction.cborHex === tx) {\n              resolve(message.transaction.txId!);\n            }\n          }\n          if (message.tag === \"TxInvalid\") {\n            if (message.transaction && message.transaction.cborHex === tx) {\n              throw JSON.stringify(message.validationError);\n            }\n          }\n        });\n      });\n      return txId;\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Submit a transaction to the Hydra node. Note, unlike other providers, Hydra does not return a transaction hash.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "init",
              "signature": "async init() {\n    this._connection.send({ tag: \"Init\" });\n  }",
              "documentation": "Commands sent to the Hydra node.\n\nAccepts one of the following commands:\n- Init: init()\n- Abort: abort()\n- NewTx: newTx()\n- Decommit: decommit()\n- Close: close()\n- Contest: contest()\n- Fanout: fanout()\nInitializes a new Head. This command is a no-op when a Head is already open and the server will output an CommandFailed message should this happen.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "abort",
              "signature": "async abort() {\n    this._connection.send({ tag: \"Abort\" });\n  }",
              "documentation": "Aborts a head before it is opened. This can only be done before all participants have committed. Once opened, the head can't be aborted anymore but it can be closed using: `Close`.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "newTx",
              "signature": "async newTx(\n    cborHex: string,\n    type:\n      | \"Tx ConwayEra\"\n      | \"Unwitnessed Tx ConwayEra\"\n      | \"Witnessed Tx ConwayEra\",\n    description = \"\",\n    txId?: string\n  ) {\n    const transaction: hTransaction = {\n      type: type,\n      description: description,\n      cborHex: cborHex,\n      txId: txId,\n    };\n    const payload = {\n      tag: \"NewTx\",\n      transaction: transaction,\n    };\n    this._connection.send(payload);\n  }",
              "documentation": "Submit a transaction through the head. Note that the transaction is only broadcast if well-formed and valid.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "decommit",
              "signature": "async decommit(\n    cborHex: string,\n    type:\n      | \"Tx ConwayEra\"\n      | \"Unwitnessed Tx ConwayEra\"\n      | \"Witnessed Tx ConwayEra\",\n    description: string\n  ) {\n    const payload = {\n      tag: \"Decommit\",\n      decommitTx: {\n        type: type,\n        description: description,\n        cborHex: cborHex,\n      },\n    };\n    this._connection.send(payload);\n  }",
              "documentation": "Request to decommit a UTxO from a Head by providing a decommit tx. Upon reaching consensus, this will eventually result in corresponding transaction outputs becoming available on the layer 1.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "close",
              "signature": "async close() {\n    this.onStatusChange((status) => {\n      console.log(\"close status\", status);\n      if (status === \"OPEN\") {\n        this._connection.send({ tag: \"Close\" });\n      }\n    });\n  }",
              "documentation": "Terminate a head with the latest known snapshot. This effectively moves the head from the Open state to the Close state where the contestation phase begin. As a result of closing a head, no more transactions can be submitted via NewTx.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "contest",
              "signature": "async contest() {\n    this._connection.send({ tag: \"Contest\" });\n  }",
              "documentation": "Challenge the latest snapshot announced as a result of a head closure from another participant. Note that this necessarily contest with the latest snapshot known of your local Hydra node. Participants can only contest once.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fanout",
              "signature": "async fanout() {\n    this.onStatusChange((status) => {\n      console.log(\"status last\", status);\n      if (status === \"FANOUT_POSSIBLE\") {\n        this._connection.send({ tag: \"Fanout\" });\n      }\n    });\n  }",
              "documentation": "Finalize a head after the contestation period passed. This will distribute the final (as closed and maybe contested) head state back on the layer 1.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "buildCommit",
              "signature": "async buildCommit(payload: unknown, headers: RawAxiosRequestHeaders = {}) {\n    const txHex = await this.post(\"/commit\", payload, headers);\n    return txHex;\n  }",
              "documentation": "OPERATIONS\nDraft a commit transaction, which can be completed and later submitted to the L1 network.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "subscribeCommit",
              "signature": "async subscribeCommit() {\n    // todo\n    await this.get(\"/commit\");\n  }",
              "documentation": "Emitted by the server after drafting a commit transaction with the user provided utxos. Transaction returned to the user is in it's cbor representation encoded as Base16.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "buildCommits",
              "signature": "async buildCommits() {\n    const commits = await this.get(\"/commits\");\n    return commits;\n  }",
              "documentation": "Obtain a list of pending deposit transaction ID's.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "subscribeCommits",
              "signature": "async subscribeCommits() {\n    // todo\n    await this.get(\"/commits\");\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "commitsTxId",
              "signature": "async commitsTxId(headers: RawAxiosRequestHeaders = {}) {\n    // todo\n    await this.post(\"/commits/tx-id\", {}, headers);\n  }",
              "documentation": "Recover deposited UTxO by providing a TxId of a deposit transaction in the request path.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "subscribeCommitsTxId",
              "signature": "async subscribeCommitsTxId() {\n    // todo\n    await this.get(\"/commits/tx-id\");\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "subscribeSnapshotUtxo",
              "signature": "async subscribeSnapshotUtxo(): Promise<UTxO[]> {\n    const data = await this.get(`snapshot/utxo`);\n    const utxos: UTxO[] = [];\n    for (const [key, value] of Object.entries(data)) {\n      const utxo = hUTxO.toUTxO(value as hUTxO, key);\n      utxos.push(utxo);\n    }\n    return utxos;\n  }",
              "documentation": "A set of unspent transaction outputs.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "publishDecommit",
              "signature": "async publishDecommit(headers: RawAxiosRequestHeaders = {}) {\n    // todo\n    await this.post(\"/decommit\", {}, headers);\n  }",
              "documentation": "Provide decommit transaction that needs to be applicable to the Hydra's local ledger state. Specified transaction outputs will be available on layer 1 after decommit is successfully processed.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "subscribeDecommit",
              "signature": "async subscribeDecommit() {\n    // todo\n    await this.get(\"/decommit\");\n  }",
              "documentation": "Emitted by the server after drafting a decommit transaction.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "subscribeProtocolParameters",
              "signature": "async subscribeProtocolParameters(): Promise<Protocol> {\n    const data = await this.get(\"protocol-parameters\");\n\n    const protocolParams = castProtocol({\n      coinsPerUtxoSize: data.utxoCostPerByte,\n      collateralPercent: data.collateralPercentage,\n      maxBlockExMem: data.maxBlockExecutionUnits.memory,\n      maxBlockExSteps: data.maxBlockExecutionUnits.steps,\n      maxBlockHeaderSize: data.maxBlockHeaderSize,\n      maxBlockSize: data.maxBlockBodySize,\n      maxCollateralInputs: data.maxCollateralInputs,\n      maxTxExMem: data.maxTxExecutionUnits.memory,\n      maxTxExSteps: data.maxTxExecutionUnits.steps,\n      maxTxSize: data.maxTxSize,\n      maxValSize: data.maxValueSize,\n      minFeeA: data.txFeePerByte,\n      minFeeB: data.txFeeFixed,\n      minPoolCost: data.minPoolCost,\n      poolDeposit: data.stakePoolDeposit,\n      priceMem: data.executionUnitPrices.priceMemory,\n      priceStep: data.executionUnitPrices.priceSteps,\n    });\n\n    return protocolParams;\n  }",
              "documentation": "Get protocol parameters.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "publishCardanoTransaction",
              "signature": "async publishCardanoTransaction(headers: RawAxiosRequestHeaders = {}) {\n    // todo\n    await this.post(\"/cardano-transaction\", {}, headers);\n  }",
              "documentation": "Cardano transaction to be submitted to the L1 network. Accepts transactions encoded as Base16 CBOR string, TextEnvelope type or JSON.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "subscribeCardanoTransaction",
              "signature": "async subscribeCardanoTransaction() {\n    // todo\n    await this.get(\"/cardano-transaction\");\n  }",
              "documentation": "Successfully submitted a cardano transaction to the L1 network.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "onMessage",
              "signature": "onMessage(\n    callback: (\n      data:\n        | Greetings\n        | PeerConnected\n        | PeerDisconnected\n        | PeerHandshakeFailure\n        | HeadIsInitializing\n        | Committed\n        | HeadIsOpen\n        | HeadIsClosed\n        | HeadIsContested\n        | ReadyToFanout\n        | HeadIsAborted\n        | HeadIsFinalized\n        | TxValid\n        | TxInvalid\n        | SnapshotConfirmed\n        | GetUTxOResponse\n        | InvalidInput\n        | PostTxOnChainFailed\n        | CommandFailed\n        | IgnoredHeadInitializing\n        | DecommitInvalid\n        | DecommitRequested\n        | DecommitApproved\n        | DecommitFinalized\n    ) => void\n  ) {\n    this._eventEmitter.on(\"onmessage\", (message) => {\n      switch (message.tag) {\n        case \"Greetings\":\n          callback(message as Greetings);\n          break;\n        case \"PeerConnected\":\n          callback(message as PeerConnected);\n          break;\n        case \"onPeerDisconnected\":\n          callback(message as PeerDisconnected);\n          break;\n        case \"PeerHandshakeFailure\":\n          callback(message as PeerHandshakeFailure);\n          break;\n        case \"HeadIsInitializing\":\n          callback(message as HeadIsInitializing);\n          break;\n        case \"Committed\":\n          callback(message as Committed);\n          break;\n        case \"HeadIsOpen\":\n          callback(message as HeadIsOpen);\n          break;\n        case \"HeadIsClosed\":\n          callback(message as HeadIsClosed);\n          break;\n        case \"HeadIsContested\":\n          callback(message as HeadIsContested);\n          break;\n        case \"ReadyToFanout\":\n          callback(message as ReadyToFanout);\n          break;\n        case \"HeadIsAborted\":\n          callback(message as HeadIsAborted);\n          break;\n        case \"HeadIsFinalized\":\n          callback(message as HeadIsFinalized);\n          break;\n        case \"TxValid\":\n          callback(message as TxValid);\n          break;\n        case \"TxInvalid\":\n          callback(message as TxInvalid);\n          break;\n        case \"SnapshotConfirmed\":\n          callback(message as SnapshotConfirmed);\n          break;\n        case \"GetUTxOResponse\":\n          callback(message as GetUTxOResponse);\n          break;\n        case \"InvalidInput\":\n          callback(message as InvalidInput);\n          break;\n        case \"PostTxOnChainFailed\":\n          callback(message as PostTxOnChainFailed);\n          break;\n        case \"CommandFailed\":\n          callback(message as CommandFailed);\n          break;\n        case \"IgnoredHeadInitializing\":\n          callback(message as IgnoredHeadInitializing);\n          break;\n        case \"DecommitInvalid\":\n          callback(message as DecommitInvalid);\n          break;\n        case \"DecommitRequested\":\n          callback(message as DecommitRequested);\n          break;\n        case \"DecommitApproved\":\n          callback(message as DecommitApproved);\n          break;\n        case \"DecommitFinalized\":\n          callback(message as DecommitFinalized);\n          break;\n        default:\n          break;\n      }\n    });\n  }",
              "documentation": "Events emitted by the Hydra node.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "onStatusChange",
              "signature": "onStatusChange(callback: (status: hStatus) => void) {\n    this._eventEmitter.on(\"onstatuschange\", callback);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "get",
              "signature": "async get(url: string): Promise<any> {\n    try {\n      const { data, status } = await this._axiosInstance.get(url);\n      if (status === 200 || status == 202) {\n        return data;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Useful utility functions.\nA generic method to fetch data from a URL.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "post",
              "signature": "async post(\n    url: string,\n    payload: unknown,\n    headers: RawAxiosRequestHeaders\n  ): Promise<any> {\n    try {\n      const { data, status } = await this._axiosInstance.post(url, payload, {\n        headers,\n      });\n      if (status === 200 || status == 202) {\n        return data;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "A generic method to post data to a URL.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAccountInfo",
              "signature": "fetchAccountInfo(address: string): Promise<AccountInfo> {\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "NOT IMPLEMENTED FETCHERS",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressTxs",
              "signature": "async fetchAddressTxs(\n    address: string,\n    options: IFetcherOptions = DEFAULT_FETCHER_OPTIONS\n  ): Promise<TransactionInfo[]> {\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAssetAddresses",
              "signature": "fetchAssetAddresses(\n    asset: string\n  ): Promise<{ address: string; quantity: string }[]> {\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAssetMetadata",
              "signature": "fetchAssetMetadata(asset: string): Promise<AssetMetadata> {\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchBlockInfo",
              "signature": "fetchBlockInfo(hash: string): Promise<BlockInfo> {\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchCollectionAssets",
              "signature": "fetchCollectionAssets(\n    policyId: string,\n    cursor?: string | number | undefined\n  ): Promise<{ assets: Asset[]; next: string | number | null }> {\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchGovernanceProposal",
              "signature": "async fetchGovernanceProposal(\n    txHash: string,\n    certIndex: number\n  ): Promise<GovernanceProposalInfo> {\n    throw new Error(\"Method not implemented\");\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchTxInfo",
              "signature": "fetchTxInfo(hash: string): Promise<TransactionInfo> {\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "_connection",
              "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/hydra-connection\").HydraConnection",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_status",
              "type": "\"IDLE\" | \"DISCONNECTED\" | \"CONNECTING\" | \"CONNECTED\" | \"INITIALIZING\" | \"OPEN\" | \"CLOSED\" | \"FANOUT_POSSIBLE\" | \"FINAL\"",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_eventEmitter",
              "type": "import(\"events\")<DefaultEventMap>",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_axiosInstance",
              "type": "AxiosInstance",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-hydra.src.index",
      "name": "index",
      "source": "mesh-hydra",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-provider.src.begin",
      "name": "begin",
      "source": "mesh-provider",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "BeginProvider",
          "documentation": "The BeginProvider class provides methods to query Begin ID.\n\nTo use this provider, simply create a new instance of the BeginProvider class and call the desired method.\n\n```typescript\nimport { BeginProvider } from \"@meshsdk/core\";\n\nconst beginProvider = new BeginProvider();\n```",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/begin.ts",
          "extends": null,
          "implements": [],
          "methods": [
            {
              "name": "resolveAddress",
              "signature": "async resolveAddress(\n    name: string,\n    url?: string,\n  ): Promise<{\n    name: string;\n    domain: string;\n    image: string;\n    address: string;\n  }> {\n    try {\n      const axiosInstance = axios.create({\n        baseURL: url ?? \"https://resolveidaddress-ylo5dtxzdq-uc.a.run.app\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: this.apikey,\n        },\n      });\n\n      const { data, status } = await axiosInstance.post(``, {\n        name: name\n          .replace(\"@\", \"\")\n          .replace(/(\\.bgin\\.id|\\.beginid\\.io|\\.bgn\\.is)$/, \"\"),\n        chain: this.chainNumber,\n      });\n\n      if (status === 200) {\n        const result = data.result;\n        return {\n          name: result.name,\n          domain: `${\"\".concat(result.name, this.domainUrl)}`,\n          image: result.image,\n          address: result.addresses[this.chainNumber],\n        };\n      }\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Given a Begin ID, resolves the address and other information.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "resolveAdressReverse",
              "signature": "async resolveAdressReverse(\n    address: string,\n    url?: string,\n  ): Promise<{\n    name: string;\n    domain: string;\n    image: string;\n    address: string;\n  }> {\n    try {\n      const axiosInstance = axios.create({\n        baseURL:\n          url ?? \"https://resolveIdReserveAddress-ylo5dtxzdq-uc.a.run.app\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: this.apikey,\n        },\n      });\n\n      const { data, status } = await axiosInstance.post(``, {\n        address: address,\n        chain: this.chainNumber,\n      });\n\n      if (status === 200) {\n        const result = data.result;\n        return {\n          name: result.name,\n          domain: `${\"\".concat(result.name, this.domainUrl)}`,\n          image: result.image,\n          address: result.addresses[this.chainNumber],\n        };\n      }\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Given an address, resolves the Begin ID and other information.",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "apikey",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "chainNumber",
              "type": "1815",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "domainUrl",
              "type": "\".bgin.id\"",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-provider.src.blockfrost",
      "name": "blockfrost",
      "source": "mesh-provider",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "BlockfrostCachingOptions",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/blockfrost\").BlockfrostCachingOptions",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/blockfrost.ts",
          "documentation": ""
        },
        {
          "name": "BlockfrostSupportedNetworks",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/blockfrost\").BlockfrostSupportedNetworks",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/blockfrost.ts",
          "documentation": ""
        }
      ],
      "classes": [
        {
          "name": "BlockfrostProvider",
          "documentation": "Blockfrost provides restful APIs which allows your app to access information stored on the blockchain.\n\nUsage:\n```\nimport { BlockfrostProvider } from \"@meshsdk/core\";\n\nconst provider = new BlockfrostProvider('<Your-API-Key>');\n\n// With caching enabled\nconst providerWithCache = new BlockfrostProvider('<Your-API-Key>', 0, { enableCaching: true });\n```",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/blockfrost.ts",
          "extends": null,
          "implements": [
            "IFetcher",
            "IListener",
            "ISubmitter",
            "IEvaluator"
          ],
          "methods": [
            {
              "name": "evaluateTx",
              "signature": "async evaluateTx(cbor: string): Promise<Omit<Action, \"data\">[]> {\n    try {\n      const headers = { \"Content-Type\": \"application/cbor\" };\n      const { status, data } = await this._axiosInstance.post(\n        \"utils/txs/evaluate\",\n        cbor,\n        {\n          headers,\n        },\n      );\n\n      if (status === 200 && data.result.EvaluationResult) {\n        const tagMap: { [key: string]: RedeemerTagType } = {\n          spend: \"SPEND\",\n          mint: \"MINT\",\n          certificate: \"CERT\",\n          withdrawal: \"REWARD\",\n        };\n        const result: Omit<Action, \"data\">[] = [];\n\n        Object.keys(data.result.EvaluationResult).forEach((key) => {\n          const [tagKey, index] = key.split(\":\");\n          const { memory, steps } = data.result.EvaluationResult[key];\n          result.push({\n            tag: tagMap[tagKey!]!,\n            index: Number(index),\n            budget: { mem: memory, steps },\n          });\n        });\n\n        return result;\n      }\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Evaluates the resources required to execute the transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAccountInfo",
              "signature": "async fetchAccountInfo(address: string): Promise<AccountInfo> {\n    const rewardAddress = address.startsWith(\"addr\")\n      ? resolveRewardAddress(address)\n      : address;\n\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `accounts/${rewardAddress}`,\n      );\n\n      if (status === 200 || status == 202)\n        return <AccountInfo>{\n          poolId: data.pool_id,\n          active: data.active || data.active_epoch !== null,\n          balance: data.controlled_amount,\n          rewards: data.withdrawable_amount,\n          withdrawals: data.withdrawals_sum,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Obtain information about a specific stake account.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressAssets",
              "signature": "async fetchAddressAssets(\n    address: string,\n  ): Promise<{ [key: string]: string }> {\n    const utxos = await this.fetchAddressUTxOs(address);\n    return utxosToAssets(utxos);\n  }",
              "documentation": "Fetches the assets for a given address.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressTxs",
              "signature": "async fetchAddressTxs(\n    address: string,\n    option: IFetcherOptions = DEFAULT_FETCHER_OPTIONS,\n  ): Promise<TransactionInfo[]> {\n    const txs: TransactionInfo[] = [];\n    try {\n      const fetcherOptions = { ...DEFAULT_FETCHER_OPTIONS, ...option };\n\n      for (let i = 1; i <= fetcherOptions.maxPage!; i++) {\n        let { data, status } = await this._axiosInstance.get(\n          `/addresses/${address}/transactions?page=${i}&order=${fetcherOptions.order}`,\n        );\n        if (status !== 200) throw parseHttpError(data);\n        if (data.length === 0) break;\n        for (const tx of data) {\n          const txInfo = await this.fetchTxInfo(tx.tx_hash);\n\n          const _tx = {\n            ...txInfo,\n            blockHeight: tx.block_height,\n            blockTime: tx.block_time,\n          };\n\n          txs.push(_tx);\n        }\n      }\n      return txs;\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Transactions for an address. The `TransactionInfo` would only return the `hash`, `inputs`, and `outputs`.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressTransactions",
              "signature": "async fetchAddressTransactions(address: string): Promise<TransactionInfo[]> {\n    return await this.fetchAddressTxs(address);\n  }",
              "documentation": "Deprecated, use fetchAddressTxs instead",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressUTxOs",
              "signature": "async fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]> {\n    // Check cache first if caching is enabled\n    if (this._enableCaching && this._offlineFetcher) {\n      try {\n        const cachedUtxos = await this._offlineFetcher.fetchAddressUTxOs(address, asset);\n        if (cachedUtxos.length > 0) {\n          return cachedUtxos;\n        }\n      } catch (error) {\n        // Cache miss or error, continue to fetch from network\n      }\n    }\n\n    const filter = asset !== undefined ? `/${asset}` : \"\";\n    const url = `addresses/${address}/utxos` + filter;\n\n    const paginateUTxOs = async (\n      page = 1,\n      utxos: UTxO[] = [],\n    ): Promise<UTxO[]> => {\n      const { data, status } = await this._axiosInstance.get(\n        `${url}?page=${page}`,\n      );\n\n      if (status === 200 || status == 202)\n        return data.length > 0\n          ? paginateUTxOs(page + 1, [\n              ...utxos,\n              ...(await Promise.all(\n                data.map((utxo: BlockfrostUTxO) =>\n                  this.toUTxO(utxo, utxo.tx_hash),\n                ),\n              )),\n            ])\n          : utxos;\n\n      throw parseHttpError(data);\n    };\n\n    try {\n      const fetchedUtxos = await paginateUTxOs();\n      \n      // Cache the fetched UTXOs if caching is enabled\n      if (this._enableCaching && this._offlineFetcher && fetchedUtxos.length > 0) {\n        try {\n          this._offlineFetcher.addUTxOs(fetchedUtxos);\n        } catch (error) {\n          // Log error but don't fail the request\n          console.warn(\"Failed to cache UTXOs:\", error);\n        }\n      }\n      \n      return fetchedUtxos;\n    } catch (error) {\n      return [];\n    }\n  }",
              "documentation": "UTXOs of the address.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAssetAddresses",
              "signature": "async fetchAssetAddresses(\n    asset: string,\n  ): Promise<{ address: string; quantity: string }[]> {\n    const paginateAddresses = async <T>(\n      page = 1,\n      addresses: T[] = [],\n    ): Promise<T[]> => {\n      const { policyId, assetName } = parseAssetUnit(asset);\n      const { data, status } = await this._axiosInstance.get(\n        `assets/${policyId}${assetName}/addresses?page=${page}`,\n      );\n\n      if (status === 200 || status == 202)\n        return data.length > 0\n          ? paginateAddresses(page + 1, [...addresses, ...data])\n          : addresses;\n\n      throw parseHttpError(data);\n    };\n\n    try {\n      return await paginateAddresses<{ address: string; quantity: string }>();\n    } catch (error) {\n      return [];\n    }\n  }",
              "documentation": "Fetches the asset addresses for a given asset.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAssetMetadata",
              "signature": "async fetchAssetMetadata(asset: string): Promise<AssetMetadata> {\n    try {\n      const { policyId, assetName } = parseAssetUnit(asset);\n      const { data, status } = await this._axiosInstance.get(\n        `assets/${policyId}${assetName}`,\n      );\n      if (status === 200 || status == 202)\n        return <AssetMetadata>{\n          ...data.onchain_metadata,\n          fingerprint: data.fingerprint,\n          totalSupply: data.quantity,\n          mintingTxHash: data.initial_mint_tx_hash, // todo: request for `initial_mint_tx_hash`\n          mintCount: data.mint_or_burn_count,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetches the metadata for a given asset.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchLatestBlock",
              "signature": "async fetchLatestBlock(): Promise<BlockInfo> {\n    try {\n      const { data, status } = await this._axiosInstance.get(`blocks/latest`);\n\n      if (status === 200 || status == 202)\n        return <BlockInfo>{\n          confirmations: data.confirmations,\n          epoch: data.epoch,\n          epochSlot: data.epoch_slot.toString(),\n          fees: data.fees,\n          hash: data.hash,\n          nextBlock: data.next_block ?? \"\",\n          operationalCertificate: data.op_cert,\n          output: data.output ?? \"0\",\n          previousBlock: data.previous_block,\n          size: data.size,\n          slot: data.slot.toString(),\n          slotLeader: data.slot_leader ?? \"\",\n          time: data.time,\n          txCount: data.tx_count,\n          VRFKey: data.block_vrf,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetches the metadata for a given asset.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchBlockInfo",
              "signature": "async fetchBlockInfo(hash: string): Promise<BlockInfo> {\n    try {\n      const { data, status } = await this._axiosInstance.get(`blocks/${hash}`);\n\n      if (status === 200 || status == 202)\n        return <BlockInfo>{\n          confirmations: data.confirmations,\n          epoch: data.epoch,\n          epochSlot: data.epoch_slot.toString(),\n          fees: data.fees,\n          hash: data.hash,\n          nextBlock: data.next_block ?? \"\",\n          operationalCertificate: data.op_cert,\n          output: data.output ?? \"0\",\n          previousBlock: data.previous_block,\n          size: data.size,\n          slot: data.slot.toString(),\n          slotLeader: data.slot_leader ?? \"\",\n          time: data.time,\n          txCount: data.tx_count,\n          VRFKey: data.block_vrf,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetches the block information for a given block hash.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchCollectionAssets",
              "signature": "async fetchCollectionAssets(\n    policyId: string,\n    cursor = 1,\n  ): Promise<{ assets: Asset[]; next: string | number | null }> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `assets/policy/${policyId}?page=${cursor}`,\n      );\n\n      if (status === 200 || status == 202)\n        return {\n          assets: data.map((asset: BlockfrostAsset) => ({\n            unit: asset.asset,\n            quantity: asset.quantity,\n          })),\n          next: data.length === 100 ? cursor + 1 : null,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      return { assets: [], next: null };\n    }\n  }",
              "documentation": "Fetches the list of assets for a given policy ID.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchHandle",
              "signature": "async fetchHandle(handle: string): Promise<AssetMetadata> {\n    if (this._network !== \"mainnet\") {\n      throw new Error(\n        \"Does not support fetching addresses by handle on non-mainnet networks.\",\n      );\n    }\n    try {\n      const assetName = fromUTF8(`${handle.replace(\"$\", \"\")}`);\n      const asset = await this.fetchAssetMetadata(\n        `${SUPPORTED_HANDLES[1]}000de140${assetName}`,\n      );\n      return asset;\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchHandleAddress",
              "signature": "async fetchHandleAddress(handle: string): Promise<string> {\n    if (this._network !== \"mainnet\") {\n      throw new Error(\n        \"Does not support fetching addresses by handle on non-mainnet networks.\",\n      );\n    }\n    try {\n      const assetName = fromUTF8(handle.replace(\"$\", \"\"));\n      const { data, status } = await this._axiosInstance.get(\n        `assets/${SUPPORTED_HANDLES[1]}${assetName}/addresses`,\n      );\n\n      if (status === 200 || status == 202) return data[0].address;\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchProtocolParameters",
              "signature": "async fetchProtocolParameters(epoch = Number.NaN): Promise<Protocol> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `epochs/${isNaN(epoch) ? \"latest\" : epoch}/parameters`,\n      );\n\n      if (status === 200 || status == 202)\n        return castProtocol({\n          coinsPerUtxoSize: data.coins_per_utxo_word,\n          collateralPercent: data.collateral_percent,\n          decentralisation: data.decentralisation_param,\n          epoch: data.epoch,\n          keyDeposit: data.key_deposit,\n          maxBlockExMem: data.max_block_ex_mem,\n          maxBlockExSteps: data.max_block_ex_steps,\n          maxBlockHeaderSize: data.max_block_header_size,\n          maxBlockSize: data.max_block_size,\n          maxCollateralInputs: data.max_collateral_inputs,\n          maxTxExMem: data.max_tx_ex_mem,\n          maxTxExSteps: data.max_tx_ex_steps,\n          maxTxSize: data.max_tx_size,\n          maxValSize: data.max_val_size,\n          minFeeA: data.min_fee_a,\n          minFeeB: data.min_fee_b,\n          minPoolCost: data.min_pool_cost,\n          poolDeposit: data.pool_deposit,\n          priceMem: data.price_mem,\n          priceStep: data.price_step,\n        });\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetch the latest protocol parameters.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchTxInfo",
              "signature": "async fetchTxInfo(hash: string): Promise<TransactionInfo> {\n    try {\n      const { data: txData, status } = await this._axiosInstance.get(\n        `txs/${hash}`,\n      );\n      if (status === 200 || status == 202) {\n        const { data, status } = await this._axiosInstance.get(\n          `/txs/${txData.hash}/utxos`,\n        );\n        if (status !== 200) throw parseHttpError(data);\n        return <TransactionInfo>{\n          block: txData.block,\n          deposit: txData.deposit,\n          fees: txData.fees,\n          hash: txData.hash,\n          index: txData.index,\n          invalidAfter: txData.invalid_hereafter ?? \"\",\n          invalidBefore: txData.invalid_before ?? \"\",\n          slot: txData.slot.toString(),\n          size: txData.size,\n          inputs: data.inputs,\n          outputs: data.outputs,\n        };\n      }\n\n      throw parseHttpError(txData);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetches the transaction information for a given transaction hash.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchUTxOs",
              "signature": "async fetchUTxOs(hash: string, index?: number): Promise<UTxO[]> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `txs/${hash}/utxos`,\n      );\n      if (status === 200 || status == 202) {\n        const bfOutputs = data.outputs as BlockfrostUTxO[];\n        const outputsPromises: Promise<UTxO>[] = [];\n        bfOutputs.forEach((output) => {\n          outputsPromises.push(this.toUTxO(output, hash));\n        });\n        const outputs = await Promise.all(outputsPromises);\n\n        if (index !== undefined) {\n          return outputs.filter((utxo) => utxo.input.outputIndex === index);\n        }\n\n        return outputs;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Get UTxOs for a given hash.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchGovernanceProposal",
              "signature": "async fetchGovernanceProposal(\n    txHash: string,\n    certIndex: number,\n  ): Promise<GovernanceProposalInfo> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `governance/proposals/${txHash}/${certIndex}`,\n      );\n      if (status === 200 || status == 202)\n        return <GovernanceProposalInfo>{\n          txHash: data.tx_hash,\n          certIndex: data.cert_index,\n          governanceType: data.governance_type,\n          deposit: data.deposit,\n          returnAddress: data.return_address,\n          governanceDescription: data.governance_description,\n          ratifiedEpoch: data.ratified_epoch,\n          enactedEpoch: data.enacted_epoch,\n          droppedEpoch: data.dropped_epoch,\n          expiredEpoch: data.expired_epoch,\n          expiration: data.expiration,\n          metadata: (\n            await this._axiosInstance.get(\n              `governance/proposals/${txHash}/${certIndex}/metadata`,\n            )\n          ).data,\n        };\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetches the governance proposal information.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "get",
              "signature": "async get(url: string): Promise<any> {\n    try {\n      const { data, status } = await this._axiosInstance.get(url);\n      if (status === 200 || status == 202) {\n        return data;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "A generic method to fetch data from a URL.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "post",
              "signature": "async post(\n    url: string,\n    body: any,\n    headers = { \"Content-Type\": \"application/json\" },\n  ): Promise<any> {\n    try {\n      const { data, status } = await this._axiosInstance.post(url, body, {\n        headers,\n      });\n\n      if (status === 200 || status == 202) return data;\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "A generic method to post data to a URL.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "onTxConfirmed",
              "signature": "onTxConfirmed(txHash: string, callback: () => void, limit = 100): void {\n    let attempts = 0;\n\n    const checkTx = setInterval(() => {\n      if (attempts >= limit) clearInterval(checkTx);\n\n      this.fetchTxInfo(txHash)\n        .then((txInfo) => {\n          this.fetchBlockInfo(txInfo.block)\n            .then((blockInfo) => {\n              if (blockInfo?.confirmations > 0) {\n                clearInterval(checkTx);\n                callback();\n              }\n            })\n            .catch(() => {\n              attempts += 1;\n            });\n        })\n        .catch(() => {\n          attempts += 1;\n        });\n    }, 5_000);\n  }",
              "documentation": "Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "setSubmitTxToBytes",
              "signature": "setSubmitTxToBytes(value: boolean): void {\n    this.submitTxToBytes = value;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "submitTx",
              "signature": "async submitTx(tx: string): Promise<string> {\n    try {\n      const headers = { \"Content-Type\": \"application/cbor\" };\n      const { data, status } = await this._axiosInstance.post(\n        \"tx/submit\",\n        this.submitTxToBytes ? toBytes(tx) : tx,\n        { headers },\n      );\n\n      if (status === 200 || status == 202) {\n        // Cache the submitted transaction if caching is enabled\n        if (this._enableCaching && this._offlineFetcher) {\n          try {\n            this._offlineFetcher.addSerializedTransaction(tx);\n          } catch (error) {\n            // Log error but don't fail the request\n            console.warn(\"Failed to cache submitted transaction:\", error);\n          }\n        }\n        \n        return data;\n      }\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Submit a serialized transaction to the network.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchPlutusScriptCBOR",
              "signature": "private async fetchPlutusScriptCBOR(scriptHash: string): Promise<string> {\n    const { data, status } = await this._axiosInstance.get(\n      `scripts/${scriptHash}/cbor`,\n    );\n\n    if (status === 200 || status == 202) return data.cbor;\n\n    throw parseHttpError(data);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "fetchNativeScriptJSON",
              "signature": "private async fetchNativeScriptJSON(\n    scriptHash: string,\n  ): Promise<NativeScript> {\n    const { data, status } = await this._axiosInstance.get(\n      `scripts/${scriptHash}/json`,\n    );\n\n    if (status === 200 || status == 202) return data.json;\n\n    throw parseHttpError(data);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "setCaching",
              "signature": "setCaching(enable: boolean, offlineFetcher?: OfflineFetcher): void {\n    this._enableCaching = enable;\n    if (enable) {\n      this._offlineFetcher = offlineFetcher || new OfflineFetcher(this._network);\n    } else {\n      this._offlineFetcher = undefined;\n    }\n  }",
              "documentation": "Enable or disable caching functionality.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getOfflineFetcher",
              "signature": "getOfflineFetcher(): OfflineFetcher | undefined {\n    return this._offlineFetcher;\n  }",
              "documentation": "Get the current OfflineFetcher instance if caching is enabled.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "isCachingEnabled",
              "signature": "isCachingEnabled(): boolean {\n    return this._enableCaching;\n  }",
              "documentation": "Check if caching is currently enabled.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "exportCache",
              "signature": "exportCache(): string | null {\n    return this._offlineFetcher ? this._offlineFetcher.toJSON() : null;\n  }",
              "documentation": "Export the cached data as JSON string.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "importCache",
              "signature": "importCache(jsonData: string, enableCaching = true): void {\n    if (enableCaching && !this._enableCaching) {\n      this.setCaching(true);\n    }\n    \n    if (this._offlineFetcher) {\n      const importedFetcher = OfflineFetcher.fromJSON(jsonData);\n      this._offlineFetcher = importedFetcher;\n    }\n  }",
              "documentation": "Import cached data from JSON string.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "clearCache",
              "signature": "clearCache(): void {\n    if (this._offlineFetcher) {\n      this._offlineFetcher = new OfflineFetcher(this._network);\n    }\n  }",
              "documentation": "Clear all cached data.",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "_axiosInstance",
              "type": "AxiosInstance",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_network",
              "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/blockfrost\").BlockfrostSupportedNetworks",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "submitTxToBytes",
              "type": "boolean",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_offlineFetcher",
              "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/offline/offline-fetcher\").OfflineFetcher | undefined",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_enableCaching",
              "type": "boolean",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "resolveScriptRef",
              "type": "(scriptHash: string) => Promise<string | undefined>",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "toUTxO",
              "type": "(bfUTxO: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/blockfrost\").BlockfrostUTxO, tx_hash: string) => Promise<UTxO>",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-provider.src.index",
      "name": "index",
      "source": "mesh-provider",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-provider.src.koios",
      "name": "koios",
      "source": "mesh-provider",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "KoiosSupportedNetworks",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/koios\").KoiosSupportedNetworks",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/koios.ts",
          "documentation": ""
        }
      ],
      "classes": [
        {
          "name": "KoiosProvider",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/koios.ts",
          "extends": null,
          "implements": [
            "IFetcher",
            "IListener",
            "ISubmitter",
            "IEvaluator"
          ],
          "methods": [
            {
              "name": "fetchAccountInfo",
              "signature": "async fetchAccountInfo(address: string): Promise<AccountInfo> {\n    try {\n      const rewardAddress = address.startsWith(\"addr\")\n        ? resolveRewardAddress(address)\n        : address;\n\n      const { data, status } = await this._axiosInstance.post(\"account_info\", {\n        _stake_addresses: [rewardAddress],\n      });\n\n      if (status === 200)\n        return <AccountInfo>{\n          poolId: data[0].delegated_pool,\n          active: data[0].status === \"registered\",\n          balance: data[0].total_balance.toString(),\n          rewards: data[0].rewards_available,\n          withdrawals: data[0].withdrawals,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Obtain information about a specific stake account.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressAssets",
              "signature": "async fetchAddressAssets(\n    address: string,\n  ): Promise<{ [key: string]: string }> {\n    const utxos = await this.fetchAddressUTxOs(address);\n    return utxosToAssets(utxos);\n  }",
              "documentation": "Fetches the assets for a given address.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressTxs",
              "signature": "async fetchAddressTxs(\n    address: string,\n    option: IFetcherOptions = DEFAULT_FETCHER_OPTIONS,\n  ): Promise<TransactionInfo[]> {\n    try {\n      const { data, status } = await this._axiosInstance.post(`/address_txs`, {\n        _addresses: [address],\n      });\n      if (status === 200 || status == 202) {\n        return data.map((tx: any) => {\n          return <TransactionInfo>{\n            hash: tx.tx_hash,\n            index: 0,\n            block: \"\",\n            slot: \"\",\n            fees: \"\",\n            size: 0,\n            deposit: \"\",\n            invalidBefore: \"\",\n            invalidAfter: \"\",\n          };\n        });\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Unimplemented - open for contribution, see blockfrost.ts for reference",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressUTxOs",
              "signature": "async fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]> {\n    try {\n      const { data, status } = await this._axiosInstance.post(\"address_info\", {\n        _addresses: [address],\n      });\n\n      if (status === 200) {\n        const utxos = <UTxO[]>(\n          data\n            .flatMap((info: { utxo_set: [] }) => info.utxo_set)\n            .map((utxo: KoiosUTxO) => this.toUTxO(utxo, address))\n        );\n\n        return asset !== undefined\n          ? utxos.filter(\n              (utxo) =>\n                utxo.output.amount.find((a) => a.unit === asset) !== undefined,\n            )\n          : utxos;\n      }\n\n      throw parseHttpError(data);\n    } catch (error) {\n      return [];\n    }\n  }",
              "documentation": "UTXOs of the address.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAssetAddresses",
              "signature": "async fetchAssetAddresses(\n    asset: string,\n  ): Promise<{ address: string; quantity: string }[]> {\n    try {\n      const { policyId, assetName } = parseAssetUnit(asset);\n      const { data, status } = await this._axiosInstance.get(\n        `asset_addresses?_asset_policy=${policyId}&_asset_name=${assetName}`,\n      );\n\n      if (status === 200)\n        return data.map(\n          (item: {\n            payment_address: string;\n            quantity: string;\n            stake_address: string;\n          }) => ({\n            address: item.payment_address,\n            quantity: item.quantity,\n          }),\n        );\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetches the asset addresses for a given asset.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAssetMetadata",
              "signature": "async fetchAssetMetadata(asset: string): Promise<AssetMetadata> {\n    try {\n      const { policyId, assetName } = parseAssetUnit(asset);\n      const { data, status } = await this._axiosInstance.get(\n        `asset_info?_asset_policy=${policyId}&_asset_name=${assetName}`,\n      );\n      if (status === 200)\n        return <AssetMetadata>{\n          ...data[0].minting_tx_metadata[721][policyId][toUTF8(assetName)],\n          fingerprint: data[0].fingerprint,\n          totalSupply: data[0].total_supply,\n          mintingTxHash: data[0].minting_tx_hash,\n          mintCount: data[0].mint_cnt,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetches the metadata for a given asset.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchBlockInfo",
              "signature": "async fetchBlockInfo(hash: string): Promise<BlockInfo> {\n    try {\n      const { data, status } = await this._axiosInstance.post(\"block_info\", {\n        _block_hashes: [hash],\n      });\n\n      if (status === 200)\n        return <BlockInfo>{\n          confirmations: data[0].num_confirmations,\n          epoch: data[0].epoch_no,\n          epochSlot: data[0].epoch_slot.toString(),\n          fees: data[0].total_fees ?? \"\",\n          hash: data[0].hash,\n          nextBlock: data[0].child_hash ?? \"\",\n          operationalCertificate: data[0].op_cert,\n          output: data[0].total_output ?? \"0\",\n          previousBlock: data[0].parent_hash,\n          size: data[0].block_size,\n          slot: data[0].abs_slot.toString(),\n          slotLeader: data[0].pool ?? \"\",\n          time: data[0].block_time,\n          txCount: data[0].tx_count,\n          VRFKey: data[0].vrf_key,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetches the block information for a given block hash.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchCollectionAssets",
              "signature": "async fetchCollectionAssets(policyId: string): Promise<{ assets: Asset[] }> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `policy_asset_info?_asset_policy=${policyId}`,\n      );\n\n      if (status === 200)\n        return {\n          assets: data.map((asset: KoiosAsset) => ({\n            unit: `${asset.policy_id}${asset.asset_name}`,\n            quantity: asset.total_supply,\n          })),\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetches the list of assets for a given policy ID.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchHandle",
              "signature": "async fetchHandle(handle: string): Promise<AssetMetadata> {\n    if (this._network !== \"api\") {\n      throw new Error(\n        \"Does not support fetching addresses by handle on non-mainnet networks.\",\n      );\n    }\n    try {\n      const assetName = fromUTF8(`${handle.replace(\"$\", \"\")}`);\n      const asset = await this.fetchAssetMetadata(\n        `${SUPPORTED_HANDLES[1]}000de140${assetName}`,\n      );\n      return asset;\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchHandleAddress",
              "signature": "async fetchHandleAddress(handle: string): Promise<string> {\n    if (this._network !== \"api\") {\n      throw new Error(\n        \"Does not support fetching addresses by handle on non-mainnet networks.\",\n      );\n    }\n    try {\n      const assetName = fromUTF8(handle.replace(\"$\", \"\"));\n      const { data, status } = await this._axiosInstance.get(\n        `asset_addresses?_asset_policy=${SUPPORTED_HANDLES[1]}&_asset_name=${assetName}`,\n      );\n\n      if (status === 200) return data[0].payment_address;\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchProtocolParameters",
              "signature": "async fetchProtocolParameters(epoch = Number.NaN): Promise<Protocol> {\n    try {\n      if (isNaN(epoch)) {\n        const { data } = await this._axiosInstance.get(`tip`);\n        epoch = data[0].epoch_no;\n      }\n\n      const { data, status } = await this._axiosInstance.get(\n        `epoch_params?_epoch_no=${epoch}`,\n      );\n\n      if (status === 200)\n        return castProtocol({\n          coinsPerUtxoSize: data[0].coins_per_utxo_size,\n          collateralPercent: data[0].collateral_percent,\n          decentralisation: data[0].decentralisation,\n          epoch: data[0].epoch_no,\n          keyDeposit: data[0].key_deposit,\n          maxBlockExMem: data[0].max_block_ex_mem.toString(),\n          maxBlockExSteps: data[0].max_block_ex_steps.toString(),\n          maxBlockHeaderSize: data[0].max_bh_size,\n          maxBlockSize: data[0].max_block_size,\n          maxCollateralInputs: data[0].max_collateral_inputs,\n          maxTxExMem: data[0].max_tx_ex_mem.toString(),\n          maxTxExSteps: data[0].max_tx_ex_steps.toString(),\n          maxTxSize: data[0].max_tx_size,\n          maxValSize: data[0].max_val_size,\n          minFeeA: data[0].min_fee_a,\n          minFeeB: data[0].min_fee_b,\n          minPoolCost: data[0].min_pool_cost,\n          poolDeposit: data[0].pool_deposit,\n          priceMem: data[0].price_mem,\n          priceStep: data[0].price_step,\n        });\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetch the latest protocol parameters.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchTxInfo",
              "signature": "async fetchTxInfo(hash: string): Promise<TransactionInfo> {\n    try {\n      const { data, status } = await this._axiosInstance.post(\"tx_info\", {\n        _tx_hashes: [hash],\n      });\n\n      if (status === 200 && data.length == 1)\n        return <TransactionInfo>{\n          block: data[0].block_hash,\n          deposit: data[0].deposit,\n          fees: data[0].fee,\n          hash: data[0].tx_hash,\n          index: data[0].tx_block_index,\n          invalidAfter: data[0].invalid_after?.toString() ?? \"\",\n          invalidBefore: data[0].invalid_before?.toString() ?? \"\",\n          slot: data[0].absolute_slot.toString(),\n          size: data[0].tx_size,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetches the transaction information for a given transaction hash.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchUTxOs",
              "signature": "async fetchUTxOs(hash: string, index?: number): Promise<UTxO[]> {\n    try {\n      // get the assets too\n      const { data, status } = await this._axiosInstance.post(\"tx_info\", {\n        _tx_hashes: [hash],\n        _assets: true,\n        _scripts: true,\n        _bytecode: true,\n      });\n\n      if (status === 200) {\n        const utxos: UTxO[] = data[0].outputs.map((utxo: KoiosUTxO) =>\n          this.toUTxO(utxo, utxo.payment_addr.bech32),\n        );\n\n        if (index !== undefined) {\n          return utxos.filter((utxo) => utxo.input.outputIndex === index);\n        }\n\n        return utxos;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Get UTxOs for a given hash.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchGovernanceProposal",
              "signature": "async fetchGovernanceProposal(\n    txHash: string,\n    certIndex: number,\n  ): Promise<GovernanceProposalInfo> {\n    throw new Error(\"Method not implemented\");\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "get",
              "signature": "async get(url: string): Promise<any> {\n    try {\n      const { data, status } = await this._axiosInstance.get(url);\n      if (status === 200 || status == 202) {\n        return data;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "A generic method to fetch data from a URL.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "post",
              "signature": "async post(\n    url: string,\n    body: any,\n    headers = { \"Content-Type\": \"application/json\" },\n  ): Promise<any> {\n    try {\n      const { data, status } = await this._axiosInstance.post(url, body, {\n        headers,\n      });\n\n      if (status === 200 || status == 202) return data;\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "A generic method to post data to a URL.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "onTxConfirmed",
              "signature": "onTxConfirmed(txHash: string, callback: () => void, limit = 100): void {\n    let attempts = 0;\n\n    const checkTx = setInterval(() => {\n      if (attempts >= limit) clearInterval(checkTx);\n\n      this.fetchTxInfo(txHash)\n        .then((txInfo) => {\n          this.fetchBlockInfo(txInfo.block)\n            .then((blockInfo) => {\n              if (blockInfo?.confirmations > 0) {\n                clearInterval(checkTx);\n                callback();\n              }\n            })\n            .catch(() => {\n              attempts += 1;\n            });\n        })\n        .catch(() => {\n          attempts += 1;\n        });\n    }, 5_000);\n  }",
              "documentation": "Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressTransactions",
              "signature": "async fetchAddressTransactions(address: string): Promise<TransactionInfo[]> {\n    return await this.fetchAddressTxs(address);\n  }",
              "documentation": "Deprecated, use fetchAddressTxs instead",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "submitTx",
              "signature": "async submitTx(tx: string): Promise<string> {\n    try {\n      const headers = { \"Content-Type\": \"application/cbor\" };\n\n      const { data, status } = await this._axiosInstance.post(\n        \"submittx\",\n        toBytes(tx),\n        { headers },\n      );\n\n      if (status === 202) return data;\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Submit a serialized transaction to the network.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "toUTxO",
              "signature": "private toUTxO(utxo: KoiosUTxO, address: string): UTxO {\n    return {\n      input: {\n        outputIndex: utxo.tx_index,\n        txHash: utxo.tx_hash,\n      },\n      output: {\n        address: address,\n        amount: [\n          { unit: \"lovelace\", quantity: utxo.value },\n          ...utxo.asset_list.map(\n            (a: KoiosAsset) =>\n              <Asset>{\n                unit: `${a.policy_id}${a.asset_name}`,\n                quantity: `${a.quantity}`,\n              },\n          ),\n        ],\n        dataHash: utxo.datum_hash ?? undefined,\n        plutusData: utxo.inline_datum?.bytes ?? undefined,\n        scriptRef: this.resolveScriptRef(utxo.reference_script),\n        scriptHash: utxo.reference_script?.hash ?? undefined,\n      },\n    };\n  }",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "evaluateTx",
              "signature": "async evaluateTx(tx: string, additionalUtxos?: UTxO[], additionalTxs?: string[]): Promise<Omit<Action, \"data\">[]> {\n    try {\n      const headers = {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\",\n      };\n\n      const body = {\n        jsonrpc: \"2.0\",\n        method: \"evaluateTransaction\",\n        params: {\n          transaction: {\n            cbor: tx\n          },\n        }\n      }\n\n      const { data, status } = await this._axiosInstance.post(\n        \"ogmios\",\n        body,\n        { headers },\n      );\n\n      if (status === 200 || status === 202) {\n        if (!data.result || !data.result.length) {\n          return [];\n        }\n\n        return data.result.map((val: any) => {\n          if (!val.validator || !val.budget) {\n            throw new Error(\"Invalid response format\");\n          }\n          return <Omit<Action, \"data\">>{\n            index: val.validator.index,\n            tag: val.validator.purpose.toUpperCase(),\n            budget: {\n              mem: val.budget.memory,\n              steps: val.budget.cpu,\n            },\n          };\n        })\n      }\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "_axiosInstance",
              "type": "AxiosInstance",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_network",
              "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/koios\").KoiosSupportedNetworks",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "resolveScriptRef",
              "type": "(kScriptRef: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/koios\").KoiosReferenceScript | undefined) => string | undefined",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-provider.src.maestro",
      "name": "maestro",
      "source": "mesh-provider",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "MaestroSupportedNetworks",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/maestro\").MaestroSupportedNetworks",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/maestro.ts",
          "documentation": ""
        }
      ],
      "classes": [
        {
          "name": "MaestroProvider",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/maestro.ts",
          "extends": null,
          "implements": [
            "IFetcher",
            "ISubmitter",
            "IEvaluator",
            "IListener"
          ],
          "methods": [
            {
              "name": "evaluateTx",
              "signature": "async evaluateTx(cbor: string): Promise<Omit<Action, \"data\">[]> {\n    try {\n      const { data, status } = await this._axiosInstance.post(\n        \"transactions/evaluate\",\n        { cbor },\n      );\n      if (status === 200) {\n        const tagMap: { [key: string]: string } = {\n          spend: \"SPEND\",\n          mint: \"MINT\",\n          cert: \"CERT\",\n          wdrl: \"REWARD\",\n        };\n        const result = data.map((action: any) => {\n          const budget = action.ex_units;\n          const index = action.redeemer_index;\n          const tag = tagMap[action.redeemer_tag];\n          return { budget, index, tag };\n        });\n        return result;\n      }\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Evaluates the resources required to execute the transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAccountInfo",
              "signature": "async fetchAccountInfo(address: string): Promise<AccountInfo> {\n    const rewardAddress = address.startsWith(\"addr\")\n      ? resolveRewardAddress(address)\n      : address;\n\n    try {\n      const { data: timestampedData, status } = await this._axiosInstance.get(\n        `accounts/${rewardAddress}`,\n        this._amountsAsStrings,\n      );\n\n      if (status === 200) {\n        const data = timestampedData.data;\n        return <AccountInfo>{\n          poolId: data.delegated_pool,\n          active: data.registered,\n          balance: data.total_balance,\n          rewards: data.rewards_available,\n          withdrawals: data.total_withdrawn,\n        };\n      }\n      throw parseHttpError(timestampedData);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Obtain information about a specific stake account.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressAssets",
              "signature": "async fetchAddressAssets(\n    address: string,\n  ): Promise<{ [key: string]: string }> {\n    const utxos = await this.fetchAddressUTxOs(address);\n    return utxosToAssets(utxos);\n  }",
              "documentation": "Fetches the assets for a given address.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressUTxOs",
              "signature": "async fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]> {\n    const queryPredicate = (() => {\n      if (\n        address.startsWith(\"addr_vkh\") ||\n        address.startsWith(\"addr_shared_vkh\")\n      )\n        return `addresses/cred/${address}`;\n      else return `addresses/${address}`;\n    })();\n    const appendAssetString = asset ? `&asset=${asset}` : \"\";\n    const paginateUTxOs = async (\n      cursor = null,\n      utxos: UTxO[] = [],\n    ): Promise<UTxO[]> => {\n      const appendCursorString = cursor === null ? \"\" : `&cursor=${cursor}`;\n      const { data: timestampedData, status } = await this._axiosInstance.get(\n        `${queryPredicate}/utxos?count=100${appendAssetString}${appendCursorString}`,\n        this._amountsAsStrings,\n      );\n      if (status === 200) {\n        const data = timestampedData.data;\n        const pageUTxOs: UTxO[] = data.map(this.toUTxO);\n        const addedUtxos = [...utxos, ...pageUTxOs];\n        const nextCursor = timestampedData.next_cursor;\n        return nextCursor == null\n          ? addedUtxos\n          : paginateUTxOs(nextCursor, addedUtxos);\n      }\n\n      throw parseHttpError(timestampedData);\n    };\n\n    try {\n      return await paginateUTxOs();\n    } catch (error) {\n      return [];\n    }\n  }",
              "documentation": "UTXOs of the address.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressTxs",
              "signature": "async fetchAddressTxs(\n    address: string,\n    option: IFetcherOptions = { maxPage: 100, order: \"desc\" },\n  ): Promise<TransactionInfo[]> {\n    // open for contribution, see blockfrost.ts for reference\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "Unimplemented - open for contribution\n\nTransactions for an address. The `TransactionInfo` would only return the `hash`, `inputs`, and `outputs`.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAssetAddresses",
              "signature": "async fetchAssetAddresses(\n    asset: string,\n  ): Promise<{ address: string; quantity: string }[]> {\n    const { policyId, assetName } = parseAssetUnit(asset);\n    const paginateAddresses = async (\n      cursor = null,\n      addressesWithQuantity: { address: string; quantity: string }[] = [],\n    ): Promise<{ address: string; quantity: string }[]> => {\n      const appendCursorString = cursor === null ? \"\" : `&cursor=${cursor}`;\n      const { data: timestampedData, status } = await this._axiosInstance.get(\n        `assets/${policyId}${assetName}/addresses?count=100${appendCursorString}`,\n        this._amountsAsStrings,\n      );\n      if (status === 200) {\n        const data = timestampedData.data;\n        const pageAddressesWithQuantity: {\n          address: string;\n          quantity: string;\n        }[] = data.map((a: { address: string; amount: string }) => {\n          return { address: a.address, quantity: a.amount };\n        });\n        const nextCursor = timestampedData.next_cursor;\n        const addedData = [\n          ...addressesWithQuantity,\n          ...pageAddressesWithQuantity,\n        ];\n        return nextCursor == null\n          ? addedData\n          : paginateAddresses(nextCursor, addedData);\n      }\n\n      throw parseHttpError(timestampedData);\n    };\n\n    try {\n      return await paginateAddresses();\n    } catch (error) {\n      return [];\n    }\n  }",
              "documentation": "Fetches the asset addresses for a given asset.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAssetMetadata",
              "signature": "async fetchAssetMetadata(asset: string): Promise<AssetMetadata> {\n    try {\n      const { policyId, assetName } = parseAssetUnit(asset);\n      const { data: timestampedData, status } = await this._axiosInstance.get(\n        `assets/${policyId}${assetName}`,\n      );\n      if (status === 200) {\n        const data = timestampedData.data;\n        return <AssetMetadata>{\n          ...data.asset_standards.cip25_metadata,\n          ...data.asset_standards.cip68_metadata,\n          fingerprint: data.fingerprint,\n          totalSupply: data.total_supply,\n          mintingTxHash: data.latest_mint_tx.tx_hash,\n          mintCount: data.mint_tx_count,\n        };\n      }\n\n      throw parseHttpError(timestampedData);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetches the metadata for a given asset.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchBlockInfo",
              "signature": "async fetchBlockInfo(hash: string): Promise<BlockInfo> {\n    try {\n      const { data: timestampedData, status } = await this._axiosInstance.get(\n        `blocks/${hash}`,\n        this._amountsAsStrings,\n      );\n\n      if (status === 200) {\n        const data = timestampedData.data;\n        return <BlockInfo>{\n          confirmations: data.confirmations,\n          epoch: data.epoch,\n          epochSlot: data.epoch_slot.toString(),\n          fees: data.total_fees,\n          hash: data.hash,\n          nextBlock: data.next_block ?? \"\",\n          operationalCertificate: data.operational_certificate?.hot_vkey,\n          output: data.total_output_lovelace ?? \"0\",\n          previousBlock: data.previous_block,\n          size: data.size,\n          slot: data.absolute_slot.toString(),\n          slotLeader: data.block_producer ?? \"\",\n          time: Date.parse(data.timestamp) / 1000,\n          txCount: data.tx_hashes.length,\n          VRFKey: VrfVkBech32.fromHex(data.vrf_key),\n        };\n      }\n\n      throw parseHttpError(timestampedData);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetches the block information for a given block hash.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchCollectionAssets",
              "signature": "async fetchCollectionAssets(\n    policyId: string,\n    cursor?: string,\n  ): Promise<{ assets: Asset[]; next: string | number | null }> {\n    try {\n      const { data: timestampedData, status } = await this._axiosInstance.get(\n        `policy/${policyId}/assets?count=100${\n          cursor ? `&cursor=${cursor}` : \"\"\n        }`,\n      );\n\n      if (status === 200) {\n        const data = timestampedData.data;\n        return {\n          assets: data.map((asset: MaestroAssetExtended) => ({\n            unit: policyId + asset.asset_name,\n            quantity: asset.total_supply,\n          })),\n          next: timestampedData.next_cursor,\n        };\n      }\n\n      throw parseHttpError(timestampedData);\n    } catch (error) {\n      return { assets: [], next: null };\n    }\n  }",
              "documentation": "Fetches the list of assets for a given policy ID.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchHandle",
              "signature": "async fetchHandle(handle: string): Promise<object> {\n    if (this._network !== \"Mainnet\") {\n      throw new Error(\n        \"Does not support fetching addresses by handle on non-mainnet networks.\",\n      );\n    }\n    try {\n      const assetName = fromUTF8(`${handle.replace(\"$\", \"\")}`);\n      const asset = (await this.fetchAssetMetadata(\n        `${SUPPORTED_HANDLES[1]}000643b0${assetName}`,\n      )) as NonFungibleAssetMetadata;\n\n      if (asset.metadata !== undefined) return asset.metadata;\n\n      throw \"Problem fetching metadata\";\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchHandleAddress",
              "signature": "async fetchHandleAddress(handle: string): Promise<string> {\n    if (this._network !== \"Mainnet\") {\n      throw new Error(\n        \"Does not support fetching addresses by handle on non-mainnet networks.\",\n      );\n    }\n\n    try {\n      const handleWithoutDollar =\n        handle.charAt(0) === \"$\" ? handle.substring(1) : handle;\n      const { data: timestampedData, status } = await this._axiosInstance.get(\n        `ecosystem/adahandle/${handleWithoutDollar}`,\n      );\n\n      if (status === 200) return timestampedData.data;\n\n      throw parseHttpError(timestampedData);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchProtocolParameters",
              "signature": "async fetchProtocolParameters(epoch = Number.NaN): Promise<Protocol> {\n    if (!isNaN(epoch))\n      throw new Error(\n        \"Maestro only supports fetching Protocol parameters of the latest completed epoch.\",\n      );\n\n    // Decimal numbers in Maestro are given as ratio of two numbers represented by string of format \"firstNumber/secondNumber\".\n    const decimalFromRationalString = (str: string): number => {\n      const forwardSlashIndex = str.indexOf(\"/\");\n      return (\n        parseInt(str.slice(0, forwardSlashIndex)) /\n        parseInt(str.slice(forwardSlashIndex + 1))\n      );\n    };\n    try {\n      const { data: timestampedData, status } =\n        await this._axiosInstance.get(\"protocol-params\");\n      if (status === 200) {\n        const data = timestampedData.data;\n        try {\n          const { data: timestampedDataEpochData, status: epochStatus } =\n            await this._axiosInstance.get(\"epochs/current\");\n          if (epochStatus === 200) {\n            const epochData = timestampedDataEpochData.data;\n            return castProtocol({\n              coinsPerUtxoSize: parseInt(data.coins_per_utxo_byte),\n              collateralPercent: parseInt(data.collateral_percentage),\n              decentralisation: 0, // Deprecated in Babbage era.\n              epoch: parseInt(epochData.epoch_no),\n              keyDeposit: parseInt(data.stake_key_deposit),\n              maxBlockExMem:\n                data.max_execution_units_per_block.memory.toString(),\n              maxBlockExSteps:\n                data.max_execution_units_per_block.steps.toString(),\n              maxBlockHeaderSize: parseInt(data.max_block_header_size),\n              maxBlockSize: parseInt(data.max_block_body_size),\n              maxCollateralInputs: parseInt(data.max_collateral_inputs),\n              maxTxExMem:\n                data.max_execution_units_per_transaction.memory.toString(),\n              maxTxExSteps:\n                data.max_execution_units_per_transaction.steps.toString(),\n              maxTxSize: parseInt(data.max_tx_size),\n              maxValSize: parseInt(data.max_value_sized),\n              minFeeA: data.min_fee_coefficient,\n              minFeeB: data.min_fee_constant,\n              minPoolCost: data.min_pool_cost.toString(),\n              poolDeposit: parseInt(data.pool_deposit),\n              priceMem: decimalFromRationalString(data.prices.memory),\n              priceStep: decimalFromRationalString(data.prices.steps),\n            });\n          }\n          throw parseHttpError(timestampedDataEpochData);\n        } catch (error) {\n          throw parseHttpError(error);\n        }\n      }\n      throw parseHttpError(timestampedData);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetch the latest protocol parameters.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchTxInfo",
              "signature": "async fetchTxInfo(hash: string): Promise<TransactionInfo> {\n    try {\n      const { data: timestampedData, status } = await this._axiosInstance.get(\n        `transactions/${hash}`,\n      );\n\n      if (status === 200) {\n        const data = timestampedData.data;\n        return <TransactionInfo>{\n          block: data.block_hash,\n          deposit: data.deposit.toString(),\n          fees: data.fee.toString(),\n          hash: data.tx_hash,\n          index: data.block_tx_index,\n          invalidAfter: data.invalid_hereafter ?? \"\",\n          invalidBefore: data.invalid_before ?? \"\",\n          slot: data.block_absolute_slot.toString(),\n          size: data.size - 1,\n        };\n      }\n      throw parseHttpError(timestampedData);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetches the transaction information for a given transaction hash.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchUTxOs",
              "signature": "async fetchUTxOs(hash: string, index?: number): Promise<UTxO[]> {\n    try {\n      const { data: timestampedData, status } = await this._axiosInstance.get(\n        `transactions/${hash}`,\n        this._amountsAsStrings,\n      );\n      if (status === 200) {\n        const msOutputs = timestampedData.data.outputs as MaestroUTxO[];\n        const outputs = msOutputs.map(this.toUTxO);\n\n        if (index !== undefined) {\n          return outputs.filter((utxo) => utxo.input.outputIndex === index);\n        }\n\n        return outputs;\n      }\n      throw parseHttpError(timestampedData);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Get UTxOs for a given hash.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchGovernanceProposal",
              "signature": "async fetchGovernanceProposal(\n    txHash: string,\n    certIndex: number,\n  ): Promise<GovernanceProposalInfo> {\n    throw new Error(\"Method not implemented by Maestro\");\n  }",
              "documentation": "Unimplemented - open for contribution\n\nFetches the governance proposal information.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "get",
              "signature": "async get(url: string): Promise<any> {\n    try {\n      const { data, status } = await this._axiosInstance.get(url);\n      if (status === 200) {\n        return data;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "onTxConfirmed",
              "signature": "onTxConfirmed(txHash: string, callback: () => void, limit = 100): void {\n    let attempts = 0;\n\n    const checkTx = setInterval(() => {\n      if (attempts >= limit) clearInterval(checkTx);\n\n      this.fetchTxInfo(txHash)\n        .then((txInfo) => {\n          this.fetchBlockInfo(txInfo.block)\n            .then((blockInfo) => {\n              if (blockInfo?.confirmations > 0) {\n                clearInterval(checkTx);\n                callback();\n              }\n            })\n            .catch(() => {\n              attempts += 1;\n            });\n        })\n        .catch(() => {\n          attempts += 1;\n        });\n    }, 5_000);\n  }",
              "documentation": "Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "setSubmitTxToBytes",
              "signature": "setSubmitTxToBytes(value: boolean): void {\n    this.submitTxToBytes = value;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "submitTx",
              "signature": "async submitTx(tx: string): Promise<string> {\n    try {\n      const headers = { \"Content-Type\": \"application/cbor\" };\n      const { data, status } = await this._axiosInstance.post(\n        this.submitUrl,\n        this.submitTxToBytes ? toBytes(tx) : tx,\n        { headers },\n      );\n\n      if (status === 202) return data;\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Submit a serialized transaction to the network.",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "_axiosInstance",
              "type": "AxiosInstance",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_amountsAsStrings",
              "type": "{ headers: { \"amounts-as-strings\": string; }; }",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_network",
              "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/maestro\").MaestroSupportedNetworks",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "submitTxToBytes",
              "type": "boolean",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "submitUrl",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "toUTxO",
              "type": "(utxo: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/maestro\").MaestroUTxO) => UTxO",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "resolveScript",
              "type": "(utxo: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/maestro\").MaestroUTxO) => any",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-provider.src.ogmios",
      "name": "ogmios",
      "source": "mesh-provider",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "OgmiosProvider",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/ogmios.ts",
          "extends": null,
          "implements": [
            "IEvaluator",
            "ISubmitter"
          ],
          "methods": [
            {
              "name": "evaluateTx",
              "signature": "async evaluateTx(tx: string): Promise<Omit<Action, \"data\">[]> {\n    const client = await this.open();\n\n    this.send(client, \"evaluateTransaction\", {\n      transaction: {\n        cbor: tx,\n      },\n    });\n\n    return new Promise((resolve, reject) => {\n      client.addEventListener(\n        \"message\",\n        (response: MessageEvent<string>) => {\n          try {\n            const { result } = JSON.parse(response.data);\n            if (result) {\n              resolve(\n                Object.values(result).map((val: any) => {\n                  return <Omit<Action, \"data\">>{\n                    index: val.validator.index,\n                    tag: val.validator.purpose.toUpperCase(),\n                    budget: {\n                      mem: val.budget.memory,\n                      steps: val.budget.cpu,\n                    },\n                  };\n                }),\n              );\n            } else {\n              reject(result);\n            }\n\n            client.close();\n          } catch (error) {\n            reject(error);\n          }\n        },\n        { once: true },\n      );\n    });\n  }",
              "documentation": "Evaluates the resources required to execute the transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "onNextTx",
              "signature": "async onNextTx(callback: (tx: unknown) => void): Promise<() => void> {\n    const client = await this.open();\n\n    this.send(client, \"acquireMempool\", {});\n\n    client.addEventListener(\"message\", (response: MessageEvent<string>) => {\n      const { result } = JSON.parse(response.data);\n      if (result === null) {\n        return this.send(client, \"acquireMempool\", {});\n      }\n\n      if (result.transaction === null || result.transaction === undefined) {\n        this.send(client, \"acquireMempool\", {});\n      } else {\n        callback(result);\n      }\n\n      this.send(client, \"nextTransaction\", {\n        fields: \"all\",\n      });\n    });\n\n    return () => client.close();\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "submitTx",
              "signature": "async submitTx(tx: string): Promise<string> {\n    const client = await this.open();\n\n    this.send(client, \"submitTransaction\", {\n      transaction: {\n        cbor: tx,\n      },\n    });\n\n    return new Promise((resolve, reject) => {\n      client.addEventListener(\n        \"message\",\n        (response: MessageEvent<string>) => {\n          try {\n            const { result } = JSON.parse(response.data);\n\n            if (!result) {\n              reject(JSON.parse(response.data).error);\n            }\n\n            if (\n              result.transaction !== null &&\n              result.transaction !== undefined\n            ) {\n              resolve(result.transaction.id);\n            } else {\n              reject(result);\n            }\n\n            client.close();\n          } catch (error) {\n            reject(error);\n          }\n        },\n        { once: true },\n      );\n    });\n  }",
              "documentation": "Submit a serialized transaction to the network.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "open",
              "signature": "private async open(): Promise<WebSocket> {\n    const client = new WebSocket(this._baseUrl);\n\n    await new Promise((resolve) => {\n      client.addEventListener(\"open\", () => resolve(true), { once: true });\n    });\n\n    return client;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "send",
              "signature": "private send(client: WebSocket, method: string, params: unknown) {\n    client.send(\n      JSON.stringify({\n        jsonrpc: \"2.0\",\n        type: \"jsonwsp/request\",\n        servicename: \"ogmios\",\n        method,\n        params,\n      }),\n    );\n  }",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ],
          "properties": [
            {
              "name": "_baseUrl",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-provider.src.utxo-rpc",
      "name": "utxo-rpc",
      "source": "mesh-provider",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "U5CProvider",
          "documentation": "A UTxO RPC Provider for [MeshJS](https://meshjs.dev/) Transaction Builder Library.\n\nExample usage of how to use the UTxO RPC provider with Mesh to build and submit a transaction.\n```\n// Step #1\n// Import Mesh SDK and UTxO RPC provider\nimport { Transaction, MeshWallet, U5CProvider } from \"@meshsdk/core\";\n\nasync function main() {\n  // Step #2\n  // Create a new U5C provider\n  const provider = new U5CProvider({\n    url: \"http://localhost:50051\",\n    headers: {\n      \"dmtr-api-key\": \"<api-key>\",\n    },\n  });\n\n  // Step #3\n  // Create a new wallet from a mnemonic\n  const wallet = new MeshWallet({\n    networkId: 0, // 0: testnet, 1: mainnet\n    fetcher: provider,\n    submitter: provider,\n    key: {\n      type: \"mnemonic\",\n      words: [\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n      ],\n    },\n  });\n\n  // Optional: Print the wallet address\n  console.log(wallet.getChangeAddress());\n\n  // Optional: Print the wallet utxos\n  console.log(await provider.fetchAddressUTxOs(wallet.getChangeAddress()));\n\n  // Step #4\n  // Create an example transaction that sends 5 ADA to an address\n  const tx = new Transaction({\n    initiator: wallet,\n    verbose: false,\n  }).sendLovelace(\n    \"addr_test1vpvx0sacufuypa2k4sngk7q40zc5c4npl337uusdh64kv0c7e4cxr\",\n    \"5000000\"\n  );\n  const unsignedTx = await tx.build();\n\n  // Step #5\n  // Sign the transaction\n  const signedTx = await wallet.signTx(unsignedTx);\n\n  // Step #6\n  // Submit the transaction to the blockchain network\n  const txId = await provider.submitTx(signedTx);\n\n  // Optional: Print the transaction ID\n  console.log(\"Transaction ID\", txId);\n}\n\nmain().catch(console.error);\n```",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/utxo-rpc.ts",
          "extends": null,
          "implements": [
            "IFetcher",
            "ISubmitter",
            "IEvaluator",
            "IListener"
          ],
          "methods": [
            {
              "name": "onTxConfirmed",
              "signature": "onTxConfirmed(txHash: string, callback: () => void, limit = 100): void {\n    const onConfirmed = async () => {\n      const updates = this.submitClient.waitForTx(hexToBytes(txHash));\n\n      for await (const stage of updates) {\n        console.log(JSON.stringify(updates));\n        if (stage === submit.Stage.CONFIRMED) {\n          callback();\n          return; // Exit once confirmed\n        }\n      }\n    };\n\n    const timeoutId = setTimeout(() => {\n      // Handle timeout if necessary (e.g., log or notify)\n      console.log(\"Transaction confirmation timed out.\");\n    }, limit * 5000);\n\n    // Start listening for confirmations and clear timeout on completion.\n    onConfirmed().finally(() => clearTimeout(timeoutId));\n  }",
              "documentation": "Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "evaluateTx",
              "signature": "async evaluateTx(tx: string): Promise<Omit<Action, \"data\">[]> {\n\n    const report = await this.submitClient.evalTx(hexToBytes(tx));\n    const evalResult = report.report[0]!.chain.value?.redeemers!;\n\n    const tagMap: { [key: number]: RedeemerTagType } = {\n      // 0: \"UNSPECIFIED\",   // REDEEMER_PURPOSE_UNSPECIFIED\n      1: \"SPEND\",   // REDEEMER_PURPOSE_SPEND\n      2: \"MINT\",    // REDEEMER_PURPOSE_MINT\n      3: \"CERT\",    // REDEEMER_PURPOSE_CERT\n      4: \"REWARD\",  // REDEEMER_PURPOSE_REWARD\n      5: \"VOTE\",    // REDEEMER_PURPOSE_VOTE\n      6: \"PROPOSE\", // REDEEMER_PURPOSE_PROPOSE\n    };\n\n    const result: Omit<Action, \"data\">[] = [];\n\n    evalResult.map((action: spec.cardano.Redeemer) => {\n      result.push({\n        tag: tagMap[action.purpose!]!,\n        index: action.index,\n        budget: { mem: Number(action.exUnits!.memory), steps: Number(action.exUnits!.steps) },\n      });\n    })\n\n    return result;\n\n  }",
              "documentation": "Evaluates the resources required to execute the transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "submitTx",
              "signature": "async submitTx(tx: string): Promise<string> {\n    const cbor = toBytes(tx);\n    const hash = await this.submitClient.submitTx(cbor);\n    return bytesToHex(hash);\n  }",
              "documentation": "Submit a serialized transaction to the network.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAccountInfo",
              "signature": "fetchAccountInfo(address: string): Promise<AccountInfo> {\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "Obtain information about a specific stake account.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressAssets",
              "signature": "async fetchAddressAssets(\n    address: string,\n  ): Promise<{ [key: string]: string }> {\n    const utxos = await this.fetchAddressUTxOs(address);\n    return utxosToAssets(utxos);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressUTxOs",
              "signature": "async fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]> {\n    const addressBytes = hexToBytes(Address.fromBech32(address).toBytes());\n\n    const utxoSearchResult =\n      await this.queryClient.searchUtxosByAddress(addressBytes);\n\n    return utxoSearchResult\n      .map((item) => {\n        const utxo = this._rpcUtxoToMeshUtxo(item.txoRef, item.parsedValued!);\n\n        if (asset) {\n          // Check if the output amount contains the specified asset\n          if (\n            utxo.output.amount.some((amountItem) => amountItem.unit === asset)\n          ) {\n            return utxo; // Return the utxo if asset matches\n          }\n          // If the asset does not match, return undefined\n          return undefined;\n        }\n\n        // If no asset is specified, return the utxo directly\n        return utxo;\n      })\n      .filter((utxo) => utxo !== undefined); // Filter out undefined results\n  }",
              "documentation": "Fetches the UTxOs for a given address.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressTxs",
              "signature": "async fetchAddressTxs(\n    address: string,\n    option: IFetcherOptions = { maxPage: 100, order: \"desc\" },\n  ): Promise<TransactionInfo[]> {\n    // open for contribution, see blockfrost.ts for reference\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "Unimplemented - open for contribution\n\nTransactions for an address. The `TransactionInfo` would only return the `hash`, `inputs`, and `outputs`.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAssetAddresses",
              "signature": "fetchAssetAddresses(\n    asset: string,\n  ): Promise<{ address: string; quantity: string }[]> {\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "Unimplemented - open for contribution\n\nFetches the asset addresses for a given asset.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAssetMetadata",
              "signature": "fetchAssetMetadata(asset: string): Promise<AssetMetadata> {\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "Unimplemented - open for contribution\n\nFetches the metadata for a given asset.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchBlockInfo",
              "signature": "fetchBlockInfo(hash: string): Promise<BlockInfo> {\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "Unimplemented - open for contribution\n\nFetches the block information for a given block hash.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchCollectionAssets",
              "signature": "fetchCollectionAssets(\n    policyId: string,\n    cursor?: number | string,\n  ): Promise<{ assets: Asset[]; next?: string | number | null }> {\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "Unimplemented - open for contribution\n\nFetches the collection assets for a given policy ID.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchHandle",
              "signature": "fetchHandle(handle: string): Promise<object> {\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "Unimplemented - open for contribution\n\nFetches the information (AssetMetadata) for a given handle.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchHandleAddress",
              "signature": "fetchHandleAddress(handle: string): Promise<string> {\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "Unimplemented - open for contribution\n\nResolve the handle's address from the handle.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchProtocolParameters",
              "signature": "async fetchProtocolParameters(epoch = Number.NaN): Promise<Protocol> {\n    const rpcPParams = await this.queryClient.readParams();\n    if (rpcPParams === undefined || rpcPParams === null) {\n      throw new Error(`Error fetching protocol parameters`);\n    }\n    return this._rpcPParamsToProtocol(rpcPParams);\n  }",
              "documentation": "Unimplemented - open for contribution\n\nFetches protocol parameters",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchTxInfo",
              "signature": "fetchTxInfo(hash: string): Promise<TransactionInfo> {\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "Unimplemented - open for contribution\n\nFetches transaction info for a given hash.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchUTxOs",
              "signature": "async fetchUTxOs(hash: string, index?: number): Promise<UTxO[]> {\n    const utxoSearchResult = await this.queryClient.readUtxosByOutputRef(\n      [{\n        txHash: hexToBytes(hash),\n        outputIndex: index || 0,    // TODO: handle case when index is not provided. Note: readUtxos might not support this, try when readTx is implemented\n      }]\n    );\n    return utxoSearchResult.map((item) => {\n      return this._rpcUtxoToMeshUtxo(item.txoRef, item.parsedValued!);\n    });\n  }",
              "documentation": "Not complete - open for contribution\n\nFetches output UTxOs of a given transaction hash.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchGovernanceProposal",
              "signature": "async fetchGovernanceProposal(\n    txHash: string,\n    certIndex: number,\n  ): Promise<GovernanceProposalInfo> {\n    throw new Error(\"Method not implemented\");\n  }",
              "documentation": "Unimplemented - open for contribution\n\nFetches the governance proposal information.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "get",
              "signature": "get(url: string): Promise<any> {\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "Unimplemented - open for contribution",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "awaitTransactionConfirmation",
              "signature": "awaitTransactionConfirmation(\n    txId: string,\n    timeout?: number,\n  ): Promise<boolean> {\n    const onConfirmed = (async () => {\n      const updates = this.submitClient.waitForTx(hexToBytes(txId));\n\n      for await (const stage of updates) {\n        if (stage == submit.Stage.CONFIRMED) {\n          return true;\n        }\n      }\n\n      return false;\n    })();\n\n    const onTimeout: Promise<boolean> = new Promise((resolve) =>\n      setTimeout(() => resolve(false), timeout),\n    );\n\n    return Promise.race([onConfirmed, onTimeout]);\n  }",
              "documentation": "Waits for transaction confirmation within a given timeout.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "_rpcUtxoToMeshUtxo",
              "signature": "private _rpcUtxoToMeshUtxo(\n    rpcTxoRef: spec.query.TxoRef,\n    rpcTxOutput: spec.cardano.TxOutput,\n  ): UTxO {\n    const amount: Asset[] = [\n      {\n        unit: \"lovelace\",\n        quantity: rpcTxOutput.coin.toString(),\n      },\n    ];\n    rpcTxOutput.assets.forEach((ma) => {\n      ma.assets.forEach((asset) => {\n        amount.push({\n          unit:\n            Buffer.from(ma.policyId).toString(\"hex\") +\n            Buffer.from(asset.name).toString(\"hex\"),\n          quantity: asset.outputCoin.toString(),\n        });\n      });\n    });\n\n    let dataHash: string | undefined = undefined;\n    let plutusData: string | undefined = undefined;\n\n    if (rpcTxOutput.datum !== undefined) {\n      if (\n        rpcTxOutput.datum?.originalCbor &&\n        rpcTxOutput.datum.originalCbor.length > 0\n      ) {\n        dataHash = Buffer.from(rpcTxOutput.datum.hash).toString(\"hex\");\n        plutusData = Buffer.from(rpcTxOutput.datum.originalCbor).toString(\n          \"hex\",\n        );\n      } else if (rpcTxOutput.datum?.hash && rpcTxOutput.datum.hash.length > 0) {\n        dataHash = Buffer.from(rpcTxOutput.datum.hash).toString(\"hex\");\n      }\n    }\n\n    let scriptRef: string | undefined = undefined;\n    let scriptHash: string | undefined = undefined;\n\n    if (rpcTxOutput.script !== undefined) {\n      // TODO: Implement scriptRef\n      // TODO: Implement scriptHash\n    }\n\n    return {\n      input: {\n        outputIndex: rpcTxoRef.index,\n        txHash: Buffer.from(rpcTxoRef.hash).toString(\"hex\"),\n      },\n      output: {\n        address: Address.fromBytes(\n          CardanoSDKUtil.HexBlob.fromBytes(rpcTxOutput.address),\n        ).toBech32(),\n        amount: amount,\n        dataHash: dataHash,\n        plutusData: plutusData,\n        scriptRef: scriptRef,\n        scriptHash: scriptHash,\n      },\n    };\n  }",
              "documentation": "Helper function to convert an RPC UTxO object to a Mesh UTxO object.",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_rpcPParamsToProtocol",
              "signature": "private _rpcPParamsToProtocol(rpcPParams: spec.cardano.PParams): Protocol {\n    return castProtocol({\n      coinsPerUtxoSize: Number(rpcPParams.coinsPerUtxoByte),\n      collateralPercent: Number(rpcPParams.collateralPercentage),\n      decentralisation: 0, // Deprecated in Babbage era.\n      keyDeposit: Number(rpcPParams.stakeKeyDeposit),\n      maxBlockExMem: Number(rpcPParams.maxExecutionUnitsPerBlock?.memory),\n      maxBlockExSteps: Number(rpcPParams.maxExecutionUnitsPerBlock?.steps),\n      maxBlockHeaderSize: Number(rpcPParams.maxBlockHeaderSize),\n      maxBlockSize: Number(rpcPParams.maxBlockBodySize),\n      maxCollateralInputs: Number(rpcPParams.maxCollateralInputs),\n      maxTxExMem: Number(rpcPParams.maxExecutionUnitsPerTransaction?.memory),\n      maxTxExSteps: Number(rpcPParams.maxExecutionUnitsPerTransaction?.steps),\n      maxTxSize: Number(rpcPParams.maxTxSize),\n      maxValSize: Number(rpcPParams.maxValueSize),\n      minFeeA: Number(rpcPParams.minFeeCoefficient),\n      minFeeB: Number(rpcPParams.minFeeConstant),\n      minPoolCost: Number(rpcPParams.minPoolCost),\n      poolDeposit: Number(rpcPParams.poolDeposit),\n      priceMem: Number(rpcPParams.prices?.memory),\n      priceStep: Number(rpcPParams.prices?.steps),\n    });\n  }",
              "documentation": "Converts RPC protocol parameters to a Mesh Protocol object.",
              "static": false,
              "visibility": "private"
            }
          ],
          "properties": [
            {
              "name": "queryClient",
              "type": "CardanoQueryClient",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "submitClient",
              "type": "CardanoSubmitClient",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-provider.src.yaci",
      "name": "yaci",
      "source": "mesh-provider",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "YaciProvider",
          "documentation": "Yaci DevKit is a development tool designed for rapid and efficient Cardano blockchain development. It allows developers to create and destroy custom Cardano devnets in seconds, providing fast feedback loops and simplifying the iteration process.\n\nGet started:\n```typescript\nimport { YaciProvider } from \"@meshsdk/core\";\nconst provider = new YaciProvider('<YACI_URL>', '<OPTIONAL_ADMIN_URL>');\n```",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/yaci.ts",
          "extends": null,
          "implements": [
            "IFetcher",
            "IListener",
            "ISubmitter",
            "IEvaluator"
          ],
          "methods": [
            {
              "name": "fetchAccountInfo",
              "signature": "async fetchAccountInfo(address: string): Promise<AccountInfo> {\n    const rewardAddress = address.startsWith(\"addr\")\n      ? resolveRewardAddress(address)\n      : address;\n\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `accounts/${rewardAddress}`,\n      );\n\n      if (status === 200)\n        return <AccountInfo>{\n          poolId: data.pool_id,\n          active: data.active || data.active_epoch !== null,\n          balance: data.controlled_amount,\n          rewards: data.withdrawable_amount,\n          withdrawals: data.withdrawals_sum,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Obtain information about a specific stake account.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressAssets",
              "signature": "async fetchAddressAssets(\n    address: string,\n  ): Promise<{ [key: string]: string }> {\n    const utxos = await this.fetchAddressUTxOs(address);\n    return utxosToAssets(utxos);\n  }",
              "documentation": "Fetches the assets for a given address.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressUTxOs",
              "signature": "async fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]> {\n    const filter = asset !== undefined ? `/${asset}` : \"\";\n    const url = `addresses/${address}/utxos` + filter;\n\n    const paginateUTxOs = async (\n      page = 1,\n      utxos: UTxO[] = [],\n    ): Promise<UTxO[]> => {\n      const { data, status } = await this._axiosInstance.get(\n        `${url}?page=${page}`,\n      );\n\n      if (status === 200)\n        return data.length > 0\n          ? paginateUTxOs(page + 1, [\n              ...utxos,\n              ...(await Promise.all(\n                data.map((utxo: any) => this.toUTxO(utxo, utxo.tx_hash)),\n              )),\n            ])\n          : utxos;\n\n      throw parseHttpError(data);\n    };\n\n    try {\n      return await paginateUTxOs();\n    } catch (error) {\n      return [];\n    }\n  }",
              "documentation": "UTXOs of the address.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressTxs",
              "signature": "async fetchAddressTxs(\n    address: string,\n    option: IFetcherOptions = { maxPage: 100, order: \"desc\" },\n  ): Promise<TransactionInfo[]> {\n    // open for contribution, see blockfrost.ts for reference\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "Unimplemented - open for contribution\n\nTransactions for an address. The `TransactionInfo` would only return the `hash`, `inputs`, and `outputs`.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAssetAddresses",
              "signature": "async fetchAssetAddresses(\n    asset: string,\n  ): Promise<{ address: string; quantity: string }[]> {\n    const paginateAddresses = async <T>(\n      page = 1,\n      addresses: T[] = [],\n    ): Promise<T[]> => {\n      const { policyId, assetName } = parseAssetUnit(asset);\n      const { data, status } = await this._axiosInstance.get(\n        `assets/${policyId}${assetName}/addresses?page=${page}`,\n      );\n\n      if (status === 200)\n        return data.length > 0\n          ? paginateAddresses(page + 1, [...addresses, ...data])\n          : addresses;\n\n      throw parseHttpError(data);\n    };\n\n    try {\n      return await paginateAddresses<{ address: string; quantity: string }>();\n    } catch (error) {\n      return [];\n    }\n  }",
              "documentation": "Fetches the asset addresses for a given asset.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAssetMetadata",
              "signature": "async fetchAssetMetadata(asset: string): Promise<AssetMetadata> {\n    try {\n      const { policyId, assetName } = parseAssetUnit(asset);\n      const { data, status } = await this._axiosInstance.get(\n        `assets/${policyId}${assetName}`,\n      );\n\n      if (status === 200)\n        return <AssetMetadata>{\n          ...data.onchain_metadata,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetches the metadata for a given asset.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchBlockInfo",
              "signature": "async fetchBlockInfo(hash: string): Promise<BlockInfo> {\n    try {\n      const { data, status } = await this._axiosInstance.get(`blocks/${hash}`);\n\n      if (status === 200)\n        return <BlockInfo>{\n          confirmations: data.confirmations,\n          epoch: data.epoch,\n          epochSlot: data.epoch_slot.toString(),\n          fees: data.fees,\n          hash: data.hash,\n          nextBlock: data.next_block ?? \"\",\n          operationalCertificate: data.op_cert,\n          output: data.output ?? \"0\",\n          previousBlock: data.previous_block,\n          size: data.size,\n          slot: data.slot.toString(),\n          slotLeader: data.slot_leader ?? \"\",\n          time: data.time,\n          txCount: data.tx_count,\n          VRFKey: data.block_vrf,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetches the block information for a given block hash.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchCollectionAssets",
              "signature": "async fetchCollectionAssets(\n    policyId: string,\n    cursor = 1,\n  ): Promise<{ assets: Asset[]; next: string | number | null }> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `assets/policy/${policyId}?page=${cursor}`,\n      );\n\n      if (status === 200)\n        return {\n          assets: data.map((asset: any) => ({\n            unit: asset.asset,\n            quantity: asset.quantity,\n          })),\n          next: data.length === 100 ? cursor + 1 : null,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      return { assets: [], next: null };\n    }\n  }",
              "documentation": "Fetches the list of assets for a given policy ID.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchHandle",
              "signature": "async fetchHandle(handle: string): Promise<object> {\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchHandleAddress",
              "signature": "async fetchHandleAddress(handle: string): Promise<string> {\n    try {\n      const assetName = fromUTF8(handle.replace(\"$\", \"\"));\n      const { data, status } = await this._axiosInstance.get(\n        `assets/${SUPPORTED_HANDLES[1]}${assetName}/addresses`,\n      );\n\n      if (status === 200) return data[0].address;\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchProtocolParameters",
              "signature": "async fetchProtocolParameters(epoch = Number.NaN): Promise<Protocol> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `epochs/${isNaN(epoch) ? \"latest\" : epoch}/parameters`,\n      );\n\n      if (status === 200)\n        return castProtocol({\n          coinsPerUtxoSize: data.coins_per_utxo_size,\n          collateralPercent: data.collateral_percent,\n          decentralisation: data.decentralisation_param,\n          epoch: data.epoch,\n          keyDeposit: data.key_deposit,\n          maxBlockExMem: data.max_block_ex_mem,\n          maxBlockExSteps: data.max_block_ex_steps,\n          maxBlockHeaderSize: data.max_block_header_size,\n          maxBlockSize: data.max_block_size,\n          maxCollateralInputs: data.max_collateral_inputs,\n          maxTxExMem: data.max_tx_ex_mem,\n          maxTxExSteps: data.max_tx_ex_steps,\n          maxTxSize: data.max_tx_size,\n          maxValSize: data.max_val_size,\n          minFeeA: data.min_fee_a,\n          minFeeB: data.min_fee_b,\n          minPoolCost: data.min_pool_cost,\n          poolDeposit: data.pool_deposit,\n          priceMem: data.price_mem,\n          priceStep: data.price_step,\n        });\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetch the latest protocol parameters.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchTxInfo",
              "signature": "async fetchTxInfo(hash: string): Promise<TransactionInfo> {\n    try {\n      const { data, status } = await this._axiosInstance.get(`txs/${hash}`);\n\n      if (status === 200)\n        return <TransactionInfo>{\n          block: data.block,\n          deposit: data.deposit,\n          fees: data.fees,\n          hash: data.hash,\n          index: data.index,\n          invalidAfter: data.invalid_hereafter ?? \"\",\n          invalidBefore: data.invalid_before ?? \"\",\n          slot: data.slot.toString(),\n          size: data.size,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetches the transaction information for a given transaction hash.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchUTxOs",
              "signature": "async fetchUTxOs(hash: string, index?: number): Promise<UTxO[]> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `txs/${hash}/utxos`,\n      );\n      if (status === 200) {\n        const bfOutputs = data.outputs as YaciUTxO[];\n        const outputsPromises: Promise<UTxO>[] = [];\n        bfOutputs.forEach((output) => {\n          outputsPromises.push(this.toUTxO(output, hash));\n        });\n        const outputs = await Promise.all(outputsPromises);\n\n        if (index !== undefined) {\n          return outputs.filter((utxo) => utxo.input.outputIndex === index);\n        }\n\n        return outputs;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Get UTxOs for a given hash.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchGovernanceProposal",
              "signature": "async fetchGovernanceProposal(\n    txHash: string,\n    certIndex: number,\n  ): Promise<GovernanceProposalInfo> {\n    throw new Error(\"Method not implemented\");\n  }",
              "documentation": "Unimplemented - open for contribution\n\nFetches the governance proposal information.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "get",
              "signature": "async get(url: string): Promise<any> {\n    try {\n      const { data, status } = await this._axiosInstance.get(url);\n      if (status === 200) {\n        return data;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "onTxConfirmed",
              "signature": "onTxConfirmed(txHash: string, callback: () => void, limit = 100): void {\n    let attempts = 0;\n\n    const checkTx = setInterval(() => {\n      if (attempts >= limit) clearInterval(checkTx);\n\n      this.fetchTxInfo(txHash)\n        .then((txInfo) => {\n          this.fetchBlockInfo(txInfo.block)\n            .then((blockInfo) => {\n              if (blockInfo?.confirmations > 0) {\n                clearInterval(checkTx);\n                callback();\n              }\n            })\n            .catch(() => {\n              attempts += 1;\n            });\n        })\n        .catch(() => {\n          attempts += 1;\n        });\n    }, 5_000);\n  }",
              "documentation": "Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "submitTx",
              "signature": "async submitTx(txHex: string): Promise<string> {\n    try {\n      const headers = { \"Content-Type\": \"text/plain\" };\n      const { status, data } = await this._axiosInstance.post(\n        \"/tx/submit\",\n        txHex,\n        {\n          headers,\n        },\n      );\n\n      if (status === 202) {\n        return data;\n      }\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Submit a serialized transaction to the network.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "evaluateTx",
              "signature": "async evaluateTx(txHex: string): Promise<Omit<Action, \"data\">[]> {\n    try {\n      const headers = { \"Content-Type\": \"application/cbor\" };\n      const { status, data } = await this._axiosInstance.post(\n        \"utils/txs/evaluate\",\n        txHex,\n        {\n          headers,\n        },\n      );\n\n      if (status === 202 && data.result.EvaluationResult) {\n        const tagMap: { [key: string]: RedeemerTagType } = {\n          spend: \"SPEND\",\n          mint: \"MINT\",\n          certificate: \"CERT\",\n          reward: \"REWARD\",\n        };\n        const result: Omit<Action, \"data\">[] = [];\n\n        Object.keys(data.result.EvaluationResult).forEach((key) => {\n          const [tagKey, index] = key.split(\":\");\n          const { memory, steps } = data.result.EvaluationResult[key];\n          result.push({\n            tag: tagMap[tagKey!]!,\n            index: Number(index),\n            budget: { mem: memory, steps },\n          });\n        });\n\n        return result;\n      }\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Evaluates the resources required to execute the transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getDevnetInfo",
              "signature": "async getDevnetInfo(): Promise<void> {\n    try {\n      if (this._adminAxiosInstance === undefined)\n        throw parseHttpError(\"Admin URL not provided\");\n      const { status, data } = await this._adminAxiosInstance.get(\n        `local-cluster/api/admin/devnet`,\n      );\n\n      if (status === 200) {\n        return data;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getGenesisByEra",
              "signature": "async getGenesisByEra(era: string): Promise<void> {\n    try {\n      if (this._adminAxiosInstance === undefined)\n        throw parseHttpError(\"Admin URL not provided\");\n      const { status, data } = await this._adminAxiosInstance.get(\n        `local-cluster/api/admin/devnet/genesis/${era}`,\n      );\n\n      if (status === 200) {\n        return data;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "addressTopup",
              "signature": "async addressTopup(address: string, amount: string): Promise<void> {\n    try {\n      if (this._adminAxiosInstance === undefined)\n        throw parseHttpError(\"Admin URL not provided\");\n      const headers = { \"Content-Type\": \"application/json\", accept: \"*/*\" };\n      const { status, data } = await this._adminAxiosInstance.post(\n        \"local-cluster/api/addresses/topup\",\n        JSON.stringify({ address: address, adaAmount: parseInt(amount) }),\n        {\n          headers,\n        },\n      );\n\n      if (status === 200) {\n        return data;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Topup address with ADA",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchPlutusScriptCBOR",
              "signature": "private async fetchPlutusScriptCBOR(scriptHash: string): Promise<string> {\n    const { data, status } = await this._axiosInstance.get(\n      `scripts/${scriptHash}/cbor`,\n    );\n\n    if (status === 200) return data.cbor;\n\n    throw parseHttpError(data);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "fetchNativeScriptJSON",
              "signature": "private async fetchNativeScriptJSON(\n    scriptHash: string,\n  ): Promise<NativeScript> {\n    const { data, status } = await this._axiosInstance.get(\n      `scripts/${scriptHash}/json`,\n    );\n\n    if (status === 200) return data.json;\n\n    throw parseHttpError(data);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ],
          "properties": [
            {
              "name": "_axiosInstance",
              "type": "AxiosInstance",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_adminAxiosInstance",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "resolveScriptRef",
              "type": "(scriptHash: string) => Promise<string | undefined>",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "toUTxO",
              "type": "(bfUTxO: YaciUTxO, tx_hash: string) => Promise<UTxO>",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-react.src.index",
      "name": "index",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-svelte.src.app.d",
      "name": "app.d",
      "source": "mesh-svelte",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-svelte.src.index",
      "name": "index",
      "source": "mesh-svelte",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-transaction.src.index",
      "name": "index",
      "source": "mesh-transaction",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-wallet.src.index",
      "name": "index",
      "source": "mesh-wallet",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:bitcoin.src.interfaces.index",
      "name": "index",
      "source": "bitcoin",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:bitcoin.src.interfaces.provider",
      "name": "provider",
      "source": "bitcoin",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "IBitcoinProvider",
          "definition": "export interface IBitcoinProvider {\n  fetchAddress(address: string): Promise<AddressInfo>;\n  fetchAddressTransactions(\n    address: string,\n    last_seen_txid?: string\n  ): Promise<TransactionsInfo[]>;\n  fetchAddressUTxOs(address: string): Promise<UTxO[]>;\n  fetchScript(hash: string): Promise<ScriptInfo>;\n  fetchScriptTransactions(\n    hash: string,\n    last_seen_txid?: string\n  ): Promise<TransactionsInfo[]>;\n  fetchScriptUTxOs(hash: string): Promise<UTxO[]>;\n  fetchTransactionStatus(txid: string): Promise<TransactionsStatus>;\n  submitTx(tx: string): Promise<string>;\n}",
          "isExported": true,
          "importPath": "offchain/bitcoin/src/interfaces/provider.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:bitcoin.src.interfaces.wallet",
      "name": "wallet",
      "source": "bitcoin",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "IBitcoinWallet",
          "definition": "export interface IBitcoinWallet {\n  getChangeAddress(): Promise<string>;\n  getNetworkId(): Promise<0 | 1>;\n  signTx(signedTx: string): Promise<string>;\n  submitTx(tx: string): Promise<string>;\n}",
          "isExported": true,
          "importPath": "offchain/bitcoin/src/interfaces/wallet.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:bitcoin.src.providers.blockstream",
      "name": "blockstream",
      "source": "bitcoin",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "BlockstreamProvider",
          "documentation": "https://github.com/Blockstream/esplora/blob/master/API.md",
          "isExported": true,
          "importPath": "offchain/bitcoin/src/providers/blockstream.ts",
          "extends": null,
          "implements": [
            "IBitcoinProvider"
          ],
          "methods": [
            {
              "name": "fetchAddress",
              "signature": "async fetchAddress(address: string): Promise<AddressInfo> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `/address/${address}`\n      );\n\n      if (status === 200) return data as AddressInfo;\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Get information about an address.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressTransactions",
              "signature": "async fetchAddressTransactions(\n    address: string,\n    last_seen_txid?: string\n  ): Promise<TransactionsInfo[]> {\n    try {\n      const url = last_seen_txid\n        ? `/address/${address}/txs/chain/${last_seen_txid}`\n        : `/address/${address}/txs`;\n      const { data, status } = await this._axiosInstance.get(url);\n\n      if (status === 200) return data as TransactionsInfo[];\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Get transaction history for the specified address, sorted with newest first.\nReturns up to 50 mempool transactions plus the first 25 confirmed transactions. You can request more confirmed transactions using `last_seen_txid`.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressUTxOs",
              "signature": "async fetchAddressUTxOs(address: string): Promise<UTxO[]> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `/address/${address}/utxo`\n      );\n\n      if (status === 200) return data as UTxO[];\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Get the list of unspent transaction outputs associated with the address.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchScript",
              "signature": "async fetchScript(hash: string): Promise<ScriptInfo> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `/scripthash/${hash}`\n      );\n\n      if (status === 200) return data as ScriptInfo;\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Get information about a scripthash.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchScriptTransactions",
              "signature": "async fetchScriptTransactions(\n    hash: string,\n    last_seen_txid?: string\n  ): Promise<TransactionsInfo[]> {\n    try {\n      const url = last_seen_txid\n        ? `/scripthash/${hash}/txs/chain/${last_seen_txid}`\n        : `/scripthash/${hash}/txs`;\n      const { data, status } = await this._axiosInstance.get(url);\n\n      if (status === 200) return data as TransactionsInfo[];\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Get transaction history for the specified scripthash, sorted with newest first.\nReturns up to 50 mempool transactions plus the first 25 confirmed transactions. You can request more confirmed transactions using `last_seen_txid`.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchScriptUTxOs",
              "signature": "async fetchScriptUTxOs(hash: string): Promise<UTxO[]> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `/scripthash/${hash}/utxo`\n      );\n\n      if (status === 200) return data as UTxO[];\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Get the list of unspent transaction outputs associated with the scripthash.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchTransactionStatus",
              "signature": "async fetchTransactionStatus(txid: string): Promise<TransactionsStatus> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `/tx/${txid}/status`\n      );\n\n      if (status === 200) return data as TransactionsStatus;\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetches the status of a transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "submitTx",
              "signature": "async submitTx(tx: string): Promise<string> {\n    try {\n      const { data, status } = await this._axiosInstance.post(\"/tx\", tx, {\n        headers: { \"Content-Type\": \"text/plain\" },\n      });\n\n      if (status === 200) return data as string;\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Broadcast a raw transaction to the network.\nThe transaction should be provided as hex in the request body. The txid will be returned on success.",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "_axiosInstance",
              "type": "AxiosInstance",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:bitcoin.src.providers.common",
      "name": "common",
      "source": "bitcoin",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:bitcoin.src.providers.index",
      "name": "index",
      "source": "bitcoin",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:bitcoin.src.types.address-info",
      "name": "address-info",
      "source": "bitcoin",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "AddressInfo",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/address-info\").AddressInfo",
          "isExported": true,
          "importPath": "offchain/bitcoin/src/types/address-info.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:bitcoin.src.types.address",
      "name": "address",
      "source": "bitcoin",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Address",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/address\").Address",
          "isExported": true,
          "importPath": "offchain/bitcoin/src/types/address.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:bitcoin.src.types.chain-stats",
      "name": "chain-stats",
      "source": "bitcoin",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "ChainStats",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/chain-stats\").ChainStats",
          "isExported": true,
          "importPath": "offchain/bitcoin/src/types/chain-stats.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:bitcoin.src.types.index",
      "name": "index",
      "source": "bitcoin",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:bitcoin.src.types.mempool-stats",
      "name": "mempool-stats",
      "source": "bitcoin",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "MempoolStats",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/mempool-stats\").MempoolStats",
          "isExported": true,
          "importPath": "offchain/bitcoin/src/types/mempool-stats.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:bitcoin.src.types.script-info",
      "name": "script-info",
      "source": "bitcoin",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "ScriptInfo",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/script-info\").ScriptInfo",
          "isExported": true,
          "importPath": "offchain/bitcoin/src/types/script-info.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:bitcoin.src.types.transactions-info",
      "name": "transactions-info",
      "source": "bitcoin",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "TransactionsInfo",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/transactions-info\").TransactionsInfo",
          "isExported": true,
          "importPath": "offchain/bitcoin/src/types/transactions-info.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:bitcoin.src.types.transactions-status",
      "name": "transactions-status",
      "source": "bitcoin",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "TransactionsStatus",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/transactions-status\").TransactionsStatus",
          "isExported": true,
          "importPath": "offchain/bitcoin/src/types/transactions-status.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:bitcoin.src.types.utxo",
      "name": "utxo",
      "source": "bitcoin",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "UTxO",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/utxo\").UTxO",
          "isExported": true,
          "importPath": "offchain/bitcoin/src/types/utxo.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:bitcoin.src.utils.address",
      "name": "address",
      "source": "bitcoin",
      "description": "",
      "functions": [
        {
          "name": "resolveAddress",
          "signature": "export function resolveAddress(\n  publicKey: string | Buffer,\n  network: \"mainnet\" | \"testnet\" | bitcoin.networks.Network\n): Address {\n  const p2wpkh = bitcoin.payments.p2wpkh({\n    pubkey:\n      typeof publicKey === \"string\" ? Buffer.from(publicKey, \"hex\") : publicKey,\n    network:\n      network === \"mainnet\"\n        ? bitcoin.networks.bitcoin\n        : network === \"testnet\"\n          ? bitcoin.networks.testnet\n          : network,\n  });\n\n  if (!p2wpkh?.address) {\n    throw new Error(\"Address is not initialized.\");\n  }\n\n  const pubKeyHex = Buffer.isBuffer(publicKey)\n    ? publicKey.toString(\"hex\")\n    : publicKey;\n\n  return {\n    address: p2wpkh.address,\n    publicKey: pubKeyHex,\n    purpose: \"payment\",\n    addressType: \"p2wpkh\",\n  };\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "publicKey",
              "type": "string | Buffer<ArrayBufferLike>",
              "optional": false
            },
            {
              "name": "network",
              "type": "any",
              "optional": false
            }
          ],
          "returnType": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/address\").Address",
          "isExported": true,
          "importPath": "offchain/bitcoin/src/utils/address.ts"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:bitcoin.src.utils.index",
      "name": "index",
      "source": "bitcoin",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:bitcoin.src.wallets.index",
      "name": "index",
      "source": "bitcoin",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.constants.cost-models",
      "name": "cost-models",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.constants.index",
      "name": "index",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.constants.language-views",
      "name": "language-views",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.constants.protocol-parameters",
      "name": "protocol-parameters",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.constants.supported-wallets",
      "name": "supported-wallets",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.data.index",
      "name": "index",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "PlutusDataType",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/index\").PlutusDataType",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/index.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.data.parser",
      "name": "parser",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.data.time",
      "name": "time",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "SlotConfig",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/time\").SlotConfig",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/time.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.data.value",
      "name": "value",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Value",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").Value",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/value.ts",
          "documentation": "Aiken alias\nValue is the JSON representation of Cardano data Value"
        },
        {
          "name": "MValue",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MValue",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/value.ts",
          "documentation": "Aiken alias\nMValue is the Cardano data Value in Mesh Data type"
        }
      ],
      "classes": [
        {
          "name": "MeshValue",
          "documentation": "MeshValue provide utility to handle the Cardano value manipulation. It offers certain axioms:\n1. No duplication of asset - adding assets with same asset name will increase the quantity of the asset in the same record.\n2. No zero and negative entry - the quantity of the asset should not be zero or negative.\n3. Sanitization of lovelace asset name - the class handle back and forth conversion of lovelace asset name to empty string.\n4. Easy convertion to Cardano data - offer utility to convert into either Mesh Data type and JSON type for its Cardano data representation.",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/value.ts",
          "extends": null,
          "implements": [],
          "methods": [],
          "properties": [
            {
              "name": "value",
              "type": "Record<string, bigint>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fromAssets",
              "type": "(assets: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset\").Asset[]) => import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue",
              "documentation": "Converting assets into MeshValue",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "fromValue",
              "type": "(plutusValue: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").Value) => import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue",
              "documentation": "Converting Value (the JSON representation of Cardano data Value) into MeshValue",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "addAsset",
              "type": "(asset: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset\").Asset) => this",
              "documentation": "Add an asset to the Value class's value record.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "addAssets",
              "type": "(assets: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset\").Asset[]) => this",
              "documentation": "Add an array of assets to the Value class's value record.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "negateAsset",
              "type": "(asset: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset\").Asset) => this",
              "documentation": "Substract an asset from the Value class's value record.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "negateAssets",
              "type": "(assets: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset\").Asset[]) => this",
              "documentation": "Subtract an array of assets from the Value class's value record.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "get",
              "type": "(unit: string) => bigint",
              "documentation": "Get the quantity of asset object per unit",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getPolicyAssets",
              "type": "(policyId: string) => import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset\").Asset[]",
              "documentation": "Get all assets that belong to a specific policy ID",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "units",
              "type": "() => string[]",
              "documentation": "Get all asset units",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "geq",
              "type": "(other: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue) => boolean",
              "documentation": "Check if the value is greater than or equal to another value",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "geqUnit",
              "type": "(unit: string, other: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue) => boolean",
              "documentation": "Check if the specific unit of value is greater than or equal to that unit of another value",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "leq",
              "type": "(other: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue) => boolean",
              "documentation": "Check if the value is less than or equal to another value",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "leqUnit",
              "type": "(unit: string, other: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue) => boolean",
              "documentation": "Check if the specific unit of value is less than or equal to that unit of another value",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "eq",
              "type": "(other: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue) => boolean",
              "documentation": "Check if the value is equal to another value",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "eqUnit",
              "type": "(unit: string, other: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue) => boolean",
              "documentation": "Check if the specific unit of value is equal to that unit of another value",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "isEmpty",
              "type": "() => boolean",
              "documentation": "Check if the value is empty",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "merge",
              "type": "(values: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue | import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue[]) => this",
              "documentation": "Merge the given values",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "toAssets",
              "type": "() => import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset\").Asset[]",
              "documentation": "Convert the MeshValue object into an array of Asset",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "toData",
              "type": "() => import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MValue",
              "documentation": "Convert the MeshValue object into Cardano data Value in Mesh Data type",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "toJSON",
              "type": "() => import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").Value",
              "documentation": "Convert the MeshValue object into a JSON representation of Cardano data Value",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-common.src.interfaces.evaluator",
      "name": "evaluator",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "IEvaluator",
          "definition": "export interface IEvaluator {\n  evaluateTx(\n    tx: string,\n    additionalUtxos?: UTxO[],\n    additionalTxs?: string[],\n  ): Promise<Omit<Action, \"data\">[]>;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/interfaces/evaluator.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.interfaces.fetcher",
      "name": "fetcher",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "IFetcherOptions",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/interfaces/fetcher\").IFetcherOptions",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/interfaces/fetcher.ts",
          "documentation": ""
        },
        {
          "name": "IFetcher",
          "definition": "export interface IFetcher {\n  fetchAccountInfo(address: string): Promise<AccountInfo>;\n  fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;\n  fetchAddressTxs(\n    address: string,\n    options?: IFetcherOptions,\n  ): Promise<TransactionInfo[]>;\n  fetchAssetAddresses(\n    asset: string,\n  ): Promise<{ address: string; quantity: string }[]>;\n  fetchAssetMetadata(asset: string): Promise<AssetMetadata>;\n  fetchBlockInfo(hash: string): Promise<BlockInfo>;\n  fetchCollectionAssets(\n    policyId: string,\n    cursor?: number | string,\n  ): Promise<{ assets: Asset[]; next?: string | number | null }>;\n  fetchProtocolParameters(epoch: number): Promise<Protocol>;\n  fetchTxInfo(hash: string): Promise<TransactionInfo>;\n  fetchUTxOs(hash: string, index?: number): Promise<UTxO[]>;\n  fetchGovernanceProposal(\n    txHash: string,\n    certIndex: number,\n  ): Promise<GovernanceProposalInfo>;\n  get(url: string): Promise<any>;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/interfaces/fetcher.ts",
          "documentation": "Fetcher interface defines end points to query blockchain data."
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.interfaces.index",
      "name": "index",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.interfaces.initiator",
      "name": "initiator",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "IInitiator",
          "definition": "export interface IInitiator {\n  getChangeAddress(): Promise<string>;\n  getCollateral(): Promise<UTxO[]>;\n  getUtxos(): Promise<UTxO[]>;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/interfaces/initiator.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.interfaces.listener",
      "name": "listener",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "IListener",
          "definition": "export interface IListener {\n  onTxConfirmed(txHash: string, callback: () => void, limit?: number): void;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/interfaces/listener.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.interfaces.serializer",
      "name": "serializer",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "IMeshTxSerializer",
          "definition": "export interface IMeshTxSerializer {\n  serializeTxBody(\n    txBuilderBody: MeshTxBuilderBody,\n    protocolParams: Protocol,\n  ): string;\n  serializeTxBodyWithMockSignatures(\n    txBuilderBody: MeshTxBuilderBody,\n    protocolParams: Protocol,\n  ): string;\n  addSigningKeys(txHex: string, signingKeys: string[]): string;\n  serializeData(data: BuilderData): string;\n  serializeAddress(address: DeserializedAddress, networkId?: 0 | 1): string;\n  serializePoolId(hash: string): string;\n  serializeRewardAddress(\n    stakeKeyHash: string,\n    isScriptHash?: boolean,\n    network_id?: 0 | 1,\n  ): string;\n  serializeOutput(output: Output): string;\n  serializeValue(value: Asset[]): string;\n  resolver: IResolver;\n  deserializer: IDeserializer;\n  parser: ITxParser;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/interfaces/serializer.ts",
          "documentation": ""
        },
        {
          "name": "ITxParser",
          "definition": "export interface ITxParser {\n  getRequiredInputs(txHex: string): TxInput[];\n  parse(txHex: string, resolvedUtxos?: UTxO[]): void;\n  toTester(): TxTester;\n  getBuilderBody(): MeshTxBuilderBody;\n  getBuilderBodyWithoutChange(): MeshTxBuilderBody;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/interfaces/serializer.ts",
          "documentation": ""
        },
        {
          "name": "IResolver",
          "definition": "export interface IResolver {\n  keys: {\n    resolvePrivateKey(words: string[]): string;\n    resolveRewardAddress(bech32: string): string;\n    resolveEd25519KeyHash(bech32: string): string;\n    resolveStakeKeyHash(bech32: string): string;\n  };\n  tx: {\n    resolveTxHash(txHex: string): string;\n  };\n  data: {\n    resolveDataHash(\n      rawData: BuilderData[\"content\"],\n      type?: PlutusDataType,\n    ): string;\n  };\n  script: {\n    resolveScriptRef(script: NativeScript | PlutusScript): string;\n  };\n}",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/interfaces/serializer.ts",
          "documentation": ""
        },
        {
          "name": "IDeserializer",
          "definition": "export interface IDeserializer {\n  key: {\n    deserializeAddress(bech32: string): DeserializedAddress;\n  };\n  script: {\n    deserializeNativeScript(script: NativeScript): DeserializedScript;\n    deserializePlutusScript(script: PlutusScript): DeserializedScript;\n  };\n  cert: {\n    deserializePoolId(poolId: string): string;\n  };\n}",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/interfaces/serializer.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.interfaces.signer",
      "name": "signer",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "ISigner",
          "definition": "export interface ISigner {\n  signData(payload: string, address?: string): Promise<DataSignature>;\n  signTx(unsignedTx: string, partialSign?: boolean): Promise<string>;\n  signTxs(unsignedTxs: string[], partialSign?: boolean): Promise<string[]>;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/interfaces/signer.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.interfaces.submitter",
      "name": "submitter",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "ISubmitter",
          "definition": "export interface ISubmitter {\n  submitTx(tx: string): Promise<string>;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/interfaces/submitter.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.interfaces.wallet",
      "name": "wallet",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "IWallet",
          "definition": "export interface IWallet extends IInitiator, ISigner, ISubmitter {\n  getAssets(): Promise<AssetExtended[]>;\n  getBalance(): Promise<Asset[]>;\n  getExtensions(): Promise<number[]>;\n  getUsedAddresses(): Promise<string[]>;\n  getLovelace(): Promise<string>;\n  getNetworkId(): Promise<number>;\n  getRewardAddresses(): Promise<string[]>;\n  getDRep(): Promise<\n    | {\n        publicKey: string;\n        publicKeyHash: string;\n        dRepIDCip105: string;\n      }\n    | undefined\n  >;\n  getUnusedAddresses(): Promise<string[]>;\n  getPolicyIdAssets(policyId: string): Promise<AssetExtended[]>;\n  getPolicyIds(): Promise<string[]>;\n  getRegisteredPubStakeKeys(): Promise<\n    | {\n        pubStakeKeys: string[];\n        pubStakeKeyHashes: string[];\n      }\n    | undefined\n  >;\n  getUnregisteredPubStakeKeys(): Promise<\n    | {\n        pubStakeKeys: string[];\n        pubStakeKeyHashes: string[];\n      }\n    | undefined\n  >;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/interfaces/wallet.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.tx-tester.index",
      "name": "index",
      "source": "mesh-common",
      "description": "",
      "functions": [
        {
          "name": "keySignedLogic",
          "signature": "export function keySignedLogic(\n  requiredSignatures: string[],\n  keyHash: string,\n): boolean {\n  return (\n    requiredSignatures?.some((signatory: string) => signatory === keyHash) ||\n    false\n  );\n}",
          "documentation": "Internal logic to check if a key is signed",
          "parameters": [
            {
              "name": "requiredSignatures",
              "type": "string[]",
              "optional": false
            },
            {
              "name": "keyHash",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "boolean",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/tx-tester/index.ts"
        },
        {
          "name": "tokenMintedLogic",
          "signature": "export function tokenMintedLogic(\n  mints: MintParam[],\n  policyId: string,\n  assetName: string,\n  quantity: number,\n): boolean {\n  return (\n    mints?.some((token) => {\n      return (\n        token.policyId === policyId &&\n        token.mintValue.findIndex(\n          (m) =>\n            m.assetName === assetName && BigInt(m.amount) === BigInt(quantity),\n        ) >= 0\n      );\n    }) || false\n  );\n}",
          "documentation": "Internal logic to check if a token is minted",
          "parameters": [
            {
              "name": "mints",
              "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/mint\").MintParam[]",
              "optional": false
            },
            {
              "name": "policyId",
              "type": "string",
              "optional": false
            },
            {
              "name": "assetName",
              "type": "string",
              "optional": false
            },
            {
              "name": "quantity",
              "type": "number",
              "optional": false
            }
          ],
          "returnType": "boolean",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/tx-tester/index.ts"
        }
      ],
      "types": [],
      "classes": [
        {
          "name": "TxTester",
          "documentation": "TxTester class for evaluating transactions",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/tx-tester/index.ts",
          "extends": null,
          "implements": [],
          "methods": [
            {
              "name": "addTrace",
              "signature": "addTrace(funcName: string, message: string): void {\n    const msg = `[Error - ${funcName}]: ${message}`;\n    this.traces.push(msg);\n  }",
              "documentation": "Add a trace to the TxTester",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "success",
              "signature": "success(): boolean {\n    return this.traces.length === 0;\n  }",
              "documentation": "Check if the transaction evaluation was successful",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "errors",
              "signature": "errors(): string {\n    if (this.traces.length > 0) {\n      return `${this.traces}`;\n    } else {\n      return \"No errors\";\n    }\n  }",
              "documentation": "Get the error messages if any",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "txBody",
              "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/index\").MeshTxBuilderBody",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "inputsEvaluating",
              "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/txin\").TxIn[]",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "outputsEvaluating",
              "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/output\").Output[]",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "traces",
              "type": "string[]",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "validAfter",
              "type": "(requiredTimestamp: number) => this",
              "documentation": "Checks if the transaction is valid after a specified timestamp.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "validBefore",
              "type": "(requiredTimestamp: number) => this",
              "documentation": "Checks if the transaction is valid before a specified timestamp.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "keySigned",
              "type": "(keyHash: string) => this",
              "documentation": "Checks if a specific key is signed in the transaction.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "oneOfKeysSigned",
              "type": "(keyHashes: string[]) => this",
              "documentation": "Checks if any one of the specified keys is signed in the transaction.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "allKeysSigned",
              "type": "(keyHashes: string[]) => this",
              "documentation": "Checks if all specified keys are signed in the transaction.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "tokenMinted",
              "type": "(policyId: string, assetName: string, quantity: number) => this",
              "documentation": "Checks if a specific token is minted in the transaction.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "onlyTokenMinted",
              "type": "(policyId: string, assetName: string, quantity: number) => this",
              "documentation": "Checks if a specific token is minted in the transaction and that it is the only mint.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "policyOnlyMintedToken",
              "type": "(policyId: string, assetName: string, quantity: number) => this",
              "documentation": "Checks if a specific token is minted in the transaction, ensuring that it is the only mint for the given policy ID.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "checkPolicyOnlyBurn",
              "type": "(policyId: string) => boolean",
              "documentation": "Checks if a specific policy ID is burned in the transaction, ensuring that it is the only minting (i.e. burning item).",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "allInputs",
              "type": "() => this",
              "documentation": "Not apply filter to inputs",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "inputsAt",
              "type": "(address: string) => this",
              "documentation": "Filter inputs by address",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "inputsWith",
              "type": "(unit: string) => this",
              "documentation": "Filter inputs by unit",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "inputsWithPolicy",
              "type": "(policyId: string) => this",
              "documentation": "Filter inputs by policy ID",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "inputsAtWithPolicy",
              "type": "(address: string, policyId: string) => this",
              "documentation": "Filter inputs by address and policy ID",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "inputsAtWith",
              "type": "(address: string, unit: string) => this",
              "documentation": "Filter inputs by address and unit",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "inputsValue",
              "type": "(expectedValue: any) => this",
              "documentation": "Check if inputs contain the expected value.\n*Reminder - It must be called after filtering methods for inputs*",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "allOutputs",
              "type": "() => this",
              "documentation": "Not apply filter to outputs",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "outputsAt",
              "type": "(address: string) => this",
              "documentation": "Filter outputs by address",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "outputsWith",
              "type": "(unit: string) => this",
              "documentation": "Filter outputs by unit",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "outputsWithPolicy",
              "type": "(policyId: string) => this",
              "documentation": "Filter outputs by policy ID",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "outputsAtWithPolicy",
              "type": "(address: string, policyId: string) => this",
              "documentation": "Filter outputs by address and policy ID",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "outputsAtWith",
              "type": "(address: string, unit: string) => this",
              "documentation": "Filter outputs by address and unit",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "outputsValue",
              "type": "(expectedValue: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue) => this",
              "documentation": "Check if outputs contain the expected value.\n*Reminder - It must be called after filtering methods for outputs*",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "outputsInlineDatumExist",
              "type": "(datumCbor: string) => this",
              "documentation": "Check if outputs contain a specific inline datum.\n*Reminder - It must be called after filtering methods for outputs*",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-common.src.types.account-info",
      "name": "account-info",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "AccountInfo",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/account-info\").AccountInfo",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/account-info.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.action",
      "name": "action",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "RedeemerTagType",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/action\").RedeemerTagType",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/action.ts",
          "documentation": ""
        },
        {
          "name": "Action",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/action\").Action",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/action.ts",
          "documentation": ""
        },
        {
          "name": "Budget",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/action\").Budget",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/action.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.asset-extended",
      "name": "asset-extended",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "AssetExtended",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset-extended\").AssetExtended",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/asset-extended.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.asset-metadata",
      "name": "asset-metadata",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "RoyaltiesStandard",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset-metadata\").RoyaltiesStandard",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/asset-metadata.ts",
          "documentation": ""
        },
        {
          "name": "Files",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset-metadata\").Files",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/asset-metadata.ts",
          "documentation": ""
        },
        {
          "name": "AssetMetadata",
          "definition": "any",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/asset-metadata.ts",
          "documentation": ""
        },
        {
          "name": "FungibleAssetMetadata",
          "definition": "any",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/asset-metadata.ts",
          "documentation": ""
        },
        {
          "name": "NonFungibleAssetMetadata",
          "definition": "any",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/asset-metadata.ts",
          "documentation": ""
        },
        {
          "name": "ImageAssetMetadata",
          "definition": "any",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/asset-metadata.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.asset",
      "name": "asset",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Asset",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset\").Asset",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/asset.ts",
          "documentation": ""
        },
        {
          "name": "Unit",
          "definition": "string",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/asset.ts",
          "documentation": ""
        },
        {
          "name": "Quantity",
          "definition": "string",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/asset.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.block-info",
      "name": "block-info",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "BlockInfo",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/block-info\").BlockInfo",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/block-info.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.data-signature",
      "name": "data-signature",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "DataSignature",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/data-signature\").DataSignature",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/data-signature.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.data",
      "name": "data",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Data",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/data\").Data",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/data.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.era",
      "name": "era",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Era",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/era\").Era",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/era.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.extension",
      "name": "extension",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Extension",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/extension\").Extension",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/extension.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.governance",
      "name": "governance",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "GovernanceProposalInfo",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/governance\").GovernanceProposalInfo",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/governance.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.index",
      "name": "index",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.message",
      "name": "message",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Message",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/message\").Message",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/message.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.mint",
      "name": "mint",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Mint",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/mint\").Mint",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/mint.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.native-script",
      "name": "native-script",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "NativeScript",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/native-script\").NativeScript",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/native-script.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.network",
      "name": "network",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Network",
          "definition": "\"mainnet\" | \"preview\" | \"preprod\" | \"testnet\"",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/network.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.plutus-script",
      "name": "plutus-script",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "PlutusScript",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/plutus-script\").PlutusScript",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/plutus-script.ts",
          "documentation": ""
        },
        {
          "name": "LanguageVersion",
          "definition": "\"V1\" | \"V2\" | \"V3\"",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/plutus-script.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.pool-params",
      "name": "pool-params",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "PoolParams",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/pool-params\").PoolParams",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/pool-params.ts",
          "documentation": ""
        },
        {
          "name": "PoolMetadata",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/pool-params\").PoolMetadata",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/pool-params.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.protocol",
      "name": "protocol",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Protocol",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/protocol\").Protocol",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/protocol.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.recipient",
      "name": "recipient",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Recipient",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/recipient\").Recipient",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/recipient.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.relay",
      "name": "relay",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Relay",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/relay\").Relay",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/relay.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.token",
      "name": "token",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Token",
          "definition": "\"LQ\" | \"MIN\" | \"NTX\" | \"iBTC\" | \"iETH\" | \"iUSD\" | \"MILK\" | \"AGIX\" | \"MELD\" | \"INDY\" | \"CLAY\" | \"MCOS\" | \"DING\" | \"GERO\" | \"NMKR\" | \"PAVIA\" | \"HOSKY\" | \"YUMMI\" | \"C3\" | \"GIMBAL\" | \"SUNDAE\" | \"GREENS\" | \"GENS\" | \"SOCIETY\" | \"DJED\" | \"SHEN\" | \"WMT\" | \"COPI\"",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/token.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.transaction-info",
      "name": "transaction-info",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "TransactionInfo",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-info\").TransactionInfo",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-info.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.utxo",
      "name": "utxo",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "TxOutput",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/utxo\").TxOutput",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/utxo.ts",
          "documentation": ""
        },
        {
          "name": "TxInput",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/utxo\").TxInput",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/utxo.ts",
          "documentation": ""
        },
        {
          "name": "UTxO",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/utxo\").UTxO",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/utxo.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.wallet",
      "name": "wallet",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Wallet",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/wallet\").Wallet",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/wallet.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.utils.asset-fingerprint",
      "name": "asset-fingerprint",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "AssetFingerprint",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/utils/asset-fingerprint.ts",
          "extends": null,
          "implements": [],
          "methods": [
            {
              "name": "fromHash",
              "signature": "static fromHash(hash: Uint8Array): AssetFingerprint {\n    return new AssetFingerprint(hash);\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "fromParts",
              "signature": "static fromParts(\n    policyId: Uint8Array,\n    assetName: Uint8Array,\n  ): AssetFingerprint {\n    // see https://github.com/cardano-foundation/CIPs/pull/64\n    const hashBuf = blake2b(20)\n      .update(new Uint8Array([...policyId, ...assetName]))\n      .digest(\"binary\");\n\n    return AssetFingerprint.fromHash(hashBuf);\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "fromBech32",
              "signature": "static fromBech32(fingerprint: string): AssetFingerprint {\n    const { prefix, words } = bech32.decode(fingerprint);\n    if (prefix !== DATA) {\n      throw new Error(\"Invalid asset fingerprint\");\n    }\n\n    const hashBuf = Buffer.from(bech32.fromWords(words));\n    return AssetFingerprint.fromHash(hashBuf);\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "fingerprint",
              "signature": "fingerprint(): string {\n    const words = bech32.toWords(this.hashBuf);\n    return bech32.encode(DATA, words);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "hash",
              "signature": "hash(): string {\n    return Buffer.from(this.hashBuf).toString(\"hex\");\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "prefix",
              "signature": "prefix(): string {\n    return DATA;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "checksum",
              "signature": "checksum(): string {\n    return this.fingerprint().slice(-6);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "hashBuf",
              "type": "Uint8Array<ArrayBufferLike>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-common.src.utils.big-num",
      "name": "big-num",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "BigNum",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/utils/big-num.ts",
          "extends": null,
          "implements": [],
          "methods": [
            {
              "name": "new",
              "signature": "static new(value: number | string | bigint | undefined): BigNum {\n    if (!value) {\n      return new BigNum(0);\n    }\n    return new BigNum(value);\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "divFloor",
              "signature": "divFloor(other: BigNum): BigNum {\n    this.value = this.value / other.value;\n    return this;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "checkedMul",
              "signature": "checkedMul(other: BigNum): BigNum {\n    this.value *= other.value;\n    return this;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "checkedAdd",
              "signature": "checkedAdd(other: BigNum): BigNum {\n    this.value += other.value;\n    return this;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "checkedSub",
              "signature": "checkedSub(other: BigNum): BigNum {\n    this.value -= other.value;\n    return this;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "clampedSub",
              "signature": "clampedSub(other: BigNum): BigNum {\n    const result = this.value - other.value;\n    this.value = result < 0n ? 0n : result;\n    return this;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "lessThan",
              "signature": "lessThan(other: BigNum): boolean {\n    return this.value < other.value;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "compare",
              "signature": "compare(other: BigNum): -1 | 0 | 1 {\n    if (this.value === other.value) {\n      return 0;\n    } else if (this.value < other.value) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "toString",
              "signature": "toString(): string {\n    return this.value.toString();\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "value",
              "type": "bigint",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-common.src.utils.data-hash",
      "name": "data-hash",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.utils.file",
      "name": "file",
      "source": "mesh-common",
      "description": "",
      "functions": [
        {
          "name": "getFile",
          "signature": "export function getFile(url: string) {\n  var Httpreq = new XMLHttpRequest();\n  Httpreq.open(\"GET\", url, false);\n  Httpreq.send(null);\n  return Httpreq.responseText;\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "url",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "string",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/utils/file.ts"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.utils.index",
      "name": "index",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.utxo-selection.common",
      "name": "common",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.utxo-selection.experimental",
      "name": "experimental",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.utxo-selection.index",
      "name": "index",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "UtxoSelectionStrategy",
          "definition": "keyof import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/utxo-selection/index\").UtxoSelection",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/utxo-selection/index.ts",
          "documentation": ""
        }
      ],
      "classes": [
        {
          "name": "UtxoSelection",
          "documentation": "All UTxO selection algorithms follows below's interface\n\nSupported algorithms:\n- largestFirst - CIP2 suggested algorithm\n- largestFirstMultiAsset - CIP2 suggested algorithm\n- keepRelevant - CIP2 suggested algorithm\n- experimental - The always evolving algorithm according to the latest research",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/utxo-selection/index.ts",
          "extends": null,
          "implements": [],
          "methods": [
            {
              "name": "largestFirst",
              "signature": "largestFirst(requiredAssets: Map<Unit, Quantity>, inputs: UTxO[]) {\n    const lovelaceAmount = requiredAssets.get(\"lovelace\") ?? \"0\";\n    const requiredAssetWithThreshold =\n      BigInt(lovelaceAmount) + BigInt(this.threshold);\n    return largestFirst(\n      requiredAssetWithThreshold.toString(),\n      inputs,\n      this.includeTxFees,\n    );\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "keepRelevant",
              "signature": "keepRelevant(requiredAssets: Map<Unit, Quantity>, inputs: UTxO[]) {\n    return keepRelevant(requiredAssets, inputs, this.threshold);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "largestFirstMultiAsset",
              "signature": "largestFirstMultiAsset(requiredAssets: Map<Unit, Quantity>, inputs: UTxO[]) {\n    const lovelaceAmount = requiredAssets.get(\"lovelace\") ?? \"0\";\n    requiredAssets.set(\n      \"lovelace\",\n      (BigInt(lovelaceAmount) + BigInt(this.threshold)).toString(),\n    );\n    return largestFirstMultiAsset(requiredAssets, inputs, this.includeTxFees);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "experimental",
              "signature": "experimental(requiredAssets: Map<Unit, Quantity>, inputs: UTxO[]) {\n    return experimentalSelectUtxos(requiredAssets, inputs, this.threshold);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "threshold",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "includeTxFees",
              "type": "boolean",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-common.src.utxo-selection.keepRelevant",
      "name": "keepRelevant",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.utxo-selection.largestFirst",
      "name": "largestFirst",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.utxo-selection.largestFirstMultiAsset",
      "name": "largestFirstMultiAsset",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-contract.src.asteria.index",
      "name": "index",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-contract.src.asteria.offchain",
      "name": "offchain",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "MeshAsteriaContract",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/asteria/offchain.ts",
          "extends": "MeshTxInitiator",
          "implements": [],
          "methods": [],
          "properties": []
        }
      ]
    },
    {
      "key": "offchain:mesh-contract.src.content-ownership.index",
      "name": "index",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-contract.src.escrow.index",
      "name": "index",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-contract.src.escrow.offchain",
      "name": "offchain",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "InitiationDatum",
          "definition": "ConStr0<[PubKeyAddress, Value]>",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/escrow/offchain.ts",
          "documentation": ""
        },
        {
          "name": "ActiveEscrowDatum",
          "definition": "ConStr1<[PubKeyAddress, Value, PubKeyAddress, Value]>",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/escrow/offchain.ts",
          "documentation": ""
        },
        {
          "name": "RecipientDepositRedeemer",
          "definition": "ConStr0<[PubKeyAddress, Value]>",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/escrow/offchain.ts",
          "documentation": ""
        }
      ],
      "classes": [
        {
          "name": "MeshEscrowContract",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/escrow/offchain.ts",
          "extends": "MeshTxInitiator",
          "implements": [],
          "methods": [],
          "properties": [
            {
              "name": "scriptCbor",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "scriptAddress",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getScriptCbor",
              "type": "() => any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "initiateEscrow",
              "type": "(escrowAmount: Asset[]) => Promise<string>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "cancelEscrow",
              "type": "(escrowUtxo: UTxO) => Promise<string>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "recipientDeposit",
              "type": "(escrowUtxo: UTxO, depositAmount: Asset[]) => Promise<string>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "completeEscrow",
              "type": "(escrowUtxo: UTxO) => Promise<string>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUtxoByTxHash",
              "type": "(txHash: string) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-contract.src.giftcard.index",
      "name": "index",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-contract.src.giftcard.offchain",
      "name": "offchain",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "MeshGiftCardContract",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/giftcard/offchain.ts",
          "extends": "MeshTxInitiator",
          "implements": [],
          "methods": [],
          "properties": [
            {
              "name": "tokenNameHex",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "paramUtxo",
              "type": "UTxO",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "giftCardCbor",
              "type": "(tokenNameHex: string, utxoTxHash: string, utxoTxId: number) => any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "redeemCbor",
              "type": "(tokenNameHex: string, policyId: string) => any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "createGiftCard",
              "type": "(tokenName: string, giftValue: Asset[]) => Promise<string>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "redeemGiftCard",
              "type": "(giftCardUtxo: UTxO) => Promise<string>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUtxoByTxHash",
              "type": "(txHash: string) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-contract.src.hello-world.index",
      "name": "index",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-contract.src.hello-world.offchain",
      "name": "offchain",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "HelloWorldDatum",
          "definition": "ConStr0<[Integer, BuiltinByteString, BuiltinByteString]>",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/hello-world/offchain.ts",
          "documentation": ""
        }
      ],
      "classes": [
        {
          "name": "MeshHelloWorldContract",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/hello-world/offchain.ts",
          "extends": "MeshTxInitiator",
          "implements": [],
          "methods": [],
          "properties": [
            {
              "name": "scriptCbor",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "scriptAddress",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getScriptCbor",
              "type": "() => any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "lockAsset",
              "type": "(assets: Asset[]) => Promise<string>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "unlockAsset",
              "type": "(scriptUtxo: UTxO, message: string) => Promise<string>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUtxoByTxHash",
              "type": "(txHash: string) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-contract.src.marketplace.index",
      "name": "index",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-contract.src.marketplace.offchain",
      "name": "offchain",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "MarketplaceDatum",
          "definition": "ConStr0<[PubKeyAddress, Integer, CurrencySymbol, TokenName]>",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/marketplace/offchain.ts",
          "documentation": ""
        }
      ],
      "classes": [
        {
          "name": "MeshMarketplaceContract",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/marketplace/offchain.ts",
          "extends": "MeshTxInitiator",
          "implements": [],
          "methods": [],
          "properties": [
            {
              "name": "ownerAddress",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "feePercentageBasisPoint",
              "type": "number",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "scriptCbor",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "scriptAddress",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getScriptCbor",
              "type": "(pubKeyHash: string, stakeCredentialHash: string, feePercentageBasisPoint: number) => any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "listAsset",
              "type": "(asset: string, price: number) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "delistAsset",
              "type": "(marketplaceUtxo: UTxO) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "purchaseAsset",
              "type": "(marketplaceUtxo: UTxO) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "relistAsset",
              "type": "(marketplaceUtxo: UTxO, newPrice: number) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUtxoByTxHash",
              "type": "(txHash: string) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getCompiledCode",
              "type": "(version?: number) => string",
              "documentation": "",
              "static": true,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-contract.src.payment-splitter.index",
      "name": "index",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-contract.src.payment-splitter.offchain",
      "name": "offchain",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "MeshPaymentSplitterContract",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/payment-splitter/offchain.ts",
          "extends": "MeshTxInitiator",
          "implements": [],
          "methods": [],
          "properties": [
            {
              "name": "scriptCbor",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "scriptAddress",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "payees",
              "type": "string[]",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "wrapPayees",
              "type": "(payees: string[]) => any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getScriptCbor",
              "type": "() => any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "sendLovelaceToSplitter",
              "type": "(lovelaceAmount: number) => Promise<string>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "triggerPayout",
              "type": "() => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-contract.src.plutus-nft.index",
      "name": "index",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-contract.src.plutus-nft.offchain",
      "name": "offchain",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "MeshPlutusNFTContract",
          "documentation": "Mesh Plutus NFT contract class\n\nThis NFT minting script enables users to mint NFTs with an automatically incremented index, which increases by one for each newly minted NFT. \n\nTo facilitate this process, the first step is to set up a one-time minting policy by minting an oracle token. This oracle token is essential as it holds the current state and index of the NFTs, acting as a reference for the minting sequence. \n\nWith each new NFT minted, the token index within the oracle is incremented by one, ensuring a consistent and orderly progression in the numbering of the NFTs.",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/plutus-nft/offchain.ts",
          "extends": "MeshTxInitiator",
          "implements": [],
          "methods": [],
          "properties": [
            {
              "name": "collectionName",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "paramUtxo",
              "type": "UTxO",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "oracleAddress",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getOracleCbor",
              "type": "() => any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getOracleNFTCbor",
              "type": "() => any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getNFTCbor",
              "type": "() => any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "setupOracle",
              "type": "(lovelacePrice: number) => Promise<{ tx: any; paramUtxo: any; }>",
              "documentation": "Set up a one-time minting policy by minting an oracle token. This oracle token is essential as it holds the current state and index of the NFTs, acting as a reference for the minting sequence.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "mintPlutusNFT",
              "type": "(assetMetadata?: any) => Promise<any>",
              "documentation": "Mint NFT token with an automatically incremented index, which increases by one for each newly minted NFT.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getOracleData",
              "type": "() => Promise<{ nftIndex: any; policyId: any; lovelacePrice: any; oracleUtxo: any; oracleNftPolicyId: any; feeCollectorAddress: any; feeCollectorAddressObj: any; }>",
              "documentation": "Get the current oracle data.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUtxoByTxHash",
              "type": "(txHash: string) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-contract.src.plutus-nft.type",
      "name": "type",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "OracleDatum",
          "definition": "ConStr0<[Integer, Integer, PubKeyAddress]>",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/plutus-nft/type.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-contract.src.royalties.index",
      "name": "index",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-contract.src.royalties.offchain",
      "name": "offchain",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "MeshRoyaltiesContract",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/royalties/offchain.ts",
          "extends": "MeshTxInitiator",
          "implements": [],
          "methods": [],
          "properties": []
        }
      ]
    },
    {
      "key": "offchain:mesh-contract.src.swap.index",
      "name": "index",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-contract.src.swap.offchain",
      "name": "offchain",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "SwapDatum",
          "definition": "ConStr0<[PubKeyAddress, Value, Value]>",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/swap/offchain.ts",
          "documentation": ""
        }
      ],
      "classes": [
        {
          "name": "MeshSwapContract",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/swap/offchain.ts",
          "extends": "MeshTxInitiator",
          "implements": [],
          "methods": [],
          "properties": [
            {
              "name": "scriptCbor",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "scriptAddress",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getScriptCbor",
              "type": "() => any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "initiateSwap",
              "type": "(toProvide: Asset[], toReceive: Asset[]) => Promise<string>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "acceptSwap",
              "type": "(swapUtxo: UTxO) => Promise<string>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "cancelSwap",
              "type": "(swapUtxo: UTxO) => Promise<string>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUtxoByTxHash",
              "type": "(txHash: string) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-contract.src.vesting.index",
      "name": "index",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-contract.src.vesting.offchain",
      "name": "offchain",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "VestingDatum",
          "definition": "ConStr0<[Integer, BuiltinByteString, BuiltinByteString]>",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/vesting/offchain.ts",
          "documentation": ""
        }
      ],
      "classes": [
        {
          "name": "MeshVestingContract",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/vesting/offchain.ts",
          "extends": "MeshTxInitiator",
          "implements": [],
          "methods": [],
          "properties": [
            {
              "name": "scriptCbor",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "scriptAddress",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getScriptCbor",
              "type": "() => any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "depositFund",
              "type": "(amount: Asset[], lockUntilTimeStampMs: number, beneficiary: string) => Promise<string>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "withdrawFund",
              "type": "(vestingUtxo: UTxO) => Promise<string>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUtxoByTxHash",
              "type": "(txHash: string) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-core.src.utils.deserializer",
      "name": "deserializer",
      "source": "mesh-core",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core.src.utils.index",
      "name": "index",
      "source": "mesh-core",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core.src.utils.resolver",
      "name": "resolver",
      "source": "mesh-core",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core.src.utils.serializer",
      "name": "serializer",
      "source": "mesh-core",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.index",
      "name": "index",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.serializer",
      "name": "serializer",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "CSLSerializer",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-core-csl/src/core/serializer.ts",
          "extends": null,
          "implements": [
            "IMeshTxSerializer"
          ],
          "methods": [
            {
              "name": "serializeTxBody",
              "signature": "serializeTxBody(\n    txBody: MeshTxBuilderBody,\n    protocolParams?: Protocol,\n  ): string {\n    const txBodyJson = JSONbig.stringify(meshTxBuilderBodyToObj(txBody));\n    const params = JSONbig.stringify(protocolParams || this.protocolParams);\n\n    const txBuildResult = csl.js_serialize_tx_body(txBodyJson, params);\n    if (txBuildResult.get_status() !== \"success\") {\n      throw new Error(`txBuildResult error: ${txBuildResult.get_error()}`);\n    }\n    return txBuildResult.get_data();\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "addSigningKeys",
              "signature": "addSigningKeys(txHex: string, signingKeys: string[]): string {\n    if (signingKeys.length > 0) {\n      return signTransaction(txHex, signingKeys);\n    }\n    return txHex;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "serializeData",
              "signature": "serializeData(data: BuilderData): string {\n    return builderDataToCbor(data);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "serializeAddress",
              "signature": "serializeAddress(\n    address: Partial<DeserializedAddress>,\n    networkId?: number,\n  ): string {\n    return serialzeAddress(address, networkId);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "serializePoolId",
              "signature": "serializePoolId(hash: string): string {\n    return serializePoolId(hash);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "serializeRewardAddress",
              "signature": "serializeRewardAddress(\n    stakeKeyHash: string,\n    isScriptHash?: boolean,\n    network_id?: 0 | 1,\n  ): string {\n    return isScriptHash\n      ? scriptHashToRewardAddress(stakeKeyHash, network_id)\n      : keyHashToRewardAddress(stakeKeyHash, network_id);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "serializeOutput",
              "signature": "serializeOutput(output: Output): string {\n    let cslOutputBuilder = csl.TransactionOutputBuilder.new().with_address(\n      csl.Address.from_bech32(output.address),\n    );\n    if (output.datum?.type === \"Hash\") {\n      cslOutputBuilder.with_data_hash(\n        csl.hash_plutus_data(castDataToPlutusData(output.datum.data)),\n      );\n    } else if (output.datum?.type === \"Inline\") {\n      cslOutputBuilder.with_plutus_data(\n        castDataToPlutusData(output.datum.data),\n      );\n    } else if (output.datum?.type === \"Embedded\") {\n      throw new Error(\"Embedded datum not supported\");\n    }\n    if (output.referenceScript) {\n      switch (output.referenceScript.version) {\n        case \"V1\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v1(),\n              ),\n            ),\n          );\n          break;\n        }\n        case \"V2\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v2(),\n              ),\n            ),\n          );\n          break;\n        }\n        case \"V3\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v3(),\n              ),\n            ),\n          );\n          break;\n        }\n        default: {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_native_script(\n              csl.NativeScript.from_hex(output.referenceScript.code),\n            ),\n          );\n          break;\n        }\n      }\n    }\n\n    return cslOutputBuilder\n      .next()\n      .with_value(toCslValue(output.amount))\n      .build()\n      .to_hex();\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "serializeTxBodyWithMockSignatures",
              "signature": "serializeTxBodyWithMockSignatures(\n    txBuilderBody: MeshTxBuilderBody,\n    protocolParams: Protocol,\n  ): string {\n    const txHex = this.serializeTxBody(txBuilderBody, protocolParams);\n    const cslTx = csl.Transaction.from_hex(txHex);\n    const mockWitnessSet = cslTx.witness_set();\n    const mockVkeyWitnesses = mockWitnessSet.vkeys() ?? csl.Vkeywitnesses.new();\n    const mockBootstrapWitnesses =\n      mockWitnessSet.bootstraps() ?? csl.BootstrapWitnesses.new();\n    for (let i = 0; i < txBuilderBody.expectedNumberKeyWitnesses; i++) {\n      const numberInHex = this.numberToIntegerHex(i);\n      const mockVkey = csl.Vkey.new(\n        csl.PublicKey.from_hex(this.mockPubkey(numberInHex)),\n      );\n\n      const mockSignature = csl.Ed25519Signature.from_hex(\n        this.mockSignature(numberInHex),\n      );\n      mockVkeyWitnesses.add(csl.Vkeywitness.new(mockVkey, mockSignature));\n    }\n    this.meshTxBuilderBody.expectedByronAddressWitnesses.forEach(\n      (bootstrapWitness, i) => {\n        const address = csl.ByronAddress.from_base58(bootstrapWitness);\n        const numberInHex = this.numberToIntegerHex(i);\n        const pubKeyHex = this.mockPubkey(numberInHex);\n        const mockVkey = csl.Vkey.new(csl.PublicKey.from_hex(pubKeyHex));\n        const signature = this.mockSignature(numberInHex);\n        const chainCode = this.mockChainCode(numberInHex);\n        mockBootstrapWitnesses.add(\n          csl.BootstrapWitness.new(\n            mockVkey,\n            csl.Ed25519Signature.from_hex(signature),\n            Buffer.from(chainCode, \"hex\"),\n            address.attributes(),\n          ),\n        );\n      },\n    );\n    mockWitnessSet.set_vkeys(mockVkeyWitnesses);\n    mockWitnessSet.set_bootstraps(mockBootstrapWitnesses);\n    return csl.Transaction.new(\n      cslTx.body(),\n      mockWitnessSet,\n      cslTx.auxiliary_data(),\n    ).to_hex();\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "serializeValue",
              "signature": "serializeValue(value: Asset[]): string {\n    return toCslValue(value).to_hex();\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "mockPubkey",
              "signature": "private mockPubkey(numberInHex: string): string {\n    return \"0\"\n      .repeat(VKEY_PUBKEY_SIZE_BYTES * 2 - numberInHex.length)\n      .concat(numberInHex);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "mockSignature",
              "signature": "private mockSignature(numberInHex: string): string {\n    return \"0\"\n      .repeat(VKEY_SIGNATURE_SIZE_BYTES * 2 - numberInHex.length)\n      .concat(numberInHex);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ],
          "properties": [
            {
              "name": "protocolParams",
              "type": "Protocol",
              "documentation": "Set to true to enable verbose logging for the txBodyJson prior going into build",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "meshTxBuilderBody",
              "type": "MeshTxBuilderBody",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "parserTxBody",
              "type": "MeshTxBuilderBody",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "deserializer",
              "type": "IDeserializer",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "resolver",
              "type": "IResolver",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "parser",
              "type": "ITxParser",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "mockChainCode",
              "type": "(numberInHex: string) => string",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "numberToIntegerHex",
              "type": "(number: number) => string",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-core-csl.src.deser.constants",
      "name": "constants",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.deser.converter",
      "name": "converter",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.deser.csl",
      "name": "csl",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.deser.deserializer",
      "name": "deserializer",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.deser.index",
      "name": "index",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.deser.resolver",
      "name": "resolver",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.offline-providers.index",
      "name": "index",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.offline-providers.offline-evaluator",
      "name": "offline-evaluator",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "OfflineEvaluator",
          "documentation": "OfflineEvaluator implements the IEvaluator interface to provide offline evaluation of Plutus scripts.\nThis class evaluates Plutus scripts contained in Cardano transactions without requiring network connectivity,\ndetermining their execution costs in terms of memory and CPU steps.\n\nEach script evaluation returns an Action object (excluding the redeemer data) that contains:\n- tag: The type of script being executed (CERT | MINT | REWARD | SPEND | VOTE | PROPOSE)\n- index: Execution index of the script within the transaction\n- budget: Execution costs including:\n  - mem: Memory units required\n  - steps: CPU steps required\n\nExample usage:\n```typescript\nimport { OfflineEvaluator, OfflineFetcher } from '@meshsdk/core';\n\n// Create fetcher and evaluator instances\nconst fetcher = new OfflineFetcher();\nconst evaluator = new OfflineEvaluator(fetcher, 'preprod');\n\n// Add required UTXOs that the transaction references\nfetcher.addUTxOs([\n  {\n    input: {\n      txHash: \"1234...\",\n      outputIndex: 0\n    },\n    output: {\n      address: \"addr1...\",\n      amount: [{ unit: \"lovelace\", quantity: \"1000000\" }],\n      scriptHash: \"abcd...\" // If this is a script UTXO\n    }\n  }\n]);\n\n// Evaluate Plutus scripts in a transaction\ntry {\n  const actions = await evaluator.evaluateTx(transactionCbor);\n  // Example result for a minting script:\n  // [{\n  //   index: 0,\n  //   tag: \"MINT\",\n  //   budget: {\n  //     mem: 508703,    // Memory units used\n  //     steps: 164980381 // CPU steps used\n  //   }\n  // }]\n} catch (error) {\n  console.error('Plutus script evaluation failed:', error);\n}\n```",
          "isExported": true,
          "importPath": "offchain/mesh-core-csl/src/offline-providers/offline-evaluator.ts",
          "extends": null,
          "implements": [
            "IEvaluator"
          ],
          "methods": [
            {
              "name": "evaluateTx",
              "signature": "async evaluateTx(\n    tx: string,\n    additionalUtxos: UTxO[],\n    additionalTxs: string[],\n  ): Promise<Omit<Action, \"data\">[]> {\n    // Track which utxos is resolved\n    const foundUtxos = new Set<string>();\n\n    for (const utxo of additionalUtxos) {\n      foundUtxos.add(`${utxo.input.txHash}:${utxo.input.outputIndex}`);\n    }\n    for (const tx of additionalTxs) {\n      const outputs = getTransactionOutputs(tx);\n      for (const output of outputs) {\n        foundUtxos.add(`${output.input.txHash}:${output.input.outputIndex}`);\n      }\n    }\n    const inputsToResolve = getTransactionInputs(tx).filter(\n      (input) => !foundUtxos.has(`${input.txHash}:${input.outputIndex}`),\n    );\n    const txHashesSet = new Set(inputsToResolve.map((input) => input.txHash));\n    for (const txHash of txHashesSet) {\n      const utxos = await this.fetcher.fetchUTxOs(txHash);\n      for (const utxo of utxos) {\n        if (utxo)\n          if (\n            inputsToResolve.find(\n              (input) =>\n                input.txHash === txHash &&\n                input.outputIndex === utxo.input.outputIndex,\n            )\n          ) {\n            additionalUtxos.push(utxo);\n            foundUtxos.add(`${utxo.input.txHash}:${utxo.input.outputIndex}`);\n          }\n      }\n    }\n    const missing = inputsToResolve.filter(\n      (input) => !foundUtxos.has(`${input.txHash}:${input.outputIndex}`),\n    );\n    if (missing.length > 0) {\n      const missingList = missing\n        .map((m) => `${m.txHash}:${m.outputIndex}`)\n        .join(\", \");\n      throw new Error(\n        `Can't resolve these UTXOs to execute plutus scripts: ${missingList}`,\n      );\n    }\n    return evaluateTransaction(\n      tx,\n      additionalUtxos,\n      additionalTxs,\n      this.network,\n      this.slotConfig,\n    );\n  }",
              "documentation": "Evaluates Plutus scripts in a transaction by resolving its input UTXOs and calculating execution costs.\n\nThe method performs these steps:\n1. Extracts input references from the transaction\n2. Resolves the corresponding UTXOs using the fetcher\n3. Verifies all required UTXOs are available\n4. Evaluates each Plutus script to determine its memory and CPU costs",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "fetcher",
              "type": "IFetcher",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "network",
              "type": "Network",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "slotConfig",
              "type": "Omit<Omit<SlotConfig, \"startEpoch\">, \"epochLength\">",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-core-csl.src.parser.index",
      "name": "index",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "CSLParser",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-core-csl/src/parser/index.ts",
          "extends": null,
          "implements": [],
          "methods": [],
          "properties": [
            {
              "name": "resolvedUtxos",
              "type": "UTxO[]",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "txBuilderBody",
              "type": "MeshTxBuilderBody",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "txHex",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "txHash",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-core-csl.src.utils.address",
      "name": "address",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.utils.aiken",
      "name": "aiken",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.utils.credentials",
      "name": "credentials",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.utils.datum",
      "name": "datum",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.utils.drep",
      "name": "drep",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.utils.index",
      "name": "index",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.utils.scripts",
      "name": "scripts",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.utils.staking",
      "name": "staking",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.utils.transaction-parser",
      "name": "transaction-parser",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.utils.transaction",
      "name": "transaction",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.message-signing.check-signature",
      "name": "check-signature",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.message-signing.cose-sign1",
      "name": "cose-sign1",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "CoseSign1",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/message-signing/cose-sign1.ts",
          "extends": null,
          "implements": [],
          "methods": [
            {
              "name": "fromCbor",
              "signature": "static fromCbor(cbor: string) {\n    const decoded = Cbor.parse(cbor) as CborArray;\n    if (!isRawCborArray(decoded.toRawObj() as RawCborArray))\n      throw Error(\"Invalid CBOR\");\n    if (decoded.array.length !== 4) throw Error(\"Invalid COSE_SIGN1\");\n\n    let protectedMap: CborMap;\n    // Decode and Set ProtectedMap\n    const protectedSerialized = decoded.array[0] as CborBytes;\n    try {\n      protectedMap = Cbor.parse(protectedSerialized.bytes) as CborMap;\n      if (!isRawCborMap(protectedMap.toRawObj() as RawCborMap)) {\n        throw Error();\n      }\n    } catch (error) {\n      throw Error(\"Invalid protected\");\n    }\n    // Set UnProtectedMap\n    let unProtectedMap = decoded.array[1] as CborMap;\n    if (!isRawCborMap(unProtectedMap.toRawObj() as RawCborMap))\n      throw Error(\"Invalid unprotected\");\n    // Set Payload\n    const payload = decoded.array[2] as CborBytes;\n\n    // Set Signature\n    const signature = decoded.array[3] as CborBytes;\n\n    return new CoseSign1({\n      protectedMap,\n      unProtectedMap,\n      payload,\n      signature,\n    });\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "createSigStructure",
              "signature": "createSigStructure(externalAad = Buffer.alloc(0)): Buffer {\n    let protectedSerialized = new CborBytes(Buffer.alloc(0));\n\n    if (this.protectedMap.map.length !== 0) {\n      protectedSerialized = new CborBytes(\n        Cbor.encode(this.protectedMap).toBuffer(),\n      );\n    }\n\n    if (!this.payload) throw Error(\"Invalid payload\");\n\n    const structure = new CborArray([\n      new CborText(\"Signature1\"),\n      protectedSerialized,\n      new CborBytes(externalAad),\n      this.payload,\n    ]);\n\n    return Buffer.from(Cbor.encode(structure).toBuffer());\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "buildMessage",
              "signature": "buildMessage(signature: Buffer): Buffer {\n    this.signature = new CborBytes(signature);\n\n    let protectedSerialized = new CborBytes(Buffer.alloc(0));\n    if (this.protectedMap.map.length !== 0) {\n      protectedSerialized = new CborBytes(\n        Cbor.encode(this.protectedMap).toBuffer(),\n      );\n    }\n\n    if (!this.payload) throw Error(\"Invalid payload\");\n\n    const coseSign1 = new CborArray([\n      protectedSerialized,\n      this.unProtectedMap,\n      this.payload,\n      this.signature,\n    ]);\n\n    return Buffer.from(Cbor.encode(coseSign1).toBuffer());\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "verifySignature",
              "signature": "verifySignature({\n    externalAad = Buffer.alloc(0),\n    publicKeyBuffer,\n  }: {\n    externalAad?: Buffer;\n    publicKeyBuffer?: Buffer;\n  } = {}): boolean {\n    if (!publicKeyBuffer) {\n      publicKeyBuffer = this.getPublicKey();\n    }\n\n    if (!publicKeyBuffer) throw Error(\"Public key not found\");\n    if (!this.signature) throw Error(\"Signature not found\");\n\n    const publicKey = new Ed25519PublicKey(publicKeyBuffer);\n\n    return publicKey.verify(\n      new Ed25519Signature(this.signature.bytes),\n      HexBlob(\n        Buffer.from(this.createSigStructure(externalAad)).toString(\"hex\"),\n      ),\n    );\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "hashPayload",
              "signature": "hashPayload() {\n    if (!this.unProtectedMap) throw Error(\"Invalid unprotected map\");\n    if (!this.payload) throw Error(\"Invalid payload\");\n\n    const hashedIndex = this.unProtectedMap.map.findIndex((value) => {\n      return (\n        JSONBig.stringify(value.k) === JSONBig.stringify(new CborText(\"hashed\"))\n      );\n    });\n\n    const hashed = this.unProtectedMap.map[hashedIndex];\n    if (\n      hashed &&\n      JSONBig.stringify(hashed.v) === JSONBig.stringify(new CborSimple(true))\n    )\n      throw Error(\"Payload already hashed\");\n    if (\n      hashed &&\n      (JSONBig.stringify(hashed.v) ===\n        JSONBig.stringify(new CborSimple(true))) !=\n        false\n    )\n      throw Error(\"Invalid unprotected map\");\n\n    this.unProtectedMap.map.splice(hashedIndex, 1);\n\n    const hash = blake2b(this.payload.bytes, undefined, 24);\n    this.payload = new CborBytes(hash);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getAddress",
              "signature": "getAddress(): Buffer {\n    const address = this.protectedMap.map.find((value) => {\n      return (\n        JSONBig.stringify(value.k) ===\n        JSONBig.stringify(new CborText(\"address\"))\n      );\n    });\n    if (!address) throw Error(\"Address not found\");\n    return Buffer.from((address.v as CborBytes).bytes);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getPublicKey",
              "signature": "getPublicKey(): Buffer {\n    const publicKey = this.protectedMap.map.find((value) => {\n      return JSONBig.stringify(value.k) === JSONBig.stringify(new CborUInt(4));\n    });\n    if (!publicKey) throw Error(\"Public key not found\");\n    return Buffer.from((publicKey.v as CborBytes).bytes);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getSignature",
              "signature": "getSignature(): Buffer | undefined {\n    return this.signature ? Buffer.from(this.signature.bytes) : this.signature;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getPayload",
              "signature": "getPayload(): Buffer | null {\n    return this.payload ? Buffer.from(this.payload.bytes) : this.payload;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "protectedMap",
              "type": "CborMap",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "unProtectedMap",
              "type": "CborMap",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "payload",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "signature",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-core-cst.src.message-signing.generate-nonce",
      "name": "generate-nonce",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.message-signing.index",
      "name": "index",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.message-signing.sign-data",
      "name": "sign-data",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.plutus-tools.index",
      "name": "index",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "OutputEncoding",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/plutus-tools/index\").OutputEncoding",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/plutus-tools/index.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.resolvers.index",
      "name": "index",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.serializer.index",
      "name": "index",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "CardanoSDKSerializer",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/serializer/index.ts",
          "extends": null,
          "implements": [
            "IMeshTxSerializer"
          ],
          "methods": [
            {
              "name": "serializeRewardAddress",
              "signature": "serializeRewardAddress(\n    stakeKeyHash: string,\n    isScriptHash?: boolean,\n    network_id?: 0 | 1,\n  ): string {\n    return RewardAddress.fromCredentials(network_id ?? 0, {\n      type: isScriptHash ? CredentialType.ScriptHash : CredentialType.KeyHash,\n      hash: Hash28ByteBase16(stakeKeyHash),\n    })\n      .toAddress()\n      .toBech32();\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "serializePoolId",
              "signature": "serializePoolId(hash: string): string {\n    return PoolId.fromKeyHash(Ed25519KeyHashHex(hash)).toString();\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "serializeAddress",
              "signature": "serializeAddress(\n    address: Partial<DeserializedAddress>,\n    networkId?: 0 | 1,\n  ): string {\n    let paymentCred: CredentialCore | undefined = undefined;\n\n    let stakeCred: CredentialCore | undefined;\n\n    if (address.pubKeyHash && address.pubKeyHash !== \"\") {\n      paymentCred = {\n        type: CredentialType.KeyHash,\n        hash: Hash28ByteBase16(address.pubKeyHash),\n      };\n    } else if (address.scriptHash && address.scriptHash !== \"\") {\n      paymentCred = {\n        type: CredentialType.ScriptHash,\n        hash: Hash28ByteBase16(address.scriptHash),\n      };\n    }\n\n    if (address.stakeCredentialHash && address.stakeCredentialHash !== \"\") {\n      stakeCred = {\n        type: CredentialType.KeyHash,\n        hash: Hash28ByteBase16(address.stakeCredentialHash),\n      };\n    } else if (address.stakeScriptCredentialHash) {\n      stakeCred = {\n        type: CredentialType.ScriptHash,\n        hash: Hash28ByteBase16(address.stakeScriptCredentialHash),\n      };\n    }\n\n    let type: AddressType = AddressType.BasePaymentKeyStakeKey;\n    if (paymentCred && stakeCred) {\n      if (\n        paymentCred.type === CredentialType.KeyHash &&\n        stakeCred.type === CredentialType.KeyHash\n      ) {\n        type = AddressType.BasePaymentKeyStakeKey;\n      } else if (\n        paymentCred.type === CredentialType.KeyHash &&\n        stakeCred.type === CredentialType.ScriptHash\n      ) {\n        type = AddressType.BasePaymentKeyStakeScript;\n      } else if (\n        paymentCred.type === CredentialType.ScriptHash &&\n        stakeCred.type === CredentialType.KeyHash\n      ) {\n        type = AddressType.BasePaymentScriptStakeKey;\n      } else if (\n        paymentCred.type === CredentialType.ScriptHash &&\n        stakeCred.type === CredentialType.ScriptHash\n      ) {\n        type = AddressType.BasePaymentScriptStakeScript;\n      }\n    } else if (paymentCred) {\n      if (paymentCred.type === CredentialType.KeyHash) {\n        type = AddressType.EnterpriseKey;\n      } else if (paymentCred.type === CredentialType.ScriptHash) {\n        type = AddressType.EnterpriseScript;\n      }\n    } else if (stakeCred) {\n      if (stakeCred.type === CredentialType.KeyHash) {\n        type = AddressType.RewardKey;\n      } else if (stakeCred.type === CredentialType.ScriptHash) {\n        type = AddressType.RewardScript;\n      }\n    }\n\n    return new Address({\n      type,\n      networkId: networkId ?? 0,\n      paymentPart: paymentCred,\n      delegationPart: stakeCred,\n    }).toBech32();\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "serializeData",
              "signature": "serializeData(data: BuilderData): string {\n    const plutusData = fromBuilderToPlutusData(data);\n    return plutusData.toCbor().toString();\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "serializeTxBodyWithMockSignatures",
              "signature": "serializeTxBodyWithMockSignatures(\n    txBuilderBody: MeshTxBuilderBody,\n    protocolParams: Protocol,\n  ): string {\n    const serializerCore = new CardanoSDKSerializerCore(protocolParams);\n    return serializerCore.coreSerializeTxWithMockSignatures(txBuilderBody);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "serializeValue",
              "signature": "serializeValue(value: Asset[]): string {\n    return toValue(value).toCbor();\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "serializeOutput",
              "signature": "serializeOutput(output: Output): string {\n    let cardanoOutput = new TransactionOutput(\n      toCardanoAddress(output.address),\n      toValue(output.amount),\n    );\n    if (output.datum?.type === \"Hash\") {\n      cardanoOutput.setDatum(\n        Datum.newDataHash(fromBuilderToPlutusData(output.datum.data).hash()),\n      );\n    } else if (output.datum?.type === \"Inline\") {\n      cardanoOutput.setDatum(\n        Datum.newInlineData(fromBuilderToPlutusData(output.datum.data)),\n      );\n    } else if (output.datum?.type === \"Embedded\") {\n      throw new Error(\"Embedded datum not supported\");\n    }\n    if (output.referenceScript) {\n      switch (output.referenceScript.version) {\n        case \"V1\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV1Script(\n              PlutusV1Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        case \"V2\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV2Script(\n              PlutusV2Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        case \"V3\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV3Script(\n              PlutusV3Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        default: {\n          cardanoOutput.setScriptRef(\n            Script.newNativeScript(\n              NativeScript.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n      }\n    }\n    return cardanoOutput.toCbor();\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "protocolParams",
              "type": "Protocol",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "deserializer",
              "type": "IDeserializer",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "resolver",
              "type": "IResolver",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "serializeTxBody",
              "type": "(txBuilderBody: MeshTxBuilderBody, protocolParams?: any) => string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "addSigningKeys",
              "type": "(txHex: string, signingKeys: string[]) => string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "parser",
              "type": "ITxParser",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-core-cst.src.types.cardano-sdk",
      "name": "cardano-sdk",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Slot",
          "definition": "Cardano.Slot",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Value",
          "definition": "Serialization.Value",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "TokenMap",
          "definition": "Cardano.TokenMap",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Transaction",
          "definition": "Serialization.Transaction",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "TransactionId",
          "definition": "Cardano.TransactionId",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "TransactionBody",
          "definition": "Serialization.TransactionBody",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "TransactionWitnessSet",
          "definition": "Serialization.TransactionWitnessSet",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "AuxiliaryData",
          "definition": "Serialization.AuxiliaryData",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "TransactionMetadatum",
          "definition": "Serialization.TransactionMetadatum",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "MetadatumMap",
          "definition": "Serialization.MetadatumMap",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "MetadatumList",
          "definition": "Serialization.MetadatumList",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "TransactionUnspentOutput",
          "definition": "Serialization.TransactionUnspentOutput",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "TransactionInput",
          "definition": "Serialization.TransactionInput",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "TransactionOutput",
          "definition": "Serialization.TransactionOutput",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "TransactionInputSet",
          "definition": "Serialization.CborSet<any, Serialization.TransactionInput>",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "TransactionWitnessPlutusData",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/types/cardano-sdk\").TransactionWitnessPlutusData",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "PlutusData",
          "definition": "Serialization.PlutusData",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "PlutusList",
          "definition": "Serialization.PlutusList",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "PlutusMap",
          "definition": "Serialization.PlutusMap",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Redeemers",
          "definition": "Serialization.Redeemers",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Redeemer",
          "definition": "Serialization.Redeemer",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "RedeemerPurpose",
          "definition": "Cardano.RedeemerPurpose",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "RedeemerTag",
          "definition": "Serialization.RedeemerTag",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Script",
          "definition": "Serialization.Script",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "PolicyId",
          "definition": "Cardano.PolicyId",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "AssetName",
          "definition": "Cardano.AssetName",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "AssetId",
          "definition": "Cardano.AssetId",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "ScriptHash",
          "definition": "Crypto.Hash28ByteBase16",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Address",
          "definition": "Cardano.Address",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "RewardAddress",
          "definition": "Cardano.RewardAddress",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "AddressType",
          "definition": "Cardano.AddressType",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "BaseAddress",
          "definition": "Cardano.BaseAddress",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "EnterpriseAddress",
          "definition": "Cardano.EnterpriseAddress",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "PaymentAddress",
          "definition": "Cardano.PaymentAddress",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "AssetFingerprint",
          "definition": "Cardano.AssetFingerprint",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Credential",
          "definition": "Serialization.Credential",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "CredentialCore",
          "definition": "Cardano.Credential",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Ed25519PublicKeyHex",
          "definition": "Crypto.Ed25519PublicKeyHex",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Ed25519PrivateNormalKeyHex",
          "definition": "OpaqueString<\"Ed25519PrivateKeyHex\">",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Ed25519PrivateExtendedKeyHex",
          "definition": "OpaqueString<\"Ed25519PrivateKeyHex\">",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Ed25519KeyHash",
          "definition": "Crypto.Ed25519KeyHash",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Ed25519KeyHashHex",
          "definition": "Crypto.Ed25519KeyHashHex",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Hash28ByteBase16",
          "definition": "Crypto.Hash28ByteBase16",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Hash32ByteBase16",
          "definition": "Crypto.Hash32ByteBase16",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "CredentialType",
          "definition": "Cardano.CredentialType",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Certificate",
          "definition": "Serialization.Certificate",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "PoolId",
          "definition": "Cardano.PoolId",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "StakeRegistration",
          "definition": "Serialization.StakeRegistration",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "StakeDelegation",
          "definition": "Serialization.StakeDelegation",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "StakeDelegationCertificate",
          "definition": "Cardano.StakeDelegationCertificate",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "CertificateType",
          "definition": "Cardano.CertificateType",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "VkeyWitness",
          "definition": "Serialization.VkeyWitness",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Ed25519SignatureHex",
          "definition": "Crypto.Ed25519SignatureHex",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Ed25519PublicKey",
          "definition": "Crypto.Ed25519PublicKey",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Ed25519Signature",
          "definition": "Crypto.Ed25519Signature",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Bip32PrivateKey",
          "definition": "Crypto.Bip32PrivateKey",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Bip32PrivateKeyHex",
          "definition": "Crypto.Bip32PrivateKeyHex",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Bip32PublicKey",
          "definition": "Crypto.Bip32PublicKey",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Bip32PublicKeyHex",
          "definition": "Crypto.Bip32PublicKeyHex",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "PlutusLanguageVersion",
          "definition": "Cardano.PlutusLanguageVersion",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "NativeScript",
          "definition": "Serialization.NativeScript",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "PlutusV1Script",
          "definition": "Serialization.PlutusV1Script",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "PlutusV2Script",
          "definition": "Serialization.PlutusV2Script",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "PlutusV3Script",
          "definition": "Serialization.PlutusV3Script",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "PlutusDataKind",
          "definition": "Serialization.PlutusDataKind",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "PointerAddress",
          "definition": "Cardano.PointerAddress",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "CertIndex",
          "definition": "Cardano.CertIndex",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "TxIndex",
          "definition": "Cardano.TxIndex",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Costmdls",
          "definition": "Serialization.Costmdls",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "CostModel",
          "definition": "Serialization.CostModel",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "CborWriter",
          "definition": "Serialization.CborWriter",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "ConstrPlutusData",
          "definition": "Serialization.ConstrPlutusData",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "RewardAccount",
          "definition": "Cardano.RewardAccount",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Hash",
          "definition": "Serialization.Hash<T>",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "DatumHash",
          "definition": "Crypto.Hash32ByteBase16",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Datum",
          "definition": "any",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "CostModels",
          "definition": "Cardano.CostModels",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "ExUnits",
          "definition": "Serialization.ExUnits",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "NetworkId",
          "definition": "Cardano.ChainId",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Witness",
          "definition": "Cardano.Witness",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Signatures",
          "definition": "Cardano.Signatures",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "RequireAllOf",
          "definition": "Cardano.NativeScriptKind.RequireAllOf",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "RequireAnyOf",
          "definition": "Cardano.NativeScriptKind.RequireAnyOf",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "RequireNOf",
          "definition": "Cardano.NativeScriptKind.RequireNOf",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "RequireSignature",
          "definition": "Cardano.NativeScriptKind.RequireSignature",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "RequireTimeAfter",
          "definition": "Cardano.NativeScriptKind.RequireTimeAfter",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "RequireTimeBefore",
          "definition": "Cardano.NativeScriptKind.RequireTimeBefore",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "VrfVkBech32",
          "definition": "Cardano.VrfVkBech32",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "ScriptPubkey",
          "definition": "Serialization.ScriptPubkey",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "DRepID",
          "definition": "Cardano.DRepID",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "DRep",
          "definition": "Serialization.DRep",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "StakeCredentialStatus",
          "definition": "Cardano.StakeCredentialStatus",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Metadatum",
          "definition": "Cardano.Metadatum",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "HexBlob",
          "definition": "CardanoHexBlob",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "TxCBOR",
          "definition": "Serialization.TxCBOR",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "Ed25519PrivateKey",
          "definition": "Crypto.Ed25519PrivateKey",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "BootstrapWitness",
          "definition": "Serialization.BootstrapWitness",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        },
        {
          "name": "ByronAttributes",
          "definition": "Cardano.ByronAttributes",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.types.index",
      "name": "index",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.types.signer",
      "name": "signer",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Signer",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/types/signer\").Signer",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/types/signer.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.utils.address",
      "name": "address",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.utils.builder",
      "name": "builder",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.utils.certificate",
      "name": "certificate",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.utils.converter",
      "name": "converter",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.utils.data",
      "name": "data",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.utils.deserializer",
      "name": "deserializer",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.utils.encoding",
      "name": "encoding",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.utils.fee",
      "name": "fee",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.utils.index",
      "name": "index",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.utils.metadata",
      "name": "metadata",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.utils.script-data-hash",
      "name": "script-data-hash",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.utils.value",
      "name": "value",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [
        {
          "name": "mergeValue",
          "signature": "export function mergeValue(a: Value, b: Value): Value {\n  const ma = a.multiasset() ?? new Map();\n  b.multiasset()?.forEach((v, k) => {\n    const newVal = (ma.get(k) ?? 0n) + v;\n    if (newVal == 0n) {\n      ma.delete(k);\n    } else {\n      ma.set(k, newVal);\n    }\n  });\n  return new Value(\n    BigInt(a.coin()) + BigInt(b.coin()),\n    ma.size > 0 ? ma : undefined,\n  );\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "a",
              "type": "Serialization.Value",
              "optional": false
            },
            {
              "name": "b",
              "type": "Serialization.Value",
              "optional": false
            }
          ],
          "returnType": "Serialization.Value",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/utils/value.ts"
        },
        {
          "name": "negateValue",
          "signature": "export function negateValue(v: Value): Value {\n  const entries = v.multiasset()?.entries();\n  const tokenMap: TokenMap = new Map();\n  if (entries) {\n    for (const entry of entries) {\n      tokenMap.set(entry[0], -entry[1]);\n    }\n  }\n  return new Value(-v.coin(), tokenMap);\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "v",
              "type": "Serialization.Value",
              "optional": false
            }
          ],
          "returnType": "Serialization.Value",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/utils/value.ts"
        },
        {
          "name": "subValue",
          "signature": "export function subValue(a: Value, b: Value): Value {\n  return mergeValue(a, negateValue(b));\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "a",
              "type": "Serialization.Value",
              "optional": false
            },
            {
              "name": "b",
              "type": "Serialization.Value",
              "optional": false
            }
          ],
          "returnType": "Serialization.Value",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/utils/value.ts"
        },
        {
          "name": "negatives",
          "signature": "export function negatives(v: Value): Value {\n  const entries = v.multiasset()?.entries();\n  const coin = v.coin() < 0n ? v.coin() : 0n;\n  const tokenMap: TokenMap = new Map();\n  if (entries) {\n    for (const entry of entries) {\n      if (entry[1] < 0n) {\n        tokenMap.set(entry[0], entry[1]);\n      }\n    }\n  }\n  return new Value(coin, tokenMap);\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "v",
              "type": "Serialization.Value",
              "optional": false
            }
          ],
          "returnType": "Serialization.Value",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/utils/value.ts"
        },
        {
          "name": "assetTypes",
          "signature": "export function assetTypes(v: Value): number {\n  let count = v.coin() == 0n ? 0 : 1;\n  const entries = v.multiasset();\n  if (entries) {\n    entries.forEach(() => {\n      count += 1;\n    });\n  }\n  return count;\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "v",
              "type": "Serialization.Value",
              "optional": false
            }
          ],
          "returnType": "number",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/utils/value.ts"
        },
        {
          "name": "empty",
          "signature": "export function empty(v: Value): boolean {\n  return assetTypes(v) == 0;\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "v",
              "type": "Serialization.Value",
              "optional": false
            }
          ],
          "returnType": "boolean",
          "isExported": true,
          "importPath": "offchain/mesh-core-cst/src/utils/value.ts"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.utils.vote",
      "name": "vote",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-cst.src.utils.witness-set",
      "name": "witness-set",
      "source": "mesh-core-cst",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-hydra.src.types.events",
      "name": "events",
      "source": "mesh-hydra",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Greetings",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").Greetings",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "PeerConnected",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").PeerConnected",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "PeerDisconnected",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").PeerDisconnected",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "PeerHandshakeFailure",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").PeerHandshakeFailure",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "HeadIsInitializing",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").HeadIsInitializing",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "Committed",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").Committed",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "HeadIsOpen",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").HeadIsOpen",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "HeadIsClosed",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").HeadIsClosed",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "HeadIsContested",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").HeadIsContested",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "ReadyToFanout",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").ReadyToFanout",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "HeadIsAborted",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").HeadIsAborted",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "HeadIsFinalized",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").HeadIsFinalized",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "TxValid",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").TxValid",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "TxInvalid",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").TxInvalid",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "SnapshotConfirmed",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").SnapshotConfirmed",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "GetUTxOResponse",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").GetUTxOResponse",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "InvalidInput",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").InvalidInput",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "PostTxOnChainFailed",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").PostTxOnChainFailed",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "CommandFailed",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").CommandFailed",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "IgnoredHeadInitializing",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").IgnoredHeadInitializing",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "DecommitInvalid",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").DecommitInvalid",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "DecommitRequested",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").DecommitRequested",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "DecommitApproved",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").DecommitApproved",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        },
        {
          "name": "DecommitFinalized",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").DecommitFinalized",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/events.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-hydra.src.types.hAssets",
      "name": "hAssets",
      "source": "mesh-hydra",
      "description": "",
      "functions": [
        {
          "name": "hAssets",
          "signature": "export function hAssets(assets: Asset[]): hAssets {\n  return assets.reduce((p, asset) => {\n      if (asset.unit === \"\" || asset.unit === \"lovelace\") {\n        p[\"lovelace\"] += BigInt(asset.quantity);\n      } else {\n        const policyId = asset.unit.slice(0, 56);\n        const assetName = asset.unit.slice(56);\n        if (!p[policyId]) p[policyId] = {};\n        p[policyId][assetName] = (p[policyId][assetName] ?? BigInt(0)) + BigInt(asset.quantity);\n      }\n      return p;\n    }, { lovelace: BigInt(0) } as hAssets\n  );\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "assets",
              "type": "Asset[]",
              "optional": false
            }
          ],
          "returnType": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hAssets\").hAssets",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hAssets.ts"
        }
      ],
      "types": [
        {
          "name": "hAssets",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hAssets\").hAssets",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hAssets.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-hydra.src.types.hReferenceScript",
      "name": "hReferenceScript",
      "source": "mesh-hydra",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "hReferenceScript",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hReferenceScript\").hReferenceScript",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hReferenceScript.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-hydra.src.types.hStatus",
      "name": "hStatus",
      "source": "mesh-hydra",
      "description": "",
      "functions": [
        {
          "name": "hStatus",
          "signature": "export function hStatus(value: { headStatus?: string; tag?: string; }): hStatus | null {\n  if (value.headStatus === \"Open\") return \"OPEN\";\n  \n  switch (value.tag) {\n    case \"HeadIsInitializing\":\n      return \"INITIALIZING\";\n    case \"HeadIsOpen\":\n      return \"OPEN\";\n    case \"HeadIsClosed\":\n      return \"CLOSED\";\n    case \"ReadyToFanout\":\n      return \"FANOUT_POSSIBLE\";\n    case \"HeadIsFinalized\":\n      return \"FINAL\";\n    default:\n      return null;\n  }\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "value",
              "type": "{ headStatus?: string | undefined; tag?: string | undefined; }",
              "optional": false
            }
          ],
          "returnType": "\"IDLE\" | \"DISCONNECTED\" | \"CONNECTING\" | \"CONNECTED\" | \"INITIALIZING\" | \"OPEN\" | \"CLOSED\" | \"FANOUT_POSSIBLE\" | \"FINAL\" | null",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hStatus.ts"
        }
      ],
      "types": [
        {
          "name": "hStatus",
          "definition": "\"IDLE\" | \"DISCONNECTED\" | \"CONNECTING\" | \"CONNECTED\" | \"INITIALIZING\" | \"OPEN\" | \"CLOSED\" | \"FANOUT_POSSIBLE\" | \"FINAL\"",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hStatus.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-hydra.src.types.hTransaction",
      "name": "hTransaction",
      "source": "mesh-hydra",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "hTransaction",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hTransaction\").hTransaction",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hTransaction.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-hydra.src.types.hUTxOs",
      "name": "hUTxOs",
      "source": "mesh-hydra",
      "description": "",
      "functions": [
        {
          "name": "hUTxOs",
          "signature": "export function hUTxOs(utxos: UTxO[]): hUTxOs {\n  return Object.fromEntries(utxos.map(\n    (utxo) => [utxo.input.txHash + \"#\" + utxo.input.outputIndex, hUTxO(utxo)]\n  ));\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "utxos",
              "type": "UTxO[]",
              "optional": false
            }
          ],
          "returnType": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hUTxOs\").hUTxOs",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hUTxOs.ts"
        },
        {
          "name": "hUTxO",
          "signature": "export function hUTxO(utxo: UTxO): hUTxO {\n  return {\n    address: utxo.output.address,\n    value: hAssets(utxo.output.amount),\n    referenceScript: null,\n    inlineDatum: utxo.output.plutusData ? JSON.parse(utxo.output.plutusData) : null,\n    inlineDatumhash: utxo.output.dataHash ?? null,\n    datum: utxo.output.plutusData ?? null,\n    datumhash: utxo.output.dataHash ?? null,\n  };\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "utxo",
              "type": "UTxO",
              "optional": false
            }
          ],
          "returnType": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hUTxOs\").hUTxO",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hUTxOs.ts"
        }
      ],
      "types": [
        {
          "name": "hUTxOs",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hUTxOs\").hUTxOs",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hUTxOs.ts",
          "documentation": ""
        },
        {
          "name": "hUTxO",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hUTxOs\").hUTxO",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hUTxOs.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-hydra.src.types.hydra-post-chain-tx",
      "name": "hydra-post-chain-tx",
      "source": "mesh-hydra",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "PostChainTx",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx\").PostChainTx",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
          "documentation": ""
        },
        {
          "name": "InitTx",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx\").InitTx",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
          "documentation": ""
        },
        {
          "name": "AbortTx",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx\").AbortTx",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
          "documentation": ""
        },
        {
          "name": "CollectComTx",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx\").CollectComTx",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
          "documentation": ""
        },
        {
          "name": "InitialSnapshot",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx\").InitialSnapshot",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
          "documentation": ""
        },
        {
          "name": "ConfirmedSnapshot",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx\").ConfirmedSnapshot",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
          "documentation": ""
        },
        {
          "name": "DecrementTx",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx\").DecrementTx",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
          "documentation": ""
        },
        {
          "name": "CloseTx",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx\").CloseTx",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
          "documentation": ""
        },
        {
          "name": "ContestTx",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx\").ContestTx",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
          "documentation": ""
        },
        {
          "name": "FanoutTx",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx\").FanoutTx",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-hydra.src.types.hydra",
      "name": "hydra",
      "source": "mesh-hydra",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "HydraCommitTransaction",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra\").HydraCommitTransaction",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hydra.ts",
          "documentation": ""
        },
        {
          "name": "HydraParty",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra\").HydraParty",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hydra.ts",
          "documentation": ""
        },
        {
          "name": "HydraSnapshot",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra\").HydraSnapshot",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hydra.ts",
          "documentation": ""
        },
        {
          "name": "HydraHeadParameters",
          "definition": "export interface HydraHeadParameters {\n  contestationPeriod: number;\n  parties: HydraParty[];\n}",
          "isExported": true,
          "importPath": "offchain/mesh-hydra/src/types/hydra.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-hydra.src.types.index",
      "name": "index",
      "source": "mesh-hydra",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-hydra.src.utils.index",
      "name": "index",
      "source": "mesh-hydra",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-hydra.src.utils.parse-http-error",
      "name": "parse-http-error",
      "source": "mesh-hydra",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-provider.src.common.utxos-to-assets",
      "name": "utxos-to-assets",
      "source": "mesh-provider",
      "description": "",
      "functions": [
        {
          "name": "utxosToAssets",
          "signature": "export function utxosToAssets(utxos: UTxO[]): { [key: string]: string } {\n  const _balance = utxos\n    .map((utxo) => {\n      return utxo.output.amount;\n    })\n    .reduce(\n      (acc, amount) => {\n        for (const asset of amount) {\n          if (asset) {\n            if (acc[asset.unit] == undefined) {\n              acc[asset.unit] = 0;\n            }\n            if (asset.unit in acc) {\n              acc[asset.unit]! += parseFloat(asset.quantity);\n            }\n          }\n        }\n        return acc;\n      },\n      {} as { [key: string]: number },\n    );\n\n  return Object.fromEntries(\n    Object.entries(_balance).map(([key, value]) => [key, value.toString()]),\n  );\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "utxos",
              "type": "UTxO[]",
              "optional": false
            }
          ],
          "returnType": "{ [key: string]: string; }",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/common/utxos-to-assets.ts"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-provider.src.offline.index",
      "name": "index",
      "source": "mesh-provider",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-provider.src.offline.offline-fetcher",
      "name": "offline-fetcher",
      "source": "mesh-provider",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "OfflineFetcher",
          "documentation": "OfflineFetcher implements the IFetcher interface to provide offline access to blockchain data.\nThis class allows working with pre-loaded blockchain data without requiring network connectivity.\nIt's useful for testing, development, and scenarios where offline operation is needed.\n\nThe class maintains internal storage for various blockchain data types:\n- Account information\n- UTXOs (Unspent Transaction Outputs)\n- Asset addresses and metadata\n- Block information\n- Protocol parameters\n- Transaction information\n\nExample usage:\n```typescript\nimport { OfflineFetcher } from '@meshsdk/core';\n\n// Create a new instance\nconst fetcher = new OfflineFetcher();\n//or const fetcher = new OfflineFetcher(\"mainnet\");\n\n// Add some blockchain data\nfetcher.addAccount(address, accountInfo);\nfetcher.addUTxOs(utxos);\nfetcher.addSerializedTransaction(\"txHash\");\n\n// Use the fetcher with MeshWallet\nconst wallet = new MeshWallet({\n  networkId: 0,\n  fetcher: fetcher,\n  key: {\n    type: 'address',\n    address: walletAddress\n  }\n});\n```",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/offline/offline-fetcher.ts",
          "extends": null,
          "implements": [
            "IFetcher"
          ],
          "methods": [
            {
              "name": "paginate",
              "signature": "private paginate<T>(\n    items: T[],\n    cursor?: number | string,\n    pageSize: number = 20,\n  ): { paginatedItems: T[]; nextCursor?: number } {\n    const startIndex = cursor != null ? parseInt(String(cursor), 10) : 0;\n    const paginatedItems = items.slice(startIndex, startIndex + pageSize);\n    const nextCursor =\n      startIndex + pageSize < items.length ? startIndex + pageSize : undefined;\n    return { paginatedItems, nextCursor };\n  }",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "fetchAccountInfo",
              "signature": "async fetchAccountInfo(address: string): Promise<AccountInfo> {\n    const account = this.accounts[address];\n    if (!account) throw new Error(`Account not found: ${address}`);\n    return account;\n  }",
              "documentation": "Fetches account information for a given address.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressUTxOs",
              "signature": "async fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]> {\n    const addressUtxos = this.utxos[address] || [];\n    return asset\n      ? addressUtxos.filter((utxo) =>\n          utxo.output.amount.some((a) => a.unit === asset),\n        )\n      : addressUtxos;\n  }",
              "documentation": "Fetches UTXOs for a given address, optionally filtered by asset.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressTxs",
              "signature": "fetchAddressTxs(\n    address: string,\n    options?: IFetcherOptions,\n  ): Promise<TransactionInfo[]> {\n    throw new Error(\"Method not implemented.\");\n  }",
              "documentation": "WIP - NOT IMPLEMENTED",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAssetAddresses",
              "signature": "async fetchAssetAddresses(asset: string): Promise<AssetAddress[]> {\n    if (!OfflineFetcher.isValidHex(asset)) {\n      throw new Error(\"Invalid asset: must be a hex string\");\n    }\n\n    const addressMap = new Map<string, bigint>();\n\n    // Get addresses from asset addresses registry\n    const registryAddresses = this.assetAddresses[asset] || [];\n    for (const addr of registryAddresses) {\n      addressMap.set(addr.address, BigInt(addr.quantity));\n    }\n\n    // Get addresses from UTXOs\n    for (const [address, utxos] of Object.entries(this.utxos)) {\n      for (const utxo of utxos) {\n        const assetAmount = utxo.output.amount.find(\n          (amt) => amt.unit === asset,\n        );\n        if (assetAmount) {\n          const currentAmount = addressMap.get(address) || BigInt(0);\n          addressMap.set(address, currentAmount + BigInt(assetAmount.quantity));\n        }\n      }\n    }\n\n    // Convert map to array of AssetAddress objects\n    return Array.from(addressMap.entries())\n      .filter(([_, quantity]) => quantity > BigInt(0))\n      .map(([address, quantity]) => ({\n        address,\n        quantity: quantity.toString(),\n      }));\n  }",
              "documentation": "Fetches addresses holding a specific asset.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAddressAssets",
              "signature": "async fetchAddressAssets(address: string): Promise<Asset[]> {\n    if (!OfflineFetcher.isValidAddress(address)) {\n      throw new Error(\n        \"Invalid address: must be a valid Bech32 or Base58 address\",\n      );\n    }\n\n    const assetMap = new Map<string, bigint>();\n\n    // Get assets from UTXOs\n    const addressUtxos = this.utxos[address] || [];\n    for (const utxo of addressUtxos) {\n      for (const amount of utxo.output.amount) {\n        const currentAmount = assetMap.get(amount.unit) || BigInt(0);\n        assetMap.set(amount.unit, currentAmount + BigInt(amount.quantity));\n      }\n    }\n\n    // Get assets from asset addresses registry\n    for (const [assetId, addresses] of Object.entries(this.assetAddresses)) {\n      const assetAddress = addresses.find((addr) => addr.address === address);\n      if (assetAddress) {\n        const currentAmount = assetMap.get(assetId) || BigInt(0);\n        assetMap.set(assetId, currentAmount + BigInt(assetAddress.quantity));\n      }\n    }\n\n    // Convert map back to array of Assets\n    return Array.from(assetMap.entries()).map(([unit, quantity]) => ({\n      unit,\n      quantity: quantity.toString(),\n    }));\n  }",
              "documentation": "Fetches all assets associated with an address.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchAssetMetadata",
              "signature": "async fetchAssetMetadata(asset: string): Promise<AssetMetadata> {\n    const metadata = this.assetMetadata[asset];\n    if (!metadata) throw new Error(`Asset metadata not found: ${asset}`);\n    return metadata;\n  }",
              "documentation": "Fetches metadata for a specific asset.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchBlockInfo",
              "signature": "async fetchBlockInfo(hash: string): Promise<BlockInfo> {\n    const block = this.blocks[hash];\n    if (!block) throw new Error(`Block not found: ${hash}`);\n    return block;\n  }",
              "documentation": "Fetches information about a specific block.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchCollectionAssets",
              "signature": "async fetchCollectionAssets(\n    policyId: string,\n    cursor?: number | string,\n  ): Promise<{ assets: Asset[]; next?: string | number }> {\n    const assets = this.collections[policyId];\n    if (!assets) throw new Error(`Collection not found: ${policyId}`);\n\n    if (cursor && !OfflineFetcher.isIntegerString(String(cursor))) {\n      throw new Error(\"Invalid cursor: must be a string of digits\");\n    }\n\n    const { paginatedItems, nextCursor } = this.paginate(assets, cursor);\n    return { assets: paginatedItems, next: nextCursor };\n  }",
              "documentation": "Fetches assets in a collection (by policy ID) with pagination.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchHandle",
              "signature": "async fetchHandle(handle: string): Promise<AssetMetadata> {\n    try {\n      const assetName = fromUTF8(handle.replace(\"$\", \"\"));\n      const handleAsset = `${SUPPORTED_HANDLES[1]}000de140${assetName}`;\n      return await this.fetchAssetMetadata(handleAsset);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
              "documentation": "Fetches metadata for a handle.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchHandleAddress",
              "signature": "async fetchHandleAddress(handle: string): Promise<string> {\n    const assetName = fromUTF8(handle.replace(\"$\", \"\"));\n    const policyId = SUPPORTED_HANDLES[1];\n    const addresses = await this.fetchAssetAddresses(`${policyId}${assetName}`);\n\n    const address = addresses[0]?.address;\n    if (!address) {\n      throw new Error(`No addresses found for handle: ${handle}`);\n    }\n\n    return address;\n  }",
              "documentation": "Fetches address associated with a handle.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchProtocolParameters",
              "signature": "async fetchProtocolParameters(epoch?: number): Promise<Protocol> {\n    if (!epoch) {\n      const maxEpochNumber = Math.max(\n        ...Object.keys(this.protocolParameters).map(Number),\n      );\n      return this.protocolParameters[maxEpochNumber]!;\n    }\n    const parameters = this.protocolParameters[epoch];\n    if (!parameters)\n      throw new Error(`Protocol parameters not found for epoch: ${epoch}`);\n    return parameters;\n  }",
              "documentation": "Fetches protocol parameters for a specific epoch.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchTxInfo",
              "signature": "async fetchTxInfo(hash: string): Promise<TransactionInfo> {\n    const transaction = this.transactions[hash];\n    if (!transaction) throw new Error(`Transaction not found: ${hash}`);\n    return transaction;\n  }",
              "documentation": "Fetches information about a specific transaction.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchUTxOs",
              "signature": "async fetchUTxOs(hash: string): Promise<UTxO[]> {\n    const utxos = Object.values(this.utxos)\n      .flat()\n      .filter((utxo) => utxo.input.txHash === hash);\n    if (!utxos.length)\n      throw new Error(`No UTxOs found for transaction hash: ${hash}`);\n    return utxos;\n  }",
              "documentation": "Fetches all UTXOs associated with a specific transaction hash.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetchGovernanceProposal",
              "signature": "async fetchGovernanceProposal(\n    txHash: string,\n    certIndex: number,\n  ): Promise<any> {\n    throw new Error(\"Method not implemented\");\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "get",
              "signature": "async get(url: string): Promise<any> {\n    throw new Error(\"Method not implemented in OfflineFetcher.\");\n  }",
              "documentation": "HTTP GET method required by IFetcher interface but not implemented in OfflineFetcher.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "toJSON",
              "signature": "toJSON(): string {\n    return JSON.stringify({\n      accounts: this.accounts,\n      utxos: this.utxos,\n      assetAddresses: this.assetAddresses,\n      assetMetadata: this.assetMetadata,\n      blocks: this.blocks,\n      collections: this.collections,\n      protocolParameters: this.protocolParameters,\n      transactions: this.transactions,\n    });\n  }",
              "documentation": "Serializes fetcher data to JSON string.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fromJSON",
              "signature": "static fromJSON(json: string): OfflineFetcher {\n    const data = JSON.parse(json);\n    const fetcher = new OfflineFetcher();\n\n    Object.entries(data.accounts || {}).forEach(([address, info]) =>\n      fetcher.addAccount(address, info as AccountInfo),\n    );\n\n    Object.entries(data.utxos || {}).forEach(([address, utxos]) =>\n      fetcher.addUTxOs(utxos as UTxO[]),\n    );\n\n    Object.entries(data.assetAddresses || {}).forEach(([asset, addresses]) =>\n      fetcher.addAssetAddresses(asset, addresses as AssetAddress[]),\n    );\n\n    Object.entries(data.assetMetadata || {}).forEach(([asset, metadata]) =>\n      fetcher.addAssetMetadata(asset, metadata as AssetMetadata),\n    );\n\n    Object.entries(data.blocks || {}).forEach(([_, info]) =>\n      fetcher.addBlock(info as BlockInfo),\n    );\n\n    Object.entries(data.collections || {}).forEach(([policyId, assets]) =>\n      fetcher.addCollectionAssets(assets as Asset[]),\n    );\n\n    Object.entries(data.protocolParameters || {}).forEach(([_, params]) =>\n      fetcher.addProtocolParameters(params as Protocol),\n    );\n\n    Object.entries(data.transactions || {}).forEach(([_, info]) =>\n      fetcher.addTransaction(info as TransactionInfo),\n    );\n\n    return fetcher;\n  }",
              "documentation": "Creates an OfflineFetcher instance from JSON data.",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "isValidHex",
              "signature": "private static isValidHex(str: string, length?: number): boolean {\n    if (length && str.length !== length) {\n      return false;\n    }\n    return /^[0-9a-fA-F]+$/.test(str);\n  }",
              "documentation": "",
              "static": true,
              "visibility": "private"
            },
            {
              "name": "isValidAddress",
              "signature": "private static isValidAddress(address: string): boolean {\n    return (\n      OfflineFetcher.isValidBech32Address(address) ||\n      OfflineFetcher.isValidBase58(address)\n    );\n  }",
              "documentation": "",
              "static": true,
              "visibility": "private"
            },
            {
              "name": "isValidBase58",
              "signature": "private static isValidBase58(input: string): boolean {\n    // Base58 character set (Bitcoin alphabet)\n    const base58Regex =\n      /^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$/;\n    // Check that input matches Base58 character set\n    if (!base58Regex.test(input)) {\n      return false;\n    }\n    // Additional checks can be added here, such as length or checksum validation\n    return true;\n  }",
              "documentation": "",
              "static": true,
              "visibility": "private"
            },
            {
              "name": "isValidBech32",
              "signature": "private static isValidBech32(input: string, prefix: string): boolean {\n    // Check if the input is all lowercase or all uppercase\n    if (input !== input.toLowerCase() && input !== input.toUpperCase()) {\n      return false;\n    }\n\n    // Bech32 regex pattern for the given prefix\n    const pattern = new RegExp(`^${prefix}1[02-9ac-hj-np-z]+$`, \"i\");\n    return pattern.test(input);\n  }",
              "documentation": "",
              "static": true,
              "visibility": "private"
            },
            {
              "name": "isValidBech32Address",
              "signature": "private static isValidBech32Address(address: string): boolean {\n    return OfflineFetcher.isValidBech32(address, \"(addr|addr_test)\");\n  }",
              "documentation": "",
              "static": true,
              "visibility": "private"
            },
            {
              "name": "isValidBech32Pool",
              "signature": "private static isValidBech32Pool(poolId: string): boolean {\n    return OfflineFetcher.isValidBech32(poolId, \"pool\");\n  }",
              "documentation": "",
              "static": true,
              "visibility": "private"
            },
            {
              "name": "isValidBech32VrfVk",
              "signature": "private static isValidBech32VrfVk(vrfKey: string): boolean {\n    return OfflineFetcher.isValidBech32(vrfKey, \"vrf_vk\");\n  }",
              "documentation": "",
              "static": true,
              "visibility": "private"
            },
            {
              "name": "isIntegerString",
              "signature": "private static isIntegerString(str: string): boolean {\n    return /^\\d+$/.test(str);\n  }",
              "documentation": "",
              "static": true,
              "visibility": "private"
            },
            {
              "name": "isValidAssetOrLovelace",
              "signature": "private static isValidAssetOrLovelace(asset: string): boolean {\n    if (asset === \"lovelace\") {\n      return true;\n    }\n    if (asset.length < 56) {\n      return false;\n    }\n    return OfflineFetcher.isValidHex(asset);\n  }",
              "documentation": "",
              "static": true,
              "visibility": "private"
            },
            {
              "name": "addAccount",
              "signature": "addAccount(address: string, accountInfo: AccountInfo): void {\n    if (!OfflineFetcher.isValidAddress(address)) {\n      throw new Error(\n        \"Invalid address: must be a valid Bech32 or Base58 address\",\n      );\n    }\n\n    if (accountInfo.poolId) {\n      if (!OfflineFetcher.isValidBech32Pool(accountInfo.poolId)) {\n        throw new Error(\n          \"Invalid 'poolId': must be a valid Bech32 pool address\",\n        );\n      }\n    }\n\n    if (!OfflineFetcher.isIntegerString(accountInfo.balance)) {\n      throw new Error(\"Invalid 'balance': must be a string of digits\");\n    }\n\n    if (!OfflineFetcher.isIntegerString(accountInfo.rewards)) {\n      throw new Error(\"Invalid 'rewards': must be a string of digits\");\n    }\n\n    if (!OfflineFetcher.isIntegerString(accountInfo.withdrawals)) {\n      throw new Error(\"Invalid 'withdrawals': must be a string of digits\");\n    }\n\n    this.accounts[address] = accountInfo;\n  }",
              "documentation": "Adds account information to the fetcher.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "addUTxOs",
              "signature": "addUTxOs(utxos: UTxO[]): void {\n    if (!Array.isArray(utxos) || utxos.length === 0) {\n      throw new Error(\"Invalid utxos: must be a non-empty array\");\n    }\n\n    utxos.forEach((utxo, index) => {\n      if (\n        !Number.isInteger(utxo.input.outputIndex) ||\n        utxo.input.outputIndex < 0\n      ) {\n        throw new Error(\n          `Invalid outputIndex for UTxO at index ${index}: must be a non-negative integer`,\n        );\n      }\n      if (!OfflineFetcher.isValidHex(utxo.input.txHash, 64)) {\n        throw new Error(\n          `Invalid txHash for UTxO at index ${index}: must be a 64-character hexadecimal string`,\n        );\n      }\n\n      if (!OfflineFetcher.isValidAddress(utxo.output.address)) {\n        throw new Error(\n          `Invalid address in output for UTxO at index ${index}: must be a valid Bech32 or Base58 address`,\n        );\n      }\n      if (\n        !Array.isArray(utxo.output.amount) ||\n        utxo.output.amount.length === 0\n      ) {\n        throw new Error(\n          `Invalid amount for UTxO at index ${index}: must be a non-empty array of assets`,\n        );\n      }\n\n      utxo.output.amount.forEach((asset, assetIndex) => {\n        if (!OfflineFetcher.isValidAssetOrLovelace(asset.unit)) {\n          throw new Error(\n            `Invalid unit for asset at index ${assetIndex} in UTxO at index ${index}`,\n          );\n        }\n        if (!OfflineFetcher.isIntegerString(asset.quantity)) {\n          throw new Error(\n            `Invalid quantity for asset at index ${assetIndex} in UTxO at index ${index}: must be a string of digits`,\n          );\n        }\n      });\n      if (\n        utxo.output.dataHash &&\n        !OfflineFetcher.isValidHex(utxo.output.dataHash, 64)\n      ) {\n        throw new Error(\n          `Invalid dataHash for UTxO at index ${index}: must be a 64-character hexadecimal string or undefined`,\n        );\n      }\n      if (\n        utxo.output.plutusData &&\n        !OfflineFetcher.isValidHex(utxo.output.plutusData)\n      ) {\n        throw new Error(\n          `Invalid plutusData for UTxO at index ${index}: must be a hexadecimal string or undefined`,\n        );\n      }\n      if (\n        utxo.output.scriptRef &&\n        !OfflineFetcher.isValidHex(utxo.output.scriptRef)\n      ) {\n        throw new Error(\n          `Invalid scriptRef for UTxO at index ${index}: must be a hexadecimal string or undefined`,\n        );\n      }\n      if (\n        utxo.output.scriptHash &&\n        !OfflineFetcher.isValidHex(utxo.output.scriptHash, 56)\n      ) {\n        throw new Error(\n          `Invalid scriptHash for UTxO at index ${index}: must be a 56-character hexadecimal string or undefined`,\n        );\n      }\n    });\n\n    for (const utxo of utxos) {\n      if (!this.utxos[utxo.output.address]) {\n        this.utxos[utxo.output.address] = [];\n      }\n      this.utxos[utxo.output.address]!.push(utxo);\n    }\n  }",
              "documentation": "Adds UTXOs to the fetcher.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "addAssetAddresses",
              "signature": "addAssetAddresses(asset: string, addresses: AssetAddress[]): void {\n    if (!OfflineFetcher.isValidHex(asset)) {\n      throw new Error(\"Invalid asset: must be a hex string\");\n    }\n    if (addresses.length === 0) {\n      throw new Error(\"Invalid addresses: must be a non-empty array\");\n    }\n    addresses.forEach((item, index) => {\n      if (!OfflineFetcher.isValidAddress(item.address)) {\n        throw new Error(\n          `Invalid 'address' field at index ${index}, should be bech32 string`,\n        );\n      }\n      if (!OfflineFetcher.isIntegerString(item.quantity)) {\n        throw new Error(\n          `Invalid 'quantity' field at index ${index}, should be a string of digits`,\n        );\n      }\n    });\n    this.assetAddresses[asset] = addresses;\n  }",
              "documentation": "Adds asset address information to the fetcher.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "addAssetMetadata",
              "signature": "addAssetMetadata(asset: string, metadata: AssetMetadata): void {\n    if (asset.length < 56) {\n      throw new Error(\n        `Invalid asset ${asset}: must be a string longer than 56 characters`,\n      );\n    }\n    if (!OfflineFetcher.isValidHex(asset)) {\n      throw new Error(\"Invalid asset: must be a hex string\");\n    }\n\n    if (typeof metadata !== \"object\" || metadata === null) {\n      throw new Error(\"Invalid metadata object\");\n    }\n    this.assetMetadata[asset] = metadata;\n  }",
              "documentation": "Adds asset metadata to the fetcher.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "addCollectionAssets",
              "signature": "addCollectionAssets(assets: Asset[]): void {\n    if (!Array.isArray(assets) || assets.length === 0) {\n      throw new Error(\"Invalid assets: must be a non-empty array\");\n    }\n\n    const groupedAssets: { [policyId: string]: Asset[] } = {};\n\n    assets.forEach((asset, index) => {\n      if (asset.unit.length < 56) {\n        throw new Error(\n          `Invalid unit for asset at index ${index}: must be a string longer than 56 characters`,\n        );\n      }\n\n      if (!OfflineFetcher.isValidHex(asset.unit)) {\n        throw new Error(\n          `Invalid unit for asset at index ${index}: must be a hexadecimal string`,\n        );\n      }\n\n      const policyId = asset.unit.slice(0, 56);\n\n      if (!OfflineFetcher.isValidHex(policyId, 56)) {\n        throw new Error(\n          `Invalid policyId in asset unit at index ${index}: must be a 56-character hexadecimal string`,\n        );\n      }\n\n      if (!OfflineFetcher.isIntegerString(asset.quantity)) {\n        throw new Error(\n          `Invalid quantity for asset at index ${index}: must be a string of digits`,\n        );\n      }\n\n      if (!groupedAssets[policyId]) {\n        groupedAssets[policyId] = [];\n      }\n      groupedAssets[policyId].push(asset);\n    });\n\n    for (const [policyId, policyAssets] of Object.entries(groupedAssets)) {\n      if (!this.collections[policyId]) {\n        this.collections[policyId] = [];\n      }\n      this.collections[policyId] =\n        this.collections[policyId].concat(policyAssets);\n    }\n  }",
              "documentation": "Adds collection assets to the fetcher.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "addProtocolParameters",
              "signature": "addProtocolParameters(parameters: Protocol): void {\n    if (parameters.epoch < 0 || !Number.isInteger(parameters.epoch)) {\n      throw new Error(\"Invalid epoch: must be a non-negative integer\");\n    }\n\n    if (parameters.minFeeA < 0 || !Number.isInteger(parameters.minFeeA)) {\n      throw new Error(\"Invalid 'minFeeA': must be a non-negative integer\");\n    }\n    if (parameters.minFeeB < 0 || !Number.isInteger(parameters.minFeeB)) {\n      throw new Error(\"Invalid 'minFeeB': must be a non-negative integer\");\n    }\n    if (\n      parameters.maxBlockSize <= 0 ||\n      !Number.isInteger(parameters.maxBlockSize)\n    ) {\n      throw new Error(\"Invalid 'maxBlockSize': must be a positive integer\");\n    }\n    if (parameters.maxTxSize <= 0 || !Number.isInteger(parameters.maxTxSize)) {\n      throw new Error(\"Invalid 'maxTxSize': must be a positive integer\");\n    }\n    if (\n      parameters.maxBlockHeaderSize <= 0 ||\n      !Number.isInteger(parameters.maxBlockHeaderSize)\n    ) {\n      throw new Error(\n        \"Invalid 'maxBlockHeaderSize': must be a positive integer\",\n      );\n    }\n    if (parameters.keyDeposit < 0 || !Number.isInteger(parameters.keyDeposit)) {\n      throw new Error(\"Invalid 'keyDeposit': must be a non-negative integer\");\n    }\n    if (\n      parameters.poolDeposit < 0 ||\n      !Number.isInteger(parameters.poolDeposit)\n    ) {\n      throw new Error(\"Invalid 'poolDeposit': must be a non-negative integer\");\n    }\n    if (parameters.decentralisation < 0 || parameters.decentralisation > 1) {\n      throw new Error(\"Invalid 'decentralisation': must be between 0 and 1\");\n    }\n    if (parameters.priceMem < 0) {\n      throw new Error(\"Invalid 'priceMem': must be non-negative\");\n    }\n    if (parameters.priceStep < 0) {\n      throw new Error(\"Invalid 'priceStep': must be non-negative\");\n    }\n    if (parameters.maxValSize < 0 || !Number.isInteger(parameters.maxValSize)) {\n      throw new Error(\"Invalid 'maxValSize': must be a non-negative integer\");\n    }\n    if (parameters.collateralPercent < 0) {\n      throw new Error(\n        \"Invalid 'collateralPercent': must be a non-negative integer\",\n      );\n    }\n    if (\n      parameters.maxCollateralInputs < 0 ||\n      !Number.isInteger(parameters.maxCollateralInputs)\n    ) {\n      throw new Error(\n        \"Invalid 'maxCollateralInputs': must be a non-negative integer\",\n      );\n    }\n    if (parameters.coinsPerUtxoSize < 0) {\n      throw new Error(\"Invalid 'coinsPerUtxoSize': must be non-negative\");\n    }\n    if (parameters.minFeeRefScriptCostPerByte < 0) {\n      throw new Error(\n        \"Invalid 'minFeeRefScriptCostPerByte': must be non-negative\",\n      );\n    }\n\n    if (!OfflineFetcher.isIntegerString(parameters.minPoolCost)) {\n      throw new Error(\"Invalid 'minPoolCost': must be a string of digits\");\n    }\n    if (!OfflineFetcher.isIntegerString(parameters.maxTxExMem)) {\n      throw new Error(\"Invalid 'maxTxExMem': must be a string of digits\");\n    }\n    if (!OfflineFetcher.isIntegerString(parameters.maxTxExSteps)) {\n      throw new Error(\"Invalid 'maxTxExSteps': must be a string of digits\");\n    }\n    if (!OfflineFetcher.isIntegerString(parameters.maxBlockExMem)) {\n      throw new Error(\"Invalid 'maxBlockExMem': must be a string of digits\");\n    }\n    if (!OfflineFetcher.isIntegerString(parameters.maxBlockExSteps)) {\n      throw new Error(\"Invalid 'maxBlockExSteps': must be a string of digits\");\n    }\n\n    this.protocolParameters[parameters.epoch] = parameters;\n  }",
              "documentation": "Adds protocol parameters to the fetcher.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "addTransaction",
              "signature": "addTransaction(txInfo: TransactionInfo): void {\n    if (!OfflineFetcher.isValidHex(txInfo.hash, 64)) {\n      throw new Error(\n        \"Invalid transaction hash: must be a 64-character hexadecimal string\",\n      );\n    }\n    if (!Number.isInteger(txInfo.index) || txInfo.index < 0) {\n      throw new Error(\"Invalid 'index': must be a non-negative integer\");\n    }\n    if (!OfflineFetcher.isValidHex(txInfo.block, 64)) {\n      throw new Error(\n        \"Invalid 'block': must be a 64-character hexadecimal string\",\n      );\n    }\n    if (!OfflineFetcher.isIntegerString(txInfo.slot)) {\n      throw new Error(\"Invalid 'slot': must be a string of digits\");\n    }\n    if (!OfflineFetcher.isIntegerString(txInfo.fees)) {\n      throw new Error(\"Invalid 'fees': must be a string of digits\");\n    }\n    if (!Number.isInteger(txInfo.size) || txInfo.size <= 0) {\n      throw new Error(\"Invalid 'size': must be a positive integer\");\n    }\n    if (!/^-?\\d+$/.test(txInfo.deposit)) {\n      throw new Error(\n        \"Invalid 'deposit': must be a string representing an integer (positive or negative)\",\n      );\n    }\n    if (\n      txInfo.invalidBefore !== \"\" &&\n      !OfflineFetcher.isIntegerString(txInfo.invalidBefore)\n    ) {\n      throw new Error(\n        \"Invalid 'invalidBefore': must be a string of digits or empty string\",\n      );\n    }\n    if (\n      txInfo.invalidAfter !== \"\" &&\n      !OfflineFetcher.isIntegerString(txInfo.invalidAfter)\n    ) {\n      throw new Error(\n        \"Invalid 'invalidAfter': must be a string of digits or empty string\",\n      );\n    }\n    this.transactions[txInfo.hash] = txInfo;\n    this.addUTxOs(txInfo.outputs);\n  }",
              "documentation": "Adds transaction information to the fetcher.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "addBlock",
              "signature": "addBlock(blockInfo: BlockInfo): void {\n    if (!OfflineFetcher.isValidHex(blockInfo.hash, 64)) {\n      throw new Error(\n        \"Invalid block hash: must be a 64-character hexadecimal string\",\n      );\n    }\n    if (!Number.isInteger(blockInfo.time) || blockInfo.time < 0) {\n      throw new Error(\"Invalid 'time': must be a non-negative integer\");\n    }\n    if (!OfflineFetcher.isIntegerString(blockInfo.slot)) {\n      throw new Error(\"Invalid 'slot': must be a string of digits\");\n    }\n    if (!Number.isInteger(blockInfo.epoch) || blockInfo.epoch < 0) {\n      throw new Error(\"Invalid 'epoch': must be a non-negative integer\");\n    }\n    if (!OfflineFetcher.isIntegerString(blockInfo.epochSlot)) {\n      throw new Error(\"Invalid 'epochSlot': must be a string of digits\");\n    }\n    if (!OfflineFetcher.isValidBech32Pool(blockInfo.slotLeader)) {\n      throw new Error(\n        \"Invalid 'slotLeader': must be a bech32 string with pool prefix\",\n      );\n    }\n    if (!Number.isInteger(blockInfo.size) || blockInfo.size <= 0) {\n      throw new Error(\"Invalid 'size': must be a positive integer\");\n    }\n    if (!Number.isInteger(blockInfo.txCount) || blockInfo.txCount < 0) {\n      throw new Error(\"Invalid 'txCount': must be a non-negative integer\");\n    }\n    if (!OfflineFetcher.isIntegerString(blockInfo.output)) {\n      throw new Error(\"Invalid 'output': must be a string of digits\");\n    }\n    if (!OfflineFetcher.isValidHex(blockInfo.operationalCertificate, 64)) {\n      throw new Error(\n        \"Invalid 'operationalCertificate': must be a 64-character hexadecimal string\",\n      );\n    }\n    if (!OfflineFetcher.isValidHex(blockInfo.previousBlock, 64)) {\n      throw new Error(\n        \"Invalid 'previousBlock': must be a 64-character hexadecimal string\",\n      );\n    }\n    if (!OfflineFetcher.isValidBech32VrfVk(blockInfo.VRFKey)) {\n      throw new Error(\n        \"Invalid 'VRFKey': must be a bech32 string with vrf_vk1 prefix\",\n      );\n    }\n    this.blocks[blockInfo.hash] = blockInfo;\n  }",
              "documentation": "Adds block information to the fetcher.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "addSerializedTransaction",
              "signature": "addSerializedTransaction(txHex: string) {\n    const tx = Serialization.Transaction.fromCbor(Serialization.TxCBOR(txHex));\n    const time = Date.now();\n    const slot = resolveSlotNo(this.network ?? \"mainnet\", time);\n    const epoch = resolveEpochNo(this.network ?? \"mainnet\", time);\n    const epochSlot = this.slotToEpochSlot(BigInt(slot));\n    const randomBlockHash = randomBytes(32).toString('hex');\n    const randomPrevBlockHash = randomBytes(32).toString('hex');\n    const randomOCert = randomBytes(32).toString('hex');\n    const fee = tx.body().fee().toString();\n    const totalOutput = tx.body().outputs().reduce((acc, output) => {\n      const amount = output.amount().coin();\n      return acc + amount;\n    }, 0n);\n    const ttl = tx.body().ttl();\n    const validityStartInterval = tx.body().validityStartInterval();\n    const txHash = tx.body().hash();\n\n    const blockInfo: BlockInfo = {\n      confirmations: 40,\n      nextBlock: \"undefined its a random block\",\n      hash: randomBlockHash,\n      time,\n      slot,\n      epoch,\n      epochSlot: epochSlot.toString(),\n      fees: fee,\n      slotLeader: \"pool1qv3x5x5x5x5x5x5x5x5x5x5x5x5x5x5\",\n      size: txHex.length / 2,\n      txCount: 1,\n      output: totalOutput.toString(),\n      operationalCertificate: randomOCert,\n      previousBlock: randomPrevBlockHash,\n      VRFKey: \"vrf_vk1qv3x5x5x5x5x5x5x5x5x5x5x5x5x5\",\n    };\n\n    const txInputs = tx.body().inputs();\n    const fetchedUTxOs = txInputs.values().map((input) => {\n      const txHash = input.transactionId();\n      const outputIndex = Number(input.index());\n      const utxo = Object.values(this.utxos).flat().find(utxo => {\n        return utxo.input.txHash === txHash && utxo.input.outputIndex === outputIndex;\n      })\n      if (!utxo) {\n        throw new Error(`UTxO not found for transaction hash and output index: ${txHash} ${outputIndex}`);\n      }\n      return utxo;\n    });\n\n    for(const addressUtxos of Object.values(this.utxos)) {\n      for (const utxo of fetchedUTxOs) {\n        const index = addressUtxos.indexOf(utxo);\n        if (index !== -1) {\n          addressUtxos.splice(index, 1);\n        }\n      }\n    }\n\n    const newUtxOs = tx.body().outputs().map((output, index) => {\n      return this.mapOutputToUTxO(output, txHash, index);\n    });\n\n    const transactionInfo: TransactionInfo = {\n      inputs: fetchedUTxOs,\n      hash: txHash,\n      index: 0,\n      block: randomBlockHash,\n      slot: slot.toString(),\n      fees: fee,\n      size: txHex.length / 2,\n      deposit: \"0\",\n      invalidBefore: validityStartInterval ? validityStartInterval.toString() : \"\",\n      invalidAfter: ttl ? ttl.toString() : \"\",\n      outputs: newUtxOs\n    }\n\n    this.addBlock(blockInfo);\n    this.addTransaction(transactionInfo);\n  }",
              "documentation": "Adds a serialized transaction to the fetcher, it's generates pseudo block in addition to transaction.\nRemoves spent UTxOs from the fetcher and adds new UTxOs from the transaction.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "slotToEpochSlot",
              "signature": "private slotToEpochSlot(slot: bigint): bigint {\n    const slotConfig = SLOT_CONFIG_NETWORK[this.network ?? \"mainnet\"];\n    const epochLength = BigInt(slotConfig.epochLength);\n    return slot % epochLength;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "mapOutputToUTxO",
              "signature": "private mapOutputToUTxO(output: TransactionOutput, txHash: string, index: number): UTxO {\n    return {\n      input: {\n        txHash,\n        outputIndex: index,\n      },\n      output: {\n        address: output.address().toBech32(),\n        amount: this.mapValueToAsset(output.amount()),\n        dataHash: output.datum()?.asDataHash(),\n        plutusData: output.datum()?.asInlineData()?.toCbor(),\n        scriptRef: output.scriptRef()?.toCbor(),\n        scriptHash: output.scriptRef()?.hash(),\n      },\n    };\n  }",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "mapValueToAsset",
              "signature": "private mapValueToAsset(value: Value): Asset[] {\n    const assets: Asset[] = [];\n    const multiAsset = value.multiasset();\n    if (multiAsset) {\n      for (const [assetId, quantity] of multiAsset) {\n        const asset = {\n          unit: assetId,\n          quantity: quantity.toString(),\n        };\n        assets.push(asset);\n      }\n    } else {\n      const lovelace = value.coin().toString();\n      assets.push({ unit: \"lovelace\", quantity: lovelace });\n    }\n    return assets;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ],
          "properties": [
            {
              "name": "accounts",
              "type": "Record<string, AccountInfo>",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "utxos",
              "type": "Record<string, UTxO[]>",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "assetAddresses",
              "type": "Record<string, AssetAddress[]>",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "assetMetadata",
              "type": "Record<string, AssetMetadata>",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "blocks",
              "type": "Record<string, BlockInfo>",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "collections",
              "type": "Record<string, Asset[]>",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "protocolParameters",
              "type": "Record<number, Protocol>",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "transactions",
              "type": "Record<string, TransactionInfo>",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-provider.src.types.blockfrost",
      "name": "blockfrost",
      "source": "mesh-provider",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "BlockfrostUTxO",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/blockfrost\").BlockfrostUTxO",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/types/blockfrost.ts",
          "documentation": ""
        },
        {
          "name": "BlockfrostAsset",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/blockfrost\").BlockfrostAsset",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/types/blockfrost.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-provider.src.types.index",
      "name": "index",
      "source": "mesh-provider",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-provider.src.types.koios",
      "name": "koios",
      "source": "mesh-provider",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "KoiosUTxO",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/koios\").KoiosUTxO",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/types/koios.ts",
          "documentation": ""
        },
        {
          "name": "KoiosAsset",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/koios\").KoiosAsset",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/types/koios.ts",
          "documentation": ""
        },
        {
          "name": "KoiosValue",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/koios\").KoiosValue",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/types/koios.ts",
          "documentation": ""
        },
        {
          "name": "KoiosReferenceScript",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/koios\").KoiosReferenceScript",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/types/koios.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-provider.src.types.maestro",
      "name": "maestro",
      "source": "mesh-provider",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "MaestroUTxO",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/maestro\").MaestroUTxO",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/types/maestro.ts",
          "documentation": ""
        },
        {
          "name": "MaestroAssetExtended",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/maestro\").MaestroAssetExtended",
          "isExported": true,
          "importPath": "offchain/mesh-provider/src/types/maestro.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-provider.src.utils.index",
      "name": "index",
      "source": "mesh-provider",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-provider.src.utils.parse-asset-unit",
      "name": "parse-asset-unit",
      "source": "mesh-provider",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-provider.src.utils.parse-http-error",
      "name": "parse-http-error",
      "source": "mesh-provider",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.cardano-wallet.connected-button",
      "name": "connected-button",
      "source": "mesh-react",
      "description": "",
      "functions": [
        {
          "name": "ConnectedButton",
          "signature": "export default function ConnectedButton() {\n  const { name, disconnect, address } = useWallet();\n\n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger asChild>\n        <Button variant=\"outline\">\n          {address.slice(0, 6)}...{address.slice(-6)}\n        </Button>\n      </DropdownMenuTrigger>\n      <DropdownMenuContent>\n        <DropdownMenuLabel>Wallet</DropdownMenuLabel>\n        <DropdownMenuItem\n          onClick={() => {\n            navigator.clipboard.writeText(address);\n          }}\n        >\n          Copy Address\n        </DropdownMenuItem>\n        {name == \"Mesh Web3 Services\" && (\n          <DropdownMenuItem\n            onClick={() => {\n              window.open(\"https://web3.meshjs.dev/dashboard\", \"_blank\");\n            }}\n          >\n            Open Web3 Wallet\n          </DropdownMenuItem>\n        )}\n        <DropdownMenuSeparator />\n        <DropdownMenuItem\n          onClick={() => {\n            disconnect();\n          }}\n        >\n          Disconnect\n        </DropdownMenuItem>\n      </DropdownMenuContent>\n    </DropdownMenu>\n  );\n}",
          "documentation": "",
          "parameters": [],
          "returnType": "React.JSX.Element",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/cardano-wallet/connected-button.tsx"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.cardano-wallet.data",
      "name": "data",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.cardano-wallet.index",
      "name": "index",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.cardano-wallet.screen-burner",
      "name": "screen-burner",
      "source": "mesh-react",
      "description": "",
      "functions": [
        {
          "name": "ScreenBurner",
          "signature": "export default function ScreenBurner({\n  networkId,\n  provider,\n  setOpen,\n}: {\n  networkId: 0 | 1;\n  provider: IFetcher & ISubmitter;\n  setOpen: Function;\n}) {\n  const [loading, setLoading] = useState(false);\n  const [hasKeyInStorage, setHasKeyInStorage] = useState(false);\n  const { setWallet } = useWallet();\n\n  function getKeyFromStorage() {\n    return localStorage.getItem(localstoragekey);\n  }\n\n  useEffect(() => {\n    const key = getKeyFromStorage();\n    if (key) {\n      setHasKeyInStorage(true);\n    }\n  }, []);\n\n  function createWallet(key: string) {\n    setTimeout(() => {\n      const wallet = new MeshWallet({\n        networkId: networkId,\n        fetcher: provider,\n        submitter: provider,\n        key: {\n          type: \"root\",\n          bech32: key as string,\n        },\n      });\n\n      if (!hasKeyInStorage) {\n        localStorage.setItem(localstoragekey, key);\n      }\n\n      setWallet(wallet, screens.burner.title);\n      setLoading(false);\n      setOpen(false);\n    }, 500);\n  }\n\n  function handleRestoreWallet() {\n    setLoading(true);\n    const key = getKeyFromStorage();\n    createWallet(key as string);\n  }\n\n  function handleCreateWallet() {\n    setLoading(true);\n    const key = MeshWallet.brew(true) as string;\n    createWallet(key as string);\n  }\n\n  return (\n    <div className=\"mesh-flex mesh-flex-row mesh-flex-gap-4 mesh-items-center mesh-justify-center\">\n      {loading ? (\n        <>Setting up wallet...</>\n      ) : (\n        <>\n          {hasKeyInStorage && (\n            <Button\n              variant=\"outline\"\n              onClick={() => {\n                handleRestoreWallet();\n              }}\n              disabled={loading}\n            >\n              Restore wallet\n            </Button>\n          )}\n          <Button\n            variant=\"outline\"\n            onClick={() => {\n              handleCreateWallet();\n            }}\n            disabled={loading}\n          >\n            Create wallet\n          </Button>\n        </>\n      )}\n    </div>\n  );\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "__0",
              "type": "{ networkId: 0 | 1; provider: any; setOpen: Function; }",
              "optional": false
            }
          ],
          "returnType": "React.JSX.Element",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/cardano-wallet/screen-burner.tsx"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.cardano-wallet.screen-main",
      "name": "screen-main",
      "source": "mesh-react",
      "description": "",
      "functions": [
        {
          "name": "ScreenMain",
          "signature": "export default function ScreenMain({\n  injectFn,\n  setOpen,\n  setScreen,\n  persist,\n  cardanoPeerConnect,\n  burnerWallet,\n  webauthn,\n  showDownload,\n  web3Services,\n}: {\n  injectFn?: () => Promise<void>;\n  setOpen: Function;\n  setScreen: Function;\n  persist: boolean;\n  cardanoPeerConnect: boolean;\n  burnerWallet: boolean;\n  webauthn: boolean;\n  showDownload: boolean;\n  web3Services?: EnableWeb3WalletOptions;\n}) {\n  const wallets = useWalletList({ injectFn });\n  const { connect, setBitcoinWallet } = useWallet();\n\n  return (\n    <TooltipProvider>\n      <div className=\"mesh-grid mesh-gap-4 mesh-py-4 mesh-grid-cols-5 mesh-place-items-center mesh-gap-y-8\">\n        {wallets.map((wallet, index) => (\n          <WalletIcon\n            key={index}\n            icon={wallet.icon}\n            name={wallet.name}\n            action={() => {\n              connect(wallet.id, persist);\n              setOpen(false);\n            }}\n          />\n        ))}\n\n        {web3Services && (\n          <Web3Services\n            options={web3Services}\n            setOpen={setOpen}\n            persist={persist}\n          />\n        )}\n\n        {webauthn && (\n          <WalletIcon\n            iconReactNode={IconFingerprint()}\n            name={screens.webauthn.title}\n            action={() => {\n              setScreen(\"webauthn\");\n            }}\n          />\n        )}\n        {cardanoPeerConnect && (\n          <WalletIcon\n            iconReactNode={IconMonitorSmartphone()}\n            name={screens.p2p.title}\n            action={() => {\n              setScreen(\"p2p\");\n            }}\n          />\n        )}\n        {burnerWallet && (\n          <WalletIcon\n            iconReactNode={IconBookDashed()}\n            name={screens.burner.title}\n            action={() => {\n              setScreen(\"burner\");\n            }}\n          />\n        )}\n\n        {showDownload && (\n          <WalletIcon\n            iconReactNode={IconDownload()}\n            name={`Download`}\n            action={() => {\n              window.open(\n                \"https://developers.cardano.org/showcase/?tags=wallet\",\n                \"_blank\",\n              );\n            }}\n          />\n        )}\n\n        <WalletIcon\n          iconReactNode={IconBitcoin()}\n          name={\"Bitcoin\"}\n          action={async () => {\n            const wallet = await BrowserWallet.enable(\n              \"Mesh SDK want to connect\",\n            );\n            setBitcoinWallet(wallet, \"Bitcoin\");\n            setOpen(false);\n          }}\n        />\n      </div>\n    </TooltipProvider>\n  );\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "__0",
              "type": "{ injectFn?: (() => Promise<void>) | undefined; setOpen: Function; setScreen: Function; persist: boolean; cardanoPeerConnect: boolean; burnerWallet: boolean; webauthn: boolean; showDownload: boolean; web3Services?: any; }",
              "optional": false
            }
          ],
          "returnType": "React.JSX.Element",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/cardano-wallet/screen-main.tsx"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.cardano-wallet.screen-p2p",
      "name": "screen-p2p",
      "source": "mesh-react",
      "description": "",
      "functions": [
        {
          "name": "ScreenP2P",
          "signature": "export default function ScreenP2P({\n  cardanoPeerConnect,\n  setOpen,\n}: {\n  cardanoPeerConnect?: {\n    dAppInfo: {\n      name: string;\n      url: string;\n    };\n    announce: string[];\n  };\n  setOpen: Function;\n}) {\n  const dAppConnect = useRef<DAppPeerConnect | null>(null);\n  const qrCodeField = useRef<HTMLDivElement | null>(null);\n  const [address, setAddress] = useState(\"\");\n  const [copied, setCopied] = useState(false);\n  const { connect } = useWallet();\n\n  useEffect(() => {\n    if (cardanoPeerConnect) {\n      if (dAppConnect.current === null) {\n        dAppConnect.current = new DAppPeerConnect({\n          dAppInfo: {\n            name: cardanoPeerConnect.dAppInfo.name,\n            url: cardanoPeerConnect.dAppInfo.url,\n          },\n          announce: cardanoPeerConnect.announce,\n          onApiInject: async (name: string, address: string) => {\n            // console.log(5, \"onApiInject\", name, address);\n            await connect(name);\n            setOpen(false);\n          },\n          onApiEject: (name: string, address: string) => {\n            // console.log(5, \"onApiEject\", name, address);\n          },\n          onConnect: (address: string, walletInfo?: IWalletInfo) => {\n            // console.log(5, \"Connected to wallet\", address, walletInfo);\n          },\n          onDisconnect: () => {\n            // console.log(5, \"Disconnected from wallet\");\n          },\n          verifyConnection: (\n            walletInfo: IWalletInfo,\n            callback: (granted: boolean, autoconnect: boolean) => void,\n          ) => {\n            // console.log(5, \"verifyConnection\", walletInfo);\n            callback(true, true);\n          },\n          useWalletDiscovery: true,\n        });\n\n        if (dAppConnect.current) {\n          const address = dAppConnect.current.getAddress();\n          setAddress(address);\n          if (qrCodeField.current !== null) {\n            dAppConnect.current.generateQRCode(qrCodeField.current);\n          }\n        }\n      }\n    }\n  }, []);\n\n  return (\n    <div className=\"mesh-flex mesh-flex-col mesh-items-center mesh-justify-center\">\n      <div style={{ marginTop: 16, marginBottom: 16 }} ref={qrCodeField}></div>\n      <Button\n        variant=\"outline\"\n        onClick={() => {\n          navigator.clipboard.writeText(address);\n          setCopied(true);\n        }}\n      >\n        {copied ? \"Copied\" : \"Copy Address\"}\n      </Button>\n    </div>\n  );\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "__0",
              "type": "{ cardanoPeerConnect?: { dAppInfo: { name: string; url: string; }; announce: string[]; } | undefined; setOpen: Function; }",
              "optional": false
            }
          ],
          "returnType": "React.JSX.Element",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/cardano-wallet/screen-p2p.tsx"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.cardano-wallet.screen-webauthn",
      "name": "screen-webauthn",
      "source": "mesh-react",
      "description": "",
      "functions": [
        {
          "name": "ScreenWebauthn",
          "signature": "export default function ScreenWebauthn({\n  url,\n  networkId,\n  provider,\n  setOpen,\n}: {\n  url: string;\n  networkId: 0 | 1;\n  provider: IFetcher & ISubmitter;\n  setOpen: Function;\n}) {\n  const [loading, setLoading] = useState(false);\n  const [userName, setUserName] = useState<string>(\"\");\n  const [password, setPassword] = useState<string>(\"\");\n  const { setWallet } = useWallet();\n\n  function createWallet(root: string) {\n    setTimeout(() => {\n      const wallet = new MeshWallet({\n        networkId: networkId,\n        fetcher: provider,\n        submitter: provider,\n        key: {\n          type: \"root\",\n          bech32: root,\n        },\n      });\n      setWallet(wallet, screens.webauthn.title);\n      setLoading(false);\n      setOpen(false);\n    }, 500);\n  }\n\n  async function handleConnect() {\n    setLoading(true);\n    const res = await connect({ username: userName, password, serverUrl: url });\n    if (res.success && res.wallet) {\n      createWallet(res.wallet.bech32PrivateKey);\n    }\n  }\n\n  return (\n    <div className=\"mesh-flex mesh-flex-row mesh-flex-gap-4 mesh-items-center mesh-justify-center\">\n      {loading ? (\n        <>Connecting wallet...</>\n      ) : (\n        <>\n          <div className=\"mesh-flex mesh-flex-col mesh-gap-6 mesh-w-full mesh-mx-8\">\n            <div className=\"mesh-grid mesh-gap-2\">\n              <Label htmlFor=\"username\">Username</Label>\n              <Input\n                id=\"username\"\n                type=\"username\"\n                placeholder=\"adalovelace\"\n                value={userName}\n                onChange={(e) => setUserName(e.target.value)}\n              />\n              <p className=\"mesh-text-gray-500 mesh-text-xs\">\n                Unique to the application you are connecting.\n              </p>\n            </div>\n            <div className=\"mesh-grid mesh-gap-2\">\n              <div className=\"mesh-flex mesh-items-center\">\n                <Label htmlFor=\"password\">Unique Code</Label>\n              </div>\n              <Input\n                id=\"password\"\n                type=\"password\"\n                placeholder=\"********\"\n                value={password}\n                onChange={(e) => setPassword(e.target.value)}\n              />\n              <p className=\"mesh-text-gray-500 mesh-text-xs\">\n                Additional security to derive your wallet.\n              </p>\n            </div>\n            <Button\n              className=\"mesh-w-full\"\n              onClick={() => handleConnect()}\n              disabled={!userName || userName.length < 6}\n            >\n              Connect\n            </Button>\n          </div>\n        </>\n      )}\n    </div>\n  );\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "__0",
              "type": "{ url: string; networkId: 0 | 1; provider: any; setOpen: Function; }",
              "optional": false
            }
          ],
          "returnType": "React.JSX.Element",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/cardano-wallet/screen-webauthn.tsx"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.cardano-wallet.wallet-icon",
      "name": "wallet-icon",
      "source": "mesh-react",
      "description": "",
      "functions": [
        {
          "name": "WalletIcon",
          "signature": "export default function WalletIcon({\n  icon,\n  name,\n  action,\n  iconReactNode,\n  loading = false,\n}: {\n  icon?: string;\n  name: string;\n  action: () => void;\n  iconReactNode?: React.ReactNode;\n  loading?: boolean;\n}) {\n  return (\n    <Tooltip delayDuration={0} defaultOpen={false}>\n      <TooltipTrigger asChild>\n        <button\n          className=\"mesh-flex mesh-items-center mesh-justify-center mesh-rounded-lg mesh-w-10 mesh-h-10 mesh-bg-neutral-50 mesh-border mesh-border-zinc-700 hover:mesh-border-zinc-200 mesh-cursor-pointer\"\n          onClick={action}\n          disabled={loading}\n        >\n          {icon && !loading && (\n            <img src={icon} alt={name} className=\"mesh-w-8 mesh-h-8\" />\n          )}\n          {!loading && iconReactNode && iconReactNode}\n          {loading && <span className=\"text-black\">...</span>}\n        </button>\n      </TooltipTrigger>\n      <TooltipContent>\n        <p>{name}</p>\n      </TooltipContent>\n    </Tooltip>\n  );\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "__0",
              "type": "{ icon?: string | undefined; name: string; action: () => void; iconReactNode?: React.ReactNode; loading?: boolean | undefined; }",
              "optional": false
            }
          ],
          "returnType": "React.JSX.Element",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/cardano-wallet/wallet-icon.tsx"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.cardano-wallet.web3-services",
      "name": "web3-services",
      "source": "mesh-react",
      "description": "",
      "functions": [
        {
          "name": "Web3Services",
          "signature": "export default function Web3Services({\n  options,\n  setOpen,\n  persist,\n}: {\n  options: EnableWeb3WalletOptions;\n  setOpen: Function;\n  persist: boolean;\n}) {\n  const { setWallet, setWeb3UserData } = useWallet();\n  const [loading, setLoading] = useState(false);\n\n  async function loadWallet(directTo: UserControlledWalletDirectTo) {\n    setLoading(true);\n    const _options: EnableWeb3WalletOptions = {\n      networkId: 0,\n      fetcher: options.fetcher,\n      submitter: options.submitter,\n      appUrl: options.appUrl,\n      projectId: options.projectId,\n      directTo: directTo,\n    };\n    const wallet = await Web3Wallet.enable(_options);\n    const user = wallet.getUser();\n\n    setWeb3UserData(user);\n    setWallet(\n      wallet,\n      \"Mesh Web3 Services\",\n      persist\n        ? {\n            walletAddress: await wallet.getChangeAddress(),\n            user: user,\n          }\n        : undefined,\n    );\n    setLoading(false);\n    setOpen(false);\n  }\n\n  return (\n    <>\n      <WalletIcon\n        iconReactNode={IconGoogle()}\n        name={`Google`}\n        action={() => loadWallet(\"google\")}\n        loading={loading}\n      />\n      <WalletIcon\n        iconReactNode={IconDiscord()}\n        name={`Discord`}\n        action={() => loadWallet(\"discord\")}\n        loading={loading}\n      />\n      <WalletIcon\n        iconReactNode={IconTwitter()}\n        name={`Twitter`}\n        action={() => loadWallet(\"twitter\")}\n        loading={loading}\n      />\n    </>\n  );\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "__0",
              "type": "{ options: EnableWeb3WalletOptions; setOpen: Function; persist: boolean; }",
              "optional": false
            }
          ],
          "returnType": "React.JSX.Element",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/cardano-wallet/web3-services.tsx"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.cardano-wallet-dropdown.checkmark",
      "name": "checkmark",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.cardano-wallet-dropdown.chevron-down",
      "name": "chevron-down",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.cardano-wallet-dropdown.index",
      "name": "index",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.cardano-wallet-dropdown.menu-item",
      "name": "menu-item",
      "source": "mesh-react",
      "description": "",
      "functions": [
        {
          "name": "MenuItem",
          "signature": "export function MenuItem({\n  icon,\n  label,\n  action,\n  active,\n}: {\n  icon?: string;\n  label: string;\n  action: () => void;\n  active: boolean;\n}) {\n  return (\n    <div\n      className=\"mesh-flex mesh-cursor-pointer mesh-items-center mesh-px-4 mesh-py-2 mesh-opacity-80 hover:mesh-opacity-100 mesh-h-16\"\n      onClick={action}\n    >\n      {icon && <img className=\"mesh-pr-2 mesh-m-1 mesh-h-8\" src={icon} />}\n      <span className=\"mesh-mr-menu-item mesh-text-xl mesh-font-normal mesh-text-neutral-700 hover:mesh-text-black\">\n        {label\n          .split(\" \")\n          .map((word: string) => {\n            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();\n          })\n          .join(\" \")}\n      </span>\n    </div>\n  );\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "__0",
              "type": "{ icon?: string | undefined; label: string; action: () => void; active: boolean; }",
              "optional": false
            }
          ],
          "returnType": "React.JSX.Element",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/cardano-wallet-dropdown/menu-item.tsx"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.cardano-wallet-dropdown.wallet-balance",
      "name": "wallet-balance",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.common.button-dropdown",
      "name": "button-dropdown",
      "source": "mesh-react",
      "description": "",
      "functions": [
        {
          "name": "ButtonDropdown",
          "signature": "export default function ButtonDropdown({\n  children,\n  isDarkMode = false,\n  hideMenuList = false,\n  setHideMenuList,\n  onMouseEnter,\n  onMouseLeave,\n}: {\n  children: React.ReactNode;\n  isDarkMode?: boolean;\n  hideMenuList?: boolean;\n  setHideMenuList?: (hideMenuList: boolean) => void;\n  onMouseEnter?: () => void;\n  onMouseLeave?: () => void;\n}) {\n  return (\n    <button\n      className={`mesh-mr-menu-list mesh-flex mesh-w-60 mesh-items-center mesh-justify-center mesh-rounded-t-md mesh-border mesh-px-4 mesh-py-2 mesh-text-lg mesh-font-normal mesh-shadow-sm ${isDarkMode ? `mesh-bg-neutral-950\tmesh-text-neutral-50` : `mesh-bg-neutral-50\tmesh-text-neutral-950`}`}\n      onClick={() => setHideMenuList && setHideMenuList(!hideMenuList)}\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n    >\n      {children}\n    </button>\n  );\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "__0",
              "type": "{ children: React.ReactNode; isDarkMode?: boolean | undefined; hideMenuList?: boolean | undefined; setHideMenuList?: ((hideMenuList: boolean) => void) | undefined; onMouseEnter?: (() => void) | undefined; onMouseLeave?: (() => void) | undefined; }",
              "optional": false
            }
          ],
          "returnType": "React.JSX.Element",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/common/button-dropdown.tsx"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.common.button",
      "name": "button",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "ButtonProps",
          "definition": "export interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/common/button.tsx",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.common.cn",
      "name": "cn",
      "source": "mesh-react",
      "description": "",
      "functions": [
        {
          "name": "cn",
          "signature": "export function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "inputs",
              "type": "import(\"/Users/g/code/don-docs/dons-docs/node_modules/clsx/clsx\").ClassValue[]",
              "optional": false
            }
          ],
          "returnType": "any",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/common/cn.ts"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.common.dialog",
      "name": "dialog",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.common.dropdown-menu",
      "name": "dropdown-menu",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.common.input",
      "name": "input",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "InputProps",
          "definition": "export interface InputProps\n  extends React.InputHTMLAttributes<HTMLInputElement> {}",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/common/input.tsx",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.common.label",
      "name": "label",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.common.tooltip",
      "name": "tooltip",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.contexts.index",
      "name": "index",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.contexts.WalletContext",
      "name": "WalletContext",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.hooks.index",
      "name": "index",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.hooks.useAddress",
      "name": "useAddress",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.hooks.useAssets",
      "name": "useAssets",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.hooks.useLovelace",
      "name": "useLovelace",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.hooks.useNetwork",
      "name": "useNetwork",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.hooks.useRewardAddress",
      "name": "useRewardAddress",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.hooks.useWallet",
      "name": "useWallet",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.hooks.useWalletList",
      "name": "useWalletList",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.hooks.useWalletSubmit",
      "name": "useWalletSubmit",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.mesh-badge.index",
      "name": "index",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.mesh-badge.mesh-logo",
      "name": "mesh-logo",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.stake-button.index",
      "name": "index",
      "source": "mesh-react",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-svelte.src.lib.index",
      "name": "index",
      "source": "mesh-svelte",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-transaction.src.mesh-tx-builder.index",
      "name": "index",
      "source": "mesh-transaction",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "MeshTxBuilderOptions",
          "definition": "export interface MeshTxBuilderOptions {\n  fetcher?: IFetcher;\n  submitter?: ISubmitter;\n  evaluator?: IEvaluator;\n  serializer?: IMeshTxSerializer;\n  isHydra?: boolean;\n  params?: Partial<Protocol>;\n  verbose?: boolean;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/index.ts",
          "documentation": ""
        }
      ],
      "classes": [
        {
          "name": "MeshTxBuilder",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/index.ts",
          "extends": "MeshTxBuilderCore",
          "implements": [],
          "methods": [
            {
              "name": "getInputsRequiredSignatures",
              "signature": "protected getInputsRequiredSignatures(): {\n    paymentCreds: Set<string>;\n    byronAddresses: Set<string>;\n  } {\n    const byronAddresses = new Set<string>();\n    const paymentCreds = new Set<string>();\n    for (let input of this.meshTxBuilderBody.inputs) {\n      if (input.type === \"PubKey\") {\n        if (input.txIn.address) {\n          const address = CstAddress.fromString(input.txIn.address);\n          if (!address) {\n            continue;\n          }\n          const addressDetails = address.getProps();\n          const paymentCred = addressDetails.paymentPart;\n          if (paymentCred?.type === CstCredentialType.KeyHash) {\n            paymentCreds.add(paymentCred.hash);\n          }\n          if (addressDetails.type === CstAddressType.Byron) {\n            byronAddresses.add(input.txIn.address);\n          }\n        }\n      } else if (input.type === \"SimpleScript\") {\n        const nativeScript = this.getInputNativeScript(input);\n        if (nativeScript) {\n          let pubKeys = this.getNativeScriptPubKeys(nativeScript);\n          for (let pubKey of pubKeys) {\n            paymentCreds.add(pubKey);\n          }\n        }\n      }\n    }\n    return { paymentCreds, byronAddresses };\n  }",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getCollateralRequiredSignatures",
              "signature": "protected getCollateralRequiredSignatures(): {\n    collateralPaymentCreds: Set<string>;\n    collateralByronAddresses: Set<string>;\n  } {\n    const collateralByronAddresses = new Set<string>();\n    const collateralPaymentCreds = new Set<string>();\n    for (let collateral of this.meshTxBuilderBody.collaterals) {\n      if (collateral.type === \"PubKey\") {\n        if (collateral.txIn.address) {\n          const address = CstAddress.fromString(collateral.txIn.address);\n          if (!address) {\n            continue;\n          }\n          const addressDetails = address.getProps();\n          const paymentCred = addressDetails.paymentPart;\n          if (paymentCred?.type === CstCredentialType.KeyHash) {\n            collateralPaymentCreds.add(paymentCred.hash);\n          }\n          if (addressDetails.type === CstAddressType.Byron) {\n            collateralByronAddresses.add(collateral.txIn.address);\n          }\n        }\n      }\n    }\n    return { collateralPaymentCreds, collateralByronAddresses };\n  }",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getWithdrawalRequiredSignatures",
              "signature": "protected getWithdrawalRequiredSignatures(): Set<string> {\n    const withdrawalCreds = new Set<string>();\n    for (let withdrawal of this.meshTxBuilderBody.withdrawals) {\n      if (withdrawal.type === \"PubKeyWithdrawal\") {\n        const address = CstAddress.fromBech32(withdrawal.address);\n        const addressDetails = address.getProps();\n        const paymentCred = addressDetails.paymentPart;\n        if (paymentCred?.type === CstCredentialType.KeyHash) {\n          withdrawalCreds.add(paymentCred.hash);\n        }\n      }\n      if (withdrawal.type === \"SimpleScriptWithdrawal\") {\n        const nativeScript = this.getWithdrawalNativeScript(withdrawal);\n        if (nativeScript) {\n          let pubKeys = this.getNativeScriptPubKeys(nativeScript);\n          for (let pubKey of pubKeys) {\n            withdrawalCreds.add(pubKey);\n          }\n        }\n      }\n    }\n    return withdrawalCreds;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getCertificatesRequiredSignatures",
              "signature": "protected getCertificatesRequiredSignatures(): Set<string> {\n    const certCreds = new Set<string>();\n    for (let cert of this.meshTxBuilderBody.certificates) {\n      if (\n        cert.type !== \"BasicCertificate\" &&\n        cert.type !== \"SimpleScriptCertificate\"\n      ) {\n        continue;\n      }\n\n      const certNativeScript = this.getCertificateNativeScript(cert);\n\n      const certType = cert.certType;\n\n      if (certType.type === \"RegisterPool\") {\n        certCreds.add(certType.poolParams.operator);\n        for (let owner of certType.poolParams.owners) {\n          certCreds.add(owner);\n        }\n      } else if (certType.type === \"RetirePool\") {\n        certCreds.add(certType.poolId);\n      } else if (\n        certType.type === \"DRepRegistration\" ||\n        certType.type === \"DRepDeregistration\" ||\n        certType.type === \"DRepUpdate\"\n      ) {\n        if (cert.type === \"BasicCertificate\") {\n          const cstDrep = coreToCstDRep(certType.drepId);\n          const keyHash = cstDrep.toKeyHash();\n          if (keyHash) {\n            certCreds.add(keyHash);\n          }\n        } else if (certNativeScript) {\n          let pubKeys = this.getNativeScriptPubKeys(certNativeScript);\n          for (let pubKey of pubKeys) {\n            certCreds.add(pubKey);\n          }\n        }\n      } else if (\n        certType.type === \"StakeRegistrationAndDelegation\" ||\n        certType.type === \"VoteRegistrationAndDelegation\" ||\n        certType.type === \"StakeVoteRegistrationAndDelegation\" ||\n        certType.type === \"VoteDelegation\" ||\n        certType.type === \"RegisterStake\" ||\n        certType.type === \"StakeAndVoteDelegation\" ||\n        certType.type === \"DelegateStake\" ||\n        certType.type === \"DeregisterStake\"\n      ) {\n        if (cert.type === \"BasicCertificate\") {\n          const address = CstAddress.fromString(certType.stakeKeyAddress);\n          if (address) {\n            const addressDetails = address.getProps();\n            const paymentCred = addressDetails.paymentPart;\n            if (paymentCred?.type === CstCredentialType.KeyHash) {\n              certCreds.add(paymentCred.hash);\n            }\n          }\n        } else if (certNativeScript) {\n          let pubKeys = this.getNativeScriptPubKeys(certNativeScript);\n          for (let pubKey of pubKeys) {\n            certCreds.add(pubKey);\n          }\n        }\n      } else if (\n        certType.type === \"CommitteeHotAuth\" ||\n        certType.type === \"CommitteeColdResign\"\n      ) {\n        if (cert.type === \"BasicCertificate\") {\n          const address = CstAddress.fromString(\n            certType.committeeColdKeyAddress,\n          );\n          if (address) {\n            const addressDetails = address.getProps();\n            const paymentCred = addressDetails.paymentPart;\n            if (paymentCred?.type === CstCredentialType.KeyHash) {\n              certCreds.add(paymentCred.hash);\n            }\n          }\n        } else if (certNativeScript) {\n          let pubKeys = this.getNativeScriptPubKeys(certNativeScript);\n          for (let pubKey of pubKeys) {\n            certCreds.add(pubKey);\n          }\n        }\n      }\n    }\n    return certCreds;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getVoteRequiredSignatures",
              "signature": "protected getVoteRequiredSignatures(): Set<string> {\n    const voteCreds = new Set<string>();\n    for (let vote of this.meshTxBuilderBody.votes) {\n      if (vote.type !== \"SimpleScriptVote\") {\n        const nativeScript = this.getVoteNativeScript(vote);\n        if (nativeScript) {\n          let pubKeys = this.getNativeScriptPubKeys(nativeScript);\n          for (let pubKey of pubKeys) {\n            voteCreds.add(pubKey);\n          }\n        } else if (vote.type === \"BasicVote\") {\n          const voter = vote.vote.voter;\n          if (voter.type === \"DRep\") {\n            const drep = coreToCstDRep(voter.drepId);\n            const keyHash = drep.toKeyHash();\n            if (keyHash) {\n              voteCreds.add(keyHash);\n            }\n          } else if (voter.type === \"StakingPool\") {\n            voteCreds.add(voter.keyHash);\n          } else if (voter.type === \"ConstitutionalCommittee\") {\n            const hotCred = voter.hotCred;\n            if (hotCred.type === \"KeyHash\") {\n              voteCreds.add(hotCred.keyHash);\n            }\n          }\n        }\n      }\n    }\n    return voteCreds;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getInputNativeScript",
              "signature": "protected getInputNativeScript(txIn: TxIn): CstNativeScript | undefined {\n    if (txIn.type !== \"SimpleScript\") {\n      return undefined;\n    }\n\n    const scriptSource = txIn.simpleScriptTxIn.scriptSource;\n    if (scriptSource === undefined) {\n      return undefined;\n    }\n\n    if (scriptSource.type === \"Inline\") {\n      return this.getInlinedNativeScript(\n        scriptSource.txHash,\n        scriptSource.txIndex,\n      );\n    }\n    if (scriptSource.type === \"Provided\") {\n      return CstNativeScript.fromCbor(\n        <CardanoSDKUtil.HexBlob>scriptSource.scriptCode,\n      );\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "clone",
              "signature": "protected clone(): MeshTxBuilder {\n    const newBuilder = super._cloneCore<MeshTxBuilder>(() => {\n      return new MeshTxBuilder({\n        serializer: this.serializer,\n        fetcher: this.fetcher,\n        submitter: this.submitter,\n        evaluator: this.evaluator,\n        verbose: this.verbose,\n        params: { ...this._protocolParams },\n      });\n    });\n\n    newBuilder.txHex = this.txHex;\n\n    newBuilder.queriedTxHashes = structuredClone(this.queriedTxHashes);\n\n    newBuilder.queriedUTxOs = structuredClone(this.queriedUTxOs);\n    newBuilder.utxosWithRefScripts = structuredClone(this.utxosWithRefScripts);\n\n    return newBuilder;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            }
          ],
          "properties": [
            {
              "name": "serializer",
              "type": "IMeshTxSerializer",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "fetcher",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "submitter",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "evaluator",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "txHex",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "verbose",
              "type": "boolean",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "queriedTxHashes",
              "type": "Set<string>",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "queriedUTxOs",
              "type": "{ [x: string]: UTxO[]; }",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "utxosWithRefScripts",
              "type": "UTxO[]",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "serializeMockTx",
              "type": "() => any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "completeUnbalanced",
              "type": "(customizedTx?: any) => string",
              "documentation": "It builds the transaction query the blockchain for missing information",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "completeSync",
              "type": "(customizedTx?: any) => any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "complete",
              "type": "(customizedTx?: any) => Promise<any>",
              "documentation": "It builds the transaction and query the blockchain for missing information",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "selectUtxos",
              "type": "() => Promise<import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface\").TransactionPrototype>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "updateByTxPrototype",
              "type": "(selectionSkeleton: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface\").TransactionPrototype, final?: boolean) => Promise<void>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUtxosForSelection",
              "type": "() => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "sortTxParts",
              "type": "() => void",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "sortInputs",
              "type": "() => void",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "sortMints",
              "type": "() => void",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "compareCredentials",
              "type": "(credentialA: CstCredential, credentialB: CstCredential) => number",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "sortWithdrawals",
              "type": "() => void",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "sortVotes",
              "type": "() => void",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "evaluateRedeemers",
              "type": "() => Promise<void>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getRedeemerCosts",
              "type": "() => Omit<Action, \"data\">[]",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "completeUnbalancedSync",
              "type": "(customizedTx?: any) => any",
              "documentation": "It builds the transaction without dependencies",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "completeSigning",
              "type": "() => any",
              "documentation": "Complete the signing process",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "submitTx",
              "type": "(txHex: string) => Promise<string | undefined>",
              "documentation": "Submit transactions to the blockchain using the fetcher instance",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUTxOInfo",
              "type": "(txHash: string) => Promise<void>",
              "documentation": "Get the UTxO information from the blockchain",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "queryAllTxInfo",
              "type": "(incompleteTxIns: TxIn[], incompleteScriptSources: ScriptSource[], incompleteSimpleScriptSources: SimpleScriptSourceInfo[]) => Promise<void[]>",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "completeTxInformation",
              "type": "(input: TxIn) => void",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "completeInputInfo",
              "type": "(input: TxIn) => void",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "completeScriptInfo",
              "type": "(scriptSource: ScriptSource) => void",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "completeSimpleScriptInfo",
              "type": "(simpleScript: SimpleScriptSourceInfo) => void",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "isInputComplete",
              "type": "(txIn: TxIn) => boolean",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "isInputInfoComplete",
              "type": "(txIn: TxIn) => boolean",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "isMintComplete",
              "type": "(mint: MintItem) => boolean",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "isRefScriptInfoComplete",
              "type": "(scriptSource: ScriptSource) => boolean",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "isSimpleRefScriptInfoComplete",
              "type": "(simpleScriptSource: SimpleScriptSourceInfo) => boolean",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "completeSerialization",
              "type": "(customizedTx?: any) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "completeTxParts",
              "type": "() => Promise<void>",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "sanitizeOutputs",
              "type": "() => Promise<void>",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "collectAllRequiredSignatures",
              "type": "() => { keyHashes: Set<string>; byronAddresses: Set<string>; }",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getMintRequiredSignatures",
              "type": "() => Set<string>",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getTotalWithdrawal",
              "type": "() => bigint",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getTotalDeposit",
              "type": "() => bigint",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getTotalRefund",
              "type": "() => bigint",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getTotalMint",
              "type": "() => Asset[]",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getNativeScriptPubKeys",
              "type": "(nativeScript: CstNativeScript) => Set<string>",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getVoteNativeScript",
              "type": "(cert: Vote) => any",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getCertificateNativeScript",
              "type": "(cert: Certificate) => any",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getMintNativeScript",
              "type": "(mint: MintParam) => any",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getWithdrawalNativeScript",
              "type": "(withdrawal: Withdrawal) => any",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getInlinedNativeScript",
              "type": "(txHash: string, index: number) => any",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "makeTxId",
              "type": "(txHash: string, index: number) => string",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getTotalReferenceInputsSize",
              "type": "() => bigint",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getAllReferenceInputsSizes",
              "type": "() => Map<string, bigint>",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getBodyReferenceInputsSizes",
              "type": "() => [string, bigint][]",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getInputsReferenceInputsSizes",
              "type": "() => [string, bigint][]",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getMintsReferenceInputsSizes",
              "type": "() => [string, bigint][]",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getWithdrawalsReferenceInputsSizes",
              "type": "() => [string, bigint][]",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getVotesReferenceInputsSizes",
              "type": "() => [string, bigint][]",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getCertificatesReferenceInputsSizes",
              "type": "() => [string, bigint][]",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getTotalExecutionUnits",
              "type": "() => { memUnits: bigint; stepUnits: bigint; }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getSerializedSize",
              "type": "() => number",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getActualFee",
              "type": "() => bigint",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "calculateFee",
              "type": "() => bigint",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "calculateFeeForSerializedTx",
              "type": "(txSize: number) => bigint",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "calculateRefScriptFee",
              "type": "() => bigint",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "calculateRedeemersFee",
              "type": "() => bigint",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "calculateMinLovelaceForOutput",
              "type": "(output: Output) => bigint",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-transaction.src.mesh-tx-builder.tx-builder-core",
      "name": "tx-builder-core",
      "source": "mesh-transaction",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "MeshTxBuilderCore",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/tx-builder-core.ts",
          "extends": null,
          "implements": [],
          "methods": [
            {
              "name": "chainTx",
              "signature": "chainTx(txHex: string): this {\n    this.meshTxBuilderBody.chainedTxs.push(txHex);\n    return this;\n  }",
              "documentation": "Add a transaction that is used as input, but not yet reflected on the global blockchain",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "inputForEvaluation",
              "signature": "inputForEvaluation(input: UTxO) {\n    const utxoId = `${input.input.txHash}${input.input.outputIndex}`;\n    const currentUtxo = this.meshTxBuilderBody.inputsForEvaluation[utxoId];\n\n    if (currentUtxo) {\n      const {\n        dataHash: currentDataHash,\n        plutusData: currentPlutusData,\n        scriptRef: currentScriptRef,\n        scriptHash: currentScriptHash,\n      } = currentUtxo.output;\n\n      const updatedUtxo: UTxO = { ...currentUtxo };\n      if (currentDataHash) updatedUtxo.output.dataHash = currentDataHash;\n      if (currentPlutusData) updatedUtxo.output.plutusData = currentPlutusData;\n      if (currentScriptRef) updatedUtxo.output.scriptRef = currentScriptRef;\n      if (currentScriptHash) updatedUtxo.output.scriptHash = currentScriptHash;\n\n      this.meshTxBuilderBody.inputsForEvaluation[utxoId] = updatedUtxo;\n    } else {\n      this.meshTxBuilderBody.inputsForEvaluation[utxoId] = input;\n    }\n    return this;\n  }",
              "documentation": "Add a transaction input to provide information for offline evaluation",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "_cloneCore",
              "signature": "protected _cloneCore<T extends MeshTxBuilderCore>(\n    createInstance: () => T,\n  ): T {\n    this.queueAllLastItem();\n\n    const newBuilder = createInstance();\n\n    newBuilder.meshTxBuilderBody = cloneTxBuilderBody(this.meshTxBuilderBody);\n\n    newBuilder.txEvaluationMultiplier = this.txEvaluationMultiplier;\n    newBuilder.txOutput = this.txOutput\n      ? structuredClone(this.txOutput)\n      : undefined;\n\n    // Clone boolean flags\n    newBuilder.addingPlutusScriptInput = this.addingPlutusScriptInput;\n    newBuilder.plutusSpendingScriptVersion = this.plutusSpendingScriptVersion;\n    newBuilder.addingPlutusMint = this.addingPlutusMint;\n    newBuilder.plutusMintingScriptVersion = this.plutusMintingScriptVersion;\n    newBuilder.addingPlutusWithdrawal = this.addingPlutusWithdrawal;\n    newBuilder.plutusWithdrawalScriptVersion =\n      this.plutusWithdrawalScriptVersion;\n    newBuilder.addingPlutusVote = this.addingPlutusVote;\n    newBuilder.plutusVoteScriptVersion = this.plutusVoteScriptVersion;\n\n    newBuilder._protocolParams = structuredClone(this._protocolParams);\n\n    newBuilder.mintItem = this.mintItem\n      ? structuredClone(this.mintItem)\n      : undefined;\n    newBuilder.txInQueueItem = this.txInQueueItem\n      ? structuredClone(this.txInQueueItem)\n      : undefined;\n    newBuilder.withdrawalItem = this.withdrawalItem\n      ? structuredClone(this.withdrawalItem)\n      : undefined;\n    newBuilder.voteItem = this.voteItem\n      ? structuredClone(this.voteItem)\n      : undefined;\n    newBuilder.collateralQueueItem = this.collateralQueueItem\n      ? structuredClone(this.collateralQueueItem)\n      : undefined;\n    newBuilder.refScriptTxInQueueItem = this.refScriptTxInQueueItem\n      ? structuredClone(this.refScriptTxInQueueItem)\n      : undefined;\n    newBuilder.manualFee = this.manualFee;\n\n    return newBuilder;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            }
          ],
          "properties": [
            {
              "name": "txEvaluationMultiplier",
              "type": "number",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "txOutput",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "addingPlutusScriptInput",
              "type": "boolean",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "plutusSpendingScriptVersion",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "addingPlutusMint",
              "type": "boolean",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "plutusMintingScriptVersion",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "addingPlutusWithdrawal",
              "type": "boolean",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "plutusWithdrawalScriptVersion",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "addingPlutusVote",
              "type": "boolean",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "plutusVoteScriptVersion",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "manualFee",
              "type": "string | undefined",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "_protocolParams",
              "type": "Protocol",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "mintItem",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "txInQueueItem",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "withdrawalItem",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "voteItem",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "collateralQueueItem",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "refScriptTxInQueueItem",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "meshTxBuilderBody",
              "type": "MeshTxBuilderBody",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "txIn",
              "type": "(txHash: string, txIndex: number, amount?: Asset[] | undefined, address?: string | undefined, scriptSize?: number | undefined) => this",
              "documentation": "Set the input for transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "txInScript",
              "type": "(scriptCbor: string) => this",
              "documentation": "Set the script for transaction input",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "txInDatumValue",
              "type": "(datum: BuilderData, type?: BuilderData) => this",
              "documentation": "Set the input datum for transaction input",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "txInInlineDatumPresent",
              "type": "() => this",
              "documentation": "Tell the transaction builder that the input UTxO has inlined datum",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "simpleScriptTxInReference",
              "type": "(txHash: string, txIndex: number, spendingScriptHash?: string | undefined, scriptSize?: string | undefined) => this",
              "documentation": "Native script - Set the reference input where it would also be spent in the transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "txInRedeemerValue",
              "type": "(redeemer: BuilderData, type?: BuilderData, exUnits?: any) => this",
              "documentation": "Set the redeemer for the reference input to be spent in same transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "txOut",
              "type": "(address: string, amount: Asset[]) => this",
              "documentation": "Set the output for transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "txOutDatumHashValue",
              "type": "(datum: BuilderData, type?: BuilderData) => this",
              "documentation": "Set the output datum hash for transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "txOutInlineDatumValue",
              "type": "(datum: BuilderData, type?: BuilderData) => this",
              "documentation": "Set the output inline datum for transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "txOutDatumEmbedValue",
              "type": "(datum: BuilderData, type?: BuilderData) => this",
              "documentation": "Set the output embed datum for transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "txOutReferenceScript",
              "type": "(scriptCbor: string, version?: LanguageVersion) => this",
              "documentation": "Set the reference script to be attached with the output",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "spendingPlutusScript",
              "type": "(languageVersion: LanguageVersion) => this",
              "documentation": "Set the reference script to be attached with the output",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "spendingPlutusScriptV1",
              "type": "() => this",
              "documentation": "Set the instruction that it is currently using V1 Plutus spending scripts",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "spendingPlutusScriptV2",
              "type": "() => this",
              "documentation": "Set the instruction that it is currently using V2 Plutus spending scripts",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "spendingPlutusScriptV3",
              "type": "() => this",
              "documentation": "Set the instruction that it is currently using V3 Plutus spending scripts",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "spendingTxInReference",
              "type": "(txHash: string, txIndex: number, scriptSize?: string | undefined, scriptHash?: string | undefined) => this",
              "documentation": "Set the reference input where it would also be spent in the transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "spendingReferenceTxInInlineDatumPresent",
              "type": "() => this",
              "documentation": "[Alias of txInInlineDatumPresent] Set the instruction that the reference input has inline datum",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "spendingReferenceTxInRedeemerValue",
              "type": "(redeemer: BuilderData, type?: BuilderData, exUnits?: any) => this",
              "documentation": "[Alias of txInRedeemerValue] Set the redeemer for the reference input to be spent in same transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "readOnlyTxInReference",
              "type": "(txHash: string, txIndex: number, scriptSize?: number | undefined) => this",
              "documentation": "Specify a read only reference input. This reference input is not witnessing anything it is simply provided in the plutus script context.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "mintPlutusScript",
              "type": "(languageVersion: LanguageVersion) => this",
              "documentation": "Set the minting script for the current mint",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "mintPlutusScriptV1",
              "type": "() => this",
              "documentation": "Set the instruction that it is currently using V1 Plutus minting scripts",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "mintPlutusScriptV2",
              "type": "() => this",
              "documentation": "Set the instruction that it is currently using V2 Plutus minting scripts",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "mintPlutusScriptV3",
              "type": "() => this",
              "documentation": "Set the instruction that it is currently using V3 Plutus minting scripts",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "mint",
              "type": "(quantity: string, policy: string, name: string) => this",
              "documentation": "Set the minting value of transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "mintingScript",
              "type": "(scriptCBOR: string) => this",
              "documentation": "Set the minting script of current mint",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "mintTxInReference",
              "type": "(txHash: string, txIndex: number, scriptSize?: string | undefined, scriptHash?: string | undefined) => this",
              "documentation": "Use reference script for minting",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "mintReferenceTxInRedeemerValue",
              "type": "(redeemer: BuilderData, type?: BuilderData, exUnits?: any) => this",
              "documentation": "Set the redeemer for minting",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "mintRedeemerValue",
              "type": "(redeemer: BuilderData, type?: BuilderData, exUnits?: any) => this",
              "documentation": "Set the redeemer for the reference input to be spent in same transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "requiredSignerHash",
              "type": "(pubKeyHash: string) => this",
              "documentation": "Set the required signer of the transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "txInCollateral",
              "type": "(txHash: string, txIndex: number, amount?: Asset[] | undefined, address?: string | undefined) => this",
              "documentation": "Set the collateral UTxO for the transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "withdrawalPlutusScript",
              "type": "(languageVersion: LanguageVersion) => this",
              "documentation": "Set the instruction that it is currently using V1 Plutus withdrawal scripts",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "withdrawalPlutusScriptV1",
              "type": "() => this",
              "documentation": "Set the instruction that it is currently using a Plutus withdrawal scripts",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "withdrawalPlutusScriptV2",
              "type": "() => this",
              "documentation": "Set the instruction that it is currently using V2 Plutus withdrawal scripts",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "withdrawalPlutusScriptV3",
              "type": "() => this",
              "documentation": "Set the instruction that it is currently using V3 Plutus withdrawal scripts",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "withdrawal",
              "type": "(rewardAddress: string, coin: string) => this",
              "documentation": "Withdraw stake rewards in the MeshTxBuilder instance",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "withdrawalScript",
              "type": "(scriptCbor: string) => this",
              "documentation": "Add a withdrawal script to the MeshTxBuilder instance",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "withdrawalTxInReference",
              "type": "(txHash: string, txIndex: number, scriptSize?: string | undefined, scriptHash?: string | undefined) => this",
              "documentation": "Add a withdrawal reference to the MeshTxBuilder instance",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "withdrawalRedeemerValue",
              "type": "(redeemer: BuilderData, type?: BuilderData, exUnits?: any) => this",
              "documentation": "Set the transaction withdrawal redeemer value in the MeshTxBuilder instance",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "votePlutusScript",
              "type": "(languageVersion: LanguageVersion) => this",
              "documentation": "Set the instruction that it is currently using a Plutus voting scripts",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "votePlutusScriptV1",
              "type": "() => this",
              "documentation": "Set the instruction that it is currently using V1 Plutus voting scripts",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "votePlutusScriptV2",
              "type": "() => this",
              "documentation": "Set the instruction that it is currently using V2 Plutus voting scripts",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "votePlutusScriptV3",
              "type": "() => this",
              "documentation": "Set the instruction that it is currently using V3 Plutus voting scripts",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "vote",
              "type": "(voter: Voter, govActionId: RefTxIn, votingProcedure: VotingProcedure) => this",
              "documentation": "Add a vote in the MeshTxBuilder instance",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "voteScript",
              "type": "(scriptCbor: string) => this",
              "documentation": "Add a voting script to the MeshTxBuilder instance",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "voteTxInReference",
              "type": "(txHash: string, txIndex: number, scriptSize?: string | undefined, scriptHash?: string | undefined) => this",
              "documentation": "Add a vote reference to the MeshTxBuilder instance",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "voteRedeemerValue",
              "type": "(redeemer: BuilderData, type?: BuilderData, exUnits?: any) => this",
              "documentation": "Set the transaction vote redeemer value in the MeshTxBuilder instance",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "registerPoolCertificate",
              "type": "(poolParams: PoolParams) => this",
              "documentation": "Creates a pool registration certificate, and adds it to the transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "registerStakeCertificate",
              "type": "(rewardAddress: string) => this",
              "documentation": "Creates a stake registration certificate, and adds it to the transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "delegateStakeCertificate",
              "type": "(rewardAddress: string, poolId: string) => this",
              "documentation": "Creates a stake delegation certificate, and adds it to the transaction\nThis will delegate stake from the corresponding stake address to the pool",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "deregisterStakeCertificate",
              "type": "(rewardAddress: string) => this",
              "documentation": "Creates a stake deregister certificate, and adds it to the transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "retirePoolCertificate",
              "type": "(poolId: string, epoch: number) => this",
              "documentation": "Creates a pool retire certificate, and adds it to the transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "drepRegistrationCertificate",
              "type": "(drepId: string, anchor?: any, coin?: string) => this",
              "documentation": "Registers DRep certificate, and adds it to the transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "drepDeregistrationCertificate",
              "type": "(drepId: string, coin?: string) => this",
              "documentation": "Dregister DRep certificate, and adds it to the transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "drepUpdateCertificate",
              "type": "(drepId: string, anchor?: any) => this",
              "documentation": "Update DRep certificate, and adds it to the transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "voteDelegationCertificate",
              "type": "(drep: DRep, rewardAddress: string) => this",
              "documentation": "Dregister DRep certificate, and adds it to the transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "certificateScript",
              "type": "(scriptCbor: string, version?: any) => this",
              "documentation": "Adds a script witness to the certificate",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "certificateTxInReference",
              "type": "(txHash: string, txIndex: number, scriptSize?: string | undefined, scriptHash?: string | undefined, version?: any) => this",
              "documentation": "Adds a script witness to the certificate",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "certificateRedeemerValue",
              "type": "(redeemer: BuilderData, type?: BuilderData, exUnits?: any) => this",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "changeAddress",
              "type": "(addr: string) => this",
              "documentation": "Configure the address to accept change UTxO",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "invalidBefore",
              "type": "(slot: number) => this",
              "documentation": "Set the transaction valid interval to be valid only after the slot",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "invalidHereafter",
              "type": "(slot: number) => this",
              "documentation": "Set the transaction valid interval to be valid only before the slot",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "metadataValue",
              "type": "(label: string | number | bigint, metadata: any) => this",
              "documentation": "Add metadata to the transaction",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "signingKey",
              "type": "(skeyHex: string) => this",
              "documentation": "Sign the transaction with the private key",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "selectUtxosFrom",
              "type": "(extraInputs: UTxO[]) => this",
              "documentation": "Selects utxos to fill output value and puts them into inputs",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "protocolParams",
              "type": "(params: Protocol) => this",
              "documentation": "Set the protocol parameters to be used for the transaction other than the default one",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "setFee",
              "type": "(fee: string) => this",
              "documentation": "Sets a specific fee for the transaction to use",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "setTotalCollateral",
              "type": "(collateral: string) => this",
              "documentation": "Sets a total collateral for the transaction to use, a collateral return\nwill be generated to either the change address or the specified collateral return address",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "setCollateralReturnAddress",
              "type": "(address: string) => this",
              "documentation": "Sets the collateral return address, if none is set, the change address will be used",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "setNetwork",
              "type": "(network: any) => this",
              "documentation": "Sets the network to use, this is mainly to know the cost models to be used to calculate script integrity hash",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "queueAllLastItem",
              "type": "() => void",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "queueInput",
              "type": "() => void",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "queueMint",
              "type": "() => void",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "queueWithdrawal",
              "type": "() => void",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "queueVote",
              "type": "() => void",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "castRawDataToJsonString",
              "type": "(rawData: string | object) => any",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "castBuilderDataToRedeemer",
              "type": "(redeemer: BuilderData, type?: BuilderData, exUnits?: any) => Redeemer",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "updateRedeemer",
              "type": "(meshTxBuilderBody: MeshTxBuilderBody, txEvaluation: Omit<Action, \"data\">[], doNotUseMultiplier?: boolean) => void",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "addUtxosFromSelection",
              "type": "() => void",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "removeDuplicateInputs",
              "type": "() => void",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "removeDuplicateRefInputs",
              "type": "() => void",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "emptyTxBuilderBody",
              "type": "() => any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "reset",
              "type": "() => void",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-transaction.src.mesh-tx-builder.utils",
      "name": "utils",
      "source": "mesh-transaction",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-transaction.src.scripts.forge.script",
      "name": "forge.script",
      "source": "mesh-transaction",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "ForgeScript",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/scripts/forge.script.ts",
          "extends": null,
          "implements": [],
          "methods": [
            {
              "name": "withOneSignature",
              "signature": "static withOneSignature(address: string): string {\n    const keyHash = deserializeEd25519KeyHash(resolvePaymentKeyHash(address));\n    return buildScriptPubkey(keyHash).toCbor();\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "fromNativeScript",
              "signature": "static fromNativeScript(script: NativeScript): string {\n    return toNativeScript(script).toCbor();\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            }
          ],
          "properties": []
        }
      ]
    },
    {
      "key": "offchain:mesh-transaction.src.scripts.index",
      "name": "index",
      "source": "mesh-transaction",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-transaction.src.transaction.index",
      "name": "index",
      "source": "mesh-transaction",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "TransactionOptions",
          "definition": "export interface TransactionOptions extends MeshTxBuilderOptions {\n  initiator: IInitiator;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/transaction/index.ts",
          "documentation": ""
        }
      ],
      "classes": [
        {
          "name": "Transaction",
          "documentation": "Deprecated - Use `MeshTxBuilder` instead",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/transaction/index.ts",
          "extends": null,
          "implements": [],
          "methods": [
            {
              "name": "attachMetadata",
              "signature": "static attachMetadata(cborTx: string, cborTxMetadata: string) {\n    const tx = deserializeTx(cborTx);\n    const txAuxData = tx.auxiliaryData() ?? new Serialization.AuxiliaryData();\n\n    txAuxData.setMetadata(\n      Serialization.GeneralTransactionMetadata.fromCbor(\n        CardanoSDKUtil.HexBlob(cborTxMetadata),\n      ),\n    );\n\n    if (\n      Cardano.computeAuxiliaryDataHash(txAuxData.toCore())?.toString() !==\n      tx.body().auxiliaryDataHash()?.toString()\n    ) {\n      throw new Error(\n        \"[Transaction] attachMetadata: The metadata hash does not match the auxiliary data hash.\",\n      );\n    }\n\n    return new Tx(tx.body(), tx.witnessSet(), txAuxData).toCbor().toString();\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "deattachMetadata",
              "signature": "static deattachMetadata(cborTx: string) {\n    const tx = deserializeTx(cborTx);\n    return new Tx(tx.body(), tx.witnessSet()).toCbor().toString();\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "maskMetadata",
              "signature": "static maskMetadata(cborTx: string) {\n    const tx = deserializeTx(cborTx);\n    const txMetadata = tx.auxiliaryData()?.metadata();\n\n    if (txMetadata !== undefined) {\n      const mockMetadata = new Map<\n        bigint,\n        Serialization.TransactionMetadatum\n      >();\n      txMetadata\n        .metadata()\n        ?.forEach((metadatum, label) =>\n          mockMetadata.set(label, mask(metadatum)),\n        );\n      const txAuxData = tx.auxiliaryData();\n      txMetadata.setMetadata(mockMetadata);\n      txAuxData?.setMetadata(txMetadata);\n      return new Tx(tx.body(), tx.witnessSet(), txAuxData).toCbor().toString();\n    }\n\n    return cborTx;\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "readMetadata",
              "signature": "static readMetadata(cborTx: string) {\n    const tx = deserializeTx(cborTx);\n    return tx.auxiliaryData()?.metadata()?.toCbor().toString() ?? \"\";\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "writeMetadata",
              "signature": "static writeMetadata(cborTx: string, cborTxMetadata: string) {\n    const tx = deserializeTx(cborTx);\n    const txAuxData = tx.auxiliaryData() ?? new Serialization.AuxiliaryData();\n\n    txAuxData.setMetadata(\n      Serialization.GeneralTransactionMetadata.fromCbor(\n        CardanoSDKUtil.HexBlob(cborTxMetadata),\n      ),\n    );\n\n    return new Tx(tx.body(), tx.witnessSet(), txAuxData).toCbor().toString();\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "sendAssets",
              "signature": "sendAssets(recipient: Recipient, assets: Asset[] | string): Transaction {\n    if (typeof assets === \"string\") {\n      assets = [\n        {\n          unit: \"lovelace\",\n          quantity: assets,\n        },\n      ];\n    }\n    if (typeof recipient === \"string\") {\n      this.txBuilder.txOut(recipient, assets);\n    }\n    if (typeof recipient === \"object\") {\n      this.txBuilder.txOut(recipient.address, assets);\n      if (recipient.datum) {\n        if (recipient.datum.inline) {\n          this.txBuilder.txOutInlineDatumValue(recipient.datum.value);\n        } else {\n          this.txBuilder.txOutDatumHashValue(recipient.datum.value);\n        }\n      }\n    }\n\n    return this;\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "sendLovelace",
              "signature": "sendLovelace(recipient: Recipient, lovelace: string): Transaction {\n    return this.sendAssets(recipient, lovelace);\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\nUse sendAssets instead:\n```ts\nthis.sendAssets(recipient, lovelace);\n```\n\nDeprecation reason - Unnecessary implementation which might cause confusion.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "sendToken",
              "signature": "sendToken(recipient: Recipient, ticker: Token, amount: string): Transaction {\n    const assets = [{ unit: SUPPORTED_TOKENS[ticker], quantity: amount }];\n    return this.sendAssets(recipient, assets);\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\nPlease use sendAssets with helper function to obtain token unit instead:\n```ts\nconst assets = [{ unit: SUPPORTED_TOKENS.GIMBAL, quantity: \"100\" }]\ntransaction.sendAssets(recipient, assets)\n```\n\nDeprecation reason - Required maintenance on tokens.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "sendValue",
              "signature": "sendValue(recipient: Recipient, value: UTxO): Transaction {\n    const assets = value.output.amount;\n    return this.sendAssets(recipient, assets);\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\n```ts\nconst assets = value.output.amount;\nthis.sendAssets(recipient, assets);\n```\nDeprecation reason - Unnecessary implementation which might cause confusion.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "setTxInputs",
              "signature": "setTxInputs(inputs: UTxO[]): Transaction {\n    inputs.forEach((input) => {\n      this.txBuilder.txIn(\n        input.input.txHash,\n        input.input.outputIndex,\n        input.output.amount,\n        input.output.address,\n        input.output.scriptRef ? input.output.scriptRef.length / 2 : 0,\n      );\n    });\n\n    return this;\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "setTxRefInputs",
              "signature": "setTxRefInputs(inputs: UTxO[]): Transaction {\n    inputs.forEach((input) => {\n      this.txBuilder.readOnlyTxInReference(\n        input.input.txHash,\n        input.input.outputIndex,\n      );\n    });\n\n    return this;\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "setNativeScriptInput",
              "signature": "setNativeScriptInput(script: NativeScript, utxo: UTxO): Transaction {\n    const { scriptCbor } =\n      this.txBuilder.serializer.deserializer.script.deserializeNativeScript(\n        script,\n      );\n    this.txBuilder\n      .txIn(\n        utxo.input.txHash,\n        utxo.input.outputIndex,\n        utxo.output.amount,\n        utxo.output.address,\n      )\n      .txInScript(scriptCbor!);\n\n    return this;\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\nSets the native script for the transaction.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "redeemValue",
              "signature": "redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): Transaction {\n    const { value, script, datum, redeemer } = options;\n    const red = redeemer || {\n      data: { alternative: 0, fields: [\"mesh\"] },\n      budget: DEFAULT_REDEEMER_BUDGET,\n    };\n\n    if (\"code\" in script) {\n      // Provided script for redemption\n      this.isCollateralNeeded = true;\n      this.spendingPlutusScript(script)\n        .txIn(\n          value.input.txHash,\n          value.input.outputIndex,\n          value.output.amount,\n          value.output.address,\n          value.output.scriptRef ? value.output.scriptRef.length / 2 : 0,\n        )\n        .txInScript(script.code)\n        .txInRedeemerValue(red.data, \"Mesh\", red.budget);\n    }\n\n    if (\"output\" in script) {\n      // Reference script for redemption\n      if (!script.output.scriptRef) {\n        throw new Error(\"redeemValue: No script reference found in UTxO\");\n      }\n      const scriptRef = fromScriptRef(script.output.scriptRef);\n      if (!scriptRef || !(\"code\" in scriptRef)) {\n        throw new Error(\"redeemValue: Script reference not found\");\n      }\n\n      this.isCollateralNeeded = true;\n      this.spendingPlutusScript(scriptRef)\n        .txIn(\n          value.input.txHash,\n          value.input.outputIndex,\n          value.output.amount,\n          value.output.address,\n        )\n        .spendingTxInReference(\n          script.input.txHash,\n          script.input.outputIndex,\n          (script.output.scriptRef.length / 2).toString(),\n          script.output.scriptHash,\n        )\n        .txInRedeemerValue(red.data, \"Mesh\", red.budget);\n    }\n\n    if (datum) {\n      // Provided datum for redemption\n      this.txBuilder.txInDatumValue(datum);\n    } else {\n      // Reference datum for redemption\n      this.txBuilder.txInInlineDatumPresent();\n    }\n    // if (typeof datum === \"object\" && \"output\" in datum) {\n    //   // Reference datum for redemption\n    // } else {\n    //   // Provided datum for redemption\n    //   if (datum) {\n    //   }\n    // }\n\n    return this;\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "mintAsset",
              "signature": "mintAsset(\n    forgeScript: string | PlutusScript | UTxO,\n    mint: Mint,\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget },\n  ): Transaction {\n    const assetQuantity = mint.assetQuantity;\n    let assetNameHex = stringToHex(mint.assetName);\n    const referenceAssetNameHex = CIP68_100(assetNameHex);\n    if (mint.cip68ScriptAddress) {\n      assetNameHex = CIP68_222(assetNameHex);\n    }\n    let policyId = \"\";\n    switch (typeof forgeScript) {\n      case \"string\":\n        policyId = deserializeNativeScript(forgeScript).hash().toString();\n        this.txBuilder\n          .mint(assetQuantity, policyId, assetNameHex)\n          .mintingScript(forgeScript);\n        if (mint.cip68ScriptAddress) {\n          this.txBuilder\n            .mint(assetQuantity, policyId, referenceAssetNameHex)\n            .mintingScript(forgeScript);\n        }\n\n        break;\n\n      case \"object\":\n        if (!redeemer)\n          throw new Error(\n            \"burnAsset: Redeemer data is required for Plutus minting\",\n          );\n        if (\"code\" in forgeScript) {\n          // Burn plutus script assets with provided script\n          policyId = deserializePlutusScript(\n            forgeScript.code,\n            forgeScript.version,\n          )\n            .hash()\n            .toString();\n\n          this.isCollateralNeeded = true;\n          this.mintPlutusScript(forgeScript)\n            .mint(assetQuantity, policyId, assetNameHex)\n            .mintingScript(forgeScript.code)\n            .mintRedeemerValue(redeemer.data, \"Mesh\", redeemer.budget);\n          if (mint.cip68ScriptAddress) {\n            this.mintPlutusScript(forgeScript)\n              .mint(assetQuantity, policyId, referenceAssetNameHex)\n              .mintingScript(forgeScript.code)\n              .mintRedeemerValue(redeemer.data, \"Mesh\", redeemer.budget);\n          }\n          break;\n        }\n        if (\"output\" in forgeScript) {\n          // Burn plutus script assets with reference script\n          if (!forgeScript.output.scriptRef) {\n            throw new Error(\"mintAsset: No script reference found in UTxO\");\n          }\n          const script = fromScriptRef(forgeScript.output.scriptRef);\n          if (!script) {\n            throw new Error(\"mintAsset: Script reference not found\");\n          }\n\n          if (\"code\" in script) {\n            policyId = deserializePlutusScript(script.code, script.version)\n              .hash()\n              .toString();\n\n            this.isCollateralNeeded = true;\n            this.mintPlutusScript(script)\n              .mint(assetQuantity, policyId, assetNameHex)\n              .mintTxInReference(\n                forgeScript.input.txHash,\n                forgeScript.input.outputIndex,\n                (forgeScript.output.scriptRef.length / 2).toString(),\n                forgeScript.output.scriptHash,\n              )\n              .mintRedeemerValue(redeemer.data, \"Mesh\", redeemer.budget);\n            if (mint.cip68ScriptAddress) {\n              this.mintPlutusScript(script)\n                .mint(assetQuantity, policyId, referenceAssetNameHex)\n                .mintTxInReference(\n                  forgeScript.input.txHash,\n                  forgeScript.input.outputIndex,\n                  (forgeScript.output.scriptRef.length / 2).toString(),\n                  forgeScript.output.scriptHash,\n                )\n                .mintRedeemerValue(redeemer.data, \"Mesh\", redeemer.budget);\n              break;\n            }\n\n            break;\n          } else {\n            // TODO: to implement reference script minting for native script tokens\n            throw new Error(\n              \"mintAsset: Reference script minting not implemented\",\n            );\n            // this.txBuilder\n            //   .mint(assetQuantity, policyId, assetName)\n            //   .mintTxInReference(\n            //     forgeScript.input.txHash,\n            //     forgeScript.input.outputIndex\n            //   );\n          }\n        }\n        break;\n    }\n\n    if (mint.recipient) {\n      this.sendAssets(mint.recipient, [\n        { unit: policyId + assetNameHex, quantity: mint.assetQuantity },\n      ]);\n    }\n    if (mint.cip68ScriptAddress) {\n      this.sendAssets(\n        {\n          address: mint.cip68ScriptAddress,\n          datum: { inline: true, value: metadataToCip68(mint.metadata) },\n        },\n        [\n          {\n            unit: policyId + referenceAssetNameHex,\n            quantity: mint.assetQuantity,\n          },\n        ],\n      );\n    }\n    if (!mint.cip68ScriptAddress && mint.metadata && mint.label) {\n      if (mint.label === \"721\" || mint.label === \"20\") {\n        let currentMetadata = this.txBuilder.meshTxBuilderBody.metadata;\n        if (currentMetadata.get(BigInt(mint.label)) === undefined) {\n          this.setMetadata(Number(mint.label), {\n            [policyId]: { [mint.assetName]: mint.metadata },\n          });\n        } else {\n          let metadataMap = metadataObjToMap({\n            [policyId]: { [mint.assetName]: mint.metadata },\n          } as object);\n          let newMetadata = mergeContents(\n            currentMetadata.get(BigInt(mint.label)) as Metadatum,\n            metadataMap,\n            mint.label === \"721\" ? 2 : 0,\n          );\n          this.setMetadata(Number(mint.label), newMetadata);\n        }\n      } else {\n        this.setMetadata(Number(mint.label), mint.metadata);\n      }\n    }\n\n    return this;\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "burnAsset",
              "signature": "burnAsset(\n    forgeScript: string | PlutusScript | UTxO,\n    asset: Asset,\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget },\n  ): Transaction {\n    const assetQuantity = \"-\" + asset.quantity;\n    const mint: Mint = {\n      assetName: hexToString(asset.unit.slice(POLICY_ID_LENGTH)),\n      assetQuantity: assetQuantity,\n    };\n    try {\n      this.mintAsset(forgeScript, mint, redeemer);\n    } catch (error) {\n      throw new Error(\"burnAsset: \" + error);\n    }\n\n    return this;\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "setChangeAddress",
              "signature": "setChangeAddress(changeAddress: string): Transaction {\n    this.txBuilder.changeAddress(changeAddress);\n    return this;\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\nSets the change address for the transaction.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "setCollateral",
              "signature": "setCollateral(collateral: UTxO[]): Transaction {\n    collateral.forEach((collateralUtxo) => {\n      this.txBuilder.txInCollateral(\n        collateralUtxo.input.txHash,\n        collateralUtxo.input.outputIndex,\n        collateralUtxo.output.amount,\n        collateralUtxo.output.address,\n      );\n    });\n\n    return this;\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\nSets the collateral for the transaction.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "setRequiredSigners",
              "signature": "setRequiredSigners(addresses: string[]): Transaction {\n    addresses.forEach((address) => {\n      const { pubKeyHash } =\n        this.txBuilder.serializer.deserializer.key.deserializeAddress(address);\n      this.txBuilder.requiredSignerHash(pubKeyHash);\n    });\n\n    return this;\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\nSets the required signers for the transaction.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "setTimeToExpire",
              "signature": "setTimeToExpire(slot: string): Transaction {\n    this.txBuilder.invalidHereafter(Number(slot));\n    return this;\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\n Set the time to live for the transaction.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "setTimeToStart",
              "signature": "setTimeToStart(slot: string): Transaction {\n    this.txBuilder.invalidBefore(Number(slot));\n    return this;\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\n Sets the start slot for the transaction.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "setMetadata",
              "signature": "setMetadata(label: number, metadata: Metadatum | object): Transaction {\n    this.txBuilder.metadataValue(label, metadata);\n    return this;\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\n Add a JSON metadata entry to the transaction.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "withdrawRewards",
              "signature": "withdrawRewards(rewardAddress: string, lovelace: string): Transaction {\n    this.txBuilder.withdrawal(rewardAddress, lovelace);\n    return this;\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "delegateStake",
              "signature": "delegateStake(rewardAddress: string, poolId: string): Transaction {\n    this.txBuilder.delegateStakeCertificate(\n      rewardAddress,\n      this.txBuilder.serializer.deserializer.cert.deserializePoolId(poolId),\n    );\n    return this;\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "deregisterStake",
              "signature": "deregisterStake(rewardAddress: string): Transaction {\n    this.txBuilder.deregisterStakeCertificate(rewardAddress);\n    return this;\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "registerStake",
              "signature": "registerStake(rewardAddress: string): Transaction {\n    this.txBuilder.registerStakeCertificate(rewardAddress);\n    return this;\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "registerPool",
              "signature": "registerPool(params: PoolParams): Transaction {\n    this.txBuilder.registerPoolCertificate(params);\n    return this;\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "retirePool",
              "signature": "retirePool(poolId: string, epochNo: number): Transaction {\n    this.txBuilder.retirePoolCertificate(poolId, epochNo);\n    return this;\n  }",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "build",
              "signature": "async build(balanced: Boolean = true): Promise<string> {\n    try {\n      await this.addCollateralIfNeeded();\n      await this.addTxInputsAsNeeded();\n      await this.addChangeAddress();\n      if (balanced) {\n        return this.txBuilder.complete();\n      } else {\n        return this.txBuilder.completeUnbalanced();\n      }\n    } catch (error) {\n      throw new Error(\n        `[Transaction] An error occurred during build: ${error}.`,\n      );\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "mintPlutusScript",
              "signature": "protected mintPlutusScript(script: PlutusScript) {\n    switch (script.version) {\n      case \"V1\":\n        this.txBuilder.mintPlutusScriptV1();\n        break;\n      case \"V2\":\n        this.txBuilder.mintPlutusScriptV2();\n        break;\n      case \"V3\":\n        this.txBuilder.mintPlutusScriptV3();\n        break;\n    }\n    return this.txBuilder;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "spendingPlutusScript",
              "signature": "protected spendingPlutusScript(script: PlutusScript) {\n    switch (script.version) {\n      case \"V1\":\n        this.txBuilder.spendingPlutusScriptV1();\n        break;\n      case \"V2\":\n        this.txBuilder.spendingPlutusScriptV2();\n        break;\n      case \"V3\":\n        this.txBuilder.spendingPlutusScriptV3();\n        break;\n    }\n    return this.txBuilder;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "addCollateralIfNeeded",
              "signature": "private async addCollateralIfNeeded() {\n    if (this.isCollateralNeeded) {\n      const collaterals = await this.initiator.getCollateral();\n      if (collaterals.length > 0) {\n        this.setCollateral(collaterals);\n        return;\n      }\n      const utxos = await this.initiator.getUtxos();\n      const pureLovelaceUtxos = utxos.filter(\n        (utxo) => utxo.output.amount.length === 1,\n      );\n\n      pureLovelaceUtxos.sort((a, b) => {\n        return (\n          Number(a.output.amount[0]?.quantity!) -\n          Number(a.output.amount[0]?.quantity!)\n        );\n      });\n\n      for (const utxo of pureLovelaceUtxos) {\n        if (Number(utxo.output.amount[0]?.quantity!) >= 5000000) {\n          return [utxo];\n        }\n      }\n\n      if (pureLovelaceUtxos.length === 0) {\n        throw new Error(\"No pure lovelace utxos found for collateral\");\n      }\n      this.setCollateral([pureLovelaceUtxos[0]!]);\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "addTxInputsAsNeeded",
              "signature": "private async addTxInputsAsNeeded() {\n    if (this.txBuilder.meshTxBuilderBody.extraInputs.length === 0) {\n      const utxos = await this.initiator.getUtxos();\n      this.txBuilder.selectUtxosFrom(utxos);\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "addChangeAddress",
              "signature": "private async addChangeAddress() {\n    if (this.txBuilder.meshTxBuilderBody.changeAddress === \"\") {\n      const changeAddress = await this.initiator.getChangeAddress();\n      this.setChangeAddress(changeAddress);\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ],
          "properties": [
            {
              "name": "txBuilder",
              "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/index\").MeshTxBuilder",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "initiator",
              "type": "IInitiator",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "isCollateralNeeded",
              "type": "boolean",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "setNetwork",
              "type": "(network: Network) => this",
              "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\nSets the network to use, this is mainly to know the cost models to be used to calculate script integrity hash",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-transaction.src.transaction.transaction-v2",
      "name": "transaction-v2",
      "source": "mesh-transaction",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "TransactionV2",
          "definition": "export interface TransactionV2 {\n  sendAssets(\n    receiver: string,\n    assets: Asset[],\n    datum?: Data,\n    inlineScript?: string,\n    isInline?: boolean,\n  ): this;\n  sendLovelace(recipient: Recipient, lovelace: string): this;\n  sendToken(recipient: Recipient, ticker: Token, amount: string): this;\n  sendValue(recipient: Recipient, value: UTxO): this;\n  setTxInputs(inputs: UTxO[]): this;\n  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;\n  mintAsset(\n    forgeScript: string | PlutusScript | UTxO,\n    mint: Mint,\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget },\n  ): this;\n  burnAsset(\n    forgeScript: string | PlutusScript | UTxO,\n    asset: Asset,\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget },\n  ): this;\n  setChangeAddress(changeAddress: string): this;\n  setCollateral(collateral: UTxO[]): this;\n  setRequiredSigners(addresses: string[]): this;\n  setTimeToExpire(slot: string): this;\n  setTimeToStart(slot: string): this;\n  setMetadata(\n    label: number,\n    metadata: unknown\n  ): this;\n  withdrawRewards(rewardAddress: string, lovelace: string): this;\n  delegateStake(rewardAddress: string, poolId: string): this;\n  deregisterStake(rewardAddress: string): this;\n  registerStake(rewardAddress: string): this;\n  registerPool(params: PoolParams): this;\n  retirePool(poolId: string, epochNo: number): this;\n  spendUtxo(utxo: UTxO, redeemer?: Data): this;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/transaction/transaction-v2.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-transaction.src.tx-parser.index",
      "name": "index",
      "source": "mesh-transaction",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "TxParser",
          "documentation": "TxParser class to parse transaction hex strings and resolve UTxOs.\n\nIt is used for either manipulating transactions or for unit testing transaction buildings.",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/tx-parser/index.ts",
          "extends": null,
          "implements": [],
          "methods": [],
          "properties": [
            {
              "name": "parse",
              "type": "(txHex: string, providedUtxos?: UTxO[]) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getBuilderBody",
              "type": "() => any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getBuilderBodyWithoutChange",
              "type": "() => any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "toTester",
              "type": "() => any",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-transaction.src.utils.index",
      "name": "index",
      "source": "mesh-transaction",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-transaction.src.utils.metadata",
      "name": "metadata",
      "source": "mesh-transaction",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "MetadataMergeLevel",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/utils/metadata\").MetadataMergeLevel",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/utils/metadata.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-wallet.src.app.index",
      "name": "index",
      "source": "mesh-wallet",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "AppWalletKeyType",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/app/index\").AppWalletKeyType",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/app/index.ts",
          "documentation": ""
        },
        {
          "name": "CreateAppWalletOptions",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/app/index\").CreateAppWalletOptions",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/app/index.ts",
          "documentation": ""
        }
      ],
      "classes": [
        {
          "name": "AppWallet",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/app/index.ts",
          "extends": null,
          "implements": [
            "ISigner",
            "ISubmitter"
          ],
          "methods": [
            {
              "name": "init",
              "signature": "async init() {\n    if (this._wallet) {\n      await this._wallet.init();\n    }\n  }",
              "documentation": "Initializes the wallet. This is a required call as fetching addresses from the wallet is an async operation.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getCollateralUnspentOutput",
              "signature": "async getCollateralUnspentOutput(\n    accountIndex = 0,\n    addressType: GetAddressType = \"payment\",\n  ): Promise<TransactionUnspentOutput[]> {\n    const utxos = await this.getUnspentOutputs(accountIndex, addressType);\n\n    // find utxos that are pure ADA-only\n    const pureAdaUtxos = utxos.filter((utxo) => {\n      return utxo.output().amount().multiasset() === undefined;\n    });\n\n    // sort utxos by their lovelace amount\n    pureAdaUtxos.sort((a, b) => {\n      return (\n        Number(a.output().amount().coin()) - Number(b.output().amount().coin())\n      );\n    });\n\n    // return the smallest utxo but not less than 5000000 lovelace\n    for (const utxo of pureAdaUtxos) {\n      if (Number(utxo.output().amount().coin()) >= 5000000) {\n        return [utxo];\n      }\n    }\n\n    return [];\n  }",
              "documentation": "Get a list of UTXOs to be used as collateral inputs for transactions with plutus script inputs.\n\nThis is used in transaction building.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getEnterpriseAddress",
              "signature": "getEnterpriseAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.enterpriseAddressBech32;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getPaymentAddress",
              "signature": "getPaymentAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.baseAddressBech32;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getRewardAddress",
              "signature": "getRewardAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.rewardAddressBech32;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getNetworkId",
              "signature": "getNetworkId(): number {\n    return this._wallet.getNetworkId();\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUsedAddress",
              "signature": "getUsedAddress(\n    accountIndex = 0,\n    keyIndex = 0,\n    addressType: GetAddressType = \"payment\",\n  ): Address {\n    if (addressType === \"enterprise\") {\n      return toAddress(this.getEnterpriseAddress(accountIndex, keyIndex));\n    } else {\n      return toAddress(this.getPaymentAddress(accountIndex, keyIndex));\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUnspentOutputs",
              "signature": "async getUnspentOutputs(\n    accountIndex = 0,\n    addressType: GetAddressType = \"payment\",\n  ): Promise<TransactionUnspentOutput[]> {\n    if (!this._fetcher) {\n      throw new Error(\n        \"[AppWallet] Fetcher is required to fetch UTxOs. Please provide a fetcher.\",\n      );\n    }\n    const account = this._wallet.getAccount(accountIndex);\n\n    const utxos = await this._fetcher.fetchAddressUTxOs(\n      addressType == \"enterprise\"\n        ? account.enterpriseAddressBech32\n        : account.baseAddressBech32,\n    );\n\n    return utxos.map((utxo) => toTxUnspentOutput(utxo));\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "signData",
              "signature": "async signData(\n    address: string,\n    payload: string,\n    accountIndex = 0,\n    keyIndex = 0,\n  ): Promise<DataSignature> {\n    try {\n      return this._wallet.signData(address, payload, accountIndex, keyIndex);\n    } catch (error) {\n      throw new Error(\n        `[AppWallet] An error occurred during signData: ${error}.`,\n      );\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "signTx",
              "signature": "async signTx(\n    unsignedTx: string,\n    partialSign = false,\n    accountIndex = 0,\n    keyIndex = 0,\n  ): Promise<string> {\n    try {\n      const tx = deserializeTx(unsignedTx);\n      if (\n        !partialSign &&\n        tx.witnessSet().vkeys() !== undefined &&\n        tx.witnessSet().vkeys()!.size() !== 0\n      )\n        throw new Error(\n          \"Signatures already exist in the transaction in a non partial sign call\",\n        );\n\n      const newSignatures = this._wallet.signTx(\n        unsignedTx,\n        accountIndex,\n        keyIndex,\n      );\n\n      let signedTx = EmbeddedWallet.addWitnessSets(unsignedTx, [newSignatures]);\n      return signedTx;\n    } catch (error) {\n      throw new Error(`[AppWallet] An error occurred during signTx: ${error}.`);\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "signTxSync",
              "signature": "signTxSync(\n    unsignedTx: string,\n    partialSign = false,\n    accountIndex = 0,\n    keyIndex = 0,\n  ): string {\n    try {\n      throw new Error(`[AppWallet] signTxSync() is not implemented.`);\n    } catch (error) {\n      throw new Error(`[AppWallet] An error occurred during signTx: ${error}.`);\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "signTxs",
              "signature": "async signTxs(\n    unsignedTxs: string[],\n    partialSign: boolean,\n  ): Promise<string[]> {\n    throw new Error(`[AppWallet] signTxs() is not implemented.`);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "submitTx",
              "signature": "submitTx(tx: string): Promise<string> {\n    if (!this._submitter) {\n      throw new Error(\n        \"[AppWallet] Submitter is required to submit transactions. Please provide a submitter.\",\n      );\n    }\n    return this._submitter.submitTx(tx);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "brew",
              "signature": "static brew(strength = 256): string[] {\n    return EmbeddedWallet.generateMnemonic(strength);\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "_fetcher",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_submitter",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_wallet",
              "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/embedded/index\").EmbeddedWallet",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-wallet.src.browser.browser-wallet",
      "name": "browser-wallet",
      "source": "mesh-wallet",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "BrowserWallet",
          "documentation": "Browser Wallet provides a set of APIs to interact with the blockchain. This wallet is compatible with Mesh transaction builders.\n\nThese wallets APIs are in accordance to CIP-30, which defines the API for apps to communicate with the user's wallet. Additional utility functions provided for developers that are useful for building applications.\n```javascript\nimport { BrowserWallet } from '@meshsdk/core';\n\nconst wallet = await BrowserWallet.enable('eternl');\n```",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/browser/browser-wallet.ts",
          "extends": null,
          "implements": [
            "IWallet"
          ],
          "methods": [
            {
              "name": "getAvailableWallets",
              "signature": "static async getAvailableWallets({\n    injectFn = undefined,\n  }: {\n    injectFn?: () => Promise<void>;\n  } = {}): Promise<Wallet[]> {\n    if (window === undefined) return [];\n\n    if (injectFn) await injectFn();\n\n    return BrowserWallet.getInstalledWallets();\n  }",
              "documentation": "Returns a list of wallets installed on user's device. Each wallet is an object with the following properties:\n- A name is provided to display wallet's name on the user interface.\n- A version is provided to display wallet's version on the user interface.\n- An icon is provided to display wallet's icon on the user interface.",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "getInstalledWallets",
              "signature": "static getInstalledWallets(): Wallet[] {\n    if (window === undefined) return [];\n    if (window.cardano === undefined) return [];\n\n    let wallets: Wallet[] = [];\n    for (const key in window.cardano) {\n      try {\n        const _wallet = window.cardano[key];\n        if (_wallet === undefined) continue;\n        if (_wallet.name === undefined) continue;\n        if (_wallet.icon === undefined) continue;\n        if (_wallet.apiVersion === undefined) continue;\n        wallets.push({\n          id: key,\n          name: key == \"nufiSnap\" ? \"MetaMask\" : _wallet.name,\n          icon: _wallet.icon,\n          version: _wallet.apiVersion,\n        });\n      } catch (e) {}\n    }\n\n    return wallets;\n  }",
              "documentation": "Returns a list of wallets installed on user's device. Each wallet is an object with the following properties:\n- A name is provided to display wallet's name on the user interface.\n- A version is provided to display wallet's version on the user interface.\n- An icon is provided to display wallet's icon on the user interface.",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "enable",
              "signature": "static async enable(\n    walletName: string,\n    extensions: Extension[] = [],\n  ): Promise<BrowserWallet> {\n    try {\n      const walletInstance = await BrowserWallet.resolveInstance(\n        walletName,\n        extensions,\n      );\n\n      if (walletInstance !== undefined)\n        return new BrowserWallet(walletInstance, walletName);\n\n      throw new Error(`Couldn't create an instance of wallet: ${walletName}`);\n    } catch (error) {\n      throw new Error(\n        `[BrowserWallet] An error occurred during enable: ${JSON.stringify(\n          error,\n        )}.`,\n      );\n    }\n  }",
              "documentation": "This is the entrypoint to start communication with the user's wallet. The wallet should request the user's permission to connect the web page to the user's wallet, and if permission has been granted, the wallet will be returned and exposing the full API for the app to use.\n\nQuery BrowserWallet.getInstalledWallets() to get a list of available wallets, then provide the wallet name for which wallet the user would like to connect with.",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "getBalance",
              "signature": "async getBalance(): Promise<Asset[]> {\n    const balance = await this._walletInstance.getBalance();\n    return fromValue(deserializeValue(balance));\n  }",
              "documentation": "Returns a list of assets in the wallet. This API will return every assets in the wallet. Each asset is an object with the following properties:\n- A unit is provided to display asset's name on the user interface.\n- A quantity is provided to display asset's quantity on the user interface.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getChangeAddress",
              "signature": "async getChangeAddress(): Promise<string> {\n    const changeAddress = await this._walletInstance.getChangeAddress();\n    return addressToBech32(deserializeAddress(changeAddress));\n  }",
              "documentation": "Returns an address owned by the wallet that should be used as a change address to return leftover assets during transaction creation back to the connected wallet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getCollateral",
              "signature": "async getCollateral(): Promise<UTxO[]> {\n    const deserializedCollateral = await this.getCollateralUnspentOutput();\n    return deserializedCollateral.map((dc) => fromTxUnspentOutput(dc));\n  }",
              "documentation": "This function shall return a list of one or more UTXOs (unspent transaction outputs) controlled by the wallet that are required to reach AT LEAST the combined ADA value target specified in amount AND the best suitable to be used as collateral inputs for transactions with plutus script inputs (pure ADA-only UTXOs).\n\nIf this cannot be attained, an error message with an explanation of the blocking problem shall be returned. NOTE: wallets are free to return UTXOs that add up to a greater total ADA value than requested in the amount parameter, but wallets must never return any result where UTXOs would sum up to a smaller total ADA value, instead in a case like that an error message must be returned.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getExtensions",
              "signature": "async getExtensions(): Promise<number[]> {\n    try {\n      const _extensions: { cip: number }[] =\n        await this._walletInstance.getExtensions();\n      return _extensions.map((e) => e.cip);\n    } catch (e) {\n      return [];\n    }\n  }",
              "documentation": "Return a list of supported CIPs of the wallet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getNetworkId",
              "signature": "getNetworkId(): Promise<number> {\n    return this._walletInstance.getNetworkId();\n  }",
              "documentation": "Returns the network ID of the currently connected account. 0 is testnet and 1 is mainnet but other networks can possibly be returned by wallets. Those other network ID values are not governed by CIP-30. This result will stay the same unless the connected account has changed.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getRewardAddresses",
              "signature": "async getRewardAddresses(): Promise<string[]> {\n    const rewardAddresses = await this._walletInstance.getRewardAddresses();\n    return rewardAddresses.map((ra) => addressToBech32(deserializeAddress(ra)));\n  }",
              "documentation": "Returns a list of reward addresses owned by the wallet. A reward address is a stake address that is used to receive rewards from staking, generally starts from `stake` prefix.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUnusedAddresses",
              "signature": "async getUnusedAddresses(): Promise<string[]> {\n    const unusedAddresses = await this._walletInstance.getUnusedAddresses();\n    return unusedAddresses.map((una) =>\n      addressToBech32(deserializeAddress(una)),\n    );\n  }",
              "documentation": "Returns a list of unused addresses controlled by the wallet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUsedAddresses",
              "signature": "async getUsedAddresses(): Promise<string[]> {\n    const usedAddresses = await this._walletInstance.getUsedAddresses();\n    return usedAddresses.map((usa) => addressToBech32(deserializeAddress(usa)));\n  }",
              "documentation": "Returns a list of used addresses controlled by the wallet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUtxos",
              "signature": "async getUtxos(): Promise<UTxO[]> {\n    const deserializedUTxOs = await this.getUsedUTxOs();\n    return deserializedUTxOs.map((du) => fromTxUnspentOutput(du));\n  }",
              "documentation": "Return a list of all UTXOs (unspent transaction outputs) controlled by the wallet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "signData",
              "signature": "async signData(\n    payload: string,\n    address?: string | undefined,\n    convertFromUTF8 = true,\n  ): Promise<DataSignature> {\n    if (address === undefined) {\n      address = (await this.getUsedAddresses())[0]!;\n      if (address === undefined) {\n        address = await this.getChangeAddress();\n      }\n    }\n\n    const _payload = convertFromUTF8 ? fromUTF8(payload) : payload;\n\n    if (address.startsWith(\"drep1\")) {\n      return this._walletInstance.cip95!.signData(address, _payload);\n    }\n\n    const signerAddress = toAddress(address).toBytes().toString();\n    return this._walletInstance.signData(signerAddress, _payload);\n  }",
              "documentation": "This endpoint utilizes the [CIP-8 - Message Signing](https://cips.cardano.org/cips/cip8/) to sign arbitrary data, to verify the data was signed by the owner of the private key.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "signTx",
              "signature": "async signTx(unsignedTx: string, partialSign = false): Promise<string> {\n    const witness = await this._walletInstance.signTx(unsignedTx, partialSign);\n    if (witness === \"\") {\n      return unsignedTx;\n    }\n    return BrowserWallet.addBrowserWitnesses(unsignedTx, witness);\n  }",
              "documentation": "Requests user to sign the provided transaction (tx). The wallet should ask the user for permission, and if given, try to sign the supplied body and return a signed transaction. partialSign should be true if the transaction provided requires multiple signatures.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "signTxs",
              "signature": "async signTxs(unsignedTxs: string[], partialSign = false): Promise<string[]> {\n    let witnessSets: string[] | undefined = undefined;\n    // Hardcoded behavior customized for different wallet for now as there is no standard confirmed\n    switch (this._walletName) {\n      case \"Typhon Wallet\":\n        if (this._walletInstance.signTxs) {\n          witnessSets = await this._walletInstance.signTxs(\n            unsignedTxs,\n            partialSign,\n          );\n        }\n        break;\n      default:\n        if (this._walletInstance.signTxs) {\n          witnessSets = await this._walletInstance.signTxs(\n            unsignedTxs.map((cbor) => ({\n              cbor,\n              partialSign,\n            })),\n          );\n        } else if (this._walletInstance.experimental.signTxs) {\n          witnessSets = await this._walletInstance.experimental.signTxs(\n            unsignedTxs.map((cbor) => ({\n              cbor,\n              partialSign,\n            })),\n          );\n        }\n        break;\n    }\n\n    if (!witnessSets) throw new Error(\"Wallet does not support signTxs\");\n\n    const signedTxs: string[] = [];\n    for (let i = 0; i < witnessSets.length; i++) {\n      const unsignedTx = unsignedTxs[i]!;\n      const cWitness = witnessSets[i]!;\n      if (cWitness === \"\") {\n        // It's possible that txs are signed just to give\n        // browser wallet the tx context\n        signedTxs.push(unsignedTx);\n      } else {\n        const signedTx = BrowserWallet.addBrowserWitnesses(\n          unsignedTx,\n          cWitness,\n        );\n        signedTxs.push(signedTx);\n      }\n    }\n\n    return signedTxs;\n  }",
              "documentation": "Experimental feature - sign multiple transactions at once (Supported wallet(s): Typhon)",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "submitTx",
              "signature": "submitTx(tx: string): Promise<string> {\n    return this._walletInstance.submitTx(tx);\n  }",
              "documentation": "Submits the signed transaction to the blockchain network.\n\nAs wallets should already have this ability to submit transaction, we allow apps to request that a transaction be sent through it. If the wallet accepts the transaction and tries to send it, it shall return the transaction ID for the app to track. The wallet can return error messages or failure if there was an error in sending it.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUsedAddress",
              "signature": "async getUsedAddress(): Promise<Address> {\n    const usedAddresses = await this._walletInstance.getUsedAddresses();\n    if (usedAddresses.length === 0) throw new Error(\"No used addresses found\");\n    return deserializeAddress(usedAddresses[0]!);\n  }",
              "documentation": "Get a used address of type Address from the wallet.\n\nThis is used in transaction building.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getCollateralUnspentOutput",
              "signature": "async getCollateralUnspentOutput(\n    limit = DEFAULT_PROTOCOL_PARAMETERS.maxCollateralInputs,\n  ): Promise<TransactionUnspentOutput[]> {\n    let collateral: string[] = [];\n    try {\n      collateral = (await this._walletInstance.getCollateral()) ?? [];\n    } catch (e) {\n      try {\n        collateral =\n          (await this._walletInstance.experimental.getCollateral()) ?? [];\n      } catch (e) {\n        console.error(e);\n      }\n    }\n    return collateral.map((c) => deserializeTxUnspentOutput(c)).slice(0, limit);\n  }",
              "documentation": "Get a list of UTXOs to be used as collateral inputs for transactions with plutus script inputs.\n\nThis is used in transaction building.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUsedUTxOs",
              "signature": "async getUsedUTxOs(): Promise<TransactionUnspentOutput[]> {\n    const utxos = (await this._walletInstance.getUtxos()) ?? [];\n    return utxos.map((u) => deserializeTxUnspentOutput(u));\n  }",
              "documentation": "Get a list of UTXOs to be used for transaction building.\n\nThis is used in transaction building.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getAssets",
              "signature": "async getAssets(): Promise<AssetExtended[]> {\n    const balance = await this.getBalance();\n    return balance\n      .filter((v) => v.unit !== \"lovelace\")\n      .map((v) => {\n        const policyId = v.unit.slice(0, POLICY_ID_LENGTH);\n        const assetName = v.unit.slice(POLICY_ID_LENGTH);\n        const fingerprint = resolveFingerprint(policyId, assetName);\n\n        return {\n          unit: v.unit,\n          policyId,\n          assetName,\n          fingerprint,\n          quantity: v.quantity,\n        };\n      });\n  }",
              "documentation": "A helper function to get the assets in the wallet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getLovelace",
              "signature": "async getLovelace(): Promise<string> {\n    const balance = await this.getBalance();\n    const nativeAsset = balance.find((v) => v.unit === \"lovelace\");\n\n    return nativeAsset !== undefined ? nativeAsset.quantity : \"0\";\n  }",
              "documentation": "A helper function to get the lovelace balance in the wallet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getPolicyIdAssets",
              "signature": "async getPolicyIdAssets(policyId: string): Promise<AssetExtended[]> {\n    const assets = await this.getAssets();\n    return assets.filter((v) => v.policyId === policyId);\n  }",
              "documentation": "A helper function to get the assets of a specific policy ID in the wallet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getPolicyIds",
              "signature": "async getPolicyIds(): Promise<string[]> {\n    const balance = await this.getBalance();\n    return Array.from(\n      new Set(balance.map((v) => v.unit.slice(0, POLICY_ID_LENGTH))),\n    ).filter((p) => p !== \"lovelace\");\n  }",
              "documentation": "A helper function to get the policy IDs of all the assets in the wallet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getDRep",
              "signature": "async getDRep(): Promise<\n    | {\n        publicKey: string;\n        publicKeyHash: string;\n        dRepIDCip105: string;\n      }\n    | undefined\n  > {\n    const pubDRepKey = await this.getPubDRepKey();\n    try {\n      if (pubDRepKey === undefined) return undefined;\n\n      const { dRepIDHash } = await BrowserWallet.dRepKeyToDRepID(pubDRepKey);\n\n      const dRepIDCip105 = hexToBech32(\"drep\", dRepIDHash);\n\n      // const dRepIDBech32 = buildDRepID(dRepKey, await this.getNetworkId());\n      // console.log(66, \"dRepIDBech32\", dRepIDBech32, dRepIDCip105 === dRepIDBech32);\n\n      return {\n        publicKey: pubDRepKey,\n        publicKeyHash: dRepIDHash,\n        dRepIDCip105: dRepIDCip105,\n      };\n    } catch (e) {\n      console.error(e);\n      return undefined;\n    }\n  }",
              "documentation": "The connected wallet account provides the account's public DRep Key, derivation as described in CIP-0105.\nThese are used by the client to identify the user's on-chain CIP-1694 interactions, i.e. if a user has registered to be a DRep.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getPubDRepKey",
              "signature": "async getPubDRepKey(): Promise<string | undefined> {\n    try {\n      if (this._walletInstance.cip95 === undefined) return undefined;\n\n      const pubDRepKey = await this._walletInstance.cip95.getPubDRepKey();\n      return pubDRepKey;\n    } catch (e) {\n      console.error(e);\n      return undefined;\n    }\n  }",
              "documentation": "The connected wallet account provides the account's public DRep Key, derivation as described in CIP-0105.\nThese are used by the client to identify the user's on-chain CIP-1694 interactions, i.e. if a user has registered to be a DRep.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getRegisteredPubStakeKeys",
              "signature": "async getRegisteredPubStakeKeys(): Promise<\n    | {\n        pubStakeKeys: string[];\n        pubStakeKeyHashes: string[];\n      }\n    | undefined\n  > {\n    try {\n      if (this._walletInstance.cip95 === undefined) return undefined;\n\n      const pubStakeKeys =\n        await this._walletInstance.cip95.getRegisteredPubStakeKeys();\n\n      const pubStakeKeyHashes = await Promise.all(\n        pubStakeKeys.map(async (pubStakeKey) => {\n          const { dRepIDHash } =\n            await BrowserWallet.dRepKeyToDRepID(pubStakeKey);\n          return dRepIDHash;\n        }),\n      );\n\n      return {\n        pubStakeKeys: pubStakeKeys,\n        pubStakeKeyHashes: pubStakeKeyHashes,\n      };\n    } catch (e) {\n      console.error(e);\n      return undefined;\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUnregisteredPubStakeKeys",
              "signature": "async getUnregisteredPubStakeKeys(): Promise<\n    | {\n        pubStakeKeys: string[];\n        pubStakeKeyHashes: string[];\n      }\n    | undefined\n  > {\n    try {\n      if (this._walletInstance.cip95 === undefined) return undefined;\n\n      const pubStakeKeys =\n        await this._walletInstance.cip95.getUnregisteredPubStakeKeys();\n\n      const pubStakeKeyHashes = await Promise.all(\n        pubStakeKeys.map(async (pubStakeKey) => {\n          const { dRepIDHash } =\n            await BrowserWallet.dRepKeyToDRepID(pubStakeKey);\n          return dRepIDHash;\n        }),\n      );\n\n      return {\n        pubStakeKeys: pubStakeKeys,\n        pubStakeKeyHashes: pubStakeKeyHashes,\n      };\n    } catch (e) {\n      console.error(e);\n      return undefined;\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "dRepKeyToDRepID",
              "signature": "private static async dRepKeyToDRepID(dRepKey: string): Promise<{\n    dRepKeyHex: Ed25519PublicKeyHex;\n    dRepID: Ed25519PublicKey;\n    dRepIDHash: Ed25519KeyHashHex;\n  }> {\n    const dRepKeyHex = Ed25519PublicKeyHex(dRepKey);\n    const dRepID = Ed25519PublicKey.fromHex(dRepKeyHex);\n    const dRepIDHash = (await dRepID.hash()).hex();\n    return {\n      dRepKeyHex,\n      dRepID,\n      dRepIDHash,\n    };\n  }",
              "documentation": "",
              "static": true,
              "visibility": "private"
            },
            {
              "name": "resolveInstance",
              "signature": "private static resolveInstance(\n    walletName: string,\n    extensions: Extension[] = [],\n  ) {\n    if (window.cardano === undefined) return undefined;\n    if (window.cardano[walletName] === undefined) return undefined;\n\n    const wallet = window.cardano[walletName];\n\n    if (extensions.length > 0) {\n      return wallet.enable({ extensions: extensions });\n    } else {\n      return wallet?.enable();\n    }\n  }",
              "documentation": "",
              "static": true,
              "visibility": "private"
            },
            {
              "name": "addBrowserWitnesses",
              "signature": "static addBrowserWitnesses(unsignedTx: string, witnesses: string) {\n    const cWitness = Serialization.TransactionWitnessSet.fromCbor(\n      CardanoSDKUtil.HexBlob(witnesses),\n    )\n      .vkeys()\n      ?.values();\n\n    if (cWitness === undefined) {\n      return unsignedTx;\n    }\n\n    let tx = deserializeTx(unsignedTx);\n    // let tx = Transaction.fromCbor(CardanoSDK.TxCBOR(txHex));\n    let witnessSet = tx.witnessSet();\n    let witnessSetVkeys = witnessSet.vkeys();\n    let witnessSetVkeysValues: Serialization.VkeyWitness[] = witnessSetVkeys\n      ? [...witnessSetVkeys.values(), ...cWitness]\n      : [...cWitness];\n    witnessSet.setVkeys(\n      Serialization.CborSet.fromCore(\n        witnessSetVkeysValues.map((vkw) => vkw.toCore()),\n        VkeyWitness.fromCore,\n      ),\n    );\n\n    return new Transaction(tx.body(), witnessSet, tx.auxiliaryData()).toCbor();\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "getSupportedExtensions",
              "signature": "static getSupportedExtensions(wallet: string) {\n    const _supportedExtensions = window?.cardano?.[wallet]?.supportedExtensions;\n    if (_supportedExtensions) return _supportedExtensions;\n    else return [];\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "walletInstance",
              "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/types/index\").WalletInstance",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-wallet.src.browser.index",
      "name": "index",
      "source": "mesh-wallet",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-wallet.src.embedded.index",
      "name": "index",
      "source": "mesh-wallet",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "AccountType",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/embedded/index\").AccountType",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/embedded/index.ts",
          "documentation": ""
        },
        {
          "name": "Account",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/embedded/index\").Account",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/embedded/index.ts",
          "documentation": ""
        },
        {
          "name": "EmbeddedWalletKeyType",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/embedded/index\").EmbeddedWalletKeyType",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/embedded/index.ts",
          "documentation": ""
        },
        {
          "name": "CreateEmbeddedWalletOptions",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/embedded/index\").CreateEmbeddedWalletOptions",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/embedded/index.ts",
          "documentation": ""
        }
      ],
      "classes": [
        {
          "name": "WalletStaticMethods",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/embedded/index.ts",
          "extends": null,
          "implements": [],
          "methods": [
            {
              "name": "privateKeyBech32ToPrivateKeyHex",
              "signature": "static privateKeyBech32ToPrivateKeyHex(_bech32: string): string {\n    const bech32DecodedBytes = BaseEncoding.bech32.decodeToBytes(_bech32).bytes;\n    const bip32PrivateKey = Bip32PrivateKey.fromBytes(bech32DecodedBytes);\n    return bytesToHex(bip32PrivateKey.bytes());\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "mnemonicToPrivateKeyHex",
              "signature": "static mnemonicToPrivateKeyHex(words: string[]): string {\n    const entropy = mnemonicToEntropy(words.join(\" \"));\n    const bip32PrivateKey = buildBip32PrivateKey(entropy);\n    return bytesToHex(bip32PrivateKey.bytes());\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "signingKeyToHexes",
              "signature": "static signingKeyToHexes(\n    paymentKey: string,\n    stakeKey: string,\n  ): [string, string] {\n    return [\n      paymentKey.startsWith(\"5820\") ? paymentKey.slice(4) : paymentKey,\n      stakeKey.startsWith(\"5820\") ? stakeKey.slice(4) : stakeKey,\n    ];\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "bip32BytesToPrivateKeyHex",
              "signature": "static bip32BytesToPrivateKeyHex(bip32Bytes: Uint8Array): string {\n    const bip32PrivateKey = Bip32PrivateKey.fromBytes(bip32Bytes);\n    return bytesToHex(bip32PrivateKey.bytes());\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "getAddresses",
              "signature": "static getAddresses(\n    paymentKey: Ed25519PrivateKey,\n    stakingKey: Ed25519PrivateKey,\n    networkId = 0,\n  ): {\n    baseAddress: Address;\n    enterpriseAddress: Address;\n    rewardAddress: Address;\n  } {\n    const baseAddress = buildBaseAddress(\n      networkId,\n      Hash28ByteBase16.fromEd25519KeyHashHex(\n        paymentKey.toPublic().hash().hex(),\n      ),\n      Hash28ByteBase16.fromEd25519KeyHashHex(\n        stakingKey.toPublic().hash().hex(),\n      ),\n    ).toAddress();\n\n    const enterpriseAddress = buildEnterpriseAddress(\n      networkId,\n      Hash28ByteBase16.fromEd25519KeyHashHex(\n        paymentKey.toPublic().hash().hex(),\n      ),\n    ).toAddress();\n\n    const rewardAddress = buildRewardAddress(\n      networkId,\n      Hash28ByteBase16.fromEd25519KeyHashHex(\n        stakingKey.toPublic().hash().hex(),\n      ),\n    ).toAddress();\n\n    return {\n      baseAddress: baseAddress,\n      enterpriseAddress: enterpriseAddress,\n      rewardAddress: rewardAddress,\n    };\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "getDRepKey",
              "signature": "static getDRepKey(\n    dRepKey: Ed25519PrivateKey,\n    networkId = 0,\n  ): {\n    pubDRepKey: string;\n    dRepIDBech32: DRepID;\n    dRepIDHash: Ed25519KeyHashHex;\n    dRepIDCip105: string;\n  } {\n    const pubDRepKey = dRepKey.toPublic().hex().toString();\n\n    const dRepIDBech32 = buildDRepID(\n      Ed25519PublicKeyHex(pubDRepKey),\n      networkId,\n    );\n    const dRep = DRep.newKeyHash(dRepKey.toPublic().hash().hex());\n    const dRepIDHash = dRep.toKeyHash()!;\n\n    const dRepIDCip105 = hexToBech32(\"drep\", dRepIDHash);\n\n    return {\n      pubDRepKey,\n      dRepIDBech32,\n      dRepIDHash,\n      dRepIDCip105,\n    };\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "generateMnemonic",
              "signature": "static generateMnemonic(strength = 256): string[] {\n    const mnemonic = generateMnemonic(strength);\n    return mnemonic.split(\" \");\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "addWitnessSets",
              "signature": "static addWitnessSets(txHex: string, witnesses: VkeyWitness[]): string {\n    let tx = deserializeTx(txHex);\n    let witnessSet = tx.witnessSet();\n    let witnessSetVkeys = witnessSet.vkeys();\n    let witnessSetVkeysValues: Serialization.VkeyWitness[] = witnessSetVkeys\n      ? [...witnessSetVkeys.values(), ...witnesses]\n      : witnesses;\n    witnessSet.setVkeys(\n      Serialization.CborSet.fromCore(\n        witnessSetVkeysValues.map((vkw) => vkw.toCore()),\n        VkeyWitness.fromCore,\n      ),\n    );\n    return new Transaction(tx.body(), witnessSet, tx.auxiliaryData()).toCbor();\n  }",
              "documentation": "",
              "static": true,
              "visibility": "public"
            }
          ],
          "properties": []
        },
        {
          "name": "EmbeddedWallet",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/embedded/index.ts",
          "extends": "WalletStaticMethods",
          "implements": [],
          "methods": [
            {
              "name": "init",
              "signature": "async init(): Promise<void> {\n    await Crypto.ready();\n    this.cryptoIsReady = true;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getAccount",
              "signature": "getAccount(accountIndex = 0, keyIndex = 0): Account {\n    if (this._walletSecret == undefined)\n      throw new Error(\"[EmbeddedWallet] No keys initialized\");\n\n    const { paymentKey, stakeKey, dRepKey } = buildKeys(\n      this._walletSecret,\n      accountIndex,\n      keyIndex,\n    );\n\n    const { baseAddress, enterpriseAddress, rewardAddress } =\n      WalletStaticMethods.getAddresses(paymentKey, stakeKey, this._networkId);\n\n    let _account: Account = {\n      baseAddress: baseAddress,\n      enterpriseAddress: enterpriseAddress,\n      rewardAddress: rewardAddress,\n\n      baseAddressBech32: baseAddress.toBech32(),\n      enterpriseAddressBech32: enterpriseAddress.toBech32(),\n      rewardAddressBech32: rewardAddress.toBech32(),\n\n      paymentKey: paymentKey,\n      stakeKey: stakeKey,\n      paymentKeyHex: paymentKey.hex(),\n      stakeKeyHex: stakeKey.hex(),\n    };\n\n    if (dRepKey) {\n      const { pubDRepKey, dRepIDBech32, dRepIDHash, dRepIDCip105 } =\n        WalletStaticMethods.getDRepKey(dRepKey, this._networkId);\n      _account.drepKey = dRepKey;\n      _account.pubDRepKey = pubDRepKey;\n      _account.dRepIDBech32 = dRepIDBech32;\n      _account.dRepIDHash = dRepIDHash;\n      _account.dRepIDCip105 = dRepIDCip105;\n    }\n\n    return _account;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getNetworkId",
              "signature": "getNetworkId(): number {\n    return this._networkId;\n  }",
              "documentation": "Get wallet network ID.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "signData",
              "signature": "signData(\n    address: string,\n    payload: string,\n    accountIndex = 0,\n    keyIndex = 0,\n  ): DataSignature {\n    try {\n      const { baseAddress, enterpriseAddress, rewardAddress, paymentKey } =\n        this.getAccount(accountIndex, keyIndex);\n\n      const foundAddress = [baseAddress, enterpriseAddress, rewardAddress].find(\n        (a) => a.toBech32() === address,\n      );\n\n      if (foundAddress === undefined)\n        throw new Error(\n          `[EmbeddedWallet] Address: ${address} doesn't belong to this account.`,\n        );\n\n      // todo tw\n      return signData(payload, {\n        address: Address.fromBech32(address),\n        key: paymentKey,\n      });\n    } catch (error) {\n      throw new Error(\n        `[EmbeddedWallet] An error occurred during signData: ${error}.`,\n      );\n    }\n  }",
              "documentation": "This endpoint utilizes the [CIP-8 - Message Signing](https://cips.cardano.org/cips/cip8/) to sign arbitrary data, to verify the data was signed by the owner of the private key.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "signTx",
              "signature": "signTx(\n    unsignedTx: string,\n    accountIndex = 0,\n    keyIndex = 0,\n    accountType: AccountType = \"payment\",\n  ): VkeyWitness {\n    try {\n      const txHash = deserializeTxHash(resolveTxHash(unsignedTx));\n\n      const { paymentKey, stakeKey, drepKey } = this.getAccount(\n        accountIndex,\n        keyIndex,\n      );\n\n      let key = paymentKey;\n      if (accountType === \"stake\") {\n        key = stakeKey;\n      } else if (accountType === \"drep\") {\n        if (!drepKey) throw new Error(\"DRep key not found\");\n        key = drepKey;\n      }\n\n      const vKeyWitness = new VkeyWitness(\n        key.toPublic().hex(),\n        key.sign(HexBlob(txHash)).hex(),\n      );\n\n      return vKeyWitness;\n    } catch (error) {\n      throw new Error(\n        `[EmbeddedWallet] An error occurred during signTx: ${error}.`,\n      );\n    }\n  }",
              "documentation": "This endpoints sign the provided transaction (unsignedTx) with the private key of the owner.",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "_walletSecret",
              "type": "string | [string, string] | undefined",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_networkId",
              "type": "number",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "cryptoIsReady",
              "type": "boolean",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-wallet.src.mesh.index",
      "name": "index",
      "source": "mesh-wallet",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "CreateMeshWalletOptions",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/mesh/index\").CreateMeshWalletOptions",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/mesh/index.ts",
          "documentation": ""
        }
      ],
      "classes": [
        {
          "name": "MeshWallet",
          "documentation": "Mesh Wallet provides a set of APIs to interact with the blockchain. This wallet is compatible with Mesh transaction builders.\n\nThere are 4 types of keys that can be used to create a wallet:\n- root: A private key in bech32 format, generally starts with `xprv1`\n- cli: CLI generated keys starts with `5820`. Payment key is required, and the stake key is optional.\n- mnemonic: A list of 24 words\n- address: A bech32 address that can be used to create a read-only wallet, generally starts with `addr` or `addr_test1`\n\n```javascript\nimport { MeshWallet, BlockfrostProvider } from '@meshsdk/core';\n\nconst provider = new BlockfrostProvider('<BLOCKFROST_API_KEY>');\n\nconst wallet = new MeshWallet({\n  networkId: 0,\n  fetcher: provider,\n  submitter: provider,\n  key: {\n    type: 'mnemonic',\n    words: [\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\"],\n  },\n});\n```\n\nPlease call `await wallet.init()` after creating the wallet to fetch the addresses from the wallet.",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/mesh/index.ts",
          "extends": null,
          "implements": [
            "IWallet"
          ],
          "methods": [
            {
              "name": "init",
              "signature": "async init() {\n    if (this._wallet && !this._wallet.cryptoIsReady) {\n      await this._wallet.init();\n      this.getAddressesFromWallet(this._wallet);\n    }\n  }",
              "documentation": "Initializes the wallet. This is a required call as fetching addresses from the wallet is an async operation.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getAddresses",
              "signature": "getAddresses() {\n    return this.addresses;\n  }",
              "documentation": "Returns all derived addresses from the wallet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getBalance",
              "signature": "async getBalance(): Promise<Asset[]> {\n    await this.init();\n\n    const utxos = await this.getUnspentOutputs();\n\n    const assets = new Map<string, number>();\n    utxos.map((utxo) => {\n      const _utxo = fromTxUnspentOutput(utxo);\n      _utxo.output.amount.map((asset) => {\n        const assetId = asset.unit;\n        const amount = Number(asset.quantity);\n        if (assets.has(assetId)) {\n          const quantity = assets.get(assetId)!;\n          assets.set(assetId, quantity + amount);\n        } else {\n          assets.set(assetId, amount);\n        }\n      });\n    });\n\n    const arrayAssets: Asset[] = Array.from(assets, ([unit, quantity]) => ({\n      unit,\n      quantity: quantity.toString(),\n    }));\n\n    return arrayAssets;\n  }",
              "documentation": "Returns a list of assets in the wallet. This API will return every assets in the wallet. Each asset is an object with the following properties:\n- A unit is provided to display asset's name on the user interface.\n- A quantity is provided to display asset's quantity on the user interface.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getChangeAddress",
              "signature": "async getChangeAddress(\n    addressType: GetAddressType = \"payment\",\n  ): Promise<string> {\n    await this.init();\n\n    if (this.addresses.baseAddressBech32 && addressType === \"payment\") {\n      return this.addresses.baseAddressBech32;\n    }\n    return this.addresses.enterpriseAddressBech32!;\n  }",
              "documentation": "Returns an address owned by the wallet that should be used as a change address to return leftover assets during transaction creation back to the connected wallet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getCollateral",
              "signature": "async getCollateral(\n    addressType: GetAddressType = \"payment\",\n  ): Promise<UTxO[]> {\n    await this.init();\n\n    const utxos = await this.getCollateralUnspentOutput(addressType);\n    return utxos.map((utxo, i) => {\n      return fromTxUnspentOutput(utxo);\n    });\n  }",
              "documentation": "This function shall return a list of one or more UTXOs (unspent transaction outputs) controlled by the wallet that are required to reach AT LEAST the combined ADA value target specified in amount AND the best suitable to be used as collateral inputs for transactions with plutus script inputs (pure ADA-only UTXOs).\n\nIf this cannot be attained, an error message with an explanation of the blocking problem shall be returned. NOTE: wallets are free to return UTXOs that add up to a greater total ADA value than requested in the amount parameter, but wallets must never return any result where UTXOs would sum up to a smaller total ADA value, instead in a case like that an error message must be returned.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getExtensions",
              "signature": "async getExtensions(): Promise<number[]> {\n    return [];\n  }",
              "documentation": "Return a list of supported CIPs of the wallet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getCollateralUnspentOutput",
              "signature": "async getCollateralUnspentOutput(\n    addressType: GetAddressType = \"payment\",\n  ): Promise<TransactionUnspentOutput[]> {\n    await this.init();\n\n    const utxos = await this.getUnspentOutputs(addressType);\n\n    // find utxos that are pure ADA-only\n    const pureAdaUtxos = utxos.filter((utxo) => {\n      return utxo.output().amount().multiasset() === undefined;\n    });\n\n    // sort utxos by their lovelace amount\n    pureAdaUtxos.sort((a, b) => {\n      return (\n        Number(a.output().amount().coin()) - Number(b.output().amount().coin())\n      );\n    });\n\n    // return the smallest utxo but not less than 5000000 lovelace\n    for (const utxo of pureAdaUtxos) {\n      if (Number(utxo.output().amount().coin()) >= 5000000) {\n        return [utxo];\n      }\n    }\n\n    return [];\n  }",
              "documentation": "Get a list of UTXOs to be used as collateral inputs for transactions with plutus script inputs.\n\nThis is used in transaction building.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getDRep",
              "signature": "async getDRep(): Promise<\n    | {\n        publicKey: string;\n        publicKeyHash: string;\n        dRepIDCip105: string;\n      }\n    | undefined\n  > {\n    await this.init();\n\n    if (\n      this.addresses.pubDRepKey &&\n      this.addresses.dRepIDHash &&\n      this.addresses.dRepIDCip105\n    )\n      return {\n        publicKey: this.addresses.pubDRepKey,\n        publicKeyHash: this.addresses.dRepIDHash,\n        dRepIDCip105: this.addresses.dRepIDCip105,\n      };\n\n    return undefined;\n  }",
              "documentation": "The connected wallet account provides the account's public DRep Key, derivation as described in CIP-0105.\nThese are used by the client to identify the user's on-chain CIP-1694 interactions, i.e. if a user has registered to be a DRep.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getNetworkId",
              "signature": "async getNetworkId(): Promise<number> {\n    return this._networkId;\n  }",
              "documentation": "Returns the network ID of the currently connected account. 0 is testnet and 1 is mainnet but other networks can possibly be returned by wallets. Those other network ID values are not governed by CIP-30. This result will stay the same unless the connected account has changed.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getRewardAddresses",
              "signature": "async getRewardAddresses(): Promise<string[]> {\n    return [this.addresses.rewardAddressBech32!];\n  }",
              "documentation": "Returns a list of reward addresses owned by the wallet. A reward address is a stake address that is used to receive rewards from staking, generally starts from `stake` prefix.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUnusedAddresses",
              "signature": "async getUnusedAddresses(): Promise<string[]> {\n    return [await this.getChangeAddress()];\n  }",
              "documentation": "Returns a list of unused addresses controlled by the wallet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUsedAddresses",
              "signature": "async getUsedAddresses(): Promise<string[]> {\n    return [await this.getChangeAddress()];\n  }",
              "documentation": "Returns a list of used addresses controlled by the wallet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUsedUTxOs",
              "signature": "async getUsedUTxOs(\n    addressType: GetAddressType = \"payment\",\n  ): Promise<TransactionUnspentOutput[]> {\n    await this.init();\n    return await this.getUnspentOutputs(addressType);\n  }",
              "documentation": "Get a list of UTXOs to be used for transaction building.\n\nThis is used in transaction building.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUtxos",
              "signature": "async getUtxos(addressType: GetAddressType = \"payment\"): Promise<UTxO[]> {\n    const utxos = await this.getUsedUTxOs(addressType);\n    return utxos.map((c) => fromTxUnspentOutput(c));\n  }",
              "documentation": "Return a list of all UTXOs (unspent transaction outputs) controlled by the wallet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "signData",
              "signature": "async signData(payload: string, address?: string): Promise<DataSignature> {\n    await this.init();\n\n    if (!this._wallet) {\n      throw new Error(\n        \"[MeshWallet] Read only wallet does not support signing data.\",\n      );\n    }\n    if (address === undefined) {\n      address = await this.getChangeAddress()!;\n    }\n    return this._wallet.signData(\n      address,\n      payload,\n      this._accountIndex,\n      this._keyIndex,\n    );\n  }",
              "documentation": "This endpoint utilizes the [CIP-8 - Message Signing](https://cips.cardano.org/cips/cip8/) to sign arbitrary data, to verify the data was signed by the owner of the private key.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "signTx",
              "signature": "async signTx(unsignedTx: string, partialSign = false): Promise<string> {\n    await this.init();\n\n    if (!this._wallet) {\n      throw new Error(\n        \"[MeshWallet] Read only wallet does not support signing data.\",\n      );\n    }\n\n    const tx = deserializeTx(unsignedTx);\n    if (\n      !partialSign &&\n      tx.witnessSet().vkeys() !== undefined &&\n      tx.witnessSet().vkeys()!.size() !== 0\n    )\n      throw new Error(\n        \"Signatures already exist in the transaction in a non partial sign call\",\n      );\n\n    const newSignatures = this._wallet.signTx(\n      unsignedTx,\n      this._accountIndex,\n      this._keyIndex,\n      this._accountType,\n    );\n\n    let signedTx = EmbeddedWallet.addWitnessSets(unsignedTx, [newSignatures]);\n    return signedTx;\n  }",
              "documentation": "Requests user to sign the provided transaction (tx). The wallet should ask the user for permission, and if given, try to sign the supplied body and return a signed transaction. partialSign should be true if the transaction provided requires multiple signatures.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "signTxs",
              "signature": "async signTxs(unsignedTxs: string[], partialSign = false): Promise<string[]> {\n    await this.init();\n\n    if (!this._wallet) {\n      throw new Error(\n        \"[MeshWallet] Read only wallet does not support signing data.\",\n      );\n    }\n\n    const signedTxs: string[] = [];\n\n    for (const unsignedTx of unsignedTxs) {\n      const signedTx = await this.signTx(unsignedTx, partialSign);\n      signedTxs.push(signedTx);\n    }\n\n    return signedTxs;\n  }",
              "documentation": "Experimental feature - sign multiple transactions at once.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "submitTx",
              "signature": "async submitTx(tx: string): Promise<string> {\n    if (!this._submitter) {\n      throw new Error(\n        \"[MeshWallet] Submitter is required to submit transactions. Please provide a submitter.\",\n      );\n    }\n    return this._submitter.submitTx(tx);\n  }",
              "documentation": "Submits the signed transaction to the blockchain network.\n\nAs wallets should already have this ability to submit transaction, we allow apps to request that a transaction be sent through it. If the wallet accepts the transaction and tries to send it, it shall return the transaction ID for the app to track. The wallet can return error messages or failure if there was an error in sending it.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUsedAddress",
              "signature": "getUsedAddress(addressType: GetAddressType = \"payment\"): Address {\n    if (this.addresses.baseAddressBech32 && addressType === \"payment\") {\n      return toAddress(this.addresses.baseAddressBech32);\n    } else {\n      return toAddress(this.addresses.enterpriseAddressBech32!);\n    }\n  }",
              "documentation": "Get a used address of type Address from the wallet.\n\nThis is used in transaction building.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUnspentOutputs",
              "signature": "async getUnspentOutputs(\n    addressType: GetAddressType = \"payment\",\n  ): Promise<TransactionUnspentOutput[]> {\n    if (!this._fetcher) {\n      throw new Error(\n        \"[MeshWallet] Fetcher is required to fetch UTxOs. Please provide a fetcher.\",\n      );\n    }\n\n    const utxos = await this._fetcher.fetchAddressUTxOs(\n      this.addresses.baseAddressBech32 && addressType == \"payment\"\n        ? this.addresses.baseAddressBech32!\n        : this.addresses.enterpriseAddressBech32!,\n    );\n\n    return utxos.map((utxo) => toTxUnspentOutput(utxo));\n  }",
              "documentation": "Get a list of UTXOs to be used for transaction building.\n\nThis is used in transaction building.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getAssets",
              "signature": "async getAssets(): Promise<AssetExtended[]> {\n    const balance = await this.getBalance();\n    return balance\n      .filter((v) => v.unit !== \"lovelace\")\n      .map((v) => {\n        const policyId = v.unit.slice(0, POLICY_ID_LENGTH);\n        const assetName = v.unit.slice(POLICY_ID_LENGTH);\n        const fingerprint = resolveFingerprint(policyId, assetName);\n\n        return {\n          unit: v.unit,\n          policyId,\n          assetName: toUTF8(assetName),\n          fingerprint,\n          quantity: v.quantity,\n        };\n      });\n  }",
              "documentation": "A helper function to get the assets in the wallet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getLovelace",
              "signature": "async getLovelace(): Promise<string> {\n    const balance = await this.getBalance();\n    const nativeAsset = balance.find((v) => v.unit === \"lovelace\");\n\n    return nativeAsset !== undefined ? nativeAsset.quantity : \"0\";\n  }",
              "documentation": "A helper function to get the lovelace balance in the wallet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getPolicyIdAssets",
              "signature": "async getPolicyIdAssets(policyId: string): Promise<AssetExtended[]> {\n    const assets = await this.getAssets();\n    return assets.filter((v) => v.policyId === policyId);\n  }",
              "documentation": "A helper function to get the assets of a specific policy ID in the wallet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getPolicyIds",
              "signature": "async getPolicyIds(): Promise<string[]> {\n    const balance = await this.getBalance();\n    return Array.from(\n      new Set(balance.map((v) => v.unit.slice(0, POLICY_ID_LENGTH))),\n    ).filter((p) => p !== \"lovelace\");\n  }",
              "documentation": "A helper function to get the policy IDs of all the assets in the wallet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getRegisteredPubStakeKeys",
              "signature": "async getRegisteredPubStakeKeys(): Promise<\n    | {\n        pubStakeKeys: string[];\n        pubStakeKeyHashes: string[];\n      }\n    | undefined\n  > {\n    console.warn(\"Not implemented yet\");\n    return undefined;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUnregisteredPubStakeKeys",
              "signature": "async getUnregisteredPubStakeKeys(): Promise<\n    | {\n        pubStakeKeys: string[];\n        pubStakeKeyHashes: string[];\n      }\n    | undefined\n  > {\n    console.warn(\"Not implemented yet\");\n    return undefined;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "createCollateral",
              "signature": "async createCollateral(): Promise<string> {\n    const tx = new Transaction({ initiator: this });\n    tx.sendLovelace(await this.getChangeAddress(), \"5000000\");\n    const unsignedTx = await tx.build();\n    const signedTx = await this.signTx(unsignedTx);\n    const txHash = await this.submitTx(signedTx);\n    return txHash;\n  }",
              "documentation": "A helper function to create a collateral input for a transaction.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getPubDRepKey",
              "signature": "getPubDRepKey(): {\n    pubDRepKey: string | undefined;\n    dRepIDBech32: string | undefined;\n    dRepIDHash: string | undefined;\n    dRepIDCip105: string | undefined;\n  } {\n    return {\n      pubDRepKey: this.addresses.pubDRepKey,\n      dRepIDBech32: this.addresses.dRepIDBech32,\n      dRepIDHash: this.addresses.dRepIDHash,\n      dRepIDCip105: this.addresses.dRepIDCip105,\n    };\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "brew",
              "signature": "static brew(privateKey = false, strength = 256): string[] | string {\n    const mnemonic = EmbeddedWallet.generateMnemonic(strength);\n\n    if (privateKey) {\n      return resolvePrivateKey(mnemonic);\n    }\n\n    return mnemonic;\n  }",
              "documentation": "Generate mnemonic or private key",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "getAddressesFromWallet",
              "signature": "private getAddressesFromWallet(wallet: EmbeddedWallet) {\n    const account = wallet.getAccount(this._accountIndex, this._keyIndex);\n\n    this.addresses = {\n      baseAddress: account.baseAddress,\n      enterpriseAddress: account.enterpriseAddress,\n      rewardAddress: account.rewardAddress,\n      baseAddressBech32: account.baseAddressBech32,\n      enterpriseAddressBech32: account.enterpriseAddressBech32,\n      rewardAddressBech32: account.rewardAddressBech32,\n\n      pubDRepKey: account.pubDRepKey,\n      dRepIDBech32: account.dRepIDBech32,\n      dRepIDHash: account.dRepIDHash,\n      dRepIDCip105: account.dRepIDCip105,\n    };\n  }",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "buildAddressFromBech32Address",
              "signature": "private buildAddressFromBech32Address(address: string) {\n    let pubKeyHash = undefined;\n    let stakeKeyHash = undefined;\n\n    const baseAddress = Address.fromBech32(address).asBase();\n    if (baseAddress) {\n      pubKeyHash = baseAddress.getPaymentCredential().hash;\n      stakeKeyHash = baseAddress.getStakeCredential().hash;\n    }\n    const enterpriseAddress = Address.fromBech32(address).asEnterprise();\n    if (enterpriseAddress) {\n      pubKeyHash = enterpriseAddress.getPaymentCredential().hash;\n    }\n\n    const rewardAddress = Address.fromBech32(address).asReward();\n    if (rewardAddress) {\n      stakeKeyHash = rewardAddress.getPaymentCredential().hash;\n    }\n\n    if (pubKeyHash && stakeKeyHash) {\n      this.addresses.baseAddress = buildBaseAddress(\n        this._networkId,\n        Hash28ByteBase16.fromEd25519KeyHashHex(Ed25519KeyHashHex(pubKeyHash)),\n        Hash28ByteBase16.fromEd25519KeyHashHex(\n          Ed25519KeyHashHex(Ed25519KeyHashHex(stakeKeyHash)),\n        ),\n      ).toAddress();\n      this.addresses.baseAddressBech32 = this.addresses.baseAddress.toBech32();\n    }\n\n    if (pubKeyHash) {\n      this.addresses.enterpriseAddress = buildEnterpriseAddress(\n        this._networkId,\n        Hash28ByteBase16.fromEd25519KeyHashHex(Ed25519KeyHashHex(pubKeyHash)),\n      ).toAddress();\n      this.addresses.enterpriseAddressBech32 =\n        this.addresses.enterpriseAddress.toBech32();\n    }\n\n    if (stakeKeyHash) {\n      this.addresses.rewardAddress = buildRewardAddress(\n        this._networkId,\n        Hash28ByteBase16.fromEd25519KeyHashHex(Ed25519KeyHashHex(stakeKeyHash)),\n      ).toAddress();\n\n      this.addresses.rewardAddressBech32 =\n        this.addresses.rewardAddress.toBech32();\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ],
          "properties": [
            {
              "name": "_keyType",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_accountType",
              "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/embedded/index\").AccountType",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_wallet",
              "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/embedded/index\").EmbeddedWallet | null",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_accountIndex",
              "type": "number",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_keyIndex",
              "type": "number",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_fetcher",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_submitter",
              "type": "any",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_networkId",
              "type": "0 | 1",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "addresses",
              "type": "{ baseAddress?: any; enterpriseAddress?: any; rewardAddress?: any; baseAddressBech32?: string | undefined; enterpriseAddressBech32?: string | undefined; rewardAddressBech32?: string | undefined; pubDRepKey?: string | undefined; dRepIDBech32?: any; dRepIDHash?: any; dRepIDCip105?: string | undefined; }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-wallet.src.types.index",
      "name": "index",
      "source": "mesh-wallet",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Cardano",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/types/index\").Cardano",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/types/index.ts",
          "documentation": ""
        },
        {
          "name": "WalletInstance",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/types/index\").WalletInstance",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/types/index.ts",
          "documentation": ""
        },
        {
          "name": "GetAddressType",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/types/index\").GetAddressType",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/types/index.ts",
          "documentation": ""
        },
        {
          "name": "Cip30WalletApi",
          "definition": "export interface Cip30WalletApi {\n  experimental: ExperimentalFeatures;\n  getBalance(): Promise<string>;\n  getChangeAddress(): Promise<string>;\n  getExtensions(): Promise<{ cip: number }[]>;\n  getCollateral(): Promise<string[] | undefined>;\n  getNetworkId(): Promise<number>;\n  getRewardAddresses(): Promise<string[]>;\n  getUnusedAddresses(): Promise<string[]>;\n  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/types/index.ts",
          "documentation": ""
        },
        {
          "name": "Cip95WalletApi",
          "definition": "export interface Cip95WalletApi {\n  getRegisteredPubStakeKeys: () => Promise<Ed25519PublicKeyHex[]>;\n  getUnregisteredPubStakeKeys: () => Promise<Ed25519PublicKeyHex[]>;\n  getPubDRepKey: () => Promise<Ed25519PublicKeyHex>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/types/index.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:bitcoin.src.wallets.browser.index",
      "name": "index",
      "source": "bitcoin",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "BrowserWallet",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/bitcoin/src/wallets/browser/index.ts",
          "extends": null,
          "implements": [
            "IBitcoinWallet"
          ],
          "methods": [
            {
              "name": "enable",
              "signature": "static async enable(\n    message: string,\n    purposes = [\"payment\"]\n  ): Promise<BrowserWallet> {\n    const response = await WalletStaticMethods.request(\"getAccounts\", {\n      purposes: purposes,\n      message: message,\n    });\n    if (response.status === \"success\") {\n      return new BrowserWallet(purposes);\n    }\n    throw new Error(\"Failed to enable wallet\");\n  }",
              "documentation": "This is the entrypoint to start communication with the user's wallet. The wallet should request the user's permission to connect the web page to the user's wallet, and if permission has been granted, the wallet will be returned and exposing the full API for the dApp to use.",
              "static": true,
              "visibility": "public"
            },
            {
              "name": "getAddresses",
              "signature": "async getAddresses(): Promise<Address[] | undefined> {\n    try {\n      const response = await this.request(\"getAddresses\", {\n        purposes: this._purposes,\n      });\n      if (response.status === \"success\") {\n        return response.result.addresses as Address[];\n      }\n    } catch (err) {\n      console.error(\"getAccounts ~ error:\", err);\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getChangeAddress",
              "signature": "async getChangeAddress() {\n    const addresses = await this.getAddresses();\n    const address = addresses?.find((address) => address.purpose === \"payment\");\n    if (address) return address.address;\n    throw new Error(\"No change address found\");\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getCollateral",
              "signature": "async getCollateral() {\n    console.log(\"Method getCollateral not implemented.\");\n    return [];\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getNetworkId",
              "signature": "async getNetworkId(): Promise<0 | 1> {\n    return 1;\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "request",
              "signature": "async request(method: string, params?: any) {\n    return WalletStaticMethods.request(method, params);\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "signData",
              "signature": "async signData(\n    payload: string,\n    address?: string,\n    addressType: \"p2wpkh\" | \"p2tr\" | \"stacks\" = \"p2wpkh\"\n  ): Promise<\n    | {\n        address: string;\n        signature: string;\n        messageHash: string;\n      }\n    | undefined\n  > {\n    try {\n      let _address = address;\n      if (!_address) {\n        _address = await this.getAddresses().then((addresses) => {\n          const address = addresses?.find(\n            (address) => address.addressType === addressType\n          );\n          return address?.address;\n        });\n      }\n\n      if (_address) {\n        const response = await this.request(\"signMessage\", {\n          message: payload,\n          address: _address,\n        });\n        if (response.status === \"success\") {\n          return response.result;\n        }\n      }\n    } catch (err) {\n      console.error(\"signMessage ~ error:\", err);\n    }\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "signTx",
              "signature": "async signTx(signedTx: string): Promise<string> {\n    console.log(\"Method signTx not implemented.\");\n    return \"\";\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "submitTx",
              "signature": "async submitTx(signedTx: string): Promise<string> {\n    console.log(\"Method submitTx not implemented.\");\n    return \"\";\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "_purposes",
              "type": "string[]",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:bitcoin.src.wallets.embedded.index",
      "name": "index",
      "source": "bitcoin",
      "description": "",
      "functions": [
        {
          "name": "verifySignature",
          "signature": "export function verifySignature(\n  message: string,\n  signatureBase64: string,\n  publicKeyHex: string\n): boolean {\n  try {\n    const messageBuffer = Buffer.from(message, \"utf8\");\n    const bufferToHash = Buffer.concat([\n      varIntBuffer(messageBuffer.length),\n      messageBuffer,\n    ]);\n    const hash = bitcoin.crypto.hash256(bufferToHash);\n    const signature = Buffer.from(signatureBase64, \"base64\");\n    const publicKey = Buffer.from(publicKeyHex, \"hex\");\n\n    return ECPair.fromPublicKey(publicKey).verify(hash, signature);\n  } catch (e) {\n    return false;\n  }\n}",
          "documentation": "Verifies if a signature is valid for a given message and public key.",
          "parameters": [
            {
              "name": "message",
              "type": "string",
              "optional": false
            },
            {
              "name": "signatureBase64",
              "type": "string",
              "optional": false
            },
            {
              "name": "publicKeyHex",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "boolean",
          "isExported": true,
          "importPath": "offchain/bitcoin/src/wallets/embedded/index.ts"
        }
      ],
      "types": [
        {
          "name": "CreateWalletOptions",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/wallets/embedded/index\").CreateWalletOptions",
          "isExported": true,
          "importPath": "offchain/bitcoin/src/wallets/embedded/index.ts",
          "documentation": ""
        },
        {
          "name": "TransactionPayload",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/wallets/embedded/index\").TransactionPayload",
          "isExported": true,
          "importPath": "offchain/bitcoin/src/wallets/embedded/index.ts",
          "documentation": ""
        }
      ],
      "classes": [
        {
          "name": "EmbeddedWallet",
          "documentation": "EmbeddedWallet is a class that provides a simple interface to interact with Bitcoin wallets.",
          "isExported": true,
          "importPath": "offchain/bitcoin/src/wallets/embedded/index.ts",
          "extends": null,
          "implements": [],
          "methods": [
            {
              "name": "getAddress",
              "signature": "getAddress(): Address {\n    return resolveAddress(\n      this._wallet.publicKey,\n      this._network\n    );\n\n    // const p2wpkh = bitcoin.payments.p2wpkh({\n    //   pubkey: this._wallet.publicKey,\n    //   network: this._network,\n    // });\n\n    // if (!p2wpkh?.address) {\n    //   throw new Error(\"Address is not initialized.\");\n    // }\n\n    // return {\n    //   address: p2wpkh.address,\n    //   publicKey: this._wallet.publicKey.toString(\"hex\"),\n    //   purpose: \"payment\",\n    //   addressType: \"p2wpkh\",\n    // };\n  }",
              "documentation": "Returns the wallet's SegWit (P2WPKH) address and associated public key.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getPublicKey",
              "signature": "getPublicKey(): string {\n    return this._wallet.publicKey.toString(\"hex\");\n  }",
              "documentation": "Returns the hex-encoded public key of the wallet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getNetworkId",
              "signature": "getNetworkId(): 0 | 1 {\n    return this._network === bitcoin.networks.testnet ? 1 : 0;\n  }",
              "documentation": "Returns the network identifier of the wallet.\n0': Indicates the Bitcoin mainnet.\n1': Indicates the Bitcoin testnet.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getUTxOs",
              "signature": "async getUTxOs(): Promise<UTxO[]> {\n    const address = this.getAddress();\n    if (this._provider === undefined) {\n      throw new Error(\"`provider` is not defined. Provide a BitcoinProvider.\");\n    }\n\n    return await this._provider.fetchAddressUTxOs(address.address);\n  }",
              "documentation": "Get UTXOs for the wallet address.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "signData",
              "signature": "signData(message: string): string {\n    if (!this._wallet.privateKey) {\n      throw new Error(\"Private key is not available for signing.\");\n    }\n\n    // Create ECPair from private key\n    const keyPair = ECPair.fromPrivateKey(this._wallet.privateKey, {\n      compressed: true,\n    });\n    // Prepare message buffer\n    const messageBuffer = Buffer.from(message, \"utf8\");\n    // Prepare the buffer to sign (see bitcoinjs-message implementation)\n\n    const bufferToHash = Buffer.concat([\n      varIntBuffer(messageBuffer.length),\n      messageBuffer,\n    ]);\n    const hash = bitcoin.crypto.hash256(bufferToHash);\n    // Sign the hash\n    const signature = keyPair.sign(hash);\n    // DER encode and return as base64\n    return signature.toString(\"base64\");\n  }",
              "documentation": "Signs a given message using the wallet's private key.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "signTx",
              "signature": "signTx(payload: TransactionPayload): string {\n    if (!this._wallet.privateKey) {\n      throw new Error(\"Private key is not available for signing.\");\n    }\n\n    const psbt = new bitcoin.Psbt({ network: this._network });\n    const p2wpkh = bitcoin.payments.p2wpkh({\n      pubkey: this._wallet.publicKey,\n      network: this._network,\n    });\n    const ecPair = ECPair.fromPrivateKey(this._wallet.privateKey, {\n      network: this._network,\n    });\n\n    for (const input of payload.inputs) {\n      psbt.addInput({\n        hash: input.txid,\n        index: input.vout,\n        witnessUtxo: {\n          script: p2wpkh.output!,\n          value: input.value,\n        },\n      });\n    }\n\n    for (const output of payload.outputs) {\n      psbt.addOutput({\n        address: output.address,\n        value: output.value,\n      });\n    }\n\n    for (let i = 0; i < payload.inputs.length; i++) {\n      psbt.signInput(i, this._wallet);\n      psbt.validateSignaturesOfInput(i, (pubkey, hash, signature) => {\n        return (\n          ecPair.publicKey.equals(pubkey) && ecPair.verify(hash, signature)\n        );\n      });\n    }\n\n    psbt.finalizeAllInputs();\n    return psbt.extractTransaction().toHex();\n  }",
              "documentation": "Sign a transaction payload.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "brew",
              "signature": "static brew(strength: number = 128): string[] {\n    if (![128, 160, 192, 224, 256].includes(strength)) {\n      throw new Error(\n        \"Invalid strength. Must be one of: 128, 160, 192, 224, 256.\"\n      );\n    }\n\n    const mnemonic = bip39.generateMnemonic(strength);\n    return mnemonic.split(\" \");\n  }",
              "documentation": "Generates a mnemonic phrase and returns it as an array of words.",
              "static": true,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "_network",
              "type": "Network",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_wallet",
              "type": "BIP32Interface",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "_provider",
              "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/interfaces/provider\").IBitcoinProvider | undefined",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-common.src.data.json.aliases",
      "name": "aliases",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "ScriptHash",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").ByteString",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
          "documentation": "The Plutus Data script hash in JSON"
        },
        {
          "name": "PubKeyHash",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").ByteString",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
          "documentation": "The Plutus Data public key hash in JSON"
        },
        {
          "name": "PolicyId",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").ByteString",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
          "documentation": "Aiken alias\nThe Plutus Data policy id in JSON"
        },
        {
          "name": "CurrencySymbol",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").ByteString",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
          "documentation": "PlutusTx alias\nThe Plutus Data currency symbol in JSON"
        },
        {
          "name": "AssetName",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").ByteString",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
          "documentation": "Aiken alias\nThe Plutus Data asset name in JSON"
        },
        {
          "name": "TokenName",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").ByteString",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
          "documentation": "PlutusTx alias\nThe Plutus Data token name in JSON"
        },
        {
          "name": "AssetClass",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/aliases\").AssetClass",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
          "documentation": "PlutusTx alias\nThe Plutus Data asset class in JSON"
        },
        {
          "name": "OutputReference",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/aliases\").OutputReference",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
          "documentation": "Aiken alias\nThe Plutus Data output reference in JSON"
        },
        {
          "name": "TxOutRef",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/aliases\").TxOutRef",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
          "documentation": "PlutusTx alias\nThe Plutus Data TxOutRef in JSON"
        },
        {
          "name": "POSIXTime",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").Integer",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
          "documentation": "PlutusTx alias\nThe Plutus Data POSIX time in JSON"
        },
        {
          "name": "DictItem",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/aliases\").DictItem<V>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
          "documentation": "Aiken alias\nThe Plutus Data dictionary item in JSON"
        },
        {
          "name": "Dict",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/aliases\").Dict<V>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
          "documentation": "Aiken alias\nThe Plutus Data dictionary in JSON"
        },
        {
          "name": "Tuple",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/aliases\").Tuple<T>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
          "documentation": "Aiken alias\nThe Plutus Data tuple in JSON"
        },
        {
          "name": "Option",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/aliases\").Option<T>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
          "documentation": "Aiken alias\nThe Plutus Data Option in JSON"
        },
        {
          "name": "Some",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/aliases\").Some<T>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
          "documentation": "Aiken alias\nThe Plutus Data Option - Some in JSON"
        },
        {
          "name": "None",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/aliases\").None",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
          "documentation": "Aiken alias\nThe Plutus Data Option - None in JSON"
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.data.json.constructors",
      "name": "constructors",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "ConStr",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/constructors\").ConStr<N, T>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/constructors.ts",
          "documentation": "The Plutus Data constructor object, representing custom data type in JSON"
        },
        {
          "name": "ConStr0",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/constructors\").ConStr0<T>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/constructors.ts",
          "documentation": "The Plutus Data index 0 constructor object, representing custom data type in JSON"
        },
        {
          "name": "ConStr1",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/constructors\").ConStr1<T>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/constructors.ts",
          "documentation": "The Plutus Data index 1 constructor object, representing custom data type in JSON"
        },
        {
          "name": "ConStr2",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/constructors\").ConStr2<T>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/constructors.ts",
          "documentation": "The Plutus Data index 2 constructor object, representing custom data type in JSON"
        },
        {
          "name": "ConStr3",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/constructors\").ConStr3<T>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/constructors.ts",
          "documentation": "The Plutus Data index 3 constructor object, representing custom data type in JSON"
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.data.json.credentials",
      "name": "credentials",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "VerificationKey",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/credentials\").VerificationKey",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/credentials.ts",
          "documentation": "The Plutus Data verification key in JSON"
        },
        {
          "name": "Script",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/credentials\").Script",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/credentials.ts",
          "documentation": "The Plutus Data Script key in JSON"
        },
        {
          "name": "MaybeStakingHash",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/credentials\").MaybeStakingHash",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/credentials.ts",
          "documentation": "The Plutus Data staking credential in JSON"
        },
        {
          "name": "PubKeyAddress",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/credentials\").PubKeyAddress",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/credentials.ts",
          "documentation": "The Plutus Data public key address in JSON"
        },
        {
          "name": "ScriptAddress",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/credentials\").ScriptAddress",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/credentials.ts",
          "documentation": "The Plutus Data script address in JSON"
        },
        {
          "name": "Credential",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/credentials\").Credential",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/credentials.ts",
          "documentation": "The Plutus Data credential in JSON"
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.data.json.index",
      "name": "index",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "PlutusData",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/index\").PlutusData",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/index.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.data.json.mpf",
      "name": "mpf",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "ProofStep",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/mpf\").ProofStep",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/mpf.ts",
          "documentation": ""
        },
        {
          "name": "ProofStepBranch",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/mpf\").ProofStepBranch",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/mpf.ts",
          "documentation": ""
        },
        {
          "name": "ProofStepFork",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/mpf\").ProofStepFork",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/mpf.ts",
          "documentation": ""
        },
        {
          "name": "ProofStepLeaf",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/mpf\").ProofStepLeaf",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/mpf.ts",
          "documentation": ""
        },
        {
          "name": "ForkNeighbor",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/mpf\").ForkNeighbor",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/mpf.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.data.json.primitives",
      "name": "primitives",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Bool",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").Bool",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/primitives.ts",
          "documentation": "The Plutus Data boolean in JSON"
        },
        {
          "name": "BuiltinByteString",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").BuiltinByteString",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/primitives.ts",
          "documentation": "The Plutus Data byte string, representing in hex, in JSON"
        },
        {
          "name": "ByteString",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").ByteString",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/primitives.ts",
          "documentation": "The Plutus Data byte string, representing in hex, in JSON"
        },
        {
          "name": "Integer",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").Integer",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/primitives.ts",
          "documentation": "The Plutus Data integer in JSON"
        },
        {
          "name": "List",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").List<T>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/primitives.ts",
          "documentation": "The Plutus Data list in JSON"
        },
        {
          "name": "AssocMapItem",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").AssocMapItem<K, V>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/primitives.ts",
          "documentation": "PlutusTx alias\nThe Plutus Data association map item in JSON"
        },
        {
          "name": "AssocMap",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").AssocMap<K, V>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/primitives.ts",
          "documentation": "PlutusTx alias\nThe Plutus Data association map in JSON"
        },
        {
          "name": "Pair",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").Pair<K, V>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/primitives.ts",
          "documentation": "Aiken alias\nThe Plutus Data association map item in JSON"
        },
        {
          "name": "Pairs",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").Pairs<K, V>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/json/primitives.ts",
          "documentation": "Aiken alias\nThe Plutus Data association map in JSON"
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.data.mesh.aliases",
      "name": "aliases",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "MAssetClass",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/aliases\").MAssetClass",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/mesh/aliases.ts",
          "documentation": "PlutusTx alias\nThe Mesh Data asset class"
        },
        {
          "name": "MOutputReference",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/aliases\").MOutputReference",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/mesh/aliases.ts",
          "documentation": "Aiken alias\nThe Mesh Data output reference"
        },
        {
          "name": "MTxOutRef",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/aliases\").MTxOutRef",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/mesh/aliases.ts",
          "documentation": "PlutusTx alias\nThe Mesh Data TxOutRef"
        },
        {
          "name": "MTuple",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/aliases\").MTuple<T>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/mesh/aliases.ts",
          "documentation": "Aiken alias\nThe Mesh Data tuple"
        },
        {
          "name": "MOption",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/aliases\").MOption<T>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/mesh/aliases.ts",
          "documentation": "Aiken alias\nThe Mesh Data Option type"
        },
        {
          "name": "MSome",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/aliases\").MSome<T>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/mesh/aliases.ts",
          "documentation": "Aiken alias\nThe Mesh Data Option - Some type"
        },
        {
          "name": "MNone",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/aliases\").MNone",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/mesh/aliases.ts",
          "documentation": "Aiken alias\nThe Mesh Data Option - None type"
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.data.mesh.constructors",
      "name": "constructors",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "MConStr",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/constructors\").MConStr<N, T>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/mesh/constructors.ts",
          "documentation": "The Mesh Data constructor object, representing custom data type"
        },
        {
          "name": "MConStr0",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/constructors\").MConStr0<T>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/mesh/constructors.ts",
          "documentation": "The Mesh Data index 0 constructor object, representing custom data type"
        },
        {
          "name": "MConStr1",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/constructors\").MConStr1<T>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/mesh/constructors.ts",
          "documentation": "The Mesh Data index 1 constructor object, representing custom data type"
        },
        {
          "name": "MConStr2",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/constructors\").MConStr2<T>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/mesh/constructors.ts",
          "documentation": "The Mesh Data index 2 constructor object, representing custom data type"
        },
        {
          "name": "MConStr3",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/constructors\").MConStr3<T>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/mesh/constructors.ts",
          "documentation": "The Mesh Data index 3 constructor object, representing custom data type"
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.data.mesh.credentials",
      "name": "credentials",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "MVerificationKey",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/credentials\").MVerificationKey",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/mesh/credentials.ts",
          "documentation": "The Mesh Data verification key"
        },
        {
          "name": "MScript",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/credentials\").MScript",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/mesh/credentials.ts",
          "documentation": "The Mesh Data script key"
        },
        {
          "name": "MMaybeStakingHash",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/credentials\").MMaybeStakingHash",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/mesh/credentials.ts",
          "documentation": "The Mesh Data staking credential"
        },
        {
          "name": "MPubKeyAddress",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/credentials\").MPubKeyAddress",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/mesh/credentials.ts",
          "documentation": "The Mesh Data public key address"
        },
        {
          "name": "MScriptAddress",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/credentials\").MScriptAddress",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/mesh/credentials.ts",
          "documentation": "The Mesh Data script address"
        },
        {
          "name": "MCredential",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/credentials\").MCredential",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/mesh/credentials.ts",
          "documentation": "The Mesh Data credential"
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.data.mesh.index",
      "name": "index",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.data.mesh.primitives",
      "name": "primitives",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "MBool",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/primitives\").MBool",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/data/mesh/primitives.ts",
          "documentation": "The Mesh Data boolean"
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.blueprint.index",
      "name": "index",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.blueprint.minting",
      "name": "minting",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "IMintingBlueprint",
          "definition": "export interface IMintingBlueprint {\n  version: LanguageVersion;\n  cbor: string;\n  hash: string;\n  paramScript(\n    compiledCode: string,\n    params: string[],\n    paramsType: PlutusDataType,\n  ): this;\n  noParamScript(compiledCode: string): this;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/blueprint/minting.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.blueprint.spending",
      "name": "spending",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "ISpendingBlueprint",
          "definition": "export interface ISpendingBlueprint {\n  version: LanguageVersion;\n  networkId: number;\n  cbor: string;\n  hash: string;\n  address: string;\n  stakeHash?: string;\n  isStakeScriptCredential: boolean;\n  paramScript(\n    compiledCode: string,\n    params: string[],\n    paramsType: PlutusDataType,\n  ): this;\n  noParamScript(compiledCode: string): this;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/blueprint/spending.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.blueprint.withdrawal",
      "name": "withdrawal",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "IWithdrawalBlueprint",
          "definition": "export interface IWithdrawalBlueprint {\n  version: LanguageVersion;\n  networkId: number;\n  cbor: string;\n  hash: string;\n  address: string;\n  paramScript(\n    compiledCode: string,\n    params: string[],\n    paramsType: PlutusDataType,\n  ): this;\n  noParamScript(compiledCode: string): this;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/blueprint/withdrawal.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.deserialized.deserialized-address",
      "name": "deserialized-address",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "DeserializedAddress",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/deserialized/deserialized-address\").DeserializedAddress",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/deserialized/deserialized-address.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.deserialized.deserialized-script",
      "name": "deserialized-script",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "DeserializedScript",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/deserialized/deserialized-script\").DeserializedScript",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/deserialized/deserialized-script.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.deserialized.index",
      "name": "index",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.transaction-builder.certificate",
      "name": "certificate",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Certificate",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/certificate\").Certificate",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/certificate.ts",
          "documentation": ""
        },
        {
          "name": "CertificateType",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/certificate\").CertificateType",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/certificate.ts",
          "documentation": ""
        },
        {
          "name": "DRep",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/certificate\").DRep",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/certificate.ts",
          "documentation": ""
        },
        {
          "name": "Anchor",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/certificate\").Anchor",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/certificate.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.transaction-builder.credential",
      "name": "credential",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Credential",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/credential\").Credential",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/credential.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.transaction-builder.data",
      "name": "data",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "BuilderData",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/data\").BuilderData",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/data.ts",
          "documentation": ""
        },
        {
          "name": "Redeemer",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/data\").Redeemer",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/data.ts",
          "documentation": ""
        },
        {
          "name": "DatumSource",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/data\").DatumSource",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/data.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.transaction-builder.index",
      "name": "index",
      "source": "mesh-common",
      "description": "",
      "functions": [
        {
          "name": "cloneTxBuilderBody",
          "signature": "export function cloneTxBuilderBody(body: MeshTxBuilderBody): MeshTxBuilderBody {\n  const { extraInputs, ...otherProps } = body;\n  const cloned = structuredClone(otherProps) as MeshTxBuilderBody;\n  cloned.extraInputs = extraInputs;\n  return cloned;\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "body",
              "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/index\").MeshTxBuilderBody",
              "optional": false
            }
          ],
          "returnType": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/index\").MeshTxBuilderBody",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/index.ts"
        }
      ],
      "types": [
        {
          "name": "MeshTxBuilderBody",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/index\").MeshTxBuilderBody",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/index.ts",
          "documentation": ""
        },
        {
          "name": "ValidityRange",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/index\").ValidityRange",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/index.ts",
          "documentation": ""
        },
        {
          "name": "MetadatumMap",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/index\").MetadatumMap",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/index.ts",
          "documentation": ""
        },
        {
          "name": "Metadatum",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/index\").Metadatum",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/index.ts",
          "documentation": ""
        },
        {
          "name": "TxMetadata",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/index\").TxMetadata",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/index.ts",
          "documentation": ""
        },
        {
          "name": "Metadata",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/index\").Metadata",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/index.ts",
          "documentation": ""
        },
        {
          "name": "RequiredWith",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/index\").RequiredWith<T, K>",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/index.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.transaction-builder.mint",
      "name": "mint",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "MintParam",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/mint\").MintParam",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/mint.ts",
          "documentation": ""
        },
        {
          "name": "MintItem",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/mint\").MintItem",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/mint.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.transaction-builder.output",
      "name": "output",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Output",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/output\").Output",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/output.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.transaction-builder.script",
      "name": "script",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "ScriptSource",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/script\").ScriptSource",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/script.ts",
          "documentation": ""
        },
        {
          "name": "SimpleScriptSourceInfo",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/script\").SimpleScriptSourceInfo",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/script.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.transaction-builder.txin",
      "name": "txin",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "RefTxIn",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/txin\").RefTxIn",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/txin.ts",
          "documentation": ""
        },
        {
          "name": "TxInParameter",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/txin\").TxInParameter",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/txin.ts",
          "documentation": ""
        },
        {
          "name": "TxIn",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/txin\").TxIn",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/txin.ts",
          "documentation": ""
        },
        {
          "name": "PubKeyTxIn",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/txin\").PubKeyTxIn",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/txin.ts",
          "documentation": ""
        },
        {
          "name": "SimpleScriptTxIn",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/txin\").SimpleScriptTxIn",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/txin.ts",
          "documentation": ""
        },
        {
          "name": "SimpleScriptTxInParameter",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/txin\").SimpleScriptTxInParameter",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/txin.ts",
          "documentation": ""
        },
        {
          "name": "ScriptTxInParameter",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/txin\").ScriptTxInParameter",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/txin.ts",
          "documentation": ""
        },
        {
          "name": "ScriptTxIn",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/txin\").ScriptTxIn",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/txin.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.transaction-builder.vote",
      "name": "vote",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Vote",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/vote\").Vote",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/vote.ts",
          "documentation": ""
        },
        {
          "name": "BasicVote",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/vote\").BasicVote",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/vote.ts",
          "documentation": ""
        },
        {
          "name": "SimpleScriptVote",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/vote\").SimpleScriptVote",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/vote.ts",
          "documentation": ""
        },
        {
          "name": "ScriptVote",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/vote\").ScriptVote",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/vote.ts",
          "documentation": ""
        },
        {
          "name": "VoteType",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/vote\").VoteType",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/vote.ts",
          "documentation": ""
        },
        {
          "name": "Voter",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/vote\").Voter",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/vote.ts",
          "documentation": ""
        },
        {
          "name": "VotingProcedure",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/vote\").VotingProcedure",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/vote.ts",
          "documentation": ""
        },
        {
          "name": "VoteKind",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/vote\").VoteKind",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/vote.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-common.src.types.transaction-builder.withdrawal",
      "name": "withdrawal",
      "source": "mesh-common",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "Withdrawal",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/withdrawal\").Withdrawal",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/withdrawal.ts",
          "documentation": ""
        },
        {
          "name": "PubKeyWithdrawal",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/withdrawal\").PubKeyWithdrawal",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/withdrawal.ts",
          "documentation": ""
        },
        {
          "name": "ScriptWithdrawal",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/withdrawal\").ScriptWithdrawal",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/withdrawal.ts",
          "documentation": ""
        },
        {
          "name": "SimpleScriptWithdrawal",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/withdrawal\").SimpleScriptWithdrawal",
          "isExported": true,
          "importPath": "offchain/mesh-common/src/types/transaction-builder/withdrawal.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-contract.src.content-ownership.offchain.common",
      "name": "common",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "InputUTxO",
          "definition": "UTxO",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/content-ownership/offchain/common.ts",
          "documentation": ""
        },
        {
          "name": "ScriptIndex",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/content-ownership/offchain/common\").ScriptIndex",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/content-ownership/offchain/common.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-contract.src.content-ownership.offchain.index",
      "name": "index",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-contract.src.content-ownership.offchain.offchain",
      "name": "offchain",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "MeshContentOwnershipContract",
          "documentation": "Mesh Content Ownership Contract\n\nThis contract is used to manage the ownership of content.\nIt facilitates on-chain record of content (i.e. file on IPFS) ownership and transfer.\nWhile one cannot prefer others from obtaining a copy of the content, the app owner of the\ncontract can serve the single source of truth of who owns the content. With the blockchain\ntrace and record in place, it provides a trustless way to verify the ownership of the content\nand facilitates further application logics such as royalties, licensing, etc.",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/content-ownership/offchain/offchain.ts",
          "extends": "MeshTxInitiator",
          "implements": [],
          "methods": [],
          "properties": [
            {
              "name": "paramUtxo",
              "type": "{ txHash: string; outputIndex: number; }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "scriptInfo",
              "type": "{ oracleNFT: { hash: any; cbor: any; }; oracleValidator: { hash: any; cbor: any; address: string; }; contentRegistry: { hash: any; cbor: any; address: string; }; contentRefToken: { hash: any; cbor: any; }; ownershipRegistry: { hash: any; cbor: any; address: string; }; ownershipRefToken: { hash: any; cbor: any; }; }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "refScriptUtxos",
              "type": "{ contentRefToken: { txHash: string; outputIndex: number; }; ownershipRefToken: { txHash: string; outputIndex: number; }; contentRegistry: { txHash: string; outputIndex: number; }; ownershipRegistry: { txHash: string; outputIndex: number; }; }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "operationAddress",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "opsKey",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getOwnerNativeScript",
              "type": "() => { nativeScript: NativeScript; scriptAddress: any; }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "mintOneTimeMintingPolicy",
              "type": "() => Promise<{ tx: any; paramUtxo: any; }>",
              "documentation": "[Setup phase]\nThis is the first transaction you need to setup the contract.\n\nThis transaction mints the one-time minting policy (a NFT) for the contract.\nIt will be attached with the datum which serves as the single source of truth for the contract oracle.\n\nNote: You must save the `paramUtxo` for future transactions.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "setupOracleUtxo",
              "type": "() => Promise<any>",
              "documentation": "[Setup phase]\nThis is the second transaction you need to setup the contract.\n\nThis transaction send the NFT to a oracle contract locking the datum,\nwhich serves as the single source of truth for the contract oracle with data integrity.\n\nNote: You must provide the `paramUtxo` from the `mintOneTimeMintingPolicy` transaction.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "sendRefScriptOnchain",
              "type": "(scriptIndex: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/content-ownership/offchain/common\").ScriptIndex) => Promise<any>",
              "documentation": "[Setup phase]\nThis are the next transactions you need to setup the contract.\nYou need to run once for each script, and you would likely have to run one after the previous one is confirmed.\n\nThis transaction sends the reference scripts to the blockchain for later transactions,\nboosting efficiency and avoid exceeding 16kb of transaction size limits enforced by protocol parameter.\n\nNote: You must provide the `paramUtxo` from the `mintOneTimeMintingPolicy` transaction.\nNote: You must save txHash (after signed and submitted) for `ContentRegistry`, `ContentRefToken`, `OwnershipRegistry`, `OwnershipRefToken` transactions for future transactions.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "createContentRegistry",
              "type": "() => Promise<any>",
              "documentation": "[Setup phase]\nThis is the next transaction you need to setup the contract after completing all the `sendRefScriptOnchain` transactions.\n\nThis transaction creates one content registry. Each registry should comes in pair with one ownership registry and\neach pair of registry serves around 50 records of content ownership. The application can be scaled indefinitely\naccording to the number of parallelization needed and volumes of content expected to be managed.\n\nNote: You must provide the `paramUtxo` from the `mintOneTimeMintingPolicy` transaction.\nNote: You must provide the txHash for `ContentRegistry`, `ContentRefToken`, `OwnershipRegistry`, `OwnershipRefToken`",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "createOwnershipRegistry",
              "type": "() => Promise<any>",
              "documentation": "[Setup phase]\nThis is the last transaction you need to setup the contract after completing all the `sendRefScriptOnchain` transactions.\n\nThis transaction creates one content registry. Each registry should comes in pair with one content registry and\neach pair of registry serves around 50 records of content ownership. The application can be scaled indefinitely\naccording to the number of parallelization needed and volumes of content expected to be managed.\n\nNote: You must provide the `paramUtxo` from the `mintOneTimeMintingPolicy` transaction.\nNote: You must provide the txHash for `ContentRegistry`, `ContentRefToken`, `OwnershipRegistry`, `OwnershipRefToken`",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getOracleData",
              "type": "() => Promise<{ contentNumber: number; ownershipNumber: number; }>",
              "documentation": "Get the current oracle data.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "mintUserToken",
              "type": "(tokenName: string, tokenMetadata?: {}) => Promise<any>",
              "documentation": "[User]\n\nThis transaction mints a user token which can be used to represent the ownership of the content. This token is used in `createContent()` transaction.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "createContent",
              "type": "(ownerAssetHex: string, contentHashHex: string, registryNumber?: number) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getContent",
              "type": "(registryNumber: number, contentNumber: number) => Promise<any>",
              "documentation": "Get the content at the registry given the registry number and content number.",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "updateContent",
              "type": "({ ownerTokenUtxo, registryNumber, newContentHashHex, contentNumber, }: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/content-ownership/offchain/type\").UpdateContent) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "transferContent",
              "type": "({ ownerTokenUtxo, registryNumber, newOwnerAssetHex, contentNumber, }: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/content-ownership/offchain/type\").TransferContent) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "stopContentRegistry",
              "type": "(registryNumber: number) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "stopOwnershipRegistry",
              "type": "(registryNumber: number) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "stopOracle",
              "type": "(txInHash: string, txInId: number) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getCurrentOracleDatum",
              "type": "(utxos?: UTxO[] | undefined) => Promise<any>",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getOracleDatum",
              "type": "(contentRegistryCount: number, ownershipRegistryCount: number) => any",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getContentDatum",
              "type": "(contentArray: string[]) => any",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getOwnershipDatum",
              "type": "(ownershipArray: [string, string][]) => any",
              "documentation": "",
              "static": false,
              "visibility": "protected"
            },
            {
              "name": "getScriptUtxos",
              "type": "(registryNumber: number, toFetch?: (\"content\" | \"oracle\" | \"ownership\")[]) => Promise<UTxO[]>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "insertContentRegistry",
              "type": "(plutusData: string, newContentHash: string) => Data",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "insertOwnershipRegistry",
              "type": "(plutusData: string, ownerAssetClass: [string, string]) => Data",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "updateContentRegistry",
              "type": "(plutusData: string, contentNumber: number, newContentHash: string) => Data",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "updateOwnershipRegistry",
              "type": "(plutusData: string, contentNumber: number, ownerAssetClass: [string, string]) => Data",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-contract.src.content-ownership.offchain.type",
      "name": "type",
      "source": "mesh-contract",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "OracleDatum",
          "definition": "ConStr0<[BuiltinByteString, ScriptAddress, BuiltinByteString, ScriptAddress, Integer, BuiltinByteString, ScriptAddress, Integer, BuiltinByteString, BuiltinByteString]>",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/content-ownership/offchain/type.ts",
          "documentation": ""
        },
        {
          "name": "ContentRegistryDatum",
          "definition": "ConStr0<[Integer, List<BuiltinByteString>]>",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/content-ownership/offchain/type.ts",
          "documentation": ""
        },
        {
          "name": "OwnershipRegistryDatum",
          "definition": "ConStr0<[Integer, List<{ list: [BuiltinByteString, BuiltinByteString]; }>]>",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/content-ownership/offchain/type.ts",
          "documentation": ""
        },
        {
          "name": "UpdateContent",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/content-ownership/offchain/type\").UpdateContent",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/content-ownership/offchain/type.ts",
          "documentation": ""
        },
        {
          "name": "TransferContent",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/content-ownership/offchain/type\").TransferContent",
          "isExported": true,
          "importPath": "offchain/mesh-contract/src/content-ownership/offchain/type.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-core.src.utils.blueprint.index",
      "name": "index",
      "source": "mesh-core",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core.src.utils.blueprint.minting",
      "name": "minting",
      "source": "mesh-core",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "MintingBlueprint",
          "documentation": "Minting blueprint",
          "isExported": true,
          "importPath": "offchain/mesh-core/src/utils/blueprint/minting.ts",
          "extends": null,
          "implements": [
            "IMintingBlueprint"
          ],
          "methods": [
            {
              "name": "paramScript",
              "signature": "paramScript(\n    compiledCode: string,\n    params: object[] | Data[],\n    paramsType: PlutusDataType = \"Mesh\",\n  ): this {\n    const cbor = applyParamsToScript(compiledCode, params, paramsType);\n    const hash = resolveScriptHash(cbor, this.version);\n    this.hash = hash;\n    this.cbor = cbor;\n    return this;\n  }",
              "documentation": "Initialize the minting blueprint, with the same parameters to `applyParamsToScript`",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "noParamScript",
              "signature": "noParamScript(compiledCode: string): this {\n    return this.paramScript(compiledCode, []);\n  }",
              "documentation": "Initialize the minting blueprint, with no parameters",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "version",
              "type": "LanguageVersion",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "cbor",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "hash",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-core.src.utils.blueprint.spending",
      "name": "spending",
      "source": "mesh-core",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "SpendingBlueprint",
          "documentation": "Spending blueprint",
          "isExported": true,
          "importPath": "offchain/mesh-core/src/utils/blueprint/spending.ts",
          "extends": null,
          "implements": [
            "ISpendingBlueprint"
          ],
          "methods": [
            {
              "name": "paramScript",
              "signature": "paramScript(\n    compiledCode: string,\n    params: object[] | Data[],\n    paramsType: PlutusDataType = \"Mesh\",\n  ): this {\n    const cbor = applyParamsToScript(compiledCode, params, paramsType);\n    const hash = resolveScriptHash(cbor, this.version);\n    const plutusScript = {\n      code: cbor,\n      version: this.version,\n    };\n    const address = serializePlutusScript(\n      plutusScript,\n      this.stakeHash,\n      this.networkId,\n      this.isStakeScriptCredential,\n    ).address;\n    this.hash = hash;\n    this.cbor = cbor;\n    this.address = address;\n    return this;\n  }",
              "documentation": "Initialize the minting blueprint, with the same parameters to `applyParamsToScript`",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "noParamScript",
              "signature": "noParamScript(compiledCode: string): this {\n    return this.paramScript(compiledCode, []);\n  }",
              "documentation": "Initialize the minting blueprint, with no parameters",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "version",
              "type": "LanguageVersion",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "networkId",
              "type": "number",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "cbor",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "hash",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "address",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "stakeHash",
              "type": "string | undefined",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "isStakeScriptCredential",
              "type": "boolean",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-core.src.utils.blueprint.withdrawal",
      "name": "withdrawal",
      "source": "mesh-core",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "WithdrawalBlueprint",
          "documentation": "Withdrawal blueprint",
          "isExported": true,
          "importPath": "offchain/mesh-core/src/utils/blueprint/withdrawal.ts",
          "extends": null,
          "implements": [
            "IWithdrawalBlueprint"
          ],
          "methods": [
            {
              "name": "paramScript",
              "signature": "paramScript(\n    compiledCode: string,\n    params: object[] | Data[],\n    paramsType: PlutusDataType = \"Mesh\",\n  ): this {\n    const cbor = applyParamsToScript(compiledCode, params, paramsType);\n    const hash = resolveScriptHash(cbor, this.version);\n    this.address = serializeRewardAddress(hash, true, this.networkId as 0 | 1);\n    this.hash = hash;\n    this.cbor = cbor;\n    return this;\n  }",
              "documentation": "Initialize the withdrawal blueprint, with the same parameters to `applyParamsToScript`",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "noParamScript",
              "signature": "noParamScript(compiledCode: string): this {\n    return this.paramScript(compiledCode, []);\n  }",
              "documentation": "Initialize the withdrawal blueprint, with no parameters",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "version",
              "type": "LanguageVersion",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "networkId",
              "type": "number",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "cbor",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "hash",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "address",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.index",
      "name": "index",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.common.icons.icon-bitcoin",
      "name": "icon-bitcoin",
      "source": "mesh-react",
      "description": "",
      "functions": [
        {
          "name": "IconBitcoin",
          "signature": "export default function IconBitcoin() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      stroke-width=\"2\"\n      stroke-linecap=\"round\"\n      stroke-linejoin=\"round\"\n      style={{\n        color: \"#CC9900\",\n        width: \"24px\",\n        height: \"24px\",\n        strokeWidth: \"1px\",\n      }}\n      className=\"hover:mesh-fill-white\"\n    >\n      <path d=\"M11.767 19.089c4.924.868 6.14-6.025 1.216-6.894m-1.216 6.894L5.86 18.047m5.908 1.042-.347 1.97m1.563-8.864c4.924.869 6.14-6.025 1.215-6.893m-1.215 6.893-3.94-.694m5.155-6.2L8.29 4.26m5.908 1.042.348-1.97M7.48 20.364l3.126-17.727\" />\n    </svg>\n  );\n}",
          "documentation": "",
          "parameters": [],
          "returnType": "React.JSX.Element",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/common/icons/icon-bitcoin.tsx"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.common.icons.icon-book-dashed",
      "name": "icon-book-dashed",
      "source": "mesh-react",
      "description": "",
      "functions": [
        {
          "name": "IconBookDashed",
          "signature": "export default function IconBookDashed() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"gray\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      style={{\n        color: \"#ffadff\",\n        width: \"24px\",\n        height: \"24px\",\n        strokeWidth: \"1px\",\n      }}\n      className=\"hover:mesh-fill-white\"\n    >\n      <path d=\"M12 17h2\" />\n      <path d=\"M12 22h2\" />\n      <path d=\"M12 2h2\" />\n      <path d=\"M18 22h1a1 1 0 0 0 1-1\" />\n      <path d=\"M18 2h1a1 1 0 0 1 1 1v1\" />\n      <path d=\"M20 15v2h-2\" />\n      <path d=\"M20 8v3\" />\n      <path d=\"M4 11V9\" />\n      <path d=\"M4 19.5V15\" />\n      <path d=\"M4 5v-.5A2.5 2.5 0 0 1 6.5 2H8\" />\n      <path d=\"M8 22H6.5a1 1 0 0 1 0-5H8\" />\n    </svg>\n  );\n}",
          "documentation": "",
          "parameters": [],
          "returnType": "React.JSX.Element",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/common/icons/icon-book-dashed.tsx"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.common.icons.icon-chevron-right",
      "name": "icon-chevron-right",
      "source": "mesh-react",
      "description": "",
      "functions": [
        {
          "name": "IconChevronRight",
          "signature": "export default function IconChevronRight() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"gray\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      style={{\n        color: \"#ffadff\",\n        width: \"24px\",\n        height: \"24px\",\n        strokeWidth: \"1px\",\n      }}\n      className=\"hover:mesh-fill-white\"\n    >\n      <path d=\"m15 18-6-6 6-6\" />\n    </svg>\n  );\n}",
          "documentation": "",
          "parameters": [],
          "returnType": "React.JSX.Element",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/common/icons/icon-chevron-right.tsx"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.common.icons.icon-discord",
      "name": "icon-discord",
      "source": "mesh-react",
      "description": "",
      "functions": [
        {
          "name": "IconDiscord",
          "signature": "export default function IconDiscord() {\n  return (\n    <svg\n      viewBox=\"0 0 20 20\"\n      aria-hidden=\"true\"\n      style={{\n        width: \"24px\",\n        height: \"24px\",\n      }}\n    >\n      <path\n        d=\"M16.238 4.515a14.842 14.842 0 0 0-3.664-1.136.055.055 0 0 0-.059.027 10.35 10.35 0 0 0-.456.938 13.702 13.702 0 0 0-4.115 0 9.479 9.479 0 0 0-.464-.938.058.058 0 0 0-.058-.027c-1.266.218-2.497.6-3.664 1.136a.052.052 0 0 0-.024.02C1.4 8.023.76 11.424 1.074 14.782a.062.062 0 0 0 .024.042 14.923 14.923 0 0 0 4.494 2.272.058.058 0 0 0 .064-.02c.346-.473.654-.972.92-1.496a.057.057 0 0 0-.032-.08 9.83 9.83 0 0 1-1.404-.669.058.058 0 0 1-.029-.046.058.058 0 0 1 .023-.05c.094-.07.189-.144.279-.218a.056.056 0 0 1 .058-.008c2.946 1.345 6.135 1.345 9.046 0a.056.056 0 0 1 .059.007c.09.074.184.149.28.22a.058.058 0 0 1 .023.049.059.059 0 0 1-.028.046 9.224 9.224 0 0 1-1.405.669.058.058 0 0 0-.033.033.056.056 0 0 0 .002.047c.27.523.58 1.022.92 1.495a.056.056 0 0 0 .062.021 14.878 14.878 0 0 0 4.502-2.272.055.055 0 0 0 .016-.018.056.056 0 0 0 .008-.023c.375-3.883-.63-7.256-2.662-10.246a.046.046 0 0 0-.023-.021Zm-9.223 8.221c-.887 0-1.618-.814-1.618-1.814s.717-1.814 1.618-1.814c.908 0 1.632.821 1.618 1.814 0 1-.717 1.814-1.618 1.814Zm5.981 0c-.887 0-1.618-.814-1.618-1.814s.717-1.814 1.618-1.814c.908 0 1.632.821 1.618 1.814 0 1-.71 1.814-1.618 1.814Z\"\n        fill=\"#5865F2\"\n      />\n    </svg>\n  );\n}",
          "documentation": "",
          "parameters": [],
          "returnType": "React.JSX.Element",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/common/icons/icon-discord.tsx"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.common.icons.icon-download",
      "name": "icon-download",
      "source": "mesh-react",
      "description": "",
      "functions": [
        {
          "name": "IconDownload",
          "signature": "export default function IconDownload() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"gray\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      style={{\n        color: \"#ffadff\",\n        width: \"24px\",\n        height: \"24px\",\n        strokeWidth: \"1px\",\n      }}\n    >\n      <path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\" />\n      <polyline points=\"7 10 12 15 17 10\" />\n      <line x1=\"12\" x2=\"12\" y1=\"15\" y2=\"3\" />\n    </svg>\n  );\n}",
          "documentation": "",
          "parameters": [],
          "returnType": "React.JSX.Element",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/common/icons/icon-download.tsx"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.common.icons.icon-fingerprint",
      "name": "icon-fingerprint",
      "source": "mesh-react",
      "description": "",
      "functions": [
        {
          "name": "IconFingerprint",
          "signature": "export default function IconFingerprint() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      style={{\n        color: \"#ffadff\",\n        width: \"24px\",\n        height: \"24px\",\n        strokeWidth: \"1px\",\n      }}\n      className=\"hover:mesh-fill-white\"\n    >\n      <path d=\"M12 10a2 2 0 0 0-2 2c0 1.02-.1 2.51-.26 4\" />\n      <path d=\"M14 13.12c0 2.38 0 6.38-1 8.88\" />\n      <path d=\"M17.29 21.02c.12-.6.43-2.3.5-3.02\" />\n      <path d=\"M2 12a10 10 0 0 1 18-6\" />\n      <path d=\"M2 16h.01\" />\n      <path d=\"M21.8 16c.2-2 .131-5.354 0-6\" />\n      <path d=\"M5 19.5C5.5 18 6 15 6 12a6 6 0 0 1 .34-2\" />\n      <path d=\"M8.65 22c.21-.66.45-1.32.57-2\" />\n      <path d=\"M9 6.8a6 6 0 0 1 9 5.2v2\" />\n    </svg>\n  );\n}",
          "documentation": "",
          "parameters": [],
          "returnType": "React.JSX.Element",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/common/icons/icon-fingerprint.tsx"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.common.icons.icon-google",
      "name": "icon-google",
      "source": "mesh-react",
      "description": "",
      "functions": [
        {
          "name": "IconGoogle",
          "signature": "export default function IconGoogle() {\n  return (\n    <svg\n      viewBox=\"0 0 262 262\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      preserveAspectRatio=\"xMidYMid\"\n      style={{\n        width: \"24px\",\n        height: \"24px\",\n      }}\n    >\n      <path\n        d=\"M255.878 133.451c0-10.734-.871-18.567-2.756-26.69H130.55v48.448h71.947c-1.45 12.04-9.283 30.172-26.69 42.356l-.244 1.622 38.755 30.023 2.685.268c24.659-22.774 38.875-56.282 38.875-96.027\"\n        fill=\"#4285F4\"\n      />\n      <path\n        d=\"M130.55 261.1c35.248 0 64.839-11.605 86.453-31.622l-41.196-31.913c-11.024 7.688-25.82 13.055-45.257 13.055-34.523 0-63.824-22.773-74.269-54.25l-1.531.13-40.298 31.187-.527 1.465C35.393 231.798 79.49 261.1 130.55 261.1\"\n        fill=\"#34A853\"\n      />\n      <path\n        d=\"M56.281 156.37c-2.756-8.123-4.351-16.827-4.351-25.82 0-8.994 1.595-17.697 4.206-25.82l-.073-1.73L15.26 71.312l-1.335.635C5.077 89.644 0 109.517 0 130.55s5.077 40.905 13.925 58.602l42.356-32.782\"\n        fill=\"#FBBC05\"\n      />\n      <path\n        d=\"M130.55 50.479c24.514 0 41.05 10.589 50.479 19.438l36.844-35.974C195.245 12.91 165.798 0 130.55 0 79.49 0 35.393 29.301 13.925 71.947l42.211 32.783c10.59-31.477 39.891-54.251 74.414-54.251\"\n        fill=\"#EB4335\"\n      />\n    </svg>\n  );\n}",
          "documentation": "",
          "parameters": [],
          "returnType": "React.JSX.Element",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/common/icons/icon-google.tsx"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.common.icons.icon-monitor-smartphone",
      "name": "icon-monitor-smartphone",
      "source": "mesh-react",
      "description": "",
      "functions": [
        {
          "name": "IconMonitorSmartphone",
          "signature": "export default function IconMonitorSmartphone() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"black\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      style={{\n        color: \"#ffadff\",\n        width: \"56px\",\n        height: \"56px\",\n        strokeWidth: \"1px\",\n      }}\n    >\n      <path d=\"M18 8V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h8\" />\n      <path d=\"M10 19v-3.96 3.15\" />\n      <path d=\"M7 19h5\" />\n      <rect width=\"6\" height=\"10\" x=\"16\" y=\"12\" rx=\"2\" />\n    </svg>\n  );\n}",
          "documentation": "",
          "parameters": [],
          "returnType": "React.JSX.Element",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/common/icons/icon-monitor-smartphone.tsx"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.common.icons.icon-plus",
      "name": "icon-plus",
      "source": "mesh-react",
      "description": "",
      "functions": [
        {
          "name": "IconPlus",
          "signature": "export default function IconPlus() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"black\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      style={{\n        color: \"#ffadff\",\n        width: \"56px\",\n        height: \"56px\",\n        strokeWidth: \"1px\",\n      }}\n    >\n      <path d=\"M5 12h14\" />\n      <path d=\"M12 5v14\" />\n    </svg>\n  );\n}",
          "documentation": "",
          "parameters": [],
          "returnType": "React.JSX.Element",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/common/icons/icon-plus.tsx"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-react.src.common.icons.icon-twitter",
      "name": "icon-twitter",
      "source": "mesh-react",
      "description": "",
      "functions": [
        {
          "name": "IconTwitter",
          "signature": "export default function IconTwitter() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      version=\"1.1\"\n      viewBox=\"0 0 24 24\"\n      style={{\n        width: \"24px\",\n        height: \"24px\",\n      }}\n    >\n      <path d=\"M14.095479,10.316482L22.286354,1h-1.940718l-7.115352,8.087682L7.551414,1H1l8.589488,12.231093L1,23h1.940717  l7.509372-8.542861L16.448587,23H23L14.095479,10.316482z M11.436522,13.338465l-0.871624-1.218704l-6.924311-9.68815h2.981339  l5.58978,7.82155l0.867949,1.218704l7.26506,10.166271h-2.981339L11.436522,13.338465z\" />\n    </svg>\n  );\n}",
          "documentation": "",
          "parameters": [],
          "returnType": "React.JSX.Element",
          "isExported": true,
          "importPath": "offchain/mesh-react/src/common/icons/icon-twitter.tsx"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-svelte.src.lib.cardano-wallet.index",
      "name": "index",
      "source": "mesh-svelte",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-svelte.src.lib.cardano-wallet-dropdown.index",
      "name": "index",
      "source": "mesh-svelte",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-svelte.src.lib.common.index",
      "name": "index",
      "source": "mesh-svelte",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-svelte.src.lib.common.types",
      "name": "types",
      "source": "mesh-svelte",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "CardanoWalletButtonProps",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-svelte/src/lib/common/types\").CardanoWalletButtonProps",
          "isExported": true,
          "importPath": "offchain/mesh-svelte/src/lib/common/types.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-svelte.src.lib.state.browser-wallet-state.svelte",
      "name": "browser-wallet-state.svelte",
      "source": "mesh-svelte",
      "description": "",
      "functions": [
        {
          "name": "connect",
          "signature": "export async function connect(w: Wallet) {\n  connecting = true;\n  try {\n    wallet = await BrowserWallet.enable(w.id);\n    name = w.name\n      .split(\" \")\n      .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n      .join(\" \");\n    icon = w.icon;\n  } catch (e) {\n    console.error(`error while connecting wallet ${w.name}: ${e}`);\n  }\n  connecting = false;\n  connected = true;\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "w",
              "type": "Wallet",
              "optional": false
            }
          ],
          "returnType": "Promise<void>",
          "isExported": true,
          "importPath": "offchain/mesh-svelte/src/lib/state/browser-wallet-state.svelte.ts"
        },
        {
          "name": "disconnect",
          "signature": "export function disconnect() {\n  wallet = undefined;\n  name = undefined;\n  icon = undefined;\n  connected = false;\n}",
          "documentation": "",
          "parameters": [],
          "returnType": "void",
          "isExported": true,
          "importPath": "offchain/mesh-svelte/src/lib/state/browser-wallet-state.svelte.ts"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-svelte.src.lib.state.index",
      "name": "index",
      "source": "mesh-svelte",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-transaction.src.mesh-tx-builder.coin-selection.cardano-sdk-adapter",
      "name": "cardano-sdk-adapter",
      "source": "mesh-transaction",
      "description": "",
      "functions": [],
      "types": [],
      "classes": [
        {
          "name": "BuilderCallbacksSdkBridge",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/cardano-sdk-adapter.ts",
          "extends": null,
          "implements": [
            "CardanoSelection.SelectionConstraints"
          ],
          "methods": [],
          "properties": [
            {
              "name": "builderCallback",
              "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface\").BuilderCallbacks",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "utxoMap",
              "type": "Map<string, UTxO>",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "usedUtxos",
              "type": "Set<string>",
              "documentation": "",
              "static": false,
              "visibility": "private"
            },
            {
              "name": "computeMinimumCoinQuantity",
              "type": "(output: CSDK.TxOut) => CSDK.Lovelace",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "computeMinimumCost",
              "type": "(selectionSkeleton: CardanoSelection.SelectionSkeleton) => Promise<CardanoSelection.TxCosts>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "computeSelectionLimit",
              "type": "(selectionSkeleton: CardanoSelection.SelectionSkeleton) => Promise<number>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "tokenBundleSizeExceedsLimit",
              "type": "(tokenBundle: any) => boolean",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "getNewInputs",
              "type": "(selectionSkeleton: CardanoSelection.SelectionSkeleton) => Set<UTxO>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        },
        {
          "name": "CardanoSdkInputSelector",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/cardano-sdk-adapter.ts",
          "extends": null,
          "implements": [
            "IInputSelector"
          ],
          "methods": [
            {
              "name": "select",
              "signature": "async select(\n    preselectedUtxos: TxIn[],\n    outputs: Output[],\n    implicitValue: ImplicitValue,\n    utxos: UTxO[],\n    changeAddress: string,\n  ): Promise<TransactionPrototype> {\n    // Create a map of UTxOs for quick lookup\n    const utxoMap = new Map<string, UTxO>();\n    for (const utxo of utxos) {\n      utxoMap.set(`${utxo.input.txHash}#${utxo.input.outputIndex}`, utxo);\n    }\n\n    // Aggregate outputs into a single output for selection\n    const aggregatedTxOut = makeAggregatedCSDKOOutput(outputs);\n    const aggregatedOuts = new Set<CSDK.TxOut>();\n    if (aggregatedTxOut) {\n      aggregatedOuts.add(aggregatedTxOut);\n    }\n    // Convert Mesh types to CSDK types\n    const preselectedUtoxsCSDK = new Set(\n      preselectedUtxos.map(meshTxInToCSDKUtxo),\n    );\n    const utxoxCSDK = utxos.map(meshUtxoToCSDKUtxo);\n\n    // Create selector with change address resolver\n    const selector = CardanoSelection.roundRobinRandomImprove({\n      changeAddressResolver: new StaticChangeAddressResolver(changeAddress),\n    });\n\n    // Track used UTxOs\n    const usedUtxos = new Set<string>();\n    for (const utxo of preselectedUtxos) {\n      usedUtxos.add(`${utxo.txIn.txHash}#${utxo.txIn.txIndex}`);\n    }\n    // Create bridge for callbacks\n    const builderCallbacksBridge = new BuilderCallbacksSdkBridge(\n      this.constraints,\n      utxoMap,\n      usedUtxos,\n    );\n\n    // Perform selection\n    const selectResult = await selector.select({\n      preSelectedUtxo: preselectedUtoxsCSDK,\n      utxo: new Set(utxoxCSDK),\n      outputs: aggregatedOuts,\n      constraints: builderCallbacksBridge,\n      implicitValue: meshImplicitCoinToCSDKImplicitCoins(implicitValue),\n    });\n    // Extract newly selected inputs\n    const newInputs = new Set<UTxO>();\n    for (const input of selectResult.selection.inputs) {\n      const utxoId = `${input[0].txId}#${input[0].index}`;\n      if (!usedUtxos.has(utxoId)) {\n        const originalUtxo = utxoMap.get(utxoId);\n        if (!originalUtxo) {\n          throw new Error(`Missing required UTxO: ${utxoId}`);\n        }\n        newInputs.add(originalUtxo);\n      }\n    }\n\n    // Return transaction prototype\n    return {\n      newInputs,\n      newOutputs: new Set(),\n      change: selectResult.selection.change.map(CSDKOutputToMeshOutput),\n      fee: selectResult.selection.fee,\n      redeemers: selectResult.redeemers?.map(CSDKRedeemerToMeshAction),\n    };\n  }",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ],
          "properties": [
            {
              "name": "constraints",
              "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface\").BuilderCallbacks",
              "documentation": "",
              "static": false,
              "visibility": "private"
            }
          ]
        },
        {
          "name": "StaticChangeAddressResolver",
          "documentation": "",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/cardano-sdk-adapter.ts",
          "extends": null,
          "implements": [
            "CardanoSelection.ChangeAddressResolver"
          ],
          "methods": [],
          "properties": [
            {
              "name": "changeAddress",
              "type": "string",
              "documentation": "",
              "static": false,
              "visibility": "public"
            },
            {
              "name": "resolve",
              "type": "(selection: CardanoSelection.Selection) => Promise<CSDK.TxOut[]>",
              "documentation": "",
              "static": false,
              "visibility": "public"
            }
          ]
        }
      ]
    },
    {
      "key": "offchain:mesh-transaction.src.mesh-tx-builder.coin-selection.coin-selection-interface",
      "name": "coin-selection-interface",
      "source": "mesh-transaction",
      "description": "",
      "functions": [],
      "types": [
        {
          "name": "EstimateTxCosts",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface\").EstimateTxCosts",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface.ts",
          "documentation": ""
        },
        {
          "name": "TokenBundleSizeExceedsLimit",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface\").TokenBundleSizeExceedsLimit",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface.ts",
          "documentation": ""
        },
        {
          "name": "ComputeMinimumCoinQuantity",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface\").ComputeMinimumCoinQuantity",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface.ts",
          "documentation": ""
        },
        {
          "name": "MaxSizeExceed",
          "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface\").MaxSizeExceed",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface.ts",
          "documentation": ""
        },
        {
          "name": "TransactionPrototype",
          "definition": "export interface TransactionPrototype {\n  newInputs: Set<UTxO>;\n  newOutputs: Set<TxOutput>;\n  change: Array<TxOutput>;\n  fee: bigint;\n  redeemers?: Array<Omit<Action, 'data'>>;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface.ts",
          "documentation": ""
        },
        {
          "name": "ImplicitValue",
          "definition": "export interface ImplicitValue {\n  withdrawals: bigint;\n  deposit: bigint;\n  reclaimDeposit: bigint;\n  mint: Asset[];\n}",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface.ts",
          "documentation": ""
        },
        {
          "name": "TransactionCost",
          "definition": "export interface TransactionCost {\n  fee: bigint;\n  redeemers?: Array<Omit<Action, 'data'>>;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface.ts",
          "documentation": ""
        },
        {
          "name": "BuilderCallbacks",
          "definition": "export interface BuilderCallbacks {\n  computeMinimumCost: EstimateTxCosts;\n  tokenBundleSizeExceedsLimit: TokenBundleSizeExceedsLimit;\n  computeMinimumCoinQuantity: ComputeMinimumCoinQuantity;\n  maxSizeExceed: MaxSizeExceed;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface.ts",
          "documentation": ""
        },
        {
          "name": "IInputSelector",
          "definition": "export interface IInputSelector {\n  select: (\n    preselectedUtoxs: TxIn[],\n    outputs: Output[],\n    implicitValue: ImplicitValue,\n    utxos: UTxO[],\n    changeAddress: string,\n  ) => Promise<TransactionPrototype>;\n}",
          "isExported": true,
          "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface.ts",
          "documentation": ""
        }
      ],
      "classes": []
    },
    {
      "key": "offchain:mesh-transaction.src.mesh-tx-builder.coin-selection.index",
      "name": "index",
      "source": "mesh-transaction",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-wallet.src.browser.webauthn.index",
      "name": "index",
      "source": "mesh-wallet",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.fromObj.certificate",
      "name": "certificate",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.fromObj.data",
      "name": "data",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.fromObj.index",
      "name": "index",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.fromObj.metadata",
      "name": "metadata",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.fromObj.mint",
      "name": "mint",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.fromObj.network",
      "name": "network",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.fromObj.output",
      "name": "output",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.fromObj.script",
      "name": "script",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.fromObj.txIn",
      "name": "txIn",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.fromObj.utxo",
      "name": "utxo",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.fromObj.vote",
      "name": "vote",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.fromObj.withdrawal",
      "name": "withdrawal",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.toObj.certificate",
      "name": "certificate",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.toObj.data",
      "name": "data",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.toObj.index",
      "name": "index",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.toObj.metadata",
      "name": "metadata",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.toObj.mint",
      "name": "mint",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.toObj.network",
      "name": "network",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.toObj.output",
      "name": "output",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.toObj.script",
      "name": "script",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.toObj.txIn",
      "name": "txIn",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.toObj.utxo",
      "name": "utxo",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.toObj.vote",
      "name": "vote",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-core-csl.src.core.adaptor.toObj.withdrawal",
      "name": "withdrawal",
      "source": "mesh-core-csl",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-svelte.src.lib.cardano-wallet.component.index",
      "name": "index",
      "source": "mesh-svelte",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-svelte.src.lib.cardano-wallet-dropdown.component.index",
      "name": "index",
      "source": "mesh-svelte",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-wallet.src.browser.webauthn.auth.connect",
      "name": "connect",
      "source": "mesh-wallet",
      "description": "",
      "functions": [
        {
          "name": "connect",
          "signature": "export async function connect({\n  username,\n  password,\n  serverUrl,\n}: {\n  username: string;\n  password: string;\n  serverUrl: string;\n}) {\n  const responseRegister = await register({ serverUrl, username });\n  if (\n    responseRegister.success ||\n    responseRegister.error.errorCode == ERRORCODES.USEREXISTS\n  ) {\n    const loginRes = await handleLogin({ serverUrl, username });\n    if (loginRes.success && loginRes.authJSON) {\n      const wallet = await buildWalletFromPasskey(\n        loginRes.authJSON.rawId,\n        password,\n      );\n      return { success: true, wallet: wallet };\n    }\n  } else {\n    return { success: false, error: responseRegister.error };\n  }\n  return { success: false, error: \"Fail to connect\" };\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "__0",
              "type": "{ username: string; password: string; serverUrl: string; }",
              "optional": false
            }
          ],
          "returnType": "Promise<{ success: boolean; wallet: { bech32PrivateKey: any; }; error?: undefined; } | { success: boolean; error: any; wallet?: undefined; }>",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/browser/webauthn/auth/connect.ts"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-wallet.src.browser.webauthn.auth.index",
      "name": "index",
      "source": "mesh-wallet",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-wallet.src.browser.webauthn.auth.login",
      "name": "login",
      "source": "mesh-wallet",
      "description": "",
      "functions": [
        {
          "name": "login",
          "signature": "export async function login({\n  serverUrl,\n  username,\n}: {\n  serverUrl: string;\n  username: string;\n}) {\n  // 1. Get challenge from server\n  const initAuthRes = await fetch(`${serverUrl}/auth-init`, {\n    credentials: \"include\",\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      username,\n    }),\n  });\n\n  const initAuth = await initAuthRes.json();\n  if (!initAuth.success) {\n    return {\n      success: false,\n      error: initAuth.error,\n      errorCode: initAuth.errorCode,\n    };\n  }\n\n  const optionsJSON = initAuth.data.optionsJSON;\n\n  // 2. Get passkey\n  const authJSON = await startAuthentication({ optionsJSON });\n\n  // 3. Verify passkey with DB\n  const verifyAuthRes = await fetch(`${serverUrl}/auth-verify`, {\n    credentials: \"include\",\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(authJSON),\n  });\n\n  const verifyAuth = await verifyAuthRes.json();\n\n  if (!verifyAuthRes.ok) {\n    return { success: false, error: verifyAuth.error };\n  }\n  if (verifyAuth.data.verified) {\n    return { success: true, authJSON: authJSON };\n  } else {\n    return { success: false, error: \"Failed to log in\" };\n  }\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "__0",
              "type": "{ serverUrl: string; username: string; }",
              "optional": false
            }
          ],
          "returnType": "Promise<{ success: boolean; error: any; errorCode: any; authJSON?: undefined; } | { success: boolean; error: any; errorCode?: undefined; authJSON?: undefined; } | { success: boolean; authJSON: any; error?: undefined; errorCode?: undefined; }>",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/browser/webauthn/auth/login.ts"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-wallet.src.browser.webauthn.auth.register",
      "name": "register",
      "source": "mesh-wallet",
      "description": "",
      "functions": [
        {
          "name": "register",
          "signature": "export async function register({\n  serverUrl,\n  username,\n}: {\n  serverUrl: string;\n  username: string;\n}) {\n  // 1. Get challenge from server\n  const initRegisterRes = await fetch(`${serverUrl}/register-init`, {\n    credentials: \"include\",\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      username,\n    }),\n  });\n  const initRegister = await initRegisterRes.json();\n  if (!initRegister.success) {\n    return {\n      success: false,\n      error: initRegister.error,\n      errorCode: initRegister.errorCode,\n    };\n  }\n\n  // 2. Create passkey\n  const optionsJSON = initRegister.data.optionsJSON;\n  const registrationJSON = await startRegistration({ optionsJSON });\n\n  // 3. Save passkey in DB\n  const verifyResponse = await fetch(`${serverUrl}/register-verify`, {\n    credentials: \"include\",\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(registrationJSON),\n  });\n\n  const verifyData = await verifyResponse.json();\n  if (!verifyResponse.ok) {\n    console.error(verifyData.error);\n    return {\n      success: false,\n      error: verifyData.error,\n      errorCode: verifyData.errorCode,\n    };\n  }\n  if (verifyData.data.verified) {\n    console.log(`Successfully registered ${username}`);\n    return { success: true };\n  } else {\n    console.error(`Failed to register`);\n    return { success: false, error: \"Failed to register\", errorCode: 1 };\n  }\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "__0",
              "type": "{ serverUrl: string; username: string; }",
              "optional": false
            }
          ],
          "returnType": "Promise<{ success: boolean; error: any; errorCode: any; } | { success: boolean; error?: undefined; errorCode?: undefined; }>",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/browser/webauthn/auth/register.ts"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-wallet.src.browser.webauthn.cardano.build-wallet-from-passkey",
      "name": "build-wallet-from-passkey",
      "source": "mesh-wallet",
      "description": "",
      "functions": [
        {
          "name": "buildWalletFromPasskey",
          "signature": "export async function buildWalletFromPasskey(\n  rawId: string,\n  password: string,\n  appSalt = \"appSalt\",\n) {\n  const entropy = await createEntropy(rawId, appSalt);\n  return buildKey(Buffer.from(entropy), password);\n}",
          "documentation": "",
          "parameters": [
            {
              "name": "rawId",
              "type": "string",
              "optional": false
            },
            {
              "name": "password",
              "type": "string",
              "optional": false
            },
            {
              "name": "appSalt",
              "type": "string",
              "optional": false
            }
          ],
          "returnType": "Promise<{ bech32PrivateKey: any; }>",
          "isExported": true,
          "importPath": "offchain/mesh-wallet/src/browser/webauthn/cardano/build-wallet-from-passkey.ts"
        }
      ],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-wallet.src.browser.webauthn.common.index",
      "name": "index",
      "source": "mesh-wallet",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    },
    {
      "key": "offchain:mesh-wallet.src.browser.webauthn.common.error-codes.index",
      "name": "index",
      "source": "mesh-wallet",
      "description": "",
      "functions": [],
      "types": [],
      "classes": []
    }
  ],
  "functions": [
    {
      "name": "resolveAddress",
      "signature": "export function resolveAddress(\n  publicKey: string | Buffer,\n  network: \"mainnet\" | \"testnet\" | bitcoin.networks.Network\n): Address {\n  const p2wpkh = bitcoin.payments.p2wpkh({\n    pubkey:\n      typeof publicKey === \"string\" ? Buffer.from(publicKey, \"hex\") : publicKey,\n    network:\n      network === \"mainnet\"\n        ? bitcoin.networks.bitcoin\n        : network === \"testnet\"\n          ? bitcoin.networks.testnet\n          : network,\n  });\n\n  if (!p2wpkh?.address) {\n    throw new Error(\"Address is not initialized.\");\n  }\n\n  const pubKeyHex = Buffer.isBuffer(publicKey)\n    ? publicKey.toString(\"hex\")\n    : publicKey;\n\n  return {\n    address: p2wpkh.address,\n    publicKey: pubKeyHex,\n    purpose: \"payment\",\n    addressType: \"p2wpkh\",\n  };\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "publicKey",
          "type": "string | Buffer<ArrayBufferLike>",
          "optional": false
        },
        {
          "name": "network",
          "type": "any",
          "optional": false
        }
      ],
      "returnType": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/address\").Address",
      "isExported": true,
      "importPath": "offchain/bitcoin/src/utils/address.ts",
      "module": "address",
      "source": "bitcoin"
    },
    {
      "name": "keySignedLogic",
      "signature": "export function keySignedLogic(\n  requiredSignatures: string[],\n  keyHash: string,\n): boolean {\n  return (\n    requiredSignatures?.some((signatory: string) => signatory === keyHash) ||\n    false\n  );\n}",
      "documentation": "Internal logic to check if a key is signed",
      "parameters": [
        {
          "name": "requiredSignatures",
          "type": "string[]",
          "optional": false
        },
        {
          "name": "keyHash",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/tx-tester/index.ts",
      "module": "index",
      "source": "mesh-common"
    },
    {
      "name": "tokenMintedLogic",
      "signature": "export function tokenMintedLogic(\n  mints: MintParam[],\n  policyId: string,\n  assetName: string,\n  quantity: number,\n): boolean {\n  return (\n    mints?.some((token) => {\n      return (\n        token.policyId === policyId &&\n        token.mintValue.findIndex(\n          (m) =>\n            m.assetName === assetName && BigInt(m.amount) === BigInt(quantity),\n        ) >= 0\n      );\n    }) || false\n  );\n}",
      "documentation": "Internal logic to check if a token is minted",
      "parameters": [
        {
          "name": "mints",
          "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/mint\").MintParam[]",
          "optional": false
        },
        {
          "name": "policyId",
          "type": "string",
          "optional": false
        },
        {
          "name": "assetName",
          "type": "string",
          "optional": false
        },
        {
          "name": "quantity",
          "type": "number",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/tx-tester/index.ts",
      "module": "index",
      "source": "mesh-common"
    },
    {
      "name": "getFile",
      "signature": "export function getFile(url: string) {\n  var Httpreq = new XMLHttpRequest();\n  Httpreq.open(\"GET\", url, false);\n  Httpreq.send(null);\n  return Httpreq.responseText;\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "string",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/utils/file.ts",
      "module": "file",
      "source": "mesh-common"
    },
    {
      "name": "mergeValue",
      "signature": "export function mergeValue(a: Value, b: Value): Value {\n  const ma = a.multiasset() ?? new Map();\n  b.multiasset()?.forEach((v, k) => {\n    const newVal = (ma.get(k) ?? 0n) + v;\n    if (newVal == 0n) {\n      ma.delete(k);\n    } else {\n      ma.set(k, newVal);\n    }\n  });\n  return new Value(\n    BigInt(a.coin()) + BigInt(b.coin()),\n    ma.size > 0 ? ma : undefined,\n  );\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "a",
          "type": "Serialization.Value",
          "optional": false
        },
        {
          "name": "b",
          "type": "Serialization.Value",
          "optional": false
        }
      ],
      "returnType": "Serialization.Value",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/utils/value.ts",
      "module": "value",
      "source": "mesh-core-cst"
    },
    {
      "name": "negateValue",
      "signature": "export function negateValue(v: Value): Value {\n  const entries = v.multiasset()?.entries();\n  const tokenMap: TokenMap = new Map();\n  if (entries) {\n    for (const entry of entries) {\n      tokenMap.set(entry[0], -entry[1]);\n    }\n  }\n  return new Value(-v.coin(), tokenMap);\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "v",
          "type": "Serialization.Value",
          "optional": false
        }
      ],
      "returnType": "Serialization.Value",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/utils/value.ts",
      "module": "value",
      "source": "mesh-core-cst"
    },
    {
      "name": "subValue",
      "signature": "export function subValue(a: Value, b: Value): Value {\n  return mergeValue(a, negateValue(b));\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "a",
          "type": "Serialization.Value",
          "optional": false
        },
        {
          "name": "b",
          "type": "Serialization.Value",
          "optional": false
        }
      ],
      "returnType": "Serialization.Value",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/utils/value.ts",
      "module": "value",
      "source": "mesh-core-cst"
    },
    {
      "name": "negatives",
      "signature": "export function negatives(v: Value): Value {\n  const entries = v.multiasset()?.entries();\n  const coin = v.coin() < 0n ? v.coin() : 0n;\n  const tokenMap: TokenMap = new Map();\n  if (entries) {\n    for (const entry of entries) {\n      if (entry[1] < 0n) {\n        tokenMap.set(entry[0], entry[1]);\n      }\n    }\n  }\n  return new Value(coin, tokenMap);\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "v",
          "type": "Serialization.Value",
          "optional": false
        }
      ],
      "returnType": "Serialization.Value",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/utils/value.ts",
      "module": "value",
      "source": "mesh-core-cst"
    },
    {
      "name": "assetTypes",
      "signature": "export function assetTypes(v: Value): number {\n  let count = v.coin() == 0n ? 0 : 1;\n  const entries = v.multiasset();\n  if (entries) {\n    entries.forEach(() => {\n      count += 1;\n    });\n  }\n  return count;\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "v",
          "type": "Serialization.Value",
          "optional": false
        }
      ],
      "returnType": "number",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/utils/value.ts",
      "module": "value",
      "source": "mesh-core-cst"
    },
    {
      "name": "empty",
      "signature": "export function empty(v: Value): boolean {\n  return assetTypes(v) == 0;\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "v",
          "type": "Serialization.Value",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/utils/value.ts",
      "module": "value",
      "source": "mesh-core-cst"
    },
    {
      "name": "hAssets",
      "signature": "export function hAssets(assets: Asset[]): hAssets {\n  return assets.reduce((p, asset) => {\n      if (asset.unit === \"\" || asset.unit === \"lovelace\") {\n        p[\"lovelace\"] += BigInt(asset.quantity);\n      } else {\n        const policyId = asset.unit.slice(0, 56);\n        const assetName = asset.unit.slice(56);\n        if (!p[policyId]) p[policyId] = {};\n        p[policyId][assetName] = (p[policyId][assetName] ?? BigInt(0)) + BigInt(asset.quantity);\n      }\n      return p;\n    }, { lovelace: BigInt(0) } as hAssets\n  );\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "assets",
          "type": "Asset[]",
          "optional": false
        }
      ],
      "returnType": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hAssets\").hAssets",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hAssets.ts",
      "module": "hAssets",
      "source": "mesh-hydra"
    },
    {
      "name": "hStatus",
      "signature": "export function hStatus(value: { headStatus?: string; tag?: string; }): hStatus | null {\n  if (value.headStatus === \"Open\") return \"OPEN\";\n  \n  switch (value.tag) {\n    case \"HeadIsInitializing\":\n      return \"INITIALIZING\";\n    case \"HeadIsOpen\":\n      return \"OPEN\";\n    case \"HeadIsClosed\":\n      return \"CLOSED\";\n    case \"ReadyToFanout\":\n      return \"FANOUT_POSSIBLE\";\n    case \"HeadIsFinalized\":\n      return \"FINAL\";\n    default:\n      return null;\n  }\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "value",
          "type": "{ headStatus?: string | undefined; tag?: string | undefined; }",
          "optional": false
        }
      ],
      "returnType": "\"IDLE\" | \"DISCONNECTED\" | \"CONNECTING\" | \"CONNECTED\" | \"INITIALIZING\" | \"OPEN\" | \"CLOSED\" | \"FANOUT_POSSIBLE\" | \"FINAL\" | null",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hStatus.ts",
      "module": "hStatus",
      "source": "mesh-hydra"
    },
    {
      "name": "hUTxOs",
      "signature": "export function hUTxOs(utxos: UTxO[]): hUTxOs {\n  return Object.fromEntries(utxos.map(\n    (utxo) => [utxo.input.txHash + \"#\" + utxo.input.outputIndex, hUTxO(utxo)]\n  ));\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "utxos",
          "type": "UTxO[]",
          "optional": false
        }
      ],
      "returnType": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hUTxOs\").hUTxOs",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hUTxOs.ts",
      "module": "hUTxOs",
      "source": "mesh-hydra"
    },
    {
      "name": "hUTxO",
      "signature": "export function hUTxO(utxo: UTxO): hUTxO {\n  return {\n    address: utxo.output.address,\n    value: hAssets(utxo.output.amount),\n    referenceScript: null,\n    inlineDatum: utxo.output.plutusData ? JSON.parse(utxo.output.plutusData) : null,\n    inlineDatumhash: utxo.output.dataHash ?? null,\n    datum: utxo.output.plutusData ?? null,\n    datumhash: utxo.output.dataHash ?? null,\n  };\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "utxo",
          "type": "UTxO",
          "optional": false
        }
      ],
      "returnType": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hUTxOs\").hUTxO",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hUTxOs.ts",
      "module": "hUTxOs",
      "source": "mesh-hydra"
    },
    {
      "name": "utxosToAssets",
      "signature": "export function utxosToAssets(utxos: UTxO[]): { [key: string]: string } {\n  const _balance = utxos\n    .map((utxo) => {\n      return utxo.output.amount;\n    })\n    .reduce(\n      (acc, amount) => {\n        for (const asset of amount) {\n          if (asset) {\n            if (acc[asset.unit] == undefined) {\n              acc[asset.unit] = 0;\n            }\n            if (asset.unit in acc) {\n              acc[asset.unit]! += parseFloat(asset.quantity);\n            }\n          }\n        }\n        return acc;\n      },\n      {} as { [key: string]: number },\n    );\n\n  return Object.fromEntries(\n    Object.entries(_balance).map(([key, value]) => [key, value.toString()]),\n  );\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "utxos",
          "type": "UTxO[]",
          "optional": false
        }
      ],
      "returnType": "{ [key: string]: string; }",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/common/utxos-to-assets.ts",
      "module": "utxos-to-assets",
      "source": "mesh-provider"
    },
    {
      "name": "ConnectedButton",
      "signature": "export default function ConnectedButton() {\n  const { name, disconnect, address } = useWallet();\n\n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger asChild>\n        <Button variant=\"outline\">\n          {address.slice(0, 6)}...{address.slice(-6)}\n        </Button>\n      </DropdownMenuTrigger>\n      <DropdownMenuContent>\n        <DropdownMenuLabel>Wallet</DropdownMenuLabel>\n        <DropdownMenuItem\n          onClick={() => {\n            navigator.clipboard.writeText(address);\n          }}\n        >\n          Copy Address\n        </DropdownMenuItem>\n        {name == \"Mesh Web3 Services\" && (\n          <DropdownMenuItem\n            onClick={() => {\n              window.open(\"https://web3.meshjs.dev/dashboard\", \"_blank\");\n            }}\n          >\n            Open Web3 Wallet\n          </DropdownMenuItem>\n        )}\n        <DropdownMenuSeparator />\n        <DropdownMenuItem\n          onClick={() => {\n            disconnect();\n          }}\n        >\n          Disconnect\n        </DropdownMenuItem>\n      </DropdownMenuContent>\n    </DropdownMenu>\n  );\n}",
      "documentation": "",
      "parameters": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/cardano-wallet/connected-button.tsx",
      "module": "connected-button",
      "source": "mesh-react"
    },
    {
      "name": "ScreenBurner",
      "signature": "export default function ScreenBurner({\n  networkId,\n  provider,\n  setOpen,\n}: {\n  networkId: 0 | 1;\n  provider: IFetcher & ISubmitter;\n  setOpen: Function;\n}) {\n  const [loading, setLoading] = useState(false);\n  const [hasKeyInStorage, setHasKeyInStorage] = useState(false);\n  const { setWallet } = useWallet();\n\n  function getKeyFromStorage() {\n    return localStorage.getItem(localstoragekey);\n  }\n\n  useEffect(() => {\n    const key = getKeyFromStorage();\n    if (key) {\n      setHasKeyInStorage(true);\n    }\n  }, []);\n\n  function createWallet(key: string) {\n    setTimeout(() => {\n      const wallet = new MeshWallet({\n        networkId: networkId,\n        fetcher: provider,\n        submitter: provider,\n        key: {\n          type: \"root\",\n          bech32: key as string,\n        },\n      });\n\n      if (!hasKeyInStorage) {\n        localStorage.setItem(localstoragekey, key);\n      }\n\n      setWallet(wallet, screens.burner.title);\n      setLoading(false);\n      setOpen(false);\n    }, 500);\n  }\n\n  function handleRestoreWallet() {\n    setLoading(true);\n    const key = getKeyFromStorage();\n    createWallet(key as string);\n  }\n\n  function handleCreateWallet() {\n    setLoading(true);\n    const key = MeshWallet.brew(true) as string;\n    createWallet(key as string);\n  }\n\n  return (\n    <div className=\"mesh-flex mesh-flex-row mesh-flex-gap-4 mesh-items-center mesh-justify-center\">\n      {loading ? (\n        <>Setting up wallet...</>\n      ) : (\n        <>\n          {hasKeyInStorage && (\n            <Button\n              variant=\"outline\"\n              onClick={() => {\n                handleRestoreWallet();\n              }}\n              disabled={loading}\n            >\n              Restore wallet\n            </Button>\n          )}\n          <Button\n            variant=\"outline\"\n            onClick={() => {\n              handleCreateWallet();\n            }}\n            disabled={loading}\n          >\n            Create wallet\n          </Button>\n        </>\n      )}\n    </div>\n  );\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "__0",
          "type": "{ networkId: 0 | 1; provider: any; setOpen: Function; }",
          "optional": false
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/cardano-wallet/screen-burner.tsx",
      "module": "screen-burner",
      "source": "mesh-react"
    },
    {
      "name": "ScreenMain",
      "signature": "export default function ScreenMain({\n  injectFn,\n  setOpen,\n  setScreen,\n  persist,\n  cardanoPeerConnect,\n  burnerWallet,\n  webauthn,\n  showDownload,\n  web3Services,\n}: {\n  injectFn?: () => Promise<void>;\n  setOpen: Function;\n  setScreen: Function;\n  persist: boolean;\n  cardanoPeerConnect: boolean;\n  burnerWallet: boolean;\n  webauthn: boolean;\n  showDownload: boolean;\n  web3Services?: EnableWeb3WalletOptions;\n}) {\n  const wallets = useWalletList({ injectFn });\n  const { connect, setBitcoinWallet } = useWallet();\n\n  return (\n    <TooltipProvider>\n      <div className=\"mesh-grid mesh-gap-4 mesh-py-4 mesh-grid-cols-5 mesh-place-items-center mesh-gap-y-8\">\n        {wallets.map((wallet, index) => (\n          <WalletIcon\n            key={index}\n            icon={wallet.icon}\n            name={wallet.name}\n            action={() => {\n              connect(wallet.id, persist);\n              setOpen(false);\n            }}\n          />\n        ))}\n\n        {web3Services && (\n          <Web3Services\n            options={web3Services}\n            setOpen={setOpen}\n            persist={persist}\n          />\n        )}\n\n        {webauthn && (\n          <WalletIcon\n            iconReactNode={IconFingerprint()}\n            name={screens.webauthn.title}\n            action={() => {\n              setScreen(\"webauthn\");\n            }}\n          />\n        )}\n        {cardanoPeerConnect && (\n          <WalletIcon\n            iconReactNode={IconMonitorSmartphone()}\n            name={screens.p2p.title}\n            action={() => {\n              setScreen(\"p2p\");\n            }}\n          />\n        )}\n        {burnerWallet && (\n          <WalletIcon\n            iconReactNode={IconBookDashed()}\n            name={screens.burner.title}\n            action={() => {\n              setScreen(\"burner\");\n            }}\n          />\n        )}\n\n        {showDownload && (\n          <WalletIcon\n            iconReactNode={IconDownload()}\n            name={`Download`}\n            action={() => {\n              window.open(\n                \"https://developers.cardano.org/showcase/?tags=wallet\",\n                \"_blank\",\n              );\n            }}\n          />\n        )}\n\n        <WalletIcon\n          iconReactNode={IconBitcoin()}\n          name={\"Bitcoin\"}\n          action={async () => {\n            const wallet = await BrowserWallet.enable(\n              \"Mesh SDK want to connect\",\n            );\n            setBitcoinWallet(wallet, \"Bitcoin\");\n            setOpen(false);\n          }}\n        />\n      </div>\n    </TooltipProvider>\n  );\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "__0",
          "type": "{ injectFn?: (() => Promise<void>) | undefined; setOpen: Function; setScreen: Function; persist: boolean; cardanoPeerConnect: boolean; burnerWallet: boolean; webauthn: boolean; showDownload: boolean; web3Services?: any; }",
          "optional": false
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/cardano-wallet/screen-main.tsx",
      "module": "screen-main",
      "source": "mesh-react"
    },
    {
      "name": "ScreenP2P",
      "signature": "export default function ScreenP2P({\n  cardanoPeerConnect,\n  setOpen,\n}: {\n  cardanoPeerConnect?: {\n    dAppInfo: {\n      name: string;\n      url: string;\n    };\n    announce: string[];\n  };\n  setOpen: Function;\n}) {\n  const dAppConnect = useRef<DAppPeerConnect | null>(null);\n  const qrCodeField = useRef<HTMLDivElement | null>(null);\n  const [address, setAddress] = useState(\"\");\n  const [copied, setCopied] = useState(false);\n  const { connect } = useWallet();\n\n  useEffect(() => {\n    if (cardanoPeerConnect) {\n      if (dAppConnect.current === null) {\n        dAppConnect.current = new DAppPeerConnect({\n          dAppInfo: {\n            name: cardanoPeerConnect.dAppInfo.name,\n            url: cardanoPeerConnect.dAppInfo.url,\n          },\n          announce: cardanoPeerConnect.announce,\n          onApiInject: async (name: string, address: string) => {\n            // console.log(5, \"onApiInject\", name, address);\n            await connect(name);\n            setOpen(false);\n          },\n          onApiEject: (name: string, address: string) => {\n            // console.log(5, \"onApiEject\", name, address);\n          },\n          onConnect: (address: string, walletInfo?: IWalletInfo) => {\n            // console.log(5, \"Connected to wallet\", address, walletInfo);\n          },\n          onDisconnect: () => {\n            // console.log(5, \"Disconnected from wallet\");\n          },\n          verifyConnection: (\n            walletInfo: IWalletInfo,\n            callback: (granted: boolean, autoconnect: boolean) => void,\n          ) => {\n            // console.log(5, \"verifyConnection\", walletInfo);\n            callback(true, true);\n          },\n          useWalletDiscovery: true,\n        });\n\n        if (dAppConnect.current) {\n          const address = dAppConnect.current.getAddress();\n          setAddress(address);\n          if (qrCodeField.current !== null) {\n            dAppConnect.current.generateQRCode(qrCodeField.current);\n          }\n        }\n      }\n    }\n  }, []);\n\n  return (\n    <div className=\"mesh-flex mesh-flex-col mesh-items-center mesh-justify-center\">\n      <div style={{ marginTop: 16, marginBottom: 16 }} ref={qrCodeField}></div>\n      <Button\n        variant=\"outline\"\n        onClick={() => {\n          navigator.clipboard.writeText(address);\n          setCopied(true);\n        }}\n      >\n        {copied ? \"Copied\" : \"Copy Address\"}\n      </Button>\n    </div>\n  );\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "__0",
          "type": "{ cardanoPeerConnect?: { dAppInfo: { name: string; url: string; }; announce: string[]; } | undefined; setOpen: Function; }",
          "optional": false
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/cardano-wallet/screen-p2p.tsx",
      "module": "screen-p2p",
      "source": "mesh-react"
    },
    {
      "name": "ScreenWebauthn",
      "signature": "export default function ScreenWebauthn({\n  url,\n  networkId,\n  provider,\n  setOpen,\n}: {\n  url: string;\n  networkId: 0 | 1;\n  provider: IFetcher & ISubmitter;\n  setOpen: Function;\n}) {\n  const [loading, setLoading] = useState(false);\n  const [userName, setUserName] = useState<string>(\"\");\n  const [password, setPassword] = useState<string>(\"\");\n  const { setWallet } = useWallet();\n\n  function createWallet(root: string) {\n    setTimeout(() => {\n      const wallet = new MeshWallet({\n        networkId: networkId,\n        fetcher: provider,\n        submitter: provider,\n        key: {\n          type: \"root\",\n          bech32: root,\n        },\n      });\n      setWallet(wallet, screens.webauthn.title);\n      setLoading(false);\n      setOpen(false);\n    }, 500);\n  }\n\n  async function handleConnect() {\n    setLoading(true);\n    const res = await connect({ username: userName, password, serverUrl: url });\n    if (res.success && res.wallet) {\n      createWallet(res.wallet.bech32PrivateKey);\n    }\n  }\n\n  return (\n    <div className=\"mesh-flex mesh-flex-row mesh-flex-gap-4 mesh-items-center mesh-justify-center\">\n      {loading ? (\n        <>Connecting wallet...</>\n      ) : (\n        <>\n          <div className=\"mesh-flex mesh-flex-col mesh-gap-6 mesh-w-full mesh-mx-8\">\n            <div className=\"mesh-grid mesh-gap-2\">\n              <Label htmlFor=\"username\">Username</Label>\n              <Input\n                id=\"username\"\n                type=\"username\"\n                placeholder=\"adalovelace\"\n                value={userName}\n                onChange={(e) => setUserName(e.target.value)}\n              />\n              <p className=\"mesh-text-gray-500 mesh-text-xs\">\n                Unique to the application you are connecting.\n              </p>\n            </div>\n            <div className=\"mesh-grid mesh-gap-2\">\n              <div className=\"mesh-flex mesh-items-center\">\n                <Label htmlFor=\"password\">Unique Code</Label>\n              </div>\n              <Input\n                id=\"password\"\n                type=\"password\"\n                placeholder=\"********\"\n                value={password}\n                onChange={(e) => setPassword(e.target.value)}\n              />\n              <p className=\"mesh-text-gray-500 mesh-text-xs\">\n                Additional security to derive your wallet.\n              </p>\n            </div>\n            <Button\n              className=\"mesh-w-full\"\n              onClick={() => handleConnect()}\n              disabled={!userName || userName.length < 6}\n            >\n              Connect\n            </Button>\n          </div>\n        </>\n      )}\n    </div>\n  );\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "__0",
          "type": "{ url: string; networkId: 0 | 1; provider: any; setOpen: Function; }",
          "optional": false
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/cardano-wallet/screen-webauthn.tsx",
      "module": "screen-webauthn",
      "source": "mesh-react"
    },
    {
      "name": "WalletIcon",
      "signature": "export default function WalletIcon({\n  icon,\n  name,\n  action,\n  iconReactNode,\n  loading = false,\n}: {\n  icon?: string;\n  name: string;\n  action: () => void;\n  iconReactNode?: React.ReactNode;\n  loading?: boolean;\n}) {\n  return (\n    <Tooltip delayDuration={0} defaultOpen={false}>\n      <TooltipTrigger asChild>\n        <button\n          className=\"mesh-flex mesh-items-center mesh-justify-center mesh-rounded-lg mesh-w-10 mesh-h-10 mesh-bg-neutral-50 mesh-border mesh-border-zinc-700 hover:mesh-border-zinc-200 mesh-cursor-pointer\"\n          onClick={action}\n          disabled={loading}\n        >\n          {icon && !loading && (\n            <img src={icon} alt={name} className=\"mesh-w-8 mesh-h-8\" />\n          )}\n          {!loading && iconReactNode && iconReactNode}\n          {loading && <span className=\"text-black\">...</span>}\n        </button>\n      </TooltipTrigger>\n      <TooltipContent>\n        <p>{name}</p>\n      </TooltipContent>\n    </Tooltip>\n  );\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "__0",
          "type": "{ icon?: string | undefined; name: string; action: () => void; iconReactNode?: React.ReactNode; loading?: boolean | undefined; }",
          "optional": false
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/cardano-wallet/wallet-icon.tsx",
      "module": "wallet-icon",
      "source": "mesh-react"
    },
    {
      "name": "Web3Services",
      "signature": "export default function Web3Services({\n  options,\n  setOpen,\n  persist,\n}: {\n  options: EnableWeb3WalletOptions;\n  setOpen: Function;\n  persist: boolean;\n}) {\n  const { setWallet, setWeb3UserData } = useWallet();\n  const [loading, setLoading] = useState(false);\n\n  async function loadWallet(directTo: UserControlledWalletDirectTo) {\n    setLoading(true);\n    const _options: EnableWeb3WalletOptions = {\n      networkId: 0,\n      fetcher: options.fetcher,\n      submitter: options.submitter,\n      appUrl: options.appUrl,\n      projectId: options.projectId,\n      directTo: directTo,\n    };\n    const wallet = await Web3Wallet.enable(_options);\n    const user = wallet.getUser();\n\n    setWeb3UserData(user);\n    setWallet(\n      wallet,\n      \"Mesh Web3 Services\",\n      persist\n        ? {\n            walletAddress: await wallet.getChangeAddress(),\n            user: user,\n          }\n        : undefined,\n    );\n    setLoading(false);\n    setOpen(false);\n  }\n\n  return (\n    <>\n      <WalletIcon\n        iconReactNode={IconGoogle()}\n        name={`Google`}\n        action={() => loadWallet(\"google\")}\n        loading={loading}\n      />\n      <WalletIcon\n        iconReactNode={IconDiscord()}\n        name={`Discord`}\n        action={() => loadWallet(\"discord\")}\n        loading={loading}\n      />\n      <WalletIcon\n        iconReactNode={IconTwitter()}\n        name={`Twitter`}\n        action={() => loadWallet(\"twitter\")}\n        loading={loading}\n      />\n    </>\n  );\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "__0",
          "type": "{ options: EnableWeb3WalletOptions; setOpen: Function; persist: boolean; }",
          "optional": false
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/cardano-wallet/web3-services.tsx",
      "module": "web3-services",
      "source": "mesh-react"
    },
    {
      "name": "MenuItem",
      "signature": "export function MenuItem({\n  icon,\n  label,\n  action,\n  active,\n}: {\n  icon?: string;\n  label: string;\n  action: () => void;\n  active: boolean;\n}) {\n  return (\n    <div\n      className=\"mesh-flex mesh-cursor-pointer mesh-items-center mesh-px-4 mesh-py-2 mesh-opacity-80 hover:mesh-opacity-100 mesh-h-16\"\n      onClick={action}\n    >\n      {icon && <img className=\"mesh-pr-2 mesh-m-1 mesh-h-8\" src={icon} />}\n      <span className=\"mesh-mr-menu-item mesh-text-xl mesh-font-normal mesh-text-neutral-700 hover:mesh-text-black\">\n        {label\n          .split(\" \")\n          .map((word: string) => {\n            return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();\n          })\n          .join(\" \")}\n      </span>\n    </div>\n  );\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "__0",
          "type": "{ icon?: string | undefined; label: string; action: () => void; active: boolean; }",
          "optional": false
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/cardano-wallet-dropdown/menu-item.tsx",
      "module": "menu-item",
      "source": "mesh-react"
    },
    {
      "name": "ButtonDropdown",
      "signature": "export default function ButtonDropdown({\n  children,\n  isDarkMode = false,\n  hideMenuList = false,\n  setHideMenuList,\n  onMouseEnter,\n  onMouseLeave,\n}: {\n  children: React.ReactNode;\n  isDarkMode?: boolean;\n  hideMenuList?: boolean;\n  setHideMenuList?: (hideMenuList: boolean) => void;\n  onMouseEnter?: () => void;\n  onMouseLeave?: () => void;\n}) {\n  return (\n    <button\n      className={`mesh-mr-menu-list mesh-flex mesh-w-60 mesh-items-center mesh-justify-center mesh-rounded-t-md mesh-border mesh-px-4 mesh-py-2 mesh-text-lg mesh-font-normal mesh-shadow-sm ${isDarkMode ? `mesh-bg-neutral-950\tmesh-text-neutral-50` : `mesh-bg-neutral-50\tmesh-text-neutral-950`}`}\n      onClick={() => setHideMenuList && setHideMenuList(!hideMenuList)}\n      onMouseEnter={onMouseEnter}\n      onMouseLeave={onMouseLeave}\n    >\n      {children}\n    </button>\n  );\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "__0",
          "type": "{ children: React.ReactNode; isDarkMode?: boolean | undefined; hideMenuList?: boolean | undefined; setHideMenuList?: ((hideMenuList: boolean) => void) | undefined; onMouseEnter?: (() => void) | undefined; onMouseLeave?: (() => void) | undefined; }",
          "optional": false
        }
      ],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/common/button-dropdown.tsx",
      "module": "button-dropdown",
      "source": "mesh-react"
    },
    {
      "name": "cn",
      "signature": "export function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "inputs",
          "type": "import(\"/Users/g/code/don-docs/dons-docs/node_modules/clsx/clsx\").ClassValue[]",
          "optional": false
        }
      ],
      "returnType": "any",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/common/cn.ts",
      "module": "cn",
      "source": "mesh-react"
    },
    {
      "name": "verifySignature",
      "signature": "export function verifySignature(\n  message: string,\n  signatureBase64: string,\n  publicKeyHex: string\n): boolean {\n  try {\n    const messageBuffer = Buffer.from(message, \"utf8\");\n    const bufferToHash = Buffer.concat([\n      varIntBuffer(messageBuffer.length),\n      messageBuffer,\n    ]);\n    const hash = bitcoin.crypto.hash256(bufferToHash);\n    const signature = Buffer.from(signatureBase64, \"base64\");\n    const publicKey = Buffer.from(publicKeyHex, \"hex\");\n\n    return ECPair.fromPublicKey(publicKey).verify(hash, signature);\n  } catch (e) {\n    return false;\n  }\n}",
      "documentation": "Verifies if a signature is valid for a given message and public key.",
      "parameters": [
        {
          "name": "message",
          "type": "string",
          "optional": false
        },
        {
          "name": "signatureBase64",
          "type": "string",
          "optional": false
        },
        {
          "name": "publicKeyHex",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "boolean",
      "isExported": true,
      "importPath": "offchain/bitcoin/src/wallets/embedded/index.ts",
      "module": "index",
      "source": "bitcoin"
    },
    {
      "name": "cloneTxBuilderBody",
      "signature": "export function cloneTxBuilderBody(body: MeshTxBuilderBody): MeshTxBuilderBody {\n  const { extraInputs, ...otherProps } = body;\n  const cloned = structuredClone(otherProps) as MeshTxBuilderBody;\n  cloned.extraInputs = extraInputs;\n  return cloned;\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "body",
          "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/index\").MeshTxBuilderBody",
          "optional": false
        }
      ],
      "returnType": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/index\").MeshTxBuilderBody",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/index.ts",
      "module": "index",
      "source": "mesh-common"
    },
    {
      "name": "IconBitcoin",
      "signature": "export default function IconBitcoin() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      stroke-width=\"2\"\n      stroke-linecap=\"round\"\n      stroke-linejoin=\"round\"\n      style={{\n        color: \"#CC9900\",\n        width: \"24px\",\n        height: \"24px\",\n        strokeWidth: \"1px\",\n      }}\n      className=\"hover:mesh-fill-white\"\n    >\n      <path d=\"M11.767 19.089c4.924.868 6.14-6.025 1.216-6.894m-1.216 6.894L5.86 18.047m5.908 1.042-.347 1.97m1.563-8.864c4.924.869 6.14-6.025 1.215-6.893m-1.215 6.893-3.94-.694m5.155-6.2L8.29 4.26m5.908 1.042.348-1.97M7.48 20.364l3.126-17.727\" />\n    </svg>\n  );\n}",
      "documentation": "",
      "parameters": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/common/icons/icon-bitcoin.tsx",
      "module": "icon-bitcoin",
      "source": "mesh-react"
    },
    {
      "name": "IconBookDashed",
      "signature": "export default function IconBookDashed() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"gray\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      style={{\n        color: \"#ffadff\",\n        width: \"24px\",\n        height: \"24px\",\n        strokeWidth: \"1px\",\n      }}\n      className=\"hover:mesh-fill-white\"\n    >\n      <path d=\"M12 17h2\" />\n      <path d=\"M12 22h2\" />\n      <path d=\"M12 2h2\" />\n      <path d=\"M18 22h1a1 1 0 0 0 1-1\" />\n      <path d=\"M18 2h1a1 1 0 0 1 1 1v1\" />\n      <path d=\"M20 15v2h-2\" />\n      <path d=\"M20 8v3\" />\n      <path d=\"M4 11V9\" />\n      <path d=\"M4 19.5V15\" />\n      <path d=\"M4 5v-.5A2.5 2.5 0 0 1 6.5 2H8\" />\n      <path d=\"M8 22H6.5a1 1 0 0 1 0-5H8\" />\n    </svg>\n  );\n}",
      "documentation": "",
      "parameters": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/common/icons/icon-book-dashed.tsx",
      "module": "icon-book-dashed",
      "source": "mesh-react"
    },
    {
      "name": "IconChevronRight",
      "signature": "export default function IconChevronRight() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"gray\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      style={{\n        color: \"#ffadff\",\n        width: \"24px\",\n        height: \"24px\",\n        strokeWidth: \"1px\",\n      }}\n      className=\"hover:mesh-fill-white\"\n    >\n      <path d=\"m15 18-6-6 6-6\" />\n    </svg>\n  );\n}",
      "documentation": "",
      "parameters": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/common/icons/icon-chevron-right.tsx",
      "module": "icon-chevron-right",
      "source": "mesh-react"
    },
    {
      "name": "IconDiscord",
      "signature": "export default function IconDiscord() {\n  return (\n    <svg\n      viewBox=\"0 0 20 20\"\n      aria-hidden=\"true\"\n      style={{\n        width: \"24px\",\n        height: \"24px\",\n      }}\n    >\n      <path\n        d=\"M16.238 4.515a14.842 14.842 0 0 0-3.664-1.136.055.055 0 0 0-.059.027 10.35 10.35 0 0 0-.456.938 13.702 13.702 0 0 0-4.115 0 9.479 9.479 0 0 0-.464-.938.058.058 0 0 0-.058-.027c-1.266.218-2.497.6-3.664 1.136a.052.052 0 0 0-.024.02C1.4 8.023.76 11.424 1.074 14.782a.062.062 0 0 0 .024.042 14.923 14.923 0 0 0 4.494 2.272.058.058 0 0 0 .064-.02c.346-.473.654-.972.92-1.496a.057.057 0 0 0-.032-.08 9.83 9.83 0 0 1-1.404-.669.058.058 0 0 1-.029-.046.058.058 0 0 1 .023-.05c.094-.07.189-.144.279-.218a.056.056 0 0 1 .058-.008c2.946 1.345 6.135 1.345 9.046 0a.056.056 0 0 1 .059.007c.09.074.184.149.28.22a.058.058 0 0 1 .023.049.059.059 0 0 1-.028.046 9.224 9.224 0 0 1-1.405.669.058.058 0 0 0-.033.033.056.056 0 0 0 .002.047c.27.523.58 1.022.92 1.495a.056.056 0 0 0 .062.021 14.878 14.878 0 0 0 4.502-2.272.055.055 0 0 0 .016-.018.056.056 0 0 0 .008-.023c.375-3.883-.63-7.256-2.662-10.246a.046.046 0 0 0-.023-.021Zm-9.223 8.221c-.887 0-1.618-.814-1.618-1.814s.717-1.814 1.618-1.814c.908 0 1.632.821 1.618 1.814 0 1-.717 1.814-1.618 1.814Zm5.981 0c-.887 0-1.618-.814-1.618-1.814s.717-1.814 1.618-1.814c.908 0 1.632.821 1.618 1.814 0 1-.71 1.814-1.618 1.814Z\"\n        fill=\"#5865F2\"\n      />\n    </svg>\n  );\n}",
      "documentation": "",
      "parameters": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/common/icons/icon-discord.tsx",
      "module": "icon-discord",
      "source": "mesh-react"
    },
    {
      "name": "IconDownload",
      "signature": "export default function IconDownload() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"gray\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      style={{\n        color: \"#ffadff\",\n        width: \"24px\",\n        height: \"24px\",\n        strokeWidth: \"1px\",\n      }}\n    >\n      <path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\" />\n      <polyline points=\"7 10 12 15 17 10\" />\n      <line x1=\"12\" x2=\"12\" y1=\"15\" y2=\"3\" />\n    </svg>\n  );\n}",
      "documentation": "",
      "parameters": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/common/icons/icon-download.tsx",
      "module": "icon-download",
      "source": "mesh-react"
    },
    {
      "name": "IconFingerprint",
      "signature": "export default function IconFingerprint() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      style={{\n        color: \"#ffadff\",\n        width: \"24px\",\n        height: \"24px\",\n        strokeWidth: \"1px\",\n      }}\n      className=\"hover:mesh-fill-white\"\n    >\n      <path d=\"M12 10a2 2 0 0 0-2 2c0 1.02-.1 2.51-.26 4\" />\n      <path d=\"M14 13.12c0 2.38 0 6.38-1 8.88\" />\n      <path d=\"M17.29 21.02c.12-.6.43-2.3.5-3.02\" />\n      <path d=\"M2 12a10 10 0 0 1 18-6\" />\n      <path d=\"M2 16h.01\" />\n      <path d=\"M21.8 16c.2-2 .131-5.354 0-6\" />\n      <path d=\"M5 19.5C5.5 18 6 15 6 12a6 6 0 0 1 .34-2\" />\n      <path d=\"M8.65 22c.21-.66.45-1.32.57-2\" />\n      <path d=\"M9 6.8a6 6 0 0 1 9 5.2v2\" />\n    </svg>\n  );\n}",
      "documentation": "",
      "parameters": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/common/icons/icon-fingerprint.tsx",
      "module": "icon-fingerprint",
      "source": "mesh-react"
    },
    {
      "name": "IconGoogle",
      "signature": "export default function IconGoogle() {\n  return (\n    <svg\n      viewBox=\"0 0 262 262\"\n      xmlns=\"http://www.w3.org/2000/svg\"\n      preserveAspectRatio=\"xMidYMid\"\n      style={{\n        width: \"24px\",\n        height: \"24px\",\n      }}\n    >\n      <path\n        d=\"M255.878 133.451c0-10.734-.871-18.567-2.756-26.69H130.55v48.448h71.947c-1.45 12.04-9.283 30.172-26.69 42.356l-.244 1.622 38.755 30.023 2.685.268c24.659-22.774 38.875-56.282 38.875-96.027\"\n        fill=\"#4285F4\"\n      />\n      <path\n        d=\"M130.55 261.1c35.248 0 64.839-11.605 86.453-31.622l-41.196-31.913c-11.024 7.688-25.82 13.055-45.257 13.055-34.523 0-63.824-22.773-74.269-54.25l-1.531.13-40.298 31.187-.527 1.465C35.393 231.798 79.49 261.1 130.55 261.1\"\n        fill=\"#34A853\"\n      />\n      <path\n        d=\"M56.281 156.37c-2.756-8.123-4.351-16.827-4.351-25.82 0-8.994 1.595-17.697 4.206-25.82l-.073-1.73L15.26 71.312l-1.335.635C5.077 89.644 0 109.517 0 130.55s5.077 40.905 13.925 58.602l42.356-32.782\"\n        fill=\"#FBBC05\"\n      />\n      <path\n        d=\"M130.55 50.479c24.514 0 41.05 10.589 50.479 19.438l36.844-35.974C195.245 12.91 165.798 0 130.55 0 79.49 0 35.393 29.301 13.925 71.947l42.211 32.783c10.59-31.477 39.891-54.251 74.414-54.251\"\n        fill=\"#EB4335\"\n      />\n    </svg>\n  );\n}",
      "documentation": "",
      "parameters": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/common/icons/icon-google.tsx",
      "module": "icon-google",
      "source": "mesh-react"
    },
    {
      "name": "IconMonitorSmartphone",
      "signature": "export default function IconMonitorSmartphone() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"black\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      style={{\n        color: \"#ffadff\",\n        width: \"56px\",\n        height: \"56px\",\n        strokeWidth: \"1px\",\n      }}\n    >\n      <path d=\"M18 8V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h8\" />\n      <path d=\"M10 19v-3.96 3.15\" />\n      <path d=\"M7 19h5\" />\n      <rect width=\"6\" height=\"10\" x=\"16\" y=\"12\" rx=\"2\" />\n    </svg>\n  );\n}",
      "documentation": "",
      "parameters": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/common/icons/icon-monitor-smartphone.tsx",
      "module": "icon-monitor-smartphone",
      "source": "mesh-react"
    },
    {
      "name": "IconPlus",
      "signature": "export default function IconPlus() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"black\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      style={{\n        color: \"#ffadff\",\n        width: \"56px\",\n        height: \"56px\",\n        strokeWidth: \"1px\",\n      }}\n    >\n      <path d=\"M5 12h14\" />\n      <path d=\"M12 5v14\" />\n    </svg>\n  );\n}",
      "documentation": "",
      "parameters": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/common/icons/icon-plus.tsx",
      "module": "icon-plus",
      "source": "mesh-react"
    },
    {
      "name": "IconTwitter",
      "signature": "export default function IconTwitter() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      version=\"1.1\"\n      viewBox=\"0 0 24 24\"\n      style={{\n        width: \"24px\",\n        height: \"24px\",\n      }}\n    >\n      <path d=\"M14.095479,10.316482L22.286354,1h-1.940718l-7.115352,8.087682L7.551414,1H1l8.589488,12.231093L1,23h1.940717  l7.509372-8.542861L16.448587,23H23L14.095479,10.316482z M11.436522,13.338465l-0.871624-1.218704l-6.924311-9.68815h2.981339  l5.58978,7.82155l0.867949,1.218704l7.26506,10.166271h-2.981339L11.436522,13.338465z\" />\n    </svg>\n  );\n}",
      "documentation": "",
      "parameters": [],
      "returnType": "React.JSX.Element",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/common/icons/icon-twitter.tsx",
      "module": "icon-twitter",
      "source": "mesh-react"
    },
    {
      "name": "connect",
      "signature": "export async function connect(w: Wallet) {\n  connecting = true;\n  try {\n    wallet = await BrowserWallet.enable(w.id);\n    name = w.name\n      .split(\" \")\n      .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n      .join(\" \");\n    icon = w.icon;\n  } catch (e) {\n    console.error(`error while connecting wallet ${w.name}: ${e}`);\n  }\n  connecting = false;\n  connected = true;\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "w",
          "type": "Wallet",
          "optional": false
        }
      ],
      "returnType": "Promise<void>",
      "isExported": true,
      "importPath": "offchain/mesh-svelte/src/lib/state/browser-wallet-state.svelte.ts",
      "module": "browser-wallet-state.svelte",
      "source": "mesh-svelte"
    },
    {
      "name": "disconnect",
      "signature": "export function disconnect() {\n  wallet = undefined;\n  name = undefined;\n  icon = undefined;\n  connected = false;\n}",
      "documentation": "",
      "parameters": [],
      "returnType": "void",
      "isExported": true,
      "importPath": "offchain/mesh-svelte/src/lib/state/browser-wallet-state.svelte.ts",
      "module": "browser-wallet-state.svelte",
      "source": "mesh-svelte"
    },
    {
      "name": "connect",
      "signature": "export async function connect({\n  username,\n  password,\n  serverUrl,\n}: {\n  username: string;\n  password: string;\n  serverUrl: string;\n}) {\n  const responseRegister = await register({ serverUrl, username });\n  if (\n    responseRegister.success ||\n    responseRegister.error.errorCode == ERRORCODES.USEREXISTS\n  ) {\n    const loginRes = await handleLogin({ serverUrl, username });\n    if (loginRes.success && loginRes.authJSON) {\n      const wallet = await buildWalletFromPasskey(\n        loginRes.authJSON.rawId,\n        password,\n      );\n      return { success: true, wallet: wallet };\n    }\n  } else {\n    return { success: false, error: responseRegister.error };\n  }\n  return { success: false, error: \"Fail to connect\" };\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "__0",
          "type": "{ username: string; password: string; serverUrl: string; }",
          "optional": false
        }
      ],
      "returnType": "Promise<{ success: boolean; wallet: { bech32PrivateKey: any; }; error?: undefined; } | { success: boolean; error: any; wallet?: undefined; }>",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/browser/webauthn/auth/connect.ts",
      "module": "connect",
      "source": "mesh-wallet"
    },
    {
      "name": "login",
      "signature": "export async function login({\n  serverUrl,\n  username,\n}: {\n  serverUrl: string;\n  username: string;\n}) {\n  // 1. Get challenge from server\n  const initAuthRes = await fetch(`${serverUrl}/auth-init`, {\n    credentials: \"include\",\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      username,\n    }),\n  });\n\n  const initAuth = await initAuthRes.json();\n  if (!initAuth.success) {\n    return {\n      success: false,\n      error: initAuth.error,\n      errorCode: initAuth.errorCode,\n    };\n  }\n\n  const optionsJSON = initAuth.data.optionsJSON;\n\n  // 2. Get passkey\n  const authJSON = await startAuthentication({ optionsJSON });\n\n  // 3. Verify passkey with DB\n  const verifyAuthRes = await fetch(`${serverUrl}/auth-verify`, {\n    credentials: \"include\",\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(authJSON),\n  });\n\n  const verifyAuth = await verifyAuthRes.json();\n\n  if (!verifyAuthRes.ok) {\n    return { success: false, error: verifyAuth.error };\n  }\n  if (verifyAuth.data.verified) {\n    return { success: true, authJSON: authJSON };\n  } else {\n    return { success: false, error: \"Failed to log in\" };\n  }\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "__0",
          "type": "{ serverUrl: string; username: string; }",
          "optional": false
        }
      ],
      "returnType": "Promise<{ success: boolean; error: any; errorCode: any; authJSON?: undefined; } | { success: boolean; error: any; errorCode?: undefined; authJSON?: undefined; } | { success: boolean; authJSON: any; error?: undefined; errorCode?: undefined; }>",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/browser/webauthn/auth/login.ts",
      "module": "login",
      "source": "mesh-wallet"
    },
    {
      "name": "register",
      "signature": "export async function register({\n  serverUrl,\n  username,\n}: {\n  serverUrl: string;\n  username: string;\n}) {\n  // 1. Get challenge from server\n  const initRegisterRes = await fetch(`${serverUrl}/register-init`, {\n    credentials: \"include\",\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      username,\n    }),\n  });\n  const initRegister = await initRegisterRes.json();\n  if (!initRegister.success) {\n    return {\n      success: false,\n      error: initRegister.error,\n      errorCode: initRegister.errorCode,\n    };\n  }\n\n  // 2. Create passkey\n  const optionsJSON = initRegister.data.optionsJSON;\n  const registrationJSON = await startRegistration({ optionsJSON });\n\n  // 3. Save passkey in DB\n  const verifyResponse = await fetch(`${serverUrl}/register-verify`, {\n    credentials: \"include\",\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(registrationJSON),\n  });\n\n  const verifyData = await verifyResponse.json();\n  if (!verifyResponse.ok) {\n    console.error(verifyData.error);\n    return {\n      success: false,\n      error: verifyData.error,\n      errorCode: verifyData.errorCode,\n    };\n  }\n  if (verifyData.data.verified) {\n    console.log(`Successfully registered ${username}`);\n    return { success: true };\n  } else {\n    console.error(`Failed to register`);\n    return { success: false, error: \"Failed to register\", errorCode: 1 };\n  }\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "__0",
          "type": "{ serverUrl: string; username: string; }",
          "optional": false
        }
      ],
      "returnType": "Promise<{ success: boolean; error: any; errorCode: any; } | { success: boolean; error?: undefined; errorCode?: undefined; }>",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/browser/webauthn/auth/register.ts",
      "module": "register",
      "source": "mesh-wallet"
    },
    {
      "name": "buildWalletFromPasskey",
      "signature": "export async function buildWalletFromPasskey(\n  rawId: string,\n  password: string,\n  appSalt = \"appSalt\",\n) {\n  const entropy = await createEntropy(rawId, appSalt);\n  return buildKey(Buffer.from(entropy), password);\n}",
      "documentation": "",
      "parameters": [
        {
          "name": "rawId",
          "type": "string",
          "optional": false
        },
        {
          "name": "password",
          "type": "string",
          "optional": false
        },
        {
          "name": "appSalt",
          "type": "string",
          "optional": false
        }
      ],
      "returnType": "Promise<{ bech32PrivateKey: any; }>",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/browser/webauthn/cardano/build-wallet-from-passkey.ts",
      "module": "build-wallet-from-passkey",
      "source": "mesh-wallet"
    }
  ],
  "types": [
    {
      "name": "MeshTxInitiatorInput",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/common\").MeshTxInitiatorInput",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/common.ts",
      "documentation": "",
      "module": "common",
      "source": "mesh-contract"
    },
    {
      "name": "BlockfrostCachingOptions",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/blockfrost\").BlockfrostCachingOptions",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/blockfrost.ts",
      "documentation": "",
      "module": "blockfrost",
      "source": "mesh-provider"
    },
    {
      "name": "BlockfrostSupportedNetworks",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/blockfrost\").BlockfrostSupportedNetworks",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/blockfrost.ts",
      "documentation": "",
      "module": "blockfrost",
      "source": "mesh-provider"
    },
    {
      "name": "KoiosSupportedNetworks",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/koios\").KoiosSupportedNetworks",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/koios.ts",
      "documentation": "",
      "module": "koios",
      "source": "mesh-provider"
    },
    {
      "name": "MaestroSupportedNetworks",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/maestro\").MaestroSupportedNetworks",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/maestro.ts",
      "documentation": "",
      "module": "maestro",
      "source": "mesh-provider"
    },
    {
      "name": "IBitcoinProvider",
      "definition": "export interface IBitcoinProvider {\n  fetchAddress(address: string): Promise<AddressInfo>;\n  fetchAddressTransactions(\n    address: string,\n    last_seen_txid?: string\n  ): Promise<TransactionsInfo[]>;\n  fetchAddressUTxOs(address: string): Promise<UTxO[]>;\n  fetchScript(hash: string): Promise<ScriptInfo>;\n  fetchScriptTransactions(\n    hash: string,\n    last_seen_txid?: string\n  ): Promise<TransactionsInfo[]>;\n  fetchScriptUTxOs(hash: string): Promise<UTxO[]>;\n  fetchTransactionStatus(txid: string): Promise<TransactionsStatus>;\n  submitTx(tx: string): Promise<string>;\n}",
      "isExported": true,
      "importPath": "offchain/bitcoin/src/interfaces/provider.ts",
      "documentation": "",
      "module": "provider",
      "source": "bitcoin"
    },
    {
      "name": "IBitcoinWallet",
      "definition": "export interface IBitcoinWallet {\n  getChangeAddress(): Promise<string>;\n  getNetworkId(): Promise<0 | 1>;\n  signTx(signedTx: string): Promise<string>;\n  submitTx(tx: string): Promise<string>;\n}",
      "isExported": true,
      "importPath": "offchain/bitcoin/src/interfaces/wallet.ts",
      "documentation": "",
      "module": "wallet",
      "source": "bitcoin"
    },
    {
      "name": "AddressInfo",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/address-info\").AddressInfo",
      "isExported": true,
      "importPath": "offchain/bitcoin/src/types/address-info.ts",
      "documentation": "",
      "module": "address-info",
      "source": "bitcoin"
    },
    {
      "name": "Address",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/address\").Address",
      "isExported": true,
      "importPath": "offchain/bitcoin/src/types/address.ts",
      "documentation": "",
      "module": "address",
      "source": "bitcoin"
    },
    {
      "name": "ChainStats",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/chain-stats\").ChainStats",
      "isExported": true,
      "importPath": "offchain/bitcoin/src/types/chain-stats.ts",
      "documentation": "",
      "module": "chain-stats",
      "source": "bitcoin"
    },
    {
      "name": "MempoolStats",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/mempool-stats\").MempoolStats",
      "isExported": true,
      "importPath": "offchain/bitcoin/src/types/mempool-stats.ts",
      "documentation": "",
      "module": "mempool-stats",
      "source": "bitcoin"
    },
    {
      "name": "ScriptInfo",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/script-info\").ScriptInfo",
      "isExported": true,
      "importPath": "offchain/bitcoin/src/types/script-info.ts",
      "documentation": "",
      "module": "script-info",
      "source": "bitcoin"
    },
    {
      "name": "TransactionsInfo",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/transactions-info\").TransactionsInfo",
      "isExported": true,
      "importPath": "offchain/bitcoin/src/types/transactions-info.ts",
      "documentation": "",
      "module": "transactions-info",
      "source": "bitcoin"
    },
    {
      "name": "TransactionsStatus",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/transactions-status\").TransactionsStatus",
      "isExported": true,
      "importPath": "offchain/bitcoin/src/types/transactions-status.ts",
      "documentation": "",
      "module": "transactions-status",
      "source": "bitcoin"
    },
    {
      "name": "UTxO",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/types/utxo\").UTxO",
      "isExported": true,
      "importPath": "offchain/bitcoin/src/types/utxo.ts",
      "documentation": "",
      "module": "utxo",
      "source": "bitcoin"
    },
    {
      "name": "PlutusDataType",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/index\").PlutusDataType",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-common"
    },
    {
      "name": "SlotConfig",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/time\").SlotConfig",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/time.ts",
      "documentation": "",
      "module": "time",
      "source": "mesh-common"
    },
    {
      "name": "Value",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").Value",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/value.ts",
      "documentation": "Aiken alias\nValue is the JSON representation of Cardano data Value",
      "module": "value",
      "source": "mesh-common"
    },
    {
      "name": "MValue",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MValue",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/value.ts",
      "documentation": "Aiken alias\nMValue is the Cardano data Value in Mesh Data type",
      "module": "value",
      "source": "mesh-common"
    },
    {
      "name": "IEvaluator",
      "definition": "export interface IEvaluator {\n  evaluateTx(\n    tx: string,\n    additionalUtxos?: UTxO[],\n    additionalTxs?: string[],\n  ): Promise<Omit<Action, \"data\">[]>;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/interfaces/evaluator.ts",
      "documentation": "",
      "module": "evaluator",
      "source": "mesh-common"
    },
    {
      "name": "IFetcherOptions",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/interfaces/fetcher\").IFetcherOptions",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/interfaces/fetcher.ts",
      "documentation": "",
      "module": "fetcher",
      "source": "mesh-common"
    },
    {
      "name": "IFetcher",
      "definition": "export interface IFetcher {\n  fetchAccountInfo(address: string): Promise<AccountInfo>;\n  fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;\n  fetchAddressTxs(\n    address: string,\n    options?: IFetcherOptions,\n  ): Promise<TransactionInfo[]>;\n  fetchAssetAddresses(\n    asset: string,\n  ): Promise<{ address: string; quantity: string }[]>;\n  fetchAssetMetadata(asset: string): Promise<AssetMetadata>;\n  fetchBlockInfo(hash: string): Promise<BlockInfo>;\n  fetchCollectionAssets(\n    policyId: string,\n    cursor?: number | string,\n  ): Promise<{ assets: Asset[]; next?: string | number | null }>;\n  fetchProtocolParameters(epoch: number): Promise<Protocol>;\n  fetchTxInfo(hash: string): Promise<TransactionInfo>;\n  fetchUTxOs(hash: string, index?: number): Promise<UTxO[]>;\n  fetchGovernanceProposal(\n    txHash: string,\n    certIndex: number,\n  ): Promise<GovernanceProposalInfo>;\n  get(url: string): Promise<any>;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/interfaces/fetcher.ts",
      "documentation": "Fetcher interface defines end points to query blockchain data.",
      "module": "fetcher",
      "source": "mesh-common"
    },
    {
      "name": "IInitiator",
      "definition": "export interface IInitiator {\n  getChangeAddress(): Promise<string>;\n  getCollateral(): Promise<UTxO[]>;\n  getUtxos(): Promise<UTxO[]>;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/interfaces/initiator.ts",
      "documentation": "",
      "module": "initiator",
      "source": "mesh-common"
    },
    {
      "name": "IListener",
      "definition": "export interface IListener {\n  onTxConfirmed(txHash: string, callback: () => void, limit?: number): void;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/interfaces/listener.ts",
      "documentation": "",
      "module": "listener",
      "source": "mesh-common"
    },
    {
      "name": "IMeshTxSerializer",
      "definition": "export interface IMeshTxSerializer {\n  serializeTxBody(\n    txBuilderBody: MeshTxBuilderBody,\n    protocolParams: Protocol,\n  ): string;\n  serializeTxBodyWithMockSignatures(\n    txBuilderBody: MeshTxBuilderBody,\n    protocolParams: Protocol,\n  ): string;\n  addSigningKeys(txHex: string, signingKeys: string[]): string;\n  serializeData(data: BuilderData): string;\n  serializeAddress(address: DeserializedAddress, networkId?: 0 | 1): string;\n  serializePoolId(hash: string): string;\n  serializeRewardAddress(\n    stakeKeyHash: string,\n    isScriptHash?: boolean,\n    network_id?: 0 | 1,\n  ): string;\n  serializeOutput(output: Output): string;\n  serializeValue(value: Asset[]): string;\n  resolver: IResolver;\n  deserializer: IDeserializer;\n  parser: ITxParser;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/interfaces/serializer.ts",
      "documentation": "",
      "module": "serializer",
      "source": "mesh-common"
    },
    {
      "name": "ITxParser",
      "definition": "export interface ITxParser {\n  getRequiredInputs(txHex: string): TxInput[];\n  parse(txHex: string, resolvedUtxos?: UTxO[]): void;\n  toTester(): TxTester;\n  getBuilderBody(): MeshTxBuilderBody;\n  getBuilderBodyWithoutChange(): MeshTxBuilderBody;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/interfaces/serializer.ts",
      "documentation": "",
      "module": "serializer",
      "source": "mesh-common"
    },
    {
      "name": "IResolver",
      "definition": "export interface IResolver {\n  keys: {\n    resolvePrivateKey(words: string[]): string;\n    resolveRewardAddress(bech32: string): string;\n    resolveEd25519KeyHash(bech32: string): string;\n    resolveStakeKeyHash(bech32: string): string;\n  };\n  tx: {\n    resolveTxHash(txHex: string): string;\n  };\n  data: {\n    resolveDataHash(\n      rawData: BuilderData[\"content\"],\n      type?: PlutusDataType,\n    ): string;\n  };\n  script: {\n    resolveScriptRef(script: NativeScript | PlutusScript): string;\n  };\n}",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/interfaces/serializer.ts",
      "documentation": "",
      "module": "serializer",
      "source": "mesh-common"
    },
    {
      "name": "IDeserializer",
      "definition": "export interface IDeserializer {\n  key: {\n    deserializeAddress(bech32: string): DeserializedAddress;\n  };\n  script: {\n    deserializeNativeScript(script: NativeScript): DeserializedScript;\n    deserializePlutusScript(script: PlutusScript): DeserializedScript;\n  };\n  cert: {\n    deserializePoolId(poolId: string): string;\n  };\n}",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/interfaces/serializer.ts",
      "documentation": "",
      "module": "serializer",
      "source": "mesh-common"
    },
    {
      "name": "ISigner",
      "definition": "export interface ISigner {\n  signData(payload: string, address?: string): Promise<DataSignature>;\n  signTx(unsignedTx: string, partialSign?: boolean): Promise<string>;\n  signTxs(unsignedTxs: string[], partialSign?: boolean): Promise<string[]>;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/interfaces/signer.ts",
      "documentation": "",
      "module": "signer",
      "source": "mesh-common"
    },
    {
      "name": "ISubmitter",
      "definition": "export interface ISubmitter {\n  submitTx(tx: string): Promise<string>;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/interfaces/submitter.ts",
      "documentation": "",
      "module": "submitter",
      "source": "mesh-common"
    },
    {
      "name": "IWallet",
      "definition": "export interface IWallet extends IInitiator, ISigner, ISubmitter {\n  getAssets(): Promise<AssetExtended[]>;\n  getBalance(): Promise<Asset[]>;\n  getExtensions(): Promise<number[]>;\n  getUsedAddresses(): Promise<string[]>;\n  getLovelace(): Promise<string>;\n  getNetworkId(): Promise<number>;\n  getRewardAddresses(): Promise<string[]>;\n  getDRep(): Promise<\n    | {\n        publicKey: string;\n        publicKeyHash: string;\n        dRepIDCip105: string;\n      }\n    | undefined\n  >;\n  getUnusedAddresses(): Promise<string[]>;\n  getPolicyIdAssets(policyId: string): Promise<AssetExtended[]>;\n  getPolicyIds(): Promise<string[]>;\n  getRegisteredPubStakeKeys(): Promise<\n    | {\n        pubStakeKeys: string[];\n        pubStakeKeyHashes: string[];\n      }\n    | undefined\n  >;\n  getUnregisteredPubStakeKeys(): Promise<\n    | {\n        pubStakeKeys: string[];\n        pubStakeKeyHashes: string[];\n      }\n    | undefined\n  >;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/interfaces/wallet.ts",
      "documentation": "",
      "module": "wallet",
      "source": "mesh-common"
    },
    {
      "name": "AccountInfo",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/account-info\").AccountInfo",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/account-info.ts",
      "documentation": "",
      "module": "account-info",
      "source": "mesh-common"
    },
    {
      "name": "RedeemerTagType",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/action\").RedeemerTagType",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/action.ts",
      "documentation": "",
      "module": "action",
      "source": "mesh-common"
    },
    {
      "name": "Action",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/action\").Action",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/action.ts",
      "documentation": "",
      "module": "action",
      "source": "mesh-common"
    },
    {
      "name": "Budget",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/action\").Budget",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/action.ts",
      "documentation": "",
      "module": "action",
      "source": "mesh-common"
    },
    {
      "name": "AssetExtended",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset-extended\").AssetExtended",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/asset-extended.ts",
      "documentation": "",
      "module": "asset-extended",
      "source": "mesh-common"
    },
    {
      "name": "RoyaltiesStandard",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset-metadata\").RoyaltiesStandard",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/asset-metadata.ts",
      "documentation": "",
      "module": "asset-metadata",
      "source": "mesh-common"
    },
    {
      "name": "Files",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset-metadata\").Files",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/asset-metadata.ts",
      "documentation": "",
      "module": "asset-metadata",
      "source": "mesh-common"
    },
    {
      "name": "AssetMetadata",
      "definition": "any",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/asset-metadata.ts",
      "documentation": "",
      "module": "asset-metadata",
      "source": "mesh-common"
    },
    {
      "name": "FungibleAssetMetadata",
      "definition": "any",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/asset-metadata.ts",
      "documentation": "",
      "module": "asset-metadata",
      "source": "mesh-common"
    },
    {
      "name": "NonFungibleAssetMetadata",
      "definition": "any",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/asset-metadata.ts",
      "documentation": "",
      "module": "asset-metadata",
      "source": "mesh-common"
    },
    {
      "name": "ImageAssetMetadata",
      "definition": "any",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/asset-metadata.ts",
      "documentation": "",
      "module": "asset-metadata",
      "source": "mesh-common"
    },
    {
      "name": "Asset",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset\").Asset",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/asset.ts",
      "documentation": "",
      "module": "asset",
      "source": "mesh-common"
    },
    {
      "name": "Unit",
      "definition": "string",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/asset.ts",
      "documentation": "",
      "module": "asset",
      "source": "mesh-common"
    },
    {
      "name": "Quantity",
      "definition": "string",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/asset.ts",
      "documentation": "",
      "module": "asset",
      "source": "mesh-common"
    },
    {
      "name": "BlockInfo",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/block-info\").BlockInfo",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/block-info.ts",
      "documentation": "",
      "module": "block-info",
      "source": "mesh-common"
    },
    {
      "name": "DataSignature",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/data-signature\").DataSignature",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/data-signature.ts",
      "documentation": "",
      "module": "data-signature",
      "source": "mesh-common"
    },
    {
      "name": "Data",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/data\").Data",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/data.ts",
      "documentation": "",
      "module": "data",
      "source": "mesh-common"
    },
    {
      "name": "Era",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/era\").Era",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/era.ts",
      "documentation": "",
      "module": "era",
      "source": "mesh-common"
    },
    {
      "name": "Extension",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/extension\").Extension",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/extension.ts",
      "documentation": "",
      "module": "extension",
      "source": "mesh-common"
    },
    {
      "name": "GovernanceProposalInfo",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/governance\").GovernanceProposalInfo",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/governance.ts",
      "documentation": "",
      "module": "governance",
      "source": "mesh-common"
    },
    {
      "name": "Message",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/message\").Message",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/message.ts",
      "documentation": "",
      "module": "message",
      "source": "mesh-common"
    },
    {
      "name": "Mint",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/mint\").Mint",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/mint.ts",
      "documentation": "",
      "module": "mint",
      "source": "mesh-common"
    },
    {
      "name": "NativeScript",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/native-script\").NativeScript",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/native-script.ts",
      "documentation": "",
      "module": "native-script",
      "source": "mesh-common"
    },
    {
      "name": "Network",
      "definition": "\"mainnet\" | \"preview\" | \"preprod\" | \"testnet\"",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/network.ts",
      "documentation": "",
      "module": "network",
      "source": "mesh-common"
    },
    {
      "name": "PlutusScript",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/plutus-script\").PlutusScript",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/plutus-script.ts",
      "documentation": "",
      "module": "plutus-script",
      "source": "mesh-common"
    },
    {
      "name": "LanguageVersion",
      "definition": "\"V1\" | \"V2\" | \"V3\"",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/plutus-script.ts",
      "documentation": "",
      "module": "plutus-script",
      "source": "mesh-common"
    },
    {
      "name": "PoolParams",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/pool-params\").PoolParams",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/pool-params.ts",
      "documentation": "",
      "module": "pool-params",
      "source": "mesh-common"
    },
    {
      "name": "PoolMetadata",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/pool-params\").PoolMetadata",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/pool-params.ts",
      "documentation": "",
      "module": "pool-params",
      "source": "mesh-common"
    },
    {
      "name": "Protocol",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/protocol\").Protocol",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/protocol.ts",
      "documentation": "",
      "module": "protocol",
      "source": "mesh-common"
    },
    {
      "name": "Recipient",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/recipient\").Recipient",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/recipient.ts",
      "documentation": "",
      "module": "recipient",
      "source": "mesh-common"
    },
    {
      "name": "Relay",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/relay\").Relay",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/relay.ts",
      "documentation": "",
      "module": "relay",
      "source": "mesh-common"
    },
    {
      "name": "Token",
      "definition": "\"LQ\" | \"MIN\" | \"NTX\" | \"iBTC\" | \"iETH\" | \"iUSD\" | \"MILK\" | \"AGIX\" | \"MELD\" | \"INDY\" | \"CLAY\" | \"MCOS\" | \"DING\" | \"GERO\" | \"NMKR\" | \"PAVIA\" | \"HOSKY\" | \"YUMMI\" | \"C3\" | \"GIMBAL\" | \"SUNDAE\" | \"GREENS\" | \"GENS\" | \"SOCIETY\" | \"DJED\" | \"SHEN\" | \"WMT\" | \"COPI\"",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/token.ts",
      "documentation": "",
      "module": "token",
      "source": "mesh-common"
    },
    {
      "name": "TransactionInfo",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-info\").TransactionInfo",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-info.ts",
      "documentation": "",
      "module": "transaction-info",
      "source": "mesh-common"
    },
    {
      "name": "TxOutput",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/utxo\").TxOutput",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/utxo.ts",
      "documentation": "",
      "module": "utxo",
      "source": "mesh-common"
    },
    {
      "name": "TxInput",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/utxo\").TxInput",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/utxo.ts",
      "documentation": "",
      "module": "utxo",
      "source": "mesh-common"
    },
    {
      "name": "UTxO",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/utxo\").UTxO",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/utxo.ts",
      "documentation": "",
      "module": "utxo",
      "source": "mesh-common"
    },
    {
      "name": "Wallet",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/wallet\").Wallet",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/wallet.ts",
      "documentation": "",
      "module": "wallet",
      "source": "mesh-common"
    },
    {
      "name": "UtxoSelectionStrategy",
      "definition": "keyof import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/utxo-selection/index\").UtxoSelection",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/utxo-selection/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-common"
    },
    {
      "name": "InitiationDatum",
      "definition": "ConStr0<[PubKeyAddress, Value]>",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/escrow/offchain.ts",
      "documentation": "",
      "module": "offchain",
      "source": "mesh-contract"
    },
    {
      "name": "ActiveEscrowDatum",
      "definition": "ConStr1<[PubKeyAddress, Value, PubKeyAddress, Value]>",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/escrow/offchain.ts",
      "documentation": "",
      "module": "offchain",
      "source": "mesh-contract"
    },
    {
      "name": "RecipientDepositRedeemer",
      "definition": "ConStr0<[PubKeyAddress, Value]>",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/escrow/offchain.ts",
      "documentation": "",
      "module": "offchain",
      "source": "mesh-contract"
    },
    {
      "name": "HelloWorldDatum",
      "definition": "ConStr0<[Integer, BuiltinByteString, BuiltinByteString]>",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/hello-world/offchain.ts",
      "documentation": "",
      "module": "offchain",
      "source": "mesh-contract"
    },
    {
      "name": "MarketplaceDatum",
      "definition": "ConStr0<[PubKeyAddress, Integer, CurrencySymbol, TokenName]>",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/marketplace/offchain.ts",
      "documentation": "",
      "module": "offchain",
      "source": "mesh-contract"
    },
    {
      "name": "OracleDatum",
      "definition": "ConStr0<[Integer, Integer, PubKeyAddress]>",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/plutus-nft/type.ts",
      "documentation": "",
      "module": "type",
      "source": "mesh-contract"
    },
    {
      "name": "SwapDatum",
      "definition": "ConStr0<[PubKeyAddress, Value, Value]>",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/swap/offchain.ts",
      "documentation": "",
      "module": "offchain",
      "source": "mesh-contract"
    },
    {
      "name": "VestingDatum",
      "definition": "ConStr0<[Integer, BuiltinByteString, BuiltinByteString]>",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/vesting/offchain.ts",
      "documentation": "",
      "module": "offchain",
      "source": "mesh-contract"
    },
    {
      "name": "OutputEncoding",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/plutus-tools/index\").OutputEncoding",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/plutus-tools/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-core-cst"
    },
    {
      "name": "Slot",
      "definition": "Cardano.Slot",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Value",
      "definition": "Serialization.Value",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "TokenMap",
      "definition": "Cardano.TokenMap",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Transaction",
      "definition": "Serialization.Transaction",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "TransactionId",
      "definition": "Cardano.TransactionId",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "TransactionBody",
      "definition": "Serialization.TransactionBody",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "TransactionWitnessSet",
      "definition": "Serialization.TransactionWitnessSet",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "AuxiliaryData",
      "definition": "Serialization.AuxiliaryData",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "TransactionMetadatum",
      "definition": "Serialization.TransactionMetadatum",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "MetadatumMap",
      "definition": "Serialization.MetadatumMap",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "MetadatumList",
      "definition": "Serialization.MetadatumList",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "TransactionUnspentOutput",
      "definition": "Serialization.TransactionUnspentOutput",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "TransactionInput",
      "definition": "Serialization.TransactionInput",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "TransactionOutput",
      "definition": "Serialization.TransactionOutput",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "TransactionInputSet",
      "definition": "Serialization.CborSet<any, Serialization.TransactionInput>",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "TransactionWitnessPlutusData",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/types/cardano-sdk\").TransactionWitnessPlutusData",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "PlutusData",
      "definition": "Serialization.PlutusData",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "PlutusList",
      "definition": "Serialization.PlutusList",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "PlutusMap",
      "definition": "Serialization.PlutusMap",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Redeemers",
      "definition": "Serialization.Redeemers",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Redeemer",
      "definition": "Serialization.Redeemer",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "RedeemerPurpose",
      "definition": "Cardano.RedeemerPurpose",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "RedeemerTag",
      "definition": "Serialization.RedeemerTag",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Script",
      "definition": "Serialization.Script",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "PolicyId",
      "definition": "Cardano.PolicyId",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "AssetName",
      "definition": "Cardano.AssetName",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "AssetId",
      "definition": "Cardano.AssetId",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "ScriptHash",
      "definition": "Crypto.Hash28ByteBase16",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Address",
      "definition": "Cardano.Address",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "RewardAddress",
      "definition": "Cardano.RewardAddress",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "AddressType",
      "definition": "Cardano.AddressType",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "BaseAddress",
      "definition": "Cardano.BaseAddress",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "EnterpriseAddress",
      "definition": "Cardano.EnterpriseAddress",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "PaymentAddress",
      "definition": "Cardano.PaymentAddress",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "AssetFingerprint",
      "definition": "Cardano.AssetFingerprint",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Credential",
      "definition": "Serialization.Credential",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "CredentialCore",
      "definition": "Cardano.Credential",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Ed25519PublicKeyHex",
      "definition": "Crypto.Ed25519PublicKeyHex",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Ed25519PrivateNormalKeyHex",
      "definition": "OpaqueString<\"Ed25519PrivateKeyHex\">",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Ed25519PrivateExtendedKeyHex",
      "definition": "OpaqueString<\"Ed25519PrivateKeyHex\">",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Ed25519KeyHash",
      "definition": "Crypto.Ed25519KeyHash",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Ed25519KeyHashHex",
      "definition": "Crypto.Ed25519KeyHashHex",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Hash28ByteBase16",
      "definition": "Crypto.Hash28ByteBase16",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Hash32ByteBase16",
      "definition": "Crypto.Hash32ByteBase16",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "CredentialType",
      "definition": "Cardano.CredentialType",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Certificate",
      "definition": "Serialization.Certificate",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "PoolId",
      "definition": "Cardano.PoolId",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "StakeRegistration",
      "definition": "Serialization.StakeRegistration",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "StakeDelegation",
      "definition": "Serialization.StakeDelegation",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "StakeDelegationCertificate",
      "definition": "Cardano.StakeDelegationCertificate",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "CertificateType",
      "definition": "Cardano.CertificateType",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "VkeyWitness",
      "definition": "Serialization.VkeyWitness",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Ed25519SignatureHex",
      "definition": "Crypto.Ed25519SignatureHex",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Ed25519PublicKey",
      "definition": "Crypto.Ed25519PublicKey",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Ed25519Signature",
      "definition": "Crypto.Ed25519Signature",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Bip32PrivateKey",
      "definition": "Crypto.Bip32PrivateKey",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Bip32PrivateKeyHex",
      "definition": "Crypto.Bip32PrivateKeyHex",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Bip32PublicKey",
      "definition": "Crypto.Bip32PublicKey",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Bip32PublicKeyHex",
      "definition": "Crypto.Bip32PublicKeyHex",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "PlutusLanguageVersion",
      "definition": "Cardano.PlutusLanguageVersion",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "NativeScript",
      "definition": "Serialization.NativeScript",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "PlutusV1Script",
      "definition": "Serialization.PlutusV1Script",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "PlutusV2Script",
      "definition": "Serialization.PlutusV2Script",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "PlutusV3Script",
      "definition": "Serialization.PlutusV3Script",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "PlutusDataKind",
      "definition": "Serialization.PlutusDataKind",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "PointerAddress",
      "definition": "Cardano.PointerAddress",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "CertIndex",
      "definition": "Cardano.CertIndex",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "TxIndex",
      "definition": "Cardano.TxIndex",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Costmdls",
      "definition": "Serialization.Costmdls",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "CostModel",
      "definition": "Serialization.CostModel",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "CborWriter",
      "definition": "Serialization.CborWriter",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "ConstrPlutusData",
      "definition": "Serialization.ConstrPlutusData",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "RewardAccount",
      "definition": "Cardano.RewardAccount",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Hash",
      "definition": "Serialization.Hash<T>",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "DatumHash",
      "definition": "Crypto.Hash32ByteBase16",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Datum",
      "definition": "any",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "CostModels",
      "definition": "Cardano.CostModels",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "ExUnits",
      "definition": "Serialization.ExUnits",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "NetworkId",
      "definition": "Cardano.ChainId",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Witness",
      "definition": "Cardano.Witness",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Signatures",
      "definition": "Cardano.Signatures",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "RequireAllOf",
      "definition": "Cardano.NativeScriptKind.RequireAllOf",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "RequireAnyOf",
      "definition": "Cardano.NativeScriptKind.RequireAnyOf",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "RequireNOf",
      "definition": "Cardano.NativeScriptKind.RequireNOf",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "RequireSignature",
      "definition": "Cardano.NativeScriptKind.RequireSignature",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "RequireTimeAfter",
      "definition": "Cardano.NativeScriptKind.RequireTimeAfter",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "RequireTimeBefore",
      "definition": "Cardano.NativeScriptKind.RequireTimeBefore",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "VrfVkBech32",
      "definition": "Cardano.VrfVkBech32",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "ScriptPubkey",
      "definition": "Serialization.ScriptPubkey",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "DRepID",
      "definition": "Cardano.DRepID",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "DRep",
      "definition": "Serialization.DRep",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "StakeCredentialStatus",
      "definition": "Cardano.StakeCredentialStatus",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Metadatum",
      "definition": "Cardano.Metadatum",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "HexBlob",
      "definition": "CardanoHexBlob",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "TxCBOR",
      "definition": "Serialization.TxCBOR",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Ed25519PrivateKey",
      "definition": "Crypto.Ed25519PrivateKey",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "BootstrapWitness",
      "definition": "Serialization.BootstrapWitness",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "ByronAttributes",
      "definition": "Cardano.ByronAttributes",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/cardano-sdk.ts",
      "documentation": "",
      "module": "cardano-sdk",
      "source": "mesh-core-cst"
    },
    {
      "name": "Signer",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-core-cst/src/types/signer\").Signer",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/types/signer.ts",
      "documentation": "",
      "module": "signer",
      "source": "mesh-core-cst"
    },
    {
      "name": "Greetings",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").Greetings",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "PeerConnected",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").PeerConnected",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "PeerDisconnected",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").PeerDisconnected",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "PeerHandshakeFailure",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").PeerHandshakeFailure",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "HeadIsInitializing",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").HeadIsInitializing",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "Committed",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").Committed",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "HeadIsOpen",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").HeadIsOpen",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "HeadIsClosed",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").HeadIsClosed",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "HeadIsContested",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").HeadIsContested",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "ReadyToFanout",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").ReadyToFanout",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "HeadIsAborted",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").HeadIsAborted",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "HeadIsFinalized",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").HeadIsFinalized",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "TxValid",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").TxValid",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "TxInvalid",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").TxInvalid",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "SnapshotConfirmed",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").SnapshotConfirmed",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "GetUTxOResponse",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").GetUTxOResponse",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "InvalidInput",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").InvalidInput",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "PostTxOnChainFailed",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").PostTxOnChainFailed",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "CommandFailed",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").CommandFailed",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "IgnoredHeadInitializing",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").IgnoredHeadInitializing",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "DecommitInvalid",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").DecommitInvalid",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "DecommitRequested",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").DecommitRequested",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "DecommitApproved",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").DecommitApproved",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "DecommitFinalized",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/events\").DecommitFinalized",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/events.ts",
      "documentation": "",
      "module": "events",
      "source": "mesh-hydra"
    },
    {
      "name": "hAssets",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hAssets\").hAssets",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hAssets.ts",
      "documentation": "",
      "module": "hAssets",
      "source": "mesh-hydra"
    },
    {
      "name": "hReferenceScript",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hReferenceScript\").hReferenceScript",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hReferenceScript.ts",
      "documentation": "",
      "module": "hReferenceScript",
      "source": "mesh-hydra"
    },
    {
      "name": "hStatus",
      "definition": "\"IDLE\" | \"DISCONNECTED\" | \"CONNECTING\" | \"CONNECTED\" | \"INITIALIZING\" | \"OPEN\" | \"CLOSED\" | \"FANOUT_POSSIBLE\" | \"FINAL\"",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hStatus.ts",
      "documentation": "",
      "module": "hStatus",
      "source": "mesh-hydra"
    },
    {
      "name": "hTransaction",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hTransaction\").hTransaction",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hTransaction.ts",
      "documentation": "",
      "module": "hTransaction",
      "source": "mesh-hydra"
    },
    {
      "name": "hUTxOs",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hUTxOs\").hUTxOs",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hUTxOs.ts",
      "documentation": "",
      "module": "hUTxOs",
      "source": "mesh-hydra"
    },
    {
      "name": "hUTxO",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hUTxOs\").hUTxO",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hUTxOs.ts",
      "documentation": "",
      "module": "hUTxOs",
      "source": "mesh-hydra"
    },
    {
      "name": "PostChainTx",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx\").PostChainTx",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
      "documentation": "",
      "module": "hydra-post-chain-tx",
      "source": "mesh-hydra"
    },
    {
      "name": "InitTx",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx\").InitTx",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
      "documentation": "",
      "module": "hydra-post-chain-tx",
      "source": "mesh-hydra"
    },
    {
      "name": "AbortTx",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx\").AbortTx",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
      "documentation": "",
      "module": "hydra-post-chain-tx",
      "source": "mesh-hydra"
    },
    {
      "name": "CollectComTx",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx\").CollectComTx",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
      "documentation": "",
      "module": "hydra-post-chain-tx",
      "source": "mesh-hydra"
    },
    {
      "name": "InitialSnapshot",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx\").InitialSnapshot",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
      "documentation": "",
      "module": "hydra-post-chain-tx",
      "source": "mesh-hydra"
    },
    {
      "name": "ConfirmedSnapshot",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx\").ConfirmedSnapshot",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
      "documentation": "",
      "module": "hydra-post-chain-tx",
      "source": "mesh-hydra"
    },
    {
      "name": "DecrementTx",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx\").DecrementTx",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
      "documentation": "",
      "module": "hydra-post-chain-tx",
      "source": "mesh-hydra"
    },
    {
      "name": "CloseTx",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx\").CloseTx",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
      "documentation": "",
      "module": "hydra-post-chain-tx",
      "source": "mesh-hydra"
    },
    {
      "name": "ContestTx",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx\").ContestTx",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
      "documentation": "",
      "module": "hydra-post-chain-tx",
      "source": "mesh-hydra"
    },
    {
      "name": "FanoutTx",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra-post-chain-tx\").FanoutTx",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hydra-post-chain-tx.ts",
      "documentation": "",
      "module": "hydra-post-chain-tx",
      "source": "mesh-hydra"
    },
    {
      "name": "HydraCommitTransaction",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra\").HydraCommitTransaction",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hydra.ts",
      "documentation": "",
      "module": "hydra",
      "source": "mesh-hydra"
    },
    {
      "name": "HydraParty",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra\").HydraParty",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hydra.ts",
      "documentation": "",
      "module": "hydra",
      "source": "mesh-hydra"
    },
    {
      "name": "HydraSnapshot",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/types/hydra\").HydraSnapshot",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hydra.ts",
      "documentation": "",
      "module": "hydra",
      "source": "mesh-hydra"
    },
    {
      "name": "HydraHeadParameters",
      "definition": "export interface HydraHeadParameters {\n  contestationPeriod: number;\n  parties: HydraParty[];\n}",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/types/hydra.ts",
      "documentation": "",
      "module": "hydra",
      "source": "mesh-hydra"
    },
    {
      "name": "BlockfrostUTxO",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/blockfrost\").BlockfrostUTxO",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/types/blockfrost.ts",
      "documentation": "",
      "module": "blockfrost",
      "source": "mesh-provider"
    },
    {
      "name": "BlockfrostAsset",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/blockfrost\").BlockfrostAsset",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/types/blockfrost.ts",
      "documentation": "",
      "module": "blockfrost",
      "source": "mesh-provider"
    },
    {
      "name": "KoiosUTxO",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/koios\").KoiosUTxO",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/types/koios.ts",
      "documentation": "",
      "module": "koios",
      "source": "mesh-provider"
    },
    {
      "name": "KoiosAsset",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/koios\").KoiosAsset",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/types/koios.ts",
      "documentation": "",
      "module": "koios",
      "source": "mesh-provider"
    },
    {
      "name": "KoiosValue",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/koios\").KoiosValue",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/types/koios.ts",
      "documentation": "",
      "module": "koios",
      "source": "mesh-provider"
    },
    {
      "name": "KoiosReferenceScript",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/koios\").KoiosReferenceScript",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/types/koios.ts",
      "documentation": "",
      "module": "koios",
      "source": "mesh-provider"
    },
    {
      "name": "MaestroUTxO",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/maestro\").MaestroUTxO",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/types/maestro.ts",
      "documentation": "",
      "module": "maestro",
      "source": "mesh-provider"
    },
    {
      "name": "MaestroAssetExtended",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/maestro\").MaestroAssetExtended",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/types/maestro.ts",
      "documentation": "",
      "module": "maestro",
      "source": "mesh-provider"
    },
    {
      "name": "ButtonProps",
      "definition": "export interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  asChild?: boolean\n}",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/common/button.tsx",
      "documentation": "",
      "module": "button",
      "source": "mesh-react"
    },
    {
      "name": "InputProps",
      "definition": "export interface InputProps\n  extends React.InputHTMLAttributes<HTMLInputElement> {}",
      "isExported": true,
      "importPath": "offchain/mesh-react/src/common/input.tsx",
      "documentation": "",
      "module": "input",
      "source": "mesh-react"
    },
    {
      "name": "MeshTxBuilderOptions",
      "definition": "export interface MeshTxBuilderOptions {\n  fetcher?: IFetcher;\n  submitter?: ISubmitter;\n  evaluator?: IEvaluator;\n  serializer?: IMeshTxSerializer;\n  isHydra?: boolean;\n  params?: Partial<Protocol>;\n  verbose?: boolean;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-transaction"
    },
    {
      "name": "TransactionOptions",
      "definition": "export interface TransactionOptions extends MeshTxBuilderOptions {\n  initiator: IInitiator;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/transaction/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-transaction"
    },
    {
      "name": "TransactionV2",
      "definition": "export interface TransactionV2 {\n  sendAssets(\n    receiver: string,\n    assets: Asset[],\n    datum?: Data,\n    inlineScript?: string,\n    isInline?: boolean,\n  ): this;\n  sendLovelace(recipient: Recipient, lovelace: string): this;\n  sendToken(recipient: Recipient, ticker: Token, amount: string): this;\n  sendValue(recipient: Recipient, value: UTxO): this;\n  setTxInputs(inputs: UTxO[]): this;\n  setTxRefInputs(inputs: UTxO[]): this;\n  setNativeScriptInput(script: NativeScript, utxo: UTxO): this;\n  redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): this;\n  mintAsset(\n    forgeScript: string | PlutusScript | UTxO,\n    mint: Mint,\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget },\n  ): this;\n  burnAsset(\n    forgeScript: string | PlutusScript | UTxO,\n    asset: Asset,\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget },\n  ): this;\n  setChangeAddress(changeAddress: string): this;\n  setCollateral(collateral: UTxO[]): this;\n  setRequiredSigners(addresses: string[]): this;\n  setTimeToExpire(slot: string): this;\n  setTimeToStart(slot: string): this;\n  setMetadata(\n    label: number,\n    metadata: unknown\n  ): this;\n  withdrawRewards(rewardAddress: string, lovelace: string): this;\n  delegateStake(rewardAddress: string, poolId: string): this;\n  deregisterStake(rewardAddress: string): this;\n  registerStake(rewardAddress: string): this;\n  registerPool(params: PoolParams): this;\n  retirePool(poolId: string, epochNo: number): this;\n  spendUtxo(utxo: UTxO, redeemer?: Data): this;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/transaction/transaction-v2.ts",
      "documentation": "",
      "module": "transaction-v2",
      "source": "mesh-transaction"
    },
    {
      "name": "MetadataMergeLevel",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/utils/metadata\").MetadataMergeLevel",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/utils/metadata.ts",
      "documentation": "",
      "module": "metadata",
      "source": "mesh-transaction"
    },
    {
      "name": "AppWalletKeyType",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/app/index\").AppWalletKeyType",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/app/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-wallet"
    },
    {
      "name": "CreateAppWalletOptions",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/app/index\").CreateAppWalletOptions",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/app/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-wallet"
    },
    {
      "name": "AccountType",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/embedded/index\").AccountType",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/embedded/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-wallet"
    },
    {
      "name": "Account",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/embedded/index\").Account",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/embedded/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-wallet"
    },
    {
      "name": "EmbeddedWalletKeyType",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/embedded/index\").EmbeddedWalletKeyType",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/embedded/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-wallet"
    },
    {
      "name": "CreateEmbeddedWalletOptions",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/embedded/index\").CreateEmbeddedWalletOptions",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/embedded/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-wallet"
    },
    {
      "name": "CreateMeshWalletOptions",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/mesh/index\").CreateMeshWalletOptions",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/mesh/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-wallet"
    },
    {
      "name": "Cardano",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/types/index\").Cardano",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/types/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-wallet"
    },
    {
      "name": "WalletInstance",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/types/index\").WalletInstance",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/types/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-wallet"
    },
    {
      "name": "GetAddressType",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/types/index\").GetAddressType",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/types/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-wallet"
    },
    {
      "name": "Cip30WalletApi",
      "definition": "export interface Cip30WalletApi {\n  experimental: ExperimentalFeatures;\n  getBalance(): Promise<string>;\n  getChangeAddress(): Promise<string>;\n  getExtensions(): Promise<{ cip: number }[]>;\n  getCollateral(): Promise<string[] | undefined>;\n  getNetworkId(): Promise<number>;\n  getRewardAddresses(): Promise<string[]>;\n  getUnusedAddresses(): Promise<string[]>;\n  getUsedAddresses(): Promise<string[]>;\n  getUtxos(): Promise<string[] | undefined>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n  signTx(tx: string, partialSign: boolean): Promise<string>;\n  signTxs?(txs: TransactionSignatureRequest[]): Promise<string[]>; // Overloading interface as currently no standard\n  signTxs?(txs: string[], partialSign: boolean): Promise<string[]>; // Overloading interface as currently no standard\n  submitTx(tx: string): Promise<string>;\n  cip95?: Cip95WalletApi;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/types/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-wallet"
    },
    {
      "name": "Cip95WalletApi",
      "definition": "export interface Cip95WalletApi {\n  getRegisteredPubStakeKeys: () => Promise<Ed25519PublicKeyHex[]>;\n  getUnregisteredPubStakeKeys: () => Promise<Ed25519PublicKeyHex[]>;\n  getPubDRepKey: () => Promise<Ed25519PublicKeyHex>;\n  signData(address: string, payload: string): Promise<DataSignature>;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/types/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-wallet"
    },
    {
      "name": "CreateWalletOptions",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/wallets/embedded/index\").CreateWalletOptions",
      "isExported": true,
      "importPath": "offchain/bitcoin/src/wallets/embedded/index.ts",
      "documentation": "",
      "module": "index",
      "source": "bitcoin"
    },
    {
      "name": "TransactionPayload",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/wallets/embedded/index\").TransactionPayload",
      "isExported": true,
      "importPath": "offchain/bitcoin/src/wallets/embedded/index.ts",
      "documentation": "",
      "module": "index",
      "source": "bitcoin"
    },
    {
      "name": "ScriptHash",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").ByteString",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
      "documentation": "The Plutus Data script hash in JSON",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "PubKeyHash",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").ByteString",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
      "documentation": "The Plutus Data public key hash in JSON",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "PolicyId",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").ByteString",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
      "documentation": "Aiken alias\nThe Plutus Data policy id in JSON",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "CurrencySymbol",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").ByteString",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
      "documentation": "PlutusTx alias\nThe Plutus Data currency symbol in JSON",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "AssetName",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").ByteString",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
      "documentation": "Aiken alias\nThe Plutus Data asset name in JSON",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "TokenName",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").ByteString",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
      "documentation": "PlutusTx alias\nThe Plutus Data token name in JSON",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "AssetClass",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/aliases\").AssetClass",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
      "documentation": "PlutusTx alias\nThe Plutus Data asset class in JSON",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "OutputReference",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/aliases\").OutputReference",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
      "documentation": "Aiken alias\nThe Plutus Data output reference in JSON",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "TxOutRef",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/aliases\").TxOutRef",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
      "documentation": "PlutusTx alias\nThe Plutus Data TxOutRef in JSON",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "POSIXTime",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").Integer",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
      "documentation": "PlutusTx alias\nThe Plutus Data POSIX time in JSON",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "DictItem",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/aliases\").DictItem<V>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
      "documentation": "Aiken alias\nThe Plutus Data dictionary item in JSON",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "Dict",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/aliases\").Dict<V>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
      "documentation": "Aiken alias\nThe Plutus Data dictionary in JSON",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "Tuple",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/aliases\").Tuple<T>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
      "documentation": "Aiken alias\nThe Plutus Data tuple in JSON",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "Option",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/aliases\").Option<T>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
      "documentation": "Aiken alias\nThe Plutus Data Option in JSON",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "Some",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/aliases\").Some<T>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
      "documentation": "Aiken alias\nThe Plutus Data Option - Some in JSON",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "None",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/aliases\").None",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/aliases.ts",
      "documentation": "Aiken alias\nThe Plutus Data Option - None in JSON",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "ConStr",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/constructors\").ConStr<N, T>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/constructors.ts",
      "documentation": "The Plutus Data constructor object, representing custom data type in JSON",
      "module": "constructors",
      "source": "mesh-common"
    },
    {
      "name": "ConStr0",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/constructors\").ConStr0<T>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/constructors.ts",
      "documentation": "The Plutus Data index 0 constructor object, representing custom data type in JSON",
      "module": "constructors",
      "source": "mesh-common"
    },
    {
      "name": "ConStr1",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/constructors\").ConStr1<T>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/constructors.ts",
      "documentation": "The Plutus Data index 1 constructor object, representing custom data type in JSON",
      "module": "constructors",
      "source": "mesh-common"
    },
    {
      "name": "ConStr2",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/constructors\").ConStr2<T>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/constructors.ts",
      "documentation": "The Plutus Data index 2 constructor object, representing custom data type in JSON",
      "module": "constructors",
      "source": "mesh-common"
    },
    {
      "name": "ConStr3",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/constructors\").ConStr3<T>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/constructors.ts",
      "documentation": "The Plutus Data index 3 constructor object, representing custom data type in JSON",
      "module": "constructors",
      "source": "mesh-common"
    },
    {
      "name": "VerificationKey",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/credentials\").VerificationKey",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/credentials.ts",
      "documentation": "The Plutus Data verification key in JSON",
      "module": "credentials",
      "source": "mesh-common"
    },
    {
      "name": "Script",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/credentials\").Script",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/credentials.ts",
      "documentation": "The Plutus Data Script key in JSON",
      "module": "credentials",
      "source": "mesh-common"
    },
    {
      "name": "MaybeStakingHash",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/credentials\").MaybeStakingHash",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/credentials.ts",
      "documentation": "The Plutus Data staking credential in JSON",
      "module": "credentials",
      "source": "mesh-common"
    },
    {
      "name": "PubKeyAddress",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/credentials\").PubKeyAddress",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/credentials.ts",
      "documentation": "The Plutus Data public key address in JSON",
      "module": "credentials",
      "source": "mesh-common"
    },
    {
      "name": "ScriptAddress",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/credentials\").ScriptAddress",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/credentials.ts",
      "documentation": "The Plutus Data script address in JSON",
      "module": "credentials",
      "source": "mesh-common"
    },
    {
      "name": "Credential",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/credentials\").Credential",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/credentials.ts",
      "documentation": "The Plutus Data credential in JSON",
      "module": "credentials",
      "source": "mesh-common"
    },
    {
      "name": "PlutusData",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/index\").PlutusData",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-common"
    },
    {
      "name": "ProofStep",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/mpf\").ProofStep",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/mpf.ts",
      "documentation": "",
      "module": "mpf",
      "source": "mesh-common"
    },
    {
      "name": "ProofStepBranch",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/mpf\").ProofStepBranch",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/mpf.ts",
      "documentation": "",
      "module": "mpf",
      "source": "mesh-common"
    },
    {
      "name": "ProofStepFork",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/mpf\").ProofStepFork",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/mpf.ts",
      "documentation": "",
      "module": "mpf",
      "source": "mesh-common"
    },
    {
      "name": "ProofStepLeaf",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/mpf\").ProofStepLeaf",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/mpf.ts",
      "documentation": "",
      "module": "mpf",
      "source": "mesh-common"
    },
    {
      "name": "ForkNeighbor",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/mpf\").ForkNeighbor",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/mpf.ts",
      "documentation": "",
      "module": "mpf",
      "source": "mesh-common"
    },
    {
      "name": "Bool",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").Bool",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/primitives.ts",
      "documentation": "The Plutus Data boolean in JSON",
      "module": "primitives",
      "source": "mesh-common"
    },
    {
      "name": "BuiltinByteString",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").BuiltinByteString",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/primitives.ts",
      "documentation": "The Plutus Data byte string, representing in hex, in JSON",
      "module": "primitives",
      "source": "mesh-common"
    },
    {
      "name": "ByteString",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").ByteString",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/primitives.ts",
      "documentation": "The Plutus Data byte string, representing in hex, in JSON",
      "module": "primitives",
      "source": "mesh-common"
    },
    {
      "name": "Integer",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").Integer",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/primitives.ts",
      "documentation": "The Plutus Data integer in JSON",
      "module": "primitives",
      "source": "mesh-common"
    },
    {
      "name": "List",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").List<T>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/primitives.ts",
      "documentation": "The Plutus Data list in JSON",
      "module": "primitives",
      "source": "mesh-common"
    },
    {
      "name": "AssocMapItem",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").AssocMapItem<K, V>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/primitives.ts",
      "documentation": "PlutusTx alias\nThe Plutus Data association map item in JSON",
      "module": "primitives",
      "source": "mesh-common"
    },
    {
      "name": "AssocMap",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").AssocMap<K, V>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/primitives.ts",
      "documentation": "PlutusTx alias\nThe Plutus Data association map in JSON",
      "module": "primitives",
      "source": "mesh-common"
    },
    {
      "name": "Pair",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").Pair<K, V>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/primitives.ts",
      "documentation": "Aiken alias\nThe Plutus Data association map item in JSON",
      "module": "primitives",
      "source": "mesh-common"
    },
    {
      "name": "Pairs",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/json/primitives\").Pairs<K, V>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/json/primitives.ts",
      "documentation": "Aiken alias\nThe Plutus Data association map in JSON",
      "module": "primitives",
      "source": "mesh-common"
    },
    {
      "name": "MAssetClass",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/aliases\").MAssetClass",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/mesh/aliases.ts",
      "documentation": "PlutusTx alias\nThe Mesh Data asset class",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "MOutputReference",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/aliases\").MOutputReference",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/mesh/aliases.ts",
      "documentation": "Aiken alias\nThe Mesh Data output reference",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "MTxOutRef",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/aliases\").MTxOutRef",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/mesh/aliases.ts",
      "documentation": "PlutusTx alias\nThe Mesh Data TxOutRef",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "MTuple",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/aliases\").MTuple<T>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/mesh/aliases.ts",
      "documentation": "Aiken alias\nThe Mesh Data tuple",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "MOption",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/aliases\").MOption<T>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/mesh/aliases.ts",
      "documentation": "Aiken alias\nThe Mesh Data Option type",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "MSome",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/aliases\").MSome<T>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/mesh/aliases.ts",
      "documentation": "Aiken alias\nThe Mesh Data Option - Some type",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "MNone",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/aliases\").MNone",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/mesh/aliases.ts",
      "documentation": "Aiken alias\nThe Mesh Data Option - None type",
      "module": "aliases",
      "source": "mesh-common"
    },
    {
      "name": "MConStr",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/constructors\").MConStr<N, T>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/mesh/constructors.ts",
      "documentation": "The Mesh Data constructor object, representing custom data type",
      "module": "constructors",
      "source": "mesh-common"
    },
    {
      "name": "MConStr0",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/constructors\").MConStr0<T>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/mesh/constructors.ts",
      "documentation": "The Mesh Data index 0 constructor object, representing custom data type",
      "module": "constructors",
      "source": "mesh-common"
    },
    {
      "name": "MConStr1",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/constructors\").MConStr1<T>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/mesh/constructors.ts",
      "documentation": "The Mesh Data index 1 constructor object, representing custom data type",
      "module": "constructors",
      "source": "mesh-common"
    },
    {
      "name": "MConStr2",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/constructors\").MConStr2<T>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/mesh/constructors.ts",
      "documentation": "The Mesh Data index 2 constructor object, representing custom data type",
      "module": "constructors",
      "source": "mesh-common"
    },
    {
      "name": "MConStr3",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/constructors\").MConStr3<T>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/mesh/constructors.ts",
      "documentation": "The Mesh Data index 3 constructor object, representing custom data type",
      "module": "constructors",
      "source": "mesh-common"
    },
    {
      "name": "MVerificationKey",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/credentials\").MVerificationKey",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/mesh/credentials.ts",
      "documentation": "The Mesh Data verification key",
      "module": "credentials",
      "source": "mesh-common"
    },
    {
      "name": "MScript",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/credentials\").MScript",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/mesh/credentials.ts",
      "documentation": "The Mesh Data script key",
      "module": "credentials",
      "source": "mesh-common"
    },
    {
      "name": "MMaybeStakingHash",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/credentials\").MMaybeStakingHash",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/mesh/credentials.ts",
      "documentation": "The Mesh Data staking credential",
      "module": "credentials",
      "source": "mesh-common"
    },
    {
      "name": "MPubKeyAddress",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/credentials\").MPubKeyAddress",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/mesh/credentials.ts",
      "documentation": "The Mesh Data public key address",
      "module": "credentials",
      "source": "mesh-common"
    },
    {
      "name": "MScriptAddress",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/credentials\").MScriptAddress",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/mesh/credentials.ts",
      "documentation": "The Mesh Data script address",
      "module": "credentials",
      "source": "mesh-common"
    },
    {
      "name": "MCredential",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/credentials\").MCredential",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/mesh/credentials.ts",
      "documentation": "The Mesh Data credential",
      "module": "credentials",
      "source": "mesh-common"
    },
    {
      "name": "MBool",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/mesh/primitives\").MBool",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/mesh/primitives.ts",
      "documentation": "The Mesh Data boolean",
      "module": "primitives",
      "source": "mesh-common"
    },
    {
      "name": "IMintingBlueprint",
      "definition": "export interface IMintingBlueprint {\n  version: LanguageVersion;\n  cbor: string;\n  hash: string;\n  paramScript(\n    compiledCode: string,\n    params: string[],\n    paramsType: PlutusDataType,\n  ): this;\n  noParamScript(compiledCode: string): this;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/blueprint/minting.ts",
      "documentation": "",
      "module": "minting",
      "source": "mesh-common"
    },
    {
      "name": "ISpendingBlueprint",
      "definition": "export interface ISpendingBlueprint {\n  version: LanguageVersion;\n  networkId: number;\n  cbor: string;\n  hash: string;\n  address: string;\n  stakeHash?: string;\n  isStakeScriptCredential: boolean;\n  paramScript(\n    compiledCode: string,\n    params: string[],\n    paramsType: PlutusDataType,\n  ): this;\n  noParamScript(compiledCode: string): this;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/blueprint/spending.ts",
      "documentation": "",
      "module": "spending",
      "source": "mesh-common"
    },
    {
      "name": "IWithdrawalBlueprint",
      "definition": "export interface IWithdrawalBlueprint {\n  version: LanguageVersion;\n  networkId: number;\n  cbor: string;\n  hash: string;\n  address: string;\n  paramScript(\n    compiledCode: string,\n    params: string[],\n    paramsType: PlutusDataType,\n  ): this;\n  noParamScript(compiledCode: string): this;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/blueprint/withdrawal.ts",
      "documentation": "",
      "module": "withdrawal",
      "source": "mesh-common"
    },
    {
      "name": "DeserializedAddress",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/deserialized/deserialized-address\").DeserializedAddress",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/deserialized/deserialized-address.ts",
      "documentation": "",
      "module": "deserialized-address",
      "source": "mesh-common"
    },
    {
      "name": "DeserializedScript",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/deserialized/deserialized-script\").DeserializedScript",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/deserialized/deserialized-script.ts",
      "documentation": "",
      "module": "deserialized-script",
      "source": "mesh-common"
    },
    {
      "name": "Certificate",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/certificate\").Certificate",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/certificate.ts",
      "documentation": "",
      "module": "certificate",
      "source": "mesh-common"
    },
    {
      "name": "CertificateType",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/certificate\").CertificateType",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/certificate.ts",
      "documentation": "",
      "module": "certificate",
      "source": "mesh-common"
    },
    {
      "name": "DRep",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/certificate\").DRep",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/certificate.ts",
      "documentation": "",
      "module": "certificate",
      "source": "mesh-common"
    },
    {
      "name": "Anchor",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/certificate\").Anchor",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/certificate.ts",
      "documentation": "",
      "module": "certificate",
      "source": "mesh-common"
    },
    {
      "name": "Credential",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/credential\").Credential",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/credential.ts",
      "documentation": "",
      "module": "credential",
      "source": "mesh-common"
    },
    {
      "name": "BuilderData",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/data\").BuilderData",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/data.ts",
      "documentation": "",
      "module": "data",
      "source": "mesh-common"
    },
    {
      "name": "Redeemer",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/data\").Redeemer",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/data.ts",
      "documentation": "",
      "module": "data",
      "source": "mesh-common"
    },
    {
      "name": "DatumSource",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/data\").DatumSource",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/data.ts",
      "documentation": "",
      "module": "data",
      "source": "mesh-common"
    },
    {
      "name": "MeshTxBuilderBody",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/index\").MeshTxBuilderBody",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-common"
    },
    {
      "name": "ValidityRange",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/index\").ValidityRange",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-common"
    },
    {
      "name": "MetadatumMap",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/index\").MetadatumMap",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-common"
    },
    {
      "name": "Metadatum",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/index\").Metadatum",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-common"
    },
    {
      "name": "TxMetadata",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/index\").TxMetadata",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-common"
    },
    {
      "name": "Metadata",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/index\").Metadata",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-common"
    },
    {
      "name": "RequiredWith",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/index\").RequiredWith<T, K>",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/index.ts",
      "documentation": "",
      "module": "index",
      "source": "mesh-common"
    },
    {
      "name": "MintParam",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/mint\").MintParam",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/mint.ts",
      "documentation": "",
      "module": "mint",
      "source": "mesh-common"
    },
    {
      "name": "MintItem",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/mint\").MintItem",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/mint.ts",
      "documentation": "",
      "module": "mint",
      "source": "mesh-common"
    },
    {
      "name": "Output",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/output\").Output",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/output.ts",
      "documentation": "",
      "module": "output",
      "source": "mesh-common"
    },
    {
      "name": "ScriptSource",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/script\").ScriptSource",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/script.ts",
      "documentation": "",
      "module": "script",
      "source": "mesh-common"
    },
    {
      "name": "SimpleScriptSourceInfo",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/script\").SimpleScriptSourceInfo",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/script.ts",
      "documentation": "",
      "module": "script",
      "source": "mesh-common"
    },
    {
      "name": "RefTxIn",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/txin\").RefTxIn",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/txin.ts",
      "documentation": "",
      "module": "txin",
      "source": "mesh-common"
    },
    {
      "name": "TxInParameter",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/txin\").TxInParameter",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/txin.ts",
      "documentation": "",
      "module": "txin",
      "source": "mesh-common"
    },
    {
      "name": "TxIn",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/txin\").TxIn",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/txin.ts",
      "documentation": "",
      "module": "txin",
      "source": "mesh-common"
    },
    {
      "name": "PubKeyTxIn",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/txin\").PubKeyTxIn",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/txin.ts",
      "documentation": "",
      "module": "txin",
      "source": "mesh-common"
    },
    {
      "name": "SimpleScriptTxIn",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/txin\").SimpleScriptTxIn",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/txin.ts",
      "documentation": "",
      "module": "txin",
      "source": "mesh-common"
    },
    {
      "name": "SimpleScriptTxInParameter",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/txin\").SimpleScriptTxInParameter",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/txin.ts",
      "documentation": "",
      "module": "txin",
      "source": "mesh-common"
    },
    {
      "name": "ScriptTxInParameter",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/txin\").ScriptTxInParameter",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/txin.ts",
      "documentation": "",
      "module": "txin",
      "source": "mesh-common"
    },
    {
      "name": "ScriptTxIn",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/txin\").ScriptTxIn",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/txin.ts",
      "documentation": "",
      "module": "txin",
      "source": "mesh-common"
    },
    {
      "name": "Vote",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/vote\").Vote",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/vote.ts",
      "documentation": "",
      "module": "vote",
      "source": "mesh-common"
    },
    {
      "name": "BasicVote",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/vote\").BasicVote",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/vote.ts",
      "documentation": "",
      "module": "vote",
      "source": "mesh-common"
    },
    {
      "name": "SimpleScriptVote",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/vote\").SimpleScriptVote",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/vote.ts",
      "documentation": "",
      "module": "vote",
      "source": "mesh-common"
    },
    {
      "name": "ScriptVote",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/vote\").ScriptVote",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/vote.ts",
      "documentation": "",
      "module": "vote",
      "source": "mesh-common"
    },
    {
      "name": "VoteType",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/vote\").VoteType",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/vote.ts",
      "documentation": "",
      "module": "vote",
      "source": "mesh-common"
    },
    {
      "name": "Voter",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/vote\").Voter",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/vote.ts",
      "documentation": "",
      "module": "vote",
      "source": "mesh-common"
    },
    {
      "name": "VotingProcedure",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/vote\").VotingProcedure",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/vote.ts",
      "documentation": "",
      "module": "vote",
      "source": "mesh-common"
    },
    {
      "name": "VoteKind",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/vote\").VoteKind",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/vote.ts",
      "documentation": "",
      "module": "vote",
      "source": "mesh-common"
    },
    {
      "name": "Withdrawal",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/withdrawal\").Withdrawal",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/withdrawal.ts",
      "documentation": "",
      "module": "withdrawal",
      "source": "mesh-common"
    },
    {
      "name": "PubKeyWithdrawal",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/withdrawal\").PubKeyWithdrawal",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/withdrawal.ts",
      "documentation": "",
      "module": "withdrawal",
      "source": "mesh-common"
    },
    {
      "name": "ScriptWithdrawal",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/withdrawal\").ScriptWithdrawal",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/withdrawal.ts",
      "documentation": "",
      "module": "withdrawal",
      "source": "mesh-common"
    },
    {
      "name": "SimpleScriptWithdrawal",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/withdrawal\").SimpleScriptWithdrawal",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/types/transaction-builder/withdrawal.ts",
      "documentation": "",
      "module": "withdrawal",
      "source": "mesh-common"
    },
    {
      "name": "InputUTxO",
      "definition": "UTxO",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/content-ownership/offchain/common.ts",
      "documentation": "",
      "module": "common",
      "source": "mesh-contract"
    },
    {
      "name": "ScriptIndex",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/content-ownership/offchain/common\").ScriptIndex",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/content-ownership/offchain/common.ts",
      "documentation": "",
      "module": "common",
      "source": "mesh-contract"
    },
    {
      "name": "OracleDatum",
      "definition": "ConStr0<[BuiltinByteString, ScriptAddress, BuiltinByteString, ScriptAddress, Integer, BuiltinByteString, ScriptAddress, Integer, BuiltinByteString, BuiltinByteString]>",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/content-ownership/offchain/type.ts",
      "documentation": "",
      "module": "type",
      "source": "mesh-contract"
    },
    {
      "name": "ContentRegistryDatum",
      "definition": "ConStr0<[Integer, List<BuiltinByteString>]>",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/content-ownership/offchain/type.ts",
      "documentation": "",
      "module": "type",
      "source": "mesh-contract"
    },
    {
      "name": "OwnershipRegistryDatum",
      "definition": "ConStr0<[Integer, List<{ list: [BuiltinByteString, BuiltinByteString]; }>]>",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/content-ownership/offchain/type.ts",
      "documentation": "",
      "module": "type",
      "source": "mesh-contract"
    },
    {
      "name": "UpdateContent",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/content-ownership/offchain/type\").UpdateContent",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/content-ownership/offchain/type.ts",
      "documentation": "",
      "module": "type",
      "source": "mesh-contract"
    },
    {
      "name": "TransferContent",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/content-ownership/offchain/type\").TransferContent",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/content-ownership/offchain/type.ts",
      "documentation": "",
      "module": "type",
      "source": "mesh-contract"
    },
    {
      "name": "CardanoWalletButtonProps",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-svelte/src/lib/common/types\").CardanoWalletButtonProps",
      "isExported": true,
      "importPath": "offchain/mesh-svelte/src/lib/common/types.ts",
      "documentation": "",
      "module": "types",
      "source": "mesh-svelte"
    },
    {
      "name": "EstimateTxCosts",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface\").EstimateTxCosts",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface.ts",
      "documentation": "",
      "module": "coin-selection-interface",
      "source": "mesh-transaction"
    },
    {
      "name": "TokenBundleSizeExceedsLimit",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface\").TokenBundleSizeExceedsLimit",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface.ts",
      "documentation": "",
      "module": "coin-selection-interface",
      "source": "mesh-transaction"
    },
    {
      "name": "ComputeMinimumCoinQuantity",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface\").ComputeMinimumCoinQuantity",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface.ts",
      "documentation": "",
      "module": "coin-selection-interface",
      "source": "mesh-transaction"
    },
    {
      "name": "MaxSizeExceed",
      "definition": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface\").MaxSizeExceed",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface.ts",
      "documentation": "",
      "module": "coin-selection-interface",
      "source": "mesh-transaction"
    },
    {
      "name": "TransactionPrototype",
      "definition": "export interface TransactionPrototype {\n  newInputs: Set<UTxO>;\n  newOutputs: Set<TxOutput>;\n  change: Array<TxOutput>;\n  fee: bigint;\n  redeemers?: Array<Omit<Action, 'data'>>;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface.ts",
      "documentation": "",
      "module": "coin-selection-interface",
      "source": "mesh-transaction"
    },
    {
      "name": "ImplicitValue",
      "definition": "export interface ImplicitValue {\n  withdrawals: bigint;\n  deposit: bigint;\n  reclaimDeposit: bigint;\n  mint: Asset[];\n}",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface.ts",
      "documentation": "",
      "module": "coin-selection-interface",
      "source": "mesh-transaction"
    },
    {
      "name": "TransactionCost",
      "definition": "export interface TransactionCost {\n  fee: bigint;\n  redeemers?: Array<Omit<Action, 'data'>>;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface.ts",
      "documentation": "",
      "module": "coin-selection-interface",
      "source": "mesh-transaction"
    },
    {
      "name": "BuilderCallbacks",
      "definition": "export interface BuilderCallbacks {\n  computeMinimumCost: EstimateTxCosts;\n  tokenBundleSizeExceedsLimit: TokenBundleSizeExceedsLimit;\n  computeMinimumCoinQuantity: ComputeMinimumCoinQuantity;\n  maxSizeExceed: MaxSizeExceed;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface.ts",
      "documentation": "",
      "module": "coin-selection-interface",
      "source": "mesh-transaction"
    },
    {
      "name": "IInputSelector",
      "definition": "export interface IInputSelector {\n  select: (\n    preselectedUtoxs: TxIn[],\n    outputs: Output[],\n    implicitValue: ImplicitValue,\n    utxos: UTxO[],\n    changeAddress: string,\n  ) => Promise<TransactionPrototype>;\n}",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface.ts",
      "documentation": "",
      "module": "coin-selection-interface",
      "source": "mesh-transaction"
    }
  ],
  "classes": [
    {
      "name": "MeshTxInitiator",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/common.ts",
      "extends": null,
      "implements": [],
      "methods": [],
      "properties": [
        {
          "name": "mesh",
          "type": "MeshTxBuilder",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetcher",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "wallet",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "stakeCredential",
          "type": "string | undefined",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "networkId",
          "type": "number",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "version",
          "type": "number",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "languageVersion",
          "type": "LanguageVersion",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getScriptAddress",
          "type": "(scriptCbor: string) => any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "signSubmitReset",
          "type": "() => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "queryUtxos",
          "type": "(walletAddress: string) => Promise<UTxO[]>",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getWalletDappAddress",
          "type": "() => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getWalletCollateral",
          "type": "() => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getWalletUtxosWithMinLovelace",
          "type": "(lovelace: number, providedUtxos?: UTxO[]) => Promise<UTxO[]>",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getWalletUtxosWithToken",
          "type": "(assetHex: string, userUtxos?: UTxO[]) => Promise<UTxO[]>",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getAddressUtxosWithMinLovelace",
          "type": "(walletAddress: string, lovelace: number, providedUtxos?: UTxO[]) => Promise<UTxO[]>",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getAddressUtxosWithToken",
          "type": "(walletAddress: string, assetHex: string, userUtxos?: UTxO[]) => Promise<UTxO[]>",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getWalletInfoForTx",
          "type": "() => Promise<{ utxos: any; collateral: any; walletAddress: any; }>",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "_getUtxoByTxHash",
          "type": "(txHash: string, scriptCbor?: string | undefined) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        }
      ],
      "module": "common",
      "source": "mesh-contract"
    },
    {
      "name": "HydraConnection",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/hydra-connection.ts",
      "extends": "EventEmitter",
      "implements": [],
      "methods": [
        {
          "name": "connect",
          "signature": "async connect(): Promise<void> {\n    this._websocket = new WebSocket(this._websocketUrl);\n    if (!this._websocket) {\n      throw new Error(\"invalid url, websocket failed to connect\");\n    }\n    this._status = \"CONNECTING\";\n\n    this._websocket.onopen = () => {\n      this._connected = true;\n      this._status = \"CONNECTED\";\n      console.log(\"WebSocket connected successfully\");\n    };\n\n    this._websocket.onerror = (error) => {\n      console.error(\"Hydra error:\", error);\n      this._connected = false;\n    };\n\n    this._websocket.onclose = (code) => {\n      console.error(\"Hydra websocket closed\", code.code, code.reason);\n      this._status = \"CLOSED\";\n      this._connected = false;\n    };\n\n    this._websocket.onmessage = (data: MessageEvent) => {\n      const message = JSON.parse(data.data as string);\n      console.log(\"Received message from Hydra:\", message);\n      this._eventEmitter.emit(\"onmessage\", message);\n      this.processStatus(message);\n    };\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "send",
          "signature": "send(data: unknown): void {\n    const sendData = () => {\n      if (this._websocket?.readyState === WebSocket.OPEN) {\n        this._websocket.send(JSON.stringify(data));\n        return true;\n      }\n      return false;\n    };\n\n    const interval = setInterval(() => {\n      if (sendData()) {\n        clearInterval(interval);\n      }\n    }, 1000);\n\n    setTimeout(() => {\n      if (!sendData()) {\n        console.error(\"Failed to send data: WebSocket connection timeout.\");\n        clearInterval(interval);\n      }\n    }, 5000);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "disconnect",
          "signature": "async disconnect() {\n    if (this._status === \"IDLE\") {\n      return;\n    }\n    if (this._websocket && this._websocket.readyState === WebSocket.OPEN) {\n      this._websocket.close(1007);\n    }\n    this._status = \"IDLE\";\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "processStatus",
          "signature": "async processStatus(message: {}) {\n    let status: hStatus | null = null;\n    if ((status = hStatus(message)) && status !== null) {\n      this._status = status;\n      this._eventEmitter.emit(\"onstatuschange\", status);\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "_websocket",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "_status",
          "type": "\"IDLE\" | \"DISCONNECTED\" | \"CONNECTING\" | \"CONNECTED\" | \"INITIALIZING\" | \"OPEN\" | \"CLOSED\" | \"FANOUT_POSSIBLE\" | \"FINAL\"",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "_websocketUrl",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "_eventEmitter",
          "type": "import(\"events\")<DefaultEventMap>",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_connected",
          "type": "boolean",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "module": "hydra-connection",
      "source": "mesh-hydra"
    },
    {
      "name": "HydraInstance",
      "documentation": "todo: implement https://hydra.family/head-protocol/docs/tutorial/",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/hydra-instance.ts",
      "extends": null,
      "implements": [],
      "methods": [
        {
          "name": "commitFunds",
          "signature": "async commitFunds(txHash: string, txIndex: number): Promise<string> {\n    const utxo = (await this.fetcher.fetchUTxOs(txHash, txIndex))[0];\n    if (!utxo) {\n      throw new Error(\"UTxO not found\");\n    }\n    const hydraUtxo = {\n      address: utxo.output.address,\n      datum: null,\n      datumhash: null, // TODO: Handle datumHash case\n      referenceScript:\n        utxo.output.scriptRef === \"\" || !utxo.output.scriptRef\n          ? null\n          : utxo.output.scriptRef,\n      value: hAssets(utxo.output.amount),\n      inlineDatum: utxo.output.plutusData ? parseDatumCbor(utxo.output.plutusData) : null,\n      inlineDatumRaw: utxo.output.plutusData ?? null,\n    };\n    const commit = await this.provider.buildCommit(\n      {\n        [txHash + \"#\" + txIndex]: hydraUtxo,\n      },\n      {\n        \"Content-Type\": \"text/plain\",\n      }\n    );\n    console.log(commit);\n    return commit.cborHex;\n  }",
          "documentation": "To commit funds to the head, choose which UTxO you would like to make available on layer 2.\nThe function returns the transaction, ready to be signed by the user.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "commitBlueprint",
          "signature": "async commitBlueprint() {\n    return \"txhash\";\n  }",
          "documentation": "https://hydra.family/head-protocol/docs/how-to/commit-blueprint/.\nA Cardano transaction in the text envelope format. \nThat is, a JSON object wrapper with some 'type' around a 'cborHex' encoded transaction.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "incrementalCommit",
          "signature": "async incrementalCommit() {\n    return \"txHash\";\n  }",
          "documentation": "TO DO\nhttps://hydra.family/head-protocol/unstable/docs/how-to/incremental-commit\n\nIf you don't want to commit any funds and only want to receive on layer two, you can request an empty commit transaction.:",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "incrementalDecommit",
          "signature": "async incrementalDecommit() {\n    return \"txHash\";\n  }",
          "documentation": "https://hydra.family/head-protocol/docs/how-to/incremental-decommit",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "provider",
          "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/hydra-provider\").HydraProvider",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetcher",
          "type": "IFetcher",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "submitter",
          "type": "ISubmitter",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "hydra-instance",
      "source": "mesh-hydra"
    },
    {
      "name": "HydraProvider",
      "documentation": "HydraProvider is a tool for administrating & interacting with Hydra Heads.\n\nUsage:\n```\nimport { HydraProvider } from \"@meshsdk/hydra\";\n\nconst hydraProvider = new HydraProvider({url:'http://123.45.67.890:4001'});",
      "isExported": true,
      "importPath": "offchain/mesh-hydra/src/hydra-provider.ts",
      "extends": null,
      "implements": [
        "IFetcher",
        "ISubmitter"
      ],
      "methods": [
        {
          "name": "connect",
          "signature": "async connect() {\n    if (this._status !== \"DISCONNECTED\") {\n      return;\n    }\n    this._connection.connect();\n    this._status = \"CONNECTED\";\n  }",
          "documentation": "Connects to the Hydra Head. This command is a no-op when a Head is already open.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressUTxOs",
          "signature": "async fetchAddressUTxOs(address: string): Promise<UTxO[]> {\n    const utxos = await this.fetchUTxOs();\n    return utxos.filter((utxo) => utxo.output.address === address);\n  }",
          "documentation": "FETCHERS and SUBMITTERS\nUTXOs of the address.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchProtocolParameters",
          "signature": "async fetchProtocolParameters(epoch = Number.NaN): Promise<Protocol> {\n    return await this.subscribeProtocolParameters();\n  }",
          "documentation": "Fetch the latest protocol parameters.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchUTxOs",
          "signature": "async fetchUTxOs(hash?: string, index?: number): Promise<UTxO[]> {\n    const snapshotUTxOs = await this.subscribeSnapshotUtxo();\n\n    const outputsPromises: Promise<UTxO>[] = [];\n    snapshotUTxOs.forEach((utxo) => {\n      if (hash === undefined || utxo.input.txHash === hash) {\n        outputsPromises.push(Promise.resolve(utxo));\n      }\n    });\n    const outputs = await Promise.all(outputsPromises);\n\n    if (index !== undefined) {\n      return outputs.filter((utxo) => utxo.input.outputIndex === index);\n    }\n\n    return outputs;\n  }",
          "documentation": "Get UTxOs for a given hash.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "submitTx",
          "signature": "async submitTx(tx: string): Promise<string> {\n    try {\n      await this.newTx(tx, \"Witnessed Tx ConwayEra\");\n      const txId = await new Promise<string>((resolve) => {\n        this.onMessage((message) => {\n          if (message.tag === \"TxValid\") {\n            if (message.transaction && message.transaction.cborHex === tx) {\n              resolve(message.transaction.txId!);\n            }\n          }\n          if (message.tag === \"TxInvalid\") {\n            if (message.transaction && message.transaction.cborHex === tx) {\n              throw JSON.stringify(message.validationError);\n            }\n          }\n        });\n      });\n      return txId;\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Submit a transaction to the Hydra node. Note, unlike other providers, Hydra does not return a transaction hash.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "init",
          "signature": "async init() {\n    this._connection.send({ tag: \"Init\" });\n  }",
          "documentation": "Commands sent to the Hydra node.\n\nAccepts one of the following commands:\n- Init: init()\n- Abort: abort()\n- NewTx: newTx()\n- Decommit: decommit()\n- Close: close()\n- Contest: contest()\n- Fanout: fanout()\nInitializes a new Head. This command is a no-op when a Head is already open and the server will output an CommandFailed message should this happen.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "abort",
          "signature": "async abort() {\n    this._connection.send({ tag: \"Abort\" });\n  }",
          "documentation": "Aborts a head before it is opened. This can only be done before all participants have committed. Once opened, the head can't be aborted anymore but it can be closed using: `Close`.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "newTx",
          "signature": "async newTx(\n    cborHex: string,\n    type:\n      | \"Tx ConwayEra\"\n      | \"Unwitnessed Tx ConwayEra\"\n      | \"Witnessed Tx ConwayEra\",\n    description = \"\",\n    txId?: string\n  ) {\n    const transaction: hTransaction = {\n      type: type,\n      description: description,\n      cborHex: cborHex,\n      txId: txId,\n    };\n    const payload = {\n      tag: \"NewTx\",\n      transaction: transaction,\n    };\n    this._connection.send(payload);\n  }",
          "documentation": "Submit a transaction through the head. Note that the transaction is only broadcast if well-formed and valid.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "decommit",
          "signature": "async decommit(\n    cborHex: string,\n    type:\n      | \"Tx ConwayEra\"\n      | \"Unwitnessed Tx ConwayEra\"\n      | \"Witnessed Tx ConwayEra\",\n    description: string\n  ) {\n    const payload = {\n      tag: \"Decommit\",\n      decommitTx: {\n        type: type,\n        description: description,\n        cborHex: cborHex,\n      },\n    };\n    this._connection.send(payload);\n  }",
          "documentation": "Request to decommit a UTxO from a Head by providing a decommit tx. Upon reaching consensus, this will eventually result in corresponding transaction outputs becoming available on the layer 1.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "close",
          "signature": "async close() {\n    this.onStatusChange((status) => {\n      console.log(\"close status\", status);\n      if (status === \"OPEN\") {\n        this._connection.send({ tag: \"Close\" });\n      }\n    });\n  }",
          "documentation": "Terminate a head with the latest known snapshot. This effectively moves the head from the Open state to the Close state where the contestation phase begin. As a result of closing a head, no more transactions can be submitted via NewTx.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "contest",
          "signature": "async contest() {\n    this._connection.send({ tag: \"Contest\" });\n  }",
          "documentation": "Challenge the latest snapshot announced as a result of a head closure from another participant. Note that this necessarily contest with the latest snapshot known of your local Hydra node. Participants can only contest once.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fanout",
          "signature": "async fanout() {\n    this.onStatusChange((status) => {\n      console.log(\"status last\", status);\n      if (status === \"FANOUT_POSSIBLE\") {\n        this._connection.send({ tag: \"Fanout\" });\n      }\n    });\n  }",
          "documentation": "Finalize a head after the contestation period passed. This will distribute the final (as closed and maybe contested) head state back on the layer 1.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "buildCommit",
          "signature": "async buildCommit(payload: unknown, headers: RawAxiosRequestHeaders = {}) {\n    const txHex = await this.post(\"/commit\", payload, headers);\n    return txHex;\n  }",
          "documentation": "OPERATIONS\nDraft a commit transaction, which can be completed and later submitted to the L1 network.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "subscribeCommit",
          "signature": "async subscribeCommit() {\n    // todo\n    await this.get(\"/commit\");\n  }",
          "documentation": "Emitted by the server after drafting a commit transaction with the user provided utxos. Transaction returned to the user is in it's cbor representation encoded as Base16.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "buildCommits",
          "signature": "async buildCommits() {\n    const commits = await this.get(\"/commits\");\n    return commits;\n  }",
          "documentation": "Obtain a list of pending deposit transaction ID's.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "subscribeCommits",
          "signature": "async subscribeCommits() {\n    // todo\n    await this.get(\"/commits\");\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "commitsTxId",
          "signature": "async commitsTxId(headers: RawAxiosRequestHeaders = {}) {\n    // todo\n    await this.post(\"/commits/tx-id\", {}, headers);\n  }",
          "documentation": "Recover deposited UTxO by providing a TxId of a deposit transaction in the request path.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "subscribeCommitsTxId",
          "signature": "async subscribeCommitsTxId() {\n    // todo\n    await this.get(\"/commits/tx-id\");\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "subscribeSnapshotUtxo",
          "signature": "async subscribeSnapshotUtxo(): Promise<UTxO[]> {\n    const data = await this.get(`snapshot/utxo`);\n    const utxos: UTxO[] = [];\n    for (const [key, value] of Object.entries(data)) {\n      const utxo = hUTxO.toUTxO(value as hUTxO, key);\n      utxos.push(utxo);\n    }\n    return utxos;\n  }",
          "documentation": "A set of unspent transaction outputs.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "publishDecommit",
          "signature": "async publishDecommit(headers: RawAxiosRequestHeaders = {}) {\n    // todo\n    await this.post(\"/decommit\", {}, headers);\n  }",
          "documentation": "Provide decommit transaction that needs to be applicable to the Hydra's local ledger state. Specified transaction outputs will be available on layer 1 after decommit is successfully processed.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "subscribeDecommit",
          "signature": "async subscribeDecommit() {\n    // todo\n    await this.get(\"/decommit\");\n  }",
          "documentation": "Emitted by the server after drafting a decommit transaction.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "subscribeProtocolParameters",
          "signature": "async subscribeProtocolParameters(): Promise<Protocol> {\n    const data = await this.get(\"protocol-parameters\");\n\n    const protocolParams = castProtocol({\n      coinsPerUtxoSize: data.utxoCostPerByte,\n      collateralPercent: data.collateralPercentage,\n      maxBlockExMem: data.maxBlockExecutionUnits.memory,\n      maxBlockExSteps: data.maxBlockExecutionUnits.steps,\n      maxBlockHeaderSize: data.maxBlockHeaderSize,\n      maxBlockSize: data.maxBlockBodySize,\n      maxCollateralInputs: data.maxCollateralInputs,\n      maxTxExMem: data.maxTxExecutionUnits.memory,\n      maxTxExSteps: data.maxTxExecutionUnits.steps,\n      maxTxSize: data.maxTxSize,\n      maxValSize: data.maxValueSize,\n      minFeeA: data.txFeePerByte,\n      minFeeB: data.txFeeFixed,\n      minPoolCost: data.minPoolCost,\n      poolDeposit: data.stakePoolDeposit,\n      priceMem: data.executionUnitPrices.priceMemory,\n      priceStep: data.executionUnitPrices.priceSteps,\n    });\n\n    return protocolParams;\n  }",
          "documentation": "Get protocol parameters.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "publishCardanoTransaction",
          "signature": "async publishCardanoTransaction(headers: RawAxiosRequestHeaders = {}) {\n    // todo\n    await this.post(\"/cardano-transaction\", {}, headers);\n  }",
          "documentation": "Cardano transaction to be submitted to the L1 network. Accepts transactions encoded as Base16 CBOR string, TextEnvelope type or JSON.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "subscribeCardanoTransaction",
          "signature": "async subscribeCardanoTransaction() {\n    // todo\n    await this.get(\"/cardano-transaction\");\n  }",
          "documentation": "Successfully submitted a cardano transaction to the L1 network.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "onMessage",
          "signature": "onMessage(\n    callback: (\n      data:\n        | Greetings\n        | PeerConnected\n        | PeerDisconnected\n        | PeerHandshakeFailure\n        | HeadIsInitializing\n        | Committed\n        | HeadIsOpen\n        | HeadIsClosed\n        | HeadIsContested\n        | ReadyToFanout\n        | HeadIsAborted\n        | HeadIsFinalized\n        | TxValid\n        | TxInvalid\n        | SnapshotConfirmed\n        | GetUTxOResponse\n        | InvalidInput\n        | PostTxOnChainFailed\n        | CommandFailed\n        | IgnoredHeadInitializing\n        | DecommitInvalid\n        | DecommitRequested\n        | DecommitApproved\n        | DecommitFinalized\n    ) => void\n  ) {\n    this._eventEmitter.on(\"onmessage\", (message) => {\n      switch (message.tag) {\n        case \"Greetings\":\n          callback(message as Greetings);\n          break;\n        case \"PeerConnected\":\n          callback(message as PeerConnected);\n          break;\n        case \"onPeerDisconnected\":\n          callback(message as PeerDisconnected);\n          break;\n        case \"PeerHandshakeFailure\":\n          callback(message as PeerHandshakeFailure);\n          break;\n        case \"HeadIsInitializing\":\n          callback(message as HeadIsInitializing);\n          break;\n        case \"Committed\":\n          callback(message as Committed);\n          break;\n        case \"HeadIsOpen\":\n          callback(message as HeadIsOpen);\n          break;\n        case \"HeadIsClosed\":\n          callback(message as HeadIsClosed);\n          break;\n        case \"HeadIsContested\":\n          callback(message as HeadIsContested);\n          break;\n        case \"ReadyToFanout\":\n          callback(message as ReadyToFanout);\n          break;\n        case \"HeadIsAborted\":\n          callback(message as HeadIsAborted);\n          break;\n        case \"HeadIsFinalized\":\n          callback(message as HeadIsFinalized);\n          break;\n        case \"TxValid\":\n          callback(message as TxValid);\n          break;\n        case \"TxInvalid\":\n          callback(message as TxInvalid);\n          break;\n        case \"SnapshotConfirmed\":\n          callback(message as SnapshotConfirmed);\n          break;\n        case \"GetUTxOResponse\":\n          callback(message as GetUTxOResponse);\n          break;\n        case \"InvalidInput\":\n          callback(message as InvalidInput);\n          break;\n        case \"PostTxOnChainFailed\":\n          callback(message as PostTxOnChainFailed);\n          break;\n        case \"CommandFailed\":\n          callback(message as CommandFailed);\n          break;\n        case \"IgnoredHeadInitializing\":\n          callback(message as IgnoredHeadInitializing);\n          break;\n        case \"DecommitInvalid\":\n          callback(message as DecommitInvalid);\n          break;\n        case \"DecommitRequested\":\n          callback(message as DecommitRequested);\n          break;\n        case \"DecommitApproved\":\n          callback(message as DecommitApproved);\n          break;\n        case \"DecommitFinalized\":\n          callback(message as DecommitFinalized);\n          break;\n        default:\n          break;\n      }\n    });\n  }",
          "documentation": "Events emitted by the Hydra node.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "onStatusChange",
          "signature": "onStatusChange(callback: (status: hStatus) => void) {\n    this._eventEmitter.on(\"onstatuschange\", callback);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "get",
          "signature": "async get(url: string): Promise<any> {\n    try {\n      const { data, status } = await this._axiosInstance.get(url);\n      if (status === 200 || status == 202) {\n        return data;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Useful utility functions.\nA generic method to fetch data from a URL.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "post",
          "signature": "async post(\n    url: string,\n    payload: unknown,\n    headers: RawAxiosRequestHeaders\n  ): Promise<any> {\n    try {\n      const { data, status } = await this._axiosInstance.post(url, payload, {\n        headers,\n      });\n      if (status === 200 || status == 202) {\n        return data;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "A generic method to post data to a URL.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAccountInfo",
          "signature": "fetchAccountInfo(address: string): Promise<AccountInfo> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "NOT IMPLEMENTED FETCHERS",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressTxs",
          "signature": "async fetchAddressTxs(\n    address: string,\n    options: IFetcherOptions = DEFAULT_FETCHER_OPTIONS\n  ): Promise<TransactionInfo[]> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAssetAddresses",
          "signature": "fetchAssetAddresses(\n    asset: string\n  ): Promise<{ address: string; quantity: string }[]> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAssetMetadata",
          "signature": "fetchAssetMetadata(asset: string): Promise<AssetMetadata> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchBlockInfo",
          "signature": "fetchBlockInfo(hash: string): Promise<BlockInfo> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchCollectionAssets",
          "signature": "fetchCollectionAssets(\n    policyId: string,\n    cursor?: string | number | undefined\n  ): Promise<{ assets: Asset[]; next: string | number | null }> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchGovernanceProposal",
          "signature": "async fetchGovernanceProposal(\n    txHash: string,\n    certIndex: number\n  ): Promise<GovernanceProposalInfo> {\n    throw new Error(\"Method not implemented\");\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchTxInfo",
          "signature": "fetchTxInfo(hash: string): Promise<TransactionInfo> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "_connection",
          "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-hydra/src/hydra-connection\").HydraConnection",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_status",
          "type": "\"IDLE\" | \"DISCONNECTED\" | \"CONNECTING\" | \"CONNECTED\" | \"INITIALIZING\" | \"OPEN\" | \"CLOSED\" | \"FANOUT_POSSIBLE\" | \"FINAL\"",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_eventEmitter",
          "type": "import(\"events\")<DefaultEventMap>",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_axiosInstance",
          "type": "AxiosInstance",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "module": "hydra-provider",
      "source": "mesh-hydra"
    },
    {
      "name": "BeginProvider",
      "documentation": "The BeginProvider class provides methods to query Begin ID.\n\nTo use this provider, simply create a new instance of the BeginProvider class and call the desired method.\n\n```typescript\nimport { BeginProvider } from \"@meshsdk/core\";\n\nconst beginProvider = new BeginProvider();\n```",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/begin.ts",
      "extends": null,
      "implements": [],
      "methods": [
        {
          "name": "resolveAddress",
          "signature": "async resolveAddress(\n    name: string,\n    url?: string,\n  ): Promise<{\n    name: string;\n    domain: string;\n    image: string;\n    address: string;\n  }> {\n    try {\n      const axiosInstance = axios.create({\n        baseURL: url ?? \"https://resolveidaddress-ylo5dtxzdq-uc.a.run.app\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: this.apikey,\n        },\n      });\n\n      const { data, status } = await axiosInstance.post(``, {\n        name: name\n          .replace(\"@\", \"\")\n          .replace(/(\\.bgin\\.id|\\.beginid\\.io|\\.bgn\\.is)$/, \"\"),\n        chain: this.chainNumber,\n      });\n\n      if (status === 200) {\n        const result = data.result;\n        return {\n          name: result.name,\n          domain: `${\"\".concat(result.name, this.domainUrl)}`,\n          image: result.image,\n          address: result.addresses[this.chainNumber],\n        };\n      }\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Given a Begin ID, resolves the address and other information.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "resolveAdressReverse",
          "signature": "async resolveAdressReverse(\n    address: string,\n    url?: string,\n  ): Promise<{\n    name: string;\n    domain: string;\n    image: string;\n    address: string;\n  }> {\n    try {\n      const axiosInstance = axios.create({\n        baseURL:\n          url ?? \"https://resolveIdReserveAddress-ylo5dtxzdq-uc.a.run.app\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Authorization: this.apikey,\n        },\n      });\n\n      const { data, status } = await axiosInstance.post(``, {\n        address: address,\n        chain: this.chainNumber,\n      });\n\n      if (status === 200) {\n        const result = data.result;\n        return {\n          name: result.name,\n          domain: `${\"\".concat(result.name, this.domainUrl)}`,\n          image: result.image,\n          address: result.addresses[this.chainNumber],\n        };\n      }\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Given an address, resolves the Begin ID and other information.",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "apikey",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "chainNumber",
          "type": "1815",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "domainUrl",
          "type": "\".bgin.id\"",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "module": "begin",
      "source": "mesh-provider"
    },
    {
      "name": "BlockfrostProvider",
      "documentation": "Blockfrost provides restful APIs which allows your app to access information stored on the blockchain.\n\nUsage:\n```\nimport { BlockfrostProvider } from \"@meshsdk/core\";\n\nconst provider = new BlockfrostProvider('<Your-API-Key>');\n\n// With caching enabled\nconst providerWithCache = new BlockfrostProvider('<Your-API-Key>', 0, { enableCaching: true });\n```",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/blockfrost.ts",
      "extends": null,
      "implements": [
        "IFetcher",
        "IListener",
        "ISubmitter",
        "IEvaluator"
      ],
      "methods": [
        {
          "name": "evaluateTx",
          "signature": "async evaluateTx(cbor: string): Promise<Omit<Action, \"data\">[]> {\n    try {\n      const headers = { \"Content-Type\": \"application/cbor\" };\n      const { status, data } = await this._axiosInstance.post(\n        \"utils/txs/evaluate\",\n        cbor,\n        {\n          headers,\n        },\n      );\n\n      if (status === 200 && data.result.EvaluationResult) {\n        const tagMap: { [key: string]: RedeemerTagType } = {\n          spend: \"SPEND\",\n          mint: \"MINT\",\n          certificate: \"CERT\",\n          withdrawal: \"REWARD\",\n        };\n        const result: Omit<Action, \"data\">[] = [];\n\n        Object.keys(data.result.EvaluationResult).forEach((key) => {\n          const [tagKey, index] = key.split(\":\");\n          const { memory, steps } = data.result.EvaluationResult[key];\n          result.push({\n            tag: tagMap[tagKey!]!,\n            index: Number(index),\n            budget: { mem: memory, steps },\n          });\n        });\n\n        return result;\n      }\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Evaluates the resources required to execute the transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAccountInfo",
          "signature": "async fetchAccountInfo(address: string): Promise<AccountInfo> {\n    const rewardAddress = address.startsWith(\"addr\")\n      ? resolveRewardAddress(address)\n      : address;\n\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `accounts/${rewardAddress}`,\n      );\n\n      if (status === 200 || status == 202)\n        return <AccountInfo>{\n          poolId: data.pool_id,\n          active: data.active || data.active_epoch !== null,\n          balance: data.controlled_amount,\n          rewards: data.withdrawable_amount,\n          withdrawals: data.withdrawals_sum,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Obtain information about a specific stake account.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressAssets",
          "signature": "async fetchAddressAssets(\n    address: string,\n  ): Promise<{ [key: string]: string }> {\n    const utxos = await this.fetchAddressUTxOs(address);\n    return utxosToAssets(utxos);\n  }",
          "documentation": "Fetches the assets for a given address.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressTxs",
          "signature": "async fetchAddressTxs(\n    address: string,\n    option: IFetcherOptions = DEFAULT_FETCHER_OPTIONS,\n  ): Promise<TransactionInfo[]> {\n    const txs: TransactionInfo[] = [];\n    try {\n      const fetcherOptions = { ...DEFAULT_FETCHER_OPTIONS, ...option };\n\n      for (let i = 1; i <= fetcherOptions.maxPage!; i++) {\n        let { data, status } = await this._axiosInstance.get(\n          `/addresses/${address}/transactions?page=${i}&order=${fetcherOptions.order}`,\n        );\n        if (status !== 200) throw parseHttpError(data);\n        if (data.length === 0) break;\n        for (const tx of data) {\n          const txInfo = await this.fetchTxInfo(tx.tx_hash);\n\n          const _tx = {\n            ...txInfo,\n            blockHeight: tx.block_height,\n            blockTime: tx.block_time,\n          };\n\n          txs.push(_tx);\n        }\n      }\n      return txs;\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Transactions for an address. The `TransactionInfo` would only return the `hash`, `inputs`, and `outputs`.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressTransactions",
          "signature": "async fetchAddressTransactions(address: string): Promise<TransactionInfo[]> {\n    return await this.fetchAddressTxs(address);\n  }",
          "documentation": "Deprecated, use fetchAddressTxs instead",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressUTxOs",
          "signature": "async fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]> {\n    // Check cache first if caching is enabled\n    if (this._enableCaching && this._offlineFetcher) {\n      try {\n        const cachedUtxos = await this._offlineFetcher.fetchAddressUTxOs(address, asset);\n        if (cachedUtxos.length > 0) {\n          return cachedUtxos;\n        }\n      } catch (error) {\n        // Cache miss or error, continue to fetch from network\n      }\n    }\n\n    const filter = asset !== undefined ? `/${asset}` : \"\";\n    const url = `addresses/${address}/utxos` + filter;\n\n    const paginateUTxOs = async (\n      page = 1,\n      utxos: UTxO[] = [],\n    ): Promise<UTxO[]> => {\n      const { data, status } = await this._axiosInstance.get(\n        `${url}?page=${page}`,\n      );\n\n      if (status === 200 || status == 202)\n        return data.length > 0\n          ? paginateUTxOs(page + 1, [\n              ...utxos,\n              ...(await Promise.all(\n                data.map((utxo: BlockfrostUTxO) =>\n                  this.toUTxO(utxo, utxo.tx_hash),\n                ),\n              )),\n            ])\n          : utxos;\n\n      throw parseHttpError(data);\n    };\n\n    try {\n      const fetchedUtxos = await paginateUTxOs();\n      \n      // Cache the fetched UTXOs if caching is enabled\n      if (this._enableCaching && this._offlineFetcher && fetchedUtxos.length > 0) {\n        try {\n          this._offlineFetcher.addUTxOs(fetchedUtxos);\n        } catch (error) {\n          // Log error but don't fail the request\n          console.warn(\"Failed to cache UTXOs:\", error);\n        }\n      }\n      \n      return fetchedUtxos;\n    } catch (error) {\n      return [];\n    }\n  }",
          "documentation": "UTXOs of the address.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAssetAddresses",
          "signature": "async fetchAssetAddresses(\n    asset: string,\n  ): Promise<{ address: string; quantity: string }[]> {\n    const paginateAddresses = async <T>(\n      page = 1,\n      addresses: T[] = [],\n    ): Promise<T[]> => {\n      const { policyId, assetName } = parseAssetUnit(asset);\n      const { data, status } = await this._axiosInstance.get(\n        `assets/${policyId}${assetName}/addresses?page=${page}`,\n      );\n\n      if (status === 200 || status == 202)\n        return data.length > 0\n          ? paginateAddresses(page + 1, [...addresses, ...data])\n          : addresses;\n\n      throw parseHttpError(data);\n    };\n\n    try {\n      return await paginateAddresses<{ address: string; quantity: string }>();\n    } catch (error) {\n      return [];\n    }\n  }",
          "documentation": "Fetches the asset addresses for a given asset.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAssetMetadata",
          "signature": "async fetchAssetMetadata(asset: string): Promise<AssetMetadata> {\n    try {\n      const { policyId, assetName } = parseAssetUnit(asset);\n      const { data, status } = await this._axiosInstance.get(\n        `assets/${policyId}${assetName}`,\n      );\n      if (status === 200 || status == 202)\n        return <AssetMetadata>{\n          ...data.onchain_metadata,\n          fingerprint: data.fingerprint,\n          totalSupply: data.quantity,\n          mintingTxHash: data.initial_mint_tx_hash, // todo: request for `initial_mint_tx_hash`\n          mintCount: data.mint_or_burn_count,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetches the metadata for a given asset.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchLatestBlock",
          "signature": "async fetchLatestBlock(): Promise<BlockInfo> {\n    try {\n      const { data, status } = await this._axiosInstance.get(`blocks/latest`);\n\n      if (status === 200 || status == 202)\n        return <BlockInfo>{\n          confirmations: data.confirmations,\n          epoch: data.epoch,\n          epochSlot: data.epoch_slot.toString(),\n          fees: data.fees,\n          hash: data.hash,\n          nextBlock: data.next_block ?? \"\",\n          operationalCertificate: data.op_cert,\n          output: data.output ?? \"0\",\n          previousBlock: data.previous_block,\n          size: data.size,\n          slot: data.slot.toString(),\n          slotLeader: data.slot_leader ?? \"\",\n          time: data.time,\n          txCount: data.tx_count,\n          VRFKey: data.block_vrf,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetches the metadata for a given asset.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchBlockInfo",
          "signature": "async fetchBlockInfo(hash: string): Promise<BlockInfo> {\n    try {\n      const { data, status } = await this._axiosInstance.get(`blocks/${hash}`);\n\n      if (status === 200 || status == 202)\n        return <BlockInfo>{\n          confirmations: data.confirmations,\n          epoch: data.epoch,\n          epochSlot: data.epoch_slot.toString(),\n          fees: data.fees,\n          hash: data.hash,\n          nextBlock: data.next_block ?? \"\",\n          operationalCertificate: data.op_cert,\n          output: data.output ?? \"0\",\n          previousBlock: data.previous_block,\n          size: data.size,\n          slot: data.slot.toString(),\n          slotLeader: data.slot_leader ?? \"\",\n          time: data.time,\n          txCount: data.tx_count,\n          VRFKey: data.block_vrf,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetches the block information for a given block hash.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchCollectionAssets",
          "signature": "async fetchCollectionAssets(\n    policyId: string,\n    cursor = 1,\n  ): Promise<{ assets: Asset[]; next: string | number | null }> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `assets/policy/${policyId}?page=${cursor}`,\n      );\n\n      if (status === 200 || status == 202)\n        return {\n          assets: data.map((asset: BlockfrostAsset) => ({\n            unit: asset.asset,\n            quantity: asset.quantity,\n          })),\n          next: data.length === 100 ? cursor + 1 : null,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      return { assets: [], next: null };\n    }\n  }",
          "documentation": "Fetches the list of assets for a given policy ID.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchHandle",
          "signature": "async fetchHandle(handle: string): Promise<AssetMetadata> {\n    if (this._network !== \"mainnet\") {\n      throw new Error(\n        \"Does not support fetching addresses by handle on non-mainnet networks.\",\n      );\n    }\n    try {\n      const assetName = fromUTF8(`${handle.replace(\"$\", \"\")}`);\n      const asset = await this.fetchAssetMetadata(\n        `${SUPPORTED_HANDLES[1]}000de140${assetName}`,\n      );\n      return asset;\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchHandleAddress",
          "signature": "async fetchHandleAddress(handle: string): Promise<string> {\n    if (this._network !== \"mainnet\") {\n      throw new Error(\n        \"Does not support fetching addresses by handle on non-mainnet networks.\",\n      );\n    }\n    try {\n      const assetName = fromUTF8(handle.replace(\"$\", \"\"));\n      const { data, status } = await this._axiosInstance.get(\n        `assets/${SUPPORTED_HANDLES[1]}${assetName}/addresses`,\n      );\n\n      if (status === 200 || status == 202) return data[0].address;\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchProtocolParameters",
          "signature": "async fetchProtocolParameters(epoch = Number.NaN): Promise<Protocol> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `epochs/${isNaN(epoch) ? \"latest\" : epoch}/parameters`,\n      );\n\n      if (status === 200 || status == 202)\n        return castProtocol({\n          coinsPerUtxoSize: data.coins_per_utxo_word,\n          collateralPercent: data.collateral_percent,\n          decentralisation: data.decentralisation_param,\n          epoch: data.epoch,\n          keyDeposit: data.key_deposit,\n          maxBlockExMem: data.max_block_ex_mem,\n          maxBlockExSteps: data.max_block_ex_steps,\n          maxBlockHeaderSize: data.max_block_header_size,\n          maxBlockSize: data.max_block_size,\n          maxCollateralInputs: data.max_collateral_inputs,\n          maxTxExMem: data.max_tx_ex_mem,\n          maxTxExSteps: data.max_tx_ex_steps,\n          maxTxSize: data.max_tx_size,\n          maxValSize: data.max_val_size,\n          minFeeA: data.min_fee_a,\n          minFeeB: data.min_fee_b,\n          minPoolCost: data.min_pool_cost,\n          poolDeposit: data.pool_deposit,\n          priceMem: data.price_mem,\n          priceStep: data.price_step,\n        });\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetch the latest protocol parameters.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchTxInfo",
          "signature": "async fetchTxInfo(hash: string): Promise<TransactionInfo> {\n    try {\n      const { data: txData, status } = await this._axiosInstance.get(\n        `txs/${hash}`,\n      );\n      if (status === 200 || status == 202) {\n        const { data, status } = await this._axiosInstance.get(\n          `/txs/${txData.hash}/utxos`,\n        );\n        if (status !== 200) throw parseHttpError(data);\n        return <TransactionInfo>{\n          block: txData.block,\n          deposit: txData.deposit,\n          fees: txData.fees,\n          hash: txData.hash,\n          index: txData.index,\n          invalidAfter: txData.invalid_hereafter ?? \"\",\n          invalidBefore: txData.invalid_before ?? \"\",\n          slot: txData.slot.toString(),\n          size: txData.size,\n          inputs: data.inputs,\n          outputs: data.outputs,\n        };\n      }\n\n      throw parseHttpError(txData);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetches the transaction information for a given transaction hash.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchUTxOs",
          "signature": "async fetchUTxOs(hash: string, index?: number): Promise<UTxO[]> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `txs/${hash}/utxos`,\n      );\n      if (status === 200 || status == 202) {\n        const bfOutputs = data.outputs as BlockfrostUTxO[];\n        const outputsPromises: Promise<UTxO>[] = [];\n        bfOutputs.forEach((output) => {\n          outputsPromises.push(this.toUTxO(output, hash));\n        });\n        const outputs = await Promise.all(outputsPromises);\n\n        if (index !== undefined) {\n          return outputs.filter((utxo) => utxo.input.outputIndex === index);\n        }\n\n        return outputs;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Get UTxOs for a given hash.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchGovernanceProposal",
          "signature": "async fetchGovernanceProposal(\n    txHash: string,\n    certIndex: number,\n  ): Promise<GovernanceProposalInfo> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `governance/proposals/${txHash}/${certIndex}`,\n      );\n      if (status === 200 || status == 202)\n        return <GovernanceProposalInfo>{\n          txHash: data.tx_hash,\n          certIndex: data.cert_index,\n          governanceType: data.governance_type,\n          deposit: data.deposit,\n          returnAddress: data.return_address,\n          governanceDescription: data.governance_description,\n          ratifiedEpoch: data.ratified_epoch,\n          enactedEpoch: data.enacted_epoch,\n          droppedEpoch: data.dropped_epoch,\n          expiredEpoch: data.expired_epoch,\n          expiration: data.expiration,\n          metadata: (\n            await this._axiosInstance.get(\n              `governance/proposals/${txHash}/${certIndex}/metadata`,\n            )\n          ).data,\n        };\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetches the governance proposal information.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "get",
          "signature": "async get(url: string): Promise<any> {\n    try {\n      const { data, status } = await this._axiosInstance.get(url);\n      if (status === 200 || status == 202) {\n        return data;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "A generic method to fetch data from a URL.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "post",
          "signature": "async post(\n    url: string,\n    body: any,\n    headers = { \"Content-Type\": \"application/json\" },\n  ): Promise<any> {\n    try {\n      const { data, status } = await this._axiosInstance.post(url, body, {\n        headers,\n      });\n\n      if (status === 200 || status == 202) return data;\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "A generic method to post data to a URL.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "onTxConfirmed",
          "signature": "onTxConfirmed(txHash: string, callback: () => void, limit = 100): void {\n    let attempts = 0;\n\n    const checkTx = setInterval(() => {\n      if (attempts >= limit) clearInterval(checkTx);\n\n      this.fetchTxInfo(txHash)\n        .then((txInfo) => {\n          this.fetchBlockInfo(txInfo.block)\n            .then((blockInfo) => {\n              if (blockInfo?.confirmations > 0) {\n                clearInterval(checkTx);\n                callback();\n              }\n            })\n            .catch(() => {\n              attempts += 1;\n            });\n        })\n        .catch(() => {\n          attempts += 1;\n        });\n    }, 5_000);\n  }",
          "documentation": "Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "setSubmitTxToBytes",
          "signature": "setSubmitTxToBytes(value: boolean): void {\n    this.submitTxToBytes = value;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "submitTx",
          "signature": "async submitTx(tx: string): Promise<string> {\n    try {\n      const headers = { \"Content-Type\": \"application/cbor\" };\n      const { data, status } = await this._axiosInstance.post(\n        \"tx/submit\",\n        this.submitTxToBytes ? toBytes(tx) : tx,\n        { headers },\n      );\n\n      if (status === 200 || status == 202) {\n        // Cache the submitted transaction if caching is enabled\n        if (this._enableCaching && this._offlineFetcher) {\n          try {\n            this._offlineFetcher.addSerializedTransaction(tx);\n          } catch (error) {\n            // Log error but don't fail the request\n            console.warn(\"Failed to cache submitted transaction:\", error);\n          }\n        }\n        \n        return data;\n      }\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Submit a serialized transaction to the network.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchPlutusScriptCBOR",
          "signature": "private async fetchPlutusScriptCBOR(scriptHash: string): Promise<string> {\n    const { data, status } = await this._axiosInstance.get(\n      `scripts/${scriptHash}/cbor`,\n    );\n\n    if (status === 200 || status == 202) return data.cbor;\n\n    throw parseHttpError(data);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "fetchNativeScriptJSON",
          "signature": "private async fetchNativeScriptJSON(\n    scriptHash: string,\n  ): Promise<NativeScript> {\n    const { data, status } = await this._axiosInstance.get(\n      `scripts/${scriptHash}/json`,\n    );\n\n    if (status === 200 || status == 202) return data.json;\n\n    throw parseHttpError(data);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "setCaching",
          "signature": "setCaching(enable: boolean, offlineFetcher?: OfflineFetcher): void {\n    this._enableCaching = enable;\n    if (enable) {\n      this._offlineFetcher = offlineFetcher || new OfflineFetcher(this._network);\n    } else {\n      this._offlineFetcher = undefined;\n    }\n  }",
          "documentation": "Enable or disable caching functionality.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getOfflineFetcher",
          "signature": "getOfflineFetcher(): OfflineFetcher | undefined {\n    return this._offlineFetcher;\n  }",
          "documentation": "Get the current OfflineFetcher instance if caching is enabled.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "isCachingEnabled",
          "signature": "isCachingEnabled(): boolean {\n    return this._enableCaching;\n  }",
          "documentation": "Check if caching is currently enabled.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "exportCache",
          "signature": "exportCache(): string | null {\n    return this._offlineFetcher ? this._offlineFetcher.toJSON() : null;\n  }",
          "documentation": "Export the cached data as JSON string.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "importCache",
          "signature": "importCache(jsonData: string, enableCaching = true): void {\n    if (enableCaching && !this._enableCaching) {\n      this.setCaching(true);\n    }\n    \n    if (this._offlineFetcher) {\n      const importedFetcher = OfflineFetcher.fromJSON(jsonData);\n      this._offlineFetcher = importedFetcher;\n    }\n  }",
          "documentation": "Import cached data from JSON string.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "clearCache",
          "signature": "clearCache(): void {\n    if (this._offlineFetcher) {\n      this._offlineFetcher = new OfflineFetcher(this._network);\n    }\n  }",
          "documentation": "Clear all cached data.",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "_axiosInstance",
          "type": "AxiosInstance",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_network",
          "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/blockfrost\").BlockfrostSupportedNetworks",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "submitTxToBytes",
          "type": "boolean",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_offlineFetcher",
          "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/offline/offline-fetcher\").OfflineFetcher | undefined",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_enableCaching",
          "type": "boolean",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "resolveScriptRef",
          "type": "(scriptHash: string) => Promise<string | undefined>",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "toUTxO",
          "type": "(bfUTxO: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/blockfrost\").BlockfrostUTxO, tx_hash: string) => Promise<UTxO>",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "module": "blockfrost",
      "source": "mesh-provider"
    },
    {
      "name": "KoiosProvider",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/koios.ts",
      "extends": null,
      "implements": [
        "IFetcher",
        "IListener",
        "ISubmitter",
        "IEvaluator"
      ],
      "methods": [
        {
          "name": "fetchAccountInfo",
          "signature": "async fetchAccountInfo(address: string): Promise<AccountInfo> {\n    try {\n      const rewardAddress = address.startsWith(\"addr\")\n        ? resolveRewardAddress(address)\n        : address;\n\n      const { data, status } = await this._axiosInstance.post(\"account_info\", {\n        _stake_addresses: [rewardAddress],\n      });\n\n      if (status === 200)\n        return <AccountInfo>{\n          poolId: data[0].delegated_pool,\n          active: data[0].status === \"registered\",\n          balance: data[0].total_balance.toString(),\n          rewards: data[0].rewards_available,\n          withdrawals: data[0].withdrawals,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Obtain information about a specific stake account.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressAssets",
          "signature": "async fetchAddressAssets(\n    address: string,\n  ): Promise<{ [key: string]: string }> {\n    const utxos = await this.fetchAddressUTxOs(address);\n    return utxosToAssets(utxos);\n  }",
          "documentation": "Fetches the assets for a given address.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressTxs",
          "signature": "async fetchAddressTxs(\n    address: string,\n    option: IFetcherOptions = DEFAULT_FETCHER_OPTIONS,\n  ): Promise<TransactionInfo[]> {\n    try {\n      const { data, status } = await this._axiosInstance.post(`/address_txs`, {\n        _addresses: [address],\n      });\n      if (status === 200 || status == 202) {\n        return data.map((tx: any) => {\n          return <TransactionInfo>{\n            hash: tx.tx_hash,\n            index: 0,\n            block: \"\",\n            slot: \"\",\n            fees: \"\",\n            size: 0,\n            deposit: \"\",\n            invalidBefore: \"\",\n            invalidAfter: \"\",\n          };\n        });\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Unimplemented - open for contribution, see blockfrost.ts for reference",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressUTxOs",
          "signature": "async fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]> {\n    try {\n      const { data, status } = await this._axiosInstance.post(\"address_info\", {\n        _addresses: [address],\n      });\n\n      if (status === 200) {\n        const utxos = <UTxO[]>(\n          data\n            .flatMap((info: { utxo_set: [] }) => info.utxo_set)\n            .map((utxo: KoiosUTxO) => this.toUTxO(utxo, address))\n        );\n\n        return asset !== undefined\n          ? utxos.filter(\n              (utxo) =>\n                utxo.output.amount.find((a) => a.unit === asset) !== undefined,\n            )\n          : utxos;\n      }\n\n      throw parseHttpError(data);\n    } catch (error) {\n      return [];\n    }\n  }",
          "documentation": "UTXOs of the address.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAssetAddresses",
          "signature": "async fetchAssetAddresses(\n    asset: string,\n  ): Promise<{ address: string; quantity: string }[]> {\n    try {\n      const { policyId, assetName } = parseAssetUnit(asset);\n      const { data, status } = await this._axiosInstance.get(\n        `asset_addresses?_asset_policy=${policyId}&_asset_name=${assetName}`,\n      );\n\n      if (status === 200)\n        return data.map(\n          (item: {\n            payment_address: string;\n            quantity: string;\n            stake_address: string;\n          }) => ({\n            address: item.payment_address,\n            quantity: item.quantity,\n          }),\n        );\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetches the asset addresses for a given asset.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAssetMetadata",
          "signature": "async fetchAssetMetadata(asset: string): Promise<AssetMetadata> {\n    try {\n      const { policyId, assetName } = parseAssetUnit(asset);\n      const { data, status } = await this._axiosInstance.get(\n        `asset_info?_asset_policy=${policyId}&_asset_name=${assetName}`,\n      );\n      if (status === 200)\n        return <AssetMetadata>{\n          ...data[0].minting_tx_metadata[721][policyId][toUTF8(assetName)],\n          fingerprint: data[0].fingerprint,\n          totalSupply: data[0].total_supply,\n          mintingTxHash: data[0].minting_tx_hash,\n          mintCount: data[0].mint_cnt,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetches the metadata for a given asset.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchBlockInfo",
          "signature": "async fetchBlockInfo(hash: string): Promise<BlockInfo> {\n    try {\n      const { data, status } = await this._axiosInstance.post(\"block_info\", {\n        _block_hashes: [hash],\n      });\n\n      if (status === 200)\n        return <BlockInfo>{\n          confirmations: data[0].num_confirmations,\n          epoch: data[0].epoch_no,\n          epochSlot: data[0].epoch_slot.toString(),\n          fees: data[0].total_fees ?? \"\",\n          hash: data[0].hash,\n          nextBlock: data[0].child_hash ?? \"\",\n          operationalCertificate: data[0].op_cert,\n          output: data[0].total_output ?? \"0\",\n          previousBlock: data[0].parent_hash,\n          size: data[0].block_size,\n          slot: data[0].abs_slot.toString(),\n          slotLeader: data[0].pool ?? \"\",\n          time: data[0].block_time,\n          txCount: data[0].tx_count,\n          VRFKey: data[0].vrf_key,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetches the block information for a given block hash.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchCollectionAssets",
          "signature": "async fetchCollectionAssets(policyId: string): Promise<{ assets: Asset[] }> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `policy_asset_info?_asset_policy=${policyId}`,\n      );\n\n      if (status === 200)\n        return {\n          assets: data.map((asset: KoiosAsset) => ({\n            unit: `${asset.policy_id}${asset.asset_name}`,\n            quantity: asset.total_supply,\n          })),\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetches the list of assets for a given policy ID.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchHandle",
          "signature": "async fetchHandle(handle: string): Promise<AssetMetadata> {\n    if (this._network !== \"api\") {\n      throw new Error(\n        \"Does not support fetching addresses by handle on non-mainnet networks.\",\n      );\n    }\n    try {\n      const assetName = fromUTF8(`${handle.replace(\"$\", \"\")}`);\n      const asset = await this.fetchAssetMetadata(\n        `${SUPPORTED_HANDLES[1]}000de140${assetName}`,\n      );\n      return asset;\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchHandleAddress",
          "signature": "async fetchHandleAddress(handle: string): Promise<string> {\n    if (this._network !== \"api\") {\n      throw new Error(\n        \"Does not support fetching addresses by handle on non-mainnet networks.\",\n      );\n    }\n    try {\n      const assetName = fromUTF8(handle.replace(\"$\", \"\"));\n      const { data, status } = await this._axiosInstance.get(\n        `asset_addresses?_asset_policy=${SUPPORTED_HANDLES[1]}&_asset_name=${assetName}`,\n      );\n\n      if (status === 200) return data[0].payment_address;\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchProtocolParameters",
          "signature": "async fetchProtocolParameters(epoch = Number.NaN): Promise<Protocol> {\n    try {\n      if (isNaN(epoch)) {\n        const { data } = await this._axiosInstance.get(`tip`);\n        epoch = data[0].epoch_no;\n      }\n\n      const { data, status } = await this._axiosInstance.get(\n        `epoch_params?_epoch_no=${epoch}`,\n      );\n\n      if (status === 200)\n        return castProtocol({\n          coinsPerUtxoSize: data[0].coins_per_utxo_size,\n          collateralPercent: data[0].collateral_percent,\n          decentralisation: data[0].decentralisation,\n          epoch: data[0].epoch_no,\n          keyDeposit: data[0].key_deposit,\n          maxBlockExMem: data[0].max_block_ex_mem.toString(),\n          maxBlockExSteps: data[0].max_block_ex_steps.toString(),\n          maxBlockHeaderSize: data[0].max_bh_size,\n          maxBlockSize: data[0].max_block_size,\n          maxCollateralInputs: data[0].max_collateral_inputs,\n          maxTxExMem: data[0].max_tx_ex_mem.toString(),\n          maxTxExSteps: data[0].max_tx_ex_steps.toString(),\n          maxTxSize: data[0].max_tx_size,\n          maxValSize: data[0].max_val_size,\n          minFeeA: data[0].min_fee_a,\n          minFeeB: data[0].min_fee_b,\n          minPoolCost: data[0].min_pool_cost,\n          poolDeposit: data[0].pool_deposit,\n          priceMem: data[0].price_mem,\n          priceStep: data[0].price_step,\n        });\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetch the latest protocol parameters.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchTxInfo",
          "signature": "async fetchTxInfo(hash: string): Promise<TransactionInfo> {\n    try {\n      const { data, status } = await this._axiosInstance.post(\"tx_info\", {\n        _tx_hashes: [hash],\n      });\n\n      if (status === 200 && data.length == 1)\n        return <TransactionInfo>{\n          block: data[0].block_hash,\n          deposit: data[0].deposit,\n          fees: data[0].fee,\n          hash: data[0].tx_hash,\n          index: data[0].tx_block_index,\n          invalidAfter: data[0].invalid_after?.toString() ?? \"\",\n          invalidBefore: data[0].invalid_before?.toString() ?? \"\",\n          slot: data[0].absolute_slot.toString(),\n          size: data[0].tx_size,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetches the transaction information for a given transaction hash.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchUTxOs",
          "signature": "async fetchUTxOs(hash: string, index?: number): Promise<UTxO[]> {\n    try {\n      // get the assets too\n      const { data, status } = await this._axiosInstance.post(\"tx_info\", {\n        _tx_hashes: [hash],\n        _assets: true,\n        _scripts: true,\n        _bytecode: true,\n      });\n\n      if (status === 200) {\n        const utxos: UTxO[] = data[0].outputs.map((utxo: KoiosUTxO) =>\n          this.toUTxO(utxo, utxo.payment_addr.bech32),\n        );\n\n        if (index !== undefined) {\n          return utxos.filter((utxo) => utxo.input.outputIndex === index);\n        }\n\n        return utxos;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Get UTxOs for a given hash.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchGovernanceProposal",
          "signature": "async fetchGovernanceProposal(\n    txHash: string,\n    certIndex: number,\n  ): Promise<GovernanceProposalInfo> {\n    throw new Error(\"Method not implemented\");\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "get",
          "signature": "async get(url: string): Promise<any> {\n    try {\n      const { data, status } = await this._axiosInstance.get(url);\n      if (status === 200 || status == 202) {\n        return data;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "A generic method to fetch data from a URL.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "post",
          "signature": "async post(\n    url: string,\n    body: any,\n    headers = { \"Content-Type\": \"application/json\" },\n  ): Promise<any> {\n    try {\n      const { data, status } = await this._axiosInstance.post(url, body, {\n        headers,\n      });\n\n      if (status === 200 || status == 202) return data;\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "A generic method to post data to a URL.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "onTxConfirmed",
          "signature": "onTxConfirmed(txHash: string, callback: () => void, limit = 100): void {\n    let attempts = 0;\n\n    const checkTx = setInterval(() => {\n      if (attempts >= limit) clearInterval(checkTx);\n\n      this.fetchTxInfo(txHash)\n        .then((txInfo) => {\n          this.fetchBlockInfo(txInfo.block)\n            .then((blockInfo) => {\n              if (blockInfo?.confirmations > 0) {\n                clearInterval(checkTx);\n                callback();\n              }\n            })\n            .catch(() => {\n              attempts += 1;\n            });\n        })\n        .catch(() => {\n          attempts += 1;\n        });\n    }, 5_000);\n  }",
          "documentation": "Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressTransactions",
          "signature": "async fetchAddressTransactions(address: string): Promise<TransactionInfo[]> {\n    return await this.fetchAddressTxs(address);\n  }",
          "documentation": "Deprecated, use fetchAddressTxs instead",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "submitTx",
          "signature": "async submitTx(tx: string): Promise<string> {\n    try {\n      const headers = { \"Content-Type\": \"application/cbor\" };\n\n      const { data, status } = await this._axiosInstance.post(\n        \"submittx\",\n        toBytes(tx),\n        { headers },\n      );\n\n      if (status === 202) return data;\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Submit a serialized transaction to the network.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "toUTxO",
          "signature": "private toUTxO(utxo: KoiosUTxO, address: string): UTxO {\n    return {\n      input: {\n        outputIndex: utxo.tx_index,\n        txHash: utxo.tx_hash,\n      },\n      output: {\n        address: address,\n        amount: [\n          { unit: \"lovelace\", quantity: utxo.value },\n          ...utxo.asset_list.map(\n            (a: KoiosAsset) =>\n              <Asset>{\n                unit: `${a.policy_id}${a.asset_name}`,\n                quantity: `${a.quantity}`,\n              },\n          ),\n        ],\n        dataHash: utxo.datum_hash ?? undefined,\n        plutusData: utxo.inline_datum?.bytes ?? undefined,\n        scriptRef: this.resolveScriptRef(utxo.reference_script),\n        scriptHash: utxo.reference_script?.hash ?? undefined,\n      },\n    };\n  }",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "evaluateTx",
          "signature": "async evaluateTx(tx: string, additionalUtxos?: UTxO[], additionalTxs?: string[]): Promise<Omit<Action, \"data\">[]> {\n    try {\n      const headers = {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\",\n      };\n\n      const body = {\n        jsonrpc: \"2.0\",\n        method: \"evaluateTransaction\",\n        params: {\n          transaction: {\n            cbor: tx\n          },\n        }\n      }\n\n      const { data, status } = await this._axiosInstance.post(\n        \"ogmios\",\n        body,\n        { headers },\n      );\n\n      if (status === 200 || status === 202) {\n        if (!data.result || !data.result.length) {\n          return [];\n        }\n\n        return data.result.map((val: any) => {\n          if (!val.validator || !val.budget) {\n            throw new Error(\"Invalid response format\");\n          }\n          return <Omit<Action, \"data\">>{\n            index: val.validator.index,\n            tag: val.validator.purpose.toUpperCase(),\n            budget: {\n              mem: val.budget.memory,\n              steps: val.budget.cpu,\n            },\n          };\n        })\n      }\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "_axiosInstance",
          "type": "AxiosInstance",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_network",
          "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/koios\").KoiosSupportedNetworks",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "resolveScriptRef",
          "type": "(kScriptRef: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/koios\").KoiosReferenceScript | undefined) => string | undefined",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "module": "koios",
      "source": "mesh-provider"
    },
    {
      "name": "MaestroProvider",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/maestro.ts",
      "extends": null,
      "implements": [
        "IFetcher",
        "ISubmitter",
        "IEvaluator",
        "IListener"
      ],
      "methods": [
        {
          "name": "evaluateTx",
          "signature": "async evaluateTx(cbor: string): Promise<Omit<Action, \"data\">[]> {\n    try {\n      const { data, status } = await this._axiosInstance.post(\n        \"transactions/evaluate\",\n        { cbor },\n      );\n      if (status === 200) {\n        const tagMap: { [key: string]: string } = {\n          spend: \"SPEND\",\n          mint: \"MINT\",\n          cert: \"CERT\",\n          wdrl: \"REWARD\",\n        };\n        const result = data.map((action: any) => {\n          const budget = action.ex_units;\n          const index = action.redeemer_index;\n          const tag = tagMap[action.redeemer_tag];\n          return { budget, index, tag };\n        });\n        return result;\n      }\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Evaluates the resources required to execute the transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAccountInfo",
          "signature": "async fetchAccountInfo(address: string): Promise<AccountInfo> {\n    const rewardAddress = address.startsWith(\"addr\")\n      ? resolveRewardAddress(address)\n      : address;\n\n    try {\n      const { data: timestampedData, status } = await this._axiosInstance.get(\n        `accounts/${rewardAddress}`,\n        this._amountsAsStrings,\n      );\n\n      if (status === 200) {\n        const data = timestampedData.data;\n        return <AccountInfo>{\n          poolId: data.delegated_pool,\n          active: data.registered,\n          balance: data.total_balance,\n          rewards: data.rewards_available,\n          withdrawals: data.total_withdrawn,\n        };\n      }\n      throw parseHttpError(timestampedData);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Obtain information about a specific stake account.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressAssets",
          "signature": "async fetchAddressAssets(\n    address: string,\n  ): Promise<{ [key: string]: string }> {\n    const utxos = await this.fetchAddressUTxOs(address);\n    return utxosToAssets(utxos);\n  }",
          "documentation": "Fetches the assets for a given address.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressUTxOs",
          "signature": "async fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]> {\n    const queryPredicate = (() => {\n      if (\n        address.startsWith(\"addr_vkh\") ||\n        address.startsWith(\"addr_shared_vkh\")\n      )\n        return `addresses/cred/${address}`;\n      else return `addresses/${address}`;\n    })();\n    const appendAssetString = asset ? `&asset=${asset}` : \"\";\n    const paginateUTxOs = async (\n      cursor = null,\n      utxos: UTxO[] = [],\n    ): Promise<UTxO[]> => {\n      const appendCursorString = cursor === null ? \"\" : `&cursor=${cursor}`;\n      const { data: timestampedData, status } = await this._axiosInstance.get(\n        `${queryPredicate}/utxos?count=100${appendAssetString}${appendCursorString}`,\n        this._amountsAsStrings,\n      );\n      if (status === 200) {\n        const data = timestampedData.data;\n        const pageUTxOs: UTxO[] = data.map(this.toUTxO);\n        const addedUtxos = [...utxos, ...pageUTxOs];\n        const nextCursor = timestampedData.next_cursor;\n        return nextCursor == null\n          ? addedUtxos\n          : paginateUTxOs(nextCursor, addedUtxos);\n      }\n\n      throw parseHttpError(timestampedData);\n    };\n\n    try {\n      return await paginateUTxOs();\n    } catch (error) {\n      return [];\n    }\n  }",
          "documentation": "UTXOs of the address.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressTxs",
          "signature": "async fetchAddressTxs(\n    address: string,\n    option: IFetcherOptions = { maxPage: 100, order: \"desc\" },\n  ): Promise<TransactionInfo[]> {\n    // open for contribution, see blockfrost.ts for reference\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "Unimplemented - open for contribution\n\nTransactions for an address. The `TransactionInfo` would only return the `hash`, `inputs`, and `outputs`.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAssetAddresses",
          "signature": "async fetchAssetAddresses(\n    asset: string,\n  ): Promise<{ address: string; quantity: string }[]> {\n    const { policyId, assetName } = parseAssetUnit(asset);\n    const paginateAddresses = async (\n      cursor = null,\n      addressesWithQuantity: { address: string; quantity: string }[] = [],\n    ): Promise<{ address: string; quantity: string }[]> => {\n      const appendCursorString = cursor === null ? \"\" : `&cursor=${cursor}`;\n      const { data: timestampedData, status } = await this._axiosInstance.get(\n        `assets/${policyId}${assetName}/addresses?count=100${appendCursorString}`,\n        this._amountsAsStrings,\n      );\n      if (status === 200) {\n        const data = timestampedData.data;\n        const pageAddressesWithQuantity: {\n          address: string;\n          quantity: string;\n        }[] = data.map((a: { address: string; amount: string }) => {\n          return { address: a.address, quantity: a.amount };\n        });\n        const nextCursor = timestampedData.next_cursor;\n        const addedData = [\n          ...addressesWithQuantity,\n          ...pageAddressesWithQuantity,\n        ];\n        return nextCursor == null\n          ? addedData\n          : paginateAddresses(nextCursor, addedData);\n      }\n\n      throw parseHttpError(timestampedData);\n    };\n\n    try {\n      return await paginateAddresses();\n    } catch (error) {\n      return [];\n    }\n  }",
          "documentation": "Fetches the asset addresses for a given asset.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAssetMetadata",
          "signature": "async fetchAssetMetadata(asset: string): Promise<AssetMetadata> {\n    try {\n      const { policyId, assetName } = parseAssetUnit(asset);\n      const { data: timestampedData, status } = await this._axiosInstance.get(\n        `assets/${policyId}${assetName}`,\n      );\n      if (status === 200) {\n        const data = timestampedData.data;\n        return <AssetMetadata>{\n          ...data.asset_standards.cip25_metadata,\n          ...data.asset_standards.cip68_metadata,\n          fingerprint: data.fingerprint,\n          totalSupply: data.total_supply,\n          mintingTxHash: data.latest_mint_tx.tx_hash,\n          mintCount: data.mint_tx_count,\n        };\n      }\n\n      throw parseHttpError(timestampedData);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetches the metadata for a given asset.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchBlockInfo",
          "signature": "async fetchBlockInfo(hash: string): Promise<BlockInfo> {\n    try {\n      const { data: timestampedData, status } = await this._axiosInstance.get(\n        `blocks/${hash}`,\n        this._amountsAsStrings,\n      );\n\n      if (status === 200) {\n        const data = timestampedData.data;\n        return <BlockInfo>{\n          confirmations: data.confirmations,\n          epoch: data.epoch,\n          epochSlot: data.epoch_slot.toString(),\n          fees: data.total_fees,\n          hash: data.hash,\n          nextBlock: data.next_block ?? \"\",\n          operationalCertificate: data.operational_certificate?.hot_vkey,\n          output: data.total_output_lovelace ?? \"0\",\n          previousBlock: data.previous_block,\n          size: data.size,\n          slot: data.absolute_slot.toString(),\n          slotLeader: data.block_producer ?? \"\",\n          time: Date.parse(data.timestamp) / 1000,\n          txCount: data.tx_hashes.length,\n          VRFKey: VrfVkBech32.fromHex(data.vrf_key),\n        };\n      }\n\n      throw parseHttpError(timestampedData);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetches the block information for a given block hash.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchCollectionAssets",
          "signature": "async fetchCollectionAssets(\n    policyId: string,\n    cursor?: string,\n  ): Promise<{ assets: Asset[]; next: string | number | null }> {\n    try {\n      const { data: timestampedData, status } = await this._axiosInstance.get(\n        `policy/${policyId}/assets?count=100${\n          cursor ? `&cursor=${cursor}` : \"\"\n        }`,\n      );\n\n      if (status === 200) {\n        const data = timestampedData.data;\n        return {\n          assets: data.map((asset: MaestroAssetExtended) => ({\n            unit: policyId + asset.asset_name,\n            quantity: asset.total_supply,\n          })),\n          next: timestampedData.next_cursor,\n        };\n      }\n\n      throw parseHttpError(timestampedData);\n    } catch (error) {\n      return { assets: [], next: null };\n    }\n  }",
          "documentation": "Fetches the list of assets for a given policy ID.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchHandle",
          "signature": "async fetchHandle(handle: string): Promise<object> {\n    if (this._network !== \"Mainnet\") {\n      throw new Error(\n        \"Does not support fetching addresses by handle on non-mainnet networks.\",\n      );\n    }\n    try {\n      const assetName = fromUTF8(`${handle.replace(\"$\", \"\")}`);\n      const asset = (await this.fetchAssetMetadata(\n        `${SUPPORTED_HANDLES[1]}000643b0${assetName}`,\n      )) as NonFungibleAssetMetadata;\n\n      if (asset.metadata !== undefined) return asset.metadata;\n\n      throw \"Problem fetching metadata\";\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchHandleAddress",
          "signature": "async fetchHandleAddress(handle: string): Promise<string> {\n    if (this._network !== \"Mainnet\") {\n      throw new Error(\n        \"Does not support fetching addresses by handle on non-mainnet networks.\",\n      );\n    }\n\n    try {\n      const handleWithoutDollar =\n        handle.charAt(0) === \"$\" ? handle.substring(1) : handle;\n      const { data: timestampedData, status } = await this._axiosInstance.get(\n        `ecosystem/adahandle/${handleWithoutDollar}`,\n      );\n\n      if (status === 200) return timestampedData.data;\n\n      throw parseHttpError(timestampedData);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchProtocolParameters",
          "signature": "async fetchProtocolParameters(epoch = Number.NaN): Promise<Protocol> {\n    if (!isNaN(epoch))\n      throw new Error(\n        \"Maestro only supports fetching Protocol parameters of the latest completed epoch.\",\n      );\n\n    // Decimal numbers in Maestro are given as ratio of two numbers represented by string of format \"firstNumber/secondNumber\".\n    const decimalFromRationalString = (str: string): number => {\n      const forwardSlashIndex = str.indexOf(\"/\");\n      return (\n        parseInt(str.slice(0, forwardSlashIndex)) /\n        parseInt(str.slice(forwardSlashIndex + 1))\n      );\n    };\n    try {\n      const { data: timestampedData, status } =\n        await this._axiosInstance.get(\"protocol-params\");\n      if (status === 200) {\n        const data = timestampedData.data;\n        try {\n          const { data: timestampedDataEpochData, status: epochStatus } =\n            await this._axiosInstance.get(\"epochs/current\");\n          if (epochStatus === 200) {\n            const epochData = timestampedDataEpochData.data;\n            return castProtocol({\n              coinsPerUtxoSize: parseInt(data.coins_per_utxo_byte),\n              collateralPercent: parseInt(data.collateral_percentage),\n              decentralisation: 0, // Deprecated in Babbage era.\n              epoch: parseInt(epochData.epoch_no),\n              keyDeposit: parseInt(data.stake_key_deposit),\n              maxBlockExMem:\n                data.max_execution_units_per_block.memory.toString(),\n              maxBlockExSteps:\n                data.max_execution_units_per_block.steps.toString(),\n              maxBlockHeaderSize: parseInt(data.max_block_header_size),\n              maxBlockSize: parseInt(data.max_block_body_size),\n              maxCollateralInputs: parseInt(data.max_collateral_inputs),\n              maxTxExMem:\n                data.max_execution_units_per_transaction.memory.toString(),\n              maxTxExSteps:\n                data.max_execution_units_per_transaction.steps.toString(),\n              maxTxSize: parseInt(data.max_tx_size),\n              maxValSize: parseInt(data.max_value_sized),\n              minFeeA: data.min_fee_coefficient,\n              minFeeB: data.min_fee_constant,\n              minPoolCost: data.min_pool_cost.toString(),\n              poolDeposit: parseInt(data.pool_deposit),\n              priceMem: decimalFromRationalString(data.prices.memory),\n              priceStep: decimalFromRationalString(data.prices.steps),\n            });\n          }\n          throw parseHttpError(timestampedDataEpochData);\n        } catch (error) {\n          throw parseHttpError(error);\n        }\n      }\n      throw parseHttpError(timestampedData);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetch the latest protocol parameters.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchTxInfo",
          "signature": "async fetchTxInfo(hash: string): Promise<TransactionInfo> {\n    try {\n      const { data: timestampedData, status } = await this._axiosInstance.get(\n        `transactions/${hash}`,\n      );\n\n      if (status === 200) {\n        const data = timestampedData.data;\n        return <TransactionInfo>{\n          block: data.block_hash,\n          deposit: data.deposit.toString(),\n          fees: data.fee.toString(),\n          hash: data.tx_hash,\n          index: data.block_tx_index,\n          invalidAfter: data.invalid_hereafter ?? \"\",\n          invalidBefore: data.invalid_before ?? \"\",\n          slot: data.block_absolute_slot.toString(),\n          size: data.size - 1,\n        };\n      }\n      throw parseHttpError(timestampedData);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetches the transaction information for a given transaction hash.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchUTxOs",
          "signature": "async fetchUTxOs(hash: string, index?: number): Promise<UTxO[]> {\n    try {\n      const { data: timestampedData, status } = await this._axiosInstance.get(\n        `transactions/${hash}`,\n        this._amountsAsStrings,\n      );\n      if (status === 200) {\n        const msOutputs = timestampedData.data.outputs as MaestroUTxO[];\n        const outputs = msOutputs.map(this.toUTxO);\n\n        if (index !== undefined) {\n          return outputs.filter((utxo) => utxo.input.outputIndex === index);\n        }\n\n        return outputs;\n      }\n      throw parseHttpError(timestampedData);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Get UTxOs for a given hash.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchGovernanceProposal",
          "signature": "async fetchGovernanceProposal(\n    txHash: string,\n    certIndex: number,\n  ): Promise<GovernanceProposalInfo> {\n    throw new Error(\"Method not implemented by Maestro\");\n  }",
          "documentation": "Unimplemented - open for contribution\n\nFetches the governance proposal information.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "get",
          "signature": "async get(url: string): Promise<any> {\n    try {\n      const { data, status } = await this._axiosInstance.get(url);\n      if (status === 200) {\n        return data;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "onTxConfirmed",
          "signature": "onTxConfirmed(txHash: string, callback: () => void, limit = 100): void {\n    let attempts = 0;\n\n    const checkTx = setInterval(() => {\n      if (attempts >= limit) clearInterval(checkTx);\n\n      this.fetchTxInfo(txHash)\n        .then((txInfo) => {\n          this.fetchBlockInfo(txInfo.block)\n            .then((blockInfo) => {\n              if (blockInfo?.confirmations > 0) {\n                clearInterval(checkTx);\n                callback();\n              }\n            })\n            .catch(() => {\n              attempts += 1;\n            });\n        })\n        .catch(() => {\n          attempts += 1;\n        });\n    }, 5_000);\n  }",
          "documentation": "Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "setSubmitTxToBytes",
          "signature": "setSubmitTxToBytes(value: boolean): void {\n    this.submitTxToBytes = value;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "submitTx",
          "signature": "async submitTx(tx: string): Promise<string> {\n    try {\n      const headers = { \"Content-Type\": \"application/cbor\" };\n      const { data, status } = await this._axiosInstance.post(\n        this.submitUrl,\n        this.submitTxToBytes ? toBytes(tx) : tx,\n        { headers },\n      );\n\n      if (status === 202) return data;\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Submit a serialized transaction to the network.",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "_axiosInstance",
          "type": "AxiosInstance",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_amountsAsStrings",
          "type": "{ headers: { \"amounts-as-strings\": string; }; }",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_network",
          "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/maestro\").MaestroSupportedNetworks",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "submitTxToBytes",
          "type": "boolean",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "submitUrl",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "toUTxO",
          "type": "(utxo: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/maestro\").MaestroUTxO) => UTxO",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "resolveScript",
          "type": "(utxo: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-provider/src/types/maestro\").MaestroUTxO) => any",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "module": "maestro",
      "source": "mesh-provider"
    },
    {
      "name": "OgmiosProvider",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/ogmios.ts",
      "extends": null,
      "implements": [
        "IEvaluator",
        "ISubmitter"
      ],
      "methods": [
        {
          "name": "evaluateTx",
          "signature": "async evaluateTx(tx: string): Promise<Omit<Action, \"data\">[]> {\n    const client = await this.open();\n\n    this.send(client, \"evaluateTransaction\", {\n      transaction: {\n        cbor: tx,\n      },\n    });\n\n    return new Promise((resolve, reject) => {\n      client.addEventListener(\n        \"message\",\n        (response: MessageEvent<string>) => {\n          try {\n            const { result } = JSON.parse(response.data);\n            if (result) {\n              resolve(\n                Object.values(result).map((val: any) => {\n                  return <Omit<Action, \"data\">>{\n                    index: val.validator.index,\n                    tag: val.validator.purpose.toUpperCase(),\n                    budget: {\n                      mem: val.budget.memory,\n                      steps: val.budget.cpu,\n                    },\n                  };\n                }),\n              );\n            } else {\n              reject(result);\n            }\n\n            client.close();\n          } catch (error) {\n            reject(error);\n          }\n        },\n        { once: true },\n      );\n    });\n  }",
          "documentation": "Evaluates the resources required to execute the transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "onNextTx",
          "signature": "async onNextTx(callback: (tx: unknown) => void): Promise<() => void> {\n    const client = await this.open();\n\n    this.send(client, \"acquireMempool\", {});\n\n    client.addEventListener(\"message\", (response: MessageEvent<string>) => {\n      const { result } = JSON.parse(response.data);\n      if (result === null) {\n        return this.send(client, \"acquireMempool\", {});\n      }\n\n      if (result.transaction === null || result.transaction === undefined) {\n        this.send(client, \"acquireMempool\", {});\n      } else {\n        callback(result);\n      }\n\n      this.send(client, \"nextTransaction\", {\n        fields: \"all\",\n      });\n    });\n\n    return () => client.close();\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "submitTx",
          "signature": "async submitTx(tx: string): Promise<string> {\n    const client = await this.open();\n\n    this.send(client, \"submitTransaction\", {\n      transaction: {\n        cbor: tx,\n      },\n    });\n\n    return new Promise((resolve, reject) => {\n      client.addEventListener(\n        \"message\",\n        (response: MessageEvent<string>) => {\n          try {\n            const { result } = JSON.parse(response.data);\n\n            if (!result) {\n              reject(JSON.parse(response.data).error);\n            }\n\n            if (\n              result.transaction !== null &&\n              result.transaction !== undefined\n            ) {\n              resolve(result.transaction.id);\n            } else {\n              reject(result);\n            }\n\n            client.close();\n          } catch (error) {\n            reject(error);\n          }\n        },\n        { once: true },\n      );\n    });\n  }",
          "documentation": "Submit a serialized transaction to the network.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "open",
          "signature": "private async open(): Promise<WebSocket> {\n    const client = new WebSocket(this._baseUrl);\n\n    await new Promise((resolve) => {\n      client.addEventListener(\"open\", () => resolve(true), { once: true });\n    });\n\n    return client;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "send",
          "signature": "private send(client: WebSocket, method: string, params: unknown) {\n    client.send(\n      JSON.stringify({\n        jsonrpc: \"2.0\",\n        type: \"jsonwsp/request\",\n        servicename: \"ogmios\",\n        method,\n        params,\n      }),\n    );\n  }",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "properties": [
        {
          "name": "_baseUrl",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "module": "ogmios",
      "source": "mesh-provider"
    },
    {
      "name": "U5CProvider",
      "documentation": "A UTxO RPC Provider for [MeshJS](https://meshjs.dev/) Transaction Builder Library.\n\nExample usage of how to use the UTxO RPC provider with Mesh to build and submit a transaction.\n```\n// Step #1\n// Import Mesh SDK and UTxO RPC provider\nimport { Transaction, MeshWallet, U5CProvider } from \"@meshsdk/core\";\n\nasync function main() {\n  // Step #2\n  // Create a new U5C provider\n  const provider = new U5CProvider({\n    url: \"http://localhost:50051\",\n    headers: {\n      \"dmtr-api-key\": \"<api-key>\",\n    },\n  });\n\n  // Step #3\n  // Create a new wallet from a mnemonic\n  const wallet = new MeshWallet({\n    networkId: 0, // 0: testnet, 1: mainnet\n    fetcher: provider,\n    submitter: provider,\n    key: {\n      type: \"mnemonic\",\n      words: [\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n        \"solution\",\n      ],\n    },\n  });\n\n  // Optional: Print the wallet address\n  console.log(wallet.getChangeAddress());\n\n  // Optional: Print the wallet utxos\n  console.log(await provider.fetchAddressUTxOs(wallet.getChangeAddress()));\n\n  // Step #4\n  // Create an example transaction that sends 5 ADA to an address\n  const tx = new Transaction({\n    initiator: wallet,\n    verbose: false,\n  }).sendLovelace(\n    \"addr_test1vpvx0sacufuypa2k4sngk7q40zc5c4npl337uusdh64kv0c7e4cxr\",\n    \"5000000\"\n  );\n  const unsignedTx = await tx.build();\n\n  // Step #5\n  // Sign the transaction\n  const signedTx = await wallet.signTx(unsignedTx);\n\n  // Step #6\n  // Submit the transaction to the blockchain network\n  const txId = await provider.submitTx(signedTx);\n\n  // Optional: Print the transaction ID\n  console.log(\"Transaction ID\", txId);\n}\n\nmain().catch(console.error);\n```",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/utxo-rpc.ts",
      "extends": null,
      "implements": [
        "IFetcher",
        "ISubmitter",
        "IEvaluator",
        "IListener"
      ],
      "methods": [
        {
          "name": "onTxConfirmed",
          "signature": "onTxConfirmed(txHash: string, callback: () => void, limit = 100): void {\n    const onConfirmed = async () => {\n      const updates = this.submitClient.waitForTx(hexToBytes(txHash));\n\n      for await (const stage of updates) {\n        console.log(JSON.stringify(updates));\n        if (stage === submit.Stage.CONFIRMED) {\n          callback();\n          return; // Exit once confirmed\n        }\n      }\n    };\n\n    const timeoutId = setTimeout(() => {\n      // Handle timeout if necessary (e.g., log or notify)\n      console.log(\"Transaction confirmation timed out.\");\n    }, limit * 5000);\n\n    // Start listening for confirmations and clear timeout on completion.\n    onConfirmed().finally(() => clearTimeout(timeoutId));\n  }",
          "documentation": "Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "evaluateTx",
          "signature": "async evaluateTx(tx: string): Promise<Omit<Action, \"data\">[]> {\n\n    const report = await this.submitClient.evalTx(hexToBytes(tx));\n    const evalResult = report.report[0]!.chain.value?.redeemers!;\n\n    const tagMap: { [key: number]: RedeemerTagType } = {\n      // 0: \"UNSPECIFIED\",   // REDEEMER_PURPOSE_UNSPECIFIED\n      1: \"SPEND\",   // REDEEMER_PURPOSE_SPEND\n      2: \"MINT\",    // REDEEMER_PURPOSE_MINT\n      3: \"CERT\",    // REDEEMER_PURPOSE_CERT\n      4: \"REWARD\",  // REDEEMER_PURPOSE_REWARD\n      5: \"VOTE\",    // REDEEMER_PURPOSE_VOTE\n      6: \"PROPOSE\", // REDEEMER_PURPOSE_PROPOSE\n    };\n\n    const result: Omit<Action, \"data\">[] = [];\n\n    evalResult.map((action: spec.cardano.Redeemer) => {\n      result.push({\n        tag: tagMap[action.purpose!]!,\n        index: action.index,\n        budget: { mem: Number(action.exUnits!.memory), steps: Number(action.exUnits!.steps) },\n      });\n    })\n\n    return result;\n\n  }",
          "documentation": "Evaluates the resources required to execute the transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "submitTx",
          "signature": "async submitTx(tx: string): Promise<string> {\n    const cbor = toBytes(tx);\n    const hash = await this.submitClient.submitTx(cbor);\n    return bytesToHex(hash);\n  }",
          "documentation": "Submit a serialized transaction to the network.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAccountInfo",
          "signature": "fetchAccountInfo(address: string): Promise<AccountInfo> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "Obtain information about a specific stake account.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressAssets",
          "signature": "async fetchAddressAssets(\n    address: string,\n  ): Promise<{ [key: string]: string }> {\n    const utxos = await this.fetchAddressUTxOs(address);\n    return utxosToAssets(utxos);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressUTxOs",
          "signature": "async fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]> {\n    const addressBytes = hexToBytes(Address.fromBech32(address).toBytes());\n\n    const utxoSearchResult =\n      await this.queryClient.searchUtxosByAddress(addressBytes);\n\n    return utxoSearchResult\n      .map((item) => {\n        const utxo = this._rpcUtxoToMeshUtxo(item.txoRef, item.parsedValued!);\n\n        if (asset) {\n          // Check if the output amount contains the specified asset\n          if (\n            utxo.output.amount.some((amountItem) => amountItem.unit === asset)\n          ) {\n            return utxo; // Return the utxo if asset matches\n          }\n          // If the asset does not match, return undefined\n          return undefined;\n        }\n\n        // If no asset is specified, return the utxo directly\n        return utxo;\n      })\n      .filter((utxo) => utxo !== undefined); // Filter out undefined results\n  }",
          "documentation": "Fetches the UTxOs for a given address.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressTxs",
          "signature": "async fetchAddressTxs(\n    address: string,\n    option: IFetcherOptions = { maxPage: 100, order: \"desc\" },\n  ): Promise<TransactionInfo[]> {\n    // open for contribution, see blockfrost.ts for reference\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "Unimplemented - open for contribution\n\nTransactions for an address. The `TransactionInfo` would only return the `hash`, `inputs`, and `outputs`.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAssetAddresses",
          "signature": "fetchAssetAddresses(\n    asset: string,\n  ): Promise<{ address: string; quantity: string }[]> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "Unimplemented - open for contribution\n\nFetches the asset addresses for a given asset.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAssetMetadata",
          "signature": "fetchAssetMetadata(asset: string): Promise<AssetMetadata> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "Unimplemented - open for contribution\n\nFetches the metadata for a given asset.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchBlockInfo",
          "signature": "fetchBlockInfo(hash: string): Promise<BlockInfo> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "Unimplemented - open for contribution\n\nFetches the block information for a given block hash.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchCollectionAssets",
          "signature": "fetchCollectionAssets(\n    policyId: string,\n    cursor?: number | string,\n  ): Promise<{ assets: Asset[]; next?: string | number | null }> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "Unimplemented - open for contribution\n\nFetches the collection assets for a given policy ID.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchHandle",
          "signature": "fetchHandle(handle: string): Promise<object> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "Unimplemented - open for contribution\n\nFetches the information (AssetMetadata) for a given handle.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchHandleAddress",
          "signature": "fetchHandleAddress(handle: string): Promise<string> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "Unimplemented - open for contribution\n\nResolve the handle's address from the handle.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchProtocolParameters",
          "signature": "async fetchProtocolParameters(epoch = Number.NaN): Promise<Protocol> {\n    const rpcPParams = await this.queryClient.readParams();\n    if (rpcPParams === undefined || rpcPParams === null) {\n      throw new Error(`Error fetching protocol parameters`);\n    }\n    return this._rpcPParamsToProtocol(rpcPParams);\n  }",
          "documentation": "Unimplemented - open for contribution\n\nFetches protocol parameters",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchTxInfo",
          "signature": "fetchTxInfo(hash: string): Promise<TransactionInfo> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "Unimplemented - open for contribution\n\nFetches transaction info for a given hash.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchUTxOs",
          "signature": "async fetchUTxOs(hash: string, index?: number): Promise<UTxO[]> {\n    const utxoSearchResult = await this.queryClient.readUtxosByOutputRef(\n      [{\n        txHash: hexToBytes(hash),\n        outputIndex: index || 0,    // TODO: handle case when index is not provided. Note: readUtxos might not support this, try when readTx is implemented\n      }]\n    );\n    return utxoSearchResult.map((item) => {\n      return this._rpcUtxoToMeshUtxo(item.txoRef, item.parsedValued!);\n    });\n  }",
          "documentation": "Not complete - open for contribution\n\nFetches output UTxOs of a given transaction hash.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchGovernanceProposal",
          "signature": "async fetchGovernanceProposal(\n    txHash: string,\n    certIndex: number,\n  ): Promise<GovernanceProposalInfo> {\n    throw new Error(\"Method not implemented\");\n  }",
          "documentation": "Unimplemented - open for contribution\n\nFetches the governance proposal information.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "get",
          "signature": "get(url: string): Promise<any> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "Unimplemented - open for contribution",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "awaitTransactionConfirmation",
          "signature": "awaitTransactionConfirmation(\n    txId: string,\n    timeout?: number,\n  ): Promise<boolean> {\n    const onConfirmed = (async () => {\n      const updates = this.submitClient.waitForTx(hexToBytes(txId));\n\n      for await (const stage of updates) {\n        if (stage == submit.Stage.CONFIRMED) {\n          return true;\n        }\n      }\n\n      return false;\n    })();\n\n    const onTimeout: Promise<boolean> = new Promise((resolve) =>\n      setTimeout(() => resolve(false), timeout),\n    );\n\n    return Promise.race([onConfirmed, onTimeout]);\n  }",
          "documentation": "Waits for transaction confirmation within a given timeout.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "_rpcUtxoToMeshUtxo",
          "signature": "private _rpcUtxoToMeshUtxo(\n    rpcTxoRef: spec.query.TxoRef,\n    rpcTxOutput: spec.cardano.TxOutput,\n  ): UTxO {\n    const amount: Asset[] = [\n      {\n        unit: \"lovelace\",\n        quantity: rpcTxOutput.coin.toString(),\n      },\n    ];\n    rpcTxOutput.assets.forEach((ma) => {\n      ma.assets.forEach((asset) => {\n        amount.push({\n          unit:\n            Buffer.from(ma.policyId).toString(\"hex\") +\n            Buffer.from(asset.name).toString(\"hex\"),\n          quantity: asset.outputCoin.toString(),\n        });\n      });\n    });\n\n    let dataHash: string | undefined = undefined;\n    let plutusData: string | undefined = undefined;\n\n    if (rpcTxOutput.datum !== undefined) {\n      if (\n        rpcTxOutput.datum?.originalCbor &&\n        rpcTxOutput.datum.originalCbor.length > 0\n      ) {\n        dataHash = Buffer.from(rpcTxOutput.datum.hash).toString(\"hex\");\n        plutusData = Buffer.from(rpcTxOutput.datum.originalCbor).toString(\n          \"hex\",\n        );\n      } else if (rpcTxOutput.datum?.hash && rpcTxOutput.datum.hash.length > 0) {\n        dataHash = Buffer.from(rpcTxOutput.datum.hash).toString(\"hex\");\n      }\n    }\n\n    let scriptRef: string | undefined = undefined;\n    let scriptHash: string | undefined = undefined;\n\n    if (rpcTxOutput.script !== undefined) {\n      // TODO: Implement scriptRef\n      // TODO: Implement scriptHash\n    }\n\n    return {\n      input: {\n        outputIndex: rpcTxoRef.index,\n        txHash: Buffer.from(rpcTxoRef.hash).toString(\"hex\"),\n      },\n      output: {\n        address: Address.fromBytes(\n          CardanoSDKUtil.HexBlob.fromBytes(rpcTxOutput.address),\n        ).toBech32(),\n        amount: amount,\n        dataHash: dataHash,\n        plutusData: plutusData,\n        scriptRef: scriptRef,\n        scriptHash: scriptHash,\n      },\n    };\n  }",
          "documentation": "Helper function to convert an RPC UTxO object to a Mesh UTxO object.",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_rpcPParamsToProtocol",
          "signature": "private _rpcPParamsToProtocol(rpcPParams: spec.cardano.PParams): Protocol {\n    return castProtocol({\n      coinsPerUtxoSize: Number(rpcPParams.coinsPerUtxoByte),\n      collateralPercent: Number(rpcPParams.collateralPercentage),\n      decentralisation: 0, // Deprecated in Babbage era.\n      keyDeposit: Number(rpcPParams.stakeKeyDeposit),\n      maxBlockExMem: Number(rpcPParams.maxExecutionUnitsPerBlock?.memory),\n      maxBlockExSteps: Number(rpcPParams.maxExecutionUnitsPerBlock?.steps),\n      maxBlockHeaderSize: Number(rpcPParams.maxBlockHeaderSize),\n      maxBlockSize: Number(rpcPParams.maxBlockBodySize),\n      maxCollateralInputs: Number(rpcPParams.maxCollateralInputs),\n      maxTxExMem: Number(rpcPParams.maxExecutionUnitsPerTransaction?.memory),\n      maxTxExSteps: Number(rpcPParams.maxExecutionUnitsPerTransaction?.steps),\n      maxTxSize: Number(rpcPParams.maxTxSize),\n      maxValSize: Number(rpcPParams.maxValueSize),\n      minFeeA: Number(rpcPParams.minFeeCoefficient),\n      minFeeB: Number(rpcPParams.minFeeConstant),\n      minPoolCost: Number(rpcPParams.minPoolCost),\n      poolDeposit: Number(rpcPParams.poolDeposit),\n      priceMem: Number(rpcPParams.prices?.memory),\n      priceStep: Number(rpcPParams.prices?.steps),\n    });\n  }",
          "documentation": "Converts RPC protocol parameters to a Mesh Protocol object.",
          "static": false,
          "visibility": "private"
        }
      ],
      "properties": [
        {
          "name": "queryClient",
          "type": "CardanoQueryClient",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "submitClient",
          "type": "CardanoSubmitClient",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "module": "utxo-rpc",
      "source": "mesh-provider"
    },
    {
      "name": "YaciProvider",
      "documentation": "Yaci DevKit is a development tool designed for rapid and efficient Cardano blockchain development. It allows developers to create and destroy custom Cardano devnets in seconds, providing fast feedback loops and simplifying the iteration process.\n\nGet started:\n```typescript\nimport { YaciProvider } from \"@meshsdk/core\";\nconst provider = new YaciProvider('<YACI_URL>', '<OPTIONAL_ADMIN_URL>');\n```",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/yaci.ts",
      "extends": null,
      "implements": [
        "IFetcher",
        "IListener",
        "ISubmitter",
        "IEvaluator"
      ],
      "methods": [
        {
          "name": "fetchAccountInfo",
          "signature": "async fetchAccountInfo(address: string): Promise<AccountInfo> {\n    const rewardAddress = address.startsWith(\"addr\")\n      ? resolveRewardAddress(address)\n      : address;\n\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `accounts/${rewardAddress}`,\n      );\n\n      if (status === 200)\n        return <AccountInfo>{\n          poolId: data.pool_id,\n          active: data.active || data.active_epoch !== null,\n          balance: data.controlled_amount,\n          rewards: data.withdrawable_amount,\n          withdrawals: data.withdrawals_sum,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Obtain information about a specific stake account.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressAssets",
          "signature": "async fetchAddressAssets(\n    address: string,\n  ): Promise<{ [key: string]: string }> {\n    const utxos = await this.fetchAddressUTxOs(address);\n    return utxosToAssets(utxos);\n  }",
          "documentation": "Fetches the assets for a given address.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressUTxOs",
          "signature": "async fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]> {\n    const filter = asset !== undefined ? `/${asset}` : \"\";\n    const url = `addresses/${address}/utxos` + filter;\n\n    const paginateUTxOs = async (\n      page = 1,\n      utxos: UTxO[] = [],\n    ): Promise<UTxO[]> => {\n      const { data, status } = await this._axiosInstance.get(\n        `${url}?page=${page}`,\n      );\n\n      if (status === 200)\n        return data.length > 0\n          ? paginateUTxOs(page + 1, [\n              ...utxos,\n              ...(await Promise.all(\n                data.map((utxo: any) => this.toUTxO(utxo, utxo.tx_hash)),\n              )),\n            ])\n          : utxos;\n\n      throw parseHttpError(data);\n    };\n\n    try {\n      return await paginateUTxOs();\n    } catch (error) {\n      return [];\n    }\n  }",
          "documentation": "UTXOs of the address.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressTxs",
          "signature": "async fetchAddressTxs(\n    address: string,\n    option: IFetcherOptions = { maxPage: 100, order: \"desc\" },\n  ): Promise<TransactionInfo[]> {\n    // open for contribution, see blockfrost.ts for reference\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "Unimplemented - open for contribution\n\nTransactions for an address. The `TransactionInfo` would only return the `hash`, `inputs`, and `outputs`.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAssetAddresses",
          "signature": "async fetchAssetAddresses(\n    asset: string,\n  ): Promise<{ address: string; quantity: string }[]> {\n    const paginateAddresses = async <T>(\n      page = 1,\n      addresses: T[] = [],\n    ): Promise<T[]> => {\n      const { policyId, assetName } = parseAssetUnit(asset);\n      const { data, status } = await this._axiosInstance.get(\n        `assets/${policyId}${assetName}/addresses?page=${page}`,\n      );\n\n      if (status === 200)\n        return data.length > 0\n          ? paginateAddresses(page + 1, [...addresses, ...data])\n          : addresses;\n\n      throw parseHttpError(data);\n    };\n\n    try {\n      return await paginateAddresses<{ address: string; quantity: string }>();\n    } catch (error) {\n      return [];\n    }\n  }",
          "documentation": "Fetches the asset addresses for a given asset.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAssetMetadata",
          "signature": "async fetchAssetMetadata(asset: string): Promise<AssetMetadata> {\n    try {\n      const { policyId, assetName } = parseAssetUnit(asset);\n      const { data, status } = await this._axiosInstance.get(\n        `assets/${policyId}${assetName}`,\n      );\n\n      if (status === 200)\n        return <AssetMetadata>{\n          ...data.onchain_metadata,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetches the metadata for a given asset.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchBlockInfo",
          "signature": "async fetchBlockInfo(hash: string): Promise<BlockInfo> {\n    try {\n      const { data, status } = await this._axiosInstance.get(`blocks/${hash}`);\n\n      if (status === 200)\n        return <BlockInfo>{\n          confirmations: data.confirmations,\n          epoch: data.epoch,\n          epochSlot: data.epoch_slot.toString(),\n          fees: data.fees,\n          hash: data.hash,\n          nextBlock: data.next_block ?? \"\",\n          operationalCertificate: data.op_cert,\n          output: data.output ?? \"0\",\n          previousBlock: data.previous_block,\n          size: data.size,\n          slot: data.slot.toString(),\n          slotLeader: data.slot_leader ?? \"\",\n          time: data.time,\n          txCount: data.tx_count,\n          VRFKey: data.block_vrf,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetches the block information for a given block hash.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchCollectionAssets",
          "signature": "async fetchCollectionAssets(\n    policyId: string,\n    cursor = 1,\n  ): Promise<{ assets: Asset[]; next: string | number | null }> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `assets/policy/${policyId}?page=${cursor}`,\n      );\n\n      if (status === 200)\n        return {\n          assets: data.map((asset: any) => ({\n            unit: asset.asset,\n            quantity: asset.quantity,\n          })),\n          next: data.length === 100 ? cursor + 1 : null,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      return { assets: [], next: null };\n    }\n  }",
          "documentation": "Fetches the list of assets for a given policy ID.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchHandle",
          "signature": "async fetchHandle(handle: string): Promise<object> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchHandleAddress",
          "signature": "async fetchHandleAddress(handle: string): Promise<string> {\n    try {\n      const assetName = fromUTF8(handle.replace(\"$\", \"\"));\n      const { data, status } = await this._axiosInstance.get(\n        `assets/${SUPPORTED_HANDLES[1]}${assetName}/addresses`,\n      );\n\n      if (status === 200) return data[0].address;\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchProtocolParameters",
          "signature": "async fetchProtocolParameters(epoch = Number.NaN): Promise<Protocol> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `epochs/${isNaN(epoch) ? \"latest\" : epoch}/parameters`,\n      );\n\n      if (status === 200)\n        return castProtocol({\n          coinsPerUtxoSize: data.coins_per_utxo_size,\n          collateralPercent: data.collateral_percent,\n          decentralisation: data.decentralisation_param,\n          epoch: data.epoch,\n          keyDeposit: data.key_deposit,\n          maxBlockExMem: data.max_block_ex_mem,\n          maxBlockExSteps: data.max_block_ex_steps,\n          maxBlockHeaderSize: data.max_block_header_size,\n          maxBlockSize: data.max_block_size,\n          maxCollateralInputs: data.max_collateral_inputs,\n          maxTxExMem: data.max_tx_ex_mem,\n          maxTxExSteps: data.max_tx_ex_steps,\n          maxTxSize: data.max_tx_size,\n          maxValSize: data.max_val_size,\n          minFeeA: data.min_fee_a,\n          minFeeB: data.min_fee_b,\n          minPoolCost: data.min_pool_cost,\n          poolDeposit: data.pool_deposit,\n          priceMem: data.price_mem,\n          priceStep: data.price_step,\n        });\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetch the latest protocol parameters.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchTxInfo",
          "signature": "async fetchTxInfo(hash: string): Promise<TransactionInfo> {\n    try {\n      const { data, status } = await this._axiosInstance.get(`txs/${hash}`);\n\n      if (status === 200)\n        return <TransactionInfo>{\n          block: data.block,\n          deposit: data.deposit,\n          fees: data.fees,\n          hash: data.hash,\n          index: data.index,\n          invalidAfter: data.invalid_hereafter ?? \"\",\n          invalidBefore: data.invalid_before ?? \"\",\n          slot: data.slot.toString(),\n          size: data.size,\n        };\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetches the transaction information for a given transaction hash.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchUTxOs",
          "signature": "async fetchUTxOs(hash: string, index?: number): Promise<UTxO[]> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `txs/${hash}/utxos`,\n      );\n      if (status === 200) {\n        const bfOutputs = data.outputs as YaciUTxO[];\n        const outputsPromises: Promise<UTxO>[] = [];\n        bfOutputs.forEach((output) => {\n          outputsPromises.push(this.toUTxO(output, hash));\n        });\n        const outputs = await Promise.all(outputsPromises);\n\n        if (index !== undefined) {\n          return outputs.filter((utxo) => utxo.input.outputIndex === index);\n        }\n\n        return outputs;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Get UTxOs for a given hash.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchGovernanceProposal",
          "signature": "async fetchGovernanceProposal(\n    txHash: string,\n    certIndex: number,\n  ): Promise<GovernanceProposalInfo> {\n    throw new Error(\"Method not implemented\");\n  }",
          "documentation": "Unimplemented - open for contribution\n\nFetches the governance proposal information.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "get",
          "signature": "async get(url: string): Promise<any> {\n    try {\n      const { data, status } = await this._axiosInstance.get(url);\n      if (status === 200) {\n        return data;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "onTxConfirmed",
          "signature": "onTxConfirmed(txHash: string, callback: () => void, limit = 100): void {\n    let attempts = 0;\n\n    const checkTx = setInterval(() => {\n      if (attempts >= limit) clearInterval(checkTx);\n\n      this.fetchTxInfo(txHash)\n        .then((txInfo) => {\n          this.fetchBlockInfo(txInfo.block)\n            .then((blockInfo) => {\n              if (blockInfo?.confirmations > 0) {\n                clearInterval(checkTx);\n                callback();\n              }\n            })\n            .catch(() => {\n              attempts += 1;\n            });\n        })\n        .catch(() => {\n          attempts += 1;\n        });\n    }, 5_000);\n  }",
          "documentation": "Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "submitTx",
          "signature": "async submitTx(txHex: string): Promise<string> {\n    try {\n      const headers = { \"Content-Type\": \"text/plain\" };\n      const { status, data } = await this._axiosInstance.post(\n        \"/tx/submit\",\n        txHex,\n        {\n          headers,\n        },\n      );\n\n      if (status === 202) {\n        return data;\n      }\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Submit a serialized transaction to the network.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "evaluateTx",
          "signature": "async evaluateTx(txHex: string): Promise<Omit<Action, \"data\">[]> {\n    try {\n      const headers = { \"Content-Type\": \"application/cbor\" };\n      const { status, data } = await this._axiosInstance.post(\n        \"utils/txs/evaluate\",\n        txHex,\n        {\n          headers,\n        },\n      );\n\n      if (status === 202 && data.result.EvaluationResult) {\n        const tagMap: { [key: string]: RedeemerTagType } = {\n          spend: \"SPEND\",\n          mint: \"MINT\",\n          certificate: \"CERT\",\n          reward: \"REWARD\",\n        };\n        const result: Omit<Action, \"data\">[] = [];\n\n        Object.keys(data.result.EvaluationResult).forEach((key) => {\n          const [tagKey, index] = key.split(\":\");\n          const { memory, steps } = data.result.EvaluationResult[key];\n          result.push({\n            tag: tagMap[tagKey!]!,\n            index: Number(index),\n            budget: { mem: memory, steps },\n          });\n        });\n\n        return result;\n      }\n\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Evaluates the resources required to execute the transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getDevnetInfo",
          "signature": "async getDevnetInfo(): Promise<void> {\n    try {\n      if (this._adminAxiosInstance === undefined)\n        throw parseHttpError(\"Admin URL not provided\");\n      const { status, data } = await this._adminAxiosInstance.get(\n        `local-cluster/api/admin/devnet`,\n      );\n\n      if (status === 200) {\n        return data;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getGenesisByEra",
          "signature": "async getGenesisByEra(era: string): Promise<void> {\n    try {\n      if (this._adminAxiosInstance === undefined)\n        throw parseHttpError(\"Admin URL not provided\");\n      const { status, data } = await this._adminAxiosInstance.get(\n        `local-cluster/api/admin/devnet/genesis/${era}`,\n      );\n\n      if (status === 200) {\n        return data;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "addressTopup",
          "signature": "async addressTopup(address: string, amount: string): Promise<void> {\n    try {\n      if (this._adminAxiosInstance === undefined)\n        throw parseHttpError(\"Admin URL not provided\");\n      const headers = { \"Content-Type\": \"application/json\", accept: \"*/*\" };\n      const { status, data } = await this._adminAxiosInstance.post(\n        \"local-cluster/api/addresses/topup\",\n        JSON.stringify({ address: address, adaAmount: parseInt(amount) }),\n        {\n          headers,\n        },\n      );\n\n      if (status === 200) {\n        return data;\n      }\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Topup address with ADA",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchPlutusScriptCBOR",
          "signature": "private async fetchPlutusScriptCBOR(scriptHash: string): Promise<string> {\n    const { data, status } = await this._axiosInstance.get(\n      `scripts/${scriptHash}/cbor`,\n    );\n\n    if (status === 200) return data.cbor;\n\n    throw parseHttpError(data);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "fetchNativeScriptJSON",
          "signature": "private async fetchNativeScriptJSON(\n    scriptHash: string,\n  ): Promise<NativeScript> {\n    const { data, status } = await this._axiosInstance.get(\n      `scripts/${scriptHash}/json`,\n    );\n\n    if (status === 200) return data.json;\n\n    throw parseHttpError(data);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "properties": [
        {
          "name": "_axiosInstance",
          "type": "AxiosInstance",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_adminAxiosInstance",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "resolveScriptRef",
          "type": "(scriptHash: string) => Promise<string | undefined>",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "toUTxO",
          "type": "(bfUTxO: YaciUTxO, tx_hash: string) => Promise<UTxO>",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "module": "yaci",
      "source": "mesh-provider"
    },
    {
      "name": "BlockstreamProvider",
      "documentation": "https://github.com/Blockstream/esplora/blob/master/API.md",
      "isExported": true,
      "importPath": "offchain/bitcoin/src/providers/blockstream.ts",
      "extends": null,
      "implements": [
        "IBitcoinProvider"
      ],
      "methods": [
        {
          "name": "fetchAddress",
          "signature": "async fetchAddress(address: string): Promise<AddressInfo> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `/address/${address}`\n      );\n\n      if (status === 200) return data as AddressInfo;\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Get information about an address.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressTransactions",
          "signature": "async fetchAddressTransactions(\n    address: string,\n    last_seen_txid?: string\n  ): Promise<TransactionsInfo[]> {\n    try {\n      const url = last_seen_txid\n        ? `/address/${address}/txs/chain/${last_seen_txid}`\n        : `/address/${address}/txs`;\n      const { data, status } = await this._axiosInstance.get(url);\n\n      if (status === 200) return data as TransactionsInfo[];\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Get transaction history for the specified address, sorted with newest first.\nReturns up to 50 mempool transactions plus the first 25 confirmed transactions. You can request more confirmed transactions using `last_seen_txid`.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressUTxOs",
          "signature": "async fetchAddressUTxOs(address: string): Promise<UTxO[]> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `/address/${address}/utxo`\n      );\n\n      if (status === 200) return data as UTxO[];\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Get the list of unspent transaction outputs associated with the address.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchScript",
          "signature": "async fetchScript(hash: string): Promise<ScriptInfo> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `/scripthash/${hash}`\n      );\n\n      if (status === 200) return data as ScriptInfo;\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Get information about a scripthash.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchScriptTransactions",
          "signature": "async fetchScriptTransactions(\n    hash: string,\n    last_seen_txid?: string\n  ): Promise<TransactionsInfo[]> {\n    try {\n      const url = last_seen_txid\n        ? `/scripthash/${hash}/txs/chain/${last_seen_txid}`\n        : `/scripthash/${hash}/txs`;\n      const { data, status } = await this._axiosInstance.get(url);\n\n      if (status === 200) return data as TransactionsInfo[];\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Get transaction history for the specified scripthash, sorted with newest first.\nReturns up to 50 mempool transactions plus the first 25 confirmed transactions. You can request more confirmed transactions using `last_seen_txid`.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchScriptUTxOs",
          "signature": "async fetchScriptUTxOs(hash: string): Promise<UTxO[]> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `/scripthash/${hash}/utxo`\n      );\n\n      if (status === 200) return data as UTxO[];\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Get the list of unspent transaction outputs associated with the scripthash.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchTransactionStatus",
          "signature": "async fetchTransactionStatus(txid: string): Promise<TransactionsStatus> {\n    try {\n      const { data, status } = await this._axiosInstance.get(\n        `/tx/${txid}/status`\n      );\n\n      if (status === 200) return data as TransactionsStatus;\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetches the status of a transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "submitTx",
          "signature": "async submitTx(tx: string): Promise<string> {\n    try {\n      const { data, status } = await this._axiosInstance.post(\"/tx\", tx, {\n        headers: { \"Content-Type\": \"text/plain\" },\n      });\n\n      if (status === 200) return data as string;\n      throw parseHttpError(data);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Broadcast a raw transaction to the network.\nThe transaction should be provided as hex in the request body. The txid will be returned on success.",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "_axiosInstance",
          "type": "AxiosInstance",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "module": "blockstream",
      "source": "bitcoin"
    },
    {
      "name": "MeshValue",
      "documentation": "MeshValue provide utility to handle the Cardano value manipulation. It offers certain axioms:\n1. No duplication of asset - adding assets with same asset name will increase the quantity of the asset in the same record.\n2. No zero and negative entry - the quantity of the asset should not be zero or negative.\n3. Sanitization of lovelace asset name - the class handle back and forth conversion of lovelace asset name to empty string.\n4. Easy convertion to Cardano data - offer utility to convert into either Mesh Data type and JSON type for its Cardano data representation.",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/data/value.ts",
      "extends": null,
      "implements": [],
      "methods": [],
      "properties": [
        {
          "name": "value",
          "type": "Record<string, bigint>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fromAssets",
          "type": "(assets: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset\").Asset[]) => import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue",
          "documentation": "Converting assets into MeshValue",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "fromValue",
          "type": "(plutusValue: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").Value) => import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue",
          "documentation": "Converting Value (the JSON representation of Cardano data Value) into MeshValue",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "addAsset",
          "type": "(asset: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset\").Asset) => this",
          "documentation": "Add an asset to the Value class's value record.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "addAssets",
          "type": "(assets: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset\").Asset[]) => this",
          "documentation": "Add an array of assets to the Value class's value record.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "negateAsset",
          "type": "(asset: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset\").Asset) => this",
          "documentation": "Substract an asset from the Value class's value record.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "negateAssets",
          "type": "(assets: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset\").Asset[]) => this",
          "documentation": "Subtract an array of assets from the Value class's value record.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "get",
          "type": "(unit: string) => bigint",
          "documentation": "Get the quantity of asset object per unit",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getPolicyAssets",
          "type": "(policyId: string) => import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset\").Asset[]",
          "documentation": "Get all assets that belong to a specific policy ID",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "units",
          "type": "() => string[]",
          "documentation": "Get all asset units",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "geq",
          "type": "(other: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue) => boolean",
          "documentation": "Check if the value is greater than or equal to another value",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "geqUnit",
          "type": "(unit: string, other: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue) => boolean",
          "documentation": "Check if the specific unit of value is greater than or equal to that unit of another value",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "leq",
          "type": "(other: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue) => boolean",
          "documentation": "Check if the value is less than or equal to another value",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "leqUnit",
          "type": "(unit: string, other: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue) => boolean",
          "documentation": "Check if the specific unit of value is less than or equal to that unit of another value",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "eq",
          "type": "(other: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue) => boolean",
          "documentation": "Check if the value is equal to another value",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "eqUnit",
          "type": "(unit: string, other: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue) => boolean",
          "documentation": "Check if the specific unit of value is equal to that unit of another value",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "isEmpty",
          "type": "() => boolean",
          "documentation": "Check if the value is empty",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "merge",
          "type": "(values: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue | import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue[]) => this",
          "documentation": "Merge the given values",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "toAssets",
          "type": "() => import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/asset\").Asset[]",
          "documentation": "Convert the MeshValue object into an array of Asset",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "toData",
          "type": "() => import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MValue",
          "documentation": "Convert the MeshValue object into Cardano data Value in Mesh Data type",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "toJSON",
          "type": "() => import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").Value",
          "documentation": "Convert the MeshValue object into a JSON representation of Cardano data Value",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "value",
      "source": "mesh-common"
    },
    {
      "name": "TxTester",
      "documentation": "TxTester class for evaluating transactions",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/tx-tester/index.ts",
      "extends": null,
      "implements": [],
      "methods": [
        {
          "name": "addTrace",
          "signature": "addTrace(funcName: string, message: string): void {\n    const msg = `[Error - ${funcName}]: ${message}`;\n    this.traces.push(msg);\n  }",
          "documentation": "Add a trace to the TxTester",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "success",
          "signature": "success(): boolean {\n    return this.traces.length === 0;\n  }",
          "documentation": "Check if the transaction evaluation was successful",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "errors",
          "signature": "errors(): string {\n    if (this.traces.length > 0) {\n      return `${this.traces}`;\n    } else {\n      return \"No errors\";\n    }\n  }",
          "documentation": "Get the error messages if any",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "txBody",
          "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/index\").MeshTxBuilderBody",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "inputsEvaluating",
          "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/txin\").TxIn[]",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "outputsEvaluating",
          "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/types/transaction-builder/output\").Output[]",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "traces",
          "type": "string[]",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "validAfter",
          "type": "(requiredTimestamp: number) => this",
          "documentation": "Checks if the transaction is valid after a specified timestamp.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "validBefore",
          "type": "(requiredTimestamp: number) => this",
          "documentation": "Checks if the transaction is valid before a specified timestamp.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "keySigned",
          "type": "(keyHash: string) => this",
          "documentation": "Checks if a specific key is signed in the transaction.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "oneOfKeysSigned",
          "type": "(keyHashes: string[]) => this",
          "documentation": "Checks if any one of the specified keys is signed in the transaction.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "allKeysSigned",
          "type": "(keyHashes: string[]) => this",
          "documentation": "Checks if all specified keys are signed in the transaction.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "tokenMinted",
          "type": "(policyId: string, assetName: string, quantity: number) => this",
          "documentation": "Checks if a specific token is minted in the transaction.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "onlyTokenMinted",
          "type": "(policyId: string, assetName: string, quantity: number) => this",
          "documentation": "Checks if a specific token is minted in the transaction and that it is the only mint.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "policyOnlyMintedToken",
          "type": "(policyId: string, assetName: string, quantity: number) => this",
          "documentation": "Checks if a specific token is minted in the transaction, ensuring that it is the only mint for the given policy ID.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "checkPolicyOnlyBurn",
          "type": "(policyId: string) => boolean",
          "documentation": "Checks if a specific policy ID is burned in the transaction, ensuring that it is the only minting (i.e. burning item).",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "allInputs",
          "type": "() => this",
          "documentation": "Not apply filter to inputs",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "inputsAt",
          "type": "(address: string) => this",
          "documentation": "Filter inputs by address",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "inputsWith",
          "type": "(unit: string) => this",
          "documentation": "Filter inputs by unit",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "inputsWithPolicy",
          "type": "(policyId: string) => this",
          "documentation": "Filter inputs by policy ID",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "inputsAtWithPolicy",
          "type": "(address: string, policyId: string) => this",
          "documentation": "Filter inputs by address and policy ID",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "inputsAtWith",
          "type": "(address: string, unit: string) => this",
          "documentation": "Filter inputs by address and unit",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "inputsValue",
          "type": "(expectedValue: any) => this",
          "documentation": "Check if inputs contain the expected value.\n*Reminder - It must be called after filtering methods for inputs*",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "allOutputs",
          "type": "() => this",
          "documentation": "Not apply filter to outputs",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "outputsAt",
          "type": "(address: string) => this",
          "documentation": "Filter outputs by address",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "outputsWith",
          "type": "(unit: string) => this",
          "documentation": "Filter outputs by unit",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "outputsWithPolicy",
          "type": "(policyId: string) => this",
          "documentation": "Filter outputs by policy ID",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "outputsAtWithPolicy",
          "type": "(address: string, policyId: string) => this",
          "documentation": "Filter outputs by address and policy ID",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "outputsAtWith",
          "type": "(address: string, unit: string) => this",
          "documentation": "Filter outputs by address and unit",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "outputsValue",
          "type": "(expectedValue: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-common/src/data/value\").MeshValue) => this",
          "documentation": "Check if outputs contain the expected value.\n*Reminder - It must be called after filtering methods for outputs*",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "outputsInlineDatumExist",
          "type": "(datumCbor: string) => this",
          "documentation": "Check if outputs contain a specific inline datum.\n*Reminder - It must be called after filtering methods for outputs*",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "index",
      "source": "mesh-common"
    },
    {
      "name": "AssetFingerprint",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/utils/asset-fingerprint.ts",
      "extends": null,
      "implements": [],
      "methods": [
        {
          "name": "fromHash",
          "signature": "static fromHash(hash: Uint8Array): AssetFingerprint {\n    return new AssetFingerprint(hash);\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "fromParts",
          "signature": "static fromParts(\n    policyId: Uint8Array,\n    assetName: Uint8Array,\n  ): AssetFingerprint {\n    // see https://github.com/cardano-foundation/CIPs/pull/64\n    const hashBuf = blake2b(20)\n      .update(new Uint8Array([...policyId, ...assetName]))\n      .digest(\"binary\");\n\n    return AssetFingerprint.fromHash(hashBuf);\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "fromBech32",
          "signature": "static fromBech32(fingerprint: string): AssetFingerprint {\n    const { prefix, words } = bech32.decode(fingerprint);\n    if (prefix !== DATA) {\n      throw new Error(\"Invalid asset fingerprint\");\n    }\n\n    const hashBuf = Buffer.from(bech32.fromWords(words));\n    return AssetFingerprint.fromHash(hashBuf);\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "fingerprint",
          "signature": "fingerprint(): string {\n    const words = bech32.toWords(this.hashBuf);\n    return bech32.encode(DATA, words);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "hash",
          "signature": "hash(): string {\n    return Buffer.from(this.hashBuf).toString(\"hex\");\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "prefix",
          "signature": "prefix(): string {\n    return DATA;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "checksum",
          "signature": "checksum(): string {\n    return this.fingerprint().slice(-6);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "hashBuf",
          "type": "Uint8Array<ArrayBufferLike>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "asset-fingerprint",
      "source": "mesh-common"
    },
    {
      "name": "BigNum",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/utils/big-num.ts",
      "extends": null,
      "implements": [],
      "methods": [
        {
          "name": "new",
          "signature": "static new(value: number | string | bigint | undefined): BigNum {\n    if (!value) {\n      return new BigNum(0);\n    }\n    return new BigNum(value);\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "divFloor",
          "signature": "divFloor(other: BigNum): BigNum {\n    this.value = this.value / other.value;\n    return this;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "checkedMul",
          "signature": "checkedMul(other: BigNum): BigNum {\n    this.value *= other.value;\n    return this;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "checkedAdd",
          "signature": "checkedAdd(other: BigNum): BigNum {\n    this.value += other.value;\n    return this;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "checkedSub",
          "signature": "checkedSub(other: BigNum): BigNum {\n    this.value -= other.value;\n    return this;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "clampedSub",
          "signature": "clampedSub(other: BigNum): BigNum {\n    const result = this.value - other.value;\n    this.value = result < 0n ? 0n : result;\n    return this;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "lessThan",
          "signature": "lessThan(other: BigNum): boolean {\n    return this.value < other.value;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "compare",
          "signature": "compare(other: BigNum): -1 | 0 | 1 {\n    if (this.value === other.value) {\n      return 0;\n    } else if (this.value < other.value) {\n      return -1;\n    } else {\n      return 1;\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "toString",
          "signature": "toString(): string {\n    return this.value.toString();\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "value",
          "type": "bigint",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "big-num",
      "source": "mesh-common"
    },
    {
      "name": "UtxoSelection",
      "documentation": "All UTxO selection algorithms follows below's interface\n\nSupported algorithms:\n- largestFirst - CIP2 suggested algorithm\n- largestFirstMultiAsset - CIP2 suggested algorithm\n- keepRelevant - CIP2 suggested algorithm\n- experimental - The always evolving algorithm according to the latest research",
      "isExported": true,
      "importPath": "offchain/mesh-common/src/utxo-selection/index.ts",
      "extends": null,
      "implements": [],
      "methods": [
        {
          "name": "largestFirst",
          "signature": "largestFirst(requiredAssets: Map<Unit, Quantity>, inputs: UTxO[]) {\n    const lovelaceAmount = requiredAssets.get(\"lovelace\") ?? \"0\";\n    const requiredAssetWithThreshold =\n      BigInt(lovelaceAmount) + BigInt(this.threshold);\n    return largestFirst(\n      requiredAssetWithThreshold.toString(),\n      inputs,\n      this.includeTxFees,\n    );\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "keepRelevant",
          "signature": "keepRelevant(requiredAssets: Map<Unit, Quantity>, inputs: UTxO[]) {\n    return keepRelevant(requiredAssets, inputs, this.threshold);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "largestFirstMultiAsset",
          "signature": "largestFirstMultiAsset(requiredAssets: Map<Unit, Quantity>, inputs: UTxO[]) {\n    const lovelaceAmount = requiredAssets.get(\"lovelace\") ?? \"0\";\n    requiredAssets.set(\n      \"lovelace\",\n      (BigInt(lovelaceAmount) + BigInt(this.threshold)).toString(),\n    );\n    return largestFirstMultiAsset(requiredAssets, inputs, this.includeTxFees);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "experimental",
          "signature": "experimental(requiredAssets: Map<Unit, Quantity>, inputs: UTxO[]) {\n    return experimentalSelectUtxos(requiredAssets, inputs, this.threshold);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "threshold",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "includeTxFees",
          "type": "boolean",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "module": "index",
      "source": "mesh-common"
    },
    {
      "name": "MeshAsteriaContract",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/asteria/offchain.ts",
      "extends": "MeshTxInitiator",
      "implements": [],
      "methods": [],
      "properties": [],
      "module": "offchain",
      "source": "mesh-contract"
    },
    {
      "name": "MeshEscrowContract",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/escrow/offchain.ts",
      "extends": "MeshTxInitiator",
      "implements": [],
      "methods": [],
      "properties": [
        {
          "name": "scriptCbor",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "scriptAddress",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getScriptCbor",
          "type": "() => any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "initiateEscrow",
          "type": "(escrowAmount: Asset[]) => Promise<string>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "cancelEscrow",
          "type": "(escrowUtxo: UTxO) => Promise<string>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "recipientDeposit",
          "type": "(escrowUtxo: UTxO, depositAmount: Asset[]) => Promise<string>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "completeEscrow",
          "type": "(escrowUtxo: UTxO) => Promise<string>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUtxoByTxHash",
          "type": "(txHash: string) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "offchain",
      "source": "mesh-contract"
    },
    {
      "name": "MeshGiftCardContract",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/giftcard/offchain.ts",
      "extends": "MeshTxInitiator",
      "implements": [],
      "methods": [],
      "properties": [
        {
          "name": "tokenNameHex",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "paramUtxo",
          "type": "UTxO",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "giftCardCbor",
          "type": "(tokenNameHex: string, utxoTxHash: string, utxoTxId: number) => any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "redeemCbor",
          "type": "(tokenNameHex: string, policyId: string) => any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "createGiftCard",
          "type": "(tokenName: string, giftValue: Asset[]) => Promise<string>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "redeemGiftCard",
          "type": "(giftCardUtxo: UTxO) => Promise<string>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUtxoByTxHash",
          "type": "(txHash: string) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "offchain",
      "source": "mesh-contract"
    },
    {
      "name": "MeshHelloWorldContract",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/hello-world/offchain.ts",
      "extends": "MeshTxInitiator",
      "implements": [],
      "methods": [],
      "properties": [
        {
          "name": "scriptCbor",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "scriptAddress",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getScriptCbor",
          "type": "() => any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "lockAsset",
          "type": "(assets: Asset[]) => Promise<string>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "unlockAsset",
          "type": "(scriptUtxo: UTxO, message: string) => Promise<string>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUtxoByTxHash",
          "type": "(txHash: string) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "offchain",
      "source": "mesh-contract"
    },
    {
      "name": "MeshMarketplaceContract",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/marketplace/offchain.ts",
      "extends": "MeshTxInitiator",
      "implements": [],
      "methods": [],
      "properties": [
        {
          "name": "ownerAddress",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "feePercentageBasisPoint",
          "type": "number",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "scriptCbor",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "scriptAddress",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getScriptCbor",
          "type": "(pubKeyHash: string, stakeCredentialHash: string, feePercentageBasisPoint: number) => any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "listAsset",
          "type": "(asset: string, price: number) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "delistAsset",
          "type": "(marketplaceUtxo: UTxO) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "purchaseAsset",
          "type": "(marketplaceUtxo: UTxO) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "relistAsset",
          "type": "(marketplaceUtxo: UTxO, newPrice: number) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUtxoByTxHash",
          "type": "(txHash: string) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getCompiledCode",
          "type": "(version?: number) => string",
          "documentation": "",
          "static": true,
          "visibility": "public"
        }
      ],
      "module": "offchain",
      "source": "mesh-contract"
    },
    {
      "name": "MeshPaymentSplitterContract",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/payment-splitter/offchain.ts",
      "extends": "MeshTxInitiator",
      "implements": [],
      "methods": [],
      "properties": [
        {
          "name": "scriptCbor",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "scriptAddress",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "payees",
          "type": "string[]",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "wrapPayees",
          "type": "(payees: string[]) => any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getScriptCbor",
          "type": "() => any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "sendLovelaceToSplitter",
          "type": "(lovelaceAmount: number) => Promise<string>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "triggerPayout",
          "type": "() => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "offchain",
      "source": "mesh-contract"
    },
    {
      "name": "MeshPlutusNFTContract",
      "documentation": "Mesh Plutus NFT contract class\n\nThis NFT minting script enables users to mint NFTs with an automatically incremented index, which increases by one for each newly minted NFT. \n\nTo facilitate this process, the first step is to set up a one-time minting policy by minting an oracle token. This oracle token is essential as it holds the current state and index of the NFTs, acting as a reference for the minting sequence. \n\nWith each new NFT minted, the token index within the oracle is incremented by one, ensuring a consistent and orderly progression in the numbering of the NFTs.",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/plutus-nft/offchain.ts",
      "extends": "MeshTxInitiator",
      "implements": [],
      "methods": [],
      "properties": [
        {
          "name": "collectionName",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "paramUtxo",
          "type": "UTxO",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "oracleAddress",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getOracleCbor",
          "type": "() => any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getOracleNFTCbor",
          "type": "() => any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getNFTCbor",
          "type": "() => any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "setupOracle",
          "type": "(lovelacePrice: number) => Promise<{ tx: any; paramUtxo: any; }>",
          "documentation": "Set up a one-time minting policy by minting an oracle token. This oracle token is essential as it holds the current state and index of the NFTs, acting as a reference for the minting sequence.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "mintPlutusNFT",
          "type": "(assetMetadata?: any) => Promise<any>",
          "documentation": "Mint NFT token with an automatically incremented index, which increases by one for each newly minted NFT.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getOracleData",
          "type": "() => Promise<{ nftIndex: any; policyId: any; lovelacePrice: any; oracleUtxo: any; oracleNftPolicyId: any; feeCollectorAddress: any; feeCollectorAddressObj: any; }>",
          "documentation": "Get the current oracle data.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUtxoByTxHash",
          "type": "(txHash: string) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "offchain",
      "source": "mesh-contract"
    },
    {
      "name": "MeshRoyaltiesContract",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/royalties/offchain.ts",
      "extends": "MeshTxInitiator",
      "implements": [],
      "methods": [],
      "properties": [],
      "module": "offchain",
      "source": "mesh-contract"
    },
    {
      "name": "MeshSwapContract",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/swap/offchain.ts",
      "extends": "MeshTxInitiator",
      "implements": [],
      "methods": [],
      "properties": [
        {
          "name": "scriptCbor",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "scriptAddress",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getScriptCbor",
          "type": "() => any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "initiateSwap",
          "type": "(toProvide: Asset[], toReceive: Asset[]) => Promise<string>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "acceptSwap",
          "type": "(swapUtxo: UTxO) => Promise<string>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "cancelSwap",
          "type": "(swapUtxo: UTxO) => Promise<string>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUtxoByTxHash",
          "type": "(txHash: string) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "offchain",
      "source": "mesh-contract"
    },
    {
      "name": "MeshVestingContract",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/vesting/offchain.ts",
      "extends": "MeshTxInitiator",
      "implements": [],
      "methods": [],
      "properties": [
        {
          "name": "scriptCbor",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "scriptAddress",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getScriptCbor",
          "type": "() => any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "depositFund",
          "type": "(amount: Asset[], lockUntilTimeStampMs: number, beneficiary: string) => Promise<string>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "withdrawFund",
          "type": "(vestingUtxo: UTxO) => Promise<string>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUtxoByTxHash",
          "type": "(txHash: string) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "offchain",
      "source": "mesh-contract"
    },
    {
      "name": "CSLSerializer",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-core-csl/src/core/serializer.ts",
      "extends": null,
      "implements": [
        "IMeshTxSerializer"
      ],
      "methods": [
        {
          "name": "serializeTxBody",
          "signature": "serializeTxBody(\n    txBody: MeshTxBuilderBody,\n    protocolParams?: Protocol,\n  ): string {\n    const txBodyJson = JSONbig.stringify(meshTxBuilderBodyToObj(txBody));\n    const params = JSONbig.stringify(protocolParams || this.protocolParams);\n\n    const txBuildResult = csl.js_serialize_tx_body(txBodyJson, params);\n    if (txBuildResult.get_status() !== \"success\") {\n      throw new Error(`txBuildResult error: ${txBuildResult.get_error()}`);\n    }\n    return txBuildResult.get_data();\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "addSigningKeys",
          "signature": "addSigningKeys(txHex: string, signingKeys: string[]): string {\n    if (signingKeys.length > 0) {\n      return signTransaction(txHex, signingKeys);\n    }\n    return txHex;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "serializeData",
          "signature": "serializeData(data: BuilderData): string {\n    return builderDataToCbor(data);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "serializeAddress",
          "signature": "serializeAddress(\n    address: Partial<DeserializedAddress>,\n    networkId?: number,\n  ): string {\n    return serialzeAddress(address, networkId);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "serializePoolId",
          "signature": "serializePoolId(hash: string): string {\n    return serializePoolId(hash);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "serializeRewardAddress",
          "signature": "serializeRewardAddress(\n    stakeKeyHash: string,\n    isScriptHash?: boolean,\n    network_id?: 0 | 1,\n  ): string {\n    return isScriptHash\n      ? scriptHashToRewardAddress(stakeKeyHash, network_id)\n      : keyHashToRewardAddress(stakeKeyHash, network_id);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "serializeOutput",
          "signature": "serializeOutput(output: Output): string {\n    let cslOutputBuilder = csl.TransactionOutputBuilder.new().with_address(\n      csl.Address.from_bech32(output.address),\n    );\n    if (output.datum?.type === \"Hash\") {\n      cslOutputBuilder.with_data_hash(\n        csl.hash_plutus_data(castDataToPlutusData(output.datum.data)),\n      );\n    } else if (output.datum?.type === \"Inline\") {\n      cslOutputBuilder.with_plutus_data(\n        castDataToPlutusData(output.datum.data),\n      );\n    } else if (output.datum?.type === \"Embedded\") {\n      throw new Error(\"Embedded datum not supported\");\n    }\n    if (output.referenceScript) {\n      switch (output.referenceScript.version) {\n        case \"V1\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v1(),\n              ),\n            ),\n          );\n          break;\n        }\n        case \"V2\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v2(),\n              ),\n            ),\n          );\n          break;\n        }\n        case \"V3\": {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_plutus_script(\n              csl.PlutusScript.from_hex_with_version(\n                output.referenceScript.code,\n                csl.Language.new_plutus_v3(),\n              ),\n            ),\n          );\n          break;\n        }\n        default: {\n          cslOutputBuilder.with_script_ref(\n            csl.ScriptRef.new_native_script(\n              csl.NativeScript.from_hex(output.referenceScript.code),\n            ),\n          );\n          break;\n        }\n      }\n    }\n\n    return cslOutputBuilder\n      .next()\n      .with_value(toCslValue(output.amount))\n      .build()\n      .to_hex();\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "serializeTxBodyWithMockSignatures",
          "signature": "serializeTxBodyWithMockSignatures(\n    txBuilderBody: MeshTxBuilderBody,\n    protocolParams: Protocol,\n  ): string {\n    const txHex = this.serializeTxBody(txBuilderBody, protocolParams);\n    const cslTx = csl.Transaction.from_hex(txHex);\n    const mockWitnessSet = cslTx.witness_set();\n    const mockVkeyWitnesses = mockWitnessSet.vkeys() ?? csl.Vkeywitnesses.new();\n    const mockBootstrapWitnesses =\n      mockWitnessSet.bootstraps() ?? csl.BootstrapWitnesses.new();\n    for (let i = 0; i < txBuilderBody.expectedNumberKeyWitnesses; i++) {\n      const numberInHex = this.numberToIntegerHex(i);\n      const mockVkey = csl.Vkey.new(\n        csl.PublicKey.from_hex(this.mockPubkey(numberInHex)),\n      );\n\n      const mockSignature = csl.Ed25519Signature.from_hex(\n        this.mockSignature(numberInHex),\n      );\n      mockVkeyWitnesses.add(csl.Vkeywitness.new(mockVkey, mockSignature));\n    }\n    this.meshTxBuilderBody.expectedByronAddressWitnesses.forEach(\n      (bootstrapWitness, i) => {\n        const address = csl.ByronAddress.from_base58(bootstrapWitness);\n        const numberInHex = this.numberToIntegerHex(i);\n        const pubKeyHex = this.mockPubkey(numberInHex);\n        const mockVkey = csl.Vkey.new(csl.PublicKey.from_hex(pubKeyHex));\n        const signature = this.mockSignature(numberInHex);\n        const chainCode = this.mockChainCode(numberInHex);\n        mockBootstrapWitnesses.add(\n          csl.BootstrapWitness.new(\n            mockVkey,\n            csl.Ed25519Signature.from_hex(signature),\n            Buffer.from(chainCode, \"hex\"),\n            address.attributes(),\n          ),\n        );\n      },\n    );\n    mockWitnessSet.set_vkeys(mockVkeyWitnesses);\n    mockWitnessSet.set_bootstraps(mockBootstrapWitnesses);\n    return csl.Transaction.new(\n      cslTx.body(),\n      mockWitnessSet,\n      cslTx.auxiliary_data(),\n    ).to_hex();\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "serializeValue",
          "signature": "serializeValue(value: Asset[]): string {\n    return toCslValue(value).to_hex();\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "mockPubkey",
          "signature": "private mockPubkey(numberInHex: string): string {\n    return \"0\"\n      .repeat(VKEY_PUBKEY_SIZE_BYTES * 2 - numberInHex.length)\n      .concat(numberInHex);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "mockSignature",
          "signature": "private mockSignature(numberInHex: string): string {\n    return \"0\"\n      .repeat(VKEY_SIGNATURE_SIZE_BYTES * 2 - numberInHex.length)\n      .concat(numberInHex);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "properties": [
        {
          "name": "protocolParams",
          "type": "Protocol",
          "documentation": "Set to true to enable verbose logging for the txBodyJson prior going into build",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "meshTxBuilderBody",
          "type": "MeshTxBuilderBody",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "parserTxBody",
          "type": "MeshTxBuilderBody",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "deserializer",
          "type": "IDeserializer",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "resolver",
          "type": "IResolver",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "parser",
          "type": "ITxParser",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "mockChainCode",
          "type": "(numberInHex: string) => string",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "numberToIntegerHex",
          "type": "(number: number) => string",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "module": "serializer",
      "source": "mesh-core-csl"
    },
    {
      "name": "OfflineEvaluator",
      "documentation": "OfflineEvaluator implements the IEvaluator interface to provide offline evaluation of Plutus scripts.\nThis class evaluates Plutus scripts contained in Cardano transactions without requiring network connectivity,\ndetermining their execution costs in terms of memory and CPU steps.\n\nEach script evaluation returns an Action object (excluding the redeemer data) that contains:\n- tag: The type of script being executed (CERT | MINT | REWARD | SPEND | VOTE | PROPOSE)\n- index: Execution index of the script within the transaction\n- budget: Execution costs including:\n  - mem: Memory units required\n  - steps: CPU steps required\n\nExample usage:\n```typescript\nimport { OfflineEvaluator, OfflineFetcher } from '@meshsdk/core';\n\n// Create fetcher and evaluator instances\nconst fetcher = new OfflineFetcher();\nconst evaluator = new OfflineEvaluator(fetcher, 'preprod');\n\n// Add required UTXOs that the transaction references\nfetcher.addUTxOs([\n  {\n    input: {\n      txHash: \"1234...\",\n      outputIndex: 0\n    },\n    output: {\n      address: \"addr1...\",\n      amount: [{ unit: \"lovelace\", quantity: \"1000000\" }],\n      scriptHash: \"abcd...\" // If this is a script UTXO\n    }\n  }\n]);\n\n// Evaluate Plutus scripts in a transaction\ntry {\n  const actions = await evaluator.evaluateTx(transactionCbor);\n  // Example result for a minting script:\n  // [{\n  //   index: 0,\n  //   tag: \"MINT\",\n  //   budget: {\n  //     mem: 508703,    // Memory units used\n  //     steps: 164980381 // CPU steps used\n  //   }\n  // }]\n} catch (error) {\n  console.error('Plutus script evaluation failed:', error);\n}\n```",
      "isExported": true,
      "importPath": "offchain/mesh-core-csl/src/offline-providers/offline-evaluator.ts",
      "extends": null,
      "implements": [
        "IEvaluator"
      ],
      "methods": [
        {
          "name": "evaluateTx",
          "signature": "async evaluateTx(\n    tx: string,\n    additionalUtxos: UTxO[],\n    additionalTxs: string[],\n  ): Promise<Omit<Action, \"data\">[]> {\n    // Track which utxos is resolved\n    const foundUtxos = new Set<string>();\n\n    for (const utxo of additionalUtxos) {\n      foundUtxos.add(`${utxo.input.txHash}:${utxo.input.outputIndex}`);\n    }\n    for (const tx of additionalTxs) {\n      const outputs = getTransactionOutputs(tx);\n      for (const output of outputs) {\n        foundUtxos.add(`${output.input.txHash}:${output.input.outputIndex}`);\n      }\n    }\n    const inputsToResolve = getTransactionInputs(tx).filter(\n      (input) => !foundUtxos.has(`${input.txHash}:${input.outputIndex}`),\n    );\n    const txHashesSet = new Set(inputsToResolve.map((input) => input.txHash));\n    for (const txHash of txHashesSet) {\n      const utxos = await this.fetcher.fetchUTxOs(txHash);\n      for (const utxo of utxos) {\n        if (utxo)\n          if (\n            inputsToResolve.find(\n              (input) =>\n                input.txHash === txHash &&\n                input.outputIndex === utxo.input.outputIndex,\n            )\n          ) {\n            additionalUtxos.push(utxo);\n            foundUtxos.add(`${utxo.input.txHash}:${utxo.input.outputIndex}`);\n          }\n      }\n    }\n    const missing = inputsToResolve.filter(\n      (input) => !foundUtxos.has(`${input.txHash}:${input.outputIndex}`),\n    );\n    if (missing.length > 0) {\n      const missingList = missing\n        .map((m) => `${m.txHash}:${m.outputIndex}`)\n        .join(\", \");\n      throw new Error(\n        `Can't resolve these UTXOs to execute plutus scripts: ${missingList}`,\n      );\n    }\n    return evaluateTransaction(\n      tx,\n      additionalUtxos,\n      additionalTxs,\n      this.network,\n      this.slotConfig,\n    );\n  }",
          "documentation": "Evaluates Plutus scripts in a transaction by resolving its input UTXOs and calculating execution costs.\n\nThe method performs these steps:\n1. Extracts input references from the transaction\n2. Resolves the corresponding UTXOs using the fetcher\n3. Verifies all required UTXOs are available\n4. Evaluates each Plutus script to determine its memory and CPU costs",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "fetcher",
          "type": "IFetcher",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "network",
          "type": "Network",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "slotConfig",
          "type": "Omit<Omit<SlotConfig, \"startEpoch\">, \"epochLength\">",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "offline-evaluator",
      "source": "mesh-core-csl"
    },
    {
      "name": "CSLParser",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-core-csl/src/parser/index.ts",
      "extends": null,
      "implements": [],
      "methods": [],
      "properties": [
        {
          "name": "resolvedUtxos",
          "type": "UTxO[]",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "txBuilderBody",
          "type": "MeshTxBuilderBody",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "txHex",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "txHash",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "index",
      "source": "mesh-core-csl"
    },
    {
      "name": "CoseSign1",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/message-signing/cose-sign1.ts",
      "extends": null,
      "implements": [],
      "methods": [
        {
          "name": "fromCbor",
          "signature": "static fromCbor(cbor: string) {\n    const decoded = Cbor.parse(cbor) as CborArray;\n    if (!isRawCborArray(decoded.toRawObj() as RawCborArray))\n      throw Error(\"Invalid CBOR\");\n    if (decoded.array.length !== 4) throw Error(\"Invalid COSE_SIGN1\");\n\n    let protectedMap: CborMap;\n    // Decode and Set ProtectedMap\n    const protectedSerialized = decoded.array[0] as CborBytes;\n    try {\n      protectedMap = Cbor.parse(protectedSerialized.bytes) as CborMap;\n      if (!isRawCborMap(protectedMap.toRawObj() as RawCborMap)) {\n        throw Error();\n      }\n    } catch (error) {\n      throw Error(\"Invalid protected\");\n    }\n    // Set UnProtectedMap\n    let unProtectedMap = decoded.array[1] as CborMap;\n    if (!isRawCborMap(unProtectedMap.toRawObj() as RawCborMap))\n      throw Error(\"Invalid unprotected\");\n    // Set Payload\n    const payload = decoded.array[2] as CborBytes;\n\n    // Set Signature\n    const signature = decoded.array[3] as CborBytes;\n\n    return new CoseSign1({\n      protectedMap,\n      unProtectedMap,\n      payload,\n      signature,\n    });\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "createSigStructure",
          "signature": "createSigStructure(externalAad = Buffer.alloc(0)): Buffer {\n    let protectedSerialized = new CborBytes(Buffer.alloc(0));\n\n    if (this.protectedMap.map.length !== 0) {\n      protectedSerialized = new CborBytes(\n        Cbor.encode(this.protectedMap).toBuffer(),\n      );\n    }\n\n    if (!this.payload) throw Error(\"Invalid payload\");\n\n    const structure = new CborArray([\n      new CborText(\"Signature1\"),\n      protectedSerialized,\n      new CborBytes(externalAad),\n      this.payload,\n    ]);\n\n    return Buffer.from(Cbor.encode(structure).toBuffer());\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "buildMessage",
          "signature": "buildMessage(signature: Buffer): Buffer {\n    this.signature = new CborBytes(signature);\n\n    let protectedSerialized = new CborBytes(Buffer.alloc(0));\n    if (this.protectedMap.map.length !== 0) {\n      protectedSerialized = new CborBytes(\n        Cbor.encode(this.protectedMap).toBuffer(),\n      );\n    }\n\n    if (!this.payload) throw Error(\"Invalid payload\");\n\n    const coseSign1 = new CborArray([\n      protectedSerialized,\n      this.unProtectedMap,\n      this.payload,\n      this.signature,\n    ]);\n\n    return Buffer.from(Cbor.encode(coseSign1).toBuffer());\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "verifySignature",
          "signature": "verifySignature({\n    externalAad = Buffer.alloc(0),\n    publicKeyBuffer,\n  }: {\n    externalAad?: Buffer;\n    publicKeyBuffer?: Buffer;\n  } = {}): boolean {\n    if (!publicKeyBuffer) {\n      publicKeyBuffer = this.getPublicKey();\n    }\n\n    if (!publicKeyBuffer) throw Error(\"Public key not found\");\n    if (!this.signature) throw Error(\"Signature not found\");\n\n    const publicKey = new Ed25519PublicKey(publicKeyBuffer);\n\n    return publicKey.verify(\n      new Ed25519Signature(this.signature.bytes),\n      HexBlob(\n        Buffer.from(this.createSigStructure(externalAad)).toString(\"hex\"),\n      ),\n    );\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "hashPayload",
          "signature": "hashPayload() {\n    if (!this.unProtectedMap) throw Error(\"Invalid unprotected map\");\n    if (!this.payload) throw Error(\"Invalid payload\");\n\n    const hashedIndex = this.unProtectedMap.map.findIndex((value) => {\n      return (\n        JSONBig.stringify(value.k) === JSONBig.stringify(new CborText(\"hashed\"))\n      );\n    });\n\n    const hashed = this.unProtectedMap.map[hashedIndex];\n    if (\n      hashed &&\n      JSONBig.stringify(hashed.v) === JSONBig.stringify(new CborSimple(true))\n    )\n      throw Error(\"Payload already hashed\");\n    if (\n      hashed &&\n      (JSONBig.stringify(hashed.v) ===\n        JSONBig.stringify(new CborSimple(true))) !=\n        false\n    )\n      throw Error(\"Invalid unprotected map\");\n\n    this.unProtectedMap.map.splice(hashedIndex, 1);\n\n    const hash = blake2b(this.payload.bytes, undefined, 24);\n    this.payload = new CborBytes(hash);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getAddress",
          "signature": "getAddress(): Buffer {\n    const address = this.protectedMap.map.find((value) => {\n      return (\n        JSONBig.stringify(value.k) ===\n        JSONBig.stringify(new CborText(\"address\"))\n      );\n    });\n    if (!address) throw Error(\"Address not found\");\n    return Buffer.from((address.v as CborBytes).bytes);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getPublicKey",
          "signature": "getPublicKey(): Buffer {\n    const publicKey = this.protectedMap.map.find((value) => {\n      return JSONBig.stringify(value.k) === JSONBig.stringify(new CborUInt(4));\n    });\n    if (!publicKey) throw Error(\"Public key not found\");\n    return Buffer.from((publicKey.v as CborBytes).bytes);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getSignature",
          "signature": "getSignature(): Buffer | undefined {\n    return this.signature ? Buffer.from(this.signature.bytes) : this.signature;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getPayload",
          "signature": "getPayload(): Buffer | null {\n    return this.payload ? Buffer.from(this.payload.bytes) : this.payload;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "protectedMap",
          "type": "CborMap",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "unProtectedMap",
          "type": "CborMap",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "payload",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "signature",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "module": "cose-sign1",
      "source": "mesh-core-cst"
    },
    {
      "name": "CardanoSDKSerializer",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-core-cst/src/serializer/index.ts",
      "extends": null,
      "implements": [
        "IMeshTxSerializer"
      ],
      "methods": [
        {
          "name": "serializeRewardAddress",
          "signature": "serializeRewardAddress(\n    stakeKeyHash: string,\n    isScriptHash?: boolean,\n    network_id?: 0 | 1,\n  ): string {\n    return RewardAddress.fromCredentials(network_id ?? 0, {\n      type: isScriptHash ? CredentialType.ScriptHash : CredentialType.KeyHash,\n      hash: Hash28ByteBase16(stakeKeyHash),\n    })\n      .toAddress()\n      .toBech32();\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "serializePoolId",
          "signature": "serializePoolId(hash: string): string {\n    return PoolId.fromKeyHash(Ed25519KeyHashHex(hash)).toString();\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "serializeAddress",
          "signature": "serializeAddress(\n    address: Partial<DeserializedAddress>,\n    networkId?: 0 | 1,\n  ): string {\n    let paymentCred: CredentialCore | undefined = undefined;\n\n    let stakeCred: CredentialCore | undefined;\n\n    if (address.pubKeyHash && address.pubKeyHash !== \"\") {\n      paymentCred = {\n        type: CredentialType.KeyHash,\n        hash: Hash28ByteBase16(address.pubKeyHash),\n      };\n    } else if (address.scriptHash && address.scriptHash !== \"\") {\n      paymentCred = {\n        type: CredentialType.ScriptHash,\n        hash: Hash28ByteBase16(address.scriptHash),\n      };\n    }\n\n    if (address.stakeCredentialHash && address.stakeCredentialHash !== \"\") {\n      stakeCred = {\n        type: CredentialType.KeyHash,\n        hash: Hash28ByteBase16(address.stakeCredentialHash),\n      };\n    } else if (address.stakeScriptCredentialHash) {\n      stakeCred = {\n        type: CredentialType.ScriptHash,\n        hash: Hash28ByteBase16(address.stakeScriptCredentialHash),\n      };\n    }\n\n    let type: AddressType = AddressType.BasePaymentKeyStakeKey;\n    if (paymentCred && stakeCred) {\n      if (\n        paymentCred.type === CredentialType.KeyHash &&\n        stakeCred.type === CredentialType.KeyHash\n      ) {\n        type = AddressType.BasePaymentKeyStakeKey;\n      } else if (\n        paymentCred.type === CredentialType.KeyHash &&\n        stakeCred.type === CredentialType.ScriptHash\n      ) {\n        type = AddressType.BasePaymentKeyStakeScript;\n      } else if (\n        paymentCred.type === CredentialType.ScriptHash &&\n        stakeCred.type === CredentialType.KeyHash\n      ) {\n        type = AddressType.BasePaymentScriptStakeKey;\n      } else if (\n        paymentCred.type === CredentialType.ScriptHash &&\n        stakeCred.type === CredentialType.ScriptHash\n      ) {\n        type = AddressType.BasePaymentScriptStakeScript;\n      }\n    } else if (paymentCred) {\n      if (paymentCred.type === CredentialType.KeyHash) {\n        type = AddressType.EnterpriseKey;\n      } else if (paymentCred.type === CredentialType.ScriptHash) {\n        type = AddressType.EnterpriseScript;\n      }\n    } else if (stakeCred) {\n      if (stakeCred.type === CredentialType.KeyHash) {\n        type = AddressType.RewardKey;\n      } else if (stakeCred.type === CredentialType.ScriptHash) {\n        type = AddressType.RewardScript;\n      }\n    }\n\n    return new Address({\n      type,\n      networkId: networkId ?? 0,\n      paymentPart: paymentCred,\n      delegationPart: stakeCred,\n    }).toBech32();\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "serializeData",
          "signature": "serializeData(data: BuilderData): string {\n    const plutusData = fromBuilderToPlutusData(data);\n    return plutusData.toCbor().toString();\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "serializeTxBodyWithMockSignatures",
          "signature": "serializeTxBodyWithMockSignatures(\n    txBuilderBody: MeshTxBuilderBody,\n    protocolParams: Protocol,\n  ): string {\n    const serializerCore = new CardanoSDKSerializerCore(protocolParams);\n    return serializerCore.coreSerializeTxWithMockSignatures(txBuilderBody);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "serializeValue",
          "signature": "serializeValue(value: Asset[]): string {\n    return toValue(value).toCbor();\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "serializeOutput",
          "signature": "serializeOutput(output: Output): string {\n    let cardanoOutput = new TransactionOutput(\n      toCardanoAddress(output.address),\n      toValue(output.amount),\n    );\n    if (output.datum?.type === \"Hash\") {\n      cardanoOutput.setDatum(\n        Datum.newDataHash(fromBuilderToPlutusData(output.datum.data).hash()),\n      );\n    } else if (output.datum?.type === \"Inline\") {\n      cardanoOutput.setDatum(\n        Datum.newInlineData(fromBuilderToPlutusData(output.datum.data)),\n      );\n    } else if (output.datum?.type === \"Embedded\") {\n      throw new Error(\"Embedded datum not supported\");\n    }\n    if (output.referenceScript) {\n      switch (output.referenceScript.version) {\n        case \"V1\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV1Script(\n              PlutusV1Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        case \"V2\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV2Script(\n              PlutusV2Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        case \"V3\": {\n          cardanoOutput.setScriptRef(\n            Script.newPlutusV3Script(\n              PlutusV3Script.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n        default: {\n          cardanoOutput.setScriptRef(\n            Script.newNativeScript(\n              NativeScript.fromCbor(HexBlob(output.referenceScript.code)),\n            ),\n          );\n          break;\n        }\n      }\n    }\n    return cardanoOutput.toCbor();\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "protocolParams",
          "type": "Protocol",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "deserializer",
          "type": "IDeserializer",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "resolver",
          "type": "IResolver",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "serializeTxBody",
          "type": "(txBuilderBody: MeshTxBuilderBody, protocolParams?: any) => string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "addSigningKeys",
          "type": "(txHex: string, signingKeys: string[]) => string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "parser",
          "type": "ITxParser",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "index",
      "source": "mesh-core-cst"
    },
    {
      "name": "OfflineFetcher",
      "documentation": "OfflineFetcher implements the IFetcher interface to provide offline access to blockchain data.\nThis class allows working with pre-loaded blockchain data without requiring network connectivity.\nIt's useful for testing, development, and scenarios where offline operation is needed.\n\nThe class maintains internal storage for various blockchain data types:\n- Account information\n- UTXOs (Unspent Transaction Outputs)\n- Asset addresses and metadata\n- Block information\n- Protocol parameters\n- Transaction information\n\nExample usage:\n```typescript\nimport { OfflineFetcher } from '@meshsdk/core';\n\n// Create a new instance\nconst fetcher = new OfflineFetcher();\n//or const fetcher = new OfflineFetcher(\"mainnet\");\n\n// Add some blockchain data\nfetcher.addAccount(address, accountInfo);\nfetcher.addUTxOs(utxos);\nfetcher.addSerializedTransaction(\"txHash\");\n\n// Use the fetcher with MeshWallet\nconst wallet = new MeshWallet({\n  networkId: 0,\n  fetcher: fetcher,\n  key: {\n    type: 'address',\n    address: walletAddress\n  }\n});\n```",
      "isExported": true,
      "importPath": "offchain/mesh-provider/src/offline/offline-fetcher.ts",
      "extends": null,
      "implements": [
        "IFetcher"
      ],
      "methods": [
        {
          "name": "paginate",
          "signature": "private paginate<T>(\n    items: T[],\n    cursor?: number | string,\n    pageSize: number = 20,\n  ): { paginatedItems: T[]; nextCursor?: number } {\n    const startIndex = cursor != null ? parseInt(String(cursor), 10) : 0;\n    const paginatedItems = items.slice(startIndex, startIndex + pageSize);\n    const nextCursor =\n      startIndex + pageSize < items.length ? startIndex + pageSize : undefined;\n    return { paginatedItems, nextCursor };\n  }",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "fetchAccountInfo",
          "signature": "async fetchAccountInfo(address: string): Promise<AccountInfo> {\n    const account = this.accounts[address];\n    if (!account) throw new Error(`Account not found: ${address}`);\n    return account;\n  }",
          "documentation": "Fetches account information for a given address.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressUTxOs",
          "signature": "async fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]> {\n    const addressUtxos = this.utxos[address] || [];\n    return asset\n      ? addressUtxos.filter((utxo) =>\n          utxo.output.amount.some((a) => a.unit === asset),\n        )\n      : addressUtxos;\n  }",
          "documentation": "Fetches UTXOs for a given address, optionally filtered by asset.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressTxs",
          "signature": "fetchAddressTxs(\n    address: string,\n    options?: IFetcherOptions,\n  ): Promise<TransactionInfo[]> {\n    throw new Error(\"Method not implemented.\");\n  }",
          "documentation": "WIP - NOT IMPLEMENTED",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAssetAddresses",
          "signature": "async fetchAssetAddresses(asset: string): Promise<AssetAddress[]> {\n    if (!OfflineFetcher.isValidHex(asset)) {\n      throw new Error(\"Invalid asset: must be a hex string\");\n    }\n\n    const addressMap = new Map<string, bigint>();\n\n    // Get addresses from asset addresses registry\n    const registryAddresses = this.assetAddresses[asset] || [];\n    for (const addr of registryAddresses) {\n      addressMap.set(addr.address, BigInt(addr.quantity));\n    }\n\n    // Get addresses from UTXOs\n    for (const [address, utxos] of Object.entries(this.utxos)) {\n      for (const utxo of utxos) {\n        const assetAmount = utxo.output.amount.find(\n          (amt) => amt.unit === asset,\n        );\n        if (assetAmount) {\n          const currentAmount = addressMap.get(address) || BigInt(0);\n          addressMap.set(address, currentAmount + BigInt(assetAmount.quantity));\n        }\n      }\n    }\n\n    // Convert map to array of AssetAddress objects\n    return Array.from(addressMap.entries())\n      .filter(([_, quantity]) => quantity > BigInt(0))\n      .map(([address, quantity]) => ({\n        address,\n        quantity: quantity.toString(),\n      }));\n  }",
          "documentation": "Fetches addresses holding a specific asset.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAddressAssets",
          "signature": "async fetchAddressAssets(address: string): Promise<Asset[]> {\n    if (!OfflineFetcher.isValidAddress(address)) {\n      throw new Error(\n        \"Invalid address: must be a valid Bech32 or Base58 address\",\n      );\n    }\n\n    const assetMap = new Map<string, bigint>();\n\n    // Get assets from UTXOs\n    const addressUtxos = this.utxos[address] || [];\n    for (const utxo of addressUtxos) {\n      for (const amount of utxo.output.amount) {\n        const currentAmount = assetMap.get(amount.unit) || BigInt(0);\n        assetMap.set(amount.unit, currentAmount + BigInt(amount.quantity));\n      }\n    }\n\n    // Get assets from asset addresses registry\n    for (const [assetId, addresses] of Object.entries(this.assetAddresses)) {\n      const assetAddress = addresses.find((addr) => addr.address === address);\n      if (assetAddress) {\n        const currentAmount = assetMap.get(assetId) || BigInt(0);\n        assetMap.set(assetId, currentAmount + BigInt(assetAddress.quantity));\n      }\n    }\n\n    // Convert map back to array of Assets\n    return Array.from(assetMap.entries()).map(([unit, quantity]) => ({\n      unit,\n      quantity: quantity.toString(),\n    }));\n  }",
          "documentation": "Fetches all assets associated with an address.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchAssetMetadata",
          "signature": "async fetchAssetMetadata(asset: string): Promise<AssetMetadata> {\n    const metadata = this.assetMetadata[asset];\n    if (!metadata) throw new Error(`Asset metadata not found: ${asset}`);\n    return metadata;\n  }",
          "documentation": "Fetches metadata for a specific asset.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchBlockInfo",
          "signature": "async fetchBlockInfo(hash: string): Promise<BlockInfo> {\n    const block = this.blocks[hash];\n    if (!block) throw new Error(`Block not found: ${hash}`);\n    return block;\n  }",
          "documentation": "Fetches information about a specific block.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchCollectionAssets",
          "signature": "async fetchCollectionAssets(\n    policyId: string,\n    cursor?: number | string,\n  ): Promise<{ assets: Asset[]; next?: string | number }> {\n    const assets = this.collections[policyId];\n    if (!assets) throw new Error(`Collection not found: ${policyId}`);\n\n    if (cursor && !OfflineFetcher.isIntegerString(String(cursor))) {\n      throw new Error(\"Invalid cursor: must be a string of digits\");\n    }\n\n    const { paginatedItems, nextCursor } = this.paginate(assets, cursor);\n    return { assets: paginatedItems, next: nextCursor };\n  }",
          "documentation": "Fetches assets in a collection (by policy ID) with pagination.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchHandle",
          "signature": "async fetchHandle(handle: string): Promise<AssetMetadata> {\n    try {\n      const assetName = fromUTF8(handle.replace(\"$\", \"\"));\n      const handleAsset = `${SUPPORTED_HANDLES[1]}000de140${assetName}`;\n      return await this.fetchAssetMetadata(handleAsset);\n    } catch (error) {\n      throw parseHttpError(error);\n    }\n  }",
          "documentation": "Fetches metadata for a handle.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchHandleAddress",
          "signature": "async fetchHandleAddress(handle: string): Promise<string> {\n    const assetName = fromUTF8(handle.replace(\"$\", \"\"));\n    const policyId = SUPPORTED_HANDLES[1];\n    const addresses = await this.fetchAssetAddresses(`${policyId}${assetName}`);\n\n    const address = addresses[0]?.address;\n    if (!address) {\n      throw new Error(`No addresses found for handle: ${handle}`);\n    }\n\n    return address;\n  }",
          "documentation": "Fetches address associated with a handle.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchProtocolParameters",
          "signature": "async fetchProtocolParameters(epoch?: number): Promise<Protocol> {\n    if (!epoch) {\n      const maxEpochNumber = Math.max(\n        ...Object.keys(this.protocolParameters).map(Number),\n      );\n      return this.protocolParameters[maxEpochNumber]!;\n    }\n    const parameters = this.protocolParameters[epoch];\n    if (!parameters)\n      throw new Error(`Protocol parameters not found for epoch: ${epoch}`);\n    return parameters;\n  }",
          "documentation": "Fetches protocol parameters for a specific epoch.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchTxInfo",
          "signature": "async fetchTxInfo(hash: string): Promise<TransactionInfo> {\n    const transaction = this.transactions[hash];\n    if (!transaction) throw new Error(`Transaction not found: ${hash}`);\n    return transaction;\n  }",
          "documentation": "Fetches information about a specific transaction.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchUTxOs",
          "signature": "async fetchUTxOs(hash: string): Promise<UTxO[]> {\n    const utxos = Object.values(this.utxos)\n      .flat()\n      .filter((utxo) => utxo.input.txHash === hash);\n    if (!utxos.length)\n      throw new Error(`No UTxOs found for transaction hash: ${hash}`);\n    return utxos;\n  }",
          "documentation": "Fetches all UTXOs associated with a specific transaction hash.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetchGovernanceProposal",
          "signature": "async fetchGovernanceProposal(\n    txHash: string,\n    certIndex: number,\n  ): Promise<any> {\n    throw new Error(\"Method not implemented\");\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "get",
          "signature": "async get(url: string): Promise<any> {\n    throw new Error(\"Method not implemented in OfflineFetcher.\");\n  }",
          "documentation": "HTTP GET method required by IFetcher interface but not implemented in OfflineFetcher.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "toJSON",
          "signature": "toJSON(): string {\n    return JSON.stringify({\n      accounts: this.accounts,\n      utxos: this.utxos,\n      assetAddresses: this.assetAddresses,\n      assetMetadata: this.assetMetadata,\n      blocks: this.blocks,\n      collections: this.collections,\n      protocolParameters: this.protocolParameters,\n      transactions: this.transactions,\n    });\n  }",
          "documentation": "Serializes fetcher data to JSON string.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fromJSON",
          "signature": "static fromJSON(json: string): OfflineFetcher {\n    const data = JSON.parse(json);\n    const fetcher = new OfflineFetcher();\n\n    Object.entries(data.accounts || {}).forEach(([address, info]) =>\n      fetcher.addAccount(address, info as AccountInfo),\n    );\n\n    Object.entries(data.utxos || {}).forEach(([address, utxos]) =>\n      fetcher.addUTxOs(utxos as UTxO[]),\n    );\n\n    Object.entries(data.assetAddresses || {}).forEach(([asset, addresses]) =>\n      fetcher.addAssetAddresses(asset, addresses as AssetAddress[]),\n    );\n\n    Object.entries(data.assetMetadata || {}).forEach(([asset, metadata]) =>\n      fetcher.addAssetMetadata(asset, metadata as AssetMetadata),\n    );\n\n    Object.entries(data.blocks || {}).forEach(([_, info]) =>\n      fetcher.addBlock(info as BlockInfo),\n    );\n\n    Object.entries(data.collections || {}).forEach(([policyId, assets]) =>\n      fetcher.addCollectionAssets(assets as Asset[]),\n    );\n\n    Object.entries(data.protocolParameters || {}).forEach(([_, params]) =>\n      fetcher.addProtocolParameters(params as Protocol),\n    );\n\n    Object.entries(data.transactions || {}).forEach(([_, info]) =>\n      fetcher.addTransaction(info as TransactionInfo),\n    );\n\n    return fetcher;\n  }",
          "documentation": "Creates an OfflineFetcher instance from JSON data.",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "isValidHex",
          "signature": "private static isValidHex(str: string, length?: number): boolean {\n    if (length && str.length !== length) {\n      return false;\n    }\n    return /^[0-9a-fA-F]+$/.test(str);\n  }",
          "documentation": "",
          "static": true,
          "visibility": "private"
        },
        {
          "name": "isValidAddress",
          "signature": "private static isValidAddress(address: string): boolean {\n    return (\n      OfflineFetcher.isValidBech32Address(address) ||\n      OfflineFetcher.isValidBase58(address)\n    );\n  }",
          "documentation": "",
          "static": true,
          "visibility": "private"
        },
        {
          "name": "isValidBase58",
          "signature": "private static isValidBase58(input: string): boolean {\n    // Base58 character set (Bitcoin alphabet)\n    const base58Regex =\n      /^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$/;\n    // Check that input matches Base58 character set\n    if (!base58Regex.test(input)) {\n      return false;\n    }\n    // Additional checks can be added here, such as length or checksum validation\n    return true;\n  }",
          "documentation": "",
          "static": true,
          "visibility": "private"
        },
        {
          "name": "isValidBech32",
          "signature": "private static isValidBech32(input: string, prefix: string): boolean {\n    // Check if the input is all lowercase or all uppercase\n    if (input !== input.toLowerCase() && input !== input.toUpperCase()) {\n      return false;\n    }\n\n    // Bech32 regex pattern for the given prefix\n    const pattern = new RegExp(`^${prefix}1[02-9ac-hj-np-z]+$`, \"i\");\n    return pattern.test(input);\n  }",
          "documentation": "",
          "static": true,
          "visibility": "private"
        },
        {
          "name": "isValidBech32Address",
          "signature": "private static isValidBech32Address(address: string): boolean {\n    return OfflineFetcher.isValidBech32(address, \"(addr|addr_test)\");\n  }",
          "documentation": "",
          "static": true,
          "visibility": "private"
        },
        {
          "name": "isValidBech32Pool",
          "signature": "private static isValidBech32Pool(poolId: string): boolean {\n    return OfflineFetcher.isValidBech32(poolId, \"pool\");\n  }",
          "documentation": "",
          "static": true,
          "visibility": "private"
        },
        {
          "name": "isValidBech32VrfVk",
          "signature": "private static isValidBech32VrfVk(vrfKey: string): boolean {\n    return OfflineFetcher.isValidBech32(vrfKey, \"vrf_vk\");\n  }",
          "documentation": "",
          "static": true,
          "visibility": "private"
        },
        {
          "name": "isIntegerString",
          "signature": "private static isIntegerString(str: string): boolean {\n    return /^\\d+$/.test(str);\n  }",
          "documentation": "",
          "static": true,
          "visibility": "private"
        },
        {
          "name": "isValidAssetOrLovelace",
          "signature": "private static isValidAssetOrLovelace(asset: string): boolean {\n    if (asset === \"lovelace\") {\n      return true;\n    }\n    if (asset.length < 56) {\n      return false;\n    }\n    return OfflineFetcher.isValidHex(asset);\n  }",
          "documentation": "",
          "static": true,
          "visibility": "private"
        },
        {
          "name": "addAccount",
          "signature": "addAccount(address: string, accountInfo: AccountInfo): void {\n    if (!OfflineFetcher.isValidAddress(address)) {\n      throw new Error(\n        \"Invalid address: must be a valid Bech32 or Base58 address\",\n      );\n    }\n\n    if (accountInfo.poolId) {\n      if (!OfflineFetcher.isValidBech32Pool(accountInfo.poolId)) {\n        throw new Error(\n          \"Invalid 'poolId': must be a valid Bech32 pool address\",\n        );\n      }\n    }\n\n    if (!OfflineFetcher.isIntegerString(accountInfo.balance)) {\n      throw new Error(\"Invalid 'balance': must be a string of digits\");\n    }\n\n    if (!OfflineFetcher.isIntegerString(accountInfo.rewards)) {\n      throw new Error(\"Invalid 'rewards': must be a string of digits\");\n    }\n\n    if (!OfflineFetcher.isIntegerString(accountInfo.withdrawals)) {\n      throw new Error(\"Invalid 'withdrawals': must be a string of digits\");\n    }\n\n    this.accounts[address] = accountInfo;\n  }",
          "documentation": "Adds account information to the fetcher.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "addUTxOs",
          "signature": "addUTxOs(utxos: UTxO[]): void {\n    if (!Array.isArray(utxos) || utxos.length === 0) {\n      throw new Error(\"Invalid utxos: must be a non-empty array\");\n    }\n\n    utxos.forEach((utxo, index) => {\n      if (\n        !Number.isInteger(utxo.input.outputIndex) ||\n        utxo.input.outputIndex < 0\n      ) {\n        throw new Error(\n          `Invalid outputIndex for UTxO at index ${index}: must be a non-negative integer`,\n        );\n      }\n      if (!OfflineFetcher.isValidHex(utxo.input.txHash, 64)) {\n        throw new Error(\n          `Invalid txHash for UTxO at index ${index}: must be a 64-character hexadecimal string`,\n        );\n      }\n\n      if (!OfflineFetcher.isValidAddress(utxo.output.address)) {\n        throw new Error(\n          `Invalid address in output for UTxO at index ${index}: must be a valid Bech32 or Base58 address`,\n        );\n      }\n      if (\n        !Array.isArray(utxo.output.amount) ||\n        utxo.output.amount.length === 0\n      ) {\n        throw new Error(\n          `Invalid amount for UTxO at index ${index}: must be a non-empty array of assets`,\n        );\n      }\n\n      utxo.output.amount.forEach((asset, assetIndex) => {\n        if (!OfflineFetcher.isValidAssetOrLovelace(asset.unit)) {\n          throw new Error(\n            `Invalid unit for asset at index ${assetIndex} in UTxO at index ${index}`,\n          );\n        }\n        if (!OfflineFetcher.isIntegerString(asset.quantity)) {\n          throw new Error(\n            `Invalid quantity for asset at index ${assetIndex} in UTxO at index ${index}: must be a string of digits`,\n          );\n        }\n      });\n      if (\n        utxo.output.dataHash &&\n        !OfflineFetcher.isValidHex(utxo.output.dataHash, 64)\n      ) {\n        throw new Error(\n          `Invalid dataHash for UTxO at index ${index}: must be a 64-character hexadecimal string or undefined`,\n        );\n      }\n      if (\n        utxo.output.plutusData &&\n        !OfflineFetcher.isValidHex(utxo.output.plutusData)\n      ) {\n        throw new Error(\n          `Invalid plutusData for UTxO at index ${index}: must be a hexadecimal string or undefined`,\n        );\n      }\n      if (\n        utxo.output.scriptRef &&\n        !OfflineFetcher.isValidHex(utxo.output.scriptRef)\n      ) {\n        throw new Error(\n          `Invalid scriptRef for UTxO at index ${index}: must be a hexadecimal string or undefined`,\n        );\n      }\n      if (\n        utxo.output.scriptHash &&\n        !OfflineFetcher.isValidHex(utxo.output.scriptHash, 56)\n      ) {\n        throw new Error(\n          `Invalid scriptHash for UTxO at index ${index}: must be a 56-character hexadecimal string or undefined`,\n        );\n      }\n    });\n\n    for (const utxo of utxos) {\n      if (!this.utxos[utxo.output.address]) {\n        this.utxos[utxo.output.address] = [];\n      }\n      this.utxos[utxo.output.address]!.push(utxo);\n    }\n  }",
          "documentation": "Adds UTXOs to the fetcher.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "addAssetAddresses",
          "signature": "addAssetAddresses(asset: string, addresses: AssetAddress[]): void {\n    if (!OfflineFetcher.isValidHex(asset)) {\n      throw new Error(\"Invalid asset: must be a hex string\");\n    }\n    if (addresses.length === 0) {\n      throw new Error(\"Invalid addresses: must be a non-empty array\");\n    }\n    addresses.forEach((item, index) => {\n      if (!OfflineFetcher.isValidAddress(item.address)) {\n        throw new Error(\n          `Invalid 'address' field at index ${index}, should be bech32 string`,\n        );\n      }\n      if (!OfflineFetcher.isIntegerString(item.quantity)) {\n        throw new Error(\n          `Invalid 'quantity' field at index ${index}, should be a string of digits`,\n        );\n      }\n    });\n    this.assetAddresses[asset] = addresses;\n  }",
          "documentation": "Adds asset address information to the fetcher.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "addAssetMetadata",
          "signature": "addAssetMetadata(asset: string, metadata: AssetMetadata): void {\n    if (asset.length < 56) {\n      throw new Error(\n        `Invalid asset ${asset}: must be a string longer than 56 characters`,\n      );\n    }\n    if (!OfflineFetcher.isValidHex(asset)) {\n      throw new Error(\"Invalid asset: must be a hex string\");\n    }\n\n    if (typeof metadata !== \"object\" || metadata === null) {\n      throw new Error(\"Invalid metadata object\");\n    }\n    this.assetMetadata[asset] = metadata;\n  }",
          "documentation": "Adds asset metadata to the fetcher.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "addCollectionAssets",
          "signature": "addCollectionAssets(assets: Asset[]): void {\n    if (!Array.isArray(assets) || assets.length === 0) {\n      throw new Error(\"Invalid assets: must be a non-empty array\");\n    }\n\n    const groupedAssets: { [policyId: string]: Asset[] } = {};\n\n    assets.forEach((asset, index) => {\n      if (asset.unit.length < 56) {\n        throw new Error(\n          `Invalid unit for asset at index ${index}: must be a string longer than 56 characters`,\n        );\n      }\n\n      if (!OfflineFetcher.isValidHex(asset.unit)) {\n        throw new Error(\n          `Invalid unit for asset at index ${index}: must be a hexadecimal string`,\n        );\n      }\n\n      const policyId = asset.unit.slice(0, 56);\n\n      if (!OfflineFetcher.isValidHex(policyId, 56)) {\n        throw new Error(\n          `Invalid policyId in asset unit at index ${index}: must be a 56-character hexadecimal string`,\n        );\n      }\n\n      if (!OfflineFetcher.isIntegerString(asset.quantity)) {\n        throw new Error(\n          `Invalid quantity for asset at index ${index}: must be a string of digits`,\n        );\n      }\n\n      if (!groupedAssets[policyId]) {\n        groupedAssets[policyId] = [];\n      }\n      groupedAssets[policyId].push(asset);\n    });\n\n    for (const [policyId, policyAssets] of Object.entries(groupedAssets)) {\n      if (!this.collections[policyId]) {\n        this.collections[policyId] = [];\n      }\n      this.collections[policyId] =\n        this.collections[policyId].concat(policyAssets);\n    }\n  }",
          "documentation": "Adds collection assets to the fetcher.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "addProtocolParameters",
          "signature": "addProtocolParameters(parameters: Protocol): void {\n    if (parameters.epoch < 0 || !Number.isInteger(parameters.epoch)) {\n      throw new Error(\"Invalid epoch: must be a non-negative integer\");\n    }\n\n    if (parameters.minFeeA < 0 || !Number.isInteger(parameters.minFeeA)) {\n      throw new Error(\"Invalid 'minFeeA': must be a non-negative integer\");\n    }\n    if (parameters.minFeeB < 0 || !Number.isInteger(parameters.minFeeB)) {\n      throw new Error(\"Invalid 'minFeeB': must be a non-negative integer\");\n    }\n    if (\n      parameters.maxBlockSize <= 0 ||\n      !Number.isInteger(parameters.maxBlockSize)\n    ) {\n      throw new Error(\"Invalid 'maxBlockSize': must be a positive integer\");\n    }\n    if (parameters.maxTxSize <= 0 || !Number.isInteger(parameters.maxTxSize)) {\n      throw new Error(\"Invalid 'maxTxSize': must be a positive integer\");\n    }\n    if (\n      parameters.maxBlockHeaderSize <= 0 ||\n      !Number.isInteger(parameters.maxBlockHeaderSize)\n    ) {\n      throw new Error(\n        \"Invalid 'maxBlockHeaderSize': must be a positive integer\",\n      );\n    }\n    if (parameters.keyDeposit < 0 || !Number.isInteger(parameters.keyDeposit)) {\n      throw new Error(\"Invalid 'keyDeposit': must be a non-negative integer\");\n    }\n    if (\n      parameters.poolDeposit < 0 ||\n      !Number.isInteger(parameters.poolDeposit)\n    ) {\n      throw new Error(\"Invalid 'poolDeposit': must be a non-negative integer\");\n    }\n    if (parameters.decentralisation < 0 || parameters.decentralisation > 1) {\n      throw new Error(\"Invalid 'decentralisation': must be between 0 and 1\");\n    }\n    if (parameters.priceMem < 0) {\n      throw new Error(\"Invalid 'priceMem': must be non-negative\");\n    }\n    if (parameters.priceStep < 0) {\n      throw new Error(\"Invalid 'priceStep': must be non-negative\");\n    }\n    if (parameters.maxValSize < 0 || !Number.isInteger(parameters.maxValSize)) {\n      throw new Error(\"Invalid 'maxValSize': must be a non-negative integer\");\n    }\n    if (parameters.collateralPercent < 0) {\n      throw new Error(\n        \"Invalid 'collateralPercent': must be a non-negative integer\",\n      );\n    }\n    if (\n      parameters.maxCollateralInputs < 0 ||\n      !Number.isInteger(parameters.maxCollateralInputs)\n    ) {\n      throw new Error(\n        \"Invalid 'maxCollateralInputs': must be a non-negative integer\",\n      );\n    }\n    if (parameters.coinsPerUtxoSize < 0) {\n      throw new Error(\"Invalid 'coinsPerUtxoSize': must be non-negative\");\n    }\n    if (parameters.minFeeRefScriptCostPerByte < 0) {\n      throw new Error(\n        \"Invalid 'minFeeRefScriptCostPerByte': must be non-negative\",\n      );\n    }\n\n    if (!OfflineFetcher.isIntegerString(parameters.minPoolCost)) {\n      throw new Error(\"Invalid 'minPoolCost': must be a string of digits\");\n    }\n    if (!OfflineFetcher.isIntegerString(parameters.maxTxExMem)) {\n      throw new Error(\"Invalid 'maxTxExMem': must be a string of digits\");\n    }\n    if (!OfflineFetcher.isIntegerString(parameters.maxTxExSteps)) {\n      throw new Error(\"Invalid 'maxTxExSteps': must be a string of digits\");\n    }\n    if (!OfflineFetcher.isIntegerString(parameters.maxBlockExMem)) {\n      throw new Error(\"Invalid 'maxBlockExMem': must be a string of digits\");\n    }\n    if (!OfflineFetcher.isIntegerString(parameters.maxBlockExSteps)) {\n      throw new Error(\"Invalid 'maxBlockExSteps': must be a string of digits\");\n    }\n\n    this.protocolParameters[parameters.epoch] = parameters;\n  }",
          "documentation": "Adds protocol parameters to the fetcher.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "addTransaction",
          "signature": "addTransaction(txInfo: TransactionInfo): void {\n    if (!OfflineFetcher.isValidHex(txInfo.hash, 64)) {\n      throw new Error(\n        \"Invalid transaction hash: must be a 64-character hexadecimal string\",\n      );\n    }\n    if (!Number.isInteger(txInfo.index) || txInfo.index < 0) {\n      throw new Error(\"Invalid 'index': must be a non-negative integer\");\n    }\n    if (!OfflineFetcher.isValidHex(txInfo.block, 64)) {\n      throw new Error(\n        \"Invalid 'block': must be a 64-character hexadecimal string\",\n      );\n    }\n    if (!OfflineFetcher.isIntegerString(txInfo.slot)) {\n      throw new Error(\"Invalid 'slot': must be a string of digits\");\n    }\n    if (!OfflineFetcher.isIntegerString(txInfo.fees)) {\n      throw new Error(\"Invalid 'fees': must be a string of digits\");\n    }\n    if (!Number.isInteger(txInfo.size) || txInfo.size <= 0) {\n      throw new Error(\"Invalid 'size': must be a positive integer\");\n    }\n    if (!/^-?\\d+$/.test(txInfo.deposit)) {\n      throw new Error(\n        \"Invalid 'deposit': must be a string representing an integer (positive or negative)\",\n      );\n    }\n    if (\n      txInfo.invalidBefore !== \"\" &&\n      !OfflineFetcher.isIntegerString(txInfo.invalidBefore)\n    ) {\n      throw new Error(\n        \"Invalid 'invalidBefore': must be a string of digits or empty string\",\n      );\n    }\n    if (\n      txInfo.invalidAfter !== \"\" &&\n      !OfflineFetcher.isIntegerString(txInfo.invalidAfter)\n    ) {\n      throw new Error(\n        \"Invalid 'invalidAfter': must be a string of digits or empty string\",\n      );\n    }\n    this.transactions[txInfo.hash] = txInfo;\n    this.addUTxOs(txInfo.outputs);\n  }",
          "documentation": "Adds transaction information to the fetcher.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "addBlock",
          "signature": "addBlock(blockInfo: BlockInfo): void {\n    if (!OfflineFetcher.isValidHex(blockInfo.hash, 64)) {\n      throw new Error(\n        \"Invalid block hash: must be a 64-character hexadecimal string\",\n      );\n    }\n    if (!Number.isInteger(blockInfo.time) || blockInfo.time < 0) {\n      throw new Error(\"Invalid 'time': must be a non-negative integer\");\n    }\n    if (!OfflineFetcher.isIntegerString(blockInfo.slot)) {\n      throw new Error(\"Invalid 'slot': must be a string of digits\");\n    }\n    if (!Number.isInteger(blockInfo.epoch) || blockInfo.epoch < 0) {\n      throw new Error(\"Invalid 'epoch': must be a non-negative integer\");\n    }\n    if (!OfflineFetcher.isIntegerString(blockInfo.epochSlot)) {\n      throw new Error(\"Invalid 'epochSlot': must be a string of digits\");\n    }\n    if (!OfflineFetcher.isValidBech32Pool(blockInfo.slotLeader)) {\n      throw new Error(\n        \"Invalid 'slotLeader': must be a bech32 string with pool prefix\",\n      );\n    }\n    if (!Number.isInteger(blockInfo.size) || blockInfo.size <= 0) {\n      throw new Error(\"Invalid 'size': must be a positive integer\");\n    }\n    if (!Number.isInteger(blockInfo.txCount) || blockInfo.txCount < 0) {\n      throw new Error(\"Invalid 'txCount': must be a non-negative integer\");\n    }\n    if (!OfflineFetcher.isIntegerString(blockInfo.output)) {\n      throw new Error(\"Invalid 'output': must be a string of digits\");\n    }\n    if (!OfflineFetcher.isValidHex(blockInfo.operationalCertificate, 64)) {\n      throw new Error(\n        \"Invalid 'operationalCertificate': must be a 64-character hexadecimal string\",\n      );\n    }\n    if (!OfflineFetcher.isValidHex(blockInfo.previousBlock, 64)) {\n      throw new Error(\n        \"Invalid 'previousBlock': must be a 64-character hexadecimal string\",\n      );\n    }\n    if (!OfflineFetcher.isValidBech32VrfVk(blockInfo.VRFKey)) {\n      throw new Error(\n        \"Invalid 'VRFKey': must be a bech32 string with vrf_vk1 prefix\",\n      );\n    }\n    this.blocks[blockInfo.hash] = blockInfo;\n  }",
          "documentation": "Adds block information to the fetcher.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "addSerializedTransaction",
          "signature": "addSerializedTransaction(txHex: string) {\n    const tx = Serialization.Transaction.fromCbor(Serialization.TxCBOR(txHex));\n    const time = Date.now();\n    const slot = resolveSlotNo(this.network ?? \"mainnet\", time);\n    const epoch = resolveEpochNo(this.network ?? \"mainnet\", time);\n    const epochSlot = this.slotToEpochSlot(BigInt(slot));\n    const randomBlockHash = randomBytes(32).toString('hex');\n    const randomPrevBlockHash = randomBytes(32).toString('hex');\n    const randomOCert = randomBytes(32).toString('hex');\n    const fee = tx.body().fee().toString();\n    const totalOutput = tx.body().outputs().reduce((acc, output) => {\n      const amount = output.amount().coin();\n      return acc + amount;\n    }, 0n);\n    const ttl = tx.body().ttl();\n    const validityStartInterval = tx.body().validityStartInterval();\n    const txHash = tx.body().hash();\n\n    const blockInfo: BlockInfo = {\n      confirmations: 40,\n      nextBlock: \"undefined its a random block\",\n      hash: randomBlockHash,\n      time,\n      slot,\n      epoch,\n      epochSlot: epochSlot.toString(),\n      fees: fee,\n      slotLeader: \"pool1qv3x5x5x5x5x5x5x5x5x5x5x5x5x5x5\",\n      size: txHex.length / 2,\n      txCount: 1,\n      output: totalOutput.toString(),\n      operationalCertificate: randomOCert,\n      previousBlock: randomPrevBlockHash,\n      VRFKey: \"vrf_vk1qv3x5x5x5x5x5x5x5x5x5x5x5x5x5\",\n    };\n\n    const txInputs = tx.body().inputs();\n    const fetchedUTxOs = txInputs.values().map((input) => {\n      const txHash = input.transactionId();\n      const outputIndex = Number(input.index());\n      const utxo = Object.values(this.utxos).flat().find(utxo => {\n        return utxo.input.txHash === txHash && utxo.input.outputIndex === outputIndex;\n      })\n      if (!utxo) {\n        throw new Error(`UTxO not found for transaction hash and output index: ${txHash} ${outputIndex}`);\n      }\n      return utxo;\n    });\n\n    for(const addressUtxos of Object.values(this.utxos)) {\n      for (const utxo of fetchedUTxOs) {\n        const index = addressUtxos.indexOf(utxo);\n        if (index !== -1) {\n          addressUtxos.splice(index, 1);\n        }\n      }\n    }\n\n    const newUtxOs = tx.body().outputs().map((output, index) => {\n      return this.mapOutputToUTxO(output, txHash, index);\n    });\n\n    const transactionInfo: TransactionInfo = {\n      inputs: fetchedUTxOs,\n      hash: txHash,\n      index: 0,\n      block: randomBlockHash,\n      slot: slot.toString(),\n      fees: fee,\n      size: txHex.length / 2,\n      deposit: \"0\",\n      invalidBefore: validityStartInterval ? validityStartInterval.toString() : \"\",\n      invalidAfter: ttl ? ttl.toString() : \"\",\n      outputs: newUtxOs\n    }\n\n    this.addBlock(blockInfo);\n    this.addTransaction(transactionInfo);\n  }",
          "documentation": "Adds a serialized transaction to the fetcher, it's generates pseudo block in addition to transaction.\nRemoves spent UTxOs from the fetcher and adds new UTxOs from the transaction.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "slotToEpochSlot",
          "signature": "private slotToEpochSlot(slot: bigint): bigint {\n    const slotConfig = SLOT_CONFIG_NETWORK[this.network ?? \"mainnet\"];\n    const epochLength = BigInt(slotConfig.epochLength);\n    return slot % epochLength;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "mapOutputToUTxO",
          "signature": "private mapOutputToUTxO(output: TransactionOutput, txHash: string, index: number): UTxO {\n    return {\n      input: {\n        txHash,\n        outputIndex: index,\n      },\n      output: {\n        address: output.address().toBech32(),\n        amount: this.mapValueToAsset(output.amount()),\n        dataHash: output.datum()?.asDataHash(),\n        plutusData: output.datum()?.asInlineData()?.toCbor(),\n        scriptRef: output.scriptRef()?.toCbor(),\n        scriptHash: output.scriptRef()?.hash(),\n      },\n    };\n  }",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "mapValueToAsset",
          "signature": "private mapValueToAsset(value: Value): Asset[] {\n    const assets: Asset[] = [];\n    const multiAsset = value.multiasset();\n    if (multiAsset) {\n      for (const [assetId, quantity] of multiAsset) {\n        const asset = {\n          unit: assetId,\n          quantity: quantity.toString(),\n        };\n        assets.push(asset);\n      }\n    } else {\n      const lovelace = value.coin().toString();\n      assets.push({ unit: \"lovelace\", quantity: lovelace });\n    }\n    return assets;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "properties": [
        {
          "name": "accounts",
          "type": "Record<string, AccountInfo>",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "utxos",
          "type": "Record<string, UTxO[]>",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "assetAddresses",
          "type": "Record<string, AssetAddress[]>",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "assetMetadata",
          "type": "Record<string, AssetMetadata>",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "blocks",
          "type": "Record<string, BlockInfo>",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "collections",
          "type": "Record<string, Asset[]>",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "protocolParameters",
          "type": "Record<number, Protocol>",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "transactions",
          "type": "Record<string, TransactionInfo>",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "module": "offline-fetcher",
      "source": "mesh-provider"
    },
    {
      "name": "MeshTxBuilder",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/index.ts",
      "extends": "MeshTxBuilderCore",
      "implements": [],
      "methods": [
        {
          "name": "getInputsRequiredSignatures",
          "signature": "protected getInputsRequiredSignatures(): {\n    paymentCreds: Set<string>;\n    byronAddresses: Set<string>;\n  } {\n    const byronAddresses = new Set<string>();\n    const paymentCreds = new Set<string>();\n    for (let input of this.meshTxBuilderBody.inputs) {\n      if (input.type === \"PubKey\") {\n        if (input.txIn.address) {\n          const address = CstAddress.fromString(input.txIn.address);\n          if (!address) {\n            continue;\n          }\n          const addressDetails = address.getProps();\n          const paymentCred = addressDetails.paymentPart;\n          if (paymentCred?.type === CstCredentialType.KeyHash) {\n            paymentCreds.add(paymentCred.hash);\n          }\n          if (addressDetails.type === CstAddressType.Byron) {\n            byronAddresses.add(input.txIn.address);\n          }\n        }\n      } else if (input.type === \"SimpleScript\") {\n        const nativeScript = this.getInputNativeScript(input);\n        if (nativeScript) {\n          let pubKeys = this.getNativeScriptPubKeys(nativeScript);\n          for (let pubKey of pubKeys) {\n            paymentCreds.add(pubKey);\n          }\n        }\n      }\n    }\n    return { paymentCreds, byronAddresses };\n  }",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getCollateralRequiredSignatures",
          "signature": "protected getCollateralRequiredSignatures(): {\n    collateralPaymentCreds: Set<string>;\n    collateralByronAddresses: Set<string>;\n  } {\n    const collateralByronAddresses = new Set<string>();\n    const collateralPaymentCreds = new Set<string>();\n    for (let collateral of this.meshTxBuilderBody.collaterals) {\n      if (collateral.type === \"PubKey\") {\n        if (collateral.txIn.address) {\n          const address = CstAddress.fromString(collateral.txIn.address);\n          if (!address) {\n            continue;\n          }\n          const addressDetails = address.getProps();\n          const paymentCred = addressDetails.paymentPart;\n          if (paymentCred?.type === CstCredentialType.KeyHash) {\n            collateralPaymentCreds.add(paymentCred.hash);\n          }\n          if (addressDetails.type === CstAddressType.Byron) {\n            collateralByronAddresses.add(collateral.txIn.address);\n          }\n        }\n      }\n    }\n    return { collateralPaymentCreds, collateralByronAddresses };\n  }",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getWithdrawalRequiredSignatures",
          "signature": "protected getWithdrawalRequiredSignatures(): Set<string> {\n    const withdrawalCreds = new Set<string>();\n    for (let withdrawal of this.meshTxBuilderBody.withdrawals) {\n      if (withdrawal.type === \"PubKeyWithdrawal\") {\n        const address = CstAddress.fromBech32(withdrawal.address);\n        const addressDetails = address.getProps();\n        const paymentCred = addressDetails.paymentPart;\n        if (paymentCred?.type === CstCredentialType.KeyHash) {\n          withdrawalCreds.add(paymentCred.hash);\n        }\n      }\n      if (withdrawal.type === \"SimpleScriptWithdrawal\") {\n        const nativeScript = this.getWithdrawalNativeScript(withdrawal);\n        if (nativeScript) {\n          let pubKeys = this.getNativeScriptPubKeys(nativeScript);\n          for (let pubKey of pubKeys) {\n            withdrawalCreds.add(pubKey);\n          }\n        }\n      }\n    }\n    return withdrawalCreds;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getCertificatesRequiredSignatures",
          "signature": "protected getCertificatesRequiredSignatures(): Set<string> {\n    const certCreds = new Set<string>();\n    for (let cert of this.meshTxBuilderBody.certificates) {\n      if (\n        cert.type !== \"BasicCertificate\" &&\n        cert.type !== \"SimpleScriptCertificate\"\n      ) {\n        continue;\n      }\n\n      const certNativeScript = this.getCertificateNativeScript(cert);\n\n      const certType = cert.certType;\n\n      if (certType.type === \"RegisterPool\") {\n        certCreds.add(certType.poolParams.operator);\n        for (let owner of certType.poolParams.owners) {\n          certCreds.add(owner);\n        }\n      } else if (certType.type === \"RetirePool\") {\n        certCreds.add(certType.poolId);\n      } else if (\n        certType.type === \"DRepRegistration\" ||\n        certType.type === \"DRepDeregistration\" ||\n        certType.type === \"DRepUpdate\"\n      ) {\n        if (cert.type === \"BasicCertificate\") {\n          const cstDrep = coreToCstDRep(certType.drepId);\n          const keyHash = cstDrep.toKeyHash();\n          if (keyHash) {\n            certCreds.add(keyHash);\n          }\n        } else if (certNativeScript) {\n          let pubKeys = this.getNativeScriptPubKeys(certNativeScript);\n          for (let pubKey of pubKeys) {\n            certCreds.add(pubKey);\n          }\n        }\n      } else if (\n        certType.type === \"StakeRegistrationAndDelegation\" ||\n        certType.type === \"VoteRegistrationAndDelegation\" ||\n        certType.type === \"StakeVoteRegistrationAndDelegation\" ||\n        certType.type === \"VoteDelegation\" ||\n        certType.type === \"RegisterStake\" ||\n        certType.type === \"StakeAndVoteDelegation\" ||\n        certType.type === \"DelegateStake\" ||\n        certType.type === \"DeregisterStake\"\n      ) {\n        if (cert.type === \"BasicCertificate\") {\n          const address = CstAddress.fromString(certType.stakeKeyAddress);\n          if (address) {\n            const addressDetails = address.getProps();\n            const paymentCred = addressDetails.paymentPart;\n            if (paymentCred?.type === CstCredentialType.KeyHash) {\n              certCreds.add(paymentCred.hash);\n            }\n          }\n        } else if (certNativeScript) {\n          let pubKeys = this.getNativeScriptPubKeys(certNativeScript);\n          for (let pubKey of pubKeys) {\n            certCreds.add(pubKey);\n          }\n        }\n      } else if (\n        certType.type === \"CommitteeHotAuth\" ||\n        certType.type === \"CommitteeColdResign\"\n      ) {\n        if (cert.type === \"BasicCertificate\") {\n          const address = CstAddress.fromString(\n            certType.committeeColdKeyAddress,\n          );\n          if (address) {\n            const addressDetails = address.getProps();\n            const paymentCred = addressDetails.paymentPart;\n            if (paymentCred?.type === CstCredentialType.KeyHash) {\n              certCreds.add(paymentCred.hash);\n            }\n          }\n        } else if (certNativeScript) {\n          let pubKeys = this.getNativeScriptPubKeys(certNativeScript);\n          for (let pubKey of pubKeys) {\n            certCreds.add(pubKey);\n          }\n        }\n      }\n    }\n    return certCreds;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getVoteRequiredSignatures",
          "signature": "protected getVoteRequiredSignatures(): Set<string> {\n    const voteCreds = new Set<string>();\n    for (let vote of this.meshTxBuilderBody.votes) {\n      if (vote.type !== \"SimpleScriptVote\") {\n        const nativeScript = this.getVoteNativeScript(vote);\n        if (nativeScript) {\n          let pubKeys = this.getNativeScriptPubKeys(nativeScript);\n          for (let pubKey of pubKeys) {\n            voteCreds.add(pubKey);\n          }\n        } else if (vote.type === \"BasicVote\") {\n          const voter = vote.vote.voter;\n          if (voter.type === \"DRep\") {\n            const drep = coreToCstDRep(voter.drepId);\n            const keyHash = drep.toKeyHash();\n            if (keyHash) {\n              voteCreds.add(keyHash);\n            }\n          } else if (voter.type === \"StakingPool\") {\n            voteCreds.add(voter.keyHash);\n          } else if (voter.type === \"ConstitutionalCommittee\") {\n            const hotCred = voter.hotCred;\n            if (hotCred.type === \"KeyHash\") {\n              voteCreds.add(hotCred.keyHash);\n            }\n          }\n        }\n      }\n    }\n    return voteCreds;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getInputNativeScript",
          "signature": "protected getInputNativeScript(txIn: TxIn): CstNativeScript | undefined {\n    if (txIn.type !== \"SimpleScript\") {\n      return undefined;\n    }\n\n    const scriptSource = txIn.simpleScriptTxIn.scriptSource;\n    if (scriptSource === undefined) {\n      return undefined;\n    }\n\n    if (scriptSource.type === \"Inline\") {\n      return this.getInlinedNativeScript(\n        scriptSource.txHash,\n        scriptSource.txIndex,\n      );\n    }\n    if (scriptSource.type === \"Provided\") {\n      return CstNativeScript.fromCbor(\n        <CardanoSDKUtil.HexBlob>scriptSource.scriptCode,\n      );\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "clone",
          "signature": "protected clone(): MeshTxBuilder {\n    const newBuilder = super._cloneCore<MeshTxBuilder>(() => {\n      return new MeshTxBuilder({\n        serializer: this.serializer,\n        fetcher: this.fetcher,\n        submitter: this.submitter,\n        evaluator: this.evaluator,\n        verbose: this.verbose,\n        params: { ...this._protocolParams },\n      });\n    });\n\n    newBuilder.txHex = this.txHex;\n\n    newBuilder.queriedTxHashes = structuredClone(this.queriedTxHashes);\n\n    newBuilder.queriedUTxOs = structuredClone(this.queriedUTxOs);\n    newBuilder.utxosWithRefScripts = structuredClone(this.utxosWithRefScripts);\n\n    return newBuilder;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        }
      ],
      "properties": [
        {
          "name": "serializer",
          "type": "IMeshTxSerializer",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "fetcher",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "submitter",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "evaluator",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "txHex",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "verbose",
          "type": "boolean",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "queriedTxHashes",
          "type": "Set<string>",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "queriedUTxOs",
          "type": "{ [x: string]: UTxO[]; }",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "utxosWithRefScripts",
          "type": "UTxO[]",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "serializeMockTx",
          "type": "() => any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "completeUnbalanced",
          "type": "(customizedTx?: any) => string",
          "documentation": "It builds the transaction query the blockchain for missing information",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "completeSync",
          "type": "(customizedTx?: any) => any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "complete",
          "type": "(customizedTx?: any) => Promise<any>",
          "documentation": "It builds the transaction and query the blockchain for missing information",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "selectUtxos",
          "type": "() => Promise<import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface\").TransactionPrototype>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "updateByTxPrototype",
          "type": "(selectionSkeleton: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface\").TransactionPrototype, final?: boolean) => Promise<void>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUtxosForSelection",
          "type": "() => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "sortTxParts",
          "type": "() => void",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "sortInputs",
          "type": "() => void",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "sortMints",
          "type": "() => void",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "compareCredentials",
          "type": "(credentialA: CstCredential, credentialB: CstCredential) => number",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "sortWithdrawals",
          "type": "() => void",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "sortVotes",
          "type": "() => void",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "evaluateRedeemers",
          "type": "() => Promise<void>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getRedeemerCosts",
          "type": "() => Omit<Action, \"data\">[]",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "completeUnbalancedSync",
          "type": "(customizedTx?: any) => any",
          "documentation": "It builds the transaction without dependencies",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "completeSigning",
          "type": "() => any",
          "documentation": "Complete the signing process",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "submitTx",
          "type": "(txHex: string) => Promise<string | undefined>",
          "documentation": "Submit transactions to the blockchain using the fetcher instance",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUTxOInfo",
          "type": "(txHash: string) => Promise<void>",
          "documentation": "Get the UTxO information from the blockchain",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "queryAllTxInfo",
          "type": "(incompleteTxIns: TxIn[], incompleteScriptSources: ScriptSource[], incompleteSimpleScriptSources: SimpleScriptSourceInfo[]) => Promise<void[]>",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "completeTxInformation",
          "type": "(input: TxIn) => void",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "completeInputInfo",
          "type": "(input: TxIn) => void",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "completeScriptInfo",
          "type": "(scriptSource: ScriptSource) => void",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "completeSimpleScriptInfo",
          "type": "(simpleScript: SimpleScriptSourceInfo) => void",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "isInputComplete",
          "type": "(txIn: TxIn) => boolean",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "isInputInfoComplete",
          "type": "(txIn: TxIn) => boolean",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "isMintComplete",
          "type": "(mint: MintItem) => boolean",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "isRefScriptInfoComplete",
          "type": "(scriptSource: ScriptSource) => boolean",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "isSimpleRefScriptInfoComplete",
          "type": "(simpleScriptSource: SimpleScriptSourceInfo) => boolean",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "completeSerialization",
          "type": "(customizedTx?: any) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "completeTxParts",
          "type": "() => Promise<void>",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "sanitizeOutputs",
          "type": "() => Promise<void>",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "collectAllRequiredSignatures",
          "type": "() => { keyHashes: Set<string>; byronAddresses: Set<string>; }",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getMintRequiredSignatures",
          "type": "() => Set<string>",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getTotalWithdrawal",
          "type": "() => bigint",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getTotalDeposit",
          "type": "() => bigint",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getTotalRefund",
          "type": "() => bigint",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getTotalMint",
          "type": "() => Asset[]",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getNativeScriptPubKeys",
          "type": "(nativeScript: CstNativeScript) => Set<string>",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getVoteNativeScript",
          "type": "(cert: Vote) => any",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getCertificateNativeScript",
          "type": "(cert: Certificate) => any",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getMintNativeScript",
          "type": "(mint: MintParam) => any",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getWithdrawalNativeScript",
          "type": "(withdrawal: Withdrawal) => any",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getInlinedNativeScript",
          "type": "(txHash: string, index: number) => any",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "makeTxId",
          "type": "(txHash: string, index: number) => string",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getTotalReferenceInputsSize",
          "type": "() => bigint",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getAllReferenceInputsSizes",
          "type": "() => Map<string, bigint>",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getBodyReferenceInputsSizes",
          "type": "() => [string, bigint][]",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getInputsReferenceInputsSizes",
          "type": "() => [string, bigint][]",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getMintsReferenceInputsSizes",
          "type": "() => [string, bigint][]",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getWithdrawalsReferenceInputsSizes",
          "type": "() => [string, bigint][]",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getVotesReferenceInputsSizes",
          "type": "() => [string, bigint][]",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getCertificatesReferenceInputsSizes",
          "type": "() => [string, bigint][]",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getTotalExecutionUnits",
          "type": "() => { memUnits: bigint; stepUnits: bigint; }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getSerializedSize",
          "type": "() => number",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getActualFee",
          "type": "() => bigint",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "calculateFee",
          "type": "() => bigint",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "calculateFeeForSerializedTx",
          "type": "(txSize: number) => bigint",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "calculateRefScriptFee",
          "type": "() => bigint",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "calculateRedeemersFee",
          "type": "() => bigint",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "calculateMinLovelaceForOutput",
          "type": "(output: Output) => bigint",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "index",
      "source": "mesh-transaction"
    },
    {
      "name": "MeshTxBuilderCore",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/tx-builder-core.ts",
      "extends": null,
      "implements": [],
      "methods": [
        {
          "name": "chainTx",
          "signature": "chainTx(txHex: string): this {\n    this.meshTxBuilderBody.chainedTxs.push(txHex);\n    return this;\n  }",
          "documentation": "Add a transaction that is used as input, but not yet reflected on the global blockchain",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "inputForEvaluation",
          "signature": "inputForEvaluation(input: UTxO) {\n    const utxoId = `${input.input.txHash}${input.input.outputIndex}`;\n    const currentUtxo = this.meshTxBuilderBody.inputsForEvaluation[utxoId];\n\n    if (currentUtxo) {\n      const {\n        dataHash: currentDataHash,\n        plutusData: currentPlutusData,\n        scriptRef: currentScriptRef,\n        scriptHash: currentScriptHash,\n      } = currentUtxo.output;\n\n      const updatedUtxo: UTxO = { ...currentUtxo };\n      if (currentDataHash) updatedUtxo.output.dataHash = currentDataHash;\n      if (currentPlutusData) updatedUtxo.output.plutusData = currentPlutusData;\n      if (currentScriptRef) updatedUtxo.output.scriptRef = currentScriptRef;\n      if (currentScriptHash) updatedUtxo.output.scriptHash = currentScriptHash;\n\n      this.meshTxBuilderBody.inputsForEvaluation[utxoId] = updatedUtxo;\n    } else {\n      this.meshTxBuilderBody.inputsForEvaluation[utxoId] = input;\n    }\n    return this;\n  }",
          "documentation": "Add a transaction input to provide information for offline evaluation",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "_cloneCore",
          "signature": "protected _cloneCore<T extends MeshTxBuilderCore>(\n    createInstance: () => T,\n  ): T {\n    this.queueAllLastItem();\n\n    const newBuilder = createInstance();\n\n    newBuilder.meshTxBuilderBody = cloneTxBuilderBody(this.meshTxBuilderBody);\n\n    newBuilder.txEvaluationMultiplier = this.txEvaluationMultiplier;\n    newBuilder.txOutput = this.txOutput\n      ? structuredClone(this.txOutput)\n      : undefined;\n\n    // Clone boolean flags\n    newBuilder.addingPlutusScriptInput = this.addingPlutusScriptInput;\n    newBuilder.plutusSpendingScriptVersion = this.plutusSpendingScriptVersion;\n    newBuilder.addingPlutusMint = this.addingPlutusMint;\n    newBuilder.plutusMintingScriptVersion = this.plutusMintingScriptVersion;\n    newBuilder.addingPlutusWithdrawal = this.addingPlutusWithdrawal;\n    newBuilder.plutusWithdrawalScriptVersion =\n      this.plutusWithdrawalScriptVersion;\n    newBuilder.addingPlutusVote = this.addingPlutusVote;\n    newBuilder.plutusVoteScriptVersion = this.plutusVoteScriptVersion;\n\n    newBuilder._protocolParams = structuredClone(this._protocolParams);\n\n    newBuilder.mintItem = this.mintItem\n      ? structuredClone(this.mintItem)\n      : undefined;\n    newBuilder.txInQueueItem = this.txInQueueItem\n      ? structuredClone(this.txInQueueItem)\n      : undefined;\n    newBuilder.withdrawalItem = this.withdrawalItem\n      ? structuredClone(this.withdrawalItem)\n      : undefined;\n    newBuilder.voteItem = this.voteItem\n      ? structuredClone(this.voteItem)\n      : undefined;\n    newBuilder.collateralQueueItem = this.collateralQueueItem\n      ? structuredClone(this.collateralQueueItem)\n      : undefined;\n    newBuilder.refScriptTxInQueueItem = this.refScriptTxInQueueItem\n      ? structuredClone(this.refScriptTxInQueueItem)\n      : undefined;\n    newBuilder.manualFee = this.manualFee;\n\n    return newBuilder;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        }
      ],
      "properties": [
        {
          "name": "txEvaluationMultiplier",
          "type": "number",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "txOutput",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "addingPlutusScriptInput",
          "type": "boolean",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "plutusSpendingScriptVersion",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "addingPlutusMint",
          "type": "boolean",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "plutusMintingScriptVersion",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "addingPlutusWithdrawal",
          "type": "boolean",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "plutusWithdrawalScriptVersion",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "addingPlutusVote",
          "type": "boolean",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "plutusVoteScriptVersion",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "manualFee",
          "type": "string | undefined",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "_protocolParams",
          "type": "Protocol",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "mintItem",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "txInQueueItem",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "withdrawalItem",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "voteItem",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "collateralQueueItem",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "refScriptTxInQueueItem",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "meshTxBuilderBody",
          "type": "MeshTxBuilderBody",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "txIn",
          "type": "(txHash: string, txIndex: number, amount?: Asset[] | undefined, address?: string | undefined, scriptSize?: number | undefined) => this",
          "documentation": "Set the input for transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "txInScript",
          "type": "(scriptCbor: string) => this",
          "documentation": "Set the script for transaction input",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "txInDatumValue",
          "type": "(datum: BuilderData, type?: BuilderData) => this",
          "documentation": "Set the input datum for transaction input",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "txInInlineDatumPresent",
          "type": "() => this",
          "documentation": "Tell the transaction builder that the input UTxO has inlined datum",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "simpleScriptTxInReference",
          "type": "(txHash: string, txIndex: number, spendingScriptHash?: string | undefined, scriptSize?: string | undefined) => this",
          "documentation": "Native script - Set the reference input where it would also be spent in the transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "txInRedeemerValue",
          "type": "(redeemer: BuilderData, type?: BuilderData, exUnits?: any) => this",
          "documentation": "Set the redeemer for the reference input to be spent in same transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "txOut",
          "type": "(address: string, amount: Asset[]) => this",
          "documentation": "Set the output for transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "txOutDatumHashValue",
          "type": "(datum: BuilderData, type?: BuilderData) => this",
          "documentation": "Set the output datum hash for transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "txOutInlineDatumValue",
          "type": "(datum: BuilderData, type?: BuilderData) => this",
          "documentation": "Set the output inline datum for transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "txOutDatumEmbedValue",
          "type": "(datum: BuilderData, type?: BuilderData) => this",
          "documentation": "Set the output embed datum for transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "txOutReferenceScript",
          "type": "(scriptCbor: string, version?: LanguageVersion) => this",
          "documentation": "Set the reference script to be attached with the output",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "spendingPlutusScript",
          "type": "(languageVersion: LanguageVersion) => this",
          "documentation": "Set the reference script to be attached with the output",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "spendingPlutusScriptV1",
          "type": "() => this",
          "documentation": "Set the instruction that it is currently using V1 Plutus spending scripts",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "spendingPlutusScriptV2",
          "type": "() => this",
          "documentation": "Set the instruction that it is currently using V2 Plutus spending scripts",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "spendingPlutusScriptV3",
          "type": "() => this",
          "documentation": "Set the instruction that it is currently using V3 Plutus spending scripts",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "spendingTxInReference",
          "type": "(txHash: string, txIndex: number, scriptSize?: string | undefined, scriptHash?: string | undefined) => this",
          "documentation": "Set the reference input where it would also be spent in the transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "spendingReferenceTxInInlineDatumPresent",
          "type": "() => this",
          "documentation": "[Alias of txInInlineDatumPresent] Set the instruction that the reference input has inline datum",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "spendingReferenceTxInRedeemerValue",
          "type": "(redeemer: BuilderData, type?: BuilderData, exUnits?: any) => this",
          "documentation": "[Alias of txInRedeemerValue] Set the redeemer for the reference input to be spent in same transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "readOnlyTxInReference",
          "type": "(txHash: string, txIndex: number, scriptSize?: number | undefined) => this",
          "documentation": "Specify a read only reference input. This reference input is not witnessing anything it is simply provided in the plutus script context.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "mintPlutusScript",
          "type": "(languageVersion: LanguageVersion) => this",
          "documentation": "Set the minting script for the current mint",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "mintPlutusScriptV1",
          "type": "() => this",
          "documentation": "Set the instruction that it is currently using V1 Plutus minting scripts",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "mintPlutusScriptV2",
          "type": "() => this",
          "documentation": "Set the instruction that it is currently using V2 Plutus minting scripts",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "mintPlutusScriptV3",
          "type": "() => this",
          "documentation": "Set the instruction that it is currently using V3 Plutus minting scripts",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "mint",
          "type": "(quantity: string, policy: string, name: string) => this",
          "documentation": "Set the minting value of transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "mintingScript",
          "type": "(scriptCBOR: string) => this",
          "documentation": "Set the minting script of current mint",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "mintTxInReference",
          "type": "(txHash: string, txIndex: number, scriptSize?: string | undefined, scriptHash?: string | undefined) => this",
          "documentation": "Use reference script for minting",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "mintReferenceTxInRedeemerValue",
          "type": "(redeemer: BuilderData, type?: BuilderData, exUnits?: any) => this",
          "documentation": "Set the redeemer for minting",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "mintRedeemerValue",
          "type": "(redeemer: BuilderData, type?: BuilderData, exUnits?: any) => this",
          "documentation": "Set the redeemer for the reference input to be spent in same transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "requiredSignerHash",
          "type": "(pubKeyHash: string) => this",
          "documentation": "Set the required signer of the transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "txInCollateral",
          "type": "(txHash: string, txIndex: number, amount?: Asset[] | undefined, address?: string | undefined) => this",
          "documentation": "Set the collateral UTxO for the transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "withdrawalPlutusScript",
          "type": "(languageVersion: LanguageVersion) => this",
          "documentation": "Set the instruction that it is currently using V1 Plutus withdrawal scripts",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "withdrawalPlutusScriptV1",
          "type": "() => this",
          "documentation": "Set the instruction that it is currently using a Plutus withdrawal scripts",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "withdrawalPlutusScriptV2",
          "type": "() => this",
          "documentation": "Set the instruction that it is currently using V2 Plutus withdrawal scripts",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "withdrawalPlutusScriptV3",
          "type": "() => this",
          "documentation": "Set the instruction that it is currently using V3 Plutus withdrawal scripts",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "withdrawal",
          "type": "(rewardAddress: string, coin: string) => this",
          "documentation": "Withdraw stake rewards in the MeshTxBuilder instance",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "withdrawalScript",
          "type": "(scriptCbor: string) => this",
          "documentation": "Add a withdrawal script to the MeshTxBuilder instance",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "withdrawalTxInReference",
          "type": "(txHash: string, txIndex: number, scriptSize?: string | undefined, scriptHash?: string | undefined) => this",
          "documentation": "Add a withdrawal reference to the MeshTxBuilder instance",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "withdrawalRedeemerValue",
          "type": "(redeemer: BuilderData, type?: BuilderData, exUnits?: any) => this",
          "documentation": "Set the transaction withdrawal redeemer value in the MeshTxBuilder instance",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "votePlutusScript",
          "type": "(languageVersion: LanguageVersion) => this",
          "documentation": "Set the instruction that it is currently using a Plutus voting scripts",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "votePlutusScriptV1",
          "type": "() => this",
          "documentation": "Set the instruction that it is currently using V1 Plutus voting scripts",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "votePlutusScriptV2",
          "type": "() => this",
          "documentation": "Set the instruction that it is currently using V2 Plutus voting scripts",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "votePlutusScriptV3",
          "type": "() => this",
          "documentation": "Set the instruction that it is currently using V3 Plutus voting scripts",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "vote",
          "type": "(voter: Voter, govActionId: RefTxIn, votingProcedure: VotingProcedure) => this",
          "documentation": "Add a vote in the MeshTxBuilder instance",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "voteScript",
          "type": "(scriptCbor: string) => this",
          "documentation": "Add a voting script to the MeshTxBuilder instance",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "voteTxInReference",
          "type": "(txHash: string, txIndex: number, scriptSize?: string | undefined, scriptHash?: string | undefined) => this",
          "documentation": "Add a vote reference to the MeshTxBuilder instance",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "voteRedeemerValue",
          "type": "(redeemer: BuilderData, type?: BuilderData, exUnits?: any) => this",
          "documentation": "Set the transaction vote redeemer value in the MeshTxBuilder instance",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "registerPoolCertificate",
          "type": "(poolParams: PoolParams) => this",
          "documentation": "Creates a pool registration certificate, and adds it to the transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "registerStakeCertificate",
          "type": "(rewardAddress: string) => this",
          "documentation": "Creates a stake registration certificate, and adds it to the transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "delegateStakeCertificate",
          "type": "(rewardAddress: string, poolId: string) => this",
          "documentation": "Creates a stake delegation certificate, and adds it to the transaction\nThis will delegate stake from the corresponding stake address to the pool",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "deregisterStakeCertificate",
          "type": "(rewardAddress: string) => this",
          "documentation": "Creates a stake deregister certificate, and adds it to the transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "retirePoolCertificate",
          "type": "(poolId: string, epoch: number) => this",
          "documentation": "Creates a pool retire certificate, and adds it to the transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "drepRegistrationCertificate",
          "type": "(drepId: string, anchor?: any, coin?: string) => this",
          "documentation": "Registers DRep certificate, and adds it to the transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "drepDeregistrationCertificate",
          "type": "(drepId: string, coin?: string) => this",
          "documentation": "Dregister DRep certificate, and adds it to the transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "drepUpdateCertificate",
          "type": "(drepId: string, anchor?: any) => this",
          "documentation": "Update DRep certificate, and adds it to the transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "voteDelegationCertificate",
          "type": "(drep: DRep, rewardAddress: string) => this",
          "documentation": "Dregister DRep certificate, and adds it to the transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "certificateScript",
          "type": "(scriptCbor: string, version?: any) => this",
          "documentation": "Adds a script witness to the certificate",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "certificateTxInReference",
          "type": "(txHash: string, txIndex: number, scriptSize?: string | undefined, scriptHash?: string | undefined, version?: any) => this",
          "documentation": "Adds a script witness to the certificate",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "certificateRedeemerValue",
          "type": "(redeemer: BuilderData, type?: BuilderData, exUnits?: any) => this",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "changeAddress",
          "type": "(addr: string) => this",
          "documentation": "Configure the address to accept change UTxO",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "invalidBefore",
          "type": "(slot: number) => this",
          "documentation": "Set the transaction valid interval to be valid only after the slot",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "invalidHereafter",
          "type": "(slot: number) => this",
          "documentation": "Set the transaction valid interval to be valid only before the slot",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "metadataValue",
          "type": "(label: string | number | bigint, metadata: any) => this",
          "documentation": "Add metadata to the transaction",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "signingKey",
          "type": "(skeyHex: string) => this",
          "documentation": "Sign the transaction with the private key",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "selectUtxosFrom",
          "type": "(extraInputs: UTxO[]) => this",
          "documentation": "Selects utxos to fill output value and puts them into inputs",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "protocolParams",
          "type": "(params: Protocol) => this",
          "documentation": "Set the protocol parameters to be used for the transaction other than the default one",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "setFee",
          "type": "(fee: string) => this",
          "documentation": "Sets a specific fee for the transaction to use",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "setTotalCollateral",
          "type": "(collateral: string) => this",
          "documentation": "Sets a total collateral for the transaction to use, a collateral return\nwill be generated to either the change address or the specified collateral return address",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "setCollateralReturnAddress",
          "type": "(address: string) => this",
          "documentation": "Sets the collateral return address, if none is set, the change address will be used",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "setNetwork",
          "type": "(network: any) => this",
          "documentation": "Sets the network to use, this is mainly to know the cost models to be used to calculate script integrity hash",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "queueAllLastItem",
          "type": "() => void",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "queueInput",
          "type": "() => void",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "queueMint",
          "type": "() => void",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "queueWithdrawal",
          "type": "() => void",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "queueVote",
          "type": "() => void",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "castRawDataToJsonString",
          "type": "(rawData: string | object) => any",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "castBuilderDataToRedeemer",
          "type": "(redeemer: BuilderData, type?: BuilderData, exUnits?: any) => Redeemer",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "updateRedeemer",
          "type": "(meshTxBuilderBody: MeshTxBuilderBody, txEvaluation: Omit<Action, \"data\">[], doNotUseMultiplier?: boolean) => void",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "addUtxosFromSelection",
          "type": "() => void",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "removeDuplicateInputs",
          "type": "() => void",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "removeDuplicateRefInputs",
          "type": "() => void",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "emptyTxBuilderBody",
          "type": "() => any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "reset",
          "type": "() => void",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "tx-builder-core",
      "source": "mesh-transaction"
    },
    {
      "name": "ForgeScript",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/scripts/forge.script.ts",
      "extends": null,
      "implements": [],
      "methods": [
        {
          "name": "withOneSignature",
          "signature": "static withOneSignature(address: string): string {\n    const keyHash = deserializeEd25519KeyHash(resolvePaymentKeyHash(address));\n    return buildScriptPubkey(keyHash).toCbor();\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "fromNativeScript",
          "signature": "static fromNativeScript(script: NativeScript): string {\n    return toNativeScript(script).toCbor();\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        }
      ],
      "properties": [],
      "module": "forge.script",
      "source": "mesh-transaction"
    },
    {
      "name": "Transaction",
      "documentation": "Deprecated - Use `MeshTxBuilder` instead",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/transaction/index.ts",
      "extends": null,
      "implements": [],
      "methods": [
        {
          "name": "attachMetadata",
          "signature": "static attachMetadata(cborTx: string, cborTxMetadata: string) {\n    const tx = deserializeTx(cborTx);\n    const txAuxData = tx.auxiliaryData() ?? new Serialization.AuxiliaryData();\n\n    txAuxData.setMetadata(\n      Serialization.GeneralTransactionMetadata.fromCbor(\n        CardanoSDKUtil.HexBlob(cborTxMetadata),\n      ),\n    );\n\n    if (\n      Cardano.computeAuxiliaryDataHash(txAuxData.toCore())?.toString() !==\n      tx.body().auxiliaryDataHash()?.toString()\n    ) {\n      throw new Error(\n        \"[Transaction] attachMetadata: The metadata hash does not match the auxiliary data hash.\",\n      );\n    }\n\n    return new Tx(tx.body(), tx.witnessSet(), txAuxData).toCbor().toString();\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "deattachMetadata",
          "signature": "static deattachMetadata(cborTx: string) {\n    const tx = deserializeTx(cborTx);\n    return new Tx(tx.body(), tx.witnessSet()).toCbor().toString();\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "maskMetadata",
          "signature": "static maskMetadata(cborTx: string) {\n    const tx = deserializeTx(cborTx);\n    const txMetadata = tx.auxiliaryData()?.metadata();\n\n    if (txMetadata !== undefined) {\n      const mockMetadata = new Map<\n        bigint,\n        Serialization.TransactionMetadatum\n      >();\n      txMetadata\n        .metadata()\n        ?.forEach((metadatum, label) =>\n          mockMetadata.set(label, mask(metadatum)),\n        );\n      const txAuxData = tx.auxiliaryData();\n      txMetadata.setMetadata(mockMetadata);\n      txAuxData?.setMetadata(txMetadata);\n      return new Tx(tx.body(), tx.witnessSet(), txAuxData).toCbor().toString();\n    }\n\n    return cborTx;\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "readMetadata",
          "signature": "static readMetadata(cborTx: string) {\n    const tx = deserializeTx(cborTx);\n    return tx.auxiliaryData()?.metadata()?.toCbor().toString() ?? \"\";\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "writeMetadata",
          "signature": "static writeMetadata(cborTx: string, cborTxMetadata: string) {\n    const tx = deserializeTx(cborTx);\n    const txAuxData = tx.auxiliaryData() ?? new Serialization.AuxiliaryData();\n\n    txAuxData.setMetadata(\n      Serialization.GeneralTransactionMetadata.fromCbor(\n        CardanoSDKUtil.HexBlob(cborTxMetadata),\n      ),\n    );\n\n    return new Tx(tx.body(), tx.witnessSet(), txAuxData).toCbor().toString();\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "sendAssets",
          "signature": "sendAssets(recipient: Recipient, assets: Asset[] | string): Transaction {\n    if (typeof assets === \"string\") {\n      assets = [\n        {\n          unit: \"lovelace\",\n          quantity: assets,\n        },\n      ];\n    }\n    if (typeof recipient === \"string\") {\n      this.txBuilder.txOut(recipient, assets);\n    }\n    if (typeof recipient === \"object\") {\n      this.txBuilder.txOut(recipient.address, assets);\n      if (recipient.datum) {\n        if (recipient.datum.inline) {\n          this.txBuilder.txOutInlineDatumValue(recipient.datum.value);\n        } else {\n          this.txBuilder.txOutDatumHashValue(recipient.datum.value);\n        }\n      }\n    }\n\n    return this;\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "sendLovelace",
          "signature": "sendLovelace(recipient: Recipient, lovelace: string): Transaction {\n    return this.sendAssets(recipient, lovelace);\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\nUse sendAssets instead:\n```ts\nthis.sendAssets(recipient, lovelace);\n```\n\nDeprecation reason - Unnecessary implementation which might cause confusion.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "sendToken",
          "signature": "sendToken(recipient: Recipient, ticker: Token, amount: string): Transaction {\n    const assets = [{ unit: SUPPORTED_TOKENS[ticker], quantity: amount }];\n    return this.sendAssets(recipient, assets);\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\nPlease use sendAssets with helper function to obtain token unit instead:\n```ts\nconst assets = [{ unit: SUPPORTED_TOKENS.GIMBAL, quantity: \"100\" }]\ntransaction.sendAssets(recipient, assets)\n```\n\nDeprecation reason - Required maintenance on tokens.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "sendValue",
          "signature": "sendValue(recipient: Recipient, value: UTxO): Transaction {\n    const assets = value.output.amount;\n    return this.sendAssets(recipient, assets);\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\n```ts\nconst assets = value.output.amount;\nthis.sendAssets(recipient, assets);\n```\nDeprecation reason - Unnecessary implementation which might cause confusion.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "setTxInputs",
          "signature": "setTxInputs(inputs: UTxO[]): Transaction {\n    inputs.forEach((input) => {\n      this.txBuilder.txIn(\n        input.input.txHash,\n        input.input.outputIndex,\n        input.output.amount,\n        input.output.address,\n        input.output.scriptRef ? input.output.scriptRef.length / 2 : 0,\n      );\n    });\n\n    return this;\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "setTxRefInputs",
          "signature": "setTxRefInputs(inputs: UTxO[]): Transaction {\n    inputs.forEach((input) => {\n      this.txBuilder.readOnlyTxInReference(\n        input.input.txHash,\n        input.input.outputIndex,\n      );\n    });\n\n    return this;\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "setNativeScriptInput",
          "signature": "setNativeScriptInput(script: NativeScript, utxo: UTxO): Transaction {\n    const { scriptCbor } =\n      this.txBuilder.serializer.deserializer.script.deserializeNativeScript(\n        script,\n      );\n    this.txBuilder\n      .txIn(\n        utxo.input.txHash,\n        utxo.input.outputIndex,\n        utxo.output.amount,\n        utxo.output.address,\n      )\n      .txInScript(scriptCbor!);\n\n    return this;\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\nSets the native script for the transaction.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "redeemValue",
          "signature": "redeemValue(options: {\n    value: UTxO;\n    script: PlutusScript | UTxO;\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget };\n    datum?: Data | UTxO;\n  }): Transaction {\n    const { value, script, datum, redeemer } = options;\n    const red = redeemer || {\n      data: { alternative: 0, fields: [\"mesh\"] },\n      budget: DEFAULT_REDEEMER_BUDGET,\n    };\n\n    if (\"code\" in script) {\n      // Provided script for redemption\n      this.isCollateralNeeded = true;\n      this.spendingPlutusScript(script)\n        .txIn(\n          value.input.txHash,\n          value.input.outputIndex,\n          value.output.amount,\n          value.output.address,\n          value.output.scriptRef ? value.output.scriptRef.length / 2 : 0,\n        )\n        .txInScript(script.code)\n        .txInRedeemerValue(red.data, \"Mesh\", red.budget);\n    }\n\n    if (\"output\" in script) {\n      // Reference script for redemption\n      if (!script.output.scriptRef) {\n        throw new Error(\"redeemValue: No script reference found in UTxO\");\n      }\n      const scriptRef = fromScriptRef(script.output.scriptRef);\n      if (!scriptRef || !(\"code\" in scriptRef)) {\n        throw new Error(\"redeemValue: Script reference not found\");\n      }\n\n      this.isCollateralNeeded = true;\n      this.spendingPlutusScript(scriptRef)\n        .txIn(\n          value.input.txHash,\n          value.input.outputIndex,\n          value.output.amount,\n          value.output.address,\n        )\n        .spendingTxInReference(\n          script.input.txHash,\n          script.input.outputIndex,\n          (script.output.scriptRef.length / 2).toString(),\n          script.output.scriptHash,\n        )\n        .txInRedeemerValue(red.data, \"Mesh\", red.budget);\n    }\n\n    if (datum) {\n      // Provided datum for redemption\n      this.txBuilder.txInDatumValue(datum);\n    } else {\n      // Reference datum for redemption\n      this.txBuilder.txInInlineDatumPresent();\n    }\n    // if (typeof datum === \"object\" && \"output\" in datum) {\n    //   // Reference datum for redemption\n    // } else {\n    //   // Provided datum for redemption\n    //   if (datum) {\n    //   }\n    // }\n\n    return this;\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "mintAsset",
          "signature": "mintAsset(\n    forgeScript: string | PlutusScript | UTxO,\n    mint: Mint,\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget },\n  ): Transaction {\n    const assetQuantity = mint.assetQuantity;\n    let assetNameHex = stringToHex(mint.assetName);\n    const referenceAssetNameHex = CIP68_100(assetNameHex);\n    if (mint.cip68ScriptAddress) {\n      assetNameHex = CIP68_222(assetNameHex);\n    }\n    let policyId = \"\";\n    switch (typeof forgeScript) {\n      case \"string\":\n        policyId = deserializeNativeScript(forgeScript).hash().toString();\n        this.txBuilder\n          .mint(assetQuantity, policyId, assetNameHex)\n          .mintingScript(forgeScript);\n        if (mint.cip68ScriptAddress) {\n          this.txBuilder\n            .mint(assetQuantity, policyId, referenceAssetNameHex)\n            .mintingScript(forgeScript);\n        }\n\n        break;\n\n      case \"object\":\n        if (!redeemer)\n          throw new Error(\n            \"burnAsset: Redeemer data is required for Plutus minting\",\n          );\n        if (\"code\" in forgeScript) {\n          // Burn plutus script assets with provided script\n          policyId = deserializePlutusScript(\n            forgeScript.code,\n            forgeScript.version,\n          )\n            .hash()\n            .toString();\n\n          this.isCollateralNeeded = true;\n          this.mintPlutusScript(forgeScript)\n            .mint(assetQuantity, policyId, assetNameHex)\n            .mintingScript(forgeScript.code)\n            .mintRedeemerValue(redeemer.data, \"Mesh\", redeemer.budget);\n          if (mint.cip68ScriptAddress) {\n            this.mintPlutusScript(forgeScript)\n              .mint(assetQuantity, policyId, referenceAssetNameHex)\n              .mintingScript(forgeScript.code)\n              .mintRedeemerValue(redeemer.data, \"Mesh\", redeemer.budget);\n          }\n          break;\n        }\n        if (\"output\" in forgeScript) {\n          // Burn plutus script assets with reference script\n          if (!forgeScript.output.scriptRef) {\n            throw new Error(\"mintAsset: No script reference found in UTxO\");\n          }\n          const script = fromScriptRef(forgeScript.output.scriptRef);\n          if (!script) {\n            throw new Error(\"mintAsset: Script reference not found\");\n          }\n\n          if (\"code\" in script) {\n            policyId = deserializePlutusScript(script.code, script.version)\n              .hash()\n              .toString();\n\n            this.isCollateralNeeded = true;\n            this.mintPlutusScript(script)\n              .mint(assetQuantity, policyId, assetNameHex)\n              .mintTxInReference(\n                forgeScript.input.txHash,\n                forgeScript.input.outputIndex,\n                (forgeScript.output.scriptRef.length / 2).toString(),\n                forgeScript.output.scriptHash,\n              )\n              .mintRedeemerValue(redeemer.data, \"Mesh\", redeemer.budget);\n            if (mint.cip68ScriptAddress) {\n              this.mintPlutusScript(script)\n                .mint(assetQuantity, policyId, referenceAssetNameHex)\n                .mintTxInReference(\n                  forgeScript.input.txHash,\n                  forgeScript.input.outputIndex,\n                  (forgeScript.output.scriptRef.length / 2).toString(),\n                  forgeScript.output.scriptHash,\n                )\n                .mintRedeemerValue(redeemer.data, \"Mesh\", redeemer.budget);\n              break;\n            }\n\n            break;\n          } else {\n            // TODO: to implement reference script minting for native script tokens\n            throw new Error(\n              \"mintAsset: Reference script minting not implemented\",\n            );\n            // this.txBuilder\n            //   .mint(assetQuantity, policyId, assetName)\n            //   .mintTxInReference(\n            //     forgeScript.input.txHash,\n            //     forgeScript.input.outputIndex\n            //   );\n          }\n        }\n        break;\n    }\n\n    if (mint.recipient) {\n      this.sendAssets(mint.recipient, [\n        { unit: policyId + assetNameHex, quantity: mint.assetQuantity },\n      ]);\n    }\n    if (mint.cip68ScriptAddress) {\n      this.sendAssets(\n        {\n          address: mint.cip68ScriptAddress,\n          datum: { inline: true, value: metadataToCip68(mint.metadata) },\n        },\n        [\n          {\n            unit: policyId + referenceAssetNameHex,\n            quantity: mint.assetQuantity,\n          },\n        ],\n      );\n    }\n    if (!mint.cip68ScriptAddress && mint.metadata && mint.label) {\n      if (mint.label === \"721\" || mint.label === \"20\") {\n        let currentMetadata = this.txBuilder.meshTxBuilderBody.metadata;\n        if (currentMetadata.get(BigInt(mint.label)) === undefined) {\n          this.setMetadata(Number(mint.label), {\n            [policyId]: { [mint.assetName]: mint.metadata },\n          });\n        } else {\n          let metadataMap = metadataObjToMap({\n            [policyId]: { [mint.assetName]: mint.metadata },\n          } as object);\n          let newMetadata = mergeContents(\n            currentMetadata.get(BigInt(mint.label)) as Metadatum,\n            metadataMap,\n            mint.label === \"721\" ? 2 : 0,\n          );\n          this.setMetadata(Number(mint.label), newMetadata);\n        }\n      } else {\n        this.setMetadata(Number(mint.label), mint.metadata);\n      }\n    }\n\n    return this;\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "burnAsset",
          "signature": "burnAsset(\n    forgeScript: string | PlutusScript | UTxO,\n    asset: Asset,\n    redeemer?: Pick<Action, \"data\"> & { budget?: Budget },\n  ): Transaction {\n    const assetQuantity = \"-\" + asset.quantity;\n    const mint: Mint = {\n      assetName: hexToString(asset.unit.slice(POLICY_ID_LENGTH)),\n      assetQuantity: assetQuantity,\n    };\n    try {\n      this.mintAsset(forgeScript, mint, redeemer);\n    } catch (error) {\n      throw new Error(\"burnAsset: \" + error);\n    }\n\n    return this;\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "setChangeAddress",
          "signature": "setChangeAddress(changeAddress: string): Transaction {\n    this.txBuilder.changeAddress(changeAddress);\n    return this;\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\nSets the change address for the transaction.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "setCollateral",
          "signature": "setCollateral(collateral: UTxO[]): Transaction {\n    collateral.forEach((collateralUtxo) => {\n      this.txBuilder.txInCollateral(\n        collateralUtxo.input.txHash,\n        collateralUtxo.input.outputIndex,\n        collateralUtxo.output.amount,\n        collateralUtxo.output.address,\n      );\n    });\n\n    return this;\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\nSets the collateral for the transaction.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "setRequiredSigners",
          "signature": "setRequiredSigners(addresses: string[]): Transaction {\n    addresses.forEach((address) => {\n      const { pubKeyHash } =\n        this.txBuilder.serializer.deserializer.key.deserializeAddress(address);\n      this.txBuilder.requiredSignerHash(pubKeyHash);\n    });\n\n    return this;\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\nSets the required signers for the transaction.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "setTimeToExpire",
          "signature": "setTimeToExpire(slot: string): Transaction {\n    this.txBuilder.invalidHereafter(Number(slot));\n    return this;\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\n Set the time to live for the transaction.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "setTimeToStart",
          "signature": "setTimeToStart(slot: string): Transaction {\n    this.txBuilder.invalidBefore(Number(slot));\n    return this;\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\n Sets the start slot for the transaction.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "setMetadata",
          "signature": "setMetadata(label: number, metadata: Metadatum | object): Transaction {\n    this.txBuilder.metadataValue(label, metadata);\n    return this;\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\n Add a JSON metadata entry to the transaction.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "withdrawRewards",
          "signature": "withdrawRewards(rewardAddress: string, lovelace: string): Transaction {\n    this.txBuilder.withdrawal(rewardAddress, lovelace);\n    return this;\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "delegateStake",
          "signature": "delegateStake(rewardAddress: string, poolId: string): Transaction {\n    this.txBuilder.delegateStakeCertificate(\n      rewardAddress,\n      this.txBuilder.serializer.deserializer.cert.deserializePoolId(poolId),\n    );\n    return this;\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "deregisterStake",
          "signature": "deregisterStake(rewardAddress: string): Transaction {\n    this.txBuilder.deregisterStakeCertificate(rewardAddress);\n    return this;\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "registerStake",
          "signature": "registerStake(rewardAddress: string): Transaction {\n    this.txBuilder.registerStakeCertificate(rewardAddress);\n    return this;\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "registerPool",
          "signature": "registerPool(params: PoolParams): Transaction {\n    this.txBuilder.registerPoolCertificate(params);\n    return this;\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "retirePool",
          "signature": "retirePool(poolId: string, epochNo: number): Transaction {\n    this.txBuilder.retirePoolCertificate(poolId, epochNo);\n    return this;\n  }",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "build",
          "signature": "async build(balanced: Boolean = true): Promise<string> {\n    try {\n      await this.addCollateralIfNeeded();\n      await this.addTxInputsAsNeeded();\n      await this.addChangeAddress();\n      if (balanced) {\n        return this.txBuilder.complete();\n      } else {\n        return this.txBuilder.completeUnbalanced();\n      }\n    } catch (error) {\n      throw new Error(\n        `[Transaction] An error occurred during build: ${error}.`,\n      );\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "mintPlutusScript",
          "signature": "protected mintPlutusScript(script: PlutusScript) {\n    switch (script.version) {\n      case \"V1\":\n        this.txBuilder.mintPlutusScriptV1();\n        break;\n      case \"V2\":\n        this.txBuilder.mintPlutusScriptV2();\n        break;\n      case \"V3\":\n        this.txBuilder.mintPlutusScriptV3();\n        break;\n    }\n    return this.txBuilder;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "spendingPlutusScript",
          "signature": "protected spendingPlutusScript(script: PlutusScript) {\n    switch (script.version) {\n      case \"V1\":\n        this.txBuilder.spendingPlutusScriptV1();\n        break;\n      case \"V2\":\n        this.txBuilder.spendingPlutusScriptV2();\n        break;\n      case \"V3\":\n        this.txBuilder.spendingPlutusScriptV3();\n        break;\n    }\n    return this.txBuilder;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "addCollateralIfNeeded",
          "signature": "private async addCollateralIfNeeded() {\n    if (this.isCollateralNeeded) {\n      const collaterals = await this.initiator.getCollateral();\n      if (collaterals.length > 0) {\n        this.setCollateral(collaterals);\n        return;\n      }\n      const utxos = await this.initiator.getUtxos();\n      const pureLovelaceUtxos = utxos.filter(\n        (utxo) => utxo.output.amount.length === 1,\n      );\n\n      pureLovelaceUtxos.sort((a, b) => {\n        return (\n          Number(a.output.amount[0]?.quantity!) -\n          Number(a.output.amount[0]?.quantity!)\n        );\n      });\n\n      for (const utxo of pureLovelaceUtxos) {\n        if (Number(utxo.output.amount[0]?.quantity!) >= 5000000) {\n          return [utxo];\n        }\n      }\n\n      if (pureLovelaceUtxos.length === 0) {\n        throw new Error(\"No pure lovelace utxos found for collateral\");\n      }\n      this.setCollateral([pureLovelaceUtxos[0]!]);\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "addTxInputsAsNeeded",
          "signature": "private async addTxInputsAsNeeded() {\n    if (this.txBuilder.meshTxBuilderBody.extraInputs.length === 0) {\n      const utxos = await this.initiator.getUtxos();\n      this.txBuilder.selectUtxosFrom(utxos);\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "addChangeAddress",
          "signature": "private async addChangeAddress() {\n    if (this.txBuilder.meshTxBuilderBody.changeAddress === \"\") {\n      const changeAddress = await this.initiator.getChangeAddress();\n      this.setChangeAddress(changeAddress);\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "properties": [
        {
          "name": "txBuilder",
          "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/index\").MeshTxBuilder",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "initiator",
          "type": "IInitiator",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "isCollateralNeeded",
          "type": "boolean",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "setNetwork",
          "type": "(network: Network) => this",
          "documentation": "[Deprecated] - `Transaction` class is on planning for V2.\nUse `MeshTxBuilder` instead for tx-building for now.\n\nSets the network to use, this is mainly to know the cost models to be used to calculate script integrity hash",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "index",
      "source": "mesh-transaction"
    },
    {
      "name": "TxParser",
      "documentation": "TxParser class to parse transaction hex strings and resolve UTxOs.\n\nIt is used for either manipulating transactions or for unit testing transaction buildings.",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/tx-parser/index.ts",
      "extends": null,
      "implements": [],
      "methods": [],
      "properties": [
        {
          "name": "parse",
          "type": "(txHex: string, providedUtxos?: UTxO[]) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getBuilderBody",
          "type": "() => any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getBuilderBodyWithoutChange",
          "type": "() => any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "toTester",
          "type": "() => any",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "index",
      "source": "mesh-transaction"
    },
    {
      "name": "AppWallet",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/app/index.ts",
      "extends": null,
      "implements": [
        "ISigner",
        "ISubmitter"
      ],
      "methods": [
        {
          "name": "init",
          "signature": "async init() {\n    if (this._wallet) {\n      await this._wallet.init();\n    }\n  }",
          "documentation": "Initializes the wallet. This is a required call as fetching addresses from the wallet is an async operation.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getCollateralUnspentOutput",
          "signature": "async getCollateralUnspentOutput(\n    accountIndex = 0,\n    addressType: GetAddressType = \"payment\",\n  ): Promise<TransactionUnspentOutput[]> {\n    const utxos = await this.getUnspentOutputs(accountIndex, addressType);\n\n    // find utxos that are pure ADA-only\n    const pureAdaUtxos = utxos.filter((utxo) => {\n      return utxo.output().amount().multiasset() === undefined;\n    });\n\n    // sort utxos by their lovelace amount\n    pureAdaUtxos.sort((a, b) => {\n      return (\n        Number(a.output().amount().coin()) - Number(b.output().amount().coin())\n      );\n    });\n\n    // return the smallest utxo but not less than 5000000 lovelace\n    for (const utxo of pureAdaUtxos) {\n      if (Number(utxo.output().amount().coin()) >= 5000000) {\n        return [utxo];\n      }\n    }\n\n    return [];\n  }",
          "documentation": "Get a list of UTXOs to be used as collateral inputs for transactions with plutus script inputs.\n\nThis is used in transaction building.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getEnterpriseAddress",
          "signature": "getEnterpriseAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.enterpriseAddressBech32;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getPaymentAddress",
          "signature": "getPaymentAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.baseAddressBech32;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getRewardAddress",
          "signature": "getRewardAddress(accountIndex = 0, keyIndex = 0): string {\n    const account = this._wallet.getAccount(accountIndex, keyIndex);\n    return account.rewardAddressBech32;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getNetworkId",
          "signature": "getNetworkId(): number {\n    return this._wallet.getNetworkId();\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUsedAddress",
          "signature": "getUsedAddress(\n    accountIndex = 0,\n    keyIndex = 0,\n    addressType: GetAddressType = \"payment\",\n  ): Address {\n    if (addressType === \"enterprise\") {\n      return toAddress(this.getEnterpriseAddress(accountIndex, keyIndex));\n    } else {\n      return toAddress(this.getPaymentAddress(accountIndex, keyIndex));\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUnspentOutputs",
          "signature": "async getUnspentOutputs(\n    accountIndex = 0,\n    addressType: GetAddressType = \"payment\",\n  ): Promise<TransactionUnspentOutput[]> {\n    if (!this._fetcher) {\n      throw new Error(\n        \"[AppWallet] Fetcher is required to fetch UTxOs. Please provide a fetcher.\",\n      );\n    }\n    const account = this._wallet.getAccount(accountIndex);\n\n    const utxos = await this._fetcher.fetchAddressUTxOs(\n      addressType == \"enterprise\"\n        ? account.enterpriseAddressBech32\n        : account.baseAddressBech32,\n    );\n\n    return utxos.map((utxo) => toTxUnspentOutput(utxo));\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "signData",
          "signature": "async signData(\n    address: string,\n    payload: string,\n    accountIndex = 0,\n    keyIndex = 0,\n  ): Promise<DataSignature> {\n    try {\n      return this._wallet.signData(address, payload, accountIndex, keyIndex);\n    } catch (error) {\n      throw new Error(\n        `[AppWallet] An error occurred during signData: ${error}.`,\n      );\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "signTx",
          "signature": "async signTx(\n    unsignedTx: string,\n    partialSign = false,\n    accountIndex = 0,\n    keyIndex = 0,\n  ): Promise<string> {\n    try {\n      const tx = deserializeTx(unsignedTx);\n      if (\n        !partialSign &&\n        tx.witnessSet().vkeys() !== undefined &&\n        tx.witnessSet().vkeys()!.size() !== 0\n      )\n        throw new Error(\n          \"Signatures already exist in the transaction in a non partial sign call\",\n        );\n\n      const newSignatures = this._wallet.signTx(\n        unsignedTx,\n        accountIndex,\n        keyIndex,\n      );\n\n      let signedTx = EmbeddedWallet.addWitnessSets(unsignedTx, [newSignatures]);\n      return signedTx;\n    } catch (error) {\n      throw new Error(`[AppWallet] An error occurred during signTx: ${error}.`);\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "signTxSync",
          "signature": "signTxSync(\n    unsignedTx: string,\n    partialSign = false,\n    accountIndex = 0,\n    keyIndex = 0,\n  ): string {\n    try {\n      throw new Error(`[AppWallet] signTxSync() is not implemented.`);\n    } catch (error) {\n      throw new Error(`[AppWallet] An error occurred during signTx: ${error}.`);\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "signTxs",
          "signature": "async signTxs(\n    unsignedTxs: string[],\n    partialSign: boolean,\n  ): Promise<string[]> {\n    throw new Error(`[AppWallet] signTxs() is not implemented.`);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "submitTx",
          "signature": "submitTx(tx: string): Promise<string> {\n    if (!this._submitter) {\n      throw new Error(\n        \"[AppWallet] Submitter is required to submit transactions. Please provide a submitter.\",\n      );\n    }\n    return this._submitter.submitTx(tx);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "brew",
          "signature": "static brew(strength = 256): string[] {\n    return EmbeddedWallet.generateMnemonic(strength);\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "_fetcher",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_submitter",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_wallet",
          "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/embedded/index\").EmbeddedWallet",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "module": "index",
      "source": "mesh-wallet"
    },
    {
      "name": "BrowserWallet",
      "documentation": "Browser Wallet provides a set of APIs to interact with the blockchain. This wallet is compatible with Mesh transaction builders.\n\nThese wallets APIs are in accordance to CIP-30, which defines the API for apps to communicate with the user's wallet. Additional utility functions provided for developers that are useful for building applications.\n```javascript\nimport { BrowserWallet } from '@meshsdk/core';\n\nconst wallet = await BrowserWallet.enable('eternl');\n```",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/browser/browser-wallet.ts",
      "extends": null,
      "implements": [
        "IWallet"
      ],
      "methods": [
        {
          "name": "getAvailableWallets",
          "signature": "static async getAvailableWallets({\n    injectFn = undefined,\n  }: {\n    injectFn?: () => Promise<void>;\n  } = {}): Promise<Wallet[]> {\n    if (window === undefined) return [];\n\n    if (injectFn) await injectFn();\n\n    return BrowserWallet.getInstalledWallets();\n  }",
          "documentation": "Returns a list of wallets installed on user's device. Each wallet is an object with the following properties:\n- A name is provided to display wallet's name on the user interface.\n- A version is provided to display wallet's version on the user interface.\n- An icon is provided to display wallet's icon on the user interface.",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "getInstalledWallets",
          "signature": "static getInstalledWallets(): Wallet[] {\n    if (window === undefined) return [];\n    if (window.cardano === undefined) return [];\n\n    let wallets: Wallet[] = [];\n    for (const key in window.cardano) {\n      try {\n        const _wallet = window.cardano[key];\n        if (_wallet === undefined) continue;\n        if (_wallet.name === undefined) continue;\n        if (_wallet.icon === undefined) continue;\n        if (_wallet.apiVersion === undefined) continue;\n        wallets.push({\n          id: key,\n          name: key == \"nufiSnap\" ? \"MetaMask\" : _wallet.name,\n          icon: _wallet.icon,\n          version: _wallet.apiVersion,\n        });\n      } catch (e) {}\n    }\n\n    return wallets;\n  }",
          "documentation": "Returns a list of wallets installed on user's device. Each wallet is an object with the following properties:\n- A name is provided to display wallet's name on the user interface.\n- A version is provided to display wallet's version on the user interface.\n- An icon is provided to display wallet's icon on the user interface.",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "enable",
          "signature": "static async enable(\n    walletName: string,\n    extensions: Extension[] = [],\n  ): Promise<BrowserWallet> {\n    try {\n      const walletInstance = await BrowserWallet.resolveInstance(\n        walletName,\n        extensions,\n      );\n\n      if (walletInstance !== undefined)\n        return new BrowserWallet(walletInstance, walletName);\n\n      throw new Error(`Couldn't create an instance of wallet: ${walletName}`);\n    } catch (error) {\n      throw new Error(\n        `[BrowserWallet] An error occurred during enable: ${JSON.stringify(\n          error,\n        )}.`,\n      );\n    }\n  }",
          "documentation": "This is the entrypoint to start communication with the user's wallet. The wallet should request the user's permission to connect the web page to the user's wallet, and if permission has been granted, the wallet will be returned and exposing the full API for the app to use.\n\nQuery BrowserWallet.getInstalledWallets() to get a list of available wallets, then provide the wallet name for which wallet the user would like to connect with.",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "getBalance",
          "signature": "async getBalance(): Promise<Asset[]> {\n    const balance = await this._walletInstance.getBalance();\n    return fromValue(deserializeValue(balance));\n  }",
          "documentation": "Returns a list of assets in the wallet. This API will return every assets in the wallet. Each asset is an object with the following properties:\n- A unit is provided to display asset's name on the user interface.\n- A quantity is provided to display asset's quantity on the user interface.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getChangeAddress",
          "signature": "async getChangeAddress(): Promise<string> {\n    const changeAddress = await this._walletInstance.getChangeAddress();\n    return addressToBech32(deserializeAddress(changeAddress));\n  }",
          "documentation": "Returns an address owned by the wallet that should be used as a change address to return leftover assets during transaction creation back to the connected wallet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getCollateral",
          "signature": "async getCollateral(): Promise<UTxO[]> {\n    const deserializedCollateral = await this.getCollateralUnspentOutput();\n    return deserializedCollateral.map((dc) => fromTxUnspentOutput(dc));\n  }",
          "documentation": "This function shall return a list of one or more UTXOs (unspent transaction outputs) controlled by the wallet that are required to reach AT LEAST the combined ADA value target specified in amount AND the best suitable to be used as collateral inputs for transactions with plutus script inputs (pure ADA-only UTXOs).\n\nIf this cannot be attained, an error message with an explanation of the blocking problem shall be returned. NOTE: wallets are free to return UTXOs that add up to a greater total ADA value than requested in the amount parameter, but wallets must never return any result where UTXOs would sum up to a smaller total ADA value, instead in a case like that an error message must be returned.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getExtensions",
          "signature": "async getExtensions(): Promise<number[]> {\n    try {\n      const _extensions: { cip: number }[] =\n        await this._walletInstance.getExtensions();\n      return _extensions.map((e) => e.cip);\n    } catch (e) {\n      return [];\n    }\n  }",
          "documentation": "Return a list of supported CIPs of the wallet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getNetworkId",
          "signature": "getNetworkId(): Promise<number> {\n    return this._walletInstance.getNetworkId();\n  }",
          "documentation": "Returns the network ID of the currently connected account. 0 is testnet and 1 is mainnet but other networks can possibly be returned by wallets. Those other network ID values are not governed by CIP-30. This result will stay the same unless the connected account has changed.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getRewardAddresses",
          "signature": "async getRewardAddresses(): Promise<string[]> {\n    const rewardAddresses = await this._walletInstance.getRewardAddresses();\n    return rewardAddresses.map((ra) => addressToBech32(deserializeAddress(ra)));\n  }",
          "documentation": "Returns a list of reward addresses owned by the wallet. A reward address is a stake address that is used to receive rewards from staking, generally starts from `stake` prefix.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUnusedAddresses",
          "signature": "async getUnusedAddresses(): Promise<string[]> {\n    const unusedAddresses = await this._walletInstance.getUnusedAddresses();\n    return unusedAddresses.map((una) =>\n      addressToBech32(deserializeAddress(una)),\n    );\n  }",
          "documentation": "Returns a list of unused addresses controlled by the wallet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUsedAddresses",
          "signature": "async getUsedAddresses(): Promise<string[]> {\n    const usedAddresses = await this._walletInstance.getUsedAddresses();\n    return usedAddresses.map((usa) => addressToBech32(deserializeAddress(usa)));\n  }",
          "documentation": "Returns a list of used addresses controlled by the wallet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUtxos",
          "signature": "async getUtxos(): Promise<UTxO[]> {\n    const deserializedUTxOs = await this.getUsedUTxOs();\n    return deserializedUTxOs.map((du) => fromTxUnspentOutput(du));\n  }",
          "documentation": "Return a list of all UTXOs (unspent transaction outputs) controlled by the wallet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "signData",
          "signature": "async signData(\n    payload: string,\n    address?: string | undefined,\n    convertFromUTF8 = true,\n  ): Promise<DataSignature> {\n    if (address === undefined) {\n      address = (await this.getUsedAddresses())[0]!;\n      if (address === undefined) {\n        address = await this.getChangeAddress();\n      }\n    }\n\n    const _payload = convertFromUTF8 ? fromUTF8(payload) : payload;\n\n    if (address.startsWith(\"drep1\")) {\n      return this._walletInstance.cip95!.signData(address, _payload);\n    }\n\n    const signerAddress = toAddress(address).toBytes().toString();\n    return this._walletInstance.signData(signerAddress, _payload);\n  }",
          "documentation": "This endpoint utilizes the [CIP-8 - Message Signing](https://cips.cardano.org/cips/cip8/) to sign arbitrary data, to verify the data was signed by the owner of the private key.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "signTx",
          "signature": "async signTx(unsignedTx: string, partialSign = false): Promise<string> {\n    const witness = await this._walletInstance.signTx(unsignedTx, partialSign);\n    if (witness === \"\") {\n      return unsignedTx;\n    }\n    return BrowserWallet.addBrowserWitnesses(unsignedTx, witness);\n  }",
          "documentation": "Requests user to sign the provided transaction (tx). The wallet should ask the user for permission, and if given, try to sign the supplied body and return a signed transaction. partialSign should be true if the transaction provided requires multiple signatures.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "signTxs",
          "signature": "async signTxs(unsignedTxs: string[], partialSign = false): Promise<string[]> {\n    let witnessSets: string[] | undefined = undefined;\n    // Hardcoded behavior customized for different wallet for now as there is no standard confirmed\n    switch (this._walletName) {\n      case \"Typhon Wallet\":\n        if (this._walletInstance.signTxs) {\n          witnessSets = await this._walletInstance.signTxs(\n            unsignedTxs,\n            partialSign,\n          );\n        }\n        break;\n      default:\n        if (this._walletInstance.signTxs) {\n          witnessSets = await this._walletInstance.signTxs(\n            unsignedTxs.map((cbor) => ({\n              cbor,\n              partialSign,\n            })),\n          );\n        } else if (this._walletInstance.experimental.signTxs) {\n          witnessSets = await this._walletInstance.experimental.signTxs(\n            unsignedTxs.map((cbor) => ({\n              cbor,\n              partialSign,\n            })),\n          );\n        }\n        break;\n    }\n\n    if (!witnessSets) throw new Error(\"Wallet does not support signTxs\");\n\n    const signedTxs: string[] = [];\n    for (let i = 0; i < witnessSets.length; i++) {\n      const unsignedTx = unsignedTxs[i]!;\n      const cWitness = witnessSets[i]!;\n      if (cWitness === \"\") {\n        // It's possible that txs are signed just to give\n        // browser wallet the tx context\n        signedTxs.push(unsignedTx);\n      } else {\n        const signedTx = BrowserWallet.addBrowserWitnesses(\n          unsignedTx,\n          cWitness,\n        );\n        signedTxs.push(signedTx);\n      }\n    }\n\n    return signedTxs;\n  }",
          "documentation": "Experimental feature - sign multiple transactions at once (Supported wallet(s): Typhon)",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "submitTx",
          "signature": "submitTx(tx: string): Promise<string> {\n    return this._walletInstance.submitTx(tx);\n  }",
          "documentation": "Submits the signed transaction to the blockchain network.\n\nAs wallets should already have this ability to submit transaction, we allow apps to request that a transaction be sent through it. If the wallet accepts the transaction and tries to send it, it shall return the transaction ID for the app to track. The wallet can return error messages or failure if there was an error in sending it.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUsedAddress",
          "signature": "async getUsedAddress(): Promise<Address> {\n    const usedAddresses = await this._walletInstance.getUsedAddresses();\n    if (usedAddresses.length === 0) throw new Error(\"No used addresses found\");\n    return deserializeAddress(usedAddresses[0]!);\n  }",
          "documentation": "Get a used address of type Address from the wallet.\n\nThis is used in transaction building.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getCollateralUnspentOutput",
          "signature": "async getCollateralUnspentOutput(\n    limit = DEFAULT_PROTOCOL_PARAMETERS.maxCollateralInputs,\n  ): Promise<TransactionUnspentOutput[]> {\n    let collateral: string[] = [];\n    try {\n      collateral = (await this._walletInstance.getCollateral()) ?? [];\n    } catch (e) {\n      try {\n        collateral =\n          (await this._walletInstance.experimental.getCollateral()) ?? [];\n      } catch (e) {\n        console.error(e);\n      }\n    }\n    return collateral.map((c) => deserializeTxUnspentOutput(c)).slice(0, limit);\n  }",
          "documentation": "Get a list of UTXOs to be used as collateral inputs for transactions with plutus script inputs.\n\nThis is used in transaction building.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUsedUTxOs",
          "signature": "async getUsedUTxOs(): Promise<TransactionUnspentOutput[]> {\n    const utxos = (await this._walletInstance.getUtxos()) ?? [];\n    return utxos.map((u) => deserializeTxUnspentOutput(u));\n  }",
          "documentation": "Get a list of UTXOs to be used for transaction building.\n\nThis is used in transaction building.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getAssets",
          "signature": "async getAssets(): Promise<AssetExtended[]> {\n    const balance = await this.getBalance();\n    return balance\n      .filter((v) => v.unit !== \"lovelace\")\n      .map((v) => {\n        const policyId = v.unit.slice(0, POLICY_ID_LENGTH);\n        const assetName = v.unit.slice(POLICY_ID_LENGTH);\n        const fingerprint = resolveFingerprint(policyId, assetName);\n\n        return {\n          unit: v.unit,\n          policyId,\n          assetName,\n          fingerprint,\n          quantity: v.quantity,\n        };\n      });\n  }",
          "documentation": "A helper function to get the assets in the wallet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getLovelace",
          "signature": "async getLovelace(): Promise<string> {\n    const balance = await this.getBalance();\n    const nativeAsset = balance.find((v) => v.unit === \"lovelace\");\n\n    return nativeAsset !== undefined ? nativeAsset.quantity : \"0\";\n  }",
          "documentation": "A helper function to get the lovelace balance in the wallet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getPolicyIdAssets",
          "signature": "async getPolicyIdAssets(policyId: string): Promise<AssetExtended[]> {\n    const assets = await this.getAssets();\n    return assets.filter((v) => v.policyId === policyId);\n  }",
          "documentation": "A helper function to get the assets of a specific policy ID in the wallet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getPolicyIds",
          "signature": "async getPolicyIds(): Promise<string[]> {\n    const balance = await this.getBalance();\n    return Array.from(\n      new Set(balance.map((v) => v.unit.slice(0, POLICY_ID_LENGTH))),\n    ).filter((p) => p !== \"lovelace\");\n  }",
          "documentation": "A helper function to get the policy IDs of all the assets in the wallet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getDRep",
          "signature": "async getDRep(): Promise<\n    | {\n        publicKey: string;\n        publicKeyHash: string;\n        dRepIDCip105: string;\n      }\n    | undefined\n  > {\n    const pubDRepKey = await this.getPubDRepKey();\n    try {\n      if (pubDRepKey === undefined) return undefined;\n\n      const { dRepIDHash } = await BrowserWallet.dRepKeyToDRepID(pubDRepKey);\n\n      const dRepIDCip105 = hexToBech32(\"drep\", dRepIDHash);\n\n      // const dRepIDBech32 = buildDRepID(dRepKey, await this.getNetworkId());\n      // console.log(66, \"dRepIDBech32\", dRepIDBech32, dRepIDCip105 === dRepIDBech32);\n\n      return {\n        publicKey: pubDRepKey,\n        publicKeyHash: dRepIDHash,\n        dRepIDCip105: dRepIDCip105,\n      };\n    } catch (e) {\n      console.error(e);\n      return undefined;\n    }\n  }",
          "documentation": "The connected wallet account provides the account's public DRep Key, derivation as described in CIP-0105.\nThese are used by the client to identify the user's on-chain CIP-1694 interactions, i.e. if a user has registered to be a DRep.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getPubDRepKey",
          "signature": "async getPubDRepKey(): Promise<string | undefined> {\n    try {\n      if (this._walletInstance.cip95 === undefined) return undefined;\n\n      const pubDRepKey = await this._walletInstance.cip95.getPubDRepKey();\n      return pubDRepKey;\n    } catch (e) {\n      console.error(e);\n      return undefined;\n    }\n  }",
          "documentation": "The connected wallet account provides the account's public DRep Key, derivation as described in CIP-0105.\nThese are used by the client to identify the user's on-chain CIP-1694 interactions, i.e. if a user has registered to be a DRep.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getRegisteredPubStakeKeys",
          "signature": "async getRegisteredPubStakeKeys(): Promise<\n    | {\n        pubStakeKeys: string[];\n        pubStakeKeyHashes: string[];\n      }\n    | undefined\n  > {\n    try {\n      if (this._walletInstance.cip95 === undefined) return undefined;\n\n      const pubStakeKeys =\n        await this._walletInstance.cip95.getRegisteredPubStakeKeys();\n\n      const pubStakeKeyHashes = await Promise.all(\n        pubStakeKeys.map(async (pubStakeKey) => {\n          const { dRepIDHash } =\n            await BrowserWallet.dRepKeyToDRepID(pubStakeKey);\n          return dRepIDHash;\n        }),\n      );\n\n      return {\n        pubStakeKeys: pubStakeKeys,\n        pubStakeKeyHashes: pubStakeKeyHashes,\n      };\n    } catch (e) {\n      console.error(e);\n      return undefined;\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUnregisteredPubStakeKeys",
          "signature": "async getUnregisteredPubStakeKeys(): Promise<\n    | {\n        pubStakeKeys: string[];\n        pubStakeKeyHashes: string[];\n      }\n    | undefined\n  > {\n    try {\n      if (this._walletInstance.cip95 === undefined) return undefined;\n\n      const pubStakeKeys =\n        await this._walletInstance.cip95.getUnregisteredPubStakeKeys();\n\n      const pubStakeKeyHashes = await Promise.all(\n        pubStakeKeys.map(async (pubStakeKey) => {\n          const { dRepIDHash } =\n            await BrowserWallet.dRepKeyToDRepID(pubStakeKey);\n          return dRepIDHash;\n        }),\n      );\n\n      return {\n        pubStakeKeys: pubStakeKeys,\n        pubStakeKeyHashes: pubStakeKeyHashes,\n      };\n    } catch (e) {\n      console.error(e);\n      return undefined;\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "dRepKeyToDRepID",
          "signature": "private static async dRepKeyToDRepID(dRepKey: string): Promise<{\n    dRepKeyHex: Ed25519PublicKeyHex;\n    dRepID: Ed25519PublicKey;\n    dRepIDHash: Ed25519KeyHashHex;\n  }> {\n    const dRepKeyHex = Ed25519PublicKeyHex(dRepKey);\n    const dRepID = Ed25519PublicKey.fromHex(dRepKeyHex);\n    const dRepIDHash = (await dRepID.hash()).hex();\n    return {\n      dRepKeyHex,\n      dRepID,\n      dRepIDHash,\n    };\n  }",
          "documentation": "",
          "static": true,
          "visibility": "private"
        },
        {
          "name": "resolveInstance",
          "signature": "private static resolveInstance(\n    walletName: string,\n    extensions: Extension[] = [],\n  ) {\n    if (window.cardano === undefined) return undefined;\n    if (window.cardano[walletName] === undefined) return undefined;\n\n    const wallet = window.cardano[walletName];\n\n    if (extensions.length > 0) {\n      return wallet.enable({ extensions: extensions });\n    } else {\n      return wallet?.enable();\n    }\n  }",
          "documentation": "",
          "static": true,
          "visibility": "private"
        },
        {
          "name": "addBrowserWitnesses",
          "signature": "static addBrowserWitnesses(unsignedTx: string, witnesses: string) {\n    const cWitness = Serialization.TransactionWitnessSet.fromCbor(\n      CardanoSDKUtil.HexBlob(witnesses),\n    )\n      .vkeys()\n      ?.values();\n\n    if (cWitness === undefined) {\n      return unsignedTx;\n    }\n\n    let tx = deserializeTx(unsignedTx);\n    // let tx = Transaction.fromCbor(CardanoSDK.TxCBOR(txHex));\n    let witnessSet = tx.witnessSet();\n    let witnessSetVkeys = witnessSet.vkeys();\n    let witnessSetVkeysValues: Serialization.VkeyWitness[] = witnessSetVkeys\n      ? [...witnessSetVkeys.values(), ...cWitness]\n      : [...cWitness];\n    witnessSet.setVkeys(\n      Serialization.CborSet.fromCore(\n        witnessSetVkeysValues.map((vkw) => vkw.toCore()),\n        VkeyWitness.fromCore,\n      ),\n    );\n\n    return new Transaction(tx.body(), witnessSet, tx.auxiliaryData()).toCbor();\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "getSupportedExtensions",
          "signature": "static getSupportedExtensions(wallet: string) {\n    const _supportedExtensions = window?.cardano?.[wallet]?.supportedExtensions;\n    if (_supportedExtensions) return _supportedExtensions;\n    else return [];\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "walletInstance",
          "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/types/index\").WalletInstance",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "browser-wallet",
      "source": "mesh-wallet"
    },
    {
      "name": "WalletStaticMethods",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/embedded/index.ts",
      "extends": null,
      "implements": [],
      "methods": [
        {
          "name": "privateKeyBech32ToPrivateKeyHex",
          "signature": "static privateKeyBech32ToPrivateKeyHex(_bech32: string): string {\n    const bech32DecodedBytes = BaseEncoding.bech32.decodeToBytes(_bech32).bytes;\n    const bip32PrivateKey = Bip32PrivateKey.fromBytes(bech32DecodedBytes);\n    return bytesToHex(bip32PrivateKey.bytes());\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "mnemonicToPrivateKeyHex",
          "signature": "static mnemonicToPrivateKeyHex(words: string[]): string {\n    const entropy = mnemonicToEntropy(words.join(\" \"));\n    const bip32PrivateKey = buildBip32PrivateKey(entropy);\n    return bytesToHex(bip32PrivateKey.bytes());\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "signingKeyToHexes",
          "signature": "static signingKeyToHexes(\n    paymentKey: string,\n    stakeKey: string,\n  ): [string, string] {\n    return [\n      paymentKey.startsWith(\"5820\") ? paymentKey.slice(4) : paymentKey,\n      stakeKey.startsWith(\"5820\") ? stakeKey.slice(4) : stakeKey,\n    ];\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "bip32BytesToPrivateKeyHex",
          "signature": "static bip32BytesToPrivateKeyHex(bip32Bytes: Uint8Array): string {\n    const bip32PrivateKey = Bip32PrivateKey.fromBytes(bip32Bytes);\n    return bytesToHex(bip32PrivateKey.bytes());\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "getAddresses",
          "signature": "static getAddresses(\n    paymentKey: Ed25519PrivateKey,\n    stakingKey: Ed25519PrivateKey,\n    networkId = 0,\n  ): {\n    baseAddress: Address;\n    enterpriseAddress: Address;\n    rewardAddress: Address;\n  } {\n    const baseAddress = buildBaseAddress(\n      networkId,\n      Hash28ByteBase16.fromEd25519KeyHashHex(\n        paymentKey.toPublic().hash().hex(),\n      ),\n      Hash28ByteBase16.fromEd25519KeyHashHex(\n        stakingKey.toPublic().hash().hex(),\n      ),\n    ).toAddress();\n\n    const enterpriseAddress = buildEnterpriseAddress(\n      networkId,\n      Hash28ByteBase16.fromEd25519KeyHashHex(\n        paymentKey.toPublic().hash().hex(),\n      ),\n    ).toAddress();\n\n    const rewardAddress = buildRewardAddress(\n      networkId,\n      Hash28ByteBase16.fromEd25519KeyHashHex(\n        stakingKey.toPublic().hash().hex(),\n      ),\n    ).toAddress();\n\n    return {\n      baseAddress: baseAddress,\n      enterpriseAddress: enterpriseAddress,\n      rewardAddress: rewardAddress,\n    };\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "getDRepKey",
          "signature": "static getDRepKey(\n    dRepKey: Ed25519PrivateKey,\n    networkId = 0,\n  ): {\n    pubDRepKey: string;\n    dRepIDBech32: DRepID;\n    dRepIDHash: Ed25519KeyHashHex;\n    dRepIDCip105: string;\n  } {\n    const pubDRepKey = dRepKey.toPublic().hex().toString();\n\n    const dRepIDBech32 = buildDRepID(\n      Ed25519PublicKeyHex(pubDRepKey),\n      networkId,\n    );\n    const dRep = DRep.newKeyHash(dRepKey.toPublic().hash().hex());\n    const dRepIDHash = dRep.toKeyHash()!;\n\n    const dRepIDCip105 = hexToBech32(\"drep\", dRepIDHash);\n\n    return {\n      pubDRepKey,\n      dRepIDBech32,\n      dRepIDHash,\n      dRepIDCip105,\n    };\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "generateMnemonic",
          "signature": "static generateMnemonic(strength = 256): string[] {\n    const mnemonic = generateMnemonic(strength);\n    return mnemonic.split(\" \");\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "addWitnessSets",
          "signature": "static addWitnessSets(txHex: string, witnesses: VkeyWitness[]): string {\n    let tx = deserializeTx(txHex);\n    let witnessSet = tx.witnessSet();\n    let witnessSetVkeys = witnessSet.vkeys();\n    let witnessSetVkeysValues: Serialization.VkeyWitness[] = witnessSetVkeys\n      ? [...witnessSetVkeys.values(), ...witnesses]\n      : witnesses;\n    witnessSet.setVkeys(\n      Serialization.CborSet.fromCore(\n        witnessSetVkeysValues.map((vkw) => vkw.toCore()),\n        VkeyWitness.fromCore,\n      ),\n    );\n    return new Transaction(tx.body(), witnessSet, tx.auxiliaryData()).toCbor();\n  }",
          "documentation": "",
          "static": true,
          "visibility": "public"
        }
      ],
      "properties": [],
      "module": "index",
      "source": "mesh-wallet"
    },
    {
      "name": "EmbeddedWallet",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/embedded/index.ts",
      "extends": "WalletStaticMethods",
      "implements": [],
      "methods": [
        {
          "name": "init",
          "signature": "async init(): Promise<void> {\n    await Crypto.ready();\n    this.cryptoIsReady = true;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getAccount",
          "signature": "getAccount(accountIndex = 0, keyIndex = 0): Account {\n    if (this._walletSecret == undefined)\n      throw new Error(\"[EmbeddedWallet] No keys initialized\");\n\n    const { paymentKey, stakeKey, dRepKey } = buildKeys(\n      this._walletSecret,\n      accountIndex,\n      keyIndex,\n    );\n\n    const { baseAddress, enterpriseAddress, rewardAddress } =\n      WalletStaticMethods.getAddresses(paymentKey, stakeKey, this._networkId);\n\n    let _account: Account = {\n      baseAddress: baseAddress,\n      enterpriseAddress: enterpriseAddress,\n      rewardAddress: rewardAddress,\n\n      baseAddressBech32: baseAddress.toBech32(),\n      enterpriseAddressBech32: enterpriseAddress.toBech32(),\n      rewardAddressBech32: rewardAddress.toBech32(),\n\n      paymentKey: paymentKey,\n      stakeKey: stakeKey,\n      paymentKeyHex: paymentKey.hex(),\n      stakeKeyHex: stakeKey.hex(),\n    };\n\n    if (dRepKey) {\n      const { pubDRepKey, dRepIDBech32, dRepIDHash, dRepIDCip105 } =\n        WalletStaticMethods.getDRepKey(dRepKey, this._networkId);\n      _account.drepKey = dRepKey;\n      _account.pubDRepKey = pubDRepKey;\n      _account.dRepIDBech32 = dRepIDBech32;\n      _account.dRepIDHash = dRepIDHash;\n      _account.dRepIDCip105 = dRepIDCip105;\n    }\n\n    return _account;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getNetworkId",
          "signature": "getNetworkId(): number {\n    return this._networkId;\n  }",
          "documentation": "Get wallet network ID.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "signData",
          "signature": "signData(\n    address: string,\n    payload: string,\n    accountIndex = 0,\n    keyIndex = 0,\n  ): DataSignature {\n    try {\n      const { baseAddress, enterpriseAddress, rewardAddress, paymentKey } =\n        this.getAccount(accountIndex, keyIndex);\n\n      const foundAddress = [baseAddress, enterpriseAddress, rewardAddress].find(\n        (a) => a.toBech32() === address,\n      );\n\n      if (foundAddress === undefined)\n        throw new Error(\n          `[EmbeddedWallet] Address: ${address} doesn't belong to this account.`,\n        );\n\n      // todo tw\n      return signData(payload, {\n        address: Address.fromBech32(address),\n        key: paymentKey,\n      });\n    } catch (error) {\n      throw new Error(\n        `[EmbeddedWallet] An error occurred during signData: ${error}.`,\n      );\n    }\n  }",
          "documentation": "This endpoint utilizes the [CIP-8 - Message Signing](https://cips.cardano.org/cips/cip8/) to sign arbitrary data, to verify the data was signed by the owner of the private key.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "signTx",
          "signature": "signTx(\n    unsignedTx: string,\n    accountIndex = 0,\n    keyIndex = 0,\n    accountType: AccountType = \"payment\",\n  ): VkeyWitness {\n    try {\n      const txHash = deserializeTxHash(resolveTxHash(unsignedTx));\n\n      const { paymentKey, stakeKey, drepKey } = this.getAccount(\n        accountIndex,\n        keyIndex,\n      );\n\n      let key = paymentKey;\n      if (accountType === \"stake\") {\n        key = stakeKey;\n      } else if (accountType === \"drep\") {\n        if (!drepKey) throw new Error(\"DRep key not found\");\n        key = drepKey;\n      }\n\n      const vKeyWitness = new VkeyWitness(\n        key.toPublic().hex(),\n        key.sign(HexBlob(txHash)).hex(),\n      );\n\n      return vKeyWitness;\n    } catch (error) {\n      throw new Error(\n        `[EmbeddedWallet] An error occurred during signTx: ${error}.`,\n      );\n    }\n  }",
          "documentation": "This endpoints sign the provided transaction (unsignedTx) with the private key of the owner.",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "_walletSecret",
          "type": "string | [string, string] | undefined",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_networkId",
          "type": "number",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "cryptoIsReady",
          "type": "boolean",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "index",
      "source": "mesh-wallet"
    },
    {
      "name": "MeshWallet",
      "documentation": "Mesh Wallet provides a set of APIs to interact with the blockchain. This wallet is compatible with Mesh transaction builders.\n\nThere are 4 types of keys that can be used to create a wallet:\n- root: A private key in bech32 format, generally starts with `xprv1`\n- cli: CLI generated keys starts with `5820`. Payment key is required, and the stake key is optional.\n- mnemonic: A list of 24 words\n- address: A bech32 address that can be used to create a read-only wallet, generally starts with `addr` or `addr_test1`\n\n```javascript\nimport { MeshWallet, BlockfrostProvider } from '@meshsdk/core';\n\nconst provider = new BlockfrostProvider('<BLOCKFROST_API_KEY>');\n\nconst wallet = new MeshWallet({\n  networkId: 0,\n  fetcher: provider,\n  submitter: provider,\n  key: {\n    type: 'mnemonic',\n    words: [\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\",\"solution\"],\n  },\n});\n```\n\nPlease call `await wallet.init()` after creating the wallet to fetch the addresses from the wallet.",
      "isExported": true,
      "importPath": "offchain/mesh-wallet/src/mesh/index.ts",
      "extends": null,
      "implements": [
        "IWallet"
      ],
      "methods": [
        {
          "name": "init",
          "signature": "async init() {\n    if (this._wallet && !this._wallet.cryptoIsReady) {\n      await this._wallet.init();\n      this.getAddressesFromWallet(this._wallet);\n    }\n  }",
          "documentation": "Initializes the wallet. This is a required call as fetching addresses from the wallet is an async operation.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getAddresses",
          "signature": "getAddresses() {\n    return this.addresses;\n  }",
          "documentation": "Returns all derived addresses from the wallet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getBalance",
          "signature": "async getBalance(): Promise<Asset[]> {\n    await this.init();\n\n    const utxos = await this.getUnspentOutputs();\n\n    const assets = new Map<string, number>();\n    utxos.map((utxo) => {\n      const _utxo = fromTxUnspentOutput(utxo);\n      _utxo.output.amount.map((asset) => {\n        const assetId = asset.unit;\n        const amount = Number(asset.quantity);\n        if (assets.has(assetId)) {\n          const quantity = assets.get(assetId)!;\n          assets.set(assetId, quantity + amount);\n        } else {\n          assets.set(assetId, amount);\n        }\n      });\n    });\n\n    const arrayAssets: Asset[] = Array.from(assets, ([unit, quantity]) => ({\n      unit,\n      quantity: quantity.toString(),\n    }));\n\n    return arrayAssets;\n  }",
          "documentation": "Returns a list of assets in the wallet. This API will return every assets in the wallet. Each asset is an object with the following properties:\n- A unit is provided to display asset's name on the user interface.\n- A quantity is provided to display asset's quantity on the user interface.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getChangeAddress",
          "signature": "async getChangeAddress(\n    addressType: GetAddressType = \"payment\",\n  ): Promise<string> {\n    await this.init();\n\n    if (this.addresses.baseAddressBech32 && addressType === \"payment\") {\n      return this.addresses.baseAddressBech32;\n    }\n    return this.addresses.enterpriseAddressBech32!;\n  }",
          "documentation": "Returns an address owned by the wallet that should be used as a change address to return leftover assets during transaction creation back to the connected wallet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getCollateral",
          "signature": "async getCollateral(\n    addressType: GetAddressType = \"payment\",\n  ): Promise<UTxO[]> {\n    await this.init();\n\n    const utxos = await this.getCollateralUnspentOutput(addressType);\n    return utxos.map((utxo, i) => {\n      return fromTxUnspentOutput(utxo);\n    });\n  }",
          "documentation": "This function shall return a list of one or more UTXOs (unspent transaction outputs) controlled by the wallet that are required to reach AT LEAST the combined ADA value target specified in amount AND the best suitable to be used as collateral inputs for transactions with plutus script inputs (pure ADA-only UTXOs).\n\nIf this cannot be attained, an error message with an explanation of the blocking problem shall be returned. NOTE: wallets are free to return UTXOs that add up to a greater total ADA value than requested in the amount parameter, but wallets must never return any result where UTXOs would sum up to a smaller total ADA value, instead in a case like that an error message must be returned.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getExtensions",
          "signature": "async getExtensions(): Promise<number[]> {\n    return [];\n  }",
          "documentation": "Return a list of supported CIPs of the wallet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getCollateralUnspentOutput",
          "signature": "async getCollateralUnspentOutput(\n    addressType: GetAddressType = \"payment\",\n  ): Promise<TransactionUnspentOutput[]> {\n    await this.init();\n\n    const utxos = await this.getUnspentOutputs(addressType);\n\n    // find utxos that are pure ADA-only\n    const pureAdaUtxos = utxos.filter((utxo) => {\n      return utxo.output().amount().multiasset() === undefined;\n    });\n\n    // sort utxos by their lovelace amount\n    pureAdaUtxos.sort((a, b) => {\n      return (\n        Number(a.output().amount().coin()) - Number(b.output().amount().coin())\n      );\n    });\n\n    // return the smallest utxo but not less than 5000000 lovelace\n    for (const utxo of pureAdaUtxos) {\n      if (Number(utxo.output().amount().coin()) >= 5000000) {\n        return [utxo];\n      }\n    }\n\n    return [];\n  }",
          "documentation": "Get a list of UTXOs to be used as collateral inputs for transactions with plutus script inputs.\n\nThis is used in transaction building.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getDRep",
          "signature": "async getDRep(): Promise<\n    | {\n        publicKey: string;\n        publicKeyHash: string;\n        dRepIDCip105: string;\n      }\n    | undefined\n  > {\n    await this.init();\n\n    if (\n      this.addresses.pubDRepKey &&\n      this.addresses.dRepIDHash &&\n      this.addresses.dRepIDCip105\n    )\n      return {\n        publicKey: this.addresses.pubDRepKey,\n        publicKeyHash: this.addresses.dRepIDHash,\n        dRepIDCip105: this.addresses.dRepIDCip105,\n      };\n\n    return undefined;\n  }",
          "documentation": "The connected wallet account provides the account's public DRep Key, derivation as described in CIP-0105.\nThese are used by the client to identify the user's on-chain CIP-1694 interactions, i.e. if a user has registered to be a DRep.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getNetworkId",
          "signature": "async getNetworkId(): Promise<number> {\n    return this._networkId;\n  }",
          "documentation": "Returns the network ID of the currently connected account. 0 is testnet and 1 is mainnet but other networks can possibly be returned by wallets. Those other network ID values are not governed by CIP-30. This result will stay the same unless the connected account has changed.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getRewardAddresses",
          "signature": "async getRewardAddresses(): Promise<string[]> {\n    return [this.addresses.rewardAddressBech32!];\n  }",
          "documentation": "Returns a list of reward addresses owned by the wallet. A reward address is a stake address that is used to receive rewards from staking, generally starts from `stake` prefix.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUnusedAddresses",
          "signature": "async getUnusedAddresses(): Promise<string[]> {\n    return [await this.getChangeAddress()];\n  }",
          "documentation": "Returns a list of unused addresses controlled by the wallet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUsedAddresses",
          "signature": "async getUsedAddresses(): Promise<string[]> {\n    return [await this.getChangeAddress()];\n  }",
          "documentation": "Returns a list of used addresses controlled by the wallet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUsedUTxOs",
          "signature": "async getUsedUTxOs(\n    addressType: GetAddressType = \"payment\",\n  ): Promise<TransactionUnspentOutput[]> {\n    await this.init();\n    return await this.getUnspentOutputs(addressType);\n  }",
          "documentation": "Get a list of UTXOs to be used for transaction building.\n\nThis is used in transaction building.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUtxos",
          "signature": "async getUtxos(addressType: GetAddressType = \"payment\"): Promise<UTxO[]> {\n    const utxos = await this.getUsedUTxOs(addressType);\n    return utxos.map((c) => fromTxUnspentOutput(c));\n  }",
          "documentation": "Return a list of all UTXOs (unspent transaction outputs) controlled by the wallet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "signData",
          "signature": "async signData(payload: string, address?: string): Promise<DataSignature> {\n    await this.init();\n\n    if (!this._wallet) {\n      throw new Error(\n        \"[MeshWallet] Read only wallet does not support signing data.\",\n      );\n    }\n    if (address === undefined) {\n      address = await this.getChangeAddress()!;\n    }\n    return this._wallet.signData(\n      address,\n      payload,\n      this._accountIndex,\n      this._keyIndex,\n    );\n  }",
          "documentation": "This endpoint utilizes the [CIP-8 - Message Signing](https://cips.cardano.org/cips/cip8/) to sign arbitrary data, to verify the data was signed by the owner of the private key.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "signTx",
          "signature": "async signTx(unsignedTx: string, partialSign = false): Promise<string> {\n    await this.init();\n\n    if (!this._wallet) {\n      throw new Error(\n        \"[MeshWallet] Read only wallet does not support signing data.\",\n      );\n    }\n\n    const tx = deserializeTx(unsignedTx);\n    if (\n      !partialSign &&\n      tx.witnessSet().vkeys() !== undefined &&\n      tx.witnessSet().vkeys()!.size() !== 0\n    )\n      throw new Error(\n        \"Signatures already exist in the transaction in a non partial sign call\",\n      );\n\n    const newSignatures = this._wallet.signTx(\n      unsignedTx,\n      this._accountIndex,\n      this._keyIndex,\n      this._accountType,\n    );\n\n    let signedTx = EmbeddedWallet.addWitnessSets(unsignedTx, [newSignatures]);\n    return signedTx;\n  }",
          "documentation": "Requests user to sign the provided transaction (tx). The wallet should ask the user for permission, and if given, try to sign the supplied body and return a signed transaction. partialSign should be true if the transaction provided requires multiple signatures.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "signTxs",
          "signature": "async signTxs(unsignedTxs: string[], partialSign = false): Promise<string[]> {\n    await this.init();\n\n    if (!this._wallet) {\n      throw new Error(\n        \"[MeshWallet] Read only wallet does not support signing data.\",\n      );\n    }\n\n    const signedTxs: string[] = [];\n\n    for (const unsignedTx of unsignedTxs) {\n      const signedTx = await this.signTx(unsignedTx, partialSign);\n      signedTxs.push(signedTx);\n    }\n\n    return signedTxs;\n  }",
          "documentation": "Experimental feature - sign multiple transactions at once.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "submitTx",
          "signature": "async submitTx(tx: string): Promise<string> {\n    if (!this._submitter) {\n      throw new Error(\n        \"[MeshWallet] Submitter is required to submit transactions. Please provide a submitter.\",\n      );\n    }\n    return this._submitter.submitTx(tx);\n  }",
          "documentation": "Submits the signed transaction to the blockchain network.\n\nAs wallets should already have this ability to submit transaction, we allow apps to request that a transaction be sent through it. If the wallet accepts the transaction and tries to send it, it shall return the transaction ID for the app to track. The wallet can return error messages or failure if there was an error in sending it.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUsedAddress",
          "signature": "getUsedAddress(addressType: GetAddressType = \"payment\"): Address {\n    if (this.addresses.baseAddressBech32 && addressType === \"payment\") {\n      return toAddress(this.addresses.baseAddressBech32);\n    } else {\n      return toAddress(this.addresses.enterpriseAddressBech32!);\n    }\n  }",
          "documentation": "Get a used address of type Address from the wallet.\n\nThis is used in transaction building.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUnspentOutputs",
          "signature": "async getUnspentOutputs(\n    addressType: GetAddressType = \"payment\",\n  ): Promise<TransactionUnspentOutput[]> {\n    if (!this._fetcher) {\n      throw new Error(\n        \"[MeshWallet] Fetcher is required to fetch UTxOs. Please provide a fetcher.\",\n      );\n    }\n\n    const utxos = await this._fetcher.fetchAddressUTxOs(\n      this.addresses.baseAddressBech32 && addressType == \"payment\"\n        ? this.addresses.baseAddressBech32!\n        : this.addresses.enterpriseAddressBech32!,\n    );\n\n    return utxos.map((utxo) => toTxUnspentOutput(utxo));\n  }",
          "documentation": "Get a list of UTXOs to be used for transaction building.\n\nThis is used in transaction building.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getAssets",
          "signature": "async getAssets(): Promise<AssetExtended[]> {\n    const balance = await this.getBalance();\n    return balance\n      .filter((v) => v.unit !== \"lovelace\")\n      .map((v) => {\n        const policyId = v.unit.slice(0, POLICY_ID_LENGTH);\n        const assetName = v.unit.slice(POLICY_ID_LENGTH);\n        const fingerprint = resolveFingerprint(policyId, assetName);\n\n        return {\n          unit: v.unit,\n          policyId,\n          assetName: toUTF8(assetName),\n          fingerprint,\n          quantity: v.quantity,\n        };\n      });\n  }",
          "documentation": "A helper function to get the assets in the wallet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getLovelace",
          "signature": "async getLovelace(): Promise<string> {\n    const balance = await this.getBalance();\n    const nativeAsset = balance.find((v) => v.unit === \"lovelace\");\n\n    return nativeAsset !== undefined ? nativeAsset.quantity : \"0\";\n  }",
          "documentation": "A helper function to get the lovelace balance in the wallet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getPolicyIdAssets",
          "signature": "async getPolicyIdAssets(policyId: string): Promise<AssetExtended[]> {\n    const assets = await this.getAssets();\n    return assets.filter((v) => v.policyId === policyId);\n  }",
          "documentation": "A helper function to get the assets of a specific policy ID in the wallet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getPolicyIds",
          "signature": "async getPolicyIds(): Promise<string[]> {\n    const balance = await this.getBalance();\n    return Array.from(\n      new Set(balance.map((v) => v.unit.slice(0, POLICY_ID_LENGTH))),\n    ).filter((p) => p !== \"lovelace\");\n  }",
          "documentation": "A helper function to get the policy IDs of all the assets in the wallet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getRegisteredPubStakeKeys",
          "signature": "async getRegisteredPubStakeKeys(): Promise<\n    | {\n        pubStakeKeys: string[];\n        pubStakeKeyHashes: string[];\n      }\n    | undefined\n  > {\n    console.warn(\"Not implemented yet\");\n    return undefined;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUnregisteredPubStakeKeys",
          "signature": "async getUnregisteredPubStakeKeys(): Promise<\n    | {\n        pubStakeKeys: string[];\n        pubStakeKeyHashes: string[];\n      }\n    | undefined\n  > {\n    console.warn(\"Not implemented yet\");\n    return undefined;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "createCollateral",
          "signature": "async createCollateral(): Promise<string> {\n    const tx = new Transaction({ initiator: this });\n    tx.sendLovelace(await this.getChangeAddress(), \"5000000\");\n    const unsignedTx = await tx.build();\n    const signedTx = await this.signTx(unsignedTx);\n    const txHash = await this.submitTx(signedTx);\n    return txHash;\n  }",
          "documentation": "A helper function to create a collateral input for a transaction.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getPubDRepKey",
          "signature": "getPubDRepKey(): {\n    pubDRepKey: string | undefined;\n    dRepIDBech32: string | undefined;\n    dRepIDHash: string | undefined;\n    dRepIDCip105: string | undefined;\n  } {\n    return {\n      pubDRepKey: this.addresses.pubDRepKey,\n      dRepIDBech32: this.addresses.dRepIDBech32,\n      dRepIDHash: this.addresses.dRepIDHash,\n      dRepIDCip105: this.addresses.dRepIDCip105,\n    };\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "brew",
          "signature": "static brew(privateKey = false, strength = 256): string[] | string {\n    const mnemonic = EmbeddedWallet.generateMnemonic(strength);\n\n    if (privateKey) {\n      return resolvePrivateKey(mnemonic);\n    }\n\n    return mnemonic;\n  }",
          "documentation": "Generate mnemonic or private key",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "getAddressesFromWallet",
          "signature": "private getAddressesFromWallet(wallet: EmbeddedWallet) {\n    const account = wallet.getAccount(this._accountIndex, this._keyIndex);\n\n    this.addresses = {\n      baseAddress: account.baseAddress,\n      enterpriseAddress: account.enterpriseAddress,\n      rewardAddress: account.rewardAddress,\n      baseAddressBech32: account.baseAddressBech32,\n      enterpriseAddressBech32: account.enterpriseAddressBech32,\n      rewardAddressBech32: account.rewardAddressBech32,\n\n      pubDRepKey: account.pubDRepKey,\n      dRepIDBech32: account.dRepIDBech32,\n      dRepIDHash: account.dRepIDHash,\n      dRepIDCip105: account.dRepIDCip105,\n    };\n  }",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "buildAddressFromBech32Address",
          "signature": "private buildAddressFromBech32Address(address: string) {\n    let pubKeyHash = undefined;\n    let stakeKeyHash = undefined;\n\n    const baseAddress = Address.fromBech32(address).asBase();\n    if (baseAddress) {\n      pubKeyHash = baseAddress.getPaymentCredential().hash;\n      stakeKeyHash = baseAddress.getStakeCredential().hash;\n    }\n    const enterpriseAddress = Address.fromBech32(address).asEnterprise();\n    if (enterpriseAddress) {\n      pubKeyHash = enterpriseAddress.getPaymentCredential().hash;\n    }\n\n    const rewardAddress = Address.fromBech32(address).asReward();\n    if (rewardAddress) {\n      stakeKeyHash = rewardAddress.getPaymentCredential().hash;\n    }\n\n    if (pubKeyHash && stakeKeyHash) {\n      this.addresses.baseAddress = buildBaseAddress(\n        this._networkId,\n        Hash28ByteBase16.fromEd25519KeyHashHex(Ed25519KeyHashHex(pubKeyHash)),\n        Hash28ByteBase16.fromEd25519KeyHashHex(\n          Ed25519KeyHashHex(Ed25519KeyHashHex(stakeKeyHash)),\n        ),\n      ).toAddress();\n      this.addresses.baseAddressBech32 = this.addresses.baseAddress.toBech32();\n    }\n\n    if (pubKeyHash) {\n      this.addresses.enterpriseAddress = buildEnterpriseAddress(\n        this._networkId,\n        Hash28ByteBase16.fromEd25519KeyHashHex(Ed25519KeyHashHex(pubKeyHash)),\n      ).toAddress();\n      this.addresses.enterpriseAddressBech32 =\n        this.addresses.enterpriseAddress.toBech32();\n    }\n\n    if (stakeKeyHash) {\n      this.addresses.rewardAddress = buildRewardAddress(\n        this._networkId,\n        Hash28ByteBase16.fromEd25519KeyHashHex(Ed25519KeyHashHex(stakeKeyHash)),\n      ).toAddress();\n\n      this.addresses.rewardAddressBech32 =\n        this.addresses.rewardAddress.toBech32();\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "properties": [
        {
          "name": "_keyType",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_accountType",
          "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/embedded/index\").AccountType",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_wallet",
          "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-wallet/src/embedded/index\").EmbeddedWallet | null",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_accountIndex",
          "type": "number",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_keyIndex",
          "type": "number",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_fetcher",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_submitter",
          "type": "any",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_networkId",
          "type": "0 | 1",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "addresses",
          "type": "{ baseAddress?: any; enterpriseAddress?: any; rewardAddress?: any; baseAddressBech32?: string | undefined; enterpriseAddressBech32?: string | undefined; rewardAddressBech32?: string | undefined; pubDRepKey?: string | undefined; dRepIDBech32?: any; dRepIDHash?: any; dRepIDCip105?: string | undefined; }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "index",
      "source": "mesh-wallet"
    },
    {
      "name": "BrowserWallet",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/bitcoin/src/wallets/browser/index.ts",
      "extends": null,
      "implements": [
        "IBitcoinWallet"
      ],
      "methods": [
        {
          "name": "enable",
          "signature": "static async enable(\n    message: string,\n    purposes = [\"payment\"]\n  ): Promise<BrowserWallet> {\n    const response = await WalletStaticMethods.request(\"getAccounts\", {\n      purposes: purposes,\n      message: message,\n    });\n    if (response.status === \"success\") {\n      return new BrowserWallet(purposes);\n    }\n    throw new Error(\"Failed to enable wallet\");\n  }",
          "documentation": "This is the entrypoint to start communication with the user's wallet. The wallet should request the user's permission to connect the web page to the user's wallet, and if permission has been granted, the wallet will be returned and exposing the full API for the dApp to use.",
          "static": true,
          "visibility": "public"
        },
        {
          "name": "getAddresses",
          "signature": "async getAddresses(): Promise<Address[] | undefined> {\n    try {\n      const response = await this.request(\"getAddresses\", {\n        purposes: this._purposes,\n      });\n      if (response.status === \"success\") {\n        return response.result.addresses as Address[];\n      }\n    } catch (err) {\n      console.error(\"getAccounts ~ error:\", err);\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getChangeAddress",
          "signature": "async getChangeAddress() {\n    const addresses = await this.getAddresses();\n    const address = addresses?.find((address) => address.purpose === \"payment\");\n    if (address) return address.address;\n    throw new Error(\"No change address found\");\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getCollateral",
          "signature": "async getCollateral() {\n    console.log(\"Method getCollateral not implemented.\");\n    return [];\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getNetworkId",
          "signature": "async getNetworkId(): Promise<0 | 1> {\n    return 1;\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "request",
          "signature": "async request(method: string, params?: any) {\n    return WalletStaticMethods.request(method, params);\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "signData",
          "signature": "async signData(\n    payload: string,\n    address?: string,\n    addressType: \"p2wpkh\" | \"p2tr\" | \"stacks\" = \"p2wpkh\"\n  ): Promise<\n    | {\n        address: string;\n        signature: string;\n        messageHash: string;\n      }\n    | undefined\n  > {\n    try {\n      let _address = address;\n      if (!_address) {\n        _address = await this.getAddresses().then((addresses) => {\n          const address = addresses?.find(\n            (address) => address.addressType === addressType\n          );\n          return address?.address;\n        });\n      }\n\n      if (_address) {\n        const response = await this.request(\"signMessage\", {\n          message: payload,\n          address: _address,\n        });\n        if (response.status === \"success\") {\n          return response.result;\n        }\n      }\n    } catch (err) {\n      console.error(\"signMessage ~ error:\", err);\n    }\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "signTx",
          "signature": "async signTx(signedTx: string): Promise<string> {\n    console.log(\"Method signTx not implemented.\");\n    return \"\";\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "submitTx",
          "signature": "async submitTx(signedTx: string): Promise<string> {\n    console.log(\"Method submitTx not implemented.\");\n    return \"\";\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "_purposes",
          "type": "string[]",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "module": "index",
      "source": "bitcoin"
    },
    {
      "name": "EmbeddedWallet",
      "documentation": "EmbeddedWallet is a class that provides a simple interface to interact with Bitcoin wallets.",
      "isExported": true,
      "importPath": "offchain/bitcoin/src/wallets/embedded/index.ts",
      "extends": null,
      "implements": [],
      "methods": [
        {
          "name": "getAddress",
          "signature": "getAddress(): Address {\n    return resolveAddress(\n      this._wallet.publicKey,\n      this._network\n    );\n\n    // const p2wpkh = bitcoin.payments.p2wpkh({\n    //   pubkey: this._wallet.publicKey,\n    //   network: this._network,\n    // });\n\n    // if (!p2wpkh?.address) {\n    //   throw new Error(\"Address is not initialized.\");\n    // }\n\n    // return {\n    //   address: p2wpkh.address,\n    //   publicKey: this._wallet.publicKey.toString(\"hex\"),\n    //   purpose: \"payment\",\n    //   addressType: \"p2wpkh\",\n    // };\n  }",
          "documentation": "Returns the wallet's SegWit (P2WPKH) address and associated public key.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getPublicKey",
          "signature": "getPublicKey(): string {\n    return this._wallet.publicKey.toString(\"hex\");\n  }",
          "documentation": "Returns the hex-encoded public key of the wallet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getNetworkId",
          "signature": "getNetworkId(): 0 | 1 {\n    return this._network === bitcoin.networks.testnet ? 1 : 0;\n  }",
          "documentation": "Returns the network identifier of the wallet.\n0': Indicates the Bitcoin mainnet.\n1': Indicates the Bitcoin testnet.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getUTxOs",
          "signature": "async getUTxOs(): Promise<UTxO[]> {\n    const address = this.getAddress();\n    if (this._provider === undefined) {\n      throw new Error(\"`provider` is not defined. Provide a BitcoinProvider.\");\n    }\n\n    return await this._provider.fetchAddressUTxOs(address.address);\n  }",
          "documentation": "Get UTXOs for the wallet address.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "signData",
          "signature": "signData(message: string): string {\n    if (!this._wallet.privateKey) {\n      throw new Error(\"Private key is not available for signing.\");\n    }\n\n    // Create ECPair from private key\n    const keyPair = ECPair.fromPrivateKey(this._wallet.privateKey, {\n      compressed: true,\n    });\n    // Prepare message buffer\n    const messageBuffer = Buffer.from(message, \"utf8\");\n    // Prepare the buffer to sign (see bitcoinjs-message implementation)\n\n    const bufferToHash = Buffer.concat([\n      varIntBuffer(messageBuffer.length),\n      messageBuffer,\n    ]);\n    const hash = bitcoin.crypto.hash256(bufferToHash);\n    // Sign the hash\n    const signature = keyPair.sign(hash);\n    // DER encode and return as base64\n    return signature.toString(\"base64\");\n  }",
          "documentation": "Signs a given message using the wallet's private key.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "signTx",
          "signature": "signTx(payload: TransactionPayload): string {\n    if (!this._wallet.privateKey) {\n      throw new Error(\"Private key is not available for signing.\");\n    }\n\n    const psbt = new bitcoin.Psbt({ network: this._network });\n    const p2wpkh = bitcoin.payments.p2wpkh({\n      pubkey: this._wallet.publicKey,\n      network: this._network,\n    });\n    const ecPair = ECPair.fromPrivateKey(this._wallet.privateKey, {\n      network: this._network,\n    });\n\n    for (const input of payload.inputs) {\n      psbt.addInput({\n        hash: input.txid,\n        index: input.vout,\n        witnessUtxo: {\n          script: p2wpkh.output!,\n          value: input.value,\n        },\n      });\n    }\n\n    for (const output of payload.outputs) {\n      psbt.addOutput({\n        address: output.address,\n        value: output.value,\n      });\n    }\n\n    for (let i = 0; i < payload.inputs.length; i++) {\n      psbt.signInput(i, this._wallet);\n      psbt.validateSignaturesOfInput(i, (pubkey, hash, signature) => {\n        return (\n          ecPair.publicKey.equals(pubkey) && ecPair.verify(hash, signature)\n        );\n      });\n    }\n\n    psbt.finalizeAllInputs();\n    return psbt.extractTransaction().toHex();\n  }",
          "documentation": "Sign a transaction payload.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "brew",
          "signature": "static brew(strength: number = 128): string[] {\n    if (![128, 160, 192, 224, 256].includes(strength)) {\n      throw new Error(\n        \"Invalid strength. Must be one of: 128, 160, 192, 224, 256.\"\n      );\n    }\n\n    const mnemonic = bip39.generateMnemonic(strength);\n    return mnemonic.split(\" \");\n  }",
          "documentation": "Generates a mnemonic phrase and returns it as an array of words.",
          "static": true,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "_network",
          "type": "Network",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_wallet",
          "type": "BIP32Interface",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "_provider",
          "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/bitcoin/src/interfaces/provider\").IBitcoinProvider | undefined",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "module": "index",
      "source": "bitcoin"
    },
    {
      "name": "MeshContentOwnershipContract",
      "documentation": "Mesh Content Ownership Contract\n\nThis contract is used to manage the ownership of content.\nIt facilitates on-chain record of content (i.e. file on IPFS) ownership and transfer.\nWhile one cannot prefer others from obtaining a copy of the content, the app owner of the\ncontract can serve the single source of truth of who owns the content. With the blockchain\ntrace and record in place, it provides a trustless way to verify the ownership of the content\nand facilitates further application logics such as royalties, licensing, etc.",
      "isExported": true,
      "importPath": "offchain/mesh-contract/src/content-ownership/offchain/offchain.ts",
      "extends": "MeshTxInitiator",
      "implements": [],
      "methods": [],
      "properties": [
        {
          "name": "paramUtxo",
          "type": "{ txHash: string; outputIndex: number; }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "scriptInfo",
          "type": "{ oracleNFT: { hash: any; cbor: any; }; oracleValidator: { hash: any; cbor: any; address: string; }; contentRegistry: { hash: any; cbor: any; address: string; }; contentRefToken: { hash: any; cbor: any; }; ownershipRegistry: { hash: any; cbor: any; address: string; }; ownershipRefToken: { hash: any; cbor: any; }; }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "refScriptUtxos",
          "type": "{ contentRefToken: { txHash: string; outputIndex: number; }; ownershipRefToken: { txHash: string; outputIndex: number; }; contentRegistry: { txHash: string; outputIndex: number; }; ownershipRegistry: { txHash: string; outputIndex: number; }; }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "operationAddress",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "opsKey",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getOwnerNativeScript",
          "type": "() => { nativeScript: NativeScript; scriptAddress: any; }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "mintOneTimeMintingPolicy",
          "type": "() => Promise<{ tx: any; paramUtxo: any; }>",
          "documentation": "[Setup phase]\nThis is the first transaction you need to setup the contract.\n\nThis transaction mints the one-time minting policy (a NFT) for the contract.\nIt will be attached with the datum which serves as the single source of truth for the contract oracle.\n\nNote: You must save the `paramUtxo` for future transactions.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "setupOracleUtxo",
          "type": "() => Promise<any>",
          "documentation": "[Setup phase]\nThis is the second transaction you need to setup the contract.\n\nThis transaction send the NFT to a oracle contract locking the datum,\nwhich serves as the single source of truth for the contract oracle with data integrity.\n\nNote: You must provide the `paramUtxo` from the `mintOneTimeMintingPolicy` transaction.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "sendRefScriptOnchain",
          "type": "(scriptIndex: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/content-ownership/offchain/common\").ScriptIndex) => Promise<any>",
          "documentation": "[Setup phase]\nThis are the next transactions you need to setup the contract.\nYou need to run once for each script, and you would likely have to run one after the previous one is confirmed.\n\nThis transaction sends the reference scripts to the blockchain for later transactions,\nboosting efficiency and avoid exceeding 16kb of transaction size limits enforced by protocol parameter.\n\nNote: You must provide the `paramUtxo` from the `mintOneTimeMintingPolicy` transaction.\nNote: You must save txHash (after signed and submitted) for `ContentRegistry`, `ContentRefToken`, `OwnershipRegistry`, `OwnershipRefToken` transactions for future transactions.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "createContentRegistry",
          "type": "() => Promise<any>",
          "documentation": "[Setup phase]\nThis is the next transaction you need to setup the contract after completing all the `sendRefScriptOnchain` transactions.\n\nThis transaction creates one content registry. Each registry should comes in pair with one ownership registry and\neach pair of registry serves around 50 records of content ownership. The application can be scaled indefinitely\naccording to the number of parallelization needed and volumes of content expected to be managed.\n\nNote: You must provide the `paramUtxo` from the `mintOneTimeMintingPolicy` transaction.\nNote: You must provide the txHash for `ContentRegistry`, `ContentRefToken`, `OwnershipRegistry`, `OwnershipRefToken`",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "createOwnershipRegistry",
          "type": "() => Promise<any>",
          "documentation": "[Setup phase]\nThis is the last transaction you need to setup the contract after completing all the `sendRefScriptOnchain` transactions.\n\nThis transaction creates one content registry. Each registry should comes in pair with one content registry and\neach pair of registry serves around 50 records of content ownership. The application can be scaled indefinitely\naccording to the number of parallelization needed and volumes of content expected to be managed.\n\nNote: You must provide the `paramUtxo` from the `mintOneTimeMintingPolicy` transaction.\nNote: You must provide the txHash for `ContentRegistry`, `ContentRefToken`, `OwnershipRegistry`, `OwnershipRefToken`",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getOracleData",
          "type": "() => Promise<{ contentNumber: number; ownershipNumber: number; }>",
          "documentation": "Get the current oracle data.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "mintUserToken",
          "type": "(tokenName: string, tokenMetadata?: {}) => Promise<any>",
          "documentation": "[User]\n\nThis transaction mints a user token which can be used to represent the ownership of the content. This token is used in `createContent()` transaction.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "createContent",
          "type": "(ownerAssetHex: string, contentHashHex: string, registryNumber?: number) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getContent",
          "type": "(registryNumber: number, contentNumber: number) => Promise<any>",
          "documentation": "Get the content at the registry given the registry number and content number.",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "updateContent",
          "type": "({ ownerTokenUtxo, registryNumber, newContentHashHex, contentNumber, }: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/content-ownership/offchain/type\").UpdateContent) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "transferContent",
          "type": "({ ownerTokenUtxo, registryNumber, newOwnerAssetHex, contentNumber, }: import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-contract/src/content-ownership/offchain/type\").TransferContent) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "stopContentRegistry",
          "type": "(registryNumber: number) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "stopOwnershipRegistry",
          "type": "(registryNumber: number) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "stopOracle",
          "type": "(txInHash: string, txInId: number) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getCurrentOracleDatum",
          "type": "(utxos?: UTxO[] | undefined) => Promise<any>",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getOracleDatum",
          "type": "(contentRegistryCount: number, ownershipRegistryCount: number) => any",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getContentDatum",
          "type": "(contentArray: string[]) => any",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getOwnershipDatum",
          "type": "(ownershipArray: [string, string][]) => any",
          "documentation": "",
          "static": false,
          "visibility": "protected"
        },
        {
          "name": "getScriptUtxos",
          "type": "(registryNumber: number, toFetch?: (\"content\" | \"oracle\" | \"ownership\")[]) => Promise<UTxO[]>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "insertContentRegistry",
          "type": "(plutusData: string, newContentHash: string) => Data",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "insertOwnershipRegistry",
          "type": "(plutusData: string, ownerAssetClass: [string, string]) => Data",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "updateContentRegistry",
          "type": "(plutusData: string, contentNumber: number, newContentHash: string) => Data",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "updateOwnershipRegistry",
          "type": "(plutusData: string, contentNumber: number, ownerAssetClass: [string, string]) => Data",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "module": "offchain",
      "source": "mesh-contract"
    },
    {
      "name": "MintingBlueprint",
      "documentation": "Minting blueprint",
      "isExported": true,
      "importPath": "offchain/mesh-core/src/utils/blueprint/minting.ts",
      "extends": null,
      "implements": [
        "IMintingBlueprint"
      ],
      "methods": [
        {
          "name": "paramScript",
          "signature": "paramScript(\n    compiledCode: string,\n    params: object[] | Data[],\n    paramsType: PlutusDataType = \"Mesh\",\n  ): this {\n    const cbor = applyParamsToScript(compiledCode, params, paramsType);\n    const hash = resolveScriptHash(cbor, this.version);\n    this.hash = hash;\n    this.cbor = cbor;\n    return this;\n  }",
          "documentation": "Initialize the minting blueprint, with the same parameters to `applyParamsToScript`",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "noParamScript",
          "signature": "noParamScript(compiledCode: string): this {\n    return this.paramScript(compiledCode, []);\n  }",
          "documentation": "Initialize the minting blueprint, with no parameters",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "version",
          "type": "LanguageVersion",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "cbor",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "hash",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "minting",
      "source": "mesh-core"
    },
    {
      "name": "SpendingBlueprint",
      "documentation": "Spending blueprint",
      "isExported": true,
      "importPath": "offchain/mesh-core/src/utils/blueprint/spending.ts",
      "extends": null,
      "implements": [
        "ISpendingBlueprint"
      ],
      "methods": [
        {
          "name": "paramScript",
          "signature": "paramScript(\n    compiledCode: string,\n    params: object[] | Data[],\n    paramsType: PlutusDataType = \"Mesh\",\n  ): this {\n    const cbor = applyParamsToScript(compiledCode, params, paramsType);\n    const hash = resolveScriptHash(cbor, this.version);\n    const plutusScript = {\n      code: cbor,\n      version: this.version,\n    };\n    const address = serializePlutusScript(\n      plutusScript,\n      this.stakeHash,\n      this.networkId,\n      this.isStakeScriptCredential,\n    ).address;\n    this.hash = hash;\n    this.cbor = cbor;\n    this.address = address;\n    return this;\n  }",
          "documentation": "Initialize the minting blueprint, with the same parameters to `applyParamsToScript`",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "noParamScript",
          "signature": "noParamScript(compiledCode: string): this {\n    return this.paramScript(compiledCode, []);\n  }",
          "documentation": "Initialize the minting blueprint, with no parameters",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "version",
          "type": "LanguageVersion",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "networkId",
          "type": "number",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "cbor",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "hash",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "address",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "stakeHash",
          "type": "string | undefined",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "isStakeScriptCredential",
          "type": "boolean",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "spending",
      "source": "mesh-core"
    },
    {
      "name": "WithdrawalBlueprint",
      "documentation": "Withdrawal blueprint",
      "isExported": true,
      "importPath": "offchain/mesh-core/src/utils/blueprint/withdrawal.ts",
      "extends": null,
      "implements": [
        "IWithdrawalBlueprint"
      ],
      "methods": [
        {
          "name": "paramScript",
          "signature": "paramScript(\n    compiledCode: string,\n    params: object[] | Data[],\n    paramsType: PlutusDataType = \"Mesh\",\n  ): this {\n    const cbor = applyParamsToScript(compiledCode, params, paramsType);\n    const hash = resolveScriptHash(cbor, this.version);\n    this.address = serializeRewardAddress(hash, true, this.networkId as 0 | 1);\n    this.hash = hash;\n    this.cbor = cbor;\n    return this;\n  }",
          "documentation": "Initialize the withdrawal blueprint, with the same parameters to `applyParamsToScript`",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "noParamScript",
          "signature": "noParamScript(compiledCode: string): this {\n    return this.paramScript(compiledCode, []);\n  }",
          "documentation": "Initialize the withdrawal blueprint, with no parameters",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "version",
          "type": "LanguageVersion",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "networkId",
          "type": "number",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "cbor",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "hash",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "address",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "withdrawal",
      "source": "mesh-core"
    },
    {
      "name": "BuilderCallbacksSdkBridge",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/cardano-sdk-adapter.ts",
      "extends": null,
      "implements": [
        "CardanoSelection.SelectionConstraints"
      ],
      "methods": [],
      "properties": [
        {
          "name": "builderCallback",
          "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface\").BuilderCallbacks",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "utxoMap",
          "type": "Map<string, UTxO>",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "usedUtxos",
          "type": "Set<string>",
          "documentation": "",
          "static": false,
          "visibility": "private"
        },
        {
          "name": "computeMinimumCoinQuantity",
          "type": "(output: CSDK.TxOut) => CSDK.Lovelace",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "computeMinimumCost",
          "type": "(selectionSkeleton: CardanoSelection.SelectionSkeleton) => Promise<CardanoSelection.TxCosts>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "computeSelectionLimit",
          "type": "(selectionSkeleton: CardanoSelection.SelectionSkeleton) => Promise<number>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "tokenBundleSizeExceedsLimit",
          "type": "(tokenBundle: any) => boolean",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "getNewInputs",
          "type": "(selectionSkeleton: CardanoSelection.SelectionSkeleton) => Set<UTxO>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "cardano-sdk-adapter",
      "source": "mesh-transaction"
    },
    {
      "name": "CardanoSdkInputSelector",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/cardano-sdk-adapter.ts",
      "extends": null,
      "implements": [
        "IInputSelector"
      ],
      "methods": [
        {
          "name": "select",
          "signature": "async select(\n    preselectedUtxos: TxIn[],\n    outputs: Output[],\n    implicitValue: ImplicitValue,\n    utxos: UTxO[],\n    changeAddress: string,\n  ): Promise<TransactionPrototype> {\n    // Create a map of UTxOs for quick lookup\n    const utxoMap = new Map<string, UTxO>();\n    for (const utxo of utxos) {\n      utxoMap.set(`${utxo.input.txHash}#${utxo.input.outputIndex}`, utxo);\n    }\n\n    // Aggregate outputs into a single output for selection\n    const aggregatedTxOut = makeAggregatedCSDKOOutput(outputs);\n    const aggregatedOuts = new Set<CSDK.TxOut>();\n    if (aggregatedTxOut) {\n      aggregatedOuts.add(aggregatedTxOut);\n    }\n    // Convert Mesh types to CSDK types\n    const preselectedUtoxsCSDK = new Set(\n      preselectedUtxos.map(meshTxInToCSDKUtxo),\n    );\n    const utxoxCSDK = utxos.map(meshUtxoToCSDKUtxo);\n\n    // Create selector with change address resolver\n    const selector = CardanoSelection.roundRobinRandomImprove({\n      changeAddressResolver: new StaticChangeAddressResolver(changeAddress),\n    });\n\n    // Track used UTxOs\n    const usedUtxos = new Set<string>();\n    for (const utxo of preselectedUtxos) {\n      usedUtxos.add(`${utxo.txIn.txHash}#${utxo.txIn.txIndex}`);\n    }\n    // Create bridge for callbacks\n    const builderCallbacksBridge = new BuilderCallbacksSdkBridge(\n      this.constraints,\n      utxoMap,\n      usedUtxos,\n    );\n\n    // Perform selection\n    const selectResult = await selector.select({\n      preSelectedUtxo: preselectedUtoxsCSDK,\n      utxo: new Set(utxoxCSDK),\n      outputs: aggregatedOuts,\n      constraints: builderCallbacksBridge,\n      implicitValue: meshImplicitCoinToCSDKImplicitCoins(implicitValue),\n    });\n    // Extract newly selected inputs\n    const newInputs = new Set<UTxO>();\n    for (const input of selectResult.selection.inputs) {\n      const utxoId = `${input[0].txId}#${input[0].index}`;\n      if (!usedUtxos.has(utxoId)) {\n        const originalUtxo = utxoMap.get(utxoId);\n        if (!originalUtxo) {\n          throw new Error(`Missing required UTxO: ${utxoId}`);\n        }\n        newInputs.add(originalUtxo);\n      }\n    }\n\n    // Return transaction prototype\n    return {\n      newInputs,\n      newOutputs: new Set(),\n      change: selectResult.selection.change.map(CSDKOutputToMeshOutput),\n      fee: selectResult.selection.fee,\n      redeemers: selectResult.redeemers?.map(CSDKRedeemerToMeshAction),\n    };\n  }",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "properties": [
        {
          "name": "constraints",
          "type": "import(\"/Users/g/code/don-docs/dons-docs/packages/offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/coin-selection-interface\").BuilderCallbacks",
          "documentation": "",
          "static": false,
          "visibility": "private"
        }
      ],
      "module": "cardano-sdk-adapter",
      "source": "mesh-transaction"
    },
    {
      "name": "StaticChangeAddressResolver",
      "documentation": "",
      "isExported": true,
      "importPath": "offchain/mesh-transaction/src/mesh-tx-builder/coin-selection/cardano-sdk-adapter.ts",
      "extends": null,
      "implements": [
        "CardanoSelection.ChangeAddressResolver"
      ],
      "methods": [],
      "properties": [
        {
          "name": "changeAddress",
          "type": "string",
          "documentation": "",
          "static": false,
          "visibility": "public"
        },
        {
          "name": "resolve",
          "type": "(selection: CardanoSelection.Selection) => Promise<CSDK.TxOut[]>",
          "documentation": "",
          "static": false,
          "visibility": "public"
        }
      ],
      "module": "cardano-sdk-adapter",
      "source": "mesh-transaction"
    }
  ],
  "stats": {
    "totalModules": 339,
    "totalFunctions": 43,
    "totalTypes": 372,
    "totalClasses": 52,
    "packages": []
  }
}