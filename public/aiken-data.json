{
  "modules": [
    {
      "key": "stdlib:aiken.cbor",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/cbor.ak",
      "name": "aiken.cbor",
      "imports": [
        {
          "module": "aiken",
          "items": [],
          "line": 1,
          "raw": "use aiken",
          "source": "stdlib"
        },
        {
          "module": "aiken/builtin",
          "items": ["decode_utf8", "serialise_data"],
          "line": 2,
          "raw": "use aiken/builtin.{decode_utf8, serialise_data}",
          "source": "stdlib"
        },
        {
          "module": "aiken/primitive/bytearray",
          "items": [],
          "line": 3,
          "raw": "use aiken/primitive/bytearray",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "diagnostic",
          "signature": "pub fn diagnostic(self: Data) -> String {",
          "documentation": "Obtain a String representation of _anything_. This is particularly (and only) useful for tracing\nand debugging. This function is expensive and should not be used in any production code as it\nwill very likely explodes the validator's budget.\n\nThe output is a [CBOR diagnostic](https://www.rfc-editor.org/rfc/rfc8949#name-diagnostic-notation)\nof the underlying on-chain binary representation of the data. It's not as\neasy to read as plain Aiken code, but it is handy for troubleshooting values\n_at runtime_. Incidentally, getting familiar with reading CBOR diagnostic is\na good idea in the Cardano world.\n\n```aiken\ncbor.diagnostic(42) == \"42\"\ncbor.diagnostic(#\"a1b2\") == \"h'A1B2'\"\ncbor.diagnostic([1, 2, 3]) == \"[_ 1, 2, 3]\"\ncbor.diagnostic([]) == \"[]\"\ncbor.diagnostic((1, 2)) == \"[_ 1, 2]\"\ncbor.diagnostic((1, #\"ff\", 3)) == \"[_ 1, h'FF', 3]\"\ncbor.diagnostic([(1, #\"ff\")]) == \"{_ 1: h'FF' }\"\ncbor.diagnostic(Some(42)) == \"121([_ 42])\"\ncbor.diagnostic(None) == \"122([])\"\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "String",
          "line": 26,
          "raw": "pub fn diagnostic(self: Data) -> String {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn diagnostic(self: Data) -> String {\n  aiken.diagnostic(self, #\"\")\n    |> decode_utf8\n}"
        },
        {
          "name": "deserialise",
          "signature": "pub fn deserialise(bytes: ByteArray) -> Option<Data> {",
          "documentation": "Deserialise a [CBOR](https://www.rfc-editor.org/rfc/rfc8949) Data. This is the reverse operation of [serialise](#serialise).\nIn particular, we have the following property:\n\n```aiken\ncbor.deserialise(cbor.serialise(any_data)) == Some(any_data)\n```\n\n> [!CAUTION]\n> Unfortunately, this function isn't derived from a builtin primitive. It\n> is therefore an order of magnitude more expensive than its counterpart\n> and shall be used with care.\n>\n> In general, one might prefer avoiding deserialisation unless truly necessary.\n> Yet, it may come in handy for testing and in rare scenarios.",
          "parameters": [
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Option<Data>",
          "line": 45,
          "raw": "pub fn deserialise(bytes: ByteArray) -> Option<Data> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn deserialise(bytes: ByteArray) -> Option<Data> {\n  let length = bytearray.length(bytes)\n\n  let peek =\n    fn(offset: Int, callback: fn(Byte) -> Decoder<Data>) -> Decoder<Data> {\n      fn(cursor) {\n        if 0 >= cursor {\n          deserialise_failure\n        } else {\n          callback(bytearray.at(bytes, length - cursor))(cursor - offset)\n        }\n      }\n    }\n\n  let take =\n    fn(n: Int, callback: fn(ByteArray) -> Decoder<Data>) -> Decoder<Data> {\n      fn(cursor) {\n        if 0 >= cursor {\n          deserialise_failure\n        } else {\n          callback(builtin.slice_bytearray(length - cursor, n, bytes))(\n            cursor - n,\n          )\n        }\n      }\n    }\n\n  if length == 0 {\n    None\n  } else {\n    let Pair(result, consumed) = decode_data(peek, take)(length)\n    if consumed != 0 {\n      None\n    } else {\n      Some(result)\n    }\n  }\n}"
        },
        {
          "name": "serialise",
          "signature": "pub fn serialise(self: Data) -> ByteArray {",
          "documentation": "Serialise any value to binary, encoding using [CBOR](https://www.rfc-editor.org/rfc/rfc8949).\n\nThis is particularly useful in combination with hashing functions, as a way\nto obtain a byte representation that matches the serialised representation\nused by the ledger in the context of on-chain code.\n\nNote that the output matches the output of [`diagnostic`](#diagnostic),\nthough with a different encoding. [`diagnostic`](#diagnostic) is merely a\ntextual representation of the CBOR encoding that is human friendly and\nuseful for debugging.\n\n```aiken\ncbor.serialise(42) == #\"182a\"\ncbor.serialise(#\"a1b2\") == #\"42a1b2\"\ncbor.serialise([]) == #\"80\"\ncbor.serialise((1, 2)) == #\"9f0102ff\"\ncbor.serialise((1, #\"ff\", 3)) == #\"9f0141ff03ff\"\ncbor.serialise([(1, #\"ff\")]) == #\"a10141ff\"\ncbor.serialise(Some(42)) == #\"d8799f182aff\"\ncbor.serialise(None) == #\"d87a80\"\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 105,
          "raw": "pub fn serialise(self: Data) -> ByteArray {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn serialise(self: Data) -> ByteArray {\n  serialise_data(self)\n}"
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [
        {
          "name": "return",
          "signature": "fn return(data: Data) -> Decoder<Data> {",
          "parameters": [
            {
              "name": "data",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "Decoder<Data>",
          "line": 121,
          "raw": "fn return(data: Data) -> Decoder<Data> {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn return(data: Data) -> Decoder<Data> {\n  fn(cursor) { Pair(data, cursor) }\n}"
        },
        {
          "name": "decode_data",
          "signature": "fn decode_data(peek: Peek<Data>, take: Take<Data>) -> Decoder<Data> {",
          "parameters": [
            {
              "name": "peek",
              "type": "Peek<Data>",
              "optional": false
            },
            {
              "name": "take",
              "type": "Take<Data>",
              "optional": false
            }
          ],
          "returnType": "Decoder<Data>",
          "line": 138,
          "raw": "fn decode_data(peek: Peek<Data>, take: Take<Data>) -> Decoder<Data> {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn decode_data(peek: Peek<Data>, take: Take<Data>) -> Decoder<Data> {\n  let next <- peek(1)\n  let major_type = next / 32\n  if major_type <= 2 {\n    if major_type == 0 {\n      let i <- decode_uint(peek, take, next)\n      return(builtin.i_data(i))\n    } else if major_type == 1 {\n      let i <- decode_uint(peek, take, next - 32)\n      return(builtin.i_data(-i - 1))\n    } else {\n      if next == token_begin_bytes {\n        let b <- decode_chunks(peek, take)\n        return(builtin.b_data(b))\n      } else {\n        let b <- decode_bytes(peek, take, next - 64)\n        return(builtin.b_data(b))\n      }\n    }\n  } else if major_type == 6 {\n    let tag <- decode_uint(peek, take, next - 192)\n    let next <- peek(1)\n    if tag == 102 {\n      fn(_) { deserialise_failure }\n    } else {\n      let ix =\n        if tag >= 1280 {\n          tag - 1280 + 7\n        } else {\n          tag - 121\n        }\n      if next == token_begin_list {\n        let fields <- decode_indefinite(peek, take, decode_data)\n        return(builtin.constr_data(ix, fields))\n      } else {\n        let size <- decode_uint(peek, take, next - 128)\n        let fields <- decode_definite(peek, take, decode_data, size)\n        return(builtin.constr_data(ix, fields))\n      }\n    }\n  } else if major_type == 4 {\n    if next == token_begin_list {\n      let xs <- decode_indefinite(peek, take, decode_data)\n      return(builtin.list_data(xs))\n    } else {\n      let size <- decode_uint(peek, take, next - 128)\n      let xs <- decode_definite(peek, take, decode_data, size)\n      return(builtin.list_data(xs))\n    }\n  } else if major_type == 5 {\n    if next == token_begin_map {\n      let xs <- decode_indefinite(peek, take, decode_pair)\n      return(builtin.map_data(xs))\n    } else {\n      let size <- decode_uint(peek, take, next - 160)\n      let xs <- decode_definite(peek, take, decode_pair, size)\n      return(builtin.map_data(xs))\n    }\n  } else {\n    fn(_) { deserialise_failure }\n  }\n}"
        },
        {
          "name": "decode_pair",
          "signature": "fn decode_pair(peek: Peek<Data>, take: Take<Data>) -> Decoder<Pair<Data, Data>> {",
          "parameters": [
            {
              "name": "peek",
              "type": "Peek<Data>",
              "optional": false
            },
            {
              "name": "take",
              "type": "Take<Data>",
              "optional": false
            }
          ],
          "returnType": "Decoder<Pair<Data, Data>>",
          "line": 201,
          "raw": "fn decode_pair(peek: Peek<Data>, take: Take<Data>) -> Decoder<Pair<Data, Data>> {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn decode_pair(peek: Peek<Data>, take: Take<Data>) -> Decoder<Pair<Data, Data>> {\n  fn(cursor) {\n    let Pair(k, cursor) = decode_data(peek, take)(cursor)\n    let Pair(v, cursor) = decode_data(peek, take)(cursor)\n    Pair(Pair(k, v), cursor)\n  }\n}"
        },
        {
          "name": "decode_uint",
          "signature": "fn decode_uint(fn decode_uint(peek: Peek<Data>, take: Take<Data>, header: Int, and_then: fn(Int) -> Decoder<Data>,",
          "parameters": [],
          "returnType": "Decoder<Data>,",
          "line": 209,
          "raw": "fn decode_uint(fn decode_uint(peek: Peek<Data>, take: Take<Data>, header: Int, and_then: fn(Int) -> Decoder<Data>,",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn decode_uint(\n  peek: Peek<Data>,\n  take: Take<Data>,\n  header: Int,\n  and_then: fn(Int) -> Decoder<Data>,\n) -> Decoder<Data> {\n  if header < 24 {\n    and_then(header)\n  } else if header == 24 {\n    let payload <- peek(1)\n    and_then(payload)\n  } else if header < 28 {\n    let width = bytearray.at(#[2, 4, 8], header - 25)\n    let payload <- take(width)\n    and_then(bytearray.to_int_big_endian(payload))\n  } else {\n    fn(_) { deserialise_failure }\n  }\n}"
        },
        {
          "name": "decode_bytes",
          "signature": "fn decode_bytes(fn decode_bytes(peek: Peek<Data>, take: Take<Data>, header: Int, and_then: fn(ByteArray) -> Decoder<Data>,",
          "parameters": [],
          "returnType": "Decoder<Data>,",
          "line": 229,
          "raw": "fn decode_bytes(fn decode_bytes(peek: Peek<Data>, take: Take<Data>, header: Int, and_then: fn(ByteArray) -> Decoder<Data>,",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn decode_bytes(\n  peek: Peek<Data>,\n  take: Take<Data>,\n  header: Int,\n  and_then: fn(ByteArray) -> Decoder<Data>,\n) -> Decoder<Data> {\n  let width <- decode_uint(peek, take, header)\n  let bytes <- take(width)\n  and_then(bytes)\n}"
        },
        {
          "name": "decode_chunks",
          "signature": "fn decode_chunks(fn decode_chunks(peek: Peek<Data>, take: Take<Data>, and_then: fn(ByteArray) -> Decoder<Data>,",
          "parameters": [],
          "returnType": "Decoder<Data>,",
          "line": 240,
          "raw": "fn decode_chunks(fn decode_chunks(peek: Peek<Data>, take: Take<Data>, and_then: fn(ByteArray) -> Decoder<Data>,",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn decode_chunks(\n  peek: Peek<Data>,\n  take: Take<Data>,\n  and_then: fn(ByteArray) -> Decoder<Data>,\n) -> Decoder<Data> {\n  let next <- peek(1)\n  if next == token_break {\n    and_then(\"\")\n  } else {\n    let chunk <- decode_bytes(peek, take, next - 64)\n    let chunks <- decode_chunks(peek, take)\n    and_then(builtin.append_bytearray(chunk, chunks))\n  }\n}"
        },
        {
          "name": "decode_definite",
          "signature": "fn decode_definite(fn decode_definite(peek: Peek<Data>, take: Take<Data>, decode_one: fn(Peek<Data>, Take<Data>) -> Decoder<a>, size: Int, and_then: fn(List<a>) -> Decoder<Data>,",
          "parameters": [],
          "returnType": "Decoder<a>, size: Int, and_then: fn(List<a>) -> Decoder<Data>,",
          "line": 255,
          "raw": "fn decode_definite(fn decode_definite(peek: Peek<Data>, take: Take<Data>, decode_one: fn(Peek<Data>, Take<Data>) -> Decoder<a>, size: Int, and_then: fn(List<a>) -> Decoder<Data>,",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn decode_definite(\n  peek: Peek<Data>,\n  take: Take<Data>,\n  decode_one: fn(Peek<Data>, Take<Data>) -> Decoder<a>,\n  size: Int,\n  and_then: fn(List<a>) -> Decoder<Data>,\n) -> Decoder<Data> {\n  if size <= 0 {\n    and_then([])\n  } else {\n    fn(cursor) {\n      let Pair(elem, cursor) = decode_one(peek, take)(cursor)\n      {\n        let elems <- decode_definite(peek, take, decode_one, size - 1)\n        and_then([elem, ..elems])\n      }(cursor)\n    }\n  }\n}"
        },
        {
          "name": "decode_indefinite",
          "signature": "fn decode_indefinite(fn decode_indefinite(peek: Peek<Data>, take: Take<Data>, decode_one: fn(Peek<Data>, Take<Data>) -> Decoder<a>, and_then: fn(List<a>) -> Decoder<Data>,",
          "parameters": [],
          "returnType": "Decoder<a>, and_then: fn(List<a>) -> Decoder<Data>,",
          "line": 275,
          "raw": "fn decode_indefinite(fn decode_indefinite(peek: Peek<Data>, take: Take<Data>, decode_one: fn(Peek<Data>, Take<Data>) -> Decoder<a>, and_then: fn(List<a>) -> Decoder<Data>,",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn decode_indefinite(\n  peek: Peek<Data>,\n  take: Take<Data>,\n  decode_one: fn(Peek<Data>, Take<Data>) -> Decoder<a>,\n  and_then: fn(List<a>) -> Decoder<Data>,\n) -> Decoder<Data> {\n  let next <- peek(1)\n  if next == token_break {\n    and_then([])\n  } else {\n    fn(cursor) {\n      let Pair(elem, cursor) = decode_one(peek, take)(cursor + 1)\n      {\n        let elems <- decode_indefinite(peek, take, decode_one)\n        and_then([elem, ..elems])\n      }(cursor)\n    }\n  }\n}"
        }
      ],
      "privateTypes": [
        {
          "name": "Byte",
          "definition": "Int",
          "line": 109,
          "raw": "type Byte =",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "Decoder<a>",
          "definition": "fn(Int) -> Pair<a, Int>",
          "line": 112,
          "raw": "type Decoder<a> =",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "Peek<a>",
          "definition": "fn(Int, fn(Byte) -> Decoder<a>) -> Decoder<a>",
          "line": 115,
          "raw": "type Peek<a> =",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "Take<a>",
          "definition": "fn(Int, fn(ByteArray) -> Decoder<a>) -> Decoder<a>",
          "line": 118,
          "raw": "type Take<a> =",
          "isPublic": false,
          "source": "stdlib"
        }
      ],
      "privateConstants": [
        {
          "name": "deserialise_failure",
          "type": "Pair<Data, Int>",
          "value": "{ let empty: Data = \"\" Pair(empty, -1) }",
          "line": 125,
          "raw": "const deserialise_failure: Pair<Data, Int> = {",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "token_begin_bytes",
          "type": "Unknown",
          "value": "0x5f",
          "line": 130,
          "raw": "const token_begin_bytes = 0x5f",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "token_begin_list",
          "type": "Unknown",
          "value": "0x9f",
          "line": 132,
          "raw": "const token_begin_list = 0x9f",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "token_begin_map",
          "type": "Unknown",
          "value": "0xbf",
          "line": 134,
          "raw": "const token_begin_map = 0xbf",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "token_break",
          "type": "Unknown",
          "value": "0xff",
          "line": 136,
          "raw": "const token_break = 0xff",
          "isPublic": false,
          "source": "stdlib"
        }
      ],
      "content": "use aiken\nuse aiken/builtin.{decode_utf8, serialise_data}\nuse aiken/primitive/bytearray\n\n/// Obtain a String representation of _anything_. This is particularly (and only) useful for tracing\n/// and debugging. This function is expensive and should not be used in any production code as it\n/// will very likely explodes the validator's budget.\n///\n/// The output is a [CBOR diagnostic](https://www.rfc-editor.org/rfc/rfc8949#name-diagnostic-notation)\n/// of the underlying on-chain binary representation of the data. It's not as\n/// easy to read as plain Aiken code, but it is handy for troubleshooting values\n/// _at runtime_. Incidentally, getting familiar with reading CBOR diagnostic is\n/// a good idea in the Cardano world.\n///\n/// ```aiken\n/// cbor.diagnostic(42) == \"42\"\n/// cbor.diagnostic(#\"a1b2\") == \"h'A1B2'\"\n/// cbor.diagnostic([1, 2, 3]) == \"[_ 1, 2, 3]\"\n/// cbor.diagnostic([]) == \"[]\"\n/// cbor.diagnostic((1, 2)) == \"[_ 1, 2]\"\n/// cbor.diagnostic((1, #\"ff\", 3)) == \"[_ 1, h'FF', 3]\"\n/// cbor.diagnostic([(1, #\"ff\")]) == \"{_ 1: h'FF' }\"\n/// cbor.diagnostic(Some(42)) == \"121([_ 42])\"\n/// cbor.diagnostic(None) == \"122([])\"\n/// ```\npub fn diagnostic(self: Data) -> String {\n  aiken.diagnostic(self, #\"\")\n    |> decode_utf8\n}\n\n/// Deserialise a [CBOR](https://www.rfc-editor.org/rfc/rfc8949) Data. This is the reverse operation of [serialise](#serialise).\n/// In particular, we have the following property:\n///\n/// ```aiken\n/// cbor.deserialise(cbor.serialise(any_data)) == Some(any_data)\n/// ```\n///\n/// > [!CAUTION]\n/// > Unfortunately, this function isn't derived from a builtin primitive. It\n/// > is therefore an order of magnitude more expensive than its counterpart\n/// > and shall be used with care.\n/// >\n/// > In general, one might prefer avoiding deserialisation unless truly necessary.\n/// > Yet, it may come in handy for testing and in rare scenarios.\npub fn deserialise(bytes: ByteArray) -> Option<Data> {\n  let length = bytearray.length(bytes)\n\n  let peek =\n    fn(offset: Int, callback: fn(Byte) -> Decoder<Data>) -> Decoder<Data> {\n      fn(cursor) {\n        if 0 >= cursor {\n          deserialise_failure\n        } else {\n          callback(bytearray.at(bytes, length - cursor))(cursor - offset)\n        }\n      }\n    }\n\n  let take =\n    fn(n: Int, callback: fn(ByteArray) -> Decoder<Data>) -> Decoder<Data> {\n      fn(cursor) {\n        if 0 >= cursor {\n          deserialise_failure\n        } else {\n          callback(builtin.slice_bytearray(length - cursor, n, bytes))(\n            cursor - n,\n          )\n        }\n      }\n    }\n\n  if length == 0 {\n    None\n  } else {\n    let Pair(result, consumed) = decode_data(peek, take)(length)\n    if consumed != 0 {\n      None\n    } else {\n      Some(result)\n    }\n  }\n}\n\n/// Serialise any value to binary, encoding using [CBOR](https://www.rfc-editor.org/rfc/rfc8949).\n///\n/// This is particularly useful in combination with hashing functions, as a way\n/// to obtain a byte representation that matches the serialised representation\n/// used by the ledger in the context of on-chain code.\n///\n/// Note that the output matches the output of [`diagnostic`](#diagnostic),\n/// though with a different encoding. [`diagnostic`](#diagnostic) is merely a\n/// textual representation of the CBOR encoding that is human friendly and\n/// useful for debugging.\n///\n/// ```aiken\n/// cbor.serialise(42) == #\"182a\"\n/// cbor.serialise(#\"a1b2\") == #\"42a1b2\"\n/// cbor.serialise([]) == #\"80\"\n/// cbor.serialise((1, 2)) == #\"9f0102ff\"\n/// cbor.serialise((1, #\"ff\", 3)) == #\"9f0141ff03ff\"\n/// cbor.serialise([(1, #\"ff\")]) == #\"a10141ff\"\n/// cbor.serialise(Some(42)) == #\"d8799f182aff\"\n/// cbor.serialise(None) == #\"d87a80\"\n/// ```\npub fn serialise(self: Data) -> ByteArray {\n  serialise_data(self)\n}\n\ntype Byte =\n  Int\n\ntype Decoder<a> =\n  fn(Int) -> Pair<a, Int>\n\ntype Peek<a> =\n  fn(Int, fn(Byte) -> Decoder<a>) -> Decoder<a>\n\ntype Take<a> =\n  fn(Int, fn(ByteArray) -> Decoder<a>) -> Decoder<a>\n\nfn return(data: Data) -> Decoder<Data> {\n  fn(cursor) { Pair(data, cursor) }\n}\n\nconst deserialise_failure: Pair<Data, Int> = {\n    let empty: Data = \"\"\n    Pair(empty, -1)\n  }\n\nconst token_begin_bytes = 0x5f\n\nconst token_begin_list = 0x9f\n\nconst token_begin_map = 0xbf\n\nconst token_break = 0xff\n\nfn decode_data(peek: Peek<Data>, take: Take<Data>) -> Decoder<Data> {\n  let next <- peek(1)\n  let major_type = next / 32\n  if major_type <= 2 {\n    if major_type == 0 {\n      let i <- decode_uint(peek, take, next)\n      return(builtin.i_data(i))\n    } else if major_type == 1 {\n      let i <- decode_uint(peek, take, next - 32)\n      return(builtin.i_data(-i - 1))\n    } else {\n      if next == token_begin_bytes {\n        let b <- decode_chunks(peek, take)\n        return(builtin.b_data(b))\n      } else {\n        let b <- decode_bytes(peek, take, next - 64)\n        return(builtin.b_data(b))\n      }\n    }\n  } else if major_type == 6 {\n    let tag <- decode_uint(peek, take, next - 192)\n    let next <- peek(1)\n    if tag == 102 {\n      fn(_) { deserialise_failure }\n    } else {\n      let ix =\n        if tag >= 1280 {\n          tag - 1280 + 7\n        } else {\n          tag - 121\n        }\n      if next == token_begin_list {\n        let fields <- decode_indefinite(peek, take, decode_data)\n        return(builtin.constr_data(ix, fields))\n      } else {\n        let size <- decode_uint(peek, take, next - 128)\n        let fields <- decode_definite(peek, take, decode_data, size)\n        return(builtin.constr_data(ix, fields))\n      }\n    }\n  } else if major_type == 4 {\n    if next == token_begin_list {\n      let xs <- decode_indefinite(peek, take, decode_data)\n      return(builtin.list_data(xs))\n    } else {\n      let size <- decode_uint(peek, take, next - 128)\n      let xs <- decode_definite(peek, take, decode_data, size)\n      return(builtin.list_data(xs))\n    }\n  } else if major_type == 5 {\n    if next == token_begin_map {\n      let xs <- decode_indefinite(peek, take, decode_pair)\n      return(builtin.map_data(xs))\n    } else {\n      let size <- decode_uint(peek, take, next - 160)\n      let xs <- decode_definite(peek, take, decode_pair, size)\n      return(builtin.map_data(xs))\n    }\n  } else {\n    fn(_) { deserialise_failure }\n  }\n}\n\nfn decode_pair(peek: Peek<Data>, take: Take<Data>) -> Decoder<Pair<Data, Data>> {\n  fn(cursor) {\n    let Pair(k, cursor) = decode_data(peek, take)(cursor)\n    let Pair(v, cursor) = decode_data(peek, take)(cursor)\n    Pair(Pair(k, v), cursor)\n  }\n}\n\nfn decode_uint(\n  peek: Peek<Data>,\n  take: Take<Data>,\n  header: Int,\n  and_then: fn(Int) -> Decoder<Data>,\n) -> Decoder<Data> {\n  if header < 24 {\n    and_then(header)\n  } else if header == 24 {\n    let payload <- peek(1)\n    and_then(payload)\n  } else if header < 28 {\n    let width = bytearray.at(#[2, 4, 8], header - 25)\n    let payload <- take(width)\n    and_then(bytearray.to_int_big_endian(payload))\n  } else {\n    fn(_) { deserialise_failure }\n  }\n}\n\nfn decode_bytes(\n  peek: Peek<Data>,\n  take: Take<Data>,\n  header: Int,\n  and_then: fn(ByteArray) -> Decoder<Data>,\n) -> Decoder<Data> {\n  let width <- decode_uint(peek, take, header)\n  let bytes <- take(width)\n  and_then(bytes)\n}\n\nfn decode_chunks(\n  peek: Peek<Data>,\n  take: Take<Data>,\n  and_then: fn(ByteArray) -> Decoder<Data>,\n) -> Decoder<Data> {\n  let next <- peek(1)\n  if next == token_break {\n    and_then(\"\")\n  } else {\n    let chunk <- decode_bytes(peek, take, next - 64)\n    let chunks <- decode_chunks(peek, take)\n    and_then(builtin.append_bytearray(chunk, chunks))\n  }\n}\n\nfn decode_definite(\n  peek: Peek<Data>,\n  take: Take<Data>,\n  decode_one: fn(Peek<Data>, Take<Data>) -> Decoder<a>,\n  size: Int,\n  and_then: fn(List<a>) -> Decoder<Data>,\n) -> Decoder<Data> {\n  if size <= 0 {\n    and_then([])\n  } else {\n    fn(cursor) {\n      let Pair(elem, cursor) = decode_one(peek, take)(cursor)\n      {\n        let elems <- decode_definite(peek, take, decode_one, size - 1)\n        and_then([elem, ..elems])\n      }(cursor)\n    }\n  }\n}\n\nfn decode_indefinite(\n  peek: Peek<Data>,\n  take: Take<Data>,\n  decode_one: fn(Peek<Data>, Take<Data>) -> Decoder<a>,\n  and_then: fn(List<a>) -> Decoder<Data>,\n) -> Decoder<Data> {\n  let next <- peek(1)\n  if next == token_break {\n    and_then([])\n  } else {\n    fn(cursor) {\n      let Pair(elem, cursor) = decode_one(peek, take)(cursor + 1)\n      {\n        let elems <- decode_indefinite(peek, take, decode_one)\n        and_then([elem, ..elems])\n      }(cursor)\n    }\n  }\n}\n",
      "dependencies": ["aiken", "aiken/builtin", "aiken/primitive/bytearray"],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.collection.dict.strategy",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/collection/dict/strategy.ak",
      "name": "aiken.collection.dict.strategy",
      "imports": [],
      "functions": [
        {
          "name": "expect_no_duplicate",
          "signature": "pub fn expect_no_duplicate() -> UnionStrategy<key, value> {",
          "documentation": "A strategy which always fail, enforcing the dict contains no duplicate.\n\n```aiken\nfn(_, _, _, _, _) {\nfail @\"unexpected duplicate key found in dict.\"\n}\n```",
          "parameters": [],
          "returnType": "UnionStrategy<key, value>",
          "line": 23,
          "raw": "pub fn expect_no_duplicate() -> UnionStrategy<key, value> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn expect_no_duplicate() -> UnionStrategy<key, value> {\n  fn(_, _, _, _, _) {\n    fail @\"unexpected duplicate key found in dict.\"\n  }\n}"
        },
        {
          "name": "keep_left",
          "signature": "pub fn keep_left() -> UnionStrategy<key, value> {",
          "documentation": "Combine values by keeping the values present in the left-most dict.\n\n```aiken\nfn(_key, left, _right, keep, _discard) { keep(left) }\n```",
          "parameters": [],
          "returnType": "UnionStrategy<key, value>",
          "line": 34,
          "raw": "pub fn keep_left() -> UnionStrategy<key, value> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn keep_left() -> UnionStrategy<key, value> {\n  fn(_key, left, _right, keep, _discard) { keep(left) }\n}"
        },
        {
          "name": "keep_right",
          "signature": "pub fn keep_right() -> UnionStrategy<key, value> {",
          "documentation": "Combine values by keeping the values present in the right-most dict.\n\n```aiken\nfn(_key, _left, right, keep, _discard) { keep(right) }\n```",
          "parameters": [],
          "returnType": "UnionStrategy<key, value>",
          "line": 43,
          "raw": "pub fn keep_right() -> UnionStrategy<key, value> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn keep_right() -> UnionStrategy<key, value> {\n  fn(_key, _left, right, keep, _discard) { keep(right) }\n}"
        },
        {
          "name": "sum",
          "signature": "pub fn sum() -> UnionStrategy<key, Int> {",
          "documentation": "Combine values by taking their sum.\n\n```aiken\nfn(_key, left, right, keep, _discard) { keep(left + right) }\n```",
          "parameters": [],
          "returnType": "UnionStrategy<key, Int>",
          "line": 52,
          "raw": "pub fn sum() -> UnionStrategy<key, Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sum() -> UnionStrategy<key, Int> {\n  fn(_key, left, right, keep, _discard) { keep(left + right) }\n}"
        },
        {
          "name": "sum_if_non_zero",
          "signature": "pub fn sum_if_non_zero() -> UnionStrategy<key, Int> {",
          "documentation": "Combine values by taking their sum, only if it is non-null. If the\nresulting sum is 0, discard the key/value entirely.\n\n```aiken\nfn(_key, left, right, keep, discard) {\nlet value = left + right\nif value == 0 {\ndiscard()\n} else {\nkeep(value)\n}\n}\n```",
          "parameters": [],
          "returnType": "UnionStrategy<key, Int>",
          "line": 69,
          "raw": "pub fn sum_if_non_zero() -> UnionStrategy<key, Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sum_if_non_zero() -> UnionStrategy<key, Int> {\n  fn(_key, left, right, keep, discard) {\n    let value = left + right\n    if value == 0 {\n      discard()\n    } else {\n      keep(value)\n    }\n  }\n}"
        }
      ],
      "types": [
        {
          "name": "UnionStrategy<key, value>",
          "definition": "fn(key, value, value, KeepValue<key, value>, DiscardValue<key, value>) ->",
          "line": 2,
          "raw": "pub type UnionStrategy<key, value> =",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "KeepValue<key, value>",
          "definition": "fn(value) -> Pairs<key, value>",
          "line": 7,
          "raw": "pub type KeepValue<key, value> =",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "DiscardValue<key, value>",
          "definition": "fn() -> Pairs<key, value>",
          "line": 11,
          "raw": "pub type DiscardValue<key, value> =",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "/// A strategy for combining two values in a dictionnary that belong to the same key.\npub type UnionStrategy<key, value> =\n  fn(key, value, value, KeepValue<key, value>, DiscardValue<key, value>) ->\n    Pairs<key, value>\n\n/// A callback to keep a combined value at a given key\npub type KeepValue<key, value> =\n  fn(value) -> Pairs<key, value>\n\n/// A callback to discard a value at a given key\npub type DiscardValue<key, value> =\n  fn() -> Pairs<key, value>\n\n// ### Union Strategies\n\n/// A strategy which always fail, enforcing the dict contains no duplicate.\n///\n/// ```aiken\n/// fn(_, _, _, _, _) {\n///   fail @\"unexpected duplicate key found in dict.\"\n/// }\n/// ```\npub fn expect_no_duplicate() -> UnionStrategy<key, value> {\n  fn(_, _, _, _, _) {\n    fail @\"unexpected duplicate key found in dict.\"\n  }\n}\n\n/// Combine values by keeping the values present in the left-most dict.\n///\n/// ```aiken\n/// fn(_key, left, _right, keep, _discard) { keep(left) }\n/// ```\npub fn keep_left() -> UnionStrategy<key, value> {\n  fn(_key, left, _right, keep, _discard) { keep(left) }\n}\n\n/// Combine values by keeping the values present in the right-most dict.\n///\n/// ```aiken\n/// fn(_key, _left, right, keep, _discard) { keep(right) }\n/// ```\npub fn keep_right() -> UnionStrategy<key, value> {\n  fn(_key, _left, right, keep, _discard) { keep(right) }\n}\n\n/// Combine values by taking their sum.\n///\n/// ```aiken\n/// fn(_key, left, right, keep, _discard) { keep(left + right) }\n/// ```\npub fn sum() -> UnionStrategy<key, Int> {\n  fn(_key, left, right, keep, _discard) { keep(left + right) }\n}\n\n/// Combine values by taking their sum, only if it is non-null. If the\n/// resulting sum is 0, discard the key/value entirely.\n///\n/// ```aiken\n/// fn(_key, left, right, keep, discard) {\n///   let value = left + right\n///   if value == 0 {\n///     discard()\n///   } else {\n///     keep(value)\n///   }\n/// }\n/// ```\npub fn sum_if_non_zero() -> UnionStrategy<key, Int> {\n  fn(_key, left, right, keep, discard) {\n    let value = left + right\n    if value == 0 {\n      discard()\n    } else {\n      keep(value)\n    }\n  }\n}\n",
      "dependencies": [],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.collection.dict",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/collection/dict.ak",
      "name": "aiken.collection.dict",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 15,
          "raw": "use aiken/builtin",
          "source": "stdlib"
        },
        {
          "module": "aiken/collection/dict/strategy",
          "items": ["UnionStrategy"],
          "line": 16,
          "raw": "use aiken/collection/dict/strategy.{UnionStrategy}",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "from_ascending_pairs",
          "signature": "pub fn from_ascending_pairs(xs: Pairs<ByteArray, value>) -> Dict<key, value> {",
          "documentation": "Like ['from_pairs'](#from_pairs), but from an already sorted list by ascending\nkeys. This function fails (i.e. halts the program execution) if the list isn't\nsorted.\n\n```aiken\nlet pairs = [Pair(\"a\", 100), Pair(\"b\", 200), Pair(\"c\", 300)]\n\nlet result =\ndict.from_ascending_pairs(pairs)\n|> dict.to_pairs()\n\nresult == [Pair(\"a\", 100), Pair(\"b\", 200), Pair(\"c\", 300)]\n```\n\nThis is meant to be used to turn a list constructed off-chain into a `Dict`\nwhich has taken care of maintaining interval invariants. This function still\nperforms a sanity check on all keys to avoid silly mistakes. It is, however,\nconsiderably faster than ['from_pairs'](from_pairs)",
          "parameters": [
            {
              "name": "xs",
              "type": "Pairs<ByteArray, value>",
              "optional": false
            }
          ],
          "returnType": "Dict<key, value>",
          "line": 72,
          "raw": "pub fn from_ascending_pairs(xs: Pairs<ByteArray, value>) -> Dict<key, value> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_ascending_pairs(xs: Pairs<ByteArray, value>) -> Dict<key, value> {\n  let Void = check_ascending_list(xs)\n  Dict { inner: xs }\n}"
        },
        {
          "name": "from_ascending_pairs_with",
          "signature": "pub fn from_ascending_pairs_with(pub fn from_ascending_pairs_with(xs: Pairs<ByteArray, value>, predicate: fn(value) -> Bool,",
          "documentation": "Like [`from_ascending_pairs`](#from_ascending_pairs) but fails if **any**\nvalue doesn't satisfy the predicate.\n\n```aiken\nlet pairs = [Pair(\"a\", 100), Pair(\"b\", 200), Pair(\"c\", 300)]\n\ndict.from_ascending_pairs_with(pairs, fn(x) { x <= 250 }) // fail\n```",
          "parameters": [],
          "returnType": "Bool,",
          "line": 98,
          "raw": "pub fn from_ascending_pairs_with(pub fn from_ascending_pairs_with(xs: Pairs<ByteArray, value>, predicate: fn(value) -> Bool,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_ascending_pairs_with(\n  xs: Pairs<ByteArray, value>,\n  predicate: fn(value) -> Bool,\n) -> Dict<key, value> {\n  let Void = check_ascending_pairs_with(xs, predicate)\n  Dict { inner: xs }\n}"
        },
        {
          "name": "from_pairs",
          "signature": "pub fn from_pairs(self: Pairs<ByteArray, value>) -> Dict<key, value> {",
          "documentation": "Construct a dictionary from a list of key-value pairs. Note that when a key is present\nmultiple times, the first occurrence prevails.\n\n```aiken\nlet pairs = [Pair(\"a\", 100), Pair(\"c\", 300), Pair(\"b\", 200)]\n\nlet result =\ndict.from_pairs(pairs)\n|> dict.to_pairs()\n\nresult == [Pair(\"a\", 100), Pair(\"b\", 200), Pair(\"c\", 300)]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Pairs<ByteArray, value>",
              "optional": false
            }
          ],
          "returnType": "Dict<key, value>",
          "line": 157,
          "raw": "pub fn from_pairs(self: Pairs<ByteArray, value>) -> Dict<key, value> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_pairs(self: Pairs<ByteArray, value>) -> Dict<key, value> {\n  Dict { inner: do_from_pairs(self) }\n}"
        },
        {
          "name": "find",
          "signature": "pub fn find(self: Dict<key, value>, value v: value) -> Option<ByteArray> {",
          "documentation": "Finds a value in the dictionary, and returns the first key found to have that value.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(key: \"a\", value: 42)\n|> dict.insert(key: \"b\", value: 14)\n|> dict.insert(key: \"c\", value: 42)\n|> dict.find(42)\n\nresult == Some(\"a\")\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Dict<key, value>",
              "optional": false
            }
          ],
          "returnType": "Option<ByteArray>",
          "line": 215,
          "raw": "pub fn find(self: Dict<key, value>, value v: value) -> Option<ByteArray> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn find(self: Dict<key, value>, value v: value) -> Option<ByteArray> {\n  do_find(self.inner, v)\n}"
        },
        {
          "name": "get",
          "signature": "pub fn get(self: Dict<key, value>, key: ByteArray) -> Option<value> {",
          "documentation": "Get a value in the dict by its key.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(key: \"a\", value: \"Aiken\")\n|> dict.get(key: \"a\")\n\nresult == Some(\"Aiken\")\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Dict<key, value>",
              "optional": false
            },
            {
              "name": "key",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Option<value>",
          "line": 271,
          "raw": "pub fn get(self: Dict<key, value>, key: ByteArray) -> Option<value> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn get(self: Dict<key, value>, key: ByteArray) -> Option<value> {\n  do_get(self.inner, key)\n}"
        },
        {
          "name": "has_key",
          "signature": "pub fn has_key(self: Dict<key, value>, key k: ByteArray) -> Bool {",
          "documentation": "Check if a key exists in the dictionary.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(key: \"a\", value: \"Aiken\")\n|> dict.has_key(\"a\")\n\nresult == True\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Dict<key, value>",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 355,
          "raw": "pub fn has_key(self: Dict<key, value>, key k: ByteArray) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn has_key(self: Dict<key, value>, key k: ByteArray) -> Bool {\n  do_has_key(self.inner, k)\n}"
        },
        {
          "name": "is_empty",
          "signature": "pub fn is_empty(self: Dict<key, value>) -> Bool {",
          "documentation": "Efficiently checks whether a dictionary is empty.\n```aiken\ndict.is_empty(dict.empty) == True\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Dict<key, value>",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 404,
          "raw": "pub fn is_empty(self: Dict<key, value>) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn is_empty(self: Dict<key, value>) -> Bool {\n  when self.inner is {\n    [] -> True\n    _ -> False\n  }\n}",
          "tests": ["test is_empty_1() {\n  is_empty(empty)\n}"]
        },
        {
          "name": "keys",
          "signature": "pub fn keys(self: Dict<key, value>) -> List<ByteArray> {",
          "documentation": "Extract all the keys present in a given `Dict`.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(\"a\", 14)\n|> dict.insert(\"b\", 42)\n|> dict.insert(\"a\", 1337)\n|> dict.keys()\n\nresult == [\"a\", \"b\"]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Dict<key, value>",
              "optional": false
            }
          ],
          "returnType": "List<ByteArray>",
          "line": 427,
          "raw": "pub fn keys(self: Dict<key, value>) -> List<ByteArray> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn keys(self: Dict<key, value>) -> List<ByteArray> {\n  do_keys(self.inner)\n}"
        },
        {
          "name": "size",
          "signature": "pub fn size(self: Dict<key, value>) -> Int {",
          "documentation": "Return the number of key-value pairs in the dictionary.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(\"a\", 100)\n|> dict.insert(\"b\", 200)\n|> dict.insert(\"c\", 300)\n|> dict.size()\n\nresult == 3\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Dict<key, value>",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 462,
          "raw": "pub fn size(self: Dict<key, value>) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn size(self: Dict<key, value>) -> Int {\n  do_size(self.inner)\n}"
        },
        {
          "name": "values",
          "signature": "pub fn values(self: Dict<key, value>) -> List<value> {",
          "documentation": "Extract all the values present in a given `Dict`.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(\"a\", 14)\n|> dict.insert(\"b\", 42)\n|> dict.insert(\"c\", 1337)\n|> dict.values()\n\nresult == [14, 42, 1337]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Dict<key, value>",
              "optional": false
            }
          ],
          "returnType": "List<value>",
          "line": 504,
          "raw": "pub fn values(self: Dict<key, value>) -> List<value> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn values(self: Dict<key, value>) -> List<value> {\n  do_values(self.inner)\n}"
        },
        {
          "name": "delete",
          "signature": "pub fn delete(self: Dict<key, value>, key: ByteArray) -> Dict<key, value> {",
          "documentation": "Remove a key-value pair from the dictionary. If the key is not found, no changes are made.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(key: \"a\", value: 100)\n|> dict.insert(key: \"b\", value: 200)\n|> dict.delete(key: \"a\")\n|> dict.to_pairs()\n\nresult == [Pair(\"b\", 200)]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Dict<key, value>",
              "optional": false
            },
            {
              "name": "key",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Dict<key, value>",
          "line": 541,
          "raw": "pub fn delete(self: Dict<key, value>, key: ByteArray) -> Dict<key, value> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn delete(self: Dict<key, value>, key: ByteArray) -> Dict<key, value> {\n  Dict { inner: do_delete(self.inner, key) }\n}"
        },
        {
          "name": "filter",
          "signature": "pub fn filter(pub fn filter(self: Dict<key, value>, with: fn(ByteArray, value) -> Bool,",
          "documentation": "Keep only the key-value pairs that pass the given predicate.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(key: \"a\", value: 100)\n|> dict.insert(key: \"b\", value: 200)\n|> dict.insert(key: \"c\", value: 300)\n|> dict.filter(fn(k, _v) { k != \"a\" })\n|> dict.to_pairs()\n\nresult == [Pair(\"b\", 200), Pair(\"c\", 300)]\n```",
          "parameters": [],
          "returnType": "Bool,",
          "line": 628,
          "raw": "pub fn filter(pub fn filter(self: Dict<key, value>, with: fn(ByteArray, value) -> Bool,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn filter(\n  self: Dict<key, value>,\n  with: fn(ByteArray, value) -> Bool,\n) -> Dict<key, value> {\n  Dict { inner: do_filter(self.inner, with) }\n}"
        },
        {
          "name": "insert",
          "signature": "pub fn insert(pub fn insert(self: Dict<key, value>, key k: ByteArray, value v: value, ) -> Dict<key, value> {",
          "documentation": "Insert a value in the dictionary at a given key. If the key already exists, its value is **overridden**. If you need ways to combine keys together, use (`insert_with`)[#insert_with].\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(key: \"a\", value: 1)\n|> dict.insert(key: \"b\", value: 2)\n|> dict.insert(key: \"a\", value: 3)\n|> dict.to_pairs()\n\nresult == [Pair(\"a\", 3), Pair(\"b\", 2)]\n```",
          "parameters": [],
          "returnType": "Dict<key, value>",
          "line": 680,
          "raw": "pub fn insert(pub fn insert(self: Dict<key, value>, key k: ByteArray, value v: value, ) -> Dict<key, value> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn insert(\n  self: Dict<key, value>,\n  key k: ByteArray,\n  value v: value,\n) -> Dict<key, value> {\n  Dict { inner: do_insert(self.inner, k, v) }\n}"
        },
        {
          "name": "insert_with",
          "signature": "pub fn insert_with(pub fn insert_with(self: Dict<key, value>, key k: ByteArray, value v: value, with: UnionStrategy<ByteArray, value>, ) -> Dict<key, value> {",
          "documentation": "Insert a value in the dictionary at a given key. When the key already exist, the provided\nmerge function is called. The value existing in the dictionary is passed as the second argument\nto the merge function, and the new value is passed as the third argument.\n\n```aiken\nuse aiken/collection/dict/union\n\nlet result =\ndict.empty\n|> dict.insert_with(key: \"a\", value: 1, with: strategy.sum())\n|> dict.insert_with(key: \"b\", value: 2, with: strategy.sum())\n|> dict.insert_with(key: \"a\", value: 3, with: strategy.sum())\n|> dict.to_pairs()\n\nresult == [Pair(\"a\", 4), Pair(\"b\", 2)]\n```",
          "parameters": [],
          "returnType": "Dict<key, value>",
          "line": 744,
          "raw": "pub fn insert_with(pub fn insert_with(self: Dict<key, value>, key k: ByteArray, value v: value, with: UnionStrategy<ByteArray, value>, ) -> Dict<key, value> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn insert_with(\n  self: Dict<key, value>,\n  key k: ByteArray,\n  value v: value,\n  with: UnionStrategy<ByteArray, value>,\n) -> Dict<key, value> {\n  Dict {\n    inner: do_insert_with(\n      self.inner,\n      k,\n      v,\n      fn(k, v1, v2, some, none) { with(k, v2, v1, some, none) },\n    ),\n  }\n}",
          "tests": [
            "test insert_with_1() {\n  let result =\n    empty\n      |> insert_with(key: \"foo\", value: 1, with: strategy.sum())\n      |> insert_with(key: \"bar\", value: 2, with: strategy.sum())\n      |> to_pairs()\n\n  result == [Pair(\"bar\", 2), Pair(\"foo\", 1)]\n}",
            "test insert_with_2() {\n  let result =\n    empty\n      |> insert_with(key: \"foo\", value: 1, with: strategy.sum())\n      |> insert_with(key: \"bar\", value: 2, with: strategy.sum())\n      |> insert_with(key: \"foo\", value: 3, with: strategy.sum())\n      |> to_pairs()\n\n  result == [Pair(\"bar\", 2), Pair(\"foo\", 4)]\n}",
            "test insert_with_3() {\n  let with =\n    fn(k, a, _b, keep, discard) {\n      if k == \"foo\" {\n        keep(a)\n      } else {\n        discard()\n      }\n    }\n\n  let result =\n    empty\n      |> insert_with(key: \"foo\", value: 1, with: with)\n      |> insert_with(key: \"bar\", value: 2, with: with)\n      |> insert_with(key: \"foo\", value: 3, with: with)\n      |> insert_with(key: \"bar\", value: 4, with: with)\n      |> to_pairs()\n\n  result == [Pair(\"foo\", 1)]\n}"
          ]
        },
        {
          "name": "map",
          "signature": "pub fn map(self: Dict<key, a>, with: fn(ByteArray, a) -> b) -> Dict<key, b> {",
          "documentation": "Apply a function to all key-value pairs in a Dict.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(\"a\", 100)\n|> dict.insert(\"b\", 200)\n|> dict.insert(\"c\", 300)\n|> dict.map(fn(_k, v) { v * 2 })\n|> dict.to_pairs()\n\nresult == [Pair(\"a\", 200), Pair(\"b\", 400), Pair(\"c\", 600)]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Dict<key, a>",
              "optional": false
            },
            {
              "name": "with",
              "type": "fn(ByteArray, a",
              "optional": false
            }
          ],
          "returnType": "b) -> Dict<key, b>",
          "line": 815,
          "raw": "pub fn map(self: Dict<key, a>, with: fn(ByteArray, a) -> b) -> Dict<key, b> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn map(self: Dict<key, a>, with: fn(ByteArray, a) -> b) -> Dict<key, b> {\n  Dict { inner: do_map(self.inner, with) }\n}"
        },
        {
          "name": "pop",
          "signature": "pub fn pop(pub fn pop(self: Dict<key, value>, key: ByteArray, ) -> (Option<value>, Dict<key, value>) {",
          "documentation": "Remove a key-value pair from the dictionary and return its value. If the key is not found, no changes are made.\n\n```aiken\nlet (value, _) =\ndict.empty\n|> dict.insert(key: \"a\", value: 100)\n|> dict.insert(key: \"b\", value: 200)\n|> dict.pop(key: \"a\")\n\nresult == 100\n```",
          "parameters": [],
          "returnType": "(Option<value>, Dict<key, value>)",
          "line": 854,
          "raw": "pub fn pop(pub fn pop(self: Dict<key, value>, key: ByteArray, ) -> (Option<value>, Dict<key, value>) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn pop(\n  self: Dict<key, value>,\n  key: ByteArray,\n) -> (Option<value>, Dict<key, value>) {\n  do_pop(self.inner, key, fn(value, inner) { (value, Dict { inner }) })\n}"
        },
        {
          "name": "union",
          "signature": "pub fn union(pub fn union(left: Dict<key, value>, right: Dict<key, value>, ) -> Dict<key, value> {",
          "documentation": "Combine two dictionaries. If the same key exist in both the left and\nright dictionary, values from the left are preferred (i.e. left-biaised).\n\n```aiken\nlet left_dict = dict.from_pairs([Pair(\"a\", 100), Pair(\"b\", 200)])\nlet right_dict = dict.from_pairs([Pair(\"a\", 150), Pair(\"c\", 300)])\n\nlet result =\ndict.union(left_dict, right_dict) |> dict.to_pairs()\n\nresult == [Pair(\"a\", 100), Pair(\"b\", 200), Pair(\"c\", 300)]\n```",
          "parameters": [],
          "returnType": "Dict<key, value>",
          "line": 942,
          "raw": "pub fn union(pub fn union(left: Dict<key, value>, right: Dict<key, value>, ) -> Dict<key, value> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn union(\n  left: Dict<key, value>,\n  right: Dict<key, value>,\n) -> Dict<key, value> {\n  Dict { inner: do_union(left.inner, right.inner) }\n}"
        },
        {
          "name": "union_with",
          "signature": "pub fn union_with(pub fn union_with(left: Dict<key, value>, right: Dict<key, value>, with: UnionStrategy<ByteArray, value>, ) -> Dict<key, value> {",
          "documentation": "Like [`union`](#union) but allows specifying the behavior to adopt when a key is present\nin both dictionaries. The first value received correspond to the value in the left\ndictionnary, whereas the second argument corresponds to the value in the right dictionnary.\n\nWhen passing `None`, the value is removed and not present in the union.\n\n```aiken\nlet left_dict = dict.from_pairs([Pair(\"a\", 100), Pair(\"b\", 200)])\nlet right_dict = dict.from_pairs([Pair(\"a\", 150), Pair(\"c\", 300)])\n\nlet result =\ndict.union_with(\nleft_dict,\nright_dict,\nfn(_k, v1, v2) { Some(v1 + v2) },\n)\n|> dict.to_pairs()\n\nresult == [Pair(\"a\", 250), Pair(\"b\", 200), Pair(\"c\", 300)]\n```",
          "parameters": [],
          "returnType": "Dict<key, value>",
          "line": 1011,
          "raw": "pub fn union_with(pub fn union_with(left: Dict<key, value>, right: Dict<key, value>, with: UnionStrategy<ByteArray, value>, ) -> Dict<key, value> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn union_with(\n  left: Dict<key, value>,\n  right: Dict<key, value>,\n  with: UnionStrategy<ByteArray, value>,\n) -> Dict<key, value> {\n  Dict { inner: do_union_with(left.inner, right.inner, with) }\n}"
        },
        {
          "name": "foldl",
          "signature": "pub fn foldl(pub fn foldl(self: Dict<key, value>, zero: result, with: fn(ByteArray, value, result) -> result,",
          "documentation": "Fold over the key-value pairs in a dictionary. The fold direction follows keys\nin ascending order and is done from left-to-right.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(key: \"a\", value: 100)\n|> dict.insert(key: \"b\", value: 200)\n|> dict.insert(key: \"c\", value: 300)\n|> dict.foldl(0, fn(_k, v, r) { v + r })\n\nresult == 600\n```",
          "parameters": [],
          "returnType": "result,",
          "line": 1088,
          "raw": "pub fn foldl(pub fn foldl(self: Dict<key, value>, zero: result, with: fn(ByteArray, value, result) -> result,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn foldl(\n  self: Dict<key, value>,\n  zero: result,\n  with: fn(ByteArray, value, result) -> result,\n) -> result {\n  do_foldl(self.inner, zero, with)\n}"
        },
        {
          "name": "foldr",
          "signature": "pub fn foldr(pub fn foldr(self: Dict<key, value>, zero: result, with: fn(ByteArray, value, result) -> result,",
          "documentation": "Fold over the key-value pairs in a dictionary. The fold direction follows keys\nin ascending order and is done from right-to-left.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(key: \"a\", value: 100)\n|> dict.insert(key: \"b\", value: 200)\n|> dict.insert(key: \"c\", value: 300)\n|> dict.foldr(0, fn(_k, v, r) { v + r })\n\nresult == 600\n```",
          "parameters": [],
          "returnType": "result,",
          "line": 1128,
          "raw": "pub fn foldr(pub fn foldr(self: Dict<key, value>, zero: result, with: fn(ByteArray, value, result) -> result,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn foldr(\n  self: Dict<key, value>,\n  zero: result,\n  with: fn(ByteArray, value, result) -> result,\n) -> result {\n  do_foldr(self.inner, zero, with)\n}"
        },
        {
          "name": "to_pairs",
          "signature": "pub fn to_pairs(self: Dict<key, value>) -> Pairs<ByteArray, value> {",
          "documentation": "Get the inner list holding the dictionary data.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(\"a\", 100)\n|> dict.insert(\"b\", 200)\n|> dict.insert(\"c\", 300)\n|> dict.to_pairs()\n\nresult == [Pair(\"a\", 100), Pair(\"b\", 200), Pair(\"c\", 300)]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Dict<key, value>",
              "optional": false
            }
          ],
          "returnType": "Pairs<ByteArray, value>",
          "line": 1167,
          "raw": "pub fn to_pairs(self: Dict<key, value>) -> Pairs<ByteArray, value> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn to_pairs(self: Dict<key, value>) -> Pairs<ByteArray, value> {\n  self.inner\n}"
        }
      ],
      "types": [
        {
          "name": "Dict<key, value>",
          "definition": "opaque { inner: Pairs<ByteArray, value>, }",
          "line": 31,
          "raw": "pub opaque type Dict<key, value> {",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "constants": [
        {
          "name": "empty",
          "type": "Dict<key, value>",
          "value": "Dict { inner: [] }",
          "line": 41,
          "raw": "pub const empty: Dict<key, value> = Dict { inner: [] }",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "atoms": [
        {
          "name": "check_ascending_list",
          "signature": "fn check_ascending_list(xs: Pairs<ByteArray, value>) {",
          "parameters": [
            {
              "name": "xs",
              "type": "Pairs<ByteArray, value>",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 77,
          "raw": "fn check_ascending_list(xs: Pairs<ByteArray, value>) {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn check_ascending_list(xs: Pairs<ByteArray, value>) {\n  when xs is {\n    [] -> Void\n    [_] -> Void\n    [Pair(x0, _), Pair(x1, _) as e, ..rest] ->\n      if builtin.less_than_bytearray(x0, x1) {\n        check_ascending_list([e, ..rest])\n      } else {\n        fail @\"keys in associative list aren't in ascending order\"\n      }\n  }\n}"
        },
        {
          "name": "check_ascending_pairs_with",
          "signature": "fn check_ascending_pairs_with(fn check_ascending_pairs_with(xs: Pairs<ByteArray, value>, predicate: fn(value) -> Bool,",
          "parameters": [],
          "returnType": "Bool,",
          "line": 106,
          "raw": "fn check_ascending_pairs_with(fn check_ascending_pairs_with(xs: Pairs<ByteArray, value>, predicate: fn(value) -> Bool,",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn check_ascending_pairs_with(\n  xs: Pairs<ByteArray, value>,\n  predicate: fn(value) -> Bool,\n) {\n  when xs is {\n    [] -> Void\n    [Pair(_, v)] ->\n      if predicate(v) {\n        Void\n      } else {\n        fail @\"value doesn't satisfy predicate\"\n      }\n    [Pair(x0, v0), Pair(x1, _) as e, ..rest] ->\n      if builtin.less_than_bytearray(x0, x1) {\n        if predicate(v0) {\n          check_ascending_pairs_with([e, ..rest], predicate)\n        } else {\n          fail @\"value doesn't satisfy predicate\"\n        }\n      } else {\n        fail @\"keys in pairs aren't in ascending order\"\n      }\n  }\n}"
        },
        {
          "name": "do_from_pairs",
          "signature": "fn do_from_pairs(xs: Pairs<ByteArray, value>) -> Pairs<ByteArray, value> {",
          "parameters": [
            {
              "name": "xs",
              "type": "Pairs<ByteArray, value>",
              "optional": false
            }
          ],
          "returnType": "Pairs<ByteArray, value>",
          "line": 161,
          "raw": "fn do_from_pairs(xs: Pairs<ByteArray, value>) -> Pairs<ByteArray, value> {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_from_pairs(xs: Pairs<ByteArray, value>) -> Pairs<ByteArray, value> {\n  when xs is {\n    [] -> []\n    [Pair(k, v), ..rest] ->\n      do_insert_with(do_from_pairs(rest), k, v, strategy.keep_left())\n  }\n}"
        },
        {
          "name": "do_find",
          "signature": "fn do_find(self: Pairs<ByteArray, value>, value v: value) -> Option<ByteArray> {",
          "parameters": [
            {
              "name": "self",
              "type": "Pairs<ByteArray, value>",
              "optional": false
            }
          ],
          "returnType": "Option<ByteArray>",
          "line": 219,
          "raw": "fn do_find(self: Pairs<ByteArray, value>, value v: value) -> Option<ByteArray> {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_find(self: Pairs<ByteArray, value>, value v: value) -> Option<ByteArray> {\n  when self is {\n    [] -> None\n    [Pair(k2, v2), ..rest] ->\n      if v == v2 {\n        Some(k2)\n      } else {\n        do_find(rest, v)\n      }\n  }\n}"
        },
        {
          "name": "do_get",
          "signature": "fn do_get(self: Pairs<ByteArray, value>, key k: ByteArray) -> Option<value> {",
          "parameters": [
            {
              "name": "self",
              "type": "Pairs<ByteArray, value>",
              "optional": false
            }
          ],
          "returnType": "Option<value>",
          "line": 275,
          "raw": "fn do_get(self: Pairs<ByteArray, value>, key k: ByteArray) -> Option<value> {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_get(self: Pairs<ByteArray, value>, key k: ByteArray) -> Option<value> {\n  when self is {\n    [] -> None\n    [Pair(k2, v), ..rest] ->\n      if builtin.less_than_equals_bytearray(k, k2) {\n        if k == k2 {\n          Some(v)\n        } else {\n          None\n        }\n      } else {\n        do_get(rest, k)\n      }\n  }\n}"
        },
        {
          "name": "do_has_key",
          "signature": "fn do_has_key(self: Pairs<ByteArray, value>, key k: ByteArray) -> Bool {",
          "parameters": [
            {
              "name": "self",
              "type": "Pairs<ByteArray, value>",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 359,
          "raw": "fn do_has_key(self: Pairs<ByteArray, value>, key k: ByteArray) -> Bool {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_has_key(self: Pairs<ByteArray, value>, key k: ByteArray) -> Bool {\n  when self is {\n    [] -> False\n    [Pair(k2, _), ..rest] ->\n      if builtin.less_than_equals_bytearray(k, k2) {\n        k == k2\n      } else {\n        do_has_key(rest, k)\n      }\n  }\n}"
        },
        {
          "name": "do_keys",
          "signature": "fn do_keys(self: Pairs<ByteArray, value>) -> List<ByteArray> {",
          "parameters": [
            {
              "name": "self",
              "type": "Pairs<ByteArray, value>",
              "optional": false
            }
          ],
          "returnType": "List<ByteArray>",
          "line": 431,
          "raw": "fn do_keys(self: Pairs<ByteArray, value>) -> List<ByteArray> {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_keys(self: Pairs<ByteArray, value>) -> List<ByteArray> {\n  when self is {\n    [] -> []\n    [Pair(k, _), ..rest] -> [k, ..do_keys(rest)]\n  }\n}"
        },
        {
          "name": "do_size",
          "signature": "fn do_size(self: Pairs<key, value>) -> Int {",
          "parameters": [
            {
              "name": "self",
              "type": "Pairs<key, value>",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 466,
          "raw": "fn do_size(self: Pairs<key, value>) -> Int {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_size(self: Pairs<key, value>) -> Int {\n  when self is {\n    [] -> 0\n    [_, ..rest] -> 1 + do_size(rest)\n  }\n}"
        },
        {
          "name": "do_values",
          "signature": "fn do_values(self: Pairs<key, value>) -> List<value> {",
          "parameters": [
            {
              "name": "self",
              "type": "Pairs<key, value>",
              "optional": false
            }
          ],
          "returnType": "List<value>",
          "line": 508,
          "raw": "fn do_values(self: Pairs<key, value>) -> List<value> {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_values(self: Pairs<key, value>) -> List<value> {\n  when self is {\n    [] -> []\n    [Pair(_, v), ..rest] -> [v, ..do_values(rest)]\n  }\n}"
        },
        {
          "name": "do_delete",
          "signature": "fn do_delete(fn do_delete(self: Pairs<ByteArray, value>, key k: ByteArray, ) -> Pairs<ByteArray, value> {",
          "parameters": [],
          "returnType": "Pairs<ByteArray, value>",
          "line": 545,
          "raw": "fn do_delete(fn do_delete(self: Pairs<ByteArray, value>, key k: ByteArray, ) -> Pairs<ByteArray, value> {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_delete(\n  self: Pairs<ByteArray, value>,\n  key k: ByteArray,\n) -> Pairs<ByteArray, value> {\n  when self is {\n    [] -> []\n    [Pair(k2, v2), ..rest] ->\n      if builtin.less_than_equals_bytearray(k, k2) {\n        if k == k2 {\n          rest\n        } else {\n          self\n        }\n      } else {\n        [Pair(k2, v2), ..do_delete(rest, k)]\n      }\n  }\n}"
        },
        {
          "name": "do_filter",
          "signature": "fn do_filter(fn do_filter(self: Pairs<ByteArray, value>, with: fn(ByteArray, value) -> Bool,",
          "parameters": [],
          "returnType": "Bool,",
          "line": 635,
          "raw": "fn do_filter(fn do_filter(self: Pairs<ByteArray, value>, with: fn(ByteArray, value) -> Bool,",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_filter(\n  self: Pairs<ByteArray, value>,\n  with: fn(ByteArray, value) -> Bool,\n) -> Pairs<ByteArray, value> {\n  when self is {\n    [] -> []\n    [Pair(k, v), ..rest] ->\n      if with(k, v) {\n        [Pair(k, v), ..do_filter(rest, with)]\n      } else {\n        do_filter(rest, with)\n      }\n  }\n}"
        },
        {
          "name": "do_insert",
          "signature": "fn do_insert(fn do_insert(self: Pairs<ByteArray, value>, key k: ByteArray, value v: value, ) -> Pairs<ByteArray, value> {",
          "parameters": [],
          "returnType": "Pairs<ByteArray, value>",
          "line": 688,
          "raw": "fn do_insert(fn do_insert(self: Pairs<ByteArray, value>, key k: ByteArray, value v: value, ) -> Pairs<ByteArray, value> {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_insert(\n  self: Pairs<ByteArray, value>,\n  key k: ByteArray,\n  value v: value,\n) -> Pairs<ByteArray, value> {\n  when self is {\n    [] -> [Pair(k, v)]\n    [Pair(k2, v2), ..rest] ->\n      if builtin.less_than_bytearray(k, k2) {\n        [Pair(k, v), ..self]\n      } else {\n        if k == k2 {\n          [Pair(k, v), ..rest]\n        } else {\n          [Pair(k2, v2), ..do_insert(rest, k, v)]\n        }\n      }\n  }\n}"
        },
        {
          "name": "do_map",
          "signature": "fn do_map(fn do_map(self: Pairs<ByteArray, a>, with: fn(ByteArray, a) -> b,",
          "parameters": [],
          "returnType": "b,",
          "line": 819,
          "raw": "fn do_map(fn do_map(self: Pairs<ByteArray, a>, with: fn(ByteArray, a) -> b,",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_map(\n  self: Pairs<ByteArray, a>,\n  with: fn(ByteArray, a) -> b,\n) -> Pairs<ByteArray, b> {\n  when self is {\n    [] -> []\n    [Pair(k, v), ..rest] -> [Pair(k, with(k, v)), ..do_map(rest, with)]\n  }\n}"
        },
        {
          "name": "do_pop",
          "signature": "fn do_pop(fn do_pop(self: Pairs<ByteArray, value>, key k: ByteArray, return: fn(Option<value>, Pairs<ByteArray, value>) -> result,",
          "parameters": [],
          "returnType": "result,",
          "line": 861,
          "raw": "fn do_pop(fn do_pop(self: Pairs<ByteArray, value>, key k: ByteArray, return: fn(Option<value>, Pairs<ByteArray, value>) -> result,",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_pop(\n  self: Pairs<ByteArray, value>,\n  key k: ByteArray,\n  return: fn(Option<value>, Pairs<ByteArray, value>) -> result,\n) -> result {\n  when self is {\n    [] -> return(None, [])\n    [Pair(k2, v2), ..rest] ->\n      if builtin.less_than_equals_bytearray(k, k2) {\n        if k == k2 {\n          return(Some(v2), rest)\n        } else {\n          return(None, self)\n        }\n      } else {\n        do_pop(\n          rest,\n          k,\n          fn(value, inner) { return(value, [Pair(k2, v2), ..inner]) },\n        )\n      }\n  }\n}"
        },
        {
          "name": "do_union",
          "signature": "fn do_union(fn do_union(left: Pairs<ByteArray, value>, right: Pairs<ByteArray, value>, ) -> Pairs<ByteArray, value> {",
          "parameters": [],
          "returnType": "Pairs<ByteArray, value>",
          "line": 949,
          "raw": "fn do_union(fn do_union(left: Pairs<ByteArray, value>, right: Pairs<ByteArray, value>, ) -> Pairs<ByteArray, value> {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_union(\n  left: Pairs<ByteArray, value>,\n  right: Pairs<ByteArray, value>,\n) -> Pairs<ByteArray, value> {\n  when left is {\n    [] -> right\n    [Pair(k, v), ..rest] -> do_union(rest, do_insert(right, k, v))\n  }\n}"
        },
        {
          "name": "do_union_with",
          "signature": "fn do_union_with(fn do_union_with(left: Pairs<ByteArray, value>, right: Pairs<ByteArray, value>, with: UnionStrategy<ByteArray, value>, ) -> Pairs<ByteArray, value> {",
          "parameters": [],
          "returnType": "Pairs<ByteArray, value>",
          "line": 1019,
          "raw": "fn do_union_with(fn do_union_with(left: Pairs<ByteArray, value>, right: Pairs<ByteArray, value>, with: UnionStrategy<ByteArray, value>, ) -> Pairs<ByteArray, value> {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_union_with(\n  left: Pairs<ByteArray, value>,\n  right: Pairs<ByteArray, value>,\n  with: UnionStrategy<ByteArray, value>,\n) -> Pairs<ByteArray, value> {\n  when left is {\n    [] -> right\n    [Pair(k, v), ..rest] ->\n      do_union_with(rest, do_insert_with(right, k, v, with), with)\n  }\n}"
        },
        {
          "name": "do_insert_with",
          "signature": "fn do_insert_with(fn do_insert_with(self: Pairs<ByteArray, value>, key k: ByteArray, value v: value, with: UnionStrategy<ByteArray, value>, ) -> Pairs<ByteArray, value> {",
          "parameters": [],
          "returnType": "Pairs<ByteArray, value>",
          "line": 1031,
          "raw": "fn do_insert_with(fn do_insert_with(self: Pairs<ByteArray, value>, key k: ByteArray, value v: value, with: UnionStrategy<ByteArray, value>, ) -> Pairs<ByteArray, value> {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_insert_with(\n  self: Pairs<ByteArray, value>,\n  key k: ByteArray,\n  value v: value,\n  with: UnionStrategy<ByteArray, value>,\n) -> Pairs<ByteArray, value> {\n  when self is {\n    [] -> [Pair(k, v)]\n    [Pair(k2, v2), ..rest] ->\n      if builtin.less_than_bytearray(k, k2) {\n        [Pair(k, v), ..self]\n      } else {\n        if k == k2 {\n          with(\n            k,\n            v,\n            v2,\n            fn(combined) { [Pair(k, combined), ..rest] },\n            fn() { rest },\n          )\n        } else {\n          [Pair(k2, v2), ..do_insert_with(rest, k, v, with)]\n        }\n      }\n  }\n}"
        },
        {
          "name": "do_foldl",
          "signature": "fn do_foldl(fn do_foldl(self: Pairs<ByteArray, value>, zero: result, with: fn(ByteArray, value, result) -> result,",
          "parameters": [],
          "returnType": "result,",
          "line": 1096,
          "raw": "fn do_foldl(fn do_foldl(self: Pairs<ByteArray, value>, zero: result, with: fn(ByteArray, value, result) -> result,",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_foldl(\n  self: Pairs<ByteArray, value>,\n  zero: result,\n  with: fn(ByteArray, value, result) -> result,\n) -> result {\n  when self is {\n    [] -> zero\n    [Pair(k, v), ..rest] -> do_foldl(rest, with(k, v, zero), with)\n  }\n}"
        },
        {
          "name": "do_foldr",
          "signature": "fn do_foldr(fn do_foldr(self: Pairs<ByteArray, value>, zero: result, with: fn(ByteArray, value, result) -> result,",
          "parameters": [],
          "returnType": "result,",
          "line": 1136,
          "raw": "fn do_foldr(fn do_foldr(self: Pairs<ByteArray, value>, zero: result, with: fn(ByteArray, value, result) -> result,",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_foldr(\n  self: Pairs<ByteArray, value>,\n  zero: result,\n  with: fn(ByteArray, value, result) -> result,\n) -> result {\n  when self is {\n    [] -> zero\n    [Pair(k, v), ..rest] -> with(k, v, do_foldr(rest, zero, with))\n  }\n}"
        }
      ],
      "privateTypes": [],
      "privateConstants": [
        {
          "name": "foo",
          "type": "Unknown",
          "value": "#\"666f6f\"",
          "line": 43,
          "raw": "const foo = #\"666f6f\"",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "bar",
          "type": "Unknown",
          "value": "#\"626172\"",
          "line": 45,
          "raw": "const bar = #\"626172\"",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "baz",
          "type": "Unknown",
          "value": "#\"62617a\"",
          "line": 47,
          "raw": "const baz = #\"62617a\"",
          "isPublic": false,
          "source": "stdlib"
        }
      ],
      "content": "//// A module for working with bytearray dictionaries.\n////\n////\n//// > [!IMPORTANT]\n//// >\n//// > Dictionaries are **ordered sets** of key-value pairs, which thus\n//// > preserve some invariants. Specifically, each key is only present once in\n//// > the dictionary and all keys are stored in ascending lexicographic order.\n//// >\n//// > These invariants allow for more optimized functions to operate on `Dict`,\n//// > but as a trade-offs, prevent `Dict` from being serializable. To recover a `Dict`\n//// > from an unknown `Data`, you must first recover an `Pairs<k, v>` and use\n//// > [`dict.from_ascending_list`](#from_ascending_list).\n\nuse aiken/builtin\nuse aiken/collection/dict/strategy.{UnionStrategy}\n\n/// An opaque `Dict`. The type is opaque because the module maintains some\n/// invariant, namely: there's only one occurrence of a given key in the dictionary.\n///\n/// Note that the `key` parameter is a phantom-type, and only present as a\n/// means of documentation. Keys can be any type, yet will need to comparable\n/// to use functions like `insert`.\n///\n/// See for example:\n///\n/// ```aiken\n/// pub type Value =\n///   Dict<PolicyId, Dict<AssetName, Int>>\n/// ```\npub opaque type Dict<key, value> {\n  inner: Pairs<ByteArray, value>,\n}\n\n// ## Constructing\n\n/// An empty dictionnary.\n/// ```aiken\n/// dict.to_pairs(dict.empty) == []\n/// ```\npub const empty: Dict<key, value> = Dict { inner: [] }\n\nconst foo = #\"666f6f\"\n\nconst bar = #\"626172\"\n\nconst baz = #\"62617a\"\n\nconst fixture_1 =\n  empty\n    |> insert(foo, 42)\n    |> insert(bar, 14)\n\n/// Like ['from_pairs'](#from_pairs), but from an already sorted list by ascending\n/// keys. This function fails (i.e. halts the program execution) if the list isn't\n/// sorted.\n///\n/// ```aiken\n/// let pairs = [Pair(\"a\", 100), Pair(\"b\", 200), Pair(\"c\", 300)]\n///\n/// let result =\n///   dict.from_ascending_pairs(pairs)\n///     |> dict.to_pairs()\n///\n/// result == [Pair(\"a\", 100), Pair(\"b\", 200), Pair(\"c\", 300)]\n/// ```\n///\n/// This is meant to be used to turn a list constructed off-chain into a `Dict`\n/// which has taken care of maintaining interval invariants. This function still\n/// performs a sanity check on all keys to avoid silly mistakes. It is, however,\n/// considerably faster than ['from_pairs'](from_pairs)\npub fn from_ascending_pairs(xs: Pairs<ByteArray, value>) -> Dict<key, value> {\n  let Void = check_ascending_list(xs)\n  Dict { inner: xs }\n}\n\nfn check_ascending_list(xs: Pairs<ByteArray, value>) {\n  when xs is {\n    [] -> Void\n    [_] -> Void\n    [Pair(x0, _), Pair(x1, _) as e, ..rest] ->\n      if builtin.less_than_bytearray(x0, x1) {\n        check_ascending_list([e, ..rest])\n      } else {\n        fail @\"keys in associative list aren't in ascending order\"\n      }\n  }\n}\n\n/// Like [`from_ascending_pairs`](#from_ascending_pairs) but fails if **any**\n/// value doesn't satisfy the predicate.\n///\n/// ```aiken\n/// let pairs = [Pair(\"a\", 100), Pair(\"b\", 200), Pair(\"c\", 300)]\n///\n/// dict.from_ascending_pairs_with(pairs, fn(x) { x <= 250 }) // fail\n/// ```\npub fn from_ascending_pairs_with(\n  xs: Pairs<ByteArray, value>,\n  predicate: fn(value) -> Bool,\n) -> Dict<key, value> {\n  let Void = check_ascending_pairs_with(xs, predicate)\n  Dict { inner: xs }\n}\n\nfn check_ascending_pairs_with(\n  xs: Pairs<ByteArray, value>,\n  predicate: fn(value) -> Bool,\n) {\n  when xs is {\n    [] -> Void\n    [Pair(_, v)] ->\n      if predicate(v) {\n        Void\n      } else {\n        fail @\"value doesn't satisfy predicate\"\n      }\n    [Pair(x0, v0), Pair(x1, _) as e, ..rest] ->\n      if builtin.less_than_bytearray(x0, x1) {\n        if predicate(v0) {\n          check_ascending_pairs_with([e, ..rest], predicate)\n        } else {\n          fail @\"value doesn't satisfy predicate\"\n        }\n      } else {\n        fail @\"keys in pairs aren't in ascending order\"\n      }\n  }\n}\n\ntest bench_from_ascending_pairs() {\n  let dict =\n    from_ascending_pairs(\n      [\n        Pair(\"aaaa\", 1), Pair(\"aaab\", 9), Pair(\"aaba\", 5), Pair(\"aabb\", 13),\n        Pair(\"abaa\", 2), Pair(\"abab\", 10), Pair(\"abba\", 6), Pair(\"abbb\", 14),\n        Pair(\"baaa\", 3), Pair(\"baab\", 11), Pair(\"baba\", 7), Pair(\"babb\", 15),\n        Pair(\"bbaa\", 4), Pair(\"bbab\", 12), Pair(\"bbba\", 8), Pair(\"bbbb\", 16),\n      ],\n    )\n\n  size(dict) == 16\n}\n\n/// Construct a dictionary from a list of key-value pairs. Note that when a key is present\n/// multiple times, the first occurrence prevails.\n///\n/// ```aiken\n/// let pairs = [Pair(\"a\", 100), Pair(\"c\", 300), Pair(\"b\", 200)]\n///\n/// let result =\n///   dict.from_pairs(pairs)\n///     |> dict.to_pairs()\n///\n/// result == [Pair(\"a\", 100), Pair(\"b\", 200), Pair(\"c\", 300)]\n/// ```\npub fn from_pairs(self: Pairs<ByteArray, value>) -> Dict<key, value> {\n  Dict { inner: do_from_pairs(self) }\n}\n\nfn do_from_pairs(xs: Pairs<ByteArray, value>) -> Pairs<ByteArray, value> {\n  when xs is {\n    [] -> []\n    [Pair(k, v), ..rest] ->\n      do_insert_with(do_from_pairs(rest), k, v, strategy.keep_left())\n  }\n}\n\ntest from_list_1() {\n  from_pairs([]) == empty\n}\n\ntest from_list_2() {\n  from_pairs([Pair(foo, 42), Pair(bar, 14)]) == from_pairs(\n    [Pair(bar, 14), Pair(foo, 42)],\n  )\n}\n\ntest from_list_3() {\n  from_pairs([Pair(foo, 42), Pair(bar, 14)]) == fixture_1\n}\n\ntest from_list_4() {\n  from_pairs([Pair(foo, 42), Pair(bar, 14), Pair(foo, 1337)]) == fixture_1\n}\n\ntest bench_from_pairs() {\n  let dict =\n    from_pairs(\n      [\n        Pair(\"bbba\", 8), Pair(\"bbab\", 12), Pair(\"aabb\", 13), Pair(\"aaab\", 9),\n        Pair(\"bbbb\", 16), Pair(\"aaaa\", 1), Pair(\"aaba\", 5), Pair(\"abab\", 10),\n        Pair(\"baba\", 7), Pair(\"baab\", 11), Pair(\"abaa\", 2), Pair(\"baaa\", 3),\n        Pair(\"bbaa\", 4), Pair(\"babb\", 15), Pair(\"abbb\", 14), Pair(\"abba\", 6),\n      ],\n    )\n\n  size(dict) == 16\n}\n\n// ## Inspecting\n\n/// Finds a value in the dictionary, and returns the first key found to have that value.\n///\n/// ```aiken\n/// let result =\n///   dict.empty\n///     |> dict.insert(key: \"a\", value: 42)\n///     |> dict.insert(key: \"b\", value: 14)\n///     |> dict.insert(key: \"c\", value: 42)\n///     |> dict.find(42)\n///\n/// result == Some(\"a\")\n/// ```\npub fn find(self: Dict<key, value>, value v: value) -> Option<ByteArray> {\n  do_find(self.inner, v)\n}\n\nfn do_find(self: Pairs<ByteArray, value>, value v: value) -> Option<ByteArray> {\n  when self is {\n    [] -> None\n    [Pair(k2, v2), ..rest] ->\n      if v == v2 {\n        Some(k2)\n      } else {\n        do_find(rest, v)\n      }\n  }\n}\n\ntest find_1() {\n  find(empty, foo) == None\n}\n\ntest find_2() {\n  find(\n    empty\n      |> insert(foo, 14),\n    14,\n  ) == Some(foo)\n}\n\ntest find_3() {\n  find(\n    empty\n      |> insert(foo, 14),\n    42,\n  ) == None\n}\n\ntest find_4() {\n  find(\n    empty\n      |> insert(foo, 14)\n      |> insert(bar, 42)\n      |> insert(baz, 14),\n    14,\n  ) == Some(baz)\n}\n\n/// Get a value in the dict by its key.\n///\n/// ```aiken\n/// let result =\n///   dict.empty\n///     |> dict.insert(key: \"a\", value: \"Aiken\")\n///     |> dict.get(key: \"a\")\n///\n///  result == Some(\"Aiken\")\n/// ```\npub fn get(self: Dict<key, value>, key: ByteArray) -> Option<value> {\n  do_get(self.inner, key)\n}\n\nfn do_get(self: Pairs<ByteArray, value>, key k: ByteArray) -> Option<value> {\n  when self is {\n    [] -> None\n    [Pair(k2, v), ..rest] ->\n      if builtin.less_than_equals_bytearray(k, k2) {\n        if k == k2 {\n          Some(v)\n        } else {\n          None\n        }\n      } else {\n        do_get(rest, k)\n      }\n  }\n}\n\ntest get_1() {\n  get(empty, foo) == None\n}\n\ntest get_2() {\n  let m =\n    empty\n      |> insert(foo, \"Aiken\")\n      |> insert(bar, \"awesome\")\n  get(m, key: foo) == Some(\"Aiken\")\n}\n\ntest get_3() {\n  let m =\n    empty\n      |> insert(foo, \"Aiken\")\n      |> insert(bar, \"awesome\")\n  get(m, key: baz) == None\n}\n\ntest get_4() {\n  let m =\n    empty\n      |> insert(\"aaa\", \"1\")\n      |> insert(\"bbb\", \"2\")\n      |> insert(\"ccc\", \"3\")\n      |> insert(\"ddd\", \"4\")\n      |> insert(\"eee\", \"5\")\n      |> insert(\"fff\", \"6\")\n      |> insert(\"ggg\", \"7\")\n      |> insert(\"hhh\", \"8\")\n      |> insert(\"iii\", \"9\")\n      |> insert(\"jjj\", \"10\")\n\n  get(m, \"bcd\") == None\n}\n\ntest get_5() {\n  let m =\n    empty\n      |> insert(\"aaa\", \"1\")\n      |> insert(\"bbb\", \"2\")\n      |> insert(\"ccc\", \"3\")\n      |> insert(\"ddd\", \"4\")\n      |> insert(\"eee\", \"5\")\n      |> insert(\"fff\", \"6\")\n      |> insert(\"ggg\", \"7\")\n      |> insert(\"hhh\", \"8\")\n      |> insert(\"iii\", \"9\")\n      |> insert(\"jjj\", \"10\")\n\n  get(m, \"kkk\") == None\n}\n\n/// Check if a key exists in the dictionary.\n///\n/// ```aiken\n/// let result =\n///   dict.empty\n///     |> dict.insert(key: \"a\", value: \"Aiken\")\n///     |> dict.has_key(\"a\")\n///\n/// result == True\n/// ```\npub fn has_key(self: Dict<key, value>, key k: ByteArray) -> Bool {\n  do_has_key(self.inner, k)\n}\n\nfn do_has_key(self: Pairs<ByteArray, value>, key k: ByteArray) -> Bool {\n  when self is {\n    [] -> False\n    [Pair(k2, _), ..rest] ->\n      if builtin.less_than_equals_bytearray(k, k2) {\n        k == k2\n      } else {\n        do_has_key(rest, k)\n      }\n  }\n}\n\ntest has_key_1() {\n  !has_key(empty, foo)\n}\n\ntest has_key_2() {\n  has_key(\n    empty\n      |> insert(foo, 14),\n    foo,\n  )\n}\n\ntest has_key_3() {\n  !has_key(\n    empty\n      |> insert(foo, 14),\n    bar,\n  )\n}\n\ntest has_key_4() {\n  has_key(\n    empty\n      |> insert(foo, 14)\n      |> insert(bar, 42),\n    bar,\n  )\n}\n\n/// Efficiently checks whether a dictionary is empty.\n/// ```aiken\n/// dict.is_empty(dict.empty) == True\n/// ```\npub fn is_empty(self: Dict<key, value>) -> Bool {\n  when self.inner is {\n    [] -> True\n    _ -> False\n  }\n}\n\ntest is_empty_1() {\n  is_empty(empty)\n}\n\n/// Extract all the keys present in a given `Dict`.\n///\n/// ```aiken\n/// let result =\n///   dict.empty\n///     |> dict.insert(\"a\", 14)\n///     |> dict.insert(\"b\", 42)\n///     |> dict.insert(\"a\", 1337)\n///     |> dict.keys()\n///\n/// result == [\"a\", \"b\"]\n/// ```\npub fn keys(self: Dict<key, value>) -> List<ByteArray> {\n  do_keys(self.inner)\n}\n\nfn do_keys(self: Pairs<ByteArray, value>) -> List<ByteArray> {\n  when self is {\n    [] -> []\n    [Pair(k, _), ..rest] -> [k, ..do_keys(rest)]\n  }\n}\n\ntest keys_1() {\n  keys(empty) == []\n}\n\ntest keys_2() {\n  keys(\n    empty\n      |> insert(foo, 0)\n      |> insert(bar, 0),\n  ) == [bar, foo]\n}\n\n/// Return the number of key-value pairs in the dictionary.\n///\n/// ```aiken\n/// let result =\n///   dict.empty\n///     |> dict.insert(\"a\", 100)\n///     |> dict.insert(\"b\", 200)\n///     |> dict.insert(\"c\", 300)\n///     |> dict.size()\n///\n/// result == 3\n/// ```\npub fn size(self: Dict<key, value>) -> Int {\n  do_size(self.inner)\n}\n\nfn do_size(self: Pairs<key, value>) -> Int {\n  when self is {\n    [] -> 0\n    [_, ..rest] -> 1 + do_size(rest)\n  }\n}\n\ntest size_1() {\n  size(empty) == 0\n}\n\ntest size_2() {\n  size(\n    empty\n      |> insert(foo, 14),\n  ) == 1\n}\n\ntest size_3() {\n  size(\n    empty\n      |> insert(foo, 14)\n      |> insert(bar, 42),\n  ) == 2\n}\n\n/// Extract all the values present in a given `Dict`.\n///\n/// ```aiken\n/// let result =\n///   dict.empty\n///     |> dict.insert(\"a\", 14)\n///     |> dict.insert(\"b\", 42)\n///     |> dict.insert(\"c\", 1337)\n///     |> dict.values()\n///\n/// result == [14, 42, 1337]\n/// ```\npub fn values(self: Dict<key, value>) -> List<value> {\n  do_values(self.inner)\n}\n\nfn do_values(self: Pairs<key, value>) -> List<value> {\n  when self is {\n    [] -> []\n    [Pair(_, v), ..rest] -> [v, ..do_values(rest)]\n  }\n}\n\ntest values_1() {\n  values(empty) == []\n}\n\ntest values_2() {\n  values(\n    empty\n      |> insert(foo, 3)\n      |> insert(bar, 4),\n  ) == [4, 3]\n}\n\n// ## Modifying\n\n/// Remove a key-value pair from the dictionary. If the key is not found, no changes are made.\n///\n/// ```aiken\n/// let result =\n///   dict.empty\n///     |> dict.insert(key: \"a\", value: 100)\n///     |> dict.insert(key: \"b\", value: 200)\n///     |> dict.delete(key: \"a\")\n///     |> dict.to_pairs()\n///\n/// result == [Pair(\"b\", 200)]\n/// ```\npub fn delete(self: Dict<key, value>, key: ByteArray) -> Dict<key, value> {\n  Dict { inner: do_delete(self.inner, key) }\n}\n\nfn do_delete(\n  self: Pairs<ByteArray, value>,\n  key k: ByteArray,\n) -> Pairs<ByteArray, value> {\n  when self is {\n    [] -> []\n    [Pair(k2, v2), ..rest] ->\n      if builtin.less_than_equals_bytearray(k, k2) {\n        if k == k2 {\n          rest\n        } else {\n          self\n        }\n      } else {\n        [Pair(k2, v2), ..do_delete(rest, k)]\n      }\n  }\n}\n\ntest delete_1() {\n  delete(empty, foo) == empty\n}\n\ntest delete_2() {\n  let m =\n    empty\n      |> insert(foo, 14)\n  delete(m, foo) == empty\n}\n\ntest delete_3() {\n  let m =\n    empty\n      |> insert(foo, 14)\n  delete(m, bar) == m\n}\n\ntest delete_4() {\n  let m =\n    empty\n      |> insert(foo, 14)\n      |> insert(bar, 14)\n  !has_key(delete(m, foo), foo)\n}\n\ntest delete_5() {\n  let m =\n    empty\n      |> insert(foo, 14)\n      |> insert(bar, 14)\n  has_key(delete(m, bar), foo)\n}\n\ntest delete_6() {\n  let m =\n    empty\n      |> insert(\"aaa\", 1)\n      |> insert(\"bbb\", 2)\n      |> insert(\"ccc\", 3)\n      |> insert(\"ddd\", 4)\n      |> insert(\"eee\", 5)\n      |> insert(\"fff\", 6)\n      |> insert(\"ggg\", 7)\n      |> insert(\"hhh\", 8)\n      |> insert(\"iii\", 9)\n      |> insert(\"jjj\", 10)\n\n  delete(m, \"bcd\") == m\n}\n\n/// Keep only the key-value pairs that pass the given predicate.\n///\n/// ```aiken\n/// let result =\n///   dict.empty\n///     |> dict.insert(key: \"a\", value: 100)\n///     |> dict.insert(key: \"b\", value: 200)\n///     |> dict.insert(key: \"c\", value: 300)\n///     |> dict.filter(fn(k, _v) { k != \"a\" })\n///     |> dict.to_pairs()\n///\n/// result == [Pair(\"b\", 200), Pair(\"c\", 300)]\n/// ```\npub fn filter(\n  self: Dict<key, value>,\n  with: fn(ByteArray, value) -> Bool,\n) -> Dict<key, value> {\n  Dict { inner: do_filter(self.inner, with) }\n}\n\nfn do_filter(\n  self: Pairs<ByteArray, value>,\n  with: fn(ByteArray, value) -> Bool,\n) -> Pairs<ByteArray, value> {\n  when self is {\n    [] -> []\n    [Pair(k, v), ..rest] ->\n      if with(k, v) {\n        [Pair(k, v), ..do_filter(rest, with)]\n      } else {\n        do_filter(rest, with)\n      }\n  }\n}\n\ntest filter_1() {\n  filter(empty, fn(_, _) { True }) == empty\n}\n\ntest filter_2() {\n  let expected =\n    empty\n      |> insert(foo, 42)\n  filter(fixture_1, fn(_, v) { v > 14 }) == expected\n}\n\ntest filter_3() {\n  let expected =\n    empty\n      |> insert(bar, 14)\n  filter(fixture_1, fn(k, _) { k == bar }) == expected\n}\n\n/// Insert a value in the dictionary at a given key. If the key already exists, its value is **overridden**. If you need ways to combine keys together, use (`insert_with`)[#insert_with].\n///\n/// ```aiken\n/// let result =\n///   dict.empty\n///     |> dict.insert(key: \"a\", value: 1)\n///     |> dict.insert(key: \"b\", value: 2)\n///     |> dict.insert(key: \"a\", value: 3)\n///     |> dict.to_pairs()\n///\n/// result == [Pair(\"a\", 3), Pair(\"b\", 2)]\n/// ```\npub fn insert(\n  self: Dict<key, value>,\n  key k: ByteArray,\n  value v: value,\n) -> Dict<key, value> {\n  Dict { inner: do_insert(self.inner, k, v) }\n}\n\nfn do_insert(\n  self: Pairs<ByteArray, value>,\n  key k: ByteArray,\n  value v: value,\n) -> Pairs<ByteArray, value> {\n  when self is {\n    [] -> [Pair(k, v)]\n    [Pair(k2, v2), ..rest] ->\n      if builtin.less_than_bytearray(k, k2) {\n        [Pair(k, v), ..self]\n      } else {\n        if k == k2 {\n          [Pair(k, v), ..rest]\n        } else {\n          [Pair(k2, v2), ..do_insert(rest, k, v)]\n        }\n      }\n  }\n}\n\ntest insert_1() {\n  let m1 =\n    empty\n      |> insert(foo, 42)\n  let m2 =\n    empty\n      |> insert(foo, 14)\n  insert(m1, foo, 14) == m2\n}\n\ntest insert_2() {\n  let m1 =\n    empty\n      |> insert(foo, 42)\n  let m2 =\n    empty\n      |> insert(bar, 14)\n  insert(m1, bar, 14) == insert(m2, foo, 42)\n}\n\n/// Insert a value in the dictionary at a given key. When the key already exist, the provided\n/// merge function is called. The value existing in the dictionary is passed as the second argument\n/// to the merge function, and the new value is passed as the third argument.\n///\n/// ```aiken\n/// use aiken/collection/dict/union\n///\n/// let result =\n///   dict.empty\n///     |> dict.insert_with(key: \"a\", value: 1, with: strategy.sum())\n///     |> dict.insert_with(key: \"b\", value: 2, with: strategy.sum())\n///     |> dict.insert_with(key: \"a\", value: 3, with: strategy.sum())\n///     |> dict.to_pairs()\n///\n/// result == [Pair(\"a\", 4), Pair(\"b\", 2)]\n/// ```\npub fn insert_with(\n  self: Dict<key, value>,\n  key k: ByteArray,\n  value v: value,\n  with: UnionStrategy<ByteArray, value>,\n) -> Dict<key, value> {\n  Dict {\n    inner: do_insert_with(\n      self.inner,\n      k,\n      v,\n      fn(k, v1, v2, some, none) { with(k, v2, v1, some, none) },\n    ),\n  }\n}\n\ntest insert_with_1() {\n  let result =\n    empty\n      |> insert_with(key: \"foo\", value: 1, with: strategy.sum())\n      |> insert_with(key: \"bar\", value: 2, with: strategy.sum())\n      |> to_pairs()\n\n  result == [Pair(\"bar\", 2), Pair(\"foo\", 1)]\n}\n\ntest insert_with_2() {\n  let result =\n    empty\n      |> insert_with(key: \"foo\", value: 1, with: strategy.sum())\n      |> insert_with(key: \"bar\", value: 2, with: strategy.sum())\n      |> insert_with(key: \"foo\", value: 3, with: strategy.sum())\n      |> to_pairs()\n\n  result == [Pair(\"bar\", 2), Pair(\"foo\", 4)]\n}\n\ntest insert_with_3() {\n  let with =\n    fn(k, a, _b, keep, discard) {\n      if k == \"foo\" {\n        keep(a)\n      } else {\n        discard()\n      }\n    }\n\n  let result =\n    empty\n      |> insert_with(key: \"foo\", value: 1, with: with)\n      |> insert_with(key: \"bar\", value: 2, with: with)\n      |> insert_with(key: \"foo\", value: 3, with: with)\n      |> insert_with(key: \"bar\", value: 4, with: with)\n      |> to_pairs()\n\n  result == [Pair(\"foo\", 1)]\n}\n\n/// Apply a function to all key-value pairs in a Dict.\n///\n/// ```aiken\n/// let result =\n///   dict.empty\n///     |> dict.insert(\"a\", 100)\n///     |> dict.insert(\"b\", 200)\n///     |> dict.insert(\"c\", 300)\n///     |> dict.map(fn(_k, v) { v * 2 })\n///     |> dict.to_pairs()\n///\n///  result == [Pair(\"a\", 200), Pair(\"b\", 400), Pair(\"c\", 600)]\n/// ```\npub fn map(self: Dict<key, a>, with: fn(ByteArray, a) -> b) -> Dict<key, b> {\n  Dict { inner: do_map(self.inner, with) }\n}\n\nfn do_map(\n  self: Pairs<ByteArray, a>,\n  with: fn(ByteArray, a) -> b,\n) -> Pairs<ByteArray, b> {\n  when self is {\n    [] -> []\n    [Pair(k, v), ..rest] -> [Pair(k, with(k, v)), ..do_map(rest, with)]\n  }\n}\n\ntest map_1() {\n  let result =\n    fixture_1\n      |> map(with: fn(k, _) { k })\n  get(result, foo) == Some(foo)\n}\n\ntest map_2() {\n  let result =\n    fixture_1\n      |> map(with: fn(_, v) { v + 1 })\n  get(result, foo) == Some(43) && size(result) == size(fixture_1)\n}\n\n/// Remove a key-value pair from the dictionary and return its value. If the key is not found, no changes are made.\n///\n/// ```aiken\n/// let (value, _) =\n///   dict.empty\n///     |> dict.insert(key: \"a\", value: 100)\n///     |> dict.insert(key: \"b\", value: 200)\n///     |> dict.pop(key: \"a\")\n///\n/// result == 100\n/// ```\npub fn pop(\n  self: Dict<key, value>,\n  key: ByteArray,\n) -> (Option<value>, Dict<key, value>) {\n  do_pop(self.inner, key, fn(value, inner) { (value, Dict { inner }) })\n}\n\nfn do_pop(\n  self: Pairs<ByteArray, value>,\n  key k: ByteArray,\n  return: fn(Option<value>, Pairs<ByteArray, value>) -> result,\n) -> result {\n  when self is {\n    [] -> return(None, [])\n    [Pair(k2, v2), ..rest] ->\n      if builtin.less_than_equals_bytearray(k, k2) {\n        if k == k2 {\n          return(Some(v2), rest)\n        } else {\n          return(None, self)\n        }\n      } else {\n        do_pop(\n          rest,\n          k,\n          fn(value, inner) { return(value, [Pair(k2, v2), ..inner]) },\n        )\n      }\n  }\n}\n\ntest pop_1() {\n  pop(empty, foo) == (None, empty)\n}\n\ntest pop_2() {\n  let m =\n    empty\n      |> insert(foo, 14)\n  pop(m, foo) == (Some(14), empty)\n}\n\ntest pop_3() {\n  let m =\n    empty\n      |> insert(foo, 14)\n  pop(m, bar) == (None, m)\n}\n\ntest pop_4() {\n  let m =\n    empty\n      |> insert(foo, 14)\n      |> insert(bar, 14)\n  pop(m, foo) == (Some(14), empty |> insert(bar, 14))\n}\n\ntest pop_6() {\n  let m =\n    empty\n      |> insert(\"aaa\", 1)\n      |> insert(\"bbb\", 2)\n      |> insert(\"ccc\", 3)\n      |> insert(\"ddd\", 4)\n      |> insert(\"eee\", 5)\n      |> insert(\"fff\", 6)\n      |> insert(\"ggg\", 7)\n      |> insert(\"hhh\", 8)\n      |> insert(\"iii\", 9)\n      |> insert(\"jjj\", 10)\n\n  pop(m, \"bcd\") == (None, m)\n}\n\n// ## Combining\n\n/// Combine two dictionaries. If the same key exist in both the left and\n/// right dictionary, values from the left are preferred (i.e. left-biaised).\n///\n/// ```aiken\n/// let left_dict = dict.from_pairs([Pair(\"a\", 100), Pair(\"b\", 200)])\n/// let right_dict = dict.from_pairs([Pair(\"a\", 150), Pair(\"c\", 300)])\n///\n/// let result =\n///   dict.union(left_dict, right_dict) |> dict.to_pairs()\n///\n/// result == [Pair(\"a\", 100), Pair(\"b\", 200), Pair(\"c\", 300)]\n/// ```\npub fn union(\n  left: Dict<key, value>,\n  right: Dict<key, value>,\n) -> Dict<key, value> {\n  Dict { inner: do_union(left.inner, right.inner) }\n}\n\nfn do_union(\n  left: Pairs<ByteArray, value>,\n  right: Pairs<ByteArray, value>,\n) -> Pairs<ByteArray, value> {\n  when left is {\n    [] -> right\n    [Pair(k, v), ..rest] -> do_union(rest, do_insert(right, k, v))\n  }\n}\n\ntest union_1() {\n  union(fixture_1, empty) == fixture_1\n}\n\ntest union_2() {\n  union(empty, fixture_1) == fixture_1\n}\n\ntest union_3() {\n  let left =\n    empty\n      |> insert(foo, 14)\n  let right =\n    empty\n      |> insert(bar, 42)\n      |> insert(baz, 1337)\n  union(left, right) == from_pairs(\n    [Pair(foo, 14), Pair(baz, 1337), Pair(bar, 42)],\n  )\n}\n\ntest union_4() {\n  let left =\n    empty\n      |> insert(foo, 14)\n  let right =\n    empty\n      |> insert(bar, 42)\n      |> insert(foo, 1337)\n  union(left, right) == from_pairs([Pair(foo, 14), Pair(bar, 42)])\n}\n\n/// Like [`union`](#union) but allows specifying the behavior to adopt when a key is present\n/// in both dictionaries. The first value received correspond to the value in the left\n/// dictionnary, whereas the second argument corresponds to the value in the right dictionnary.\n///\n/// When passing `None`, the value is removed and not present in the union.\n///\n/// ```aiken\n/// let left_dict = dict.from_pairs([Pair(\"a\", 100), Pair(\"b\", 200)])\n/// let right_dict = dict.from_pairs([Pair(\"a\", 150), Pair(\"c\", 300)])\n///\n/// let result =\n///   dict.union_with(\n///     left_dict,\n///     right_dict,\n///     fn(_k, v1, v2) { Some(v1 + v2) },\n///   )\n///     |> dict.to_pairs()\n///\n/// result == [Pair(\"a\", 250), Pair(\"b\", 200), Pair(\"c\", 300)]\n/// ```\npub fn union_with(\n  left: Dict<key, value>,\n  right: Dict<key, value>,\n  with: UnionStrategy<ByteArray, value>,\n) -> Dict<key, value> {\n  Dict { inner: do_union_with(left.inner, right.inner, with) }\n}\n\nfn do_union_with(\n  left: Pairs<ByteArray, value>,\n  right: Pairs<ByteArray, value>,\n  with: UnionStrategy<ByteArray, value>,\n) -> Pairs<ByteArray, value> {\n  when left is {\n    [] -> right\n    [Pair(k, v), ..rest] ->\n      do_union_with(rest, do_insert_with(right, k, v, with), with)\n  }\n}\n\nfn do_insert_with(\n  self: Pairs<ByteArray, value>,\n  key k: ByteArray,\n  value v: value,\n  with: UnionStrategy<ByteArray, value>,\n) -> Pairs<ByteArray, value> {\n  when self is {\n    [] -> [Pair(k, v)]\n    [Pair(k2, v2), ..rest] ->\n      if builtin.less_than_bytearray(k, k2) {\n        [Pair(k, v), ..self]\n      } else {\n        if k == k2 {\n          with(\n            k,\n            v,\n            v2,\n            fn(combined) { [Pair(k, combined), ..rest] },\n            fn() { rest },\n          )\n        } else {\n          [Pair(k2, v2), ..do_insert_with(rest, k, v, with)]\n        }\n      }\n  }\n}\n\ntest union_with_1() {\n  let left =\n    empty\n      |> insert(foo, 14)\n\n  let right =\n    empty\n      |> insert(bar, 42)\n      |> insert(foo, 1337)\n\n  let result = union_with(left, right, with: strategy.sum())\n\n  result == from_pairs([Pair(foo, 1351), Pair(bar, 42)])\n}\n\n// ## Transforming\n\n/// Fold over the key-value pairs in a dictionary. The fold direction follows keys\n/// in ascending order and is done from left-to-right.\n///\n/// ```aiken\n/// let result =\n///   dict.empty\n///     |> dict.insert(key: \"a\", value: 100)\n///     |> dict.insert(key: \"b\", value: 200)\n///     |> dict.insert(key: \"c\", value: 300)\n///     |> dict.foldl(0, fn(_k, v, r) { v + r })\n///\n/// result == 600\n/// ```\npub fn foldl(\n  self: Dict<key, value>,\n  zero: result,\n  with: fn(ByteArray, value, result) -> result,\n) -> result {\n  do_foldl(self.inner, zero, with)\n}\n\nfn do_foldl(\n  self: Pairs<ByteArray, value>,\n  zero: result,\n  with: fn(ByteArray, value, result) -> result,\n) -> result {\n  when self is {\n    [] -> zero\n    [Pair(k, v), ..rest] -> do_foldl(rest, with(k, v, zero), with)\n  }\n}\n\ntest fold_1() {\n  foldl(empty, 14, fn(_, _, _) { 42 }) == 14\n}\n\ntest fold_2() {\n  foldl(fixture_1, zero: 0, with: fn(_, v, total) { v + total }) == 56\n}\n\n/// Fold over the key-value pairs in a dictionary. The fold direction follows keys\n/// in ascending order and is done from right-to-left.\n///\n/// ```aiken\n/// let result =\n///   dict.empty\n///     |> dict.insert(key: \"a\", value: 100)\n///     |> dict.insert(key: \"b\", value: 200)\n///     |> dict.insert(key: \"c\", value: 300)\n///     |> dict.foldr(0, fn(_k, v, r) { v + r })\n///\n/// result == 600\n/// ```\npub fn foldr(\n  self: Dict<key, value>,\n  zero: result,\n  with: fn(ByteArray, value, result) -> result,\n) -> result {\n  do_foldr(self.inner, zero, with)\n}\n\nfn do_foldr(\n  self: Pairs<ByteArray, value>,\n  zero: result,\n  with: fn(ByteArray, value, result) -> result,\n) -> result {\n  when self is {\n    [] -> zero\n    [Pair(k, v), ..rest] -> with(k, v, do_foldr(rest, zero, with))\n  }\n}\n\ntest foldr_1() {\n  foldr(empty, 14, fn(_, _, _) { 42 }) == 14\n}\n\ntest foldr_2() {\n  foldr(fixture_1, zero: 0, with: fn(_, v, total) { v + total }) == 56\n}\n\n/// Get the inner list holding the dictionary data.\n///\n/// ```aiken\n/// let result =\n///   dict.empty\n///     |> dict.insert(\"a\", 100)\n///     |> dict.insert(\"b\", 200)\n///     |> dict.insert(\"c\", 300)\n///     |> dict.to_pairs()\n///\n/// result == [Pair(\"a\", 100), Pair(\"b\", 200), Pair(\"c\", 300)]\n/// ```\npub fn to_pairs(self: Dict<key, value>) -> Pairs<ByteArray, value> {\n  self.inner\n}\n\ntest to_list_1() {\n  to_pairs(empty) == []\n}\n\ntest to_list_2() {\n  to_pairs(fixture_1) == [Pair(bar, 14), Pair(foo, 42)]\n}\n",
      "dependencies": ["aiken/builtin", "aiken/collection/dict/strategy"],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.collection.list",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/collection/list.ak",
      "name": "aiken.collection.list",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 1,
          "raw": "use aiken/builtin",
          "source": "stdlib"
        },
        {
          "module": "aiken/primitive/bytearray",
          "items": [],
          "line": 2,
          "raw": "use aiken/primitive/bytearray",
          "source": "stdlib"
        },
        {
          "module": "aiken/primitive/int",
          "items": [],
          "line": 3,
          "raw": "use aiken/primitive/int",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "push",
          "signature": "pub fn push(self: List<a>, elem: a) -> List<a> {",
          "documentation": "Add an element in front of the list. Sometimes useful when combined with\nother functions.\n\n```aiken\nlist.push([2, 3], 1) == [1, ..[2, 3]] == [1, 2, 3]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "elem",
              "type": "a",
              "optional": false
            }
          ],
          "returnType": "List<a>",
          "line": 13,
          "raw": "pub fn push(self: List<a>, elem: a) -> List<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn push(self: List<a>, elem: a) -> List<a> {\n  [elem, ..self]\n}",
          "tests": [
            "test push_1() {\n  push([], 0) == [0]\n}",
            "test push_2() {\n  push([2, 3], 1) == [1, 2, 3]\n}"
          ]
        },
        {
          "name": "range",
          "signature": "pub fn range(from: Int, to: Int) -> List<Int> {",
          "documentation": "Construct a list of a integer from a given range.\n\n```aiken\nlist.range(0, 3) == [0, 1, 2, 3]\nlist.range(-1, 1) == [-1, 0, 1]\n```",
          "parameters": [
            {
              "name": "from",
              "type": "Int",
              "optional": false
            },
            {
              "name": "to",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "List<Int>",
          "line": 31,
          "raw": "pub fn range(from: Int, to: Int) -> List<Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn range(from: Int, to: Int) -> List<Int> {\n  if from > to {\n    []\n  } else {\n    [from, ..range(from + 1, to)]\n  }\n}",
          "tests": [
            "test range_1() {\n  range(0, 3) == [0, 1, 2, 3]\n}",
            "test range_2() {\n  range(-1, 1) == [-1, 0, 1]\n}"
          ]
        },
        {
          "name": "repeat",
          "signature": "pub fn repeat(elem: a, n_times: Int) -> List<a> {",
          "documentation": "Construct a list filled with n copies of a value.\n\n```aiken\nlist.repeat(\"na\", 3) == [\"na\", \"na\", \"na\"]\n```",
          "parameters": [
            {
              "name": "elem",
              "type": "a",
              "optional": false
            },
            {
              "name": "n_times",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "List<a>",
          "line": 52,
          "raw": "pub fn repeat(elem: a, n_times: Int) -> List<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn repeat(elem: a, n_times: Int) -> List<a> {\n  if n_times <= 0 {\n    []\n  } else {\n    [elem, ..repeat(elem, n_times - 1)]\n  }\n}",
          "tests": [
            "test repeat_1() {\n  repeat(42, 0) == []\n}",
            "test repeat_2() {\n  repeat(14, 3) == [14, 14, 14]\n}"
          ]
        },
        {
          "name": "all",
          "signature": "pub fn all(self: List<a>, predicate: fn(a) -> Bool) -> Bool {",
          "documentation": "Determine if all elements of the list satisfy the given predicate.\n\nNote: an empty list always satisfies the predicate.\n\n```aiken\nlist.all([], fn(n) { n > 0 }) == True\nlist.all([1, 2, 3], fn(n) { n > 0 }) == True\nlist.all([1, 2, 3], fn(n) { n == 2 }) == False\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "predicate",
              "type": "fn(a",
              "optional": false
            }
          ],
          "returnType": "Bool) -> Bool",
          "line": 79,
          "raw": "pub fn all(self: List<a>, predicate: fn(a) -> Bool) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn all(self: List<a>, predicate: fn(a) -> Bool) -> Bool {\n  when self is {\n    [] -> True\n    [x, ..xs] -> predicate(x) && all(xs, predicate)\n  }\n}",
          "tests": [
            "test all_1() {\n  all([1, 2, 3], fn(n) { n > 0 }) == True\n}",
            "test all_2() {\n  all([1, 2, 3], fn(n) { n > 42 }) == False\n}",
            "test all_3() {\n  all([], fn(n) { n == 42 }) == True\n}"
          ]
        },
        {
          "name": "any",
          "signature": "pub fn any(self: List<a>, predicate: fn(a) -> Bool) -> Bool {",
          "documentation": "Determine if at least one element of the list satisfies the given predicate.\n\nNote: an empty list never satisfies the predicate.\n\n```aiken\nlist.any([], fn(n) { n > 2 }) == False\nlist.any([1, 2, 3], fn(n) { n > 0 }) == True\nlist.any([1, 2, 3], fn(n) { n == 2 }) == True\nlist.any([1, 2, 3], fn(n) { n < 0 }) == False\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "predicate",
              "type": "fn(a",
              "optional": false
            }
          ],
          "returnType": "Bool) -> Bool",
          "line": 108,
          "raw": "pub fn any(self: List<a>, predicate: fn(a) -> Bool) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn any(self: List<a>, predicate: fn(a) -> Bool) -> Bool {\n  when self is {\n    [] -> False\n    [x, ..xs] -> predicate(x) || any(xs, predicate)\n  }\n}",
          "tests": [
            "test any_1() {\n  any([1, 2, 3], fn(n) { n > 0 }) == True\n}",
            "test any_2() {\n  any([1, 2, 3], fn(n) { n > 42 }) == False\n}",
            "test any_3() {\n  any([], fn(n) { n == 42 }) == False\n}"
          ]
        },
        {
          "name": "at",
          "signature": "pub fn at(self: List<a>, index: Int) -> Option<a> {",
          "documentation": "Return Some(item) at the index or None if the index is out of range. The index is 0-based.\n\n```aiken\nlist.at([1, 2, 3], 1) == Some(2)\nlist.at([1, 2, 3], 42) == None\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "index",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Option<a>",
          "line": 133,
          "raw": "pub fn at(self: List<a>, index: Int) -> Option<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn at(self: List<a>, index: Int) -> Option<a> {\n  when self is {\n    [] -> None\n    [x, ..xs] ->\n      if index == 0 {\n        Some(x)\n      } else {\n        at(xs, index - 1)\n      }\n  }\n}",
          "tests": [
            "test at_1() {\n  at([1, 2, 3], -1) == None\n}",
            "test at_2() {\n  at([], 0) == None\n}",
            "test at_3() {\n  at([1, 2, 3], 3) == None\n}",
            "test at_4() {\n  at([1], 0) == Some(1)\n}",
            "test at_5() {\n  at([1, 2, 3], 2) == Some(3)\n}"
          ]
        },
        {
          "name": "count",
          "signature": "pub fn count(self: List<a>, predicate: fn(a) -> Bool) -> Int {",
          "documentation": "Count how many items in the list satisfy the given predicate.\n\n```aiken\nlist.count([], fn(a) { a > 2}) == 0\nlist.count([1, 2, 3], fn(a) { n > 0 }) == 3\nlist.count([1, 2, 3], fn(a) { n >= 2 }) == 2\nlist.count([1, 2, 3], fn(a) { n > 5 }) == 0\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "predicate",
              "type": "fn(a",
              "optional": false
            }
          ],
          "returnType": "Bool) -> Int",
          "line": 173,
          "raw": "pub fn count(self: List<a>, predicate: fn(a) -> Bool) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn count(self: List<a>, predicate: fn(a) -> Bool) -> Int {\n  foldr(\n    self,\n    0,\n    fn(item, total) {\n      if predicate(item) {\n        total + 1\n      } else {\n        total\n      }\n    },\n  )\n}",
          "tests": [
            "test count_empty() {\n  count([], fn(a) { a > 2 }) == 0\n}",
            "test count_all() {\n  count([1, 2, 3], fn(a) { a > 0 }) == 3\n}",
            "test count_some() {\n  count([1, 2, 3], fn(a) { a >= 2 }) == 2\n}",
            "test count_none() {\n  count([1, 2, 3], fn(a) { a > 5 }) == 0\n}"
          ]
        },
        {
          "name": "find",
          "signature": "pub fn find(self: List<a>, predicate: fn(a) -> Bool) -> Option<a> {",
          "documentation": "Find the first element satisfying the given predicate, if any.\n\n```aiken\nlist.find([1, 2, 3], fn(x) { x == 2 }) == Some(2)\nlist.find([4, 5, 6], fn(x) { x == 2 }) == None\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "predicate",
              "type": "fn(a",
              "optional": false
            }
          ],
          "returnType": "Bool) -> Option<a>",
          "line": 209,
          "raw": "pub fn find(self: List<a>, predicate: fn(a) -> Bool) -> Option<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn find(self: List<a>, predicate: fn(a) -> Bool) -> Option<a> {\n  when self is {\n    [] -> None\n    [x, ..xs] ->\n      if predicate(x) {\n        Some(x)\n      } else {\n        find(xs, predicate)\n      }\n  }\n}",
          "tests": [
            "test find_1() {\n  find([1, 2, 3], fn(x) { x == 1 }) == Some(1)\n}",
            "test find_2() {\n  find([1, 2, 3], fn(x) { x > 42 }) == None\n}",
            "test find_3() {\n  find([], fn(_) { True }) == None\n}"
          ]
        },
        {
          "name": "has",
          "signature": "pub fn has(self: List<a>, elem: a) -> Bool {",
          "documentation": "Figures out whether a list contain the given element.\n\n```aiken\nlist.has([1, 2, 3], 2) == True\nlist.has([1, 2, 3], 14) == False\nlist.has([], 14) == False\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "elem",
              "type": "a",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 240,
          "raw": "pub fn has(self: List<a>, elem: a) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn has(self: List<a>, elem: a) -> Bool {\n  when self is {\n    [] -> False\n    [x, ..xs] ->\n      if x == elem {\n        True\n      } else {\n        has(xs, elem)\n      }\n  }\n}",
          "tests": [
            "test has_1() {\n  has([1, 2, 3], 1) == True\n}",
            "test has_2() {\n  has([1, 2, 3], 14) == False\n}",
            "test has_3() {\n  has([], 14) == False\n}"
          ]
        },
        {
          "name": "head",
          "signature": "pub fn head(self: List<a>) -> Option<a> {",
          "documentation": "Get the first element of a list\n\n```aiken\nlist.head([1, 2, 3]) == Some(1)\nlist.head([]) == None\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            }
          ],
          "returnType": "Option<a>",
          "line": 270,
          "raw": "pub fn head(self: List<a>) -> Option<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn head(self: List<a>) -> Option<a> {\n  when self is {\n    [] -> None\n    _ -> Some(builtin.head_list(self))\n  }\n}",
          "tests": [
            "test head_1() {\n  head([1, 2, 3]) == Some(1)\n}",
            "test head_2() {\n  head([]) == None\n}"
          ]
        },
        {
          "name": "is_empty",
          "signature": "pub fn is_empty(self: List<a>) -> Bool {",
          "documentation": "Checks whether a list is empty.\n\n```aiken\nlist.is_empty([]) == True\nlist.is_empty([1, 2, 3]) == False\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 291,
          "raw": "pub fn is_empty(self: List<a>) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn is_empty(self: List<a>) -> Bool {\n  when self is {\n    [] -> True\n    _ -> False\n  }\n}",
          "tests": [
            "test is_empty_1() {\n  is_empty([]) == True\n}",
            "test is_empty_2() {\n  is_empty([1, 2, 3]) == False\n}"
          ]
        },
        {
          "name": "index_of",
          "signature": "pub fn index_of(self: List<a>, elem: a) -> Option<Int> {",
          "documentation": "Gets the index of an element of a list, if any. Otherwise, returns None.\n\n```aiken\nlist.index_of([1, 5, 2], 2) == Some(2)\nlist.index_of([1, 7, 3], 4) == None\nlist.index_of([1, 0, 9, 6], 6) == 3\nlist.index_of([], 6) == None\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "elem",
              "type": "a",
              "optional": false
            }
          ],
          "returnType": "Option<Int>",
          "line": 314,
          "raw": "pub fn index_of(self: List<a>, elem: a) -> Option<Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn index_of(self: List<a>, elem: a) -> Option<Int> {\n  do_index_of(self, elem, 0)\n}"
        },
        {
          "name": "last",
          "signature": "pub fn last(self: List<a>) -> Option<a> {",
          "documentation": "Get the last in the given list, if any.\n\n```aiken\nlist.last([]) == None\nlist.last([1, 2, 3]) == Some(3)\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            }
          ],
          "returnType": "Option<a>",
          "line": 352,
          "raw": "pub fn last(self: List<a>) -> Option<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn last(self: List<a>) -> Option<a> {\n  when self is {\n    [] -> None\n    [x] -> Some(x)\n    [_, ..xs] -> last(xs)\n  }\n}",
          "tests": [
            "test last_1() {\n  last([]) == None\n}",
            "test last_2() {\n  last([1]) == Some(1)\n}",
            "test last_3() {\n  last([1, 2, 3, 4]) == Some(4)\n}"
          ]
        },
        {
          "name": "length",
          "signature": "pub fn length(self: List<a>) -> Int {",
          "documentation": "Get the number of elements in the given list.\n\n```aiken\nlist.length([]) == 0\nlist.length([1, 2, 3]) == 3\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 378,
          "raw": "pub fn length(self: List<a>) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn length(self: List<a>) -> Int {\n  when self is {\n    [] -> 0\n    [_, ..xs] -> 1 + length(xs)\n  }\n}",
          "tests": [
            "test length_1() {\n  length([]) == 0\n}",
            "test length_2() {\n  length([1, 2, 3]) == 3\n}"
          ]
        },
        {
          "name": "delete",
          "signature": "pub fn delete(self: List<a>, elem: a) -> List<a> {",
          "documentation": "Remove the first occurrence of the given element from the list.\n\n```aiken\nlist.delete([1, 2, 3, 1], 1) == [2, 3, 1]\nlist.delete([1, 2, 3], 14) == [1, 2, 3]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "elem",
              "type": "a",
              "optional": false
            }
          ],
          "returnType": "List<a>",
          "line": 403,
          "raw": "pub fn delete(self: List<a>, elem: a) -> List<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn delete(self: List<a>, elem: a) -> List<a> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      if x == elem {\n        xs\n      } else {\n        [x, ..delete(xs, elem)]\n      }\n  }\n}",
          "tests": [
            "test delete_1() {\n  delete([], 42) == []\n}",
            "test delete_2() {\n  delete([1, 2, 3, 1], 1) == [2, 3, 1]\n}",
            "test delete_3() {\n  delete([1, 2, 3], 14) == [1, 2, 3]\n}",
            "test delete_4() {\n  delete([2], 2) == []\n}"
          ]
        },
        {
          "name": "drop",
          "signature": "pub fn drop(self: List<a>, n: Int) -> List<a> {",
          "documentation": "Drop the first `n` elements of a list.\n\n```aiken\nlist.drop([1, 2, 3], 2) == [3]\nlist.drop([], 42) == []\nlist.drop([1, 2, 3], 42) == []\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "n",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "List<a>",
          "line": 438,
          "raw": "pub fn drop(self: List<a>, n: Int) -> List<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn drop(self: List<a>, n: Int) -> List<a> {\n  if n <= 0 {\n    self\n  } else {\n    when self is {\n      [] -> []\n      [_x, ..xs] -> drop(xs, n - 1)\n    }\n  }\n}",
          "tests": [
            "test drop_1() {\n  drop([], 42) == []\n}",
            "test drop_2() {\n  drop([1, 2, 3], 2) == [3]\n}"
          ]
        },
        {
          "name": "drop_while",
          "signature": "pub fn drop_while(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {",
          "documentation": "Returns the suffix of the given list after removing all elements that satisfy the predicate.\n\n```aiken\nlist.drop_while([1, 2, 3], fn(x) { x < 2 }) == [2, 3]\nlist.drop_while([], fn(x) { x > 2 }) == []\nlist.drop_while([1, 2, 3], fn(x) { x == 3 }) == [1, 2, 3]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "predicate",
              "type": "fn(a",
              "optional": false
            }
          ],
          "returnType": "Bool) -> List<a>",
          "line": 464,
          "raw": "pub fn drop_while(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn drop_while(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      if predicate(x) {\n        drop_while(xs, predicate)\n      } else {\n        self\n      }\n  }\n}",
          "tests": [
            "test drop_while_1() {\n  drop_while([], fn(x) { x > 2 }) == []\n}",
            "test drop_while_2() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  drop_while(xs, fn(x) { x > 5 }) == [5, 4, 3, 2, 1]\n}",
            "test drop_while_3() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  drop_while(xs, fn(x) { x == 42 }) == xs\n}",
            "test drop_while_4() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  drop_while(xs, fn(x) { x < 42 }) == []\n}"
          ]
        },
        {
          "name": "filter",
          "signature": "pub fn filter(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {",
          "documentation": "Produce a list of elements that satisfy a predicate.\n\n```aiken\nlist.filter([1, 2, 3], fn(x) { x >= 2 }) == [2, 3]\nlist.filter([], fn(x) { x > 2 }) == []\nlist.filter([1, 2, 3], fn(x) { x == 3 }) == [3]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "predicate",
              "type": "fn(a",
              "optional": false
            }
          ],
          "returnType": "Bool) -> List<a>",
          "line": 502,
          "raw": "pub fn filter(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn filter(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      if predicate(x) {\n        [x, ..filter(xs, predicate)]\n      } else {\n        filter(xs, predicate)\n      }\n  }\n}",
          "tests": [
            "test filter_1() {\n  filter([], fn(x) { x > 0 }) == []\n}",
            "test filter_2() {\n  let xs = [1, 2, 3, 4, 5, 6]\n  filter(xs, fn(x) { builtin.mod_integer(x, 2) == 0 }) == [2, 4, 6]\n}",
            "test filter_3() {\n  let filter_foldr =\n    fn(xs, f) {\n      foldr(\n        xs,\n        [],\n        fn(x, ys) {\n          if f(x) {\n            [x, ..ys]\n          } else {\n            ys\n          }\n        },\n      )\n    }\n\n  let is_odd =\n    fn(n) { builtin.mod_integer(n, 2) != 0 }\n\n  filter_foldr([1, 2, 3], is_odd) == filter([1, 2, 3], is_odd)\n}"
          ]
        },
        {
          "name": "filter_map",
          "signature": "pub fn filter_map(self: List<a>, predicate: fn(a) -> Option<b>) -> List<b> {",
          "documentation": "Produce a list of transformed elements that satisfy a predicate.\n\n```aiken\nlet transform = fn(x) { if x % 2 == 0 { None } else { Some(3*x) } }\nlist.filter_map([1, 2, 3], transform) == [3, 9]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "predicate",
              "type": "fn(a",
              "optional": false
            }
          ],
          "returnType": "Option<b>) -> List<b>",
          "line": 551,
          "raw": "pub fn filter_map(self: List<a>, predicate: fn(a) -> Option<b>) -> List<b> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn filter_map(self: List<a>, predicate: fn(a) -> Option<b>) -> List<b> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      when predicate(x) is {\n        None -> filter_map(xs, predicate)\n        Some(y) -> [y, ..filter_map(xs, predicate)]\n      }\n  }\n}",
          "tests": [
            "test filter_map_1() {\n  filter_map([], fn(_) { Some(42) }) == []\n}",
            "test filter_map_2() {\n  filter_map(\n    [1, 2, 3, 4, 5, 6],\n    fn(x) {\n      if builtin.mod_integer(x, 2) != 0 {\n        Some(3 * x)\n      } else {\n        None\n      }\n    },\n  ) == [3, 9, 15]\n}"
          ]
        },
        {
          "name": "init",
          "signature": "pub fn init(self: List<a>) -> Option<List<a>> {",
          "documentation": "Return all elements except the last one.\n\n```aiken\nlist.init([]) == None\nlist.init([1, 2, 3]) == Some([1, 2])\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            }
          ],
          "returnType": "Option<List<a>>",
          "line": 585,
          "raw": "pub fn init(self: List<a>) -> Option<List<a>> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn init(self: List<a>) -> Option<List<a>> {\n  when self is {\n    [] -> None\n    _ -> Some(do_init(self))\n  }\n}"
        },
        {
          "name": "partition",
          "signature": "pub fn partition(self: List<a>, predicate: fn(a) -> Bool) -> (List<a>, List<a>) {",
          "documentation": "Returns a tuple with all elements that satisfy the predicate at first\nelement, and the rest as second element.\n\n```aiken\nlist.partition([1, 2, 3, 4], fn(x) { x % 2 == 0 }) == ([2, 4], [1, 3])\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "predicate",
              "type": "fn(a",
              "optional": false
            }
          ],
          "returnType": "Bool) -> (List<a>, List<a>)",
          "line": 618,
          "raw": "pub fn partition(self: List<a>, predicate: fn(a) -> Bool) -> (List<a>, List<a>) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn partition(self: List<a>, predicate: fn(a) -> Bool) -> (List<a>, List<a>) {\n  when self is {\n    [] -> ([], [])\n    [x, ..xs] -> {\n      let (left, right) = partition(xs, predicate)\n      if predicate(x) {\n        ([x, ..left], right)\n      } else {\n        (left, [x, ..right])\n      }\n    }\n  }\n}",
          "tests": [
            "test partition_1() {\n  partition([], fn(x) { x > 2 }) == ([], [])\n}",
            "test partition_2() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  partition(xs, fn(x) { x > 5 }) == ([10, 9, 8, 7, 6], [5, 4, 3, 2, 1])\n}",
            "test partition_3() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  partition(xs, fn(x) { x == 42 }) == ([], xs)\n}",
            "test partition_4() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  partition(xs, fn(x) { x < 42 }) == (xs, [])\n}",
            "test partition_5() {\n  partition([1, 2, 3, 4], fn(x) { x % 2 == 0 }) == ([2, 4], [1, 3])\n}"
          ]
        },
        {
          "name": "slice",
          "signature": "pub fn slice(self: List<a>, from: Int, to: Int) -> List<a> {",
          "documentation": "Extract a sublist from the given list using 0-based indexes. Negative\nindexes wrap over, so `-1` refers to the last element of the list.\n\n```aiken\nlist.slice([1, 2, 3, 4, 5, 6], from: 2, to: 4) == [3, 4, 5]\nlist.slice([1, 2, 3, 4, 5, 6], from: -2, to: -1) == [5, 6]\nlist.slice([1, 2, 3, 4, 5, 6], from: 1, to: -1) == [2, 3, 4, 5, 6]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "from",
              "type": "Int",
              "optional": false
            },
            {
              "name": "to",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "List<a>",
          "line": 663,
          "raw": "pub fn slice(self: List<a>, from: Int, to: Int) -> List<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn slice(self: List<a>, from: Int, to: Int) -> List<a> {\n  let (i, l) =\n    if from >= 0 {\n      (from, None)\n    } else {\n      let l = length(self)\n      (l + from, Some(l))\n    }\n\n  let j =\n    if to >= 0 {\n      to - i + 1\n    } else {\n      when l is {\n        Some(l) -> l + to - i + 1\n        None -> length(self) + to - i + 1\n      }\n    }\n\n  self\n    |> drop(i)\n    |> take(j)\n}",
          "tests": [
            "test slice_1() {\n  slice([1, 2, 3], 0, 2) == [1, 2, 3]\n}",
            "test slice_2() {\n  slice([1, 2, 3, 4, 5, 6], from: 2, to: 4) == [3, 4, 5]\n}",
            "test slice_3() {\n  slice([1, 2, 3, 4, 5, 6], from: -2, to: -1) == [5, 6]\n}",
            "test slice_4() {\n  slice([1, 2, 3, 4, 5, 6], from: 1, to: -1) == [2, 3, 4, 5, 6]\n}",
            "test slice_5() {\n  slice([1, 2, 3, 4, 5, 6], from: -4, to: -3) == [3, 4]\n}",
            "test slice_6() {\n  slice([1, 2, 3, 4, 5, 6], from: -2, to: 1) == []\n}"
          ]
        },
        {
          "name": "span",
          "signature": "pub fn span(self: List<a>, n: Int) -> (List<a>, List<a>) {",
          "documentation": "Cut a list in two, such that the first list contains the given number of /\nelements and the second list contains the rest.\n\nFundamentally equivalent to (but more efficient):\n\n```aiken\n// span(xs, n) == (take(xs, n), drop(xs, n))\nspan([1, 2, 3, 4, 5], 3) == ([1, 2, 3], [4, 5])\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "n",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "(List<a>, List<a>)",
          "line": 720,
          "raw": "pub fn span(self: List<a>, n: Int) -> (List<a>, List<a>) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn span(self: List<a>, n: Int) -> (List<a>, List<a>) {\n  when self is {\n    [] -> ([], [])\n    [x, ..xs] ->\n      if n <= 0 {\n        ([], self)\n      } else {\n        let (left, right) = span(xs, n - 1)\n        ([x, ..left], right)\n      }\n  }\n}",
          "tests": [
            "test span_1() {\n  span([], 2) == ([], [])\n}",
            "test span_2() {\n  span([1, 2, 3], 2) == ([1, 2], [3])\n}",
            "test span_3() {\n  span([1, 2, 3], -1) == ([], [1, 2, 3])\n}",
            "test span_4() {\n  span([1, 2, 3], 42) == ([1, 2, 3], [])\n}"
          ]
        },
        {
          "name": "tail",
          "signature": "pub fn tail(self: List<a>) -> Option<List<a>> {",
          "documentation": "Get elements of a list after the first one, if any.\n\n```aiken\nlist.tail([]) == None\nlist.tail([1, 2, 3]) == Some([2, 3])\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            }
          ],
          "returnType": "Option<List<a>>",
          "line": 755,
          "raw": "pub fn tail(self: List<a>) -> Option<List<a>> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn tail(self: List<a>) -> Option<List<a>> {\n  when self is {\n    [] -> None\n    [_, ..xs] -> Some(xs)\n  }\n}",
          "tests": [
            "test tail_1() {\n  tail([1, 2, 3]) == Some([2, 3])\n}",
            "test tail_2() {\n  tail([]) == None\n}"
          ]
        },
        {
          "name": "take",
          "signature": "pub fn take(self: List<a>, n: Int) -> List<a> {",
          "documentation": "Get the first `n` elements of a list.\n\n```aiken\nlist.take([1, 2, 3], 2) == [1, 2]\nlist.take([1, 2, 3], 14) == [1, 2, 3]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "n",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "List<a>",
          "line": 776,
          "raw": "pub fn take(self: List<a>, n: Int) -> List<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn take(self: List<a>, n: Int) -> List<a> {\n  if n <= 0 {\n    []\n  } else {\n    when self is {\n      [] -> []\n      [x, ..xs] -> [x, ..take(xs, n - 1)]\n    }\n  }\n}",
          "tests": [
            "test take_1() {\n  take([], 42) == []\n}",
            "test take_2() {\n  take([1, 2, 3], 2) == [1, 2]\n}"
          ]
        },
        {
          "name": "take_while",
          "signature": "pub fn take_while(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {",
          "documentation": "Returns the longest prefix of the given list where all elements satisfy the predicate.\n\n```aiken\nlist.take_while([1, 2, 3], fn(x) { x > 2 }) == []\nlist.take_while([1, 2, 3], fn(x) { x < 2 }) == [1]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "predicate",
              "type": "fn(a",
              "optional": false
            }
          ],
          "returnType": "Bool) -> List<a>",
          "line": 801,
          "raw": "pub fn take_while(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn take_while(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      if predicate(x) {\n        [x, ..take_while(xs, predicate)]\n      } else {\n        []\n      }\n  }\n}",
          "tests": [
            "test take_while_1() {\n  take_while([], fn(x) { x > 2 }) == []\n}",
            "test take_while_2() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  take_while(xs, fn(x) { x > 5 }) == [10, 9, 8, 7, 6]\n}",
            "test take_while_3() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  take_while(xs, fn(x) { x == 42 }) == []\n}",
            "test take_while_4() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  take_while(xs, fn(x) { x < 42 }) == xs\n}"
          ]
        },
        {
          "name": "unique",
          "signature": "pub fn unique(self: List<a>) -> List<a> {",
          "documentation": "Removes duplicate elements from a list.\n\n```aiken\nlist.unique([1, 2, 3, 1]) == [1, 2, 3]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            }
          ],
          "returnType": "List<a>",
          "line": 837,
          "raw": "pub fn unique(self: List<a>) -> List<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn unique(self: List<a>) -> List<a> {\n  when self is {\n    [] -> []\n    [x, ..xs] -> [x, ..unique(filter(xs, fn(y) { y != x }))]\n  }\n}",
          "tests": [
            "test unique_1() {\n  unique([]) == []\n}",
            "test unique_2() {\n  let xs = [1, 2, 3, 1, 1, 3, 4, 1, 2, 3, 2, 4, 5, 6, 7, 8, 9, 10, 9]\n  unique(xs) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n}"
          ]
        },
        {
          "name": "flat_map",
          "signature": "pub fn flat_map(self: List<a>, with: fn(a) -> List<b>) -> List<b> {",
          "documentation": "Map elements of a list into a new list and flatten the result.\n\n```aiken\nlist.flat_map([1, 2, 3], fn(a) { [a, 2*a] }) == [1, 2, 2, 4, 3, 6]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "with",
              "type": "fn(a",
              "optional": false
            }
          ],
          "returnType": "List<b>) -> List<b>",
          "line": 860,
          "raw": "pub fn flat_map(self: List<a>, with: fn(a) -> List<b>) -> List<b> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn flat_map(self: List<a>, with: fn(a) -> List<b>) -> List<b> {\n  foldr(self, [], fn(x, xs) { concat(with(x), xs) })\n}",
          "tests": [
            "test flat_map_1() {\n  flat_map([], fn(a) { [a] }) == []\n}",
            "test flat_map_2() {\n  flat_map([1, 2, 3], fn(a) { [a, a] }) == [1, 1, 2, 2, 3, 3]\n}"
          ]
        },
        {
          "name": "for_each",
          "signature": "pub fn for_each(self: List<a>, do: fn(a) -> Void) -> Void {",
          "documentation": "Perform an action for each element of a list.\n\n```aiken\nlist.for_each(labels, do: fn(lbl) { trace lbl Void })\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "do",
              "type": "fn(a",
              "optional": false
            }
          ],
          "returnType": "Void) -> Void",
          "line": 877,
          "raw": "pub fn for_each(self: List<a>, do: fn(a) -> Void) -> Void {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn for_each(self: List<a>, do: fn(a) -> Void) -> Void {\n  foldr(self, Void, fn(x, _) { do(x) })\n}",
          "tests": [
            "test for_each_1() {\n  for_each(\n    [@\"hello\", @\"world\"],\n    do: fn(lbl) {\n      trace lbl\n      Void\n    },\n  )\n}"
          ]
        },
        {
          "name": "indexed_map",
          "signature": "pub fn indexed_map(self: List<a>, with: fn(Int, a) -> result) -> List<result> {",
          "documentation": "List [`map`](#map) but provides the position (0-based) of the elements while iterating.\n\n```aiken\nlist.indexed_map([1, 2, 3], fn(i, x) { i + x }) == [1, 3, 5]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "with",
              "type": "fn(Int, a",
              "optional": false
            }
          ],
          "returnType": "result) -> List<result>",
          "line": 896,
          "raw": "pub fn indexed_map(self: List<a>, with: fn(Int, a) -> result) -> List<result> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn indexed_map(self: List<a>, with: fn(Int, a) -> result) -> List<result> {\n  do_indexed_map(0, self, with)\n}"
        },
        {
          "name": "map",
          "signature": "pub fn map(self: List<a>, with: fn(a) -> result) -> List<result> {",
          "documentation": "Apply a function to each element of a list.\n\n```aiken\nlist.map([1, 2, 3, 4], fn(n) { n + 1 }) == [2, 3, 4, 5]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "with",
              "type": "fn(a",
              "optional": false
            }
          ],
          "returnType": "result) -> List<result>",
          "line": 933,
          "raw": "pub fn map(self: List<a>, with: fn(a) -> result) -> List<result> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn map(self: List<a>, with: fn(a) -> result) -> List<result> {\n  when self is {\n    [] -> []\n    [x, ..xs] -> [with(x), ..map(xs, with)]\n  }\n}",
          "tests": [
            "test map_1() {\n  map([], fn(n) { n + 1 }) == []\n}",
            "test map_2() {\n  map([1, 2, 3, 4], fn(n) { n + 1 }) == [2, 3, 4, 5]\n}"
          ]
        },
        {
          "name": "map2",
          "signature": "pub fn map2(pub fn map2(self: List<a>, bs: List<b>, with: fn(a, b) -> result,",
          "documentation": "Apply a function of two arguments, combining elements from two lists.\n\nNote: if one list is longer, the extra elements are dropped.\n\n```aiken\nlist.map2([1, 2, 3], [1, 2], fn(a, b) { a + b }) == [2, 4]\n```",
          "parameters": [],
          "returnType": "result,",
          "line": 955,
          "raw": "pub fn map2(pub fn map2(self: List<a>, bs: List<b>, with: fn(a, b) -> result,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn map2(\n  self: List<a>,\n  bs: List<b>,\n  with: fn(a, b) -> result,\n) -> List<result> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      when bs is {\n        [] -> []\n        [y, ..ys] -> [with(x, y), ..map2(xs, ys, with)]\n      }\n  }\n}",
          "tests": [
            "test map2_1() {\n  map2([], [1, 2, 3], fn(a, b) { a + b }) == []\n}",
            "test map2_2() {\n  map2([1, 2, 3], [1, 2], fn(a, b) { a + b }) == [2, 4]\n}",
            "test map2_3() {\n  map2([42], [1, 2, 3], fn(_a, b) { Some(b) }) == [Some(1)]\n}"
          ]
        },
        {
          "name": "map3",
          "signature": "pub fn map3(pub fn map3(self: List<a>, bs: List<b>, cs: List<c>, with: fn(a, b, c) -> result,",
          "documentation": "Apply a function of three arguments, combining elements from three lists.\n\nNote: if one list is longer, the extra elements are dropped.\n\n```aiken\nlist.map3([1, 2, 3], [1, 2], [1, 2, 3], fn(a, b, c) { a + b + c }) == [3, 6]\n```",
          "parameters": [],
          "returnType": "result,",
          "line": 989,
          "raw": "pub fn map3(pub fn map3(self: List<a>, bs: List<b>, cs: List<c>, with: fn(a, b, c) -> result,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn map3(\n  self: List<a>,\n  bs: List<b>,\n  cs: List<c>,\n  with: fn(a, b, c) -> result,\n) -> List<result> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      when bs is {\n        [] -> []\n        [y, ..ys] ->\n          when cs is {\n            [] -> []\n            [z, ..zs] -> [with(x, y, z), ..map3(xs, ys, zs, with)]\n          }\n      }\n  }\n}",
          "tests": [
            "test map3_1() {\n  map3([], [], [1, 2, 3], fn(a, b, c) { a + b + c }) == []\n}",
            "test map3_2() {\n  map3([1, 2, 3], [1, 2], [1, 2, 3], fn(a, b, c) { a + b + c }) == [3, 6]\n}"
          ]
        },
        {
          "name": "reverse",
          "signature": "pub fn reverse(self: List<a>) -> List<a> {",
          "documentation": "Return the list with its elements in the reserve order.\n\n```aiken\nlist.reverse([1, 2, 3]) == [3, 2, 1]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            }
          ],
          "returnType": "List<a>",
          "line": 1022,
          "raw": "pub fn reverse(self: List<a>) -> List<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn reverse(self: List<a>) -> List<a> {\n  foldl(self, [], fn(x, xs) { [x, ..xs] })\n}",
          "tests": [
            "test reverse_1() {\n  reverse([]) == []\n}",
            "test reverse_2() {\n  reverse([1, 2, 3]) == [3, 2, 1]\n}"
          ]
        },
        {
          "name": "sort",
          "signature": "pub fn sort(self: List<a>, compare: fn(a, a) -> Ordering) -> List<a> {",
          "documentation": "Sort a list in ascending order using the given comparison function.\n\n```aiken\nuse aiken/int\n\nsort([3, 1, 4, 0, 2], int.compare) == [0, 1, 2, 3, 4]\nsort([1, 2, 3], int.compare) == [1, 2, 3]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "compare",
              "type": "fn(a, a",
              "optional": false
            }
          ],
          "returnType": "Ordering) -> List<a>",
          "line": 1042,
          "raw": "pub fn sort(self: List<a>, compare: fn(a, a) -> Ordering) -> List<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sort(self: List<a>, compare: fn(a, a) -> Ordering) -> List<a> {\n  when self is {\n    [] -> []\n    [x, ..xs] -> insert(sort(xs, compare), x, compare)\n  }\n}"
        },
        {
          "name": "unzip",
          "signature": "pub fn unzip(self: List<(a, b)>) -> (List<a>, List<b>) {",
          "documentation": "Decompose a list of tuples into a tuple of lists.\n\n```\nlist.unzip([(1, \"a\"), (2, \"b\")]) == ([1, 2], [\"a\", \"b\"])\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<(a, b",
              "optional": false
            }
          ],
          "returnType": "(List<a>, List<b>)",
          "line": 1085,
          "raw": "pub fn unzip(self: List<(a, b)>) -> (List<a>, List<b>) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn unzip(self: List<(a, b)>) -> (List<a>, List<b>) {\n  when self is {\n    [] -> ([], [])\n    [(a, b), ..xs] -> {\n      let (a_tail, b_tail) = unzip(xs)\n      ([a, ..a_tail], [b, ..b_tail])\n    }\n  }\n}",
          "tests": [
            "test unzip_1() {\n  unzip([]) == ([], [])\n}",
            "test unzip_2() {\n  unzip([(1, \"a\"), (2, \"b\")]) == ([1, 2], [\"a\", \"b\"])\n}"
          ]
        },
        {
          "name": "concat",
          "signature": "pub fn concat(left: List<a>, right: List<a>) -> List<a> {",
          "documentation": "Merge two lists together.\n\n```aiken\nlist.concat([], []) == []\nlist.concat([], [1, 2, 3]) == [1, 2, 3]\nlist.concat([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n```",
          "parameters": [
            {
              "name": "left",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "right",
              "type": "List<a>",
              "optional": false
            }
          ],
          "returnType": "List<a>",
          "line": 1112,
          "raw": "pub fn concat(left: List<a>, right: List<a>) -> List<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn concat(left: List<a>, right: List<a>) -> List<a> {\n  when left is {\n    [] -> right\n    [x, ..xs] -> [x, ..concat(xs, right)]\n  }\n}",
          "tests": [
            "test concat_1() {\n  concat([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n}",
            "test concat_2() {\n  concat([1, 2, 3], []) == [1, 2, 3]\n}",
            "test concat_3() {\n  concat([], [1, 2, 3]) == [1, 2, 3]\n}"
          ]
        },
        {
          "name": "difference",
          "signature": "pub fn difference(self: List<a>, with: List<a>) -> List<a> {",
          "documentation": "Remove the first occurrence of each element of the second list from the first one.\n\n```\nlist.difference([\"h\", \"e\", \"l\", \"l\", \"o\"], [\"l\", \"e\", \"l\"]) == [\"h\", \"o\"]\nlist.difference([1, 2, 3, 4, 5], [1, 1, 2]) == [3, 4, 5]\nlist.difference([1, 2, 3], []) == [1, 2, 3]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "with",
              "type": "List<a>",
              "optional": false
            }
          ],
          "returnType": "List<a>",
          "line": 1138,
          "raw": "pub fn difference(self: List<a>, with: List<a>) -> List<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn difference(self: List<a>, with: List<a>) -> List<a> {\n  when with is {\n    [] -> self\n    [x, ..xs] -> difference(delete(self, x), xs)\n  }\n}",
          "tests": [
            "test difference_1() {\n  difference([\"h\", \"e\", \"l\", \"l\", \"o\"], [\"l\", \"e\", \"l\"]) == [\"h\", \"o\"]\n}",
            "test difference_2() {\n  difference([1, 2, 3, 4, 5], [1, 1, 2]) == [3, 4, 5]\n}",
            "test difference_3() {\n  difference([1, 2, 3], []) == [1, 2, 3]\n}",
            "test difference_4() {\n  difference([], [1, 2, 3]) == []\n}"
          ]
        },
        {
          "name": "zip",
          "signature": "pub fn zip(self: List<a>, bs: List<b>) -> List<(a, b)> {",
          "documentation": "Combine two lists together.\n\nNote: if one list is longer, the extra elements are dropped.\n\n```aiken\nlist.zip([1, 2], [\"a\", \"b\", \"c\"]) == [(1, \"a\"), (2, \"b\")]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "bs",
              "type": "List<b>",
              "optional": false
            }
          ],
          "returnType": "List<(a, b)>",
          "line": 1168,
          "raw": "pub fn zip(self: List<a>, bs: List<b>) -> List<(a, b)> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn zip(self: List<a>, bs: List<b>) -> List<(a, b)> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      when bs is {\n        [] -> []\n        [y, ..ys] -> [(x, y), ..zip(xs, ys)]\n      }\n  }\n}",
          "tests": [
            "test zip_1() {\n  zip([], [1, 2, 3]) == []\n}",
            "test zip_2() {\n  zip([1, 2, 3], []) == []\n}",
            "test zip_3() {\n  zip([1, 2], [\"a\", \"b\", \"c\"]) == [(1, \"a\"), (2, \"b\")]\n}"
          ]
        },
        {
          "name": "foldl",
          "signature": "pub fn foldl(self: List<a>, zero: b, with: fn(a, b) -> b) -> b {",
          "documentation": "Reduce a list from left to right.\n\n```aiken\nlist.foldl([1, 2, 3], 0, fn(n, total) { n + total }) == 6\nlist.foldl([1, 2, 3], [], fn(x, xs) { [x, ..xs] }) == [3, 2, 1]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "zero",
              "type": "b",
              "optional": false
            },
            {
              "name": "with",
              "type": "fn(a, b",
              "optional": false
            }
          ],
          "returnType": "b) -> b",
          "line": 1199,
          "raw": "pub fn foldl(self: List<a>, zero: b, with: fn(a, b) -> b) -> b {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn foldl(self: List<a>, zero: b, with: fn(a, b) -> b) -> b {\n  when self is {\n    [] -> zero\n    [x, ..xs] -> foldl(xs, with(x, zero), with)\n  }\n}"
        },
        {
          "name": "foldl2",
          "signature": "pub fn foldl2(pub fn foldl2(self: List<elem>, zero_a: a, zero_b: b, with: fn(elem, a, b, Fold2<a, b, result>) -> result, return: Fold2<a, b, result>,",
          "documentation": "Reduce a list from left to right, while accumulating two results. This is\nfaster (albeit equivalent) than accumulating both results in a `Pair` or tuple.\n\n> [!TIP]\n> Using [`backpassing`](https://aiken-lang.org/language-tour/functions#backpassing-) to ease readability is a good idea.\n\n```aiken\nlet len, sum <-\nfoldl2(\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n0,\n0,\nfn(n, len, sum, return) { return(len + 1, sum + n) },\n)\n\nand {\nlen == 10,\nsum == 55,\n}\n```",
          "parameters": [],
          "returnType": "result, return: Fold2<a, b, result>,",
          "line": 1230,
          "raw": "pub fn foldl2(pub fn foldl2(self: List<elem>, zero_a: a, zero_b: b, with: fn(elem, a, b, Fold2<a, b, result>) -> result, return: Fold2<a, b, result>,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn foldl2(\n  self: List<elem>,\n  zero_a: a,\n  zero_b: b,\n  with: fn(elem, a, b, Fold2<a, b, result>) -> result,\n  return: Fold2<a, b, result>,\n) -> result {\n  when self is {\n    [] -> return(zero_a, zero_b)\n    [x, ..xs] -> {\n      let a, b <- with(x, zero_a, zero_b)\n      foldl2(xs, a, b, with, return)\n    }\n  }\n}",
          "tests": [
            "test foldl2_optimized() {\n  let\n    len,\n    sum,\n  <-\n    foldl2(\n      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n      0,\n      0,\n      fn(n, len, sum, return) { return(len + 1, sum + n) },\n    )\n\n  and {\n    len == 10,\n    sum == 55,\n  }\n}",
            "test foldl2_classic() {\n  let (len, sum) =\n    foldl(\n      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n      (0, 0),\n      fn(n, (len, sum)) { (len + 1, sum + n) },\n    )\n\n  and {\n    len == 10,\n    sum == 55,\n  }\n}",
            "test foldl2_pair() {\n  let Pair(len, sum) =\n    foldl(\n      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n      Pair(0, 0),\n      fn(n, Pair(len, sum)) { Pair(len + 1, sum + n) },\n    )\n\n  and {\n    len == 10,\n    sum == 55,\n  }\n}",
            "test foldl2_foo() {\n  let Foo(len, sum) =\n    foldl(\n      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n      Foo(0, 0),\n      fn(n, Foo(len, sum)) { Foo(len + 1, sum + n) },\n    )\n\n  and {\n    len == 10,\n    sum == 55,\n  }\n}"
          ]
        },
        {
          "name": "foldr",
          "signature": "pub fn foldr(self: List<a>, zero: b, with: fn(a, b) -> b) -> b {",
          "documentation": "Reduce a list from right to left.\n\n```aiken\nlist.foldr([1, 2, 3], 0, fn(n, total) { n + total }) == 6\nlist.foldr([1, 2, 3], [], fn(x, xs) { [x, ..xs] }) == [1, 2, 3]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "zero",
              "type": "b",
              "optional": false
            },
            {
              "name": "with",
              "type": "fn(a, b",
              "optional": false
            }
          ],
          "returnType": "b) -> b",
          "line": 1328,
          "raw": "pub fn foldr(self: List<a>, zero: b, with: fn(a, b) -> b) -> b {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn foldr(self: List<a>, zero: b, with: fn(a, b) -> b) -> b {\n  when self is {\n    [] -> zero\n    [x, ..xs] -> with(x, foldr(xs, zero, with))\n  }\n}",
          "tests": [
            "test foldr_1() {\n  foldr([1, 2, 3, 4, 5], 0, fn(n, total) { n + total }) == 15\n}",
            "test foldr_2() {\n  foldr(\n    [1, 2, 3],\n    \"\",\n    fn(n, _str) {\n      if builtin.mod_integer(n, 2) == 0 {\n        \"foo\"\n      } else {\n        \"bar\"\n      }\n    },\n  ) == \"bar\"\n}",
            "test foldr_3() {\n  foldr([1, 2, 3, 4], [], fn(x, xs) { [x, ..xs] }) == [1, 2, 3, 4]\n}"
          ]
        },
        {
          "name": "foldr2",
          "signature": "pub fn foldr2(pub fn foldr2(self: List<elem>, zero_a: a, zero_b: b, with: fn(elem, a, b, Fold2<a, b, result>) -> result, return: Fold2<a, b, result>,",
          "documentation": "Reduce a list from right to left, while accumulating two results. This is\nfaster (albeit equivalent) than accumulating both results in a `Pair` or tuple.\n\n> [!TIP]\n> Using [`backpassing`](https://aiken-lang.org/language-tour/functions#backpassing-) to ease readability is a good idea.\n\n```aiken\nlet len, sum <-\nfoldr2(\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n0,\n0,\nfn(n, len, sum, return) { return(len + 1, sum + n) },\n)\n\nand {\nlen == 10,\nsum == 55,\n}\n```",
          "parameters": [],
          "returnType": "result, return: Fold2<a, b, result>,",
          "line": 1377,
          "raw": "pub fn foldr2(pub fn foldr2(self: List<elem>, zero_a: a, zero_b: b, with: fn(elem, a, b, Fold2<a, b, result>) -> result, return: Fold2<a, b, result>,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn foldr2(\n  self: List<elem>,\n  zero_a: a,\n  zero_b: b,\n  with: fn(elem, a, b, Fold2<a, b, result>) -> result,\n  return: Fold2<a, b, result>,\n) -> result {\n  do_foldr2(self, with, return)(zero_a, zero_b)\n}"
        },
        {
          "name": "indexed_foldr",
          "signature": "pub fn indexed_foldr(pub fn indexed_foldr(self: List<a>, zero: result, with: fn(Int, a, result) -> result,",
          "documentation": "Like [`foldr`](#foldr), but also provides the position (0-based) of the elements when iterating.\n\n```aiken\nlet group = fn(i, x, xs) { [(i, x), ..xs] }\nlist.indexed_foldr([\"a\", \"b\", \"c\"], [], group) == [\n(0, \"a\"),\n(1, \"b\"),\n(2, \"c\")\n]\n```",
          "parameters": [],
          "returnType": "result,",
          "line": 1426,
          "raw": "pub fn indexed_foldr(pub fn indexed_foldr(self: List<a>, zero: result, with: fn(Int, a, result) -> result,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn indexed_foldr(\n  self: List<a>,\n  zero: result,\n  with: fn(Int, a, result) -> result,\n) -> result {\n  do_indexed_foldr(0, self, zero, with)\n}"
        },
        {
          "name": "reduce",
          "signature": "pub fn reduce(self: List<a>, zero: b, with: fn(b, a) -> b) -> b {",
          "documentation": "Reduce a list from left to right using the accumulator as left operand.\nSaid differently, this is [`foldl`](#foldl) with callback arguments swapped.\n\n```aiken\nlist.reduce([#[1], #[2], #[3]], #[0], bytearray.concat) == #[0, 1, 2, 3]\nlist.reduce([True, False, True], False, fn(b, a) { or { b, a } }) == True\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "zero",
              "type": "b",
              "optional": false
            },
            {
              "name": "with",
              "type": "fn(b, a",
              "optional": false
            }
          ],
          "returnType": "b) -> b",
          "line": 1464,
          "raw": "pub fn reduce(self: List<a>, zero: b, with: fn(b, a) -> b) -> b {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn reduce(self: List<a>, zero: b, with: fn(b, a) -> b) -> b {\n  foldl(self, zero, flip(with))\n}",
          "tests": [
            "test reduce_1() {\n  reduce([], 0, fn(n, total) { n + total }) == 0\n}",
            "test reduce_2() {\n  reduce([1, 2, 3], 0, fn(n, total) { n + total }) == 6\n}",
            "test reduce_3() {\n  reduce([True, False, True], False, fn(left, right) { left || right }) == True\n}",
            "test reduce_4() {\n  reduce(\n    [#[1], #[2], #[3]],\n    #[9],\n    fn(left, right) { bytearray.concat(left, right) },\n  ) == #[9, 1, 2, 3]\n}"
          ]
        }
      ],
      "types": [
        {
          "name": "Fold2<a, b, result>",
          "definition": "fn(a, b) -> result",
          "line": 1207,
          "raw": "pub type Fold2<a, b, result> =",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "constants": [],
      "atoms": [
        {
          "name": "do_index_of",
          "signature": "fn do_index_of(self: List<a>, elem: a, i: Int) -> Option<Int> {",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "elem",
              "type": "a",
              "optional": false
            },
            {
              "name": "i",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Option<Int>",
          "line": 318,
          "raw": "fn do_index_of(self: List<a>, elem: a, i: Int) -> Option<Int> {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_index_of(self: List<a>, elem: a, i: Int) -> Option<Int> {\n  when self is {\n    [] -> None\n    [x, ..xs] ->\n      if x == elem {\n        Some(i)\n      } else {\n        do_index_of(xs, elem, i + 1)\n      }\n  }\n}"
        },
        {
          "name": "do_init",
          "signature": "fn do_init(self: List<a>) -> List<a> {",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            }
          ],
          "returnType": "List<a>",
          "line": 592,
          "raw": "fn do_init(self: List<a>) -> List<a> {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_init(self: List<a>) -> List<a> {\n  when self is {\n    [] -> fail @\"unreachable\"\n    [_] -> []\n    [x, ..xs] -> [x, ..do_init(xs)]\n  }\n}"
        },
        {
          "name": "do_indexed_map",
          "signature": "fn do_indexed_map(fn do_indexed_map(n: Int, self: List<a>, with: fn(Int, a) -> result,",
          "parameters": [],
          "returnType": "result,",
          "line": 900,
          "raw": "fn do_indexed_map(fn do_indexed_map(n: Int, self: List<a>, with: fn(Int, a) -> result,",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_indexed_map(\n  n: Int,\n  self: List<a>,\n  with: fn(Int, a) -> result,\n) -> List<result> {\n  when self is {\n    [] -> []\n    [x, ..xs] -> [with(n, x), ..do_indexed_map(n + 1, xs, with)]\n  }\n}"
        },
        {
          "name": "insert",
          "signature": "fn insert(self: List<a>, e: a, compare: fn(a, a) -> Ordering) -> List<a> {",
          "parameters": [
            {
              "name": "self",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "e",
              "type": "a",
              "optional": false
            },
            {
              "name": "compare",
              "type": "fn(a, a",
              "optional": false
            }
          ],
          "returnType": "Ordering) -> List<a>",
          "line": 1049,
          "raw": "fn insert(self: List<a>, e: a, compare: fn(a, a) -> Ordering) -> List<a> {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn insert(self: List<a>, e: a, compare: fn(a, a) -> Ordering) -> List<a> {\n  when self is {\n    [] -> [e]\n    [x, ..xs] ->\n      if compare(e, x) == Less {\n        [e, ..self]\n      } else {\n        [x, ..insert(xs, e, compare)]\n      }\n  }\n}"
        },
        {
          "name": "do_foldr2",
          "signature": "fn do_foldr2(fn do_foldr2(self: List<elem>, with: fn(elem, a, b, Fold2<a, b, result>) -> result, return: Fold2<a, b, result>,",
          "parameters": [],
          "returnType": "result, return: Fold2<a, b, result>,",
          "line": 1387,
          "raw": "fn do_foldr2(fn do_foldr2(self: List<elem>, with: fn(elem, a, b, Fold2<a, b, result>) -> result, return: Fold2<a, b, result>,",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_foldr2(\n  self: List<elem>,\n  with: fn(elem, a, b, Fold2<a, b, result>) -> result,\n  return: Fold2<a, b, result>,\n) -> Fold2<a, b, result> {\n  when self is {\n    [] -> return\n    [x, ..xs] -> do_foldr2(xs, with, fn(a, b) { with(x, a, b, return) })\n  }\n}"
        },
        {
          "name": "do_indexed_foldr",
          "signature": "fn do_indexed_foldr(fn do_indexed_foldr(n: Int, self: List<a>, zero: result, with: fn(Int, a, result) -> result,",
          "parameters": [],
          "returnType": "result,",
          "line": 1434,
          "raw": "fn do_indexed_foldr(fn do_indexed_foldr(n: Int, self: List<a>, zero: result, with: fn(Int, a, result) -> result,",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_indexed_foldr(\n  n: Int,\n  self: List<a>,\n  zero: result,\n  with: fn(Int, a, result) -> result,\n) -> result {\n  when self is {\n    [] -> zero\n    [x, ..xs] -> with(n, x, do_indexed_foldr(n + 1, xs, zero, with))\n  }\n}"
        }
      ],
      "privateTypes": [
        {
          "name": "Foo",
          "definition": "{ Foo(Int, Int) }",
          "line": 1278,
          "raw": "type Foo {",
          "isPublic": false,
          "source": "stdlib"
        }
      ],
      "privateConstants": [],
      "content": "use aiken/builtin\nuse aiken/primitive/bytearray\nuse aiken/primitive/int\n\n// ## Constructing\n\n/// Add an element in front of the list. Sometimes useful when combined with\n/// other functions.\n///\n/// ```aiken\n/// list.push([2, 3], 1) == [1, ..[2, 3]] == [1, 2, 3]\n/// ```\npub fn push(self: List<a>, elem: a) -> List<a> {\n  [elem, ..self]\n}\n\ntest push_1() {\n  push([], 0) == [0]\n}\n\ntest push_2() {\n  push([2, 3], 1) == [1, 2, 3]\n}\n\n/// Construct a list of a integer from a given range.\n///\n/// ```aiken\n/// list.range(0, 3) == [0, 1, 2, 3]\n/// list.range(-1, 1) == [-1, 0, 1]\n/// ```\npub fn range(from: Int, to: Int) -> List<Int> {\n  if from > to {\n    []\n  } else {\n    [from, ..range(from + 1, to)]\n  }\n}\n\ntest range_1() {\n  range(0, 3) == [0, 1, 2, 3]\n}\n\ntest range_2() {\n  range(-1, 1) == [-1, 0, 1]\n}\n\n/// Construct a list filled with n copies of a value.\n///\n/// ```aiken\n/// list.repeat(\"na\", 3) == [\"na\", \"na\", \"na\"]\n/// ```\npub fn repeat(elem: a, n_times: Int) -> List<a> {\n  if n_times <= 0 {\n    []\n  } else {\n    [elem, ..repeat(elem, n_times - 1)]\n  }\n}\n\ntest repeat_1() {\n  repeat(42, 0) == []\n}\n\ntest repeat_2() {\n  repeat(14, 3) == [14, 14, 14]\n}\n\n// ## Inspecting\n\n/// Determine if all elements of the list satisfy the given predicate.\n///\n/// Note: an empty list always satisfies the predicate.\n///\n/// ```aiken\n/// list.all([], fn(n) { n > 0 }) == True\n/// list.all([1, 2, 3], fn(n) { n > 0 }) == True\n/// list.all([1, 2, 3], fn(n) { n == 2 }) == False\n/// ```\npub fn all(self: List<a>, predicate: fn(a) -> Bool) -> Bool {\n  when self is {\n    [] -> True\n    [x, ..xs] -> predicate(x) && all(xs, predicate)\n  }\n}\n\ntest all_1() {\n  all([1, 2, 3], fn(n) { n > 0 }) == True\n}\n\ntest all_2() {\n  all([1, 2, 3], fn(n) { n > 42 }) == False\n}\n\ntest all_3() {\n  all([], fn(n) { n == 42 }) == True\n}\n\n/// Determine if at least one element of the list satisfies the given predicate.\n///\n/// Note: an empty list never satisfies the predicate.\n///\n/// ```aiken\n/// list.any([], fn(n) { n > 2 }) == False\n/// list.any([1, 2, 3], fn(n) { n > 0 }) == True\n/// list.any([1, 2, 3], fn(n) { n == 2 }) == True\n/// list.any([1, 2, 3], fn(n) { n < 0 }) == False\n/// ```\npub fn any(self: List<a>, predicate: fn(a) -> Bool) -> Bool {\n  when self is {\n    [] -> False\n    [x, ..xs] -> predicate(x) || any(xs, predicate)\n  }\n}\n\ntest any_1() {\n  any([1, 2, 3], fn(n) { n > 0 }) == True\n}\n\ntest any_2() {\n  any([1, 2, 3], fn(n) { n > 42 }) == False\n}\n\ntest any_3() {\n  any([], fn(n) { n == 42 }) == False\n}\n\n/// Return Some(item) at the index or None if the index is out of range. The index is 0-based.\n///\n/// ```aiken\n/// list.at([1, 2, 3], 1) == Some(2)\n/// list.at([1, 2, 3], 42) == None\n/// ```\npub fn at(self: List<a>, index: Int) -> Option<a> {\n  when self is {\n    [] -> None\n    [x, ..xs] ->\n      if index == 0 {\n        Some(x)\n      } else {\n        at(xs, index - 1)\n      }\n  }\n}\n\ntest at_1() {\n  at([1, 2, 3], -1) == None\n}\n\ntest at_2() {\n  at([], 0) == None\n}\n\ntest at_3() {\n  at([1, 2, 3], 3) == None\n}\n\ntest at_4() {\n  at([1], 0) == Some(1)\n}\n\ntest at_5() {\n  at([1, 2, 3], 2) == Some(3)\n}\n\n/// Count how many items in the list satisfy the given predicate.\n///\n/// ```aiken\n/// list.count([], fn(a) { a > 2}) == 0\n/// list.count([1, 2, 3], fn(a) { n > 0 }) == 3\n/// list.count([1, 2, 3], fn(a) { n >= 2 }) == 2\n/// list.count([1, 2, 3], fn(a) { n > 5 }) == 0\n/// ```\npub fn count(self: List<a>, predicate: fn(a) -> Bool) -> Int {\n  foldr(\n    self,\n    0,\n    fn(item, total) {\n      if predicate(item) {\n        total + 1\n      } else {\n        total\n      }\n    },\n  )\n}\n\ntest count_empty() {\n  count([], fn(a) { a > 2 }) == 0\n}\n\ntest count_all() {\n  count([1, 2, 3], fn(a) { a > 0 }) == 3\n}\n\ntest count_some() {\n  count([1, 2, 3], fn(a) { a >= 2 }) == 2\n}\n\ntest count_none() {\n  count([1, 2, 3], fn(a) { a > 5 }) == 0\n}\n\n/// Find the first element satisfying the given predicate, if any.\n///\n/// ```aiken\n/// list.find([1, 2, 3], fn(x) { x == 2 }) == Some(2)\n/// list.find([4, 5, 6], fn(x) { x == 2 }) == None\n/// ```\npub fn find(self: List<a>, predicate: fn(a) -> Bool) -> Option<a> {\n  when self is {\n    [] -> None\n    [x, ..xs] ->\n      if predicate(x) {\n        Some(x)\n      } else {\n        find(xs, predicate)\n      }\n  }\n}\n\ntest find_1() {\n  find([1, 2, 3], fn(x) { x == 1 }) == Some(1)\n}\n\ntest find_2() {\n  find([1, 2, 3], fn(x) { x > 42 }) == None\n}\n\ntest find_3() {\n  find([], fn(_) { True }) == None\n}\n\n/// Figures out whether a list contain the given element.\n///\n/// ```aiken\n/// list.has([1, 2, 3], 2) == True\n/// list.has([1, 2, 3], 14) == False\n/// list.has([], 14) == False\n/// ```\npub fn has(self: List<a>, elem: a) -> Bool {\n  when self is {\n    [] -> False\n    [x, ..xs] ->\n      if x == elem {\n        True\n      } else {\n        has(xs, elem)\n      }\n  }\n}\n\ntest has_1() {\n  has([1, 2, 3], 1) == True\n}\n\ntest has_2() {\n  has([1, 2, 3], 14) == False\n}\n\ntest has_3() {\n  has([], 14) == False\n}\n\n/// Get the first element of a list\n///\n/// ```aiken\n/// list.head([1, 2, 3]) == Some(1)\n/// list.head([]) == None\n/// ```\npub fn head(self: List<a>) -> Option<a> {\n  when self is {\n    [] -> None\n    _ -> Some(builtin.head_list(self))\n  }\n}\n\ntest head_1() {\n  head([1, 2, 3]) == Some(1)\n}\n\ntest head_2() {\n  head([]) == None\n}\n\n/// Checks whether a list is empty.\n///\n/// ```aiken\n/// list.is_empty([]) == True\n/// list.is_empty([1, 2, 3]) == False\n/// ```\npub fn is_empty(self: List<a>) -> Bool {\n  when self is {\n    [] -> True\n    _ -> False\n  }\n}\n\ntest is_empty_1() {\n  is_empty([]) == True\n}\n\ntest is_empty_2() {\n  is_empty([1, 2, 3]) == False\n}\n\n/// Gets the index of an element of a list, if any. Otherwise, returns None.\n///\n/// ```aiken\n/// list.index_of([1, 5, 2], 2) == Some(2)\n/// list.index_of([1, 7, 3], 4) == None\n/// list.index_of([1, 0, 9, 6], 6) == 3\n/// list.index_of([], 6) == None\n/// ```\npub fn index_of(self: List<a>, elem: a) -> Option<Int> {\n  do_index_of(self, elem, 0)\n}\n\nfn do_index_of(self: List<a>, elem: a, i: Int) -> Option<Int> {\n  when self is {\n    [] -> None\n    [x, ..xs] ->\n      if x == elem {\n        Some(i)\n      } else {\n        do_index_of(xs, elem, i + 1)\n      }\n  }\n}\n\ntest index_of_1() {\n  index_of([1, 5, 2], 2) == Some(2)\n}\n\ntest index_of_2() {\n  index_of([1, 7, 3], 4) == None\n}\n\ntest index_of_3() {\n  index_of([1, 0, 9, 6], 6) == Some(3)\n}\n\ntest index_of_4() {\n  index_of([], 6) == None\n}\n\n/// Get the last in the given list, if any.\n///\n/// ```aiken\n/// list.last([]) == None\n/// list.last([1, 2, 3]) == Some(3)\n/// ```\npub fn last(self: List<a>) -> Option<a> {\n  when self is {\n    [] -> None\n    [x] -> Some(x)\n    [_, ..xs] -> last(xs)\n  }\n}\n\ntest last_1() {\n  last([]) == None\n}\n\ntest last_2() {\n  last([1]) == Some(1)\n}\n\ntest last_3() {\n  last([1, 2, 3, 4]) == Some(4)\n}\n\n/// Get the number of elements in the given list.\n///\n/// ```aiken\n/// list.length([]) == 0\n/// list.length([1, 2, 3]) == 3\n/// ```\npub fn length(self: List<a>) -> Int {\n  when self is {\n    [] -> 0\n    [_, ..xs] -> 1 + length(xs)\n  }\n}\n\ntest length_1() {\n  length([]) == 0\n}\n\ntest length_2() {\n  length([1, 2, 3]) == 3\n}\n\n// ## Modifying\n\n// ### Extracting\n\n/// Remove the first occurrence of the given element from the list.\n///\n/// ```aiken\n/// list.delete([1, 2, 3, 1], 1) == [2, 3, 1]\n/// list.delete([1, 2, 3], 14) == [1, 2, 3]\n/// ```\npub fn delete(self: List<a>, elem: a) -> List<a> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      if x == elem {\n        xs\n      } else {\n        [x, ..delete(xs, elem)]\n      }\n  }\n}\n\ntest delete_1() {\n  delete([], 42) == []\n}\n\ntest delete_2() {\n  delete([1, 2, 3, 1], 1) == [2, 3, 1]\n}\n\ntest delete_3() {\n  delete([1, 2, 3], 14) == [1, 2, 3]\n}\n\ntest delete_4() {\n  delete([2], 2) == []\n}\n\n/// Drop the first `n` elements of a list.\n///\n/// ```aiken\n/// list.drop([1, 2, 3], 2) == [3]\n/// list.drop([], 42) == []\n/// list.drop([1, 2, 3], 42) == []\n/// ```\npub fn drop(self: List<a>, n: Int) -> List<a> {\n  if n <= 0 {\n    self\n  } else {\n    when self is {\n      [] -> []\n      [_x, ..xs] -> drop(xs, n - 1)\n    }\n  }\n}\n\ntest drop_1() {\n  drop([], 42) == []\n}\n\ntest drop_2() {\n  drop([1, 2, 3], 2) == [3]\n}\n\n/// Returns the suffix of the given list after removing all elements that satisfy the predicate.\n///\n/// ```aiken\n/// list.drop_while([1, 2, 3], fn(x) { x < 2 }) == [2, 3]\n/// list.drop_while([], fn(x) { x > 2 }) == []\n/// list.drop_while([1, 2, 3], fn(x) { x == 3 }) == [1, 2, 3]\n/// ```\npub fn drop_while(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      if predicate(x) {\n        drop_while(xs, predicate)\n      } else {\n        self\n      }\n  }\n}\n\ntest drop_while_1() {\n  drop_while([], fn(x) { x > 2 }) == []\n}\n\ntest drop_while_2() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  drop_while(xs, fn(x) { x > 5 }) == [5, 4, 3, 2, 1]\n}\n\ntest drop_while_3() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  drop_while(xs, fn(x) { x == 42 }) == xs\n}\n\ntest drop_while_4() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  drop_while(xs, fn(x) { x < 42 }) == []\n}\n\n/// Produce a list of elements that satisfy a predicate.\n///\n/// ```aiken\n/// list.filter([1, 2, 3], fn(x) { x >= 2 }) == [2, 3]\n/// list.filter([], fn(x) { x > 2 }) == []\n/// list.filter([1, 2, 3], fn(x) { x == 3 }) == [3]\n/// ```\npub fn filter(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      if predicate(x) {\n        [x, ..filter(xs, predicate)]\n      } else {\n        filter(xs, predicate)\n      }\n  }\n}\n\ntest filter_1() {\n  filter([], fn(x) { x > 0 }) == []\n}\n\ntest filter_2() {\n  let xs = [1, 2, 3, 4, 5, 6]\n  filter(xs, fn(x) { builtin.mod_integer(x, 2) == 0 }) == [2, 4, 6]\n}\n\ntest filter_3() {\n  let filter_foldr =\n    fn(xs, f) {\n      foldr(\n        xs,\n        [],\n        fn(x, ys) {\n          if f(x) {\n            [x, ..ys]\n          } else {\n            ys\n          }\n        },\n      )\n    }\n\n  let is_odd =\n    fn(n) { builtin.mod_integer(n, 2) != 0 }\n\n  filter_foldr([1, 2, 3], is_odd) == filter([1, 2, 3], is_odd)\n}\n\n/// Produce a list of transformed elements that satisfy a predicate.\n///\n/// ```aiken\n/// let transform = fn(x) { if x % 2 == 0 { None } else { Some(3*x) } }\n/// list.filter_map([1, 2, 3], transform) == [3, 9]\n/// ```\npub fn filter_map(self: List<a>, predicate: fn(a) -> Option<b>) -> List<b> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      when predicate(x) is {\n        None -> filter_map(xs, predicate)\n        Some(y) -> [y, ..filter_map(xs, predicate)]\n      }\n  }\n}\n\ntest filter_map_1() {\n  filter_map([], fn(_) { Some(42) }) == []\n}\n\ntest filter_map_2() {\n  filter_map(\n    [1, 2, 3, 4, 5, 6],\n    fn(x) {\n      if builtin.mod_integer(x, 2) != 0 {\n        Some(3 * x)\n      } else {\n        None\n      }\n    },\n  ) == [3, 9, 15]\n}\n\n/// Return all elements except the last one.\n///\n/// ```aiken\n/// list.init([]) == None\n/// list.init([1, 2, 3]) == Some([1, 2])\n/// ```\npub fn init(self: List<a>) -> Option<List<a>> {\n  when self is {\n    [] -> None\n    _ -> Some(do_init(self))\n  }\n}\n\nfn do_init(self: List<a>) -> List<a> {\n  when self is {\n    [] -> fail @\"unreachable\"\n    [_] -> []\n    [x, ..xs] -> [x, ..do_init(xs)]\n  }\n}\n\ntest init_1() {\n  init([]) == None\n}\n\ntest init_2() {\n  init([1]) == Some([])\n}\n\ntest init_3() {\n  init([1, 2, 3, 4]) == Some([1, 2, 3])\n}\n\n/// Returns a tuple with all elements that satisfy the predicate at first\n/// element, and the rest as second element.\n///\n/// ```aiken\n/// list.partition([1, 2, 3, 4], fn(x) { x % 2 == 0 }) == ([2, 4], [1, 3])\n/// ```\npub fn partition(self: List<a>, predicate: fn(a) -> Bool) -> (List<a>, List<a>) {\n  when self is {\n    [] -> ([], [])\n    [x, ..xs] -> {\n      let (left, right) = partition(xs, predicate)\n      if predicate(x) {\n        ([x, ..left], right)\n      } else {\n        (left, [x, ..right])\n      }\n    }\n  }\n}\n\ntest partition_1() {\n  partition([], fn(x) { x > 2 }) == ([], [])\n}\n\ntest partition_2() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  partition(xs, fn(x) { x > 5 }) == ([10, 9, 8, 7, 6], [5, 4, 3, 2, 1])\n}\n\ntest partition_3() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  partition(xs, fn(x) { x == 42 }) == ([], xs)\n}\n\ntest partition_4() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  partition(xs, fn(x) { x < 42 }) == (xs, [])\n}\n\ntest partition_5() {\n  partition([1, 2, 3, 4], fn(x) { x % 2 == 0 }) == ([2, 4], [1, 3])\n}\n\n/// Extract a sublist from the given list using 0-based indexes. Negative\n/// indexes wrap over, so `-1` refers to the last element of the list.\n///\n/// ```aiken\n/// list.slice([1, 2, 3, 4, 5, 6], from: 2, to: 4) == [3, 4, 5]\n/// list.slice([1, 2, 3, 4, 5, 6], from: -2, to: -1) == [5, 6]\n/// list.slice([1, 2, 3, 4, 5, 6], from: 1, to: -1) == [2, 3, 4, 5, 6]\n/// ```\npub fn slice(self: List<a>, from: Int, to: Int) -> List<a> {\n  let (i, l) =\n    if from >= 0 {\n      (from, None)\n    } else {\n      let l = length(self)\n      (l + from, Some(l))\n    }\n\n  let j =\n    if to >= 0 {\n      to - i + 1\n    } else {\n      when l is {\n        Some(l) -> l + to - i + 1\n        None -> length(self) + to - i + 1\n      }\n    }\n\n  self\n    |> drop(i)\n    |> take(j)\n}\n\ntest slice_1() {\n  slice([1, 2, 3], 0, 2) == [1, 2, 3]\n}\n\ntest slice_2() {\n  slice([1, 2, 3, 4, 5, 6], from: 2, to: 4) == [3, 4, 5]\n}\n\ntest slice_3() {\n  slice([1, 2, 3, 4, 5, 6], from: -2, to: -1) == [5, 6]\n}\n\ntest slice_4() {\n  slice([1, 2, 3, 4, 5, 6], from: 1, to: -1) == [2, 3, 4, 5, 6]\n}\n\ntest slice_5() {\n  slice([1, 2, 3, 4, 5, 6], from: -4, to: -3) == [3, 4]\n}\n\ntest slice_6() {\n  slice([1, 2, 3, 4, 5, 6], from: -2, to: 1) == []\n}\n\n/// Cut a list in two, such that the first list contains the given number of /\n/// elements and the second list contains the rest.\n///\n/// Fundamentally equivalent to (but more efficient):\n///\n/// ```aiken\n/// // span(xs, n) == (take(xs, n), drop(xs, n))\n/// span([1, 2, 3, 4, 5], 3) == ([1, 2, 3], [4, 5])\n/// ```\npub fn span(self: List<a>, n: Int) -> (List<a>, List<a>) {\n  when self is {\n    [] -> ([], [])\n    [x, ..xs] ->\n      if n <= 0 {\n        ([], self)\n      } else {\n        let (left, right) = span(xs, n - 1)\n        ([x, ..left], right)\n      }\n  }\n}\n\ntest span_1() {\n  span([], 2) == ([], [])\n}\n\ntest span_2() {\n  span([1, 2, 3], 2) == ([1, 2], [3])\n}\n\ntest span_3() {\n  span([1, 2, 3], -1) == ([], [1, 2, 3])\n}\n\ntest span_4() {\n  span([1, 2, 3], 42) == ([1, 2, 3], [])\n}\n\n/// Get elements of a list after the first one, if any.\n///\n/// ```aiken\n/// list.tail([]) == None\n/// list.tail([1, 2, 3]) == Some([2, 3])\n/// ```\npub fn tail(self: List<a>) -> Option<List<a>> {\n  when self is {\n    [] -> None\n    [_, ..xs] -> Some(xs)\n  }\n}\n\ntest tail_1() {\n  tail([1, 2, 3]) == Some([2, 3])\n}\n\ntest tail_2() {\n  tail([]) == None\n}\n\n/// Get the first `n` elements of a list.\n///\n/// ```aiken\n/// list.take([1, 2, 3], 2) == [1, 2]\n/// list.take([1, 2, 3], 14) == [1, 2, 3]\n/// ```\npub fn take(self: List<a>, n: Int) -> List<a> {\n  if n <= 0 {\n    []\n  } else {\n    when self is {\n      [] -> []\n      [x, ..xs] -> [x, ..take(xs, n - 1)]\n    }\n  }\n}\n\ntest take_1() {\n  take([], 42) == []\n}\n\ntest take_2() {\n  take([1, 2, 3], 2) == [1, 2]\n}\n\n/// Returns the longest prefix of the given list where all elements satisfy the predicate.\n///\n/// ```aiken\n/// list.take_while([1, 2, 3], fn(x) { x > 2 }) == []\n/// list.take_while([1, 2, 3], fn(x) { x < 2 }) == [1]\n/// ```\npub fn take_while(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      if predicate(x) {\n        [x, ..take_while(xs, predicate)]\n      } else {\n        []\n      }\n  }\n}\n\ntest take_while_1() {\n  take_while([], fn(x) { x > 2 }) == []\n}\n\ntest take_while_2() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  take_while(xs, fn(x) { x > 5 }) == [10, 9, 8, 7, 6]\n}\n\ntest take_while_3() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  take_while(xs, fn(x) { x == 42 }) == []\n}\n\ntest take_while_4() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  take_while(xs, fn(x) { x < 42 }) == xs\n}\n\n/// Removes duplicate elements from a list.\n///\n/// ```aiken\n/// list.unique([1, 2, 3, 1]) == [1, 2, 3]\n/// ```\npub fn unique(self: List<a>) -> List<a> {\n  when self is {\n    [] -> []\n    [x, ..xs] -> [x, ..unique(filter(xs, fn(y) { y != x }))]\n  }\n}\n\ntest unique_1() {\n  unique([]) == []\n}\n\ntest unique_2() {\n  let xs = [1, 2, 3, 1, 1, 3, 4, 1, 2, 3, 2, 4, 5, 6, 7, 8, 9, 10, 9]\n  unique(xs) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n}\n\n// ### Mapping\n\n/// Map elements of a list into a new list and flatten the result.\n///\n/// ```aiken\n/// list.flat_map([1, 2, 3], fn(a) { [a, 2*a] }) == [1, 2, 2, 4, 3, 6]\n/// ```\npub fn flat_map(self: List<a>, with: fn(a) -> List<b>) -> List<b> {\n  foldr(self, [], fn(x, xs) { concat(with(x), xs) })\n}\n\ntest flat_map_1() {\n  flat_map([], fn(a) { [a] }) == []\n}\n\ntest flat_map_2() {\n  flat_map([1, 2, 3], fn(a) { [a, a] }) == [1, 1, 2, 2, 3, 3]\n}\n\n/// Perform an action for each element of a list.\n///\n/// ```aiken\n/// list.for_each(labels, do: fn(lbl) { trace lbl Void })\n/// ```\npub fn for_each(self: List<a>, do: fn(a) -> Void) -> Void {\n  foldr(self, Void, fn(x, _) { do(x) })\n}\n\ntest for_each_1() {\n  for_each(\n    [@\"hello\", @\"world\"],\n    do: fn(lbl) {\n      trace lbl\n      Void\n    },\n  )\n}\n\n/// List [`map`](#map) but provides the position (0-based) of the elements while iterating.\n///\n/// ```aiken\n/// list.indexed_map([1, 2, 3], fn(i, x) { i + x }) == [1, 3, 5]\n/// ```\npub fn indexed_map(self: List<a>, with: fn(Int, a) -> result) -> List<result> {\n  do_indexed_map(0, self, with)\n}\n\nfn do_indexed_map(\n  n: Int,\n  self: List<a>,\n  with: fn(Int, a) -> result,\n) -> List<result> {\n  when self is {\n    [] -> []\n    [x, ..xs] -> [with(n, x), ..do_indexed_map(n + 1, xs, with)]\n  }\n}\n\ntest indexed_map_1() {\n  indexed_map([], fn(i, _n) { i }) == []\n}\n\ntest indexed_map_2() {\n  indexed_map(\n    [4, 8, 13, 2],\n    fn(i, n) {\n      if n == 8 {\n        n\n      } else {\n        i\n      }\n    },\n  ) == [0, 8, 2, 3]\n}\n\n/// Apply a function to each element of a list.\n///\n/// ```aiken\n/// list.map([1, 2, 3, 4], fn(n) { n + 1 }) == [2, 3, 4, 5]\n/// ```\npub fn map(self: List<a>, with: fn(a) -> result) -> List<result> {\n  when self is {\n    [] -> []\n    [x, ..xs] -> [with(x), ..map(xs, with)]\n  }\n}\n\ntest map_1() {\n  map([], fn(n) { n + 1 }) == []\n}\n\ntest map_2() {\n  map([1, 2, 3, 4], fn(n) { n + 1 }) == [2, 3, 4, 5]\n}\n\n/// Apply a function of two arguments, combining elements from two lists.\n///\n/// Note: if one list is longer, the extra elements are dropped.\n///\n/// ```aiken\n/// list.map2([1, 2, 3], [1, 2], fn(a, b) { a + b }) == [2, 4]\n/// ```\npub fn map2(\n  self: List<a>,\n  bs: List<b>,\n  with: fn(a, b) -> result,\n) -> List<result> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      when bs is {\n        [] -> []\n        [y, ..ys] -> [with(x, y), ..map2(xs, ys, with)]\n      }\n  }\n}\n\ntest map2_1() {\n  map2([], [1, 2, 3], fn(a, b) { a + b }) == []\n}\n\ntest map2_2() {\n  map2([1, 2, 3], [1, 2], fn(a, b) { a + b }) == [2, 4]\n}\n\ntest map2_3() {\n  map2([42], [1, 2, 3], fn(_a, b) { Some(b) }) == [Some(1)]\n}\n\n/// Apply a function of three arguments, combining elements from three lists.\n///\n/// Note: if one list is longer, the extra elements are dropped.\n///\n/// ```aiken\n/// list.map3([1, 2, 3], [1, 2], [1, 2, 3], fn(a, b, c) { a + b + c }) == [3, 6]\n/// ```\npub fn map3(\n  self: List<a>,\n  bs: List<b>,\n  cs: List<c>,\n  with: fn(a, b, c) -> result,\n) -> List<result> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      when bs is {\n        [] -> []\n        [y, ..ys] ->\n          when cs is {\n            [] -> []\n            [z, ..zs] -> [with(x, y, z), ..map3(xs, ys, zs, with)]\n          }\n      }\n  }\n}\n\ntest map3_1() {\n  map3([], [], [1, 2, 3], fn(a, b, c) { a + b + c }) == []\n}\n\ntest map3_2() {\n  map3([1, 2, 3], [1, 2], [1, 2, 3], fn(a, b, c) { a + b + c }) == [3, 6]\n}\n\n/// Return the list with its elements in the reserve order.\n///\n/// ```aiken\n/// list.reverse([1, 2, 3]) == [3, 2, 1]\n/// ```\npub fn reverse(self: List<a>) -> List<a> {\n  foldl(self, [], fn(x, xs) { [x, ..xs] })\n}\n\ntest reverse_1() {\n  reverse([]) == []\n}\n\ntest reverse_2() {\n  reverse([1, 2, 3]) == [3, 2, 1]\n}\n\n/// Sort a list in ascending order using the given comparison function.\n///\n/// ```aiken\n/// use aiken/int\n///\n/// sort([3, 1, 4, 0, 2], int.compare) == [0, 1, 2, 3, 4]\n/// sort([1, 2, 3], int.compare) == [1, 2, 3]\n/// ```\npub fn sort(self: List<a>, compare: fn(a, a) -> Ordering) -> List<a> {\n  when self is {\n    [] -> []\n    [x, ..xs] -> insert(sort(xs, compare), x, compare)\n  }\n}\n\nfn insert(self: List<a>, e: a, compare: fn(a, a) -> Ordering) -> List<a> {\n  when self is {\n    [] -> [e]\n    [x, ..xs] ->\n      if compare(e, x) == Less {\n        [e, ..self]\n      } else {\n        [x, ..insert(xs, e, compare)]\n      }\n  }\n}\n\ntest sort_1() {\n  let xs = [6, 7, 5, 4, 1, 3, 9, 8, 0, 2]\n  sort(xs, int.compare) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n}\n\ntest sort_2() {\n  let xs = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n  sort(xs, int.compare) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n}\n\ntest sort_3() {\n  let xs = [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\n  sort(xs, int.compare) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n}\n\ntest sort_4() {\n  sort([], int.compare) == []\n}\n\n/// Decompose a list of tuples into a tuple of lists.\n///\n/// ```\n/// list.unzip([(1, \"a\"), (2, \"b\")]) == ([1, 2], [\"a\", \"b\"])\n/// ```\npub fn unzip(self: List<(a, b)>) -> (List<a>, List<b>) {\n  when self is {\n    [] -> ([], [])\n    [(a, b), ..xs] -> {\n      let (a_tail, b_tail) = unzip(xs)\n      ([a, ..a_tail], [b, ..b_tail])\n    }\n  }\n}\n\ntest unzip_1() {\n  unzip([]) == ([], [])\n}\n\ntest unzip_2() {\n  unzip([(1, \"a\"), (2, \"b\")]) == ([1, 2], [\"a\", \"b\"])\n}\n\n// ## Combining\n\n/// Merge two lists together.\n///\n/// ```aiken\n/// list.concat([], []) == []\n/// list.concat([], [1, 2, 3]) == [1, 2, 3]\n/// list.concat([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n/// ```\npub fn concat(left: List<a>, right: List<a>) -> List<a> {\n  when left is {\n    [] -> right\n    [x, ..xs] -> [x, ..concat(xs, right)]\n  }\n}\n\ntest concat_1() {\n  concat([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n}\n\ntest concat_2() {\n  concat([1, 2, 3], []) == [1, 2, 3]\n}\n\ntest concat_3() {\n  concat([], [1, 2, 3]) == [1, 2, 3]\n}\n\n/// Remove the first occurrence of each element of the second list from the first one.\n///\n/// ```\n/// list.difference([\"h\", \"e\", \"l\", \"l\", \"o\"], [\"l\", \"e\", \"l\"]) == [\"h\", \"o\"]\n/// list.difference([1, 2, 3, 4, 5], [1, 1, 2]) == [3, 4, 5]\n/// list.difference([1, 2, 3], []) == [1, 2, 3]\n/// ```\npub fn difference(self: List<a>, with: List<a>) -> List<a> {\n  when with is {\n    [] -> self\n    [x, ..xs] -> difference(delete(self, x), xs)\n  }\n}\n\ntest difference_1() {\n  difference([\"h\", \"e\", \"l\", \"l\", \"o\"], [\"l\", \"e\", \"l\"]) == [\"h\", \"o\"]\n}\n\ntest difference_2() {\n  difference([1, 2, 3, 4, 5], [1, 1, 2]) == [3, 4, 5]\n}\n\ntest difference_3() {\n  difference([1, 2, 3], []) == [1, 2, 3]\n}\n\ntest difference_4() {\n  difference([], [1, 2, 3]) == []\n}\n\n/// Combine two lists together.\n///\n/// Note: if one list is longer, the extra elements are dropped.\n///\n/// ```aiken\n/// list.zip([1, 2], [\"a\", \"b\", \"c\"]) == [(1, \"a\"), (2, \"b\")]\n/// ```\npub fn zip(self: List<a>, bs: List<b>) -> List<(a, b)> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      when bs is {\n        [] -> []\n        [y, ..ys] -> [(x, y), ..zip(xs, ys)]\n      }\n  }\n}\n\ntest zip_1() {\n  zip([], [1, 2, 3]) == []\n}\n\ntest zip_2() {\n  zip([1, 2, 3], []) == []\n}\n\ntest zip_3() {\n  zip([1, 2], [\"a\", \"b\", \"c\"]) == [(1, \"a\"), (2, \"b\")]\n}\n\n// ## Transforming\n\n/// Reduce a list from left to right.\n///\n/// ```aiken\n/// list.foldl([1, 2, 3], 0, fn(n, total) { n + total }) == 6\n/// list.foldl([1, 2, 3], [], fn(x, xs) { [x, ..xs] }) == [3, 2, 1]\n/// ```\npub fn foldl(self: List<a>, zero: b, with: fn(a, b) -> b) -> b {\n  when self is {\n    [] -> zero\n    [x, ..xs] -> foldl(xs, with(x, zero), with)\n  }\n}\n\n/// A function callback to accumulate two returned values at once. See also [`foldl2`](#foldl2) and [`foldr2`](#foldr2) about usage.\npub type Fold2<a, b, result> =\n  fn(a, b) -> result\n\n/// Reduce a list from left to right, while accumulating two results. This is\n/// faster (albeit equivalent) than accumulating both results in a `Pair` or tuple.\n///\n/// > [!TIP]\n/// > Using [`backpassing`](https://aiken-lang.org/language-tour/functions#backpassing-) to ease readability is a good idea.\n///\n/// ```aiken\n/// let len, sum <-\n///    foldl2(\n///      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n///      0,\n///      0,\n///      fn(n, len, sum, return) { return(len + 1, sum + n) },\n///    )\n///\n/// and {\n///   len == 10,\n///   sum == 55,\n/// }\n/// ```\npub fn foldl2(\n  self: List<elem>,\n  zero_a: a,\n  zero_b: b,\n  with: fn(elem, a, b, Fold2<a, b, result>) -> result,\n  return: Fold2<a, b, result>,\n) -> result {\n  when self is {\n    [] -> return(zero_a, zero_b)\n    [x, ..xs] -> {\n      let a, b <- with(x, zero_a, zero_b)\n      foldl2(xs, a, b, with, return)\n    }\n  }\n}\n\ntest foldl2_optimized() {\n  let\n    len,\n    sum,\n  <-\n    foldl2(\n      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n      0,\n      0,\n      fn(n, len, sum, return) { return(len + 1, sum + n) },\n    )\n\n  and {\n    len == 10,\n    sum == 55,\n  }\n}\n\ntest foldl2_classic() {\n  let (len, sum) =\n    foldl(\n      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n      (0, 0),\n      fn(n, (len, sum)) { (len + 1, sum + n) },\n    )\n\n  and {\n    len == 10,\n    sum == 55,\n  }\n}\n\ntype Foo {\n  Foo(Int, Int)\n}\n\ntest foldl2_pair() {\n  let Pair(len, sum) =\n    foldl(\n      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n      Pair(0, 0),\n      fn(n, Pair(len, sum)) { Pair(len + 1, sum + n) },\n    )\n\n  and {\n    len == 10,\n    sum == 55,\n  }\n}\n\ntest foldl2_foo() {\n  let Foo(len, sum) =\n    foldl(\n      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n      Foo(0, 0),\n      fn(n, Foo(len, sum)) { Foo(len + 1, sum + n) },\n    )\n\n  and {\n    len == 10,\n    sum == 55,\n  }\n}\n\ntest foldl_1() {\n  foldl([], 0, fn(_, _) { 1 }) == 0\n}\n\ntest foldl_2() {\n  foldl([1, 2, 3, 4, 5], 0, fn(n, total) { n + total }) == 15\n}\n\ntest foldl_3() {\n  foldl([1, 2, 3, 4], [], fn(x, xs) { [x, ..xs] }) == [4, 3, 2, 1]\n}\n\n/// Reduce a list from right to left.\n///\n/// ```aiken\n/// list.foldr([1, 2, 3], 0, fn(n, total) { n + total }) == 6\n/// list.foldr([1, 2, 3], [], fn(x, xs) { [x, ..xs] }) == [1, 2, 3]\n/// ```\npub fn foldr(self: List<a>, zero: b, with: fn(a, b) -> b) -> b {\n  when self is {\n    [] -> zero\n    [x, ..xs] -> with(x, foldr(xs, zero, with))\n  }\n}\n\ntest foldr_1() {\n  foldr([1, 2, 3, 4, 5], 0, fn(n, total) { n + total }) == 15\n}\n\ntest foldr_2() {\n  foldr(\n    [1, 2, 3],\n    \"\",\n    fn(n, _str) {\n      if builtin.mod_integer(n, 2) == 0 {\n        \"foo\"\n      } else {\n        \"bar\"\n      }\n    },\n  ) == \"bar\"\n}\n\ntest foldr_3() {\n  foldr([1, 2, 3, 4], [], fn(x, xs) { [x, ..xs] }) == [1, 2, 3, 4]\n}\n\n/// Reduce a list from right to left, while accumulating two results. This is\n/// faster (albeit equivalent) than accumulating both results in a `Pair` or tuple.\n///\n/// > [!TIP]\n/// > Using [`backpassing`](https://aiken-lang.org/language-tour/functions#backpassing-) to ease readability is a good idea.\n///\n/// ```aiken\n/// let len, sum <-\n///    foldr2(\n///      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n///      0,\n///      0,\n///      fn(n, len, sum, return) { return(len + 1, sum + n) },\n///    )\n///\n/// and {\n///   len == 10,\n///   sum == 55,\n/// }\n/// ```\npub fn foldr2(\n  self: List<elem>,\n  zero_a: a,\n  zero_b: b,\n  with: fn(elem, a, b, Fold2<a, b, result>) -> result,\n  return: Fold2<a, b, result>,\n) -> result {\n  do_foldr2(self, with, return)(zero_a, zero_b)\n}\n\nfn do_foldr2(\n  self: List<elem>,\n  with: fn(elem, a, b, Fold2<a, b, result>) -> result,\n  return: Fold2<a, b, result>,\n) -> Fold2<a, b, result> {\n  when self is {\n    [] -> return\n    [x, ..xs] -> do_foldr2(xs, with, fn(a, b) { with(x, a, b, return) })\n  }\n}\n\ntest foldr2_optimized() {\n  let\n    len,\n    sum,\n  <-\n    foldr2(\n      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n      0,\n      0,\n      fn(n, len, sum, return) { return(len + 1, sum + n) },\n    )\n\n  and {\n    len == 10,\n    sum == 55,\n  }\n}\n\n/// Like [`foldr`](#foldr), but also provides the position (0-based) of the elements when iterating.\n///\n/// ```aiken\n/// let group = fn(i, x, xs) { [(i, x), ..xs] }\n/// list.indexed_foldr([\"a\", \"b\", \"c\"], [], group) == [\n///   (0, \"a\"),\n///   (1, \"b\"),\n///   (2, \"c\")\n/// ]\n/// ```\npub fn indexed_foldr(\n  self: List<a>,\n  zero: result,\n  with: fn(Int, a, result) -> result,\n) -> result {\n  do_indexed_foldr(0, self, zero, with)\n}\n\nfn do_indexed_foldr(\n  n: Int,\n  self: List<a>,\n  zero: result,\n  with: fn(Int, a, result) -> result,\n) -> result {\n  when self is {\n    [] -> zero\n    [x, ..xs] -> with(n, x, do_indexed_foldr(n + 1, xs, zero, with))\n  }\n}\n\ntest indexed_foldr_1() {\n  indexed_foldr([], 0, fn(i, x, xs) { i + x + xs }) == 0\n}\n\ntest indexed_foldr_2() {\n  let letters = [\"a\", \"b\", \"c\"]\n  indexed_foldr(letters, [], fn(i, x, xs) { [(i, x), ..xs] }) == [\n    (0, \"a\"), (1, \"b\"), (2, \"c\"),\n  ]\n}\n\n/// Reduce a list from left to right using the accumulator as left operand.\n/// Said differently, this is [`foldl`](#foldl) with callback arguments swapped.\n///\n/// ```aiken\n/// list.reduce([#[1], #[2], #[3]], #[0], bytearray.concat) == #[0, 1, 2, 3]\n/// list.reduce([True, False, True], False, fn(b, a) { or { b, a } }) == True\n/// ```\npub fn reduce(self: List<a>, zero: b, with: fn(b, a) -> b) -> b {\n  foldl(self, zero, flip(with))\n}\n\ntest reduce_1() {\n  reduce([], 0, fn(n, total) { n + total }) == 0\n}\n\ntest reduce_2() {\n  reduce([1, 2, 3], 0, fn(n, total) { n + total }) == 6\n}\n\ntest reduce_3() {\n  reduce([True, False, True], False, fn(left, right) { left || right }) == True\n}\n\ntest reduce_4() {\n  reduce(\n    [#[1], #[2], #[3]],\n    #[9],\n    fn(left, right) { bytearray.concat(left, right) },\n  ) == #[9, 1, 2, 3]\n}\n",
      "dependencies": [
        "aiken/builtin",
        "aiken/primitive/bytearray",
        "aiken/primitive/int"
      ],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.collection.pairs",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/collection/pairs.ak",
      "name": "aiken.collection.pairs",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 15,
          "raw": "use aiken/builtin",
          "source": "stdlib"
        },
        {
          "module": "aiken/primitive/bytearray",
          "items": [],
          "line": 16,
          "raw": "use aiken/primitive/bytearray",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "get_all",
          "signature": "pub fn get_all(self: Pairs<key, value>, key k: key) -> List<value> {",
          "documentation": "Get all values in the alist associated with a given key.\n\n```aiken\npairs.get_all([], \"a\") == []\npairs.get_all([Pair(\"a\", 1)], \"a\") == [1]\npairs.get_all([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == [1]\npairs.get_all([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == [1, 3]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Pairs<key, value>",
              "optional": false
            }
          ],
          "returnType": "List<value>",
          "line": 28,
          "raw": "pub fn get_all(self: Pairs<key, value>, key k: key) -> List<value> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn get_all(self: Pairs<key, value>, key k: key) -> List<value> {\n  when self is {\n    [] -> []\n    [Pair(k2, v), ..rest] ->\n      if k == k2 {\n        [v, ..get_all(rest, k)]\n      } else {\n        get_all(rest, k)\n      }\n  }\n}",
          "tests": [
            "test get_all_1() {\n  get_all([], \"a\") == []\n}",
            "test get_all_2() {\n  get_all([Pair(\"a\", 1)], \"a\") == [1]\n}",
            "test get_all_3() {\n  get_all([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == [1]\n}",
            "test get_all_4() {\n  get_all([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == [1, 3]\n}",
            "test get_all_5() {\n  get_all([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"c\", 3)], \"d\") == []\n}"
          ]
        },
        {
          "name": "get_first",
          "signature": "pub fn get_first(self: Pairs<key, value>, key k: key) -> Option<value> {",
          "documentation": "Get the value in the alist by its key.\nIf multiple values with the same key exist, only the first one is returned.\n\n```aiken\npairs.get_first([], \"a\") == None\npairs.get_first([Pair(\"a\", 1)], \"a\") == Some(1)\npairs.get_first([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == Some(1)\npairs.get_first([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == Some(1)\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Pairs<key, value>",
              "optional": false
            }
          ],
          "returnType": "Option<value>",
          "line": 69,
          "raw": "pub fn get_first(self: Pairs<key, value>, key k: key) -> Option<value> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn get_first(self: Pairs<key, value>, key k: key) -> Option<value> {\n  when self is {\n    [] -> None\n    [Pair(k2, v), ..rest] ->\n      if k == k2 {\n        Some(v)\n      } else {\n        get_first(rest, k)\n      }\n  }\n}",
          "tests": [
            "test get_first_1() {\n  get_first([], \"a\") == None\n}",
            "test get_first_2() {\n  get_first([Pair(\"a\", 1)], \"a\") == Some(1)\n}",
            "test get_first_3() {\n  get_first([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == Some(1)\n}",
            "test get_first_4() {\n  get_first([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == Some(1)\n}",
            "test get_first_5() {\n  get_first([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"c\", 3)], \"d\") == None\n}"
          ]
        },
        {
          "name": "get_last",
          "signature": "pub fn get_last(self: Pairs<key, value>, key k: key) -> Option<value> {",
          "documentation": "Get the value in the alist by its key.\nIf multiple values with the same key exist, only the last one is returned.\n\n```aiken\npairs.get_last([], \"a\") == None\npairs.get_last([Pair(\"a\", 1)], \"a\") == Some(1)\npairs.get_last([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == Some(1)\npairs.get_last([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == Some(3)\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Pairs<key, value>",
              "optional": false
            }
          ],
          "returnType": "Option<value>",
          "line": 110,
          "raw": "pub fn get_last(self: Pairs<key, value>, key k: key) -> Option<value> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn get_last(self: Pairs<key, value>, key k: key) -> Option<value> {\n  when self is {\n    [] -> None\n    [Pair(k2, v), ..rest] ->\n      if k == k2 {\n        when get_last(rest, k) is {\n          None -> Some(v)\n          some -> some\n        }\n      } else {\n        get_last(rest, k)\n      }\n  }\n}",
          "tests": [
            "test get_last_1() {\n  get_last([], \"a\") == None\n}",
            "test get_last_2() {\n  get_last([Pair(\"a\", 1)], \"a\") == Some(1)\n}",
            "test get_last_3() {\n  get_last([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == Some(1)\n}",
            "test get_last_4() {\n  get_last([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == Some(3)\n}",
            "test get_last_5() {\n  get_last([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"c\", 3)], \"d\") == None\n}"
          ]
        },
        {
          "name": "find_all",
          "signature": "pub fn find_all(self: Pairs<key, value>, v: value) -> List<key> {",
          "documentation": "Finds all keys in the alist associated with a given value.\n\n```aiken\npairs.find_all([], 1) == []\npairs.find_all([Pair(\"a\", 1)], 1) == [\"a\"]\npairs.find_all([Pair(\"a\", 1), Pair(\"b\", 2)], 1) == [\"a\"]\npairs.find_all([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"c\", 1)], 1) == [\"a\", \"c\"]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Pairs<key, value>",
              "optional": false
            },
            {
              "name": "v",
              "type": "value",
              "optional": false
            }
          ],
          "returnType": "List<key>",
          "line": 153,
          "raw": "pub fn find_all(self: Pairs<key, value>, v: value) -> List<key> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn find_all(self: Pairs<key, value>, v: value) -> List<key> {\n  when self is {\n    [] -> []\n    [Pair(k2, v2), ..rest] ->\n      if v == v2 {\n        [k2, ..find_all(rest, v)]\n      } else {\n        find_all(rest, v)\n      }\n  }\n}",
          "tests": [
            "test find_all_1() {\n  find_all([], \"a\") == []\n}",
            "test find_all_2() {\n  find_all([Pair(\"a\", 14)], 14) == [\"a\"]\n}",
            "test find_all_3() {\n  find_all([Pair(\"a\", 14)], 42) == []\n}",
            "test find_all_4() {\n  find_all([Pair(\"a\", 14), Pair(\"b\", 42), Pair(\"c\", 14)], 14) == [\"a\", \"c\"]\n}"
          ]
        },
        {
          "name": "find_first",
          "signature": "pub fn find_first(self: Pairs<key, value>, v: value) -> Option<key> {",
          "documentation": "Finds the first key in the alist associated with a given value, if any.\n\n```aiken\npairs.find_first([], 1) == None\npairs.find_first([Pair(\"a\", 1)], 1) == Some(\"a\")\npairs.find_first([Pair(\"a\", 1), Pair(\"b\", 2)], 1) == Some(\"a\")\npairs.find_first([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"c\", 1)], 1) == Some(\"a\")\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Pairs<key, value>",
              "optional": false
            },
            {
              "name": "v",
              "type": "value",
              "optional": false
            }
          ],
          "returnType": "Option<key>",
          "line": 189,
          "raw": "pub fn find_first(self: Pairs<key, value>, v: value) -> Option<key> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn find_first(self: Pairs<key, value>, v: value) -> Option<key> {\n  when self is {\n    [] -> None\n    [Pair(k2, v2), ..rest] ->\n      if v == v2 {\n        Some(k2)\n      } else {\n        find_first(rest, v)\n      }\n  }\n}",
          "tests": [
            "test find_first_1() {\n  find_first([], \"a\") == None\n}",
            "test find_first_2() {\n  find_first([Pair(\"a\", 14)], 14) == Some(\"a\")\n}",
            "test find_first_3() {\n  find_first([Pair(\"a\", 14)], 42) == None\n}",
            "test find_first_4() {\n  find_first([Pair(\"a\", 14), Pair(\"b\", 42), Pair(\"c\", 14)], 14) == Some(\"a\")\n}"
          ]
        },
        {
          "name": "find_last",
          "signature": "pub fn find_last(self: Pairs<key, value>, v: value) -> Option<key> {",
          "documentation": "Finds the last key in the alist associated with a given value, if any.\n\n```aiken\npairs.find_last([], 1) == None\npairs.find_last([Pair(\"a\", 1)], 1) == Some(\"a\")\npairs.find_last([Pair(\"a\", 1), Pair(\"b\", 2)], 1) == Some(\"a\")\npairs.find_last([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"c\", 1)], 1) == Some(\"c\")\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Pairs<key, value>",
              "optional": false
            },
            {
              "name": "v",
              "type": "value",
              "optional": false
            }
          ],
          "returnType": "Option<key>",
          "line": 225,
          "raw": "pub fn find_last(self: Pairs<key, value>, v: value) -> Option<key> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn find_last(self: Pairs<key, value>, v: value) -> Option<key> {\n  when self is {\n    [] -> None\n    [Pair(k2, v2), ..rest] ->\n      if v == v2 {\n        when find_last(rest, v) is {\n          None -> Some(k2)\n          some -> some\n        }\n      } else {\n        find_last(rest, v)\n      }\n  }\n}",
          "tests": [
            "test find_last_1() {\n  find_last([], \"a\") == None\n}",
            "test find_last_2() {\n  find_last([Pair(\"a\", 14)], 14) == Some(\"a\")\n}",
            "test find_last_3() {\n  find_last([Pair(\"a\", 14)], 42) == None\n}",
            "test find_last_4() {\n  find_last([Pair(\"a\", 14), Pair(\"b\", 42), Pair(\"c\", 14)], 14) == Some(\"c\")\n}"
          ]
        },
        {
          "name": "has_key",
          "signature": "pub fn has_key(self: Pairs<key, value>, k: key) -> Bool {",
          "documentation": "Check if a key exists in the pairs.\n\n```aiken\npairs.has_key([], \"a\") == False\npairs.has_key([Pair(\"a\", 1)], \"a\") == True\npairs.has_key([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == True\npairs.has_key([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == True\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Pairs<key, value>",
              "optional": false
            },
            {
              "name": "k",
              "type": "key",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 264,
          "raw": "pub fn has_key(self: Pairs<key, value>, k: key) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn has_key(self: Pairs<key, value>, k: key) -> Bool {\n  when self is {\n    [] -> False\n    // || is lazy so this is fine\n    [Pair(k2, _), ..rest] -> k == k2 || has_key(rest, k)\n  }\n}",
          "tests": [
            "test has_key_1() {\n  !has_key([], \"a\")\n}",
            "test has_key_2() {\n  has_key([Pair(\"a\", 14)], \"a\")\n}",
            "test has_key_3() {\n  !has_key([Pair(\"a\", 14)], \"b\")\n}",
            "test has_key_4() {\n  has_key([Pair(\"a\", 14), Pair(\"b\", 42)], \"b\")\n}",
            "test has_key_5() {\n  has_key([Pair(\"a\", 14), Pair(\"b\", 42), Pair(\"a\", 42)], \"a\")\n}"
          ]
        },
        {
          "name": "keys",
          "signature": "pub fn keys(self: Pairs<key, value>) -> List<key> {",
          "documentation": "Extract all the keys present in a given `Pairs`.\n\n```aiken\npairs.keys([]) == []\npairs.keys([Pair(\"a\", 1)]) == [\"a\"]\npairs.keys([Pair(\"a\", 1), Pair(\"b\", 2)]) == [\"a\", \"b\"]\npairs.keys([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)]) == [\"a\", \"b\", \"a\"]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Pairs<key, value>",
              "optional": false
            }
          ],
          "returnType": "List<key>",
          "line": 300,
          "raw": "pub fn keys(self: Pairs<key, value>) -> List<key> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn keys(self: Pairs<key, value>) -> List<key> {\n  when self is {\n    [] -> []\n    [Pair(k, _), ..rest] -> [k, ..keys(rest)]\n  }\n}",
          "tests": [
            "test keys_1() {\n  keys([]) == []\n}",
            "test keys_2() {\n  keys([Pair(\"a\", 0)]) == [\"a\"]\n}",
            "test keys_3() {\n  keys([Pair(\"a\", 0), Pair(\"b\", 0)]) == [\"a\", \"b\"]\n}"
          ]
        },
        {
          "name": "values",
          "signature": "pub fn values(self: Pairs<key, value>) -> List<value> {",
          "documentation": "Extract all the values present in a given `Pairs`.\n\n```aiken\npairs.values([]) == []\npairs.values([Pair(\"a\", 1)]) == [1]\npairs.values([Pair(\"a\", 1), Pair(\"b\", 2)]) == [1, 2]\npairs.values([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)]) == [1, 2, 3]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Pairs<key, value>",
              "optional": false
            }
          ],
          "returnType": "List<value>",
          "line": 327,
          "raw": "pub fn values(self: Pairs<key, value>) -> List<value> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn values(self: Pairs<key, value>) -> List<value> {\n  when self is {\n    [] -> []\n    [Pair(_, v), ..rest] -> [v, ..values(rest)]\n  }\n}",
          "tests": [
            "test values_1() {\n  values([]) == []\n}",
            "test values_2() {\n  values([Pair(\"a\", 1)]) == [1]\n}",
            "test values_3() {\n  values([Pair(\"a\", 1), Pair(\"b\", 2)]) == [1, 2]\n}",
            "test values_4() {\n  values([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)]) == [1, 2, 3]\n}"
          ]
        },
        {
          "name": "delete_all",
          "signature": "pub fn delete_all(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {",
          "documentation": "Remove all key-value pairs matching the key from the Pairs. If the key is not found, no changes are made.\n\n```aiken\npairs.delete_all([], \"a\") == []\npairs.delete_all([Pair(\"a\", 1)], \"a\") == []\npairs.delete_all([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == [Pair(\"b\", 2)]\npairs.delete_all([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == [Pair(\"b\", 2)]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Pairs<key, value>",
              "optional": false
            }
          ],
          "returnType": "Pairs<key, value>",
          "line": 360,
          "raw": "pub fn delete_all(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn delete_all(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {\n  when self is {\n    [] -> []\n    [Pair(k2, v2), ..rest] ->\n      if k == k2 {\n        delete_all(rest, k)\n      } else {\n        [Pair(k2, v2), ..delete_all(rest, k)]\n      }\n  }\n}",
          "tests": [
            "test delete_all_1() {\n  delete_all([], \"a\") == []\n}",
            "test delete_all_2() {\n  delete_all([Pair(\"a\", 14)], \"a\") == []\n}",
            "test delete_all_3() {\n  let fixture = [Pair(\"a\", 14)]\n  delete_all(fixture, \"b\") == fixture\n}",
            "test delete_all_4() {\n  let fixture = [Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)]\n  delete_all(fixture, \"a\") == [Pair(\"b\", 2)]\n}"
          ]
        },
        {
          "name": "delete_first",
          "signature": "pub fn delete_first(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {",
          "documentation": "Remove a single key-value pair from the `Pairs`. If the key is not found, no changes are made.\nDuplicate keys are not deleted. Only the **first** key found is deleted.\n\n```aiken\npairs.delete_first([], \"a\") == []\npairs.delete_first([Pair(\"a\", 1)], \"a\") == []\npairs.delete_first([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == [Pair(\"b\", 2)]\npairs.delete_first([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == [Pair(\"b\", 2), Pair(\"a\", 3)]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Pairs<key, value>",
              "optional": false
            }
          ],
          "returnType": "Pairs<key, value>",
          "line": 399,
          "raw": "pub fn delete_first(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn delete_first(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {\n  when self is {\n    [] -> []\n    [Pair(k2, v2), ..rest] ->\n      if k == k2 {\n        rest\n      } else {\n        [Pair(k2, v2), ..delete_first(rest, k)]\n      }\n  }\n}",
          "tests": [
            "test delete_first_1() {\n  delete_first([], \"a\") == []\n}",
            "test delete_first_2() {\n  delete_first([Pair(\"a\", 14)], \"a\") == []\n}",
            "test delete_first_3() {\n  let fixture = [Pair(\"a\", 14)]\n  delete_first(fixture, \"b\") == fixture\n}",
            "test delete_first_4() {\n  let fixture = [Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)]\n  delete_first(fixture, \"a\") == [Pair(\"b\", 2), Pair(\"a\", 3)]\n}"
          ]
        },
        {
          "name": "delete_last",
          "signature": "pub fn delete_last(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {",
          "documentation": "Remove a single key-value pair from the Pairs. If the key is not found, no changes are made.\nDuplicate keys are not deleted. Only the **last** key found is deleted.\n\n```aiken\npairs.delete_last([], \"a\") == []\npairs.delete_last([Pair(\"a\", 1)], \"a\") == []\npairs.delete_last([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == [Pair(\"b\", 2)]\npairs.delete_last([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == [Pair(\"a\", 1), Pair(\"b\", 2)]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Pairs<key, value>",
              "optional": false
            }
          ],
          "returnType": "Pairs<key, value>",
          "line": 438,
          "raw": "pub fn delete_last(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn delete_last(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {\n  when self is {\n    [] -> []\n    [Pair(k2, v2), ..rest] ->\n      if k == k2 {\n        let tail = delete_last(rest, k)\n        if tail == rest {\n          rest\n        } else {\n          [Pair(k2, v2), ..tail]\n        }\n      } else {\n        [Pair(k2, v2), ..delete_last(rest, k)]\n      }\n  }\n}",
          "tests": [
            "test delete_last_1() {\n  delete_last([], \"a\") == []\n}",
            "test delete_last_2() {\n  delete_last([Pair(\"a\", 14)], \"a\") == []\n}",
            "test delete_last_3() {\n  let fixture = [Pair(\"a\", 14)]\n  delete_last(fixture, \"b\") == fixture\n}",
            "test delete_last_4() {\n  let fixture = [Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)]\n  delete_last(fixture, \"a\") == [Pair(\"a\", 1), Pair(\"b\", 2)]\n}"
          ]
        },
        {
          "name": "insert_by_ascending_key",
          "signature": "pub fn insert_by_ascending_key(pub fn insert_by_ascending_key(self: Pairs<key, value>, key k: key, value v: value, compare: fn(key, key) -> Ordering,",
          "documentation": "Insert a value in the `Pairs` at a given key. If the key already exists,\nthe value is added in front.\n\n> [!CAUTION]\n> The list is only traversed up to the given key and the traversal\n> stops as soon as a higher key is encountered. Said differently, the list\n> is assumed to **be ordered by ascending keys**! If it is not, expect the\n> unexpected.\n\n```aiken\nuse aiken/primitive/bytearray\n\nlet result =\n[]\n|> pairs.insert_by_ascending_key(key: \"foo\", value: 1, compare: bytearray.compare)\n|> pairs.insert_by_ascending_key(key: \"bar\", value: 2, compare: bytearray.compare)\n|> pairs.insert_by_ascending_key(key: \"foo\", value: 3, compare: bytearray.compare)\n\nresult == [Pair(\"bar\", 2), Pair(\"foo\", 3), Pair(\"foo\", 1)]\n```",
          "parameters": [],
          "returnType": "Ordering,",
          "line": 493,
          "raw": "pub fn insert_by_ascending_key(pub fn insert_by_ascending_key(self: Pairs<key, value>, key k: key, value v: value, compare: fn(key, key) -> Ordering,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn insert_by_ascending_key(\n  self: Pairs<key, value>,\n  key k: key,\n  value v: value,\n  compare: fn(key, key) -> Ordering,\n) -> Pairs<key, value> {\n  when self is {\n    [] -> [Pair(k, v)]\n    [Pair(k2, v2), ..rest] ->\n      if compare(k, k2) == Less {\n        [Pair(k, v), ..self]\n      } else {\n        if k == k2 {\n          [Pair(k, v), ..self]\n        } else {\n          [Pair(k2, v2), ..insert_by_ascending_key(rest, k, v, compare)]\n        }\n      }\n  }\n}",
          "tests": [
            "test insert_by_ascending_key_1() {\n  let m =\n    []\n      |> insert_by_ascending_key(\"foo\", 42, bytearray.compare)\n      |> insert_by_ascending_key(\"foo\", 14, bytearray.compare)\n\n  m == [Pair(\"foo\", 14), Pair(\"foo\", 42)]\n}",
            "test insert_by_ascending_key_2() {\n  let m =\n    []\n      |> insert_by_ascending_key(\"foo\", 42, bytearray.compare)\n      |> insert_by_ascending_key(\"bar\", 14, bytearray.compare)\n      |> insert_by_ascending_key(\"baz\", 1337, bytearray.compare)\n\n  m == [Pair(\"bar\", 14), Pair(\"baz\", 1337), Pair(\"foo\", 42)]\n}"
          ]
        },
        {
          "name": "insert_with_by_ascending_key",
          "signature": "pub fn insert_with_by_ascending_key(pub fn insert_with_by_ascending_key(self: Pairs<key, value>, key k: key, value v: value, compare: fn(key, key) -> Ordering, with: fn(value, value) -> value,",
          "documentation": "Like [`insert_by_ascending_key`](#insert_by_ascending_key) but specifies\nhow to combine two values on a key conflict.\n\n> [!CAUTION]\n> The list is only traversed up to the given key and the traversal\n> stops as soon as a higher key is encountered. Said differently, the list\n> is assumed to **be ordered by ascending keys**! If it is not, expect the\n> unexpected.\n\n```aiken\nuse aiken/primitive/bytearray\n\nlet add_integer = fn(x, y) { x + y }\n\nlet result =\n[]\n|> pairs.insert_with_by_ascending_key(key: \"foo\", value: 1, compare: bytearray.compare, with: add_integer)\n|> pairs.insert_with_by_ascending_key(key: \"bar\", value: 2, compare: bytearray.compare, with: add_integer)\n|> pairs.insert_with_by_ascending_key(key: \"foo\", value: 3, compare: bytearray.compare, with: add_integer)\n\nresult == [Pair(\"bar\", 2), Pair(\"foo\", 4)]\n```",
          "parameters": [],
          "returnType": "Ordering, with: fn(value, value) -> value,",
          "line": 555,
          "raw": "pub fn insert_with_by_ascending_key(pub fn insert_with_by_ascending_key(self: Pairs<key, value>, key k: key, value v: value, compare: fn(key, key) -> Ordering, with: fn(value, value) -> value,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn insert_with_by_ascending_key(\n  self: Pairs<key, value>,\n  key k: key,\n  value v: value,\n  compare: fn(key, key) -> Ordering,\n  with: fn(value, value) -> value,\n) -> Pairs<key, value> {\n  when self is {\n    [] -> [Pair(k, v)]\n    [Pair(k2, v2), ..rest] ->\n      if compare(k, k2) == Less {\n        [Pair(k, v), ..self]\n      } else {\n        if k == k2 {\n          [Pair(k, with(v, v2)), ..rest]\n        } else {\n          [\n            Pair(k2, v2),\n            ..insert_with_by_ascending_key(rest, k, v, compare, with)\n          ]\n        }\n      }\n  }\n}",
          "tests": [
            "test insert_with_by_ascending_key_1() {\n  let compare_un_b_data =\n    fn(l, r) {\n      bytearray.compare(l |> builtin.un_b_data, r |> builtin.un_b_data)\n    }\n\n  let m =\n    []\n      |> insert_with_by_ascending_key(\n          \"foo\" |> builtin.b_data,\n          42,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n      |> insert_with_by_ascending_key(\n          \"foo\" |> builtin.b_data,\n          14,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n\n  m == [Pair(\"foo\" |> builtin.b_data, 56)]\n}",
            "test insert_with_by_ascending_key_2() {\n  let compare_un_b_data =\n    fn(l, r) {\n      bytearray.compare(l |> builtin.un_b_data, r |> builtin.un_b_data)\n    }\n\n  let m =\n    []\n      |> insert_with_by_ascending_key(\n          \"foo\" |> builtin.b_data,\n          42,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n      |> insert_with_by_ascending_key(\n          \"bar\" |> builtin.b_data,\n          14,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n      |> insert_with_by_ascending_key(\n          \"baz\" |> builtin.b_data,\n          1337,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n\n  m == [\n    Pair(\"bar\" |> builtin.b_data, 14),\n    Pair(\"baz\" |> builtin.b_data, 1337),\n    Pair(\"foo\" |> builtin.b_data, 42),\n  ]\n}",
            "test insert_with_by_ascending_key_3() {\n  let compare_un_b_data =\n    fn(l, r) {\n      bytearray.compare(l |> builtin.un_b_data, r |> builtin.un_b_data)\n    }\n\n  let result =\n    []\n      |> insert_with_by_ascending_key(\n          \"foo\" |> builtin.b_data,\n          1,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n      |> insert_with_by_ascending_key(\n          \"bar\" |> builtin.b_data,\n          2,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n      |> insert_with_by_ascending_key(\n          \"foo\" |> builtin.b_data,\n          3,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n\n  result == [Pair(\"bar\" |> builtin.b_data, 2), Pair(\"foo\" |> builtin.b_data, 4)]\n}"
          ]
        },
        {
          "name": "map",
          "signature": "pub fn map(pub fn map(self: Pairs<key, value>, with: fn(key, value) -> result,",
          "documentation": "Apply a function to all key-value pairs in a alist, replacing the values.\n\n```aiken\nlet fixture = [Pair(\"a\", 100), Pair(\"b\", 200)]\n\npairs.map(fixture, fn(_k, v) { v * 2 }) == [Pair(\"a\", 200), Pair(\"b\", 400)]\n```",
          "parameters": [],
          "returnType": "result,",
          "line": 675,
          "raw": "pub fn map(pub fn map(self: Pairs<key, value>, with: fn(key, value) -> result,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn map(\n  self: Pairs<key, value>,\n  with: fn(key, value) -> result,\n) -> Pairs<key, result> {\n  when self is {\n    [] -> []\n    [Pair(k, v), ..rest] -> [Pair(k, with(k, v)), ..map(rest, with)]\n  }\n}",
          "tests": [
            "test map_1() {\n  let fixture = [Pair(\"a\", 1), Pair(\"b\", 2)]\n\n  map(fixture, with: fn(k, _) { k }) == [Pair(\"a\", \"a\"), Pair(\"b\", \"b\")]\n}",
            "test map_2() {\n  let fixture = [Pair(\"a\", 1), Pair(\"b\", 2)]\n\n  map(fixture, with: fn(_, v) { v + 1 }) == [Pair(\"a\", 2), Pair(\"b\", 3)]\n}"
          ]
        },
        {
          "name": "repsert_by_ascending_key",
          "signature": "pub fn repsert_by_ascending_key(pub fn repsert_by_ascending_key(self: Pairs<key, value>, key k: key, value v: value, compare: fn(key, key) -> Ordering,",
          "documentation": "Insert a value in the `Pairs` at a given key. If the key already exists,\nits value is replaced.\n\n> [!CAUTION]\n> The list is only traversed up to the given key and the traversal\n> stops as soon as a higher key is encountered. Said differently, the list\n> is assumed to **be ordered by ascending keys**! If it is not, expect the\n> unexpected.\n\n```aiken\nuse aiken/primitive/bytearray\n\nlet result =\n[]\n|> pairs.repsert_by_ascending_key(key: \"foo\", value: 1, compare: bytearray.compare)\n|> pairs.repsert_by_ascending_key(key: \"bar\", value: 2, compare: bytearray.compare)\n|> pairs.repsert_by_ascending_key(key: \"foo\", value: 3, compare: bytearray.compare)\n\nresult == [Pair(\"bar\", 2), Pair(\"foo\", 3)]\n```",
          "parameters": [],
          "returnType": "Ordering,",
          "line": 717,
          "raw": "pub fn repsert_by_ascending_key(pub fn repsert_by_ascending_key(self: Pairs<key, value>, key k: key, value v: value, compare: fn(key, key) -> Ordering,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn repsert_by_ascending_key(\n  self: Pairs<key, value>,\n  key k: key,\n  value v: value,\n  compare: fn(key, key) -> Ordering,\n) -> Pairs<key, value> {\n  when self is {\n    [] -> [Pair(k, v)]\n    [Pair(k2, v2), ..rest] ->\n      if compare(k, k2) == Less {\n        [Pair(k, v), ..self]\n      } else {\n        if k == k2 {\n          [Pair(k, v), ..rest]\n        } else {\n          [Pair(k2, v2), ..repsert_by_ascending_key(rest, k, v, compare)]\n        }\n      }\n  }\n}",
          "tests": [
            "test repsert_by_ascending_key_1() {\n  let m =\n    []\n      |> repsert_by_ascending_key(\"foo\", 42, bytearray.compare)\n      |> repsert_by_ascending_key(\"foo\", 14, bytearray.compare)\n\n  m == [Pair(\"foo\", 14)]\n}",
            "test repsert_by_ascending_key_2() {\n  let m =\n    []\n      |> repsert_by_ascending_key(\"foo\", 42, bytearray.compare)\n      |> repsert_by_ascending_key(\"bar\", 14, bytearray.compare)\n      |> repsert_by_ascending_key(\"baz\", 1337, bytearray.compare)\n\n  m == [Pair(\"bar\", 14), Pair(\"baz\", 1337), Pair(\"foo\", 42)]\n}"
          ]
        },
        {
          "name": "foldl",
          "signature": "pub fn foldl(pub fn foldl(self: Pairs<key, value>, zero: result, with: fn(key, value, result) -> result,",
          "documentation": "Fold over the key-value pairs in a pairs. The fold direction follows keys\nin ascending order and is done from left-to-right.\n\n```aiken\nlet fixture = [\nPair(1, 100),\nPair(2, 200),\nPair(3, 300),\n]\n\npairs.foldl(fixture, 0, fn(k, v, result) { k * v + result }) == 1400\n```",
          "parameters": [],
          "returnType": "result,",
          "line": 771,
          "raw": "pub fn foldl(pub fn foldl(self: Pairs<key, value>, zero: result, with: fn(key, value, result) -> result,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn foldl(\n  self: Pairs<key, value>,\n  zero: result,\n  with: fn(key, value, result) -> result,\n) -> result {\n  when self is {\n    [] -> zero\n    [Pair(k, v), ..rest] -> foldl(rest, with(k, v, zero), with)\n  }\n}",
          "tests": [
            "test foldl_1() {\n  foldl([], 14, fn(_, _, _) { 42 }) == 14\n}",
            "test foldl_2() {\n  foldl(\n    [Pair(\"a\", 42), Pair(\"b\", 14)],\n    zero: 0,\n    with: fn(_, v, total) { v + total },\n  ) == 56\n}"
          ]
        },
        {
          "name": "foldr",
          "signature": "pub fn foldr(pub fn foldr(self: Pairs<key, value>, zero: result, with: fn(key, value, result) -> result,",
          "documentation": "Fold over the key-value pairs in a Pairs. The fold direction follows the\norder of elements in the Pairs and is done from right-to-left.\n\n```aiken\nlet fixture = [\nPair(1, 100),\nPair(2, 200),\nPair(3, 300),\n]\n\npairs.foldr(fixture, 0, fn(k, v, result) { k * v + result }) == 1400\n```",
          "parameters": [],
          "returnType": "result,",
          "line": 806,
          "raw": "pub fn foldr(pub fn foldr(self: Pairs<key, value>, zero: result, with: fn(key, value, result) -> result,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn foldr(\n  self: Pairs<key, value>,\n  zero: result,\n  with: fn(key, value, result) -> result,\n) -> result {\n  when self is {\n    [] -> zero\n    [Pair(k, v), ..rest] -> with(k, v, foldr(rest, zero, with))\n  }\n}",
          "tests": [
            "test foldr_1() {\n  foldr([], 14, fn(_, _, _) { 42 }) == 14\n}",
            "test foldr_2() {\n  foldr(\n    [Pair(\"a\", 42), Pair(\"b\", 14)],\n    zero: 0,\n    with: fn(_, v, total) { v + total },\n  ) == 56\n}",
            "test foldr_3() {\n  let fixture = [Pair(1, 100), Pair(2, 200), Pair(3, 300)]\n\n  foldr(fixture, 0, fn(k, v, result) { k * v + result }) == 1400\n}"
          ]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "//// A module for working with associative lists (a.k.a `Pairs`).\n////\n//// While any function that works on `List` also work on `Pairs`, this module provides some extra helpers\n//// that are specifically tailored to working with associative lists. Fundamentally, a `Pairs<k, v>` is\n//// a type-alias to `List<Pair<k, v>>`.\n////\n//// > [!CAUTION]\n//// >\n//// > Unlike dictionnaries (a.k.a. [`Dict`](./dict.html#Dict), associative lists make no assumption\n//// > about the ordering of elements within the list. As a result, lookup\n//// > functions do traverse the entire list when invoked. They are also not _sets_,\n//// > and thus allow for duplicate keys. This is reflected in the functions used\n//// > to interact with them.\n\nuse aiken/builtin\nuse aiken/primitive/bytearray\n\n// ## Inspecting\n\n/// Get all values in the alist associated with a given key.\n///\n/// ```aiken\n/// pairs.get_all([], \"a\") == []\n/// pairs.get_all([Pair(\"a\", 1)], \"a\") == [1]\n/// pairs.get_all([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == [1]\n/// pairs.get_all([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == [1, 3]\n/// ```\npub fn get_all(self: Pairs<key, value>, key k: key) -> List<value> {\n  when self is {\n    [] -> []\n    [Pair(k2, v), ..rest] ->\n      if k == k2 {\n        [v, ..get_all(rest, k)]\n      } else {\n        get_all(rest, k)\n      }\n  }\n}\n\ntest get_all_1() {\n  get_all([], \"a\") == []\n}\n\ntest get_all_2() {\n  get_all([Pair(\"a\", 1)], \"a\") == [1]\n}\n\ntest get_all_3() {\n  get_all([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == [1]\n}\n\ntest get_all_4() {\n  get_all([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == [1, 3]\n}\n\ntest get_all_5() {\n  get_all([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"c\", 3)], \"d\") == []\n}\n\n/// Get the value in the alist by its key.\n/// If multiple values with the same key exist, only the first one is returned.\n///\n/// ```aiken\n/// pairs.get_first([], \"a\") == None\n/// pairs.get_first([Pair(\"a\", 1)], \"a\") == Some(1)\n/// pairs.get_first([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == Some(1)\n/// pairs.get_first([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == Some(1)\n/// ```\npub fn get_first(self: Pairs<key, value>, key k: key) -> Option<value> {\n  when self is {\n    [] -> None\n    [Pair(k2, v), ..rest] ->\n      if k == k2 {\n        Some(v)\n      } else {\n        get_first(rest, k)\n      }\n  }\n}\n\ntest get_first_1() {\n  get_first([], \"a\") == None\n}\n\ntest get_first_2() {\n  get_first([Pair(\"a\", 1)], \"a\") == Some(1)\n}\n\ntest get_first_3() {\n  get_first([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == Some(1)\n}\n\ntest get_first_4() {\n  get_first([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == Some(1)\n}\n\ntest get_first_5() {\n  get_first([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"c\", 3)], \"d\") == None\n}\n\n/// Get the value in the alist by its key.\n/// If multiple values with the same key exist, only the last one is returned.\n///\n/// ```aiken\n/// pairs.get_last([], \"a\") == None\n/// pairs.get_last([Pair(\"a\", 1)], \"a\") == Some(1)\n/// pairs.get_last([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == Some(1)\n/// pairs.get_last([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == Some(3)\n/// ```\npub fn get_last(self: Pairs<key, value>, key k: key) -> Option<value> {\n  when self is {\n    [] -> None\n    [Pair(k2, v), ..rest] ->\n      if k == k2 {\n        when get_last(rest, k) is {\n          None -> Some(v)\n          some -> some\n        }\n      } else {\n        get_last(rest, k)\n      }\n  }\n}\n\ntest get_last_1() {\n  get_last([], \"a\") == None\n}\n\ntest get_last_2() {\n  get_last([Pair(\"a\", 1)], \"a\") == Some(1)\n}\n\ntest get_last_3() {\n  get_last([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == Some(1)\n}\n\ntest get_last_4() {\n  get_last([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == Some(3)\n}\n\ntest get_last_5() {\n  get_last([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"c\", 3)], \"d\") == None\n}\n\n/// Finds all keys in the alist associated with a given value.\n///\n/// ```aiken\n/// pairs.find_all([], 1) == []\n/// pairs.find_all([Pair(\"a\", 1)], 1) == [\"a\"]\n/// pairs.find_all([Pair(\"a\", 1), Pair(\"b\", 2)], 1) == [\"a\"]\n/// pairs.find_all([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"c\", 1)], 1) == [\"a\", \"c\"]\n/// ```\npub fn find_all(self: Pairs<key, value>, v: value) -> List<key> {\n  when self is {\n    [] -> []\n    [Pair(k2, v2), ..rest] ->\n      if v == v2 {\n        [k2, ..find_all(rest, v)]\n      } else {\n        find_all(rest, v)\n      }\n  }\n}\n\ntest find_all_1() {\n  find_all([], \"a\") == []\n}\n\ntest find_all_2() {\n  find_all([Pair(\"a\", 14)], 14) == [\"a\"]\n}\n\ntest find_all_3() {\n  find_all([Pair(\"a\", 14)], 42) == []\n}\n\ntest find_all_4() {\n  find_all([Pair(\"a\", 14), Pair(\"b\", 42), Pair(\"c\", 14)], 14) == [\"a\", \"c\"]\n}\n\n/// Finds the first key in the alist associated with a given value, if any.\n///\n/// ```aiken\n/// pairs.find_first([], 1) == None\n/// pairs.find_first([Pair(\"a\", 1)], 1) == Some(\"a\")\n/// pairs.find_first([Pair(\"a\", 1), Pair(\"b\", 2)], 1) == Some(\"a\")\n/// pairs.find_first([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"c\", 1)], 1) == Some(\"a\")\n/// ```\npub fn find_first(self: Pairs<key, value>, v: value) -> Option<key> {\n  when self is {\n    [] -> None\n    [Pair(k2, v2), ..rest] ->\n      if v == v2 {\n        Some(k2)\n      } else {\n        find_first(rest, v)\n      }\n  }\n}\n\ntest find_first_1() {\n  find_first([], \"a\") == None\n}\n\ntest find_first_2() {\n  find_first([Pair(\"a\", 14)], 14) == Some(\"a\")\n}\n\ntest find_first_3() {\n  find_first([Pair(\"a\", 14)], 42) == None\n}\n\ntest find_first_4() {\n  find_first([Pair(\"a\", 14), Pair(\"b\", 42), Pair(\"c\", 14)], 14) == Some(\"a\")\n}\n\n/// Finds the last key in the alist associated with a given value, if any.\n///\n/// ```aiken\n/// pairs.find_last([], 1) == None\n/// pairs.find_last([Pair(\"a\", 1)], 1) == Some(\"a\")\n/// pairs.find_last([Pair(\"a\", 1), Pair(\"b\", 2)], 1) == Some(\"a\")\n/// pairs.find_last([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"c\", 1)], 1) == Some(\"c\")\n/// ```\npub fn find_last(self: Pairs<key, value>, v: value) -> Option<key> {\n  when self is {\n    [] -> None\n    [Pair(k2, v2), ..rest] ->\n      if v == v2 {\n        when find_last(rest, v) is {\n          None -> Some(k2)\n          some -> some\n        }\n      } else {\n        find_last(rest, v)\n      }\n  }\n}\n\ntest find_last_1() {\n  find_last([], \"a\") == None\n}\n\ntest find_last_2() {\n  find_last([Pair(\"a\", 14)], 14) == Some(\"a\")\n}\n\ntest find_last_3() {\n  find_last([Pair(\"a\", 14)], 42) == None\n}\n\ntest find_last_4() {\n  find_last([Pair(\"a\", 14), Pair(\"b\", 42), Pair(\"c\", 14)], 14) == Some(\"c\")\n}\n\n/// Check if a key exists in the pairs.\n///\n/// ```aiken\n/// pairs.has_key([], \"a\") == False\n/// pairs.has_key([Pair(\"a\", 1)], \"a\") == True\n/// pairs.has_key([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == True\n/// pairs.has_key([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == True\n/// ```\npub fn has_key(self: Pairs<key, value>, k: key) -> Bool {\n  when self is {\n    [] -> False\n    // || is lazy so this is fine\n    [Pair(k2, _), ..rest] -> k == k2 || has_key(rest, k)\n  }\n}\n\ntest has_key_1() {\n  !has_key([], \"a\")\n}\n\ntest has_key_2() {\n  has_key([Pair(\"a\", 14)], \"a\")\n}\n\ntest has_key_3() {\n  !has_key([Pair(\"a\", 14)], \"b\")\n}\n\ntest has_key_4() {\n  has_key([Pair(\"a\", 14), Pair(\"b\", 42)], \"b\")\n}\n\ntest has_key_5() {\n  has_key([Pair(\"a\", 14), Pair(\"b\", 42), Pair(\"a\", 42)], \"a\")\n}\n\n/// Extract all the keys present in a given `Pairs`.\n///\n/// ```aiken\n/// pairs.keys([]) == []\n/// pairs.keys([Pair(\"a\", 1)]) == [\"a\"]\n/// pairs.keys([Pair(\"a\", 1), Pair(\"b\", 2)]) == [\"a\", \"b\"]\n/// pairs.keys([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)]) == [\"a\", \"b\", \"a\"]\n/// ```\npub fn keys(self: Pairs<key, value>) -> List<key> {\n  when self is {\n    [] -> []\n    [Pair(k, _), ..rest] -> [k, ..keys(rest)]\n  }\n}\n\ntest keys_1() {\n  keys([]) == []\n}\n\ntest keys_2() {\n  keys([Pair(\"a\", 0)]) == [\"a\"]\n}\n\ntest keys_3() {\n  keys([Pair(\"a\", 0), Pair(\"b\", 0)]) == [\"a\", \"b\"]\n}\n\n/// Extract all the values present in a given `Pairs`.\n///\n/// ```aiken\n/// pairs.values([]) == []\n/// pairs.values([Pair(\"a\", 1)]) == [1]\n/// pairs.values([Pair(\"a\", 1), Pair(\"b\", 2)]) == [1, 2]\n/// pairs.values([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)]) == [1, 2, 3]\n/// ```\npub fn values(self: Pairs<key, value>) -> List<value> {\n  when self is {\n    [] -> []\n    [Pair(_, v), ..rest] -> [v, ..values(rest)]\n  }\n}\n\ntest values_1() {\n  values([]) == []\n}\n\ntest values_2() {\n  values([Pair(\"a\", 1)]) == [1]\n}\n\ntest values_3() {\n  values([Pair(\"a\", 1), Pair(\"b\", 2)]) == [1, 2]\n}\n\ntest values_4() {\n  values([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)]) == [1, 2, 3]\n}\n\n// ## Modifying\n\n/// Remove all key-value pairs matching the key from the Pairs. If the key is not found, no changes are made.\n///\n/// ```aiken\n/// pairs.delete_all([], \"a\") == []\n/// pairs.delete_all([Pair(\"a\", 1)], \"a\") == []\n/// pairs.delete_all([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == [Pair(\"b\", 2)]\n/// pairs.delete_all([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == [Pair(\"b\", 2)]\n/// ```\npub fn delete_all(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {\n  when self is {\n    [] -> []\n    [Pair(k2, v2), ..rest] ->\n      if k == k2 {\n        delete_all(rest, k)\n      } else {\n        [Pair(k2, v2), ..delete_all(rest, k)]\n      }\n  }\n}\n\ntest delete_all_1() {\n  delete_all([], \"a\") == []\n}\n\ntest delete_all_2() {\n  delete_all([Pair(\"a\", 14)], \"a\") == []\n}\n\ntest delete_all_3() {\n  let fixture = [Pair(\"a\", 14)]\n  delete_all(fixture, \"b\") == fixture\n}\n\ntest delete_all_4() {\n  let fixture = [Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)]\n  delete_all(fixture, \"a\") == [Pair(\"b\", 2)]\n}\n\n/// Remove a single key-value pair from the `Pairs`. If the key is not found, no changes are made.\n/// Duplicate keys are not deleted. Only the **first** key found is deleted.\n///\n/// ```aiken\n/// pairs.delete_first([], \"a\") == []\n/// pairs.delete_first([Pair(\"a\", 1)], \"a\") == []\n/// pairs.delete_first([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == [Pair(\"b\", 2)]\n/// pairs.delete_first([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == [Pair(\"b\", 2), Pair(\"a\", 3)]\n/// ```\npub fn delete_first(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {\n  when self is {\n    [] -> []\n    [Pair(k2, v2), ..rest] ->\n      if k == k2 {\n        rest\n      } else {\n        [Pair(k2, v2), ..delete_first(rest, k)]\n      }\n  }\n}\n\ntest delete_first_1() {\n  delete_first([], \"a\") == []\n}\n\ntest delete_first_2() {\n  delete_first([Pair(\"a\", 14)], \"a\") == []\n}\n\ntest delete_first_3() {\n  let fixture = [Pair(\"a\", 14)]\n  delete_first(fixture, \"b\") == fixture\n}\n\ntest delete_first_4() {\n  let fixture = [Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)]\n  delete_first(fixture, \"a\") == [Pair(\"b\", 2), Pair(\"a\", 3)]\n}\n\n/// Remove a single key-value pair from the Pairs. If the key is not found, no changes are made.\n/// Duplicate keys are not deleted. Only the **last** key found is deleted.\n///\n/// ```aiken\n/// pairs.delete_last([], \"a\") == []\n/// pairs.delete_last([Pair(\"a\", 1)], \"a\") == []\n/// pairs.delete_last([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == [Pair(\"b\", 2)]\n/// pairs.delete_last([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == [Pair(\"a\", 1), Pair(\"b\", 2)]\n/// ```\npub fn delete_last(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {\n  when self is {\n    [] -> []\n    [Pair(k2, v2), ..rest] ->\n      if k == k2 {\n        let tail = delete_last(rest, k)\n        if tail == rest {\n          rest\n        } else {\n          [Pair(k2, v2), ..tail]\n        }\n      } else {\n        [Pair(k2, v2), ..delete_last(rest, k)]\n      }\n  }\n}\n\ntest delete_last_1() {\n  delete_last([], \"a\") == []\n}\n\ntest delete_last_2() {\n  delete_last([Pair(\"a\", 14)], \"a\") == []\n}\n\ntest delete_last_3() {\n  let fixture = [Pair(\"a\", 14)]\n  delete_last(fixture, \"b\") == fixture\n}\n\ntest delete_last_4() {\n  let fixture = [Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)]\n  delete_last(fixture, \"a\") == [Pair(\"a\", 1), Pair(\"b\", 2)]\n}\n\n/// Insert a value in the `Pairs` at a given key. If the key already exists,\n/// the value is added in front.\n///\n/// > [!CAUTION]\n/// > The list is only traversed up to the given key and the traversal\n/// > stops as soon as a higher key is encountered. Said differently, the list\n/// > is assumed to **be ordered by ascending keys**! If it is not, expect the\n/// > unexpected.\n///\n/// ```aiken\n/// use aiken/primitive/bytearray\n///\n/// let result =\n///   []\n///     |> pairs.insert_by_ascending_key(key: \"foo\", value: 1, compare: bytearray.compare)\n///     |> pairs.insert_by_ascending_key(key: \"bar\", value: 2, compare: bytearray.compare)\n///     |> pairs.insert_by_ascending_key(key: \"foo\", value: 3, compare: bytearray.compare)\n///\n/// result == [Pair(\"bar\", 2), Pair(\"foo\", 3), Pair(\"foo\", 1)]\n/// ```\npub fn insert_by_ascending_key(\n  self: Pairs<key, value>,\n  key k: key,\n  value v: value,\n  compare: fn(key, key) -> Ordering,\n) -> Pairs<key, value> {\n  when self is {\n    [] -> [Pair(k, v)]\n    [Pair(k2, v2), ..rest] ->\n      if compare(k, k2) == Less {\n        [Pair(k, v), ..self]\n      } else {\n        if k == k2 {\n          [Pair(k, v), ..self]\n        } else {\n          [Pair(k2, v2), ..insert_by_ascending_key(rest, k, v, compare)]\n        }\n      }\n  }\n}\n\ntest insert_by_ascending_key_1() {\n  let m =\n    []\n      |> insert_by_ascending_key(\"foo\", 42, bytearray.compare)\n      |> insert_by_ascending_key(\"foo\", 14, bytearray.compare)\n\n  m == [Pair(\"foo\", 14), Pair(\"foo\", 42)]\n}\n\ntest insert_by_ascending_key_2() {\n  let m =\n    []\n      |> insert_by_ascending_key(\"foo\", 42, bytearray.compare)\n      |> insert_by_ascending_key(\"bar\", 14, bytearray.compare)\n      |> insert_by_ascending_key(\"baz\", 1337, bytearray.compare)\n\n  m == [Pair(\"bar\", 14), Pair(\"baz\", 1337), Pair(\"foo\", 42)]\n}\n\n/// Like [`insert_by_ascending_key`](#insert_by_ascending_key) but specifies\n/// how to combine two values on a key conflict.\n///\n/// > [!CAUTION]\n/// > The list is only traversed up to the given key and the traversal\n/// > stops as soon as a higher key is encountered. Said differently, the list\n/// > is assumed to **be ordered by ascending keys**! If it is not, expect the\n/// > unexpected.\n///\n/// ```aiken\n/// use aiken/primitive/bytearray\n///\n/// let add_integer = fn(x, y) { x + y }\n///\n/// let result =\n///   []\n///     |> pairs.insert_with_by_ascending_key(key: \"foo\", value: 1, compare: bytearray.compare, with: add_integer)\n///     |> pairs.insert_with_by_ascending_key(key: \"bar\", value: 2, compare: bytearray.compare, with: add_integer)\n///     |> pairs.insert_with_by_ascending_key(key: \"foo\", value: 3, compare: bytearray.compare, with: add_integer)\n///\n/// result == [Pair(\"bar\", 2), Pair(\"foo\", 4)]\n/// ```\npub fn insert_with_by_ascending_key(\n  self: Pairs<key, value>,\n  key k: key,\n  value v: value,\n  compare: fn(key, key) -> Ordering,\n  with: fn(value, value) -> value,\n) -> Pairs<key, value> {\n  when self is {\n    [] -> [Pair(k, v)]\n    [Pair(k2, v2), ..rest] ->\n      if compare(k, k2) == Less {\n        [Pair(k, v), ..self]\n      } else {\n        if k == k2 {\n          [Pair(k, with(v, v2)), ..rest]\n        } else {\n          [\n            Pair(k2, v2),\n            ..insert_with_by_ascending_key(rest, k, v, compare, with)\n          ]\n        }\n      }\n  }\n}\n\ntest insert_with_by_ascending_key_1() {\n  let compare_un_b_data =\n    fn(l, r) {\n      bytearray.compare(l |> builtin.un_b_data, r |> builtin.un_b_data)\n    }\n\n  let m =\n    []\n      |> insert_with_by_ascending_key(\n          \"foo\" |> builtin.b_data,\n          42,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n      |> insert_with_by_ascending_key(\n          \"foo\" |> builtin.b_data,\n          14,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n\n  m == [Pair(\"foo\" |> builtin.b_data, 56)]\n}\n\ntest insert_with_by_ascending_key_2() {\n  let compare_un_b_data =\n    fn(l, r) {\n      bytearray.compare(l |> builtin.un_b_data, r |> builtin.un_b_data)\n    }\n\n  let m =\n    []\n      |> insert_with_by_ascending_key(\n          \"foo\" |> builtin.b_data,\n          42,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n      |> insert_with_by_ascending_key(\n          \"bar\" |> builtin.b_data,\n          14,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n      |> insert_with_by_ascending_key(\n          \"baz\" |> builtin.b_data,\n          1337,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n\n  m == [\n    Pair(\"bar\" |> builtin.b_data, 14),\n    Pair(\"baz\" |> builtin.b_data, 1337),\n    Pair(\"foo\" |> builtin.b_data, 42),\n  ]\n}\n\ntest insert_with_by_ascending_key_3() {\n  let compare_un_b_data =\n    fn(l, r) {\n      bytearray.compare(l |> builtin.un_b_data, r |> builtin.un_b_data)\n    }\n\n  let result =\n    []\n      |> insert_with_by_ascending_key(\n          \"foo\" |> builtin.b_data,\n          1,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n      |> insert_with_by_ascending_key(\n          \"bar\" |> builtin.b_data,\n          2,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n      |> insert_with_by_ascending_key(\n          \"foo\" |> builtin.b_data,\n          3,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n\n  result == [Pair(\"bar\" |> builtin.b_data, 2), Pair(\"foo\" |> builtin.b_data, 4)]\n}\n\n/// Apply a function to all key-value pairs in a alist, replacing the values.\n///\n/// ```aiken\n/// let fixture = [Pair(\"a\", 100), Pair(\"b\", 200)]\n///\n/// pairs.map(fixture, fn(_k, v) { v * 2 }) == [Pair(\"a\", 200), Pair(\"b\", 400)]\n/// ```\npub fn map(\n  self: Pairs<key, value>,\n  with: fn(key, value) -> result,\n) -> Pairs<key, result> {\n  when self is {\n    [] -> []\n    [Pair(k, v), ..rest] -> [Pair(k, with(k, v)), ..map(rest, with)]\n  }\n}\n\ntest map_1() {\n  let fixture = [Pair(\"a\", 1), Pair(\"b\", 2)]\n\n  map(fixture, with: fn(k, _) { k }) == [Pair(\"a\", \"a\"), Pair(\"b\", \"b\")]\n}\n\ntest map_2() {\n  let fixture = [Pair(\"a\", 1), Pair(\"b\", 2)]\n\n  map(fixture, with: fn(_, v) { v + 1 }) == [Pair(\"a\", 2), Pair(\"b\", 3)]\n}\n\n/// Insert a value in the `Pairs` at a given key. If the key already exists,\n/// its value is replaced.\n///\n/// > [!CAUTION]\n/// > The list is only traversed up to the given key and the traversal\n/// > stops as soon as a higher key is encountered. Said differently, the list\n/// > is assumed to **be ordered by ascending keys**! If it is not, expect the\n/// > unexpected.\n///\n/// ```aiken\n/// use aiken/primitive/bytearray\n///\n/// let result =\n///   []\n///     |> pairs.repsert_by_ascending_key(key: \"foo\", value: 1, compare: bytearray.compare)\n///     |> pairs.repsert_by_ascending_key(key: \"bar\", value: 2, compare: bytearray.compare)\n///     |> pairs.repsert_by_ascending_key(key: \"foo\", value: 3, compare: bytearray.compare)\n///\n/// result == [Pair(\"bar\", 2), Pair(\"foo\", 3)]\n/// ```\npub fn repsert_by_ascending_key(\n  self: Pairs<key, value>,\n  key k: key,\n  value v: value,\n  compare: fn(key, key) -> Ordering,\n) -> Pairs<key, value> {\n  when self is {\n    [] -> [Pair(k, v)]\n    [Pair(k2, v2), ..rest] ->\n      if compare(k, k2) == Less {\n        [Pair(k, v), ..self]\n      } else {\n        if k == k2 {\n          [Pair(k, v), ..rest]\n        } else {\n          [Pair(k2, v2), ..repsert_by_ascending_key(rest, k, v, compare)]\n        }\n      }\n  }\n}\n\ntest repsert_by_ascending_key_1() {\n  let m =\n    []\n      |> repsert_by_ascending_key(\"foo\", 42, bytearray.compare)\n      |> repsert_by_ascending_key(\"foo\", 14, bytearray.compare)\n\n  m == [Pair(\"foo\", 14)]\n}\n\ntest repsert_by_ascending_key_2() {\n  let m =\n    []\n      |> repsert_by_ascending_key(\"foo\", 42, bytearray.compare)\n      |> repsert_by_ascending_key(\"bar\", 14, bytearray.compare)\n      |> repsert_by_ascending_key(\"baz\", 1337, bytearray.compare)\n\n  m == [Pair(\"bar\", 14), Pair(\"baz\", 1337), Pair(\"foo\", 42)]\n}\n\n// ## Transforming\n\n/// Fold over the key-value pairs in a pairs. The fold direction follows keys\n/// in ascending order and is done from left-to-right.\n///\n/// ```aiken\n/// let fixture = [\n///   Pair(1, 100),\n///   Pair(2, 200),\n///   Pair(3, 300),\n/// ]\n///\n/// pairs.foldl(fixture, 0, fn(k, v, result) { k * v + result }) == 1400\n/// ```\npub fn foldl(\n  self: Pairs<key, value>,\n  zero: result,\n  with: fn(key, value, result) -> result,\n) -> result {\n  when self is {\n    [] -> zero\n    [Pair(k, v), ..rest] -> foldl(rest, with(k, v, zero), with)\n  }\n}\n\ntest foldl_1() {\n  foldl([], 14, fn(_, _, _) { 42 }) == 14\n}\n\ntest foldl_2() {\n  foldl(\n    [Pair(\"a\", 42), Pair(\"b\", 14)],\n    zero: 0,\n    with: fn(_, v, total) { v + total },\n  ) == 56\n}\n\n/// Fold over the key-value pairs in a Pairs. The fold direction follows the\n/// order of elements in the Pairs and is done from right-to-left.\n///\n/// ```aiken\n/// let fixture = [\n///   Pair(1, 100),\n///   Pair(2, 200),\n///   Pair(3, 300),\n/// ]\n///\n/// pairs.foldr(fixture, 0, fn(k, v, result) { k * v + result }) == 1400\n/// ```\npub fn foldr(\n  self: Pairs<key, value>,\n  zero: result,\n  with: fn(key, value, result) -> result,\n) -> result {\n  when self is {\n    [] -> zero\n    [Pair(k, v), ..rest] -> with(k, v, foldr(rest, zero, with))\n  }\n}\n\ntest foldr_1() {\n  foldr([], 14, fn(_, _, _) { 42 }) == 14\n}\n\ntest foldr_2() {\n  foldr(\n    [Pair(\"a\", 42), Pair(\"b\", 14)],\n    zero: 0,\n    with: fn(_, v, total) { v + total },\n  ) == 56\n}\n\ntest foldr_3() {\n  let fixture = [Pair(1, 100), Pair(2, 200), Pair(3, 300)]\n\n  foldr(fixture, 0, fn(k, v, result) { k * v + result }) == 1400\n}\n",
      "dependencies": ["aiken/builtin", "aiken/primitive/bytearray"],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.collection",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/collection.ak",
      "name": "aiken.collection",
      "imports": [],
      "functions": [],
      "types": [
        {
          "name": "Index",
          "definition": "Int",
          "line": 3,
          "raw": "pub type Index =",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "/// A non negative integer that materializes the position of an element in a\n/// collection.\npub type Index =\n  Int\n",
      "dependencies": [],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.crypto.bitwise",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/crypto/bitwise.ak",
      "name": "aiken.crypto.bitwise",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 3,
          "raw": "use aiken/builtin",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "add_bits",
          "signature": "pub fn add_bits(field: Int, big_endian: Bool) {",
          "parameters": [
            {
              "name": "field",
              "type": "Int",
              "optional": false
            },
            {
              "name": "big_endian",
              "type": "Bool",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 13,
          "raw": "pub fn add_bits(field: Int, big_endian: Bool) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn add_bits(field: Int, big_endian: Bool) {\n  fn(state: State<t>, bytes: ByteArray) -> State<t> {\n    builtin.bytearray_to_integer(big_endian, bytes)\n      |> builtin.add_integer(state.inner, _)\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}"
        },
        {
          "name": "add_int",
          "signature": "pub fn add_int(field: Int) {",
          "parameters": [
            {
              "name": "field",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 22,
          "raw": "pub fn add_int(field: Int) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn add_int(field: Int) {\n  fn(state: State<t>, int: Int) -> State<t> {\n    state.inner + int\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}"
        },
        {
          "name": "add_state",
          "signature": "pub fn add_state(field: Int) {",
          "parameters": [
            {
              "name": "field",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 30,
          "raw": "pub fn add_state(field: Int) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn add_state(field: Int) {\n  fn(state: State<t>, other: State<t>) -> State<t> {\n    state.inner + other.inner\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}"
        },
        {
          "name": "sub_bits",
          "signature": "pub fn sub_bits(field: Int, big_endian: Bool) {",
          "parameters": [
            {
              "name": "field",
              "type": "Int",
              "optional": false
            },
            {
              "name": "big_endian",
              "type": "Bool",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 38,
          "raw": "pub fn sub_bits(field: Int, big_endian: Bool) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sub_bits(field: Int, big_endian: Bool) {\n  fn(state: State<t>, bytes: ByteArray) -> State<t> {\n    builtin.bytearray_to_integer(big_endian, bytes)\n      |> builtin.subtract_integer(state.inner, _)\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}"
        },
        {
          "name": "sub_int",
          "signature": "pub fn sub_int(field: Int) {",
          "parameters": [
            {
              "name": "field",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 47,
          "raw": "pub fn sub_int(field: Int) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sub_int(field: Int) {\n  fn(state: State<t>, int: Int) -> State<t> {\n    state.inner - int\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}"
        },
        {
          "name": "sub_state",
          "signature": "pub fn sub_state(field: Int) {",
          "parameters": [
            {
              "name": "field",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 55,
          "raw": "pub fn sub_state(field: Int) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sub_state(field: Int) {\n  fn(state: State<t>, other: State<t>) -> State<t> {\n    state.inner - other.inner\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}"
        },
        {
          "name": "mul_bits",
          "signature": "pub fn mul_bits(field: Int, big_endian: Bool) {",
          "parameters": [
            {
              "name": "field",
              "type": "Int",
              "optional": false
            },
            {
              "name": "big_endian",
              "type": "Bool",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 63,
          "raw": "pub fn mul_bits(field: Int, big_endian: Bool) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn mul_bits(field: Int, big_endian: Bool) {\n  fn(state: State<t>, bytes: ByteArray) -> State<t> {\n    builtin.bytearray_to_integer(big_endian, bytes)\n      |> builtin.multiply_integer(state.inner, _)\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}"
        },
        {
          "name": "mul_int",
          "signature": "pub fn mul_int(field: Int) {",
          "parameters": [
            {
              "name": "field",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 72,
          "raw": "pub fn mul_int(field: Int) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn mul_int(field: Int) {\n  fn(state: State<t>, int: Int) -> State<t> {\n    state.inner * int\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}"
        },
        {
          "name": "mul_state",
          "signature": "pub fn mul_state(field: Int) {",
          "parameters": [
            {
              "name": "field",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 80,
          "raw": "pub fn mul_state(field: Int) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn mul_state(field: Int) {\n  fn(state: State<t>, other: State<t>) -> State<t> {\n    state.inner * other.inner\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}"
        },
        {
          "name": "scale",
          "signature": "pub fn scale(pub fn scale(self: State<t>, e: Int, mul: fn(State<t>, State<t>) -> State<t>,",
          "parameters": [],
          "returnType": "State<t>,",
          "line": 88,
          "raw": "pub fn scale(pub fn scale(self: State<t>, e: Int, mul: fn(State<t>, State<t>) -> State<t>,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn scale(\n  self: State<t>,\n  e: Int,\n  mul: fn(State<t>, State<t>) -> State<t>,\n) -> State<t> {\n  if e < 0 {\n    zero\n  } else if e == 0 {\n    one\n  } else if e % 2 == 0 {\n    scale(mul(self, self), e / 2, mul)\n  } else {\n    mul(self, scale(mul(self, self), ( e - 1 ) / 2, mul))\n  }\n}"
        },
        {
          "name": "scale2",
          "signature": "pub fn scale2(self: State<t>, k: Int, mul: fn(State<t>, State<t>) -> State<t>) {",
          "documentation": "A faster version of `scale` for the case where the exponent is a power of two.\nThat is, the exponent $e = 2^k$ for some non-negative integer $k$. Which is used a lot in zk-SNARKs.",
          "parameters": [
            {
              "name": "self",
              "type": "State<t>",
              "optional": false
            },
            {
              "name": "k",
              "type": "Int",
              "optional": false
            },
            {
              "name": "mul",
              "type": "fn(State<t>, State<t>",
              "optional": false
            }
          ],
          "returnType": "State<t>)",
          "line": 106,
          "raw": "pub fn scale2(self: State<t>, k: Int, mul: fn(State<t>, State<t>) -> State<t>) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn scale2(self: State<t>, k: Int, mul: fn(State<t>, State<t>) -> State<t>) {\n  if k < 0 {\n    zero\n  } else {\n    do_scale2(self, k, mul)\n  }\n}"
        },
        {
          "name": "neg",
          "signature": "pub fn neg(field: Int) {",
          "parameters": [
            {
              "name": "field",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 122,
          "raw": "pub fn neg(field: Int) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn neg(field: Int) {\n  fn(state: State<t>) -> State<t> {\n    ( field - state.inner ) % field\n      |> State\n  }\n}"
        },
        {
          "name": "to_int",
          "signature": "pub fn to_int(state: State<t>) -> Int {",
          "parameters": [
            {
              "name": "state",
              "type": "State<t>",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 129,
          "raw": "pub fn to_int(state: State<t>) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn to_int(state: State<t>) -> Int {\n  state.inner\n}"
        },
        {
          "name": "from_int",
          "signature": "pub fn from_int(int: Int, field: Int) -> State<t> {",
          "parameters": [
            {
              "name": "int",
              "type": "Int",
              "optional": false
            },
            {
              "name": "field",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "State<t>",
          "line": 133,
          "raw": "pub fn from_int(int: Int, field: Int) -> State<t> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_int(int: Int, field: Int) -> State<t> {\n  int % field\n    |> State\n}"
        }
      ],
      "types": [
        {
          "name": "State<t>",
          "definition": "opaque { inner: Int, }",
          "line": 5,
          "raw": "pub opaque type State<t> {",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "constants": [
        {
          "name": "zero",
          "type": "Unknown",
          "value": "State { inner: 0 }",
          "line": 9,
          "raw": "pub const zero = State { inner: 0 }",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "one",
          "type": "Unknown",
          "value": "State { inner: 1 }",
          "line": 11,
          "raw": "pub const one = State { inner: 1 }",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "atoms": [
        {
          "name": "do_scale2",
          "signature": "fn do_scale2(self: State<t>, k: Int, mul) -> State<t> {",
          "parameters": [
            {
              "name": "self",
              "type": "State<t>",
              "optional": false
            },
            {
              "name": "k",
              "type": "Int",
              "optional": false
            },
            {
              "name": "mul",
              "type": "Unknown",
              "optional": false
            }
          ],
          "returnType": "State<t>",
          "line": 114,
          "raw": "fn do_scale2(self: State<t>, k: Int, mul) -> State<t> {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_scale2(self: State<t>, k: Int, mul) -> State<t> {\n  if k == 0 {\n    self\n  } else {\n    do_scale2(mul(self, self), k - 1, mul)\n  }\n}"
        }
      ],
      "privateTypes": [],
      "privateConstants": [],
      "content": "//// @hidden\n\nuse aiken/builtin\n\npub opaque type State<t> {\n  inner: Int,\n}\n\npub const zero = State { inner: 0 }\n\npub const one = State { inner: 1 }\n\npub fn add_bits(field: Int, big_endian: Bool) {\n  fn(state: State<t>, bytes: ByteArray) -> State<t> {\n    builtin.bytearray_to_integer(big_endian, bytes)\n      |> builtin.add_integer(state.inner, _)\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}\n\npub fn add_int(field: Int) {\n  fn(state: State<t>, int: Int) -> State<t> {\n    state.inner + int\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}\n\npub fn add_state(field: Int) {\n  fn(state: State<t>, other: State<t>) -> State<t> {\n    state.inner + other.inner\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}\n\npub fn sub_bits(field: Int, big_endian: Bool) {\n  fn(state: State<t>, bytes: ByteArray) -> State<t> {\n    builtin.bytearray_to_integer(big_endian, bytes)\n      |> builtin.subtract_integer(state.inner, _)\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}\n\npub fn sub_int(field: Int) {\n  fn(state: State<t>, int: Int) -> State<t> {\n    state.inner - int\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}\n\npub fn sub_state(field: Int) {\n  fn(state: State<t>, other: State<t>) -> State<t> {\n    state.inner - other.inner\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}\n\npub fn mul_bits(field: Int, big_endian: Bool) {\n  fn(state: State<t>, bytes: ByteArray) -> State<t> {\n    builtin.bytearray_to_integer(big_endian, bytes)\n      |> builtin.multiply_integer(state.inner, _)\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}\n\npub fn mul_int(field: Int) {\n  fn(state: State<t>, int: Int) -> State<t> {\n    state.inner * int\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}\n\npub fn mul_state(field: Int) {\n  fn(state: State<t>, other: State<t>) -> State<t> {\n    state.inner * other.inner\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}\n\npub fn scale(\n  self: State<t>,\n  e: Int,\n  mul: fn(State<t>, State<t>) -> State<t>,\n) -> State<t> {\n  if e < 0 {\n    zero\n  } else if e == 0 {\n    one\n  } else if e % 2 == 0 {\n    scale(mul(self, self), e / 2, mul)\n  } else {\n    mul(self, scale(mul(self, self), ( e - 1 ) / 2, mul))\n  }\n}\n\n/// A faster version of `scale` for the case where the exponent is a power of two.\n/// That is, the exponent $e = 2^k$ for some non-negative integer $k$. Which is used a lot in zk-SNARKs.\npub fn scale2(self: State<t>, k: Int, mul: fn(State<t>, State<t>) -> State<t>) {\n  if k < 0 {\n    zero\n  } else {\n    do_scale2(self, k, mul)\n  }\n}\n\nfn do_scale2(self: State<t>, k: Int, mul) -> State<t> {\n  if k == 0 {\n    self\n  } else {\n    do_scale2(mul(self, self), k - 1, mul)\n  }\n}\n\npub fn neg(field: Int) {\n  fn(state: State<t>) -> State<t> {\n    ( field - state.inner ) % field\n      |> State\n  }\n}\n\npub fn to_int(state: State<t>) -> Int {\n  state.inner\n}\n\npub fn from_int(int: Int, field: Int) -> State<t> {\n  int % field\n    |> State\n}\n",
      "dependencies": ["aiken/builtin"],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.g1",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/crypto/bls12_381/g1.ak",
      "name": "aiken.crypto.bls12_381.g1",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 13,
          "raw": "use aiken/builtin",
          "source": "stdlib"
        },
        {
          "module": "aiken/crypto/bitwise",
          "items": ["State"],
          "line": 14,
          "raw": "use aiken/crypto/bitwise.{State}",
          "source": "stdlib"
        },
        {
          "module": "aiken/crypto/bls12_381/scalar",
          "items": ["Scalar"],
          "line": 15,
          "raw": "use aiken/crypto/bls12_381/scalar.{Scalar}",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "compress",
          "signature": "pub fn compress(point) {",
          "documentation": "Compresses a point in the G1 group into a more compact representation.\nThe compressed representation is a 48-byte string, corresponding to a modified `x` coordinate.\nThe leading most significant 3 bits of this string indicate how to reconstruct the `y` coordinate.\n\n> [!NOTE]\n> More explicitly via [Zcash's spec](https://github.com/supranational/blst#serialization-format):\n>\n> <i>The most-significant three bits of a G1 or G2 encoding should be masked away before the coordinate(s) are interpreted. These bits are used to unambiguously represent the underlying element:\n>\n> - The most significant bit, when set, indicates that the point is in compressed form. Otherwise, the point is in uncompressed form.\n> - The second-most significant bit indicates that the point is at infinity. If this bit is set, the remaining bits of the group element's encoding should be set to zero.\n> - The third-most significant bit is set if (and only if) this point is in compressed form and it is not the point at infinity and its y-coordinate is the lexicographically largest of the two associated with the encoded x-coordinate.</i>",
          "parameters": [
            {
              "name": "point",
              "type": "Unknown",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 60,
          "raw": "pub fn compress(point) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn compress(point) {\n  builtin.bls12_381_g1_compress(point)\n}",
          "tests": [
            "test compress_1() {\n  compress(\n    #<Bls12_381, G1>\"97f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb\",\n  ) == #\"97f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb\"\n}"
          ]
        },
        {
          "name": "decompress",
          "signature": "pub fn decompress(bytes) {",
          "documentation": "Decompresses a point in the G1 group from its compressed form.",
          "parameters": [
            {
              "name": "bytes",
              "type": "Unknown",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 71,
          "raw": "pub fn decompress(bytes) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn decompress(bytes) {\n  builtin.bls12_381_g1_uncompress(bytes)\n}"
        },
        {
          "name": "equal",
          "signature": "pub fn equal(left, right) {",
          "parameters": [
            {
              "name": "left",
              "type": "Unknown",
              "optional": false
            },
            {
              "name": "right",
              "type": "Unknown",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 75,
          "raw": "pub fn equal(left, right) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn equal(left, right) {\n  builtin.bls12_381_g1_equal(left, right)\n}",
          "tests": ["test equal_1() {\n  equal(generator, generator)\n}"]
        },
        {
          "name": "add",
          "signature": "pub fn add(left, right) {",
          "documentation": "Adds two points in the G1 group.",
          "parameters": [
            {
              "name": "left",
              "type": "Unknown",
              "optional": false
            },
            {
              "name": "right",
              "type": "Unknown",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 84,
          "raw": "pub fn add(left, right) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn add(left, right) {\n  builtin.bls12_381_g1_add(left, right)\n}"
        },
        {
          "name": "sub",
          "signature": "pub fn sub(left, right) {",
          "documentation": "Subtracts one point in the G1 group from another.",
          "parameters": [
            {
              "name": "left",
              "type": "Unknown",
              "optional": false
            },
            {
              "name": "right",
              "type": "Unknown",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 89,
          "raw": "pub fn sub(left, right) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sub(left, right) {\n  builtin.bls12_381_g1_add(left, builtin.bls12_381_g1_neg(right))\n}",
          "tests": [
            "test sub_1() {\n  generator == sub(add(generator, generator), generator)\n}"
          ]
        },
        {
          "name": "scale",
          "signature": "pub fn scale(point, e: State<Scalar>) {",
          "documentation": "Exponentiates a point in the G1 group with a `scalar`.\nThis operation is equivalent to the repeated addition of the point with itself `e` times.",
          "parameters": [
            {
              "name": "point",
              "type": "Unknown",
              "optional": false
            },
            {
              "name": "e",
              "type": "State<Scalar>",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 99,
          "raw": "pub fn scale(point, e: State<Scalar>) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn scale(point, e: State<Scalar>) {\n  builtin.bls12_381_g1_scalar_mul(scalar.to_int(e), point)\n}",
          "tests": [
            "test scale_1() {\n  let x = scalar.from_int(2)\n  builtin.bls12_381_g1_add(generator, generator) == scale(generator, x)\n}"
          ]
        },
        {
          "name": "hash_to_group",
          "signature": "pub fn hash_to_group(bytes: ByteArray, domain_separation_tag: ByteArray) {",
          "documentation": "Hashes arbitrary data to a point in the G1 group.\nYou can use the `domain_separation_tag` parameter to cryptographically separate different uses of the hash function between applications.",
          "parameters": [
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "domain_separation_tag",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 110,
          "raw": "pub fn hash_to_group(bytes: ByteArray, domain_separation_tag: ByteArray) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn hash_to_group(bytes: ByteArray, domain_separation_tag: ByteArray) {\n  builtin.bls12_381_g1_hash_to_group(bytes, domain_separation_tag)\n}",
          "tests": [
            "test hash_to_group_1() {\n  hash_to_group(\"hello\", \"world\") == #<Bls12_381, G1>\"89223b03c629cc6bcbbdccbba46b6679bc6a79db82f2d3bd115899a45a5a38c391587b59d3d1e297f977d1c4ee9e3388\"\n}"
          ]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "//// This module is designed for cryptographic operations involving the BLS12-381 elliptic curve, particularly focusing on the G1 group of the curve.\n////\n//// The key functionalities provided by this module include:\n//// - Defining the generator of the G1 group, which is a fixed base point on the elliptic curve used for various cryptographic computations.\n//// - Implementing the additive identity (zero) in the G1 group, which plays a crucial role in elliptic curve arithmetic.\n//// - Providing functions to compress and decompress points in the G1 group. Compression reduces the size of the point representation, which is useful for efficient storage and transmission. Decompression restores the original point from its compressed form.\n//// - Implementing basic arithmetic operations on the points in the G1 group, such as addition and subtraction.\n//// - Enabling the exponentiation of a point in the G1 group with a scalar, which is a fundamental operation in elliptic curve cryptography.\n//// - Offering a function to hash arbitrary data to a point in the G1 group, a process important in several cryptographic protocols.\n////\n//// This module ensures that all operations respect the properties of the BLS12-381 curve and the mathematical structure of the G1 group.\n\nuse aiken/builtin\nuse aiken/crypto/bitwise.{State}\nuse aiken/crypto/bls12_381/scalar.{Scalar}\n\n/// The compressed generator of the G1 group of the BLS12-381 curve.\n/// This constant represents a fixed base point on the elliptic curve.\n/// Note that flat encoded plutus does not allow for the direct usage of BLS12-381 points.\n/// More explicit, any points in plutus data or scripts must be decompressed before usage onchain.\npub const generator: G1Element =\n  #<Bls12_381, G1>\"97f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb\"\n\ntest generator_1() {\n  builtin.bls12_381_g1_scalar_mul(scalar.field_prime, generator) == #<Bls12_381, G1>\"c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n}\n\n/// Represents the additive identity (zero) in the G1 group.\n/// Note that flat encoded plutus does not allow for the direct usage of BLS12-381 points.\n/// More explicit, any points in plutus data or scripts must be decompressed before usage onchain.\npub const zero: G1Element =\n  #<Bls12_381, G1>\"c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n\ntest zero_1() {\n  and {\n    zero == builtin.bls12_381_g1_scalar_mul(scalar.field_prime, generator),\n    zero == builtin.bls12_381_g1_scalar_mul(\n      scalar.field_prime,\n      #<Bls12_381, G1>\"88c7e388ee58f1db9a24d7098b01d13634298bebf2d159254975bd450cb0d287fcc622eb71edde8b469a8513551baf1f\",\n    ),\n    zero == builtin.bls12_381_g1_scalar_mul(\n      scalar.field_prime,\n      #<Bls12_381, G1>\"a6ac32e625dc30b8d31bacf5f4c89c27b0388b15f57ae10de8d5cec02dd1f113c9a31077be05ab587ca57a88d34deb75\",\n    ),\n  }\n}\n\n/// Compresses a point in the G1 group into a more compact representation.\n/// The compressed representation is a 48-byte string, corresponding to a modified `x` coordinate.\n/// The leading most significant 3 bits of this string indicate how to reconstruct the `y` coordinate.\n///\n/// > [!NOTE]\n/// > More explicitly via [Zcash's spec](https://github.com/supranational/blst#serialization-format):\n/// >\n/// > <i>The most-significant three bits of a G1 or G2 encoding should be masked away before the coordinate(s) are interpreted. These bits are used to unambiguously represent the underlying element:\n/// >\n/// > - The most significant bit, when set, indicates that the point is in compressed form. Otherwise, the point is in uncompressed form.\n/// > - The second-most significant bit indicates that the point is at infinity. If this bit is set, the remaining bits of the group element's encoding should be set to zero.\n/// > - The third-most significant bit is set if (and only if) this point is in compressed form and it is not the point at infinity and its y-coordinate is the lexicographically largest of the two associated with the encoded x-coordinate.</i>\npub fn compress(point) {\n  builtin.bls12_381_g1_compress(point)\n}\n\ntest compress_1() {\n  compress(\n    #<Bls12_381, G1>\"97f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb\",\n  ) == #\"97f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb\"\n}\n\n/// Decompresses a point in the G1 group from its compressed form.\npub fn decompress(bytes) {\n  builtin.bls12_381_g1_uncompress(bytes)\n}\n\npub fn equal(left, right) {\n  builtin.bls12_381_g1_equal(left, right)\n}\n\ntest equal_1() {\n  equal(generator, generator)\n}\n\n/// Adds two points in the G1 group.\npub fn add(left, right) {\n  builtin.bls12_381_g1_add(left, right)\n}\n\n/// Subtracts one point in the G1 group from another.\npub fn sub(left, right) {\n  builtin.bls12_381_g1_add(left, builtin.bls12_381_g1_neg(right))\n}\n\ntest sub_1() {\n  generator == sub(add(generator, generator), generator)\n}\n\n/// Exponentiates a point in the G1 group with a `scalar`.\n/// This operation is equivalent to the repeated addition of the point with itself `e` times.\npub fn scale(point, e: State<Scalar>) {\n  builtin.bls12_381_g1_scalar_mul(scalar.to_int(e), point)\n}\n\ntest scale_1() {\n  let x = scalar.from_int(2)\n  builtin.bls12_381_g1_add(generator, generator) == scale(generator, x)\n}\n\n/// Hashes arbitrary data to a point in the G1 group.\n/// You can use the `domain_separation_tag` parameter to cryptographically separate different uses of the hash function between applications.\npub fn hash_to_group(bytes: ByteArray, domain_separation_tag: ByteArray) {\n  builtin.bls12_381_g1_hash_to_group(bytes, domain_separation_tag)\n}\n\ntest hash_to_group_1() {\n  hash_to_group(\"hello\", \"world\") == #<Bls12_381, G1>\"89223b03c629cc6bcbbdccbba46b6679bc6a79db82f2d3bd115899a45a5a38c391587b59d3d1e297f977d1c4ee9e3388\"\n}\n",
      "dependencies": [
        "aiken/builtin",
        "aiken/crypto/bitwise",
        "aiken/crypto/bls12_381/scalar"
      ],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.g2",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/crypto/bls12_381/g2.ak",
      "name": "aiken.crypto.bls12_381.g2",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 13,
          "raw": "use aiken/builtin",
          "source": "stdlib"
        },
        {
          "module": "aiken/crypto/bitwise",
          "items": ["State"],
          "line": 14,
          "raw": "use aiken/crypto/bitwise.{State}",
          "source": "stdlib"
        },
        {
          "module": "aiken/crypto/bls12_381/scalar",
          "items": ["Scalar"],
          "line": 15,
          "raw": "use aiken/crypto/bls12_381/scalar.{Scalar}",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "compress",
          "signature": "pub fn compress(point) {",
          "documentation": "Compresses a point in the G2 group into a more compact representation.\nThe compressed representation is the concatenation of two 48-byte strings, corresponding to a modified and complexified `x` coordinate.\nThe leading most significant 3 bits of this string indicate how to reconstruct the `y` coordinate.\n\n> [!NOTE]\n> More explicitly via [Zcash's spec](https://github.com/supranational/blst#serialization-format):\n>\n> <i>The most-significant three bits of a G1 or G2 encoding should be masked away before the coordinate(s) are interpreted. These bits are used to unambiguously represent the underlying element:\n>\n> - The most significant bit, when set, indicates that the point is in compressed form. Otherwise, the point is in uncompressed form.\n> - The second-most significant bit indicates that the point is at infinity. If this bit is set, the remaining bits of the group element's encoding should be set to zero.\n> - The third-most significant bit is set if (and only if) this point is in compressed form and it is not the point at infinity and its y-coordinate is the lexicographically largest of the two associated with the encoded x-coordinate.</i>",
          "parameters": [
            {
              "name": "point",
              "type": "Unknown",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 60,
          "raw": "pub fn compress(point) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn compress(point) {\n  builtin.bls12_381_g2_compress(point)\n}",
          "tests": [
            "test compress_1() {\n  let g2 =\n    #<Bls12_381, G2>\"93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8\"\n  compress(g2) == #\"93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8\"\n}"
          ]
        },
        {
          "name": "decompress",
          "signature": "pub fn decompress(bytes) {",
          "documentation": "Decompresses a point in the G2 group from its compressed form.",
          "parameters": [
            {
              "name": "bytes",
              "type": "Unknown",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 71,
          "raw": "pub fn decompress(bytes) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn decompress(bytes) {\n  builtin.bls12_381_g2_uncompress(bytes)\n}",
          "tests": [
            "test decompress_1() {\n  let g2 =\n    #<Bls12_381, G2>\"93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8\"\n  generator == g2\n}"
          ]
        },
        {
          "name": "equal",
          "signature": "pub fn equal(left, right) {",
          "parameters": [
            {
              "name": "left",
              "type": "Unknown",
              "optional": false
            },
            {
              "name": "right",
              "type": "Unknown",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 81,
          "raw": "pub fn equal(left, right) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn equal(left, right) {\n  builtin.bls12_381_g2_equal(left, right)\n}",
          "tests": [
            "test equal_1() {\n  equal(\n    generator,\n    #<Bls12_381, G2>\"93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8\",\n  )\n}"
          ]
        },
        {
          "name": "add",
          "signature": "pub fn add(left, right) {",
          "documentation": "Adds two points in the G2 group.",
          "parameters": [
            {
              "name": "left",
              "type": "Unknown",
              "optional": false
            },
            {
              "name": "right",
              "type": "Unknown",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 93,
          "raw": "pub fn add(left, right) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn add(left, right) {\n  builtin.bls12_381_g2_add(left, right)\n}"
        },
        {
          "name": "sub",
          "signature": "pub fn sub(left, right) {",
          "documentation": "Subtracts one point in the G2 group from another.",
          "parameters": [
            {
              "name": "left",
              "type": "Unknown",
              "optional": false
            },
            {
              "name": "right",
              "type": "Unknown",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 98,
          "raw": "pub fn sub(left, right) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sub(left, right) {\n  builtin.bls12_381_g2_add(left, builtin.bls12_381_g2_neg(right))\n}",
          "tests": [
            "test sub_1() {\n  generator == sub(add(generator, generator), generator)\n}"
          ]
        },
        {
          "name": "scale",
          "signature": "pub fn scale(point, e: State<Scalar>) {",
          "documentation": "Exponentiates a point in the G2 group with a `scalar`.\nThis operation is equivalent to the repeated addition of the point with itself `e` times.",
          "parameters": [
            {
              "name": "point",
              "type": "Unknown",
              "optional": false
            },
            {
              "name": "e",
              "type": "State<Scalar>",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 108,
          "raw": "pub fn scale(point, e: State<Scalar>) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn scale(point, e: State<Scalar>) {\n  builtin.bls12_381_g2_scalar_mul(scalar.to_int(e), point)\n}",
          "tests": [
            "test scale_1() {\n  let x = scalar.from_int(2)\n  builtin.bls12_381_g2_add(generator, generator) == scale(generator, x)\n}"
          ]
        },
        {
          "name": "hash_to_group",
          "signature": "pub fn hash_to_group(bytes, domain_separation_tag) {",
          "documentation": "Hashes arbitrary data to a point in the G2 group.\nYou can use the `domain_separation_tag` parameter to cryptographically separate different uses of the hash function between applications.",
          "parameters": [
            {
              "name": "bytes",
              "type": "Unknown",
              "optional": false
            },
            {
              "name": "domain_separation_tag",
              "type": "Unknown",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 119,
          "raw": "pub fn hash_to_group(bytes, domain_separation_tag) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn hash_to_group(bytes, domain_separation_tag) {\n  builtin.bls12_381_g2_hash_to_group(bytes, domain_separation_tag)\n}",
          "tests": [
            "test hash_to_group_1() {\n  hash_to_group(\"hello\", \"world\") == #<Bls12_381, G2>\"a18486bba1dc8321f4998ed4268c6df8dfa5618dd5c91595844059d517f8104bf8031d3e766f9c99db1d6f58b201ee9614de92fc08f9e5cc3a6cd814e871857cb6e3924e8a4fa48775116c5f158d58ceda63614d62f6b7bc47db798d656969a5\"\n}"
          ]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "//// This module is designed for cryptographic operations involving the BLS12-381 elliptic curve, particularly focusing on the G2 group of the curve.\n////\n//// The key functionalities provided by this module include:\n//// - Defining the generator of the G2 group, which is a fixed base point on the elliptic curve used for various cryptographic computations.\n//// - Implementing the additive identity (zero) in the G2 group, which plays a crucial role in elliptic curve arithmetic.\n//// - Providing functions to compress and decompress points in the G2 group. Compression reduces the size of the point representation, which is useful for efficient storage and transmission. Decompression restores the original point from its compressed form.\n//// - Implementing basic arithmetic operations on the points in the G2 group, such as addition and subtraction.\n//// - Enabling the exponentiation of a point in the G2 group with a scalar, which is a fundamental operation in elliptic curve cryptography.\n//// - Offering a function to hash arbitrary data to a point in the G2 group, a process important in several cryptographic protocols.\n////\n//// This module ensures that all operations respect the properties of the BLS12-381 curve and the mathematical structure of the G2 group.\n\nuse aiken/builtin\nuse aiken/crypto/bitwise.{State}\nuse aiken/crypto/bls12_381/scalar.{Scalar}\n\n/// The compressed generator of the G2 group of the BLS12-381 curve.\n/// This constant represents a fixed base point on the elliptic curve.\n/// Note that flat encoded plutus does not allow for the direct usage of BLS12-381 points.\n/// More explicit, any points in plutus data or scripts must be decompressed before usage onchain.\npub const generator: G2Element =\n  #<Bls12_381, G2>\"93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8\"\n\ntest generator_1() {\n  builtin.bls12_381_g2_scalar_mul(scalar.field_prime, generator) == #<Bls12_381, G2>\"c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n}\n\n/// Represents the additive identity (zero) in the G2 group.\n/// Note that flat encoded plutus does not allow for the direct usage of BLS12-381 points.\n/// More explicit, any points in plutus data or scripts must be decompressed before usage onchain.\npub const zero: G2Element =\n  #<Bls12_381, G2>\"c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n\ntest zero_1() {\n  and {\n    zero == builtin.bls12_381_g2_scalar_mul(scalar.field_prime, generator),\n    zero == builtin.bls12_381_g2_scalar_mul(\n      scalar.field_prime,\n      #<Bls12_381, G2>\"9964a9ac2ee28a4dab595ff0970d446373bf46701c5d0b29ce8e1ba995d811a1c7b193c928269192c64ba1fbe4b1940207c251e086b452b920bc72e3cebab46ce672b9b088ca620a471d3b888d9737f6abd165319aa457dbf8835e3d34196051\",\n    ),\n    zero == builtin.bls12_381_g2_scalar_mul(\n      scalar.field_prime,\n      #<Bls12_381, G2>\"a900e25cb53cf1eeb1a82c0c83292937c49c97966351273767a204256a7ef6e95aa391404387075d361e7b13ccd694db03aa73ee0e1bd2c3dd735582b99fdf71696de72e4eda18ae99ea45995f1c9605aa0057008ee9a4da604b5716fb4a345b\",\n    ),\n  }\n}\n\n/// Compresses a point in the G2 group into a more compact representation.\n/// The compressed representation is the concatenation of two 48-byte strings, corresponding to a modified and complexified `x` coordinate.\n/// The leading most significant 3 bits of this string indicate how to reconstruct the `y` coordinate.\n///\n/// > [!NOTE]\n/// > More explicitly via [Zcash's spec](https://github.com/supranational/blst#serialization-format):\n/// >\n/// > <i>The most-significant three bits of a G1 or G2 encoding should be masked away before the coordinate(s) are interpreted. These bits are used to unambiguously represent the underlying element:\n/// >\n/// > - The most significant bit, when set, indicates that the point is in compressed form. Otherwise, the point is in uncompressed form.\n/// > - The second-most significant bit indicates that the point is at infinity. If this bit is set, the remaining bits of the group element's encoding should be set to zero.\n/// > - The third-most significant bit is set if (and only if) this point is in compressed form and it is not the point at infinity and its y-coordinate is the lexicographically largest of the two associated with the encoded x-coordinate.</i>\npub fn compress(point) {\n  builtin.bls12_381_g2_compress(point)\n}\n\ntest compress_1() {\n  let g2 =\n    #<Bls12_381, G2>\"93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8\"\n  compress(g2) == #\"93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8\"\n}\n\n/// Decompresses a point in the G2 group from its compressed form.\npub fn decompress(bytes) {\n  builtin.bls12_381_g2_uncompress(bytes)\n}\n\ntest decompress_1() {\n  let g2 =\n    #<Bls12_381, G2>\"93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8\"\n  generator == g2\n}\n\npub fn equal(left, right) {\n  builtin.bls12_381_g2_equal(left, right)\n}\n\ntest equal_1() {\n  equal(\n    generator,\n    #<Bls12_381, G2>\"93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8\",\n  )\n}\n\n/// Adds two points in the G2 group.\npub fn add(left, right) {\n  builtin.bls12_381_g2_add(left, right)\n}\n\n/// Subtracts one point in the G2 group from another.\npub fn sub(left, right) {\n  builtin.bls12_381_g2_add(left, builtin.bls12_381_g2_neg(right))\n}\n\ntest sub_1() {\n  generator == sub(add(generator, generator), generator)\n}\n\n/// Exponentiates a point in the G2 group with a `scalar`.\n/// This operation is equivalent to the repeated addition of the point with itself `e` times.\npub fn scale(point, e: State<Scalar>) {\n  builtin.bls12_381_g2_scalar_mul(scalar.to_int(e), point)\n}\n\ntest scale_1() {\n  let x = scalar.from_int(2)\n  builtin.bls12_381_g2_add(generator, generator) == scale(generator, x)\n}\n\n/// Hashes arbitrary data to a point in the G2 group.\n/// You can use the `domain_separation_tag` parameter to cryptographically separate different uses of the hash function between applications.\npub fn hash_to_group(bytes, domain_separation_tag) {\n  builtin.bls12_381_g2_hash_to_group(bytes, domain_separation_tag)\n}\n\ntest hash_to_group_1() {\n  hash_to_group(\"hello\", \"world\") == #<Bls12_381, G2>\"a18486bba1dc8321f4998ed4268c6df8dfa5618dd5c91595844059d517f8104bf8031d3e766f9c99db1d6f58b201ee9614de92fc08f9e5cc3a6cd814e871857cb6e3924e8a4fa48775116c5f158d58ceda63614d62f6b7bc47db798d656969a5\"\n}\n",
      "dependencies": [
        "aiken/builtin",
        "aiken/crypto/bitwise",
        "aiken/crypto/bls12_381/scalar"
      ],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/crypto/bls12_381/scalar.ak",
      "name": "aiken.crypto.bls12_381.scalar",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 19,
          "raw": "use aiken/builtin",
          "source": "stdlib"
        },
        {
          "module": "aiken/crypto/bitwise",
          "items": ["State", "one", "zero"],
          "line": 20,
          "raw": "use aiken/crypto/bitwise.{State, one, zero}",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "from_bytes",
          "signature": "pub fn from_bytes(b: ByteArray) -> State<Scalar> {",
          "documentation": "Constructs a new `Scalar` element from a Big-Endian (most-significant bits first) `ByteArray`.",
          "parameters": [
            {
              "name": "b",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "State<Scalar>",
          "line": 37,
          "raw": "pub fn from_bytes(b: ByteArray) -> State<Scalar> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_bytes(b: ByteArray) -> State<Scalar> {\n  b\n    |> builtin.bytearray_to_integer(True, _)\n    |> bitwise.from_int(field_prime)\n}"
        },
        {
          "name": "from_bytes_little_endian",
          "signature": "pub fn from_bytes_little_endian(bytes: ByteArray) -> State<Scalar> {",
          "documentation": "Constructs a new `Scalar` element from a Little-Endian (least-significant bits first) `ByteArray`.",
          "parameters": [
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "State<Scalar>",
          "line": 44,
          "raw": "pub fn from_bytes_little_endian(bytes: ByteArray) -> State<Scalar> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_bytes_little_endian(bytes: ByteArray) -> State<Scalar> {\n  bytes\n    |> builtin.bytearray_to_integer(False, _)\n    |> bitwise.from_int(field_prime)\n}"
        },
        {
          "name": "from_int",
          "signature": "pub fn from_int(n: Int) -> State<Scalar> {",
          "documentation": "Constructs a new `Scalar` element from an integer, ensuring it's within the valid range of the field.",
          "parameters": [
            {
              "name": "n",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "State<Scalar>",
          "line": 51,
          "raw": "pub fn from_int(n: Int) -> State<Scalar> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_int(n: Int) -> State<Scalar> {\n  bitwise.from_int(n, field_prime)\n}"
        },
        {
          "name": "scale",
          "signature": "pub fn scale(self: State<Scalar>, e: Int) -> State<Scalar> {",
          "documentation": "Exponentiates an `Scalar` element by a non-negative integer exponent, using repeated squaring.\nNote that this function returns `scalar.zero` for negative exponents.\nA dedicated builtin function for this is in the making, see CIP 109.",
          "parameters": [
            {
              "name": "self",
              "type": "State<Scalar>",
              "optional": false
            },
            {
              "name": "e",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "State<Scalar>",
          "line": 86,
          "raw": "pub fn scale(self: State<Scalar>, e: Int) -> State<Scalar> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn scale(self: State<Scalar>, e: Int) -> State<Scalar> {\n  bitwise.scale(self, e, mul)\n}",
          "tests": [
            "test scale_1() {\n  let x = from_int(834884848)\n\n  and {\n    ( x |> scale(-1) ) == zero,\n    ( x |> scale(0) ) == one,\n    ( x |> scale(1) ) == x,\n    ( x |> scale(2) |> to_int ) == 697032709419983104,\n    ( x |> scale(3) |> to_int ) == 581942047655130761945608192,\n    (\n      from_int(field_prime - 4)\n        |> scale(200)\n        |> to_int\n    ) == 12843927705572658539565969578937286576443167978938369866871449552629978143484,\n  }\n}"
          ]
        },
        {
          "name": "scale2",
          "signature": "pub fn scale2(self: State<Scalar>, k: Int) -> State<Scalar> {",
          "documentation": "A faster version of `scale` for the case where the exponent is a power of two.\nThat is, the exponent `e = 2^k` for some non-negative integer `k`. Which is used alot in zk-SNARKs.",
          "parameters": [
            {
              "name": "self",
              "type": "State<Scalar>",
              "optional": false
            },
            {
              "name": "k",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "State<Scalar>",
          "line": 109,
          "raw": "pub fn scale2(self: State<Scalar>, k: Int) -> State<Scalar> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn scale2(self: State<Scalar>, k: Int) -> State<Scalar> {\n  bitwise.scale2(self, k, mul)\n}",
          "tests": [
            "test scale2_1() {\n  let x = from_int(834884848)\n\n  and {\n    scale2(x, -1) == zero,\n    scale2(x, 0) == scale(x, 1),\n    scale2(x, 1) == scale(x, 2),\n    scale2(x, 2) == scale(x, 4),\n    scale2(x, 3) == scale(x, 8),\n    scale2(x, 4) == scale(x, 16),\n  }\n}"
          ]
        },
        {
          "name": "add",
          "signature": "pub fn add(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {",
          "documentation": "Adds two `Scalar` elements, ensuring the result stays within the finite field range.",
          "parameters": [
            {
              "name": "left",
              "type": "State<Scalar>",
              "optional": false
            },
            {
              "name": "right",
              "type": "State<Scalar>",
              "optional": false
            }
          ],
          "returnType": "State<Scalar>",
          "line": 131,
          "raw": "pub fn add(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn add(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {\n  add_s_scalar(left, right)\n}"
        },
        {
          "name": "add_bytes",
          "signature": "pub fn add_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {",
          "parameters": [
            {
              "name": "intermediate",
              "type": "State<Scalar>",
              "optional": false
            },
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "State<Scalar>",
          "line": 137,
          "raw": "pub fn add_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn add_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {\n  add_bit_scalar(intermediate, bytes)\n}"
        },
        {
          "name": "add_int",
          "signature": "pub fn add_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {",
          "parameters": [
            {
              "name": "intermediate",
              "type": "State<Scalar>",
              "optional": false
            },
            {
              "name": "int",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "State<Scalar>",
          "line": 143,
          "raw": "pub fn add_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn add_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {\n  add_i_scalar(intermediate, int)\n}"
        },
        {
          "name": "div",
          "signature": "pub fn div(left: State<Scalar>, right: State<Scalar>) -> Option<State<Scalar>> {",
          "documentation": "Divides one `Scalar` element by another, returning `None` if the divisor is zero.",
          "parameters": [
            {
              "name": "left",
              "type": "State<Scalar>",
              "optional": false
            },
            {
              "name": "right",
              "type": "State<Scalar>",
              "optional": false
            }
          ],
          "returnType": "Option<State<Scalar>>",
          "line": 160,
          "raw": "pub fn div(left: State<Scalar>, right: State<Scalar>) -> Option<State<Scalar>> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn div(left: State<Scalar>, right: State<Scalar>) -> Option<State<Scalar>> {\n  if right == zero {\n    None\n  } else {\n    Some(mul(left, scale(right, field_prime - 2)))\n  }\n}"
        },
        {
          "name": "div_int",
          "signature": "pub fn div_int(left: State<Scalar>, right: Int) -> Option<State<Scalar>> {",
          "parameters": [
            {
              "name": "left",
              "type": "State<Scalar>",
              "optional": false
            },
            {
              "name": "right",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Option<State<Scalar>>",
          "line": 168,
          "raw": "pub fn div_int(left: State<Scalar>, right: Int) -> Option<State<Scalar>> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn div_int(left: State<Scalar>, right: Int) -> Option<State<Scalar>> {\n  let right = from_int(right)\n  if right == zero {\n    None\n  } else {\n    Some(mul(left, scale(right, field_prime - 2)))\n  }\n}"
        },
        {
          "name": "div_bytes",
          "signature": "pub fn div_bytes(left: State<Scalar>, right: ByteArray) -> Option<State<Scalar>> {",
          "parameters": [
            {
              "name": "left",
              "type": "State<Scalar>",
              "optional": false
            },
            {
              "name": "right",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Option<State<Scalar>>",
          "line": 177,
          "raw": "pub fn div_bytes(left: State<Scalar>, right: ByteArray) -> Option<State<Scalar>> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn div_bytes(left: State<Scalar>, right: ByteArray) -> Option<State<Scalar>> {\n  let right = from_bytes(right)\n\n  if right == zero {\n    None\n  } else {\n    Some(mul(left, scale(right, field_prime - 2)))\n  }\n}"
        },
        {
          "name": "mul",
          "signature": "pub fn mul(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {",
          "documentation": "Multiplies two `Scalar` elements, with the result constrained within the finite field.",
          "parameters": [
            {
              "name": "left",
              "type": "State<Scalar>",
              "optional": false
            },
            {
              "name": "right",
              "type": "State<Scalar>",
              "optional": false
            }
          ],
          "returnType": "State<Scalar>",
          "line": 204,
          "raw": "pub fn mul(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn mul(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {\n  mul_s_scalar(left, right)\n}"
        },
        {
          "name": "mul_bytes",
          "signature": "pub fn mul_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {",
          "parameters": [
            {
              "name": "intermediate",
              "type": "State<Scalar>",
              "optional": false
            },
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "State<Scalar>",
          "line": 210,
          "raw": "pub fn mul_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn mul_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {\n  mul_bit_scalar(intermediate, bytes)\n}"
        },
        {
          "name": "mul_int",
          "signature": "pub fn mul_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {",
          "parameters": [
            {
              "name": "intermediate",
              "type": "State<Scalar>",
              "optional": false
            },
            {
              "name": "int",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "State<Scalar>",
          "line": 216,
          "raw": "pub fn mul_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn mul_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {\n  mul_i_scalar(intermediate, int)\n}"
        },
        {
          "name": "neg",
          "signature": "pub fn neg(intermediate: State<Scalar>) -> State<Scalar> {",
          "documentation": "Calculates the additive inverse of a `Scalar` element.",
          "parameters": [
            {
              "name": "intermediate",
              "type": "State<Scalar>",
              "optional": false
            }
          ],
          "returnType": "State<Scalar>",
          "line": 234,
          "raw": "pub fn neg(intermediate: State<Scalar>) -> State<Scalar> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn neg(intermediate: State<Scalar>) -> State<Scalar> {\n  neg_scalar(intermediate)\n}",
          "tests": [
            "test neg_1() {\n  trace neg(zero)\n\n  and {\n    neg(from_int(834884848)) == from_int(\n      52435875175126190479447740508185965837690552500527637822603658699937746299665,\n    ),\n    neg(zero) == zero,\n    neg(one) == from_int(field_prime - 1),\n  }\n}"
          ]
        },
        {
          "name": "recip",
          "signature": "pub fn recip(self: State<Scalar>) -> Option<State<Scalar>> {",
          "documentation": "Calculates the multiplicative inverse of an `Scalar` element, returning `None` if the element is zero.",
          "parameters": [
            {
              "name": "self",
              "type": "State<Scalar>",
              "optional": false
            }
          ],
          "returnType": "Option<State<Scalar>>",
          "line": 251,
          "raw": "pub fn recip(self: State<Scalar>) -> Option<State<Scalar>> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn recip(self: State<Scalar>) -> Option<State<Scalar>> {\n  div(one, self)\n}",
          "tests": [
            "test recip_1() {\n  and {\n    recip(from_int(834884848)) == Some(\n      from_int(\n        35891248691642227249400403463796410930702563777316955162085759263735363466421,\n      ),\n    ),\n    recip(zero) == None,\n  }\n}"
          ]
        },
        {
          "name": "sub",
          "signature": "pub fn sub(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {",
          "documentation": "Subtracts one `Scalar` element from another, with the result wrapped within the finite field range.",
          "parameters": [
            {
              "name": "left",
              "type": "State<Scalar>",
              "optional": false
            },
            {
              "name": "right",
              "type": "State<Scalar>",
              "optional": false
            }
          ],
          "returnType": "State<Scalar>",
          "line": 269,
          "raw": "pub fn sub(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sub(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {\n  sub_s_scalar(left, right)\n}"
        },
        {
          "name": "sub_bytes",
          "signature": "pub fn sub_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {",
          "parameters": [
            {
              "name": "intermediate",
              "type": "State<Scalar>",
              "optional": false
            },
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "State<Scalar>",
          "line": 275,
          "raw": "pub fn sub_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sub_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {\n  sub_bit_scalar(intermediate, bytes)\n}"
        },
        {
          "name": "sub_int",
          "signature": "pub fn sub_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {",
          "parameters": [
            {
              "name": "intermediate",
              "type": "State<Scalar>",
              "optional": false
            },
            {
              "name": "int",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "State<Scalar>",
          "line": 281,
          "raw": "pub fn sub_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sub_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {\n  sub_i_scalar(intermediate, int)\n}"
        },
        {
          "name": "to_int",
          "signature": "pub fn to_int(s: State<Scalar>) -> Int {",
          "documentation": "Converts a `Scalar` element back to its integer representation.",
          "parameters": [
            {
              "name": "s",
              "type": "State<Scalar>",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 297,
          "raw": "pub fn to_int(s: State<Scalar>) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn to_int(s: State<Scalar>) -> Int {\n  bitwise.to_int(s)\n}"
        },
        {
          "name": "to_bytes",
          "signature": "pub fn to_bytes(s: State<Scalar>) -> ByteArray {",
          "documentation": "Converts a `Scalar` element to a Big-Endian (most-significant bits first) `ByteArray`.",
          "parameters": [
            {
              "name": "s",
              "type": "State<Scalar>",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 302,
          "raw": "pub fn to_bytes(s: State<Scalar>) -> ByteArray {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn to_bytes(s: State<Scalar>) -> ByteArray {\n  s |> bitwise.to_int |> builtin.integer_to_bytearray(True, field_size, _)\n}"
        },
        {
          "name": "to_bytes_little_endian",
          "signature": "pub fn to_bytes_little_endian(s: State<Scalar>) -> ByteArray {",
          "documentation": "Converts a `Scalar` element to a Little-Endian (least-significant bits first) `ByteArray`.",
          "parameters": [
            {
              "name": "s",
              "type": "State<Scalar>",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 307,
          "raw": "pub fn to_bytes_little_endian(s: State<Scalar>) -> ByteArray {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn to_bytes_little_endian(s: State<Scalar>) -> ByteArray {\n  s |> bitwise.to_int |> builtin.integer_to_bytearray(False, field_size, _)\n}"
        }
      ],
      "types": [
        {
          "name": "Scalar",
          "definition": "ByteArray",
          "line": 28,
          "raw": "pub type Scalar =",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "constants": [
        {
          "name": "field_size",
          "type": "Unknown",
          "value": "32",
          "line": 26,
          "raw": "pub const field_size = 32",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "atoms": [],
      "privateTypes": [
        {
          "name": "BitwiseScalarBytes",
          "definition": "fn(State<Scalar>, ByteArray) -> State<Scalar>",
          "line": 72,
          "raw": "type BitwiseScalarBytes =",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "BitwiseScalarInt",
          "definition": "fn(State<Scalar>, Int) -> State<Scalar>",
          "line": 75,
          "raw": "type BitwiseScalarInt =",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "BitwiseScalarState",
          "definition": "fn(State<Scalar>, State<Scalar>) -> State<Scalar>",
          "line": 78,
          "raw": "type BitwiseScalarState =",
          "isPublic": false,
          "source": "stdlib"
        }
      ],
      "privateConstants": [
        {
          "name": "add_s_scalar",
          "type": "BitwiseScalarState",
          "value": "bitwise.add_state(field_prime)",
          "line": 128,
          "raw": "const add_s_scalar: BitwiseScalarState = bitwise.add_state(field_prime)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "add_bit_scalar",
          "type": "BitwiseScalarBytes",
          "value": "bitwise.add_bits(field_prime, True)",
          "line": 135,
          "raw": "const add_bit_scalar: BitwiseScalarBytes = bitwise.add_bits(field_prime, True)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "add_i_scalar",
          "type": "BitwiseScalarInt",
          "value": "bitwise.add_int(field_prime)",
          "line": 141,
          "raw": "const add_i_scalar: BitwiseScalarInt = bitwise.add_int(field_prime)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "mul_s_scalar",
          "type": "BitwiseScalarState",
          "value": "bitwise.mul_state(field_prime)",
          "line": 201,
          "raw": "const mul_s_scalar: BitwiseScalarState = bitwise.mul_state(field_prime)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "mul_bit_scalar",
          "type": "BitwiseScalarBytes",
          "value": "bitwise.mul_bits(field_prime, True)",
          "line": 208,
          "raw": "const mul_bit_scalar: BitwiseScalarBytes = bitwise.mul_bits(field_prime, True)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "mul_i_scalar",
          "type": "BitwiseScalarInt",
          "value": "bitwise.mul_int(field_prime)",
          "line": 214,
          "raw": "const mul_i_scalar: BitwiseScalarInt = bitwise.mul_int(field_prime)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "neg_scalar",
          "type": "fn(State<Scalar>) -> State<Scalar>",
          "value": "bitwise.neg(field_prime)",
          "line": 231,
          "raw": "const neg_scalar: fn(State<Scalar>) -> State<Scalar> = bitwise.neg(field_prime)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "sub_s_scalar",
          "type": "BitwiseScalarState",
          "value": "bitwise.sub_state(field_prime)",
          "line": 266,
          "raw": "const sub_s_scalar: BitwiseScalarState = bitwise.sub_state(field_prime)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "sub_bit_scalar",
          "type": "BitwiseScalarBytes",
          "value": "bitwise.sub_bits(field_prime, True)",
          "line": 273,
          "raw": "const sub_bit_scalar: BitwiseScalarBytes = bitwise.sub_bits(field_prime, True)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "sub_i_scalar",
          "type": "BitwiseScalarInt",
          "value": "bitwise.sub_int(field_prime)",
          "line": 279,
          "raw": "const sub_i_scalar: BitwiseScalarInt = bitwise.sub_int(field_prime)",
          "isPublic": false,
          "source": "stdlib"
        }
      ],
      "content": "//// This module implements arithmetic operations in the scalar field associated with the BLS12-381 elliptic curve.\n//// The scalar field, defined over a prime number `q`, is derived from the order of the subgroup G1.\n////\n//// More explicitly, we have the identity:\n////\n//// ```aiken\n//// builtin.bls12_381_g1_scalar_mul(q, bls12_381_g1_generator) == 1\n//// ```\n////\n//// where,\n////\n//// ```aiken\n//// q = 52435875175126190479447740508185965837690552500527637822603658699938581184513\n//// ```\n////\n//// This module provides functionality for basic arithmetic operations (addition, subtraction, multiplication, division) within this scalar field.\n//// Additionally, it includes advanced operations such as exponentiation and calculation of multiplicative inverses, tailored for cryptographic applications.\n\nuse aiken/builtin\nuse aiken/crypto/bitwise.{State, one, zero}\n\n/// The prime number defining the scalar field of the BLS12-381 curve.\npub const field_prime =\n  52435875175126190479447740508185965837690552500527637822603658699938581184513\n\npub const field_size = 32\n\npub type Scalar =\n  ByteArray\n\ntest field_prime_1() {\n  builtin.integer_to_bytearray(True, 32, field_prime) == #\"73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\"\n}\n\n// ## Constructing\n/// Constructs a new `Scalar` element from a Big-Endian (most-significant bits first) `ByteArray`.\npub fn from_bytes(b: ByteArray) -> State<Scalar> {\n  b\n    |> builtin.bytearray_to_integer(True, _)\n    |> bitwise.from_int(field_prime)\n}\n\n/// Constructs a new `Scalar` element from a Little-Endian (least-significant bits first) `ByteArray`.\npub fn from_bytes_little_endian(bytes: ByteArray) -> State<Scalar> {\n  bytes\n    |> builtin.bytearray_to_integer(False, _)\n    |> bitwise.from_int(field_prime)\n}\n\n/// Constructs a new `Scalar` element from an integer, ensuring it's within the valid range of the field.\npub fn from_int(n: Int) -> State<Scalar> {\n  bitwise.from_int(n, field_prime)\n}\n\ntest new_1() {\n  trace from_int(-1)\n  and {\n    ( from_int(-1) |> to_int ) == field_prime - 1,\n    ( from_int(field_prime) |> to_int ) == 0,\n    ( from_int(834884848) |> to_int ) == 834884848,\n  }\n}\n\ntest from_bytearray_big_endian_1() {\n  ( from_bytes(#\"ffff00\") |> to_int ) == 16776960\n}\n\ntest from_bytearray_little_endian_1() {\n  ( from_bytes_little_endian(#\"ffff00\") |> to_int ) == 65535\n}\n\ntype BitwiseScalarBytes =\n  fn(State<Scalar>, ByteArray) -> State<Scalar>\n\ntype BitwiseScalarInt =\n  fn(State<Scalar>, Int) -> State<Scalar>\n\ntype BitwiseScalarState =\n  fn(State<Scalar>, State<Scalar>) -> State<Scalar>\n\n// ## Modifying\n\n/// Exponentiates an `Scalar` element by a non-negative integer exponent, using repeated squaring.\n/// Note that this function returns `scalar.zero` for negative exponents.\n/// A dedicated builtin function for this is in the making, see CIP 109.\npub fn scale(self: State<Scalar>, e: Int) -> State<Scalar> {\n  bitwise.scale(self, e, mul)\n}\n\ntest scale_1() {\n  let x = from_int(834884848)\n\n  and {\n    ( x |> scale(-1) ) == zero,\n    ( x |> scale(0) ) == one,\n    ( x |> scale(1) ) == x,\n    ( x |> scale(2) |> to_int ) == 697032709419983104,\n    ( x |> scale(3) |> to_int ) == 581942047655130761945608192,\n    (\n      from_int(field_prime - 4)\n        |> scale(200)\n        |> to_int\n    ) == 12843927705572658539565969578937286576443167978938369866871449552629978143484,\n  }\n}\n\n/// A faster version of `scale` for the case where the exponent is a power of two.\n/// That is, the exponent `e = 2^k` for some non-negative integer `k`. Which is used alot in zk-SNARKs.\npub fn scale2(self: State<Scalar>, k: Int) -> State<Scalar> {\n  bitwise.scale2(self, k, mul)\n}\n\ntest scale2_1() {\n  let x = from_int(834884848)\n\n  and {\n    scale2(x, -1) == zero,\n    scale2(x, 0) == scale(x, 1),\n    scale2(x, 1) == scale(x, 2),\n    scale2(x, 2) == scale(x, 4),\n    scale2(x, 3) == scale(x, 8),\n    scale2(x, 4) == scale(x, 16),\n  }\n}\n\n// ## Combining\n\nconst add_s_scalar: BitwiseScalarState = bitwise.add_state(field_prime)\n\n/// Adds two `Scalar` elements, ensuring the result stays within the finite field range.\npub fn add(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {\n  add_s_scalar(left, right)\n}\n\nconst add_bit_scalar: BitwiseScalarBytes = bitwise.add_bits(field_prime, True)\n\npub fn add_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {\n  add_bit_scalar(intermediate, bytes)\n}\n\nconst add_i_scalar: BitwiseScalarInt = bitwise.add_int(field_prime)\n\npub fn add_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {\n  add_i_scalar(intermediate, int)\n}\n\ntest add_1() {\n  let x = from_int(834884848)\n  let y = from_int(field_prime - 1)\n  let z = from_int(3)\n\n  and {\n    (( add(x, x) |> to_int ) == 1669769696)?,\n    (add(y, one) == zero)?,\n    (add(z, add(y, one)) == z)?,\n  }\n}\n\n/// Divides one `Scalar` element by another, returning `None` if the divisor is zero.\npub fn div(left: State<Scalar>, right: State<Scalar>) -> Option<State<Scalar>> {\n  if right == zero {\n    None\n  } else {\n    Some(mul(left, scale(right, field_prime - 2)))\n  }\n}\n\npub fn div_int(left: State<Scalar>, right: Int) -> Option<State<Scalar>> {\n  let right = from_int(right)\n  if right == zero {\n    None\n  } else {\n    Some(mul(left, scale(right, field_prime - 2)))\n  }\n}\n\npub fn div_bytes(left: State<Scalar>, right: ByteArray) -> Option<State<Scalar>> {\n  let right = from_bytes(right)\n\n  if right == zero {\n    None\n  } else {\n    Some(mul(left, scale(right, field_prime - 2)))\n  }\n}\n\ntest div_1() {\n  let x = from_int(834884848)\n\n  and {\n    div(x, x) == Some(one),\n    div(x, zero) == None,\n    div(from_int(field_prime - 1), from_int(2)) == Some(\n      from_int(\n        26217937587563095239723870254092982918845276250263818911301829349969290592256,\n      ),\n    ),\n  }\n}\n\nconst mul_s_scalar: BitwiseScalarState = bitwise.mul_state(field_prime)\n\n/// Multiplies two `Scalar` elements, with the result constrained within the finite field.\npub fn mul(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {\n  mul_s_scalar(left, right)\n}\n\nconst mul_bit_scalar: BitwiseScalarBytes = bitwise.mul_bits(field_prime, True)\n\npub fn mul_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {\n  mul_bit_scalar(intermediate, bytes)\n}\n\nconst mul_i_scalar: BitwiseScalarInt = bitwise.mul_int(field_prime)\n\npub fn mul_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {\n  mul_i_scalar(intermediate, int)\n}\n\ntest mul_1() {\n  let x = from_int(834884848)\n  and {\n    mul(x, x) == from_int(697032709419983104),\n    mul(zero, x) == zero,\n    mul(from_int(field_prime - 1), from_int(2)) == from_int(\n      52435875175126190479447740508185965837690552500527637822603658699938581184511,\n    ),\n  }\n}\n\nconst neg_scalar: fn(State<Scalar>) -> State<Scalar> = bitwise.neg(field_prime)\n\n/// Calculates the additive inverse of a `Scalar` element.\npub fn neg(intermediate: State<Scalar>) -> State<Scalar> {\n  neg_scalar(intermediate)\n}\n\ntest neg_1() {\n  trace neg(zero)\n\n  and {\n    neg(from_int(834884848)) == from_int(\n      52435875175126190479447740508185965837690552500527637822603658699937746299665,\n    ),\n    neg(zero) == zero,\n    neg(one) == from_int(field_prime - 1),\n  }\n}\n\n/// Calculates the multiplicative inverse of an `Scalar` element, returning `None` if the element is zero.\npub fn recip(self: State<Scalar>) -> Option<State<Scalar>> {\n  div(one, self)\n}\n\ntest recip_1() {\n  and {\n    recip(from_int(834884848)) == Some(\n      from_int(\n        35891248691642227249400403463796410930702563777316955162085759263735363466421,\n      ),\n    ),\n    recip(zero) == None,\n  }\n}\n\nconst sub_s_scalar: BitwiseScalarState = bitwise.sub_state(field_prime)\n\n/// Subtracts one `Scalar` element from another, with the result wrapped within the finite field range.\npub fn sub(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {\n  sub_s_scalar(left, right)\n}\n\nconst sub_bit_scalar: BitwiseScalarBytes = bitwise.sub_bits(field_prime, True)\n\npub fn sub_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {\n  sub_bit_scalar(intermediate, bytes)\n}\n\nconst sub_i_scalar: BitwiseScalarInt = bitwise.sub_int(field_prime)\n\npub fn sub_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {\n  sub_i_scalar(intermediate, int)\n}\n\ntest sub_1() {\n  let x = from_int(834884848)\n\n  and {\n    (sub(x, x) == zero)?,\n    (sub(zero, from_int(5)) == from_int(field_prime - 5))?,\n  }\n}\n\n// ## Transforming\n\n/// Converts a `Scalar` element back to its integer representation.\npub fn to_int(s: State<Scalar>) -> Int {\n  bitwise.to_int(s)\n}\n\n/// Converts a `Scalar` element to a Big-Endian (most-significant bits first) `ByteArray`.\npub fn to_bytes(s: State<Scalar>) -> ByteArray {\n  s |> bitwise.to_int |> builtin.integer_to_bytearray(True, field_size, _)\n}\n\n/// Converts a `Scalar` element to a Little-Endian (least-significant bits first) `ByteArray`.\npub fn to_bytes_little_endian(s: State<Scalar>) -> ByteArray {\n  s |> bitwise.to_int |> builtin.integer_to_bytearray(False, field_size, _)\n}\n\ntest to_int_1() {\n  to_int(from_int(834884848)) == 834884848\n}\n\ntest to_bytearray_1() {\n  ( to_bytes(from_int(16777215)) |> builtin.slice_bytearray(29, 32, _) ) == #\"ffffff\"\n}\n",
      "dependencies": ["aiken/builtin", "aiken/crypto/bitwise"],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.crypto.int224",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/crypto/int224.ak",
      "name": "aiken.crypto.int224",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 9,
          "raw": "use aiken/builtin",
          "source": "stdlib"
        },
        {
          "module": "aiken/crypto/bitwise",
          "items": [],
          "line": 10,
          "raw": "use aiken/crypto/bitwise",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "from_bytearray_big_endian",
          "signature": "pub fn from_bytearray_big_endian(bytes: ByteArray) -> State {",
          "documentation": "Constructs a new `Bits224` element from a Big-Endian (most-significant bits first) `ByteArray`.",
          "parameters": [
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 34,
          "raw": "pub fn from_bytearray_big_endian(bytes: ByteArray) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_bytearray_big_endian(bytes: ByteArray) -> State {\n  bytes\n    |> builtin.bytearray_to_integer(True, _)\n    |> bitwise.from_int(field)\n}"
        },
        {
          "name": "from_bytearray_little_endian",
          "signature": "pub fn from_bytearray_little_endian(bytes: ByteArray) -> State {",
          "documentation": "Constructs a new `Bits224` element from a Little-Endian (least-significant bits first) `ByteArray`.",
          "parameters": [
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 41,
          "raw": "pub fn from_bytearray_little_endian(bytes: ByteArray) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_bytearray_little_endian(bytes: ByteArray) -> State {\n  bytes\n    |> builtin.bytearray_to_integer(False, _)\n    |> bitwise.from_int(field)\n}"
        },
        {
          "name": "from_int",
          "signature": "pub fn from_int(int: Int) -> State {",
          "documentation": "Constructs a new `Bits224` element from an integer, ensuring it's within the valid range of the field.",
          "parameters": [
            {
              "name": "int",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 48,
          "raw": "pub fn from_int(int: Int) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_int(int: Int) -> State {\n  bitwise.from_int(int, field)\n}"
        },
        {
          "name": "scale",
          "signature": "pub fn scale(self: State, e: Int) -> State {",
          "documentation": "Exponentiates a `Bits224` element by a non-negative integer exponent, using repeated squaring.\nNote that this function returns `zero` for negative exponents.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            },
            {
              "name": "e",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 56,
          "raw": "pub fn scale(self: State, e: Int) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn scale(self: State, e: Int) -> State {\n  bitwise.scale(self, e, mul)\n}"
        },
        {
          "name": "scale2",
          "signature": "pub fn scale2(self: State, k: Int) -> State {",
          "documentation": "A faster version of `scale` for the case where the exponent is a power of two.\nThat is, the exponent $e = 2^k$ for some non-negative integer $k$.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            },
            {
              "name": "k",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 62,
          "raw": "pub fn scale2(self: State, k: Int) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn scale2(self: State, k: Int) -> State {\n  bitwise.scale2(self, k, mul)\n}"
        },
        {
          "name": "add",
          "signature": "pub fn add(left: State, right: State) -> State {",
          "documentation": "Adds two `Bits224` elements, ensuring the result stays within the finite field range.",
          "parameters": [
            {
              "name": "left",
              "type": "State",
              "optional": false
            },
            {
              "name": "right",
              "type": "State",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 71,
          "raw": "pub fn add(left: State, right: State) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn add(left: State, right: State) -> State {\n  add_s_bits224(left, right)\n}"
        },
        {
          "name": "add_bytes",
          "signature": "pub fn add_bytes(self: State, bytes: ByteArray) -> State {",
          "documentation": "Adds a ByteArray to a `Bits224` element, interpreting bytes as a big-endian number.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            },
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 78,
          "raw": "pub fn add_bytes(self: State, bytes: ByteArray) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn add_bytes(self: State, bytes: ByteArray) -> State {\n  add_bit224(self, bytes)\n}"
        },
        {
          "name": "add_int",
          "signature": "pub fn add_int(self: State, int: Int) -> State {",
          "documentation": "Adds an integer to a `Bits224` element.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            },
            {
              "name": "int",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 85,
          "raw": "pub fn add_int(self: State, int: Int) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn add_int(self: State, int: Int) -> State {\n  add_i224(self, int)\n}"
        },
        {
          "name": "mul",
          "signature": "pub fn mul(left: State, right: State) -> State {",
          "documentation": "Multiplies two `Bits224` elements, with the result constrained within the finite field.",
          "parameters": [
            {
              "name": "left",
              "type": "State",
              "optional": false
            },
            {
              "name": "right",
              "type": "State",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 92,
          "raw": "pub fn mul(left: State, right: State) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn mul(left: State, right: State) -> State {\n  mul_s_bits224(left, right)\n}"
        },
        {
          "name": "mul_bytes",
          "signature": "pub fn mul_bytes(self: State, bytes: ByteArray) -> State {",
          "documentation": "Multiplies a `Bits224` element by a ByteArray, interpreting bytes as a big-endian number.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            },
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 99,
          "raw": "pub fn mul_bytes(self: State, bytes: ByteArray) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn mul_bytes(self: State, bytes: ByteArray) -> State {\n  mul_bit224(self, bytes)\n}"
        },
        {
          "name": "mul_int",
          "signature": "pub fn mul_int(self: State, int: Int) -> State {",
          "documentation": "Multiplies a `Bits224` element by an integer.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            },
            {
              "name": "int",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 106,
          "raw": "pub fn mul_int(self: State, int: Int) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn mul_int(self: State, int: Int) -> State {\n  mul_i224(self, int)\n}"
        },
        {
          "name": "neg",
          "signature": "pub fn neg(self: State) -> State {",
          "documentation": "Calculates the additive inverse of a `Bits224` element.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 113,
          "raw": "pub fn neg(self: State) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn neg(self: State) -> State {\n  neg224(self)\n}"
        },
        {
          "name": "sub",
          "signature": "pub fn sub(left: State, right: State) -> State {",
          "documentation": "Subtracts one `Bits224` element from another, with the result wrapped within the finite field range.",
          "parameters": [
            {
              "name": "left",
              "type": "State",
              "optional": false
            },
            {
              "name": "right",
              "type": "State",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 120,
          "raw": "pub fn sub(left: State, right: State) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sub(left: State, right: State) -> State {\n  sub_s_bits224(left, right)\n}"
        },
        {
          "name": "sub_bytes",
          "signature": "pub fn sub_bytes(self: State, bytes: ByteArray) -> State {",
          "documentation": "Subtracts a `ByteArray` from a `Bits224` element, interpreting bytes as a big-endian number.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            },
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 127,
          "raw": "pub fn sub_bytes(self: State, bytes: ByteArray) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sub_bytes(self: State, bytes: ByteArray) -> State {\n  sub_bit224(self, bytes)\n}"
        },
        {
          "name": "sub_int",
          "signature": "pub fn sub_int(self: State, int: Int) -> State {",
          "documentation": "Subtracts an integer from a `Bits224` element.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            },
            {
              "name": "int",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 134,
          "raw": "pub fn sub_int(self: State, int: Int) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sub_int(self: State, int: Int) -> State {\n  sub_i224(self, int)\n}"
        },
        {
          "name": "to_bytearray_big_endian",
          "signature": "pub fn to_bytearray_big_endian(self: State) -> ByteArray {",
          "documentation": "Converts a `Bits224` element to a Big-Endian (most-significant bits first) `ByteArray`.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 141,
          "raw": "pub fn to_bytearray_big_endian(self: State) -> ByteArray {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn to_bytearray_big_endian(self: State) -> ByteArray {\n  bitwise.to_int(self)\n    |> builtin.integer_to_bytearray(True, field_size, _)\n}"
        },
        {
          "name": "to_bytearray_little_endian",
          "signature": "pub fn to_bytearray_little_endian(self: State) -> ByteArray {",
          "documentation": "Converts a `Bits224` element to a Little-Endian (least-significant bits first) `ByteArray`.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 147,
          "raw": "pub fn to_bytearray_little_endian(self: State) -> ByteArray {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn to_bytearray_little_endian(self: State) -> ByteArray {\n  bitwise.to_int(self)\n    |> builtin.integer_to_bytearray(False, field_size, _)\n}"
        },
        {
          "name": "to_int",
          "signature": "pub fn to_int(self: State) -> Int {",
          "documentation": "Converts a `Bits224` element back to its integer representation.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 153,
          "raw": "pub fn to_int(self: State) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn to_int(self: State) -> Int {\n  bitwise.to_int(self)\n}"
        }
      ],
      "types": [
        {
          "name": "Bits224",
          "definition": "opaque { Bits224 }",
          "line": 12,
          "raw": "pub opaque type Bits224 {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "State",
          "definition": "bitwise.State<Bits224>",
          "line": 16,
          "raw": "pub type State =",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "constants": [
        {
          "name": "field_size",
          "type": "Unknown",
          "value": "28",
          "line": 29,
          "raw": "pub const field_size = 28",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "atoms": [],
      "privateTypes": [
        {
          "name": "Over<a>",
          "definition": "fn(State, a) -> State",
          "line": 19,
          "raw": "type Over<a> =",
          "isPublic": false,
          "source": "stdlib"
        }
      ],
      "privateConstants": [
        {
          "name": "add_s_bits224",
          "type": "Over<State>",
          "value": "bitwise.add_state(field)",
          "line": 68,
          "raw": "const add_s_bits224: Over<State> = bitwise.add_state(field)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "add_bit224",
          "type": "Over<ByteArray>",
          "value": "bitwise.add_bits(field, True)",
          "line": 75,
          "raw": "const add_bit224: Over<ByteArray> = bitwise.add_bits(field, True)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "add_i224",
          "type": "Over<Int>",
          "value": "bitwise.add_int(field)",
          "line": 82,
          "raw": "const add_i224: Over<Int> = bitwise.add_int(field)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "mul_s_bits224",
          "type": "Over<State>",
          "value": "bitwise.mul_state(field)",
          "line": 89,
          "raw": "const mul_s_bits224: Over<State> = bitwise.mul_state(field)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "mul_bit224",
          "type": "Over<ByteArray>",
          "value": "bitwise.mul_bits(field, True)",
          "line": 96,
          "raw": "const mul_bit224: Over<ByteArray> = bitwise.mul_bits(field, True)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "mul_i224",
          "type": "Over<Int>",
          "value": "bitwise.mul_int(field)",
          "line": 103,
          "raw": "const mul_i224: Over<Int> = bitwise.mul_int(field)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "neg224",
          "type": "fn(State) -> State",
          "value": "bitwise.neg(field)",
          "line": 110,
          "raw": "const neg224: fn(State) -> State = bitwise.neg(field)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "sub_s_bits224",
          "type": "Over<State>",
          "value": "bitwise.sub_state(field)",
          "line": 117,
          "raw": "const sub_s_bits224: Over<State> = bitwise.sub_state(field)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "sub_bit224",
          "type": "Over<ByteArray>",
          "value": "bitwise.sub_bits(field, True)",
          "line": 124,
          "raw": "const sub_bit224: Over<ByteArray> = bitwise.sub_bits(field, True)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "sub_i224",
          "type": "Over<Int>",
          "value": "bitwise.sub_int(field)",
          "line": 131,
          "raw": "const sub_i224: Over<Int> = bitwise.sub_int(field)",
          "isPublic": false,
          "source": "stdlib"
        }
      ],
      "content": "//// This module implements arithmetic operations in a constrained 224-bit integer field.\n//// Operations are performed modulo $2^{224}$, providing a field for cryptographic operations\n//// that require 28-byte values.\n////\n//// The module provides functionality for basic arithmetic operations (addition, subtraction,\n//// multiplication) within this constrained field, as well as conversion functions between\n//// different representations.\n\nuse aiken/builtin\nuse aiken/crypto/bitwise\n\npub opaque type Bits224 {\n  Bits224\n}\n\npub type State =\n  bitwise.State<Bits224>\n\ntype Over<a> =\n  fn(State, a) -> State\n\n/// The prime defining the 224-bit integer field $2^{224}$\npub const field =\n  builtin.replicate_byte(28, 0)\n    |> builtin.cons_bytearray(1, _)\n    |> builtin.bytearray_to_integer(True, _)\n\n/// The field size, in **bytes**.\npub const field_size = 28\n\n// ## Constructing\n\n/// Constructs a new `Bits224` element from a Big-Endian (most-significant bits first) `ByteArray`.\npub fn from_bytearray_big_endian(bytes: ByteArray) -> State {\n  bytes\n    |> builtin.bytearray_to_integer(True, _)\n    |> bitwise.from_int(field)\n}\n\n/// Constructs a new `Bits224` element from a Little-Endian (least-significant bits first) `ByteArray`.\npub fn from_bytearray_little_endian(bytes: ByteArray) -> State {\n  bytes\n    |> builtin.bytearray_to_integer(False, _)\n    |> bitwise.from_int(field)\n}\n\n/// Constructs a new `Bits224` element from an integer, ensuring it's within the valid range of the field.\npub fn from_int(int: Int) -> State {\n  bitwise.from_int(int, field)\n}\n\n// ## Modifying\n\n/// Exponentiates a `Bits224` element by a non-negative integer exponent, using repeated squaring.\n/// Note that this function returns `zero` for negative exponents.\npub fn scale(self: State, e: Int) -> State {\n  bitwise.scale(self, e, mul)\n}\n\n/// A faster version of `scale` for the case where the exponent is a power of two.\n/// That is, the exponent $e = 2^k$ for some non-negative integer $k$.\npub fn scale2(self: State, k: Int) -> State {\n  bitwise.scale2(self, k, mul)\n}\n\n// ## Combining\n\nconst add_s_bits224: Over<State> = bitwise.add_state(field)\n\n/// Adds two `Bits224` elements, ensuring the result stays within the finite field range.\npub fn add(left: State, right: State) -> State {\n  add_s_bits224(left, right)\n}\n\nconst add_bit224: Over<ByteArray> = bitwise.add_bits(field, True)\n\n/// Adds a ByteArray to a `Bits224` element, interpreting bytes as a big-endian number.\npub fn add_bytes(self: State, bytes: ByteArray) -> State {\n  add_bit224(self, bytes)\n}\n\nconst add_i224: Over<Int> = bitwise.add_int(field)\n\n/// Adds an integer to a `Bits224` element.\npub fn add_int(self: State, int: Int) -> State {\n  add_i224(self, int)\n}\n\nconst mul_s_bits224: Over<State> = bitwise.mul_state(field)\n\n/// Multiplies two `Bits224` elements, with the result constrained within the finite field.\npub fn mul(left: State, right: State) -> State {\n  mul_s_bits224(left, right)\n}\n\nconst mul_bit224: Over<ByteArray> = bitwise.mul_bits(field, True)\n\n/// Multiplies a `Bits224` element by a ByteArray, interpreting bytes as a big-endian number.\npub fn mul_bytes(self: State, bytes: ByteArray) -> State {\n  mul_bit224(self, bytes)\n}\n\nconst mul_i224: Over<Int> = bitwise.mul_int(field)\n\n/// Multiplies a `Bits224` element by an integer.\npub fn mul_int(self: State, int: Int) -> State {\n  mul_i224(self, int)\n}\n\nconst neg224: fn(State) -> State = bitwise.neg(field)\n\n/// Calculates the additive inverse of a `Bits224` element.\npub fn neg(self: State) -> State {\n  neg224(self)\n}\n\nconst sub_s_bits224: Over<State> = bitwise.sub_state(field)\n\n/// Subtracts one `Bits224` element from another, with the result wrapped within the finite field range.\npub fn sub(left: State, right: State) -> State {\n  sub_s_bits224(left, right)\n}\n\nconst sub_bit224: Over<ByteArray> = bitwise.sub_bits(field, True)\n\n/// Subtracts a `ByteArray` from a `Bits224` element, interpreting bytes as a big-endian number.\npub fn sub_bytes(self: State, bytes: ByteArray) -> State {\n  sub_bit224(self, bytes)\n}\n\nconst sub_i224: Over<Int> = bitwise.sub_int(field)\n\n/// Subtracts an integer from a `Bits224` element.\npub fn sub_int(self: State, int: Int) -> State {\n  sub_i224(self, int)\n}\n\n// ## Transforming\n\n/// Converts a `Bits224` element to a Big-Endian (most-significant bits first) `ByteArray`.\npub fn to_bytearray_big_endian(self: State) -> ByteArray {\n  bitwise.to_int(self)\n    |> builtin.integer_to_bytearray(True, field_size, _)\n}\n\n/// Converts a `Bits224` element to a Little-Endian (least-significant bits first) `ByteArray`.\npub fn to_bytearray_little_endian(self: State) -> ByteArray {\n  bitwise.to_int(self)\n    |> builtin.integer_to_bytearray(False, field_size, _)\n}\n\n/// Converts a `Bits224` element back to its integer representation.\npub fn to_int(self: State) -> Int {\n  bitwise.to_int(self)\n}\n",
      "dependencies": ["aiken/builtin", "aiken/crypto/bitwise"],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.crypto.int224.tests",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/crypto/int224.tests.ak",
      "name": "aiken.crypto.int224.tests",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 1,
          "raw": "use aiken/builtin",
          "source": "stdlib"
        },
        {
          "module": "aiken/crypto/bitwise",
          "items": ["one", "zero"],
          "line": 2,
          "raw": "use aiken/crypto/bitwise.{one, zero}",
          "source": "stdlib"
        }
      ],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/builtin\nuse aiken/crypto/bitwise.{one, zero}\nuse aiken/crypto/int224.{\n  add, add_bytes, add_int, field, from_bytearray_big_endian,\n  from_bytearray_little_endian, from_int, mul, mul_bytes, mul_int, neg, scale,\n  scale2, sub, sub_bytes, sub_int, to_bytearray_big_endian,\n  to_bytearray_little_endian, to_int,\n}\n\ntest equal_pad_for_addition() {\n  let a: ByteArray = #\"acab\"\n  let b: ByteArray = #\"cafe\"\n\n  let x =\n    a\n      |> from_bytearray_big_endian\n      |> add_bytes(b)\n      |> to_bytearray_big_endian\n\n  x == #\"000000000000000000000000000000000000000000000000000177a9\"\n}\n\ntest unequal_pad_for_addition() {\n  let a: ByteArray = #\"acabbeefface\"\n  let b: ByteArray = #\"cafe\"\n\n  let x =\n    a\n      |> from_bytearray_big_endian\n      |> add_bytes(b)\n      |> to_bytearray_big_endian\n\n  x == #\"00000000000000000000000000000000000000000000acabbef0c5cc\"\n}\n\n// ## Test for constructing Hash224 elements\n\ntest from_int_1() {\n  and {\n    ( from_int(-1) |> to_int ) == field - 1,\n    ( from_int(field) |> to_int ) == 0,\n    ( from_int(834884848) |> to_int ) == 834884848,\n  }\n}\n\ntest from_bytes_big_endian_1() {\n  ( from_bytearray_big_endian(#\"ffff00\") |> to_int ) == 16776960\n}\n\ntest from_bytes_little_endian_1() {\n  ( from_bytearray_little_endian(#\"ffff00\") |> to_int ) == 65535\n}\n\n// ## Tests for modifying Hash224 elements\n\ntest scale_1() {\n  let x = from_int(834884848)\n\n  and {\n    ( x |> scale(-1) ) == zero,\n    ( x |> scale(0) ) == one,\n    ( x |> scale(1) ) == x,\n    ( x |> scale(2) |> to_int ) == 697032709419983104,\n    ( x |> scale(3) |> to_int ) == 581942047655130761945608192,\n    (\n      from_int(field - 5)\n        |> scale(200)\n        |> to_int\n    ) != 0,\n  }\n}\n\ntest scale2_1() {\n  let a = from_int(2)\n\n  and {\n    ( scale2(a, 0) |> to_int ) == 2,\n    ( scale2(a, 1) |> to_int ) == 4,\n    ( scale2(a, 2) |> to_int ) == 16,\n    ( scale2(a, 3) |> to_int ) == 256,\n  }\n}\n\n// ## Tests for combining Hash224 elements\n\ntest add_1() {\n  let x = from_int(834884848)\n  let y = from_int(field - 1)\n  let z = from_int(3)\n\n  and {\n    (( add(x, x) |> to_int ) == 1669769696)?,\n    (add(y, one) == zero)?,\n    (add(z, add(y, one)) == z)?,\n  }\n}\n\ntest add_overflow_1() {\n  let a = from_int(field - 1)\n  let b = from_int(1)\n\n  ( add(a, b) |> to_int ) == 0\n}\n\ntest mul_1() {\n  let x = from_int(834884848)\n  and {\n    mul(x, x) == from_int(697032709419983104),\n    mul(zero, x) == zero,\n    mul(from_int(field - 1), from_int(2)) == from_int(field - 2),\n  }\n}\n\ntest neg_1() {\n  and {\n    neg(from_int(834884848)) == from_int(field - 834884848),\n    neg(zero) == zero,\n    neg(one) == from_int(field - 1),\n  }\n}\n\ntest sub_1() {\n  let x = from_int(834884848)\n\n  and {\n    (sub(x, x) == zero)?,\n    (sub(zero, from_int(5)) == from_int(field - 5))?,\n  }\n}\n\n// ## Tests for transforming Hash224 elements\n\ntest to_int_1() {\n  to_int(from_int(834884848)) == 834884848\n}\n\ntest to_bytes_1() {\n  (\n    to_bytearray_big_endian(from_int(16777215))\n      |> builtin.slice_bytearray(25, 28, _)\n  ) == #\"ffffff\"\n}\n\ntest to_bytes_little_endian_1() {\n  let value = 16777215\n  let bytes = to_bytearray_little_endian(from_int(value))\n  and {\n    ( bytes |> builtin.slice_bytearray(0, 3, _) ) == #\"ffffff\",\n    ( bytes |> builtin.bytearray_to_integer(False, _) ) == value,\n  }\n}\n\n// ## Tests for various operations and edge cases\n\ntest add_bytes_1() {\n  let x = from_int(100)\n  let result = add_bytes(x, #\"0a\") |> to_int\n  result == 110\n}\n\ntest add_int_1() {\n  let x = from_int(100)\n  let result = add_int(x, 50) |> to_int\n  result == 150\n}\n\ntest mul_bytes_1() {\n  let x = from_int(10)\n  let result = mul_bytes(x, #\"0a\") |> to_int\n  result == 100\n}\n\ntest mul_int_1() {\n  let x = from_int(10)\n  let result = mul_int(x, 5) |> to_int\n  result == 50\n}\n\ntest sub_bytes_1() {\n  let x = from_int(100)\n  let result = sub_bytes(x, #\"0a\") |> to_int\n  result == 90\n}\n\ntest sub_int_1() {\n  let x = from_int(100)\n  let result = sub_int(x, 60) |> to_int\n  result == 40\n}\n\ntest sub_underflow_1() {\n  let a = from_int(0)\n  let b = from_int(1)\n\n  ( sub(a, b) |> to_int ) == field - 1\n}\n\ntest overflow_handling() {\n  let max = from_int(field - 1)\n  and {\n    (add_int(max, 1) == zero)?,\n    (( add_int(max, 2) |> to_int ) == 1)?,\n  }\n}\n\ntest wraparound_behavior() {\n  let x = from_int(10)\n  let y = from_int(15)\n  and {\n    ( sub(x, y) |> to_int ) == field - 5,\n    (add(sub(x, y), y) == x)?,\n  }\n}\n\ntest from_bytes_tests() {\n  let a = #\"acabbeefface\"\n  let b = #\"cafe\"\n\n  and {\n    ( from_bytearray_big_endian(a) |> to_int ) == 0xacabbeefface,\n    ( from_bytearray_big_endian(b) |> to_int ) == 0xcafe,\n    ( from_bytearray_little_endian(a) |> to_int ) == 0xcefaefbeabac,\n    ( from_bytearray_little_endian(b) |> to_int ) == 0xfeca,\n  }\n}\n\ntest add_tests() {\n  let a = from_bytearray_big_endian(#\"acab\")\n  let b = from_bytearray_big_endian(#\"cafe\")\n\n  and {\n    (\n      add(a, b) |> to_bytearray_big_endian |> builtin.slice_bytearray(25, 28, _)\n    ) == #\"0177a9\",\n    add(from_int(0), from_bytearray_big_endian(#\"01\")) == from_bytearray_big_endian(\n      #\"01\",\n    ),\n  }\n}\n\ntest add_communitive() {\n  let a = from_bytearray_big_endian(#\"acab\")\n  let b = from_bytearray_big_endian(#\"cafe\")\n\n  add(a, b) == add(b, a)\n}\n\ntest add_associativity() {\n  let a = from_bytearray_big_endian(#\"0101\")\n  let b = from_bytearray_big_endian(#\"0202\")\n  let c = from_bytearray_big_endian(#\"0303\")\n\n  add(add(a, b), c) == add(a, add(b, c))\n}\n\ntest add_identity() {\n  let a = from_bytearray_big_endian(#\"01\")\n\n  add(zero, a) == a\n}\n\ntest add_bytes_tests() {\n  let a = from_int(0)\n  let b = from_bytearray_big_endian(#\"acab\")\n\n  and {\n    (\n      add_bytes(a, #\"cafe\")\n        |> to_bytearray_big_endian\n        |> builtin.slice_bytearray(26, 28, _)\n    ) == #\"cafe\",\n    (\n      add_bytes(b, #\"cafe\")\n        |> to_bytearray_big_endian\n        |> builtin.slice_bytearray(25, 28, _)\n    ) == #\"0177a9\",\n  }\n}\n\ntest sub_tests() {\n  let a = from_bytearray_big_endian(#\"0177a9\")\n  let b = from_bytearray_big_endian(#\"cafe\")\n\n  and {\n    (\n      sub(a, b) |> to_bytearray_big_endian |> builtin.slice_bytearray(26, 28, _)\n    ) == #\"acab\",\n    (\n      sub(\n        from_bytearray_big_endian(#\"77a9\"),\n        from_bytearray_big_endian(#\"cafe\"),\n      )\n        |> to_bytearray_big_endian\n        |> builtin.slice_bytearray(26, 28, _)\n    ) == #\"acab\",\n  }\n}\n\ntest sub_identity() {\n  let a = from_bytearray_big_endian(#\"10\")\n\n  sub(a, zero) == a\n}\n\ntest mul_tests() {\n  let a = from_bytearray_big_endian(#\"ffff\")\n  let b = from_bytearray_big_endian(#\"ffff\")\n\n  ( mul(a, b) |> to_bytearray_big_endian |> builtin.slice_bytearray(24, 28, _) ) == #\"fffe0001\"\n}\n\ntest mul_communitive() {\n  let a = from_bytearray_big_endian(#\"acab\")\n  let b = from_bytearray_big_endian(#\"cafe\")\n\n  mul(a, b) == mul(b, a)\n}\n\ntest mul_associativity() {\n  let a = from_bytearray_big_endian(#\"33\")\n  let b = from_bytearray_big_endian(#\"44\")\n  let c = from_bytearray_big_endian(#\"55\")\n\n  mul(mul(a, b), c) == mul(a, mul(b, c))\n}\n\ntest mul_identity() {\n  let a = from_bytearray_big_endian(#\"acab\")\n\n  mul(one, a) == a\n}\n\ntest mul_bytes_tests() {\n  let a = from_int(0)\n  let b = from_bytearray_big_endian(#\"0002\")\n\n  and {\n    mul_bytes(a, #\"cafe\") == zero,\n    (\n      mul_bytes(b, #\"0003\")\n        |> to_bytearray_big_endian\n        |> builtin.slice_bytearray(26, 28, _)\n    ) == #\"0006\",\n  }\n}\n\ntest bytes_conversion_roundtrip() {\n  let original = #\"acabbeefface\"\n\n  and {\n    (\n      to_bytearray_big_endian(from_bytearray_big_endian(original))\n        |> builtin.slice_bytearray(\n            28 - builtin.length_of_bytearray(original),\n            28,\n            _,\n          )\n    ) == original,\n    (\n      to_bytearray_little_endian(from_bytearray_little_endian(original))\n        |> builtin.slice_bytearray(0, builtin.length_of_bytearray(original), _)\n    ) == original,\n  }\n}\n\ntest operation_with_zero() {\n  and {\n    add(zero, zero) == zero,\n    mul(zero, from_int(123456)) == zero,\n    sub(zero, zero) == zero,\n    neg(zero) == zero,\n  }\n}\n\ntest operation_with_large_numbers() {\n  let almost_field_size = from_int(field - 1)\n  let large_num = from_int(0xffffffffffffffffffffff)\n\n  and {\n    add(almost_field_size, one) == zero,\n    mul(large_num, large_num) != zero,\n    // Should be non-zero due to modular arithmetic\n    neg(almost_field_size) == one,\n  }\n}\n",
      "dependencies": ["aiken/builtin", "aiken/crypto/bitwise"],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.crypto.int256",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/crypto/int256.ak",
      "name": "aiken.crypto.int256",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 9,
          "raw": "use aiken/builtin",
          "source": "stdlib"
        },
        {
          "module": "aiken/crypto/bitwise",
          "items": [],
          "line": 10,
          "raw": "use aiken/crypto/bitwise",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "from_bytearray_big_endian",
          "signature": "pub fn from_bytearray_big_endian(bytes: ByteArray) -> State {",
          "documentation": "Constructs a new `Bits256` element from a Big-Endian (most-significant bits first) `ByteArray`.",
          "parameters": [
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 33,
          "raw": "pub fn from_bytearray_big_endian(bytes: ByteArray) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_bytearray_big_endian(bytes: ByteArray) -> State {\n  bytes\n    |> builtin.bytearray_to_integer(True, _)\n    |> bitwise.from_int(field)\n}"
        },
        {
          "name": "from_bytearray_little_endian",
          "signature": "pub fn from_bytearray_little_endian(bytes: ByteArray) -> State {",
          "documentation": "Constructs a new `Bits256` element from a Little-Endian (least-significant bits first) `ByteArray`.",
          "parameters": [
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 40,
          "raw": "pub fn from_bytearray_little_endian(bytes: ByteArray) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_bytearray_little_endian(bytes: ByteArray) -> State {\n  bytes\n    |> builtin.bytearray_to_integer(False, _)\n    |> bitwise.from_int(field)\n}"
        },
        {
          "name": "from_int",
          "signature": "pub fn from_int(int: Int) -> State {",
          "documentation": "Constructs a new `Bits256` element from an integer, ensuring it's within the valid range of the field.",
          "parameters": [
            {
              "name": "int",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 47,
          "raw": "pub fn from_int(int: Int) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_int(int: Int) -> State {\n  bitwise.from_int(int, field)\n}"
        },
        {
          "name": "scale",
          "signature": "pub fn scale(self: State, e: Int) -> State {",
          "documentation": "Exponentiates a `Bits256` element by a non-negative integer exponent, using repeated squaring.\nNote that this function returns `zero` for negative exponents.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            },
            {
              "name": "e",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 55,
          "raw": "pub fn scale(self: State, e: Int) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn scale(self: State, e: Int) -> State {\n  bitwise.scale(self, e, mul)\n}"
        },
        {
          "name": "scale2",
          "signature": "pub fn scale2(self: State, k: Int) -> State {",
          "documentation": "A faster version of `scale` for the case where the exponent is a power of two.\nThat is, the exponent $e = 2^k$ for some non-negative integer $k$.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            },
            {
              "name": "k",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 61,
          "raw": "pub fn scale2(self: State, k: Int) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn scale2(self: State, k: Int) -> State {\n  bitwise.scale2(self, k, mul)\n}"
        },
        {
          "name": "add",
          "signature": "pub fn add(left: State, right: State) -> State {",
          "documentation": "Adds two `Bits256` elements, ensuring the result stays within the finite field range.",
          "parameters": [
            {
              "name": "left",
              "type": "State",
              "optional": false
            },
            {
              "name": "right",
              "type": "State",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 70,
          "raw": "pub fn add(left: State, right: State) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn add(left: State, right: State) -> State {\n  add_s_hash256(left, right)\n}"
        },
        {
          "name": "add_bytes",
          "signature": "pub fn add_bytes(self: State, bytes: ByteArray) -> State {",
          "documentation": "Adds a ByteArray to a `Bits256` element, interpreting bytes as a big-endian number.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            },
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 77,
          "raw": "pub fn add_bytes(self: State, bytes: ByteArray) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn add_bytes(self: State, bytes: ByteArray) -> State {\n  add_bit256(self, bytes)\n}"
        },
        {
          "name": "add_int",
          "signature": "pub fn add_int(self: State, int: Int) -> State {",
          "documentation": "Adds an integer to a `Bits256` element.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            },
            {
              "name": "int",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 84,
          "raw": "pub fn add_int(self: State, int: Int) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn add_int(self: State, int: Int) -> State {\n  add_i256(self, int)\n}"
        },
        {
          "name": "mul",
          "signature": "pub fn mul(left: State, right: State) -> State {",
          "documentation": "Multiplies two `Bits256` elements, with the result constrained within the finite field.",
          "parameters": [
            {
              "name": "left",
              "type": "State",
              "optional": false
            },
            {
              "name": "right",
              "type": "State",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 91,
          "raw": "pub fn mul(left: State, right: State) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn mul(left: State, right: State) -> State {\n  mul_s_hash256(left, right)\n}"
        },
        {
          "name": "mul_bytes",
          "signature": "pub fn mul_bytes(self: State, bytes: ByteArray) -> State {",
          "documentation": "Multiplies a `Bits256` element by a ByteArray, interpreting bytes as a big-endian number.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            },
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 98,
          "raw": "pub fn mul_bytes(self: State, bytes: ByteArray) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn mul_bytes(self: State, bytes: ByteArray) -> State {\n  mul_bit256(self, bytes)\n}"
        },
        {
          "name": "mul_int",
          "signature": "pub fn mul_int(self: State, int: Int) -> State {",
          "documentation": "Multiplies a `Bits256` element by an integer.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            },
            {
              "name": "int",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 105,
          "raw": "pub fn mul_int(self: State, int: Int) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn mul_int(self: State, int: Int) -> State {\n  mul_i256(self, int)\n}"
        },
        {
          "name": "neg",
          "signature": "pub fn neg(self: State) -> State {",
          "documentation": "Calculates the additive inverse of a `Bits256` element.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 112,
          "raw": "pub fn neg(self: State) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn neg(self: State) -> State {\n  neg256(self)\n}"
        },
        {
          "name": "sub",
          "signature": "pub fn sub(left: State, right: State) -> State {",
          "documentation": "Subtracts one `Bits256` element from another, with the result wrapped within the finite field range.",
          "parameters": [
            {
              "name": "left",
              "type": "State",
              "optional": false
            },
            {
              "name": "right",
              "type": "State",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 119,
          "raw": "pub fn sub(left: State, right: State) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sub(left: State, right: State) -> State {\n  sub_s_hash256(left, right)\n}"
        },
        {
          "name": "sub_bytes",
          "signature": "pub fn sub_bytes(self: State, bytes: ByteArray) -> State {",
          "documentation": "Subtracts a `ByteArray` from a `Bits256` element, interpreting bytes as a big-endian number.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            },
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 126,
          "raw": "pub fn sub_bytes(self: State, bytes: ByteArray) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sub_bytes(self: State, bytes: ByteArray) -> State {\n  sub_bit256(self, bytes)\n}"
        },
        {
          "name": "sub_int",
          "signature": "pub fn sub_int(self: State, int: Int) -> State {",
          "documentation": "Subtracts an integer from a `Bits256` element.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            },
            {
              "name": "int",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "State",
          "line": 133,
          "raw": "pub fn sub_int(self: State, int: Int) -> State {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sub_int(self: State, int: Int) -> State {\n  sub_i256(self, int)\n}"
        },
        {
          "name": "to_bytearray_big_endian",
          "signature": "pub fn to_bytearray_big_endian(self: State) -> ByteArray {",
          "documentation": "Converts a `Bits256` element to a Big-Endian (most-significant bits first) `ByteArray`.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 140,
          "raw": "pub fn to_bytearray_big_endian(self: State) -> ByteArray {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn to_bytearray_big_endian(self: State) -> ByteArray {\n  bitwise.to_int(self)\n    |> builtin.integer_to_bytearray(True, field_size, _)\n}"
        },
        {
          "name": "to_bytearray_little_endian",
          "signature": "pub fn to_bytearray_little_endian(self: State) -> ByteArray {",
          "documentation": "Converts a `Bits256` element to a Little-Endian (least-significant bits first) `ByteArray`.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 146,
          "raw": "pub fn to_bytearray_little_endian(self: State) -> ByteArray {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn to_bytearray_little_endian(self: State) -> ByteArray {\n  bitwise.to_int(self)\n    |> builtin.integer_to_bytearray(False, field_size, _)\n}"
        },
        {
          "name": "to_int",
          "signature": "pub fn to_int(self: State) -> Int {",
          "documentation": "Converts a `Bits256` element back to its integer representation.",
          "parameters": [
            {
              "name": "self",
              "type": "State",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 152,
          "raw": "pub fn to_int(self: State) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn to_int(self: State) -> Int {\n  bitwise.to_int(self)\n}"
        }
      ],
      "types": [
        {
          "name": "Bits256",
          "definition": "opaque { Bits256 }",
          "line": 20,
          "raw": "pub opaque type Bits256 {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "State",
          "definition": "bitwise.State<Bits256>",
          "line": 24,
          "raw": "pub type State =",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "constants": [
        {
          "name": "field_size",
          "type": "Unknown",
          "value": "32",
          "line": 18,
          "raw": "pub const field_size = 32",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "atoms": [],
      "privateTypes": [
        {
          "name": "Over<a>",
          "definition": "fn(State, a) -> State",
          "line": 27,
          "raw": "type Over<a> =",
          "isPublic": false,
          "source": "stdlib"
        }
      ],
      "privateConstants": [
        {
          "name": "add_s_hash256",
          "type": "Over<State>",
          "value": "bitwise.add_state(field)",
          "line": 67,
          "raw": "const add_s_hash256: Over<State> = bitwise.add_state(field)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "add_bit256",
          "type": "Over<ByteArray>",
          "value": "bitwise.add_bits(field, True)",
          "line": 74,
          "raw": "const add_bit256: Over<ByteArray> = bitwise.add_bits(field, True)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "add_i256",
          "type": "Over<Int>",
          "value": "bitwise.add_int(field)",
          "line": 81,
          "raw": "const add_i256: Over<Int> = bitwise.add_int(field)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "mul_s_hash256",
          "type": "Over<State>",
          "value": "bitwise.mul_state(field)",
          "line": 88,
          "raw": "const mul_s_hash256: Over<State> = bitwise.mul_state(field)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "mul_bit256",
          "type": "Over<ByteArray>",
          "value": "bitwise.mul_bits(field, True)",
          "line": 95,
          "raw": "const mul_bit256: Over<ByteArray> = bitwise.mul_bits(field, True)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "mul_i256",
          "type": "Over<Int>",
          "value": "bitwise.mul_int(field)",
          "line": 102,
          "raw": "const mul_i256: Over<Int> = bitwise.mul_int(field)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "neg256",
          "type": "fn(State) -> State",
          "value": "bitwise.neg(field)",
          "line": 109,
          "raw": "const neg256: fn(State) -> State = bitwise.neg(field)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "sub_s_hash256",
          "type": "Over<State>",
          "value": "bitwise.sub_state(field)",
          "line": 116,
          "raw": "const sub_s_hash256: Over<State> = bitwise.sub_state(field)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "sub_bit256",
          "type": "Over<ByteArray>",
          "value": "bitwise.sub_bits(field, True)",
          "line": 123,
          "raw": "const sub_bit256: Over<ByteArray> = bitwise.sub_bits(field, True)",
          "isPublic": false,
          "source": "stdlib"
        },
        {
          "name": "sub_i256",
          "type": "Over<Int>",
          "value": "bitwise.sub_int(field)",
          "line": 130,
          "raw": "const sub_i256: Over<Int> = bitwise.sub_int(field)",
          "isPublic": false,
          "source": "stdlib"
        }
      ],
      "content": "//// This module implements arithmetic operations in a constrained 256-bit integer field.\n//// Operations are performed modulo $2^{256}$, providing a field for cryptographic operations\n//// that require 32-byte values.\n////\n//// The module provides functionality for basic arithmetic operations (addition, subtraction,\n//// multiplication) within this constrained field, as well as conversion functions between\n//// different representations.\n\nuse aiken/builtin\nuse aiken/crypto/bitwise\n\n/// The prime defining the 256-bit integer field $2^{256}$\npub const field =\n  builtin.replicate_byte(32, 0)\n    |> builtin.cons_bytearray(1, _)\n    |> builtin.bytearray_to_integer(True, _)\n\npub const field_size = 32\n\npub opaque type Bits256 {\n  Bits256\n}\n\npub type State =\n  bitwise.State<Bits256>\n\ntype Over<a> =\n  fn(State, a) -> State\n\n// ## Constructing\n\n/// Constructs a new `Bits256` element from a Big-Endian (most-significant bits first) `ByteArray`.\npub fn from_bytearray_big_endian(bytes: ByteArray) -> State {\n  bytes\n    |> builtin.bytearray_to_integer(True, _)\n    |> bitwise.from_int(field)\n}\n\n/// Constructs a new `Bits256` element from a Little-Endian (least-significant bits first) `ByteArray`.\npub fn from_bytearray_little_endian(bytes: ByteArray) -> State {\n  bytes\n    |> builtin.bytearray_to_integer(False, _)\n    |> bitwise.from_int(field)\n}\n\n/// Constructs a new `Bits256` element from an integer, ensuring it's within the valid range of the field.\npub fn from_int(int: Int) -> State {\n  bitwise.from_int(int, field)\n}\n\n// ## Modifying\n\n/// Exponentiates a `Bits256` element by a non-negative integer exponent, using repeated squaring.\n/// Note that this function returns `zero` for negative exponents.\npub fn scale(self: State, e: Int) -> State {\n  bitwise.scale(self, e, mul)\n}\n\n/// A faster version of `scale` for the case where the exponent is a power of two.\n/// That is, the exponent $e = 2^k$ for some non-negative integer $k$.\npub fn scale2(self: State, k: Int) -> State {\n  bitwise.scale2(self, k, mul)\n}\n\n// ## Combining\n\nconst add_s_hash256: Over<State> = bitwise.add_state(field)\n\n/// Adds two `Bits256` elements, ensuring the result stays within the finite field range.\npub fn add(left: State, right: State) -> State {\n  add_s_hash256(left, right)\n}\n\nconst add_bit256: Over<ByteArray> = bitwise.add_bits(field, True)\n\n/// Adds a ByteArray to a `Bits256` element, interpreting bytes as a big-endian number.\npub fn add_bytes(self: State, bytes: ByteArray) -> State {\n  add_bit256(self, bytes)\n}\n\nconst add_i256: Over<Int> = bitwise.add_int(field)\n\n/// Adds an integer to a `Bits256` element.\npub fn add_int(self: State, int: Int) -> State {\n  add_i256(self, int)\n}\n\nconst mul_s_hash256: Over<State> = bitwise.mul_state(field)\n\n/// Multiplies two `Bits256` elements, with the result constrained within the finite field.\npub fn mul(left: State, right: State) -> State {\n  mul_s_hash256(left, right)\n}\n\nconst mul_bit256: Over<ByteArray> = bitwise.mul_bits(field, True)\n\n/// Multiplies a `Bits256` element by a ByteArray, interpreting bytes as a big-endian number.\npub fn mul_bytes(self: State, bytes: ByteArray) -> State {\n  mul_bit256(self, bytes)\n}\n\nconst mul_i256: Over<Int> = bitwise.mul_int(field)\n\n/// Multiplies a `Bits256` element by an integer.\npub fn mul_int(self: State, int: Int) -> State {\n  mul_i256(self, int)\n}\n\nconst neg256: fn(State) -> State = bitwise.neg(field)\n\n/// Calculates the additive inverse of a `Bits256` element.\npub fn neg(self: State) -> State {\n  neg256(self)\n}\n\nconst sub_s_hash256: Over<State> = bitwise.sub_state(field)\n\n/// Subtracts one `Bits256` element from another, with the result wrapped within the finite field range.\npub fn sub(left: State, right: State) -> State {\n  sub_s_hash256(left, right)\n}\n\nconst sub_bit256: Over<ByteArray> = bitwise.sub_bits(field, True)\n\n/// Subtracts a `ByteArray` from a `Bits256` element, interpreting bytes as a big-endian number.\npub fn sub_bytes(self: State, bytes: ByteArray) -> State {\n  sub_bit256(self, bytes)\n}\n\nconst sub_i256: Over<Int> = bitwise.sub_int(field)\n\n/// Subtracts an integer from a `Bits256` element.\npub fn sub_int(self: State, int: Int) -> State {\n  sub_i256(self, int)\n}\n\n// ## Transforming\n\n/// Converts a `Bits256` element to a Big-Endian (most-significant bits first) `ByteArray`.\npub fn to_bytearray_big_endian(self: State) -> ByteArray {\n  bitwise.to_int(self)\n    |> builtin.integer_to_bytearray(True, field_size, _)\n}\n\n/// Converts a `Bits256` element to a Little-Endian (least-significant bits first) `ByteArray`.\npub fn to_bytearray_little_endian(self: State) -> ByteArray {\n  bitwise.to_int(self)\n    |> builtin.integer_to_bytearray(False, field_size, _)\n}\n\n/// Converts a `Bits256` element back to its integer representation.\npub fn to_int(self: State) -> Int {\n  bitwise.to_int(self)\n}\n",
      "dependencies": ["aiken/builtin", "aiken/crypto/bitwise"],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.crypto.int256.tests",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/crypto/int256.tests.ak",
      "name": "aiken.crypto.int256.tests",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 1,
          "raw": "use aiken/builtin",
          "source": "stdlib"
        },
        {
          "module": "aiken/crypto/bitwise",
          "items": ["one", "zero"],
          "line": 2,
          "raw": "use aiken/crypto/bitwise.{one, zero}",
          "source": "stdlib"
        }
      ],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/builtin\nuse aiken/crypto/bitwise.{one, zero}\nuse aiken/crypto/int256.{\n  add, add_bytes, add_int, field, from_bytearray_big_endian,\n  from_bytearray_little_endian, from_int, mul, mul_bytes, mul_int, neg, scale,\n  scale2, sub, sub_bytes, sub_int, to_bytearray_big_endian,\n  to_bytearray_little_endian, to_int,\n}\n\ntest equal_pad_for_addition() {\n  let a: ByteArray = #\"acab\"\n  let b: ByteArray = #\"cafe\"\n\n  let x =\n    a\n      |> from_bytearray_big_endian\n      |> add_bytes(b)\n      |> to_bytearray_big_endian\n\n  x == #\"00000000000000000000000000000000000000000000000000000000000177a9\"\n}\n\ntest unequal_pad_for_addition() {\n  let a: ByteArray = #\"acabbeefface\"\n  let b: ByteArray = #\"cafe\"\n\n  let x =\n    a\n      |> from_bytearray_big_endian\n      |> add_bytes(b)\n      |> to_bytearray_big_endian\n\n  x == #\"0000000000000000000000000000000000000000000000000000acabbef0c5cc\"\n}\n\n// ## Test for constructing Hash256 elements\n\ntest from_int_1() {\n  and {\n    ( from_int(-1) |> to_int ) == field - 1,\n    ( from_int(field) |> to_int ) == 0,\n    ( from_int(834884848) |> to_int ) == 834884848,\n  }\n}\n\ntest from_bytes_big_endian_1() {\n  ( from_bytearray_big_endian(#\"ffff00\") |> to_int ) == 16776960\n}\n\ntest from_bytes_little_endian_1() {\n  ( from_bytearray_little_endian(#\"ffff00\") |> to_int ) == 65535\n}\n\n// ## Tests for modifying Hash256 elements\n\ntest scale_1() {\n  let x = from_int(834884848)\n\n  and {\n    ( x |> scale(-1) ) == zero,\n    ( x |> scale(0) ) == one,\n    ( x |> scale(1) ) == x,\n    ( x |> scale(2) |> to_int ) == 697032709419983104,\n    ( x |> scale(3) |> to_int ) == 581942047655130761945608192,\n    (\n      from_int(field - 5)\n        |> scale(200)\n        |> to_int\n    ) != 0,\n  }\n}\n\ntest scale2_1() {\n  let a = from_int(2)\n\n  and {\n    ( scale2(a, 0) |> to_int ) == 2,\n    ( scale2(a, 1) |> to_int ) == 4,\n    ( scale2(a, 2) |> to_int ) == 16,\n    ( scale2(a, 3) |> to_int ) == 256,\n  }\n}\n\n// ## Tests for combining Hash256 elements\n\ntest add_1() {\n  let x = from_int(834884848)\n  let y = from_int(field - 1)\n  let z = from_int(3)\n\n  and {\n    (( add(x, x) |> to_int ) == 1669769696)?,\n    (add(y, one) == zero)?,\n    (add(z, add(y, one)) == z)?,\n  }\n}\n\ntest add_overflow_1() {\n  let a = from_int(field - 1)\n  let b = from_int(1)\n\n  ( add(a, b) |> to_int ) == 0\n}\n\ntest mul_1() {\n  let x = from_int(834884848)\n  and {\n    mul(x, x) == from_int(697032709419983104),\n    mul(zero, x) == zero,\n    mul(from_int(field - 1), from_int(2)) == from_int(field - 2),\n  }\n}\n\ntest neg_1() {\n  and {\n    neg(from_int(834884848)) == from_int(field - 834884848),\n    neg(zero) == zero,\n    neg(one) == from_int(field - 1),\n  }\n}\n\ntest sub_1() {\n  let x = from_int(834884848)\n\n  and {\n    (sub(x, x) == zero)?,\n    (sub(zero, from_int(5)) == from_int(field - 5))?,\n  }\n}\n\n// ## Tests for transforming Hash256 elements\n\ntest to_int_1() {\n  to_int(from_int(834884848)) == 834884848\n}\n\ntest to_bytes_1() {\n  (\n    to_bytearray_big_endian(from_int(16777215))\n      |> builtin.slice_bytearray(29, 32, _)\n  ) == #\"ffffff\"\n}\n\ntest to_bytes_little_endian_1() {\n  let value = 16777215\n  let bytes = to_bytearray_little_endian(from_int(value))\n  and {\n    ( bytes |> builtin.slice_bytearray(0, 3, _) ) == #\"ffffff\",\n    ( bytes |> builtin.bytearray_to_integer(False, _) ) == value,\n  }\n}\n\n// ## Tests for various operations and edge cases\n\ntest add_bytes_1() {\n  let x = from_int(100)\n  let result = add_bytes(x, #\"0a\") |> to_int\n  result == 110\n}\n\ntest add_int_1() {\n  let x = from_int(100)\n  let result = add_int(x, 50) |> to_int\n  result == 150\n}\n\ntest mul_bytes_1() {\n  let x = from_int(10)\n  let result = mul_bytes(x, #\"0a\") |> to_int\n  result == 100\n}\n\ntest mul_int_1() {\n  let x = from_int(10)\n  let result = mul_int(x, 5) |> to_int\n  result == 50\n}\n\ntest sub_bytes_1() {\n  let x = from_int(100)\n\n  trace builtin.bytearray_to_integer(True, #\"0a\")\n\n  let result = sub_bytes(x, #\"0a\") |> to_int\n  result == 90\n}\n\ntest sub_int_1() {\n  let x = from_int(100)\n  let result = sub_int(x, 60) |> to_int\n  result == 40\n}\n\ntest sub_underflow_1() {\n  let a = from_int(0)\n  let b = from_int(1)\n\n  ( sub(a, b) |> to_int ) == field - 1\n}\n\ntest overflow_handling() {\n  let max = from_int(field - 1)\n  and {\n    (add_int(max, 1) == zero)?,\n    (( add_int(max, 2) |> to_int ) == 1)?,\n  }\n}\n\ntest wraparound_behavior() {\n  let x = from_int(10)\n  let y = from_int(15)\n  and {\n    ( sub(x, y) |> to_int ) == field - 5,\n    (add(sub(x, y), y) == x)?,\n  }\n}\n\ntest from_bytes_tests() {\n  let a = #\"acabbeefface\"\n  let b = #\"cafe\"\n\n  trace from_bytearray_little_endian(a)\n  trace 0xfaceefbeabac\n\n  and {\n    ( from_bytearray_big_endian(a) |> to_int ) == 0xacabbeefface,\n    ( from_bytearray_big_endian(b) |> to_int ) == 0xcafe,\n    ( from_bytearray_little_endian(a) |> to_int ) == 0xcefaefbeabac,\n    ( from_bytearray_little_endian(b) |> to_int ) == 0xfeca,\n  }\n}\n\ntest add_tests() {\n  let a = from_bytearray_big_endian(#\"acab\")\n  let b = from_bytearray_big_endian(#\"cafe\")\n\n  and {\n    (\n      add(a, b) |> to_bytearray_big_endian |> builtin.slice_bytearray(29, 32, _)\n    ) == #\"0177a9\",\n    add(from_int(0), from_bytearray_big_endian(#\"01\")) == from_bytearray_big_endian(\n      #\"01\",\n    ),\n  }\n}\n\ntest add_communitive() {\n  let a = from_bytearray_big_endian(#\"acab\")\n  let b = from_bytearray_big_endian(#\"cafe\")\n\n  add(a, b) == add(b, a)\n}\n\ntest add_associativity() {\n  let a = from_bytearray_big_endian(#\"0101\")\n  let b = from_bytearray_big_endian(#\"0202\")\n  let c = from_bytearray_big_endian(#\"0303\")\n\n  add(add(a, b), c) == add(a, add(b, c))\n}\n\ntest add_identity() {\n  let a = from_bytearray_big_endian(#\"01\")\n\n  add(zero, a) == a\n}\n\ntest add_bytes_tests() {\n  let a = from_int(0)\n  let b = from_bytearray_big_endian(#\"acab\")\n\n  and {\n    (\n      add_bytes(a, #\"cafe\")\n        |> to_bytearray_big_endian\n        |> builtin.slice_bytearray(30, 32, _)\n    ) == #\"cafe\",\n    (\n      add_bytes(b, #\"cafe\")\n        |> to_bytearray_big_endian\n        |> builtin.slice_bytearray(29, 32, _)\n    ) == #\"0177a9\",\n  }\n}\n\ntest sub_tests() {\n  let a = from_bytearray_big_endian(#\"0177a9\")\n  let b = from_bytearray_big_endian(#\"cafe\")\n\n  and {\n    (\n      sub(a, b) |> to_bytearray_big_endian |> builtin.slice_bytearray(30, 32, _)\n    ) == #\"acab\",\n    (\n      sub(\n        from_bytearray_big_endian(#\"77a9\"),\n        from_bytearray_big_endian(#\"cafe\"),\n      )\n        |> to_bytearray_big_endian\n        |> builtin.slice_bytearray(30, 32, _)\n    ) == #\"acab\",\n  }\n}\n\ntest sub_identity() {\n  let a = from_bytearray_big_endian(#\"10\")\n\n  sub(a, zero) == a\n}\n\ntest mul_tests() {\n  let a = from_bytearray_big_endian(#\"ffff\")\n  let b = from_bytearray_big_endian(#\"ffff\")\n\n  ( mul(a, b) |> to_bytearray_big_endian |> builtin.slice_bytearray(28, 32, _) ) == #\"fffe0001\"\n}\n\ntest mul_communitive() {\n  let a = from_bytearray_big_endian(#\"acab\")\n  let b = from_bytearray_big_endian(#\"cafe\")\n\n  mul(a, b) == mul(b, a)\n}\n\ntest mul_associativity() {\n  let a = from_bytearray_big_endian(#\"33\")\n  let b = from_bytearray_big_endian(#\"44\")\n  let c = from_bytearray_big_endian(#\"55\")\n\n  mul(mul(a, b), c) == mul(a, mul(b, c))\n}\n\ntest mul_identity() {\n  let a = from_bytearray_big_endian(#\"acab\")\n\n  mul(one, a) == a\n}\n\ntest mul_bytes_tests() {\n  let a = from_int(0)\n  let b = from_bytearray_big_endian(#\"0002\")\n\n  and {\n    mul_bytes(a, #\"cafe\") == zero,\n    (\n      mul_bytes(b, #\"0003\")\n        |> to_bytearray_big_endian\n        |> builtin.slice_bytearray(30, 32, _)\n    ) == #\"0006\",\n  }\n}\n\ntest bytes_conversion_roundtrip() {\n  let original = #\"acabbeefface\"\n\n  and {\n    (\n      to_bytearray_big_endian(from_bytearray_big_endian(original))\n        |> builtin.slice_bytearray(\n            32 - builtin.length_of_bytearray(original),\n            32,\n            _,\n          )\n    ) == original,\n    (\n      to_bytearray_little_endian(from_bytearray_little_endian(original))\n        |> builtin.slice_bytearray(0, builtin.length_of_bytearray(original), _)\n    ) == original,\n  }\n}\n\ntest operation_with_zero() {\n  and {\n    add(zero, zero) == zero,\n    mul(zero, from_int(123456)) == zero,\n    sub(zero, zero) == zero,\n    neg(zero) == zero,\n  }\n}\n\ntest operation_with_large_numbers() {\n  let almost_field_size = from_int(field - 1)\n  let large_num = from_int(0xffffffffffffffffffffffffffffff)\n\n  and {\n    add(almost_field_size, one) == zero,\n    mul(large_num, large_num) != zero,\n    // Should be non-zero due to modular arithmetic\n    neg(almost_field_size) == one,\n  }\n}\n",
      "dependencies": ["aiken/builtin", "aiken/crypto/bitwise"],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.crypto",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/crypto.ak",
      "name": "aiken.crypto",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 1,
          "raw": "use aiken/builtin",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "blake2b_224",
          "signature": "pub fn blake2b_224(bytes: ByteArray) -> Hash<Blake2b_224, a> {",
          "documentation": "Compute the blake2b-224 hash digest (28 bytes) of some data.\nMinimum Plutus Version: 3",
          "parameters": [
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Hash<Blake2b_224, a>",
          "line": 68,
          "raw": "pub fn blake2b_224(bytes: ByteArray) -> Hash<Blake2b_224, a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn blake2b_224(bytes: ByteArray) -> Hash<Blake2b_224, a> {\n  builtin.blake2b_224(bytes)\n}"
        },
        {
          "name": "blake2b_256",
          "signature": "pub fn blake2b_256(bytes: ByteArray) -> Hash<Blake2b_256, a> {",
          "documentation": "Compute the blake2b-256 hash digest (32 bytes) of some data.",
          "parameters": [
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Hash<Blake2b_256, a>",
          "line": 82,
          "raw": "pub fn blake2b_256(bytes: ByteArray) -> Hash<Blake2b_256, a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn blake2b_256(bytes: ByteArray) -> Hash<Blake2b_256, a> {\n  builtin.blake2b_256(bytes)\n}"
        },
        {
          "name": "keccak_256",
          "signature": "pub fn keccak_256(bytes: ByteArray) -> Hash<Keccak_256, a> {",
          "documentation": "Compute the keccak-256 hash digest (32 bytes) of some data.",
          "parameters": [
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Hash<Keccak_256, a>",
          "line": 92,
          "raw": "pub fn keccak_256(bytes: ByteArray) -> Hash<Keccak_256, a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn keccak_256(bytes: ByteArray) -> Hash<Keccak_256, a> {\n  builtin.keccak_256(bytes)\n}"
        },
        {
          "name": "sha2_256",
          "signature": "pub fn sha2_256(bytes: ByteArray) -> Hash<Sha2_256, a> {",
          "documentation": "Compute the sha2-256 hash digest (32 bytes) of some data.",
          "parameters": [
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Hash<Sha2_256, a>",
          "line": 102,
          "raw": "pub fn sha2_256(bytes: ByteArray) -> Hash<Sha2_256, a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sha2_256(bytes: ByteArray) -> Hash<Sha2_256, a> {\n  builtin.sha2_256(bytes)\n}"
        },
        {
          "name": "sha3_256",
          "signature": "pub fn sha3_256(bytes: ByteArray) -> Hash<Sha3_256, a> {",
          "documentation": "Compute the sha3-256 hash digest (32 bytes) of some data.",
          "parameters": [
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Hash<Sha3_256, a>",
          "line": 112,
          "raw": "pub fn sha3_256(bytes: ByteArray) -> Hash<Sha3_256, a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sha3_256(bytes: ByteArray) -> Hash<Sha3_256, a> {\n  builtin.sha3_256(bytes)\n}"
        },
        {
          "name": "verify_ecdsa_signature",
          "signature": "pub fn verify_ecdsa_signature(pub fn verify_ecdsa_signature(key: VerificationKey, msg: ByteArray, sig: Signature, ) -> Bool {",
          "documentation": "Verify an ECDCA signature (over secp256k1) using the given verification key.\nReturns `True` when the signature is valid.",
          "parameters": [],
          "returnType": "Bool",
          "line": 120,
          "raw": "pub fn verify_ecdsa_signature(pub fn verify_ecdsa_signature(key: VerificationKey, msg: ByteArray, sig: Signature, ) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn verify_ecdsa_signature(\n  key: VerificationKey,\n  msg: ByteArray,\n  sig: Signature,\n) -> Bool {\n  builtin.verify_ecdsa_secp256k1_signature(key, msg, sig)\n}"
        },
        {
          "name": "verify_ed25519_signature",
          "signature": "pub fn verify_ed25519_signature(pub fn verify_ed25519_signature(key: VerificationKey, msg: ByteArray, sig: Signature, ) -> Bool {",
          "documentation": "Verify an Ed25519 signature using the given verification key.\nReturns `True` when the signature is valid.",
          "parameters": [],
          "returnType": "Bool",
          "line": 130,
          "raw": "pub fn verify_ed25519_signature(pub fn verify_ed25519_signature(key: VerificationKey, msg: ByteArray, sig: Signature, ) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn verify_ed25519_signature(\n  key: VerificationKey,\n  msg: ByteArray,\n  sig: Signature,\n) -> Bool {\n  builtin.verify_ed25519_signature(key, msg, sig)\n}"
        },
        {
          "name": "verify_schnorr_signature",
          "signature": "pub fn verify_schnorr_signature(pub fn verify_schnorr_signature(key: VerificationKey, msg: ByteArray, sig: Signature, ) -> Bool {",
          "documentation": "Verify a Schnorr signature (over secp256k1) using the given verification key.\nReturns `True` when the signature is valid.",
          "parameters": [],
          "returnType": "Bool",
          "line": 140,
          "raw": "pub fn verify_schnorr_signature(pub fn verify_schnorr_signature(key: VerificationKey, msg: ByteArray, sig: Signature, ) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn verify_schnorr_signature(\n  key: VerificationKey,\n  msg: ByteArray,\n  sig: Signature,\n) -> Bool {\n  builtin.verify_schnorr_secp256k1_signature(key, msg, sig)\n}"
        }
      ],
      "types": [
        {
          "name": "VerificationKey",
          "definition": "ByteArray",
          "line": 3,
          "raw": "pub type VerificationKey =",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "VerificationKeyHash",
          "definition": "Hash<Blake2b_224, VerificationKey>",
          "line": 6,
          "raw": "pub type VerificationKeyHash =",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Script",
          "definition": "ByteArray",
          "line": 9,
          "raw": "pub type Script =",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "ScriptHash",
          "definition": "Hash<Blake2b_224, Script>",
          "line": 12,
          "raw": "pub type ScriptHash =",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Signature",
          "definition": "ByteArray",
          "line": 15,
          "raw": "pub type Signature =",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "DataHash",
          "definition": "Hash<Blake2b_256, Data>",
          "line": 18,
          "raw": "pub type DataHash =",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Hash<alg, a>",
          "definition": "ByteArray",
          "line": 51,
          "raw": "pub type Hash<alg, a> =",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Blake2b_224",
          "definition": "opaque { Blake2b_224 }",
          "line": 62,
          "raw": "pub opaque type Blake2b_224 {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Blake2b_256",
          "definition": "opaque { Blake2b_256 }",
          "line": 77,
          "raw": "pub opaque type Blake2b_256 {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Keccak_256",
          "definition": "opaque { Keccak_256 }",
          "line": 87,
          "raw": "pub opaque type Keccak_256 {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Sha2_256",
          "definition": "opaque { Sha2_256 }",
          "line": 97,
          "raw": "pub opaque type Sha2_256 {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Sha3_256",
          "definition": "opaque { Sha3_256 }",
          "line": 107,
          "raw": "pub opaque type Sha3_256 {",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/builtin\n\npub type VerificationKey =\n  ByteArray\n\npub type VerificationKeyHash =\n  Hash<Blake2b_224, VerificationKey>\n\npub type Script =\n  ByteArray\n\npub type ScriptHash =\n  Hash<Blake2b_224, Script>\n\npub type Signature =\n  ByteArray\n\npub type DataHash =\n  Hash<Blake2b_256, Data>\n\n/// A `Hash` is nothing more than a `ByteArray`, but it carries extra\n/// information for readability.\n///\n/// On-chain, any hash digest value is represented as a plain 'ByteArray'.\n/// Though in practice, hashes come from different sources and have\n/// different semantics.\n///\n/// Hence, while this type-alias doesn't provide any strong type-guarantees,\n/// it helps writing functions signatures with more meaningful types than mere\n/// 'ByteArray'.\n///\n/// Compare for example:\n///\n/// ```aiken\n/// pub type Credential {\n///   VerificationKey(ByteArray)\n///   Script(ByteArray)\n/// }\n/// ```\n///\n/// with\n///\n/// ```aiken\n/// pub type Credential {\n///   VerificationKey(Hash<Blake2b_224, VerificationKey>)\n///   Script(Hash<Blake2b_224, Script>)\n/// }\n/// ```\n///\n/// Both are strictly equivalent, but the second reads much better.\npub type Hash<alg, a> =\n  ByteArray\n\n// ## Hashing\n\n/// A blake2b-224 hash algorithm.\n///\n/// Typically used for:\n///\n/// - [`Credential`](../cardano/address.html#Credential)\n/// - [`PolicyId`](../cardano/assets.html#PolicyId)\npub opaque type Blake2b_224 {\n  Blake2b_224\n}\n\n/// Compute the blake2b-224 hash digest (28 bytes) of some data.\n/// Minimum Plutus Version: 3\npub fn blake2b_224(bytes: ByteArray) -> Hash<Blake2b_224, a> {\n  builtin.blake2b_224(bytes)\n}\n\n/// A blake2b-256 hash algorithm.\n///\n/// Typically used for:\n///\n/// - [`TransactionId`](../cardano/transaction.html#TransactionId)\npub opaque type Blake2b_256 {\n  Blake2b_256\n}\n\n/// Compute the blake2b-256 hash digest (32 bytes) of some data.\npub fn blake2b_256(bytes: ByteArray) -> Hash<Blake2b_256, a> {\n  builtin.blake2b_256(bytes)\n}\n\n/// A Keccak-256 hash algorithm.\npub opaque type Keccak_256 {\n  Keccak_256\n}\n\n/// Compute the keccak-256 hash digest (32 bytes) of some data.\npub fn keccak_256(bytes: ByteArray) -> Hash<Keccak_256, a> {\n  builtin.keccak_256(bytes)\n}\n\n/// A SHA2-256 hash algorithm.\npub opaque type Sha2_256 {\n  Sha2_256\n}\n\n/// Compute the sha2-256 hash digest (32 bytes) of some data.\npub fn sha2_256(bytes: ByteArray) -> Hash<Sha2_256, a> {\n  builtin.sha2_256(bytes)\n}\n\n/// A SHA3-256 hash algorithm.\npub opaque type Sha3_256 {\n  Sha3_256\n}\n\n/// Compute the sha3-256 hash digest (32 bytes) of some data.\npub fn sha3_256(bytes: ByteArray) -> Hash<Sha3_256, a> {\n  builtin.sha3_256(bytes)\n}\n\n// ## Verifying signatures\n\n/// Verify an ECDCA signature (over secp256k1) using the given verification key.\n/// Returns `True` when the signature is valid.\npub fn verify_ecdsa_signature(\n  key: VerificationKey,\n  msg: ByteArray,\n  sig: Signature,\n) -> Bool {\n  builtin.verify_ecdsa_secp256k1_signature(key, msg, sig)\n}\n\n/// Verify an Ed25519 signature using the given verification key.\n/// Returns `True` when the signature is valid.\npub fn verify_ed25519_signature(\n  key: VerificationKey,\n  msg: ByteArray,\n  sig: Signature,\n) -> Bool {\n  builtin.verify_ed25519_signature(key, msg, sig)\n}\n\n/// Verify a Schnorr signature (over secp256k1) using the given verification key.\n/// Returns `True` when the signature is valid.\npub fn verify_schnorr_signature(\n  key: VerificationKey,\n  msg: ByteArray,\n  sig: Signature,\n) -> Bool {\n  builtin.verify_schnorr_secp256k1_signature(key, msg, sig)\n}\n",
      "dependencies": ["aiken/builtin"],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.interval",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/interval.ak",
      "name": "aiken.interval",
      "imports": [
        {
          "module": "aiken/primitive/string",
          "items": [],
          "line": 67,
          "raw": "use aiken/primitive/string",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "after",
          "signature": "pub fn after(lower_bound: Int) -> Interval {",
          "documentation": "Create an interval that includes all values greater than the given bound. i.e $[lower_bound, +∞]$\n\n```aiken\ninterval.after(10) == Interval {\nlower_bound: IntervalBound { bound_type: Finite(10), is_inclusive: True },\nupper_bound: IntervalBound { bound_type: PositiveInfinity, is_inclusive: True },\n}\n```",
          "parameters": [
            {
              "name": "lower_bound",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Interval",
          "line": 123,
          "raw": "pub fn after(lower_bound: Int) -> Interval {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn after(lower_bound: Int) -> Interval {\n  Interval {\n    lower_bound: IntervalBound {\n      bound_type: Finite(lower_bound),\n      is_inclusive: True,\n    },\n    upper_bound: IntervalBound {\n      bound_type: PositiveInfinity,\n      is_inclusive: True,\n    },\n  }\n}"
        },
        {
          "name": "entirely_after",
          "signature": "pub fn entirely_after(lower_bound: Int) -> Interval {",
          "documentation": "Create an interval that includes all values after (and not including) the given bound. i.e $(lower_bound, +∞]$\n\n```aiken\ninterval.entirely_after(10) == Interval {\nlower_bound: IntervalBound { bound_type: Finite(10), is_inclusive: False },\nupper_bound: IntervalBound { bound_type: PositiveInfinity, is_inclusive: True },\n}\n```",
          "parameters": [
            {
              "name": "lower_bound",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Interval",
          "line": 144,
          "raw": "pub fn entirely_after(lower_bound: Int) -> Interval {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn entirely_after(lower_bound: Int) -> Interval {\n  Interval {\n    lower_bound: IntervalBound {\n      bound_type: Finite(lower_bound),\n      is_inclusive: False,\n    },\n    upper_bound: IntervalBound {\n      bound_type: PositiveInfinity,\n      is_inclusive: True,\n    },\n  }\n}"
        },
        {
          "name": "before",
          "signature": "pub fn before(upper_bound: Int) -> Interval {",
          "documentation": "Create an interval that includes all values before (and including) the given bound. i.e $(-∞, upper_bound]$\n\n```aiken\ninterval.before(100) == Interval {\nlower_bound: IntervalBound { bound_type: NegativeInfinity, is_inclusive: True },\nupper_bound: IntervalBound { bound_type: Finite(100), is_inclusive: True },\n}\n```",
          "parameters": [
            {
              "name": "upper_bound",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Interval",
          "line": 165,
          "raw": "pub fn before(upper_bound: Int) -> Interval {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn before(upper_bound: Int) -> Interval {\n  Interval {\n    lower_bound: IntervalBound {\n      bound_type: NegativeInfinity,\n      is_inclusive: True,\n    },\n    upper_bound: IntervalBound {\n      bound_type: Finite(upper_bound),\n      is_inclusive: True,\n    },\n  }\n}"
        },
        {
          "name": "entirely_before",
          "signature": "pub fn entirely_before(upper_bound: Int) -> Interval {",
          "documentation": "Create an interval that includes all values before (and not including) the given bound. i.e $(-∞, upper_bound)$\n\n```aiken\ninterval.entirely_before(10) == Interval {\nlower_bound: IntervalBound { bound_type: NegativeInfinity, is_inclusive: True },\nupper_bound: IntervalBound { bound_type: Finite(10), is_inclusive: False },\n}\n```",
          "parameters": [
            {
              "name": "upper_bound",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Interval",
          "line": 186,
          "raw": "pub fn entirely_before(upper_bound: Int) -> Interval {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn entirely_before(upper_bound: Int) -> Interval {\n  Interval {\n    lower_bound: IntervalBound {\n      bound_type: NegativeInfinity,\n      is_inclusive: True,\n    },\n    upper_bound: IntervalBound {\n      bound_type: Finite(upper_bound),\n      is_inclusive: False,\n    },\n  }\n}"
        },
        {
          "name": "between",
          "signature": "pub fn between(lower_bound: Int, upper_bound: Int) -> Interval {",
          "documentation": "Create an interval that includes all values between two bounds, including the bounds. i.e. $[lower_bound, upper_bound]$\n\n```aiken\ninterval.between(10, 100) == Interval {\nlower_bound: IntervalBound { bound_type: Finite(10), is_inclusive: True },\nupper_bound: IntervalBound { bound_type: Finite(100), is_inclusive: True },\n}\n```",
          "parameters": [
            {
              "name": "lower_bound",
              "type": "Int",
              "optional": false
            },
            {
              "name": "upper_bound",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Interval",
          "line": 207,
          "raw": "pub fn between(lower_bound: Int, upper_bound: Int) -> Interval {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn between(lower_bound: Int, upper_bound: Int) -> Interval {\n  Interval {\n    lower_bound: IntervalBound {\n      bound_type: Finite(lower_bound),\n      is_inclusive: True,\n    },\n    upper_bound: IntervalBound {\n      bound_type: Finite(upper_bound),\n      is_inclusive: True,\n    },\n  }\n}"
        },
        {
          "name": "entirely_between",
          "signature": "pub fn entirely_between(lower_bound: Int, upper_bound: Int) -> Interval {",
          "documentation": "Create an interval that includes all values between two bounds, excluding the bounds. i.e. $(lower_bound, upper_bound)$\n\n```aiken\ninterval.entirely_between(10, 100) == Interval {\nlower_bound: IntervalBound { bound_type: Finite(10), is_inclusive: False },\nupper_bound: IntervalBound { bound_type: Finite(100), is_inclusive: False },\n}\n```",
          "parameters": [
            {
              "name": "lower_bound",
              "type": "Int",
              "optional": false
            },
            {
              "name": "upper_bound",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Interval",
          "line": 228,
          "raw": "pub fn entirely_between(lower_bound: Int, upper_bound: Int) -> Interval {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn entirely_between(lower_bound: Int, upper_bound: Int) -> Interval {\n  Interval {\n    lower_bound: IntervalBound {\n      bound_type: Finite(lower_bound),\n      is_inclusive: False,\n    },\n    upper_bound: IntervalBound {\n      bound_type: Finite(upper_bound),\n      is_inclusive: False,\n    },\n  }\n}"
        },
        {
          "name": "contains",
          "signature": "pub fn contains(self: Interval, elem: Int) -> Bool {",
          "documentation": "Checks whether an element is contained within the interval.\n\n```aiken\nlet iv =\nInterval {\nlower_bound: IntervalBound {\nbound_type: Finite(14),\nis_inclusive: True\n},\nupper_bound: IntervalBound {\nbound_type: Finite(42),\nis_inclusive: False\n},\n}\n\ninterval.contains(iv, 25) == True\ninterval.contains(iv, 0) == False\ninterval.contains(iv, 14) == True\ninterval.contains(iv, 42) == False\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Interval",
              "optional": false
            },
            {
              "name": "elem",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 299,
          "raw": "pub fn contains(self: Interval, elem: Int) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn contains(self: Interval, elem: Int) -> Bool {\n  let is_greater_than_lower_bound =\n    when self.lower_bound.bound_type is {\n      NegativeInfinity -> True\n      Finite(lower_bound) ->\n        if self.lower_bound.is_inclusive {\n          elem >= lower_bound\n        } else {\n          elem > lower_bound\n        }\n      PositiveInfinity -> False\n    }\n\n  let is_smaller_than_upper_bound =\n    when self.upper_bound.bound_type is {\n      NegativeInfinity -> False\n      Finite(upper_bound) ->\n        if self.upper_bound.is_inclusive {\n          elem <= upper_bound\n        } else {\n          elem < upper_bound\n        }\n      PositiveInfinity -> True\n    }\n\n  is_greater_than_lower_bound && is_smaller_than_upper_bound\n}",
          "tests": [
            "test contains_1() {\n  let iv = everything\n  contains(iv, 14)\n}",
            "test contains_2() {\n  let iv = entirely_before(15)\n  contains(iv, 14)\n}",
            "test contains_3() {\n  let iv = before(14)\n  contains(iv, 14)\n}",
            "test contains_4() {\n  let iv = entirely_before(14)\n  !contains(iv, 14)\n}",
            "test contains_5() {\n  let iv = entirely_after(13)\n  contains(iv, 14)\n}",
            "test contains_6() {\n  let iv = after(14)\n  contains(iv, 14)\n}",
            "test contains_7() {\n  let iv = entirely_after(14)\n  !contains(iv, 14)\n}",
            "test contains_8() {\n  let iv = between(42, 1337)\n  !contains(iv, 14)\n}",
            "test contains_9() {\n  let iv = between(0, 42)\n  contains(iv, 14)\n}",
            "test contains_10() {\n  let iv = between(0, 42)\n  contains(iv, 42)\n}",
            "test contains_11() {\n  let iv = entirely_between(0, 42)\n  !contains(iv, 0)\n}",
            "test contains_12() {\n  let iv = empty\n  !contains(iv, 14)\n}"
          ]
        },
        {
          "name": "is_empty",
          "signature": "pub fn is_empty(self: Interval) -> Bool {",
          "documentation": "Tells whether an interval is empty; i.e. that is contains no value.\n\n```aiken\nlet iv1 = interval.empty\n\nlet iv2 = Interval {\nlower_bound: IntervalBound { bound_type: Finite(0), is_inclusive: False },\nupper_bound: IntervalBound { bound_type: Finite(0), is_inclusive: False },\n}\n\nlet iv3 = Interval {\nlower_bound: IntervalBound { bound_type: Finite(0), is_inclusive: False },\nupper_bound: IntervalBound { bound_type: Finite(100), is_inclusive: False },\n}\n\ninterval.is_empty(iv1) == True\ninterval.is_empty(iv2) == True\ninterval.is_empty(iv3) == False\n\n// Note: Two empty intervals are not necessarily equal.\niv1 != iv2\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Interval",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 409,
          "raw": "pub fn is_empty(self: Interval) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn is_empty(self: Interval) -> Bool {\n  compare_bound_type(\n    self.lower_bound.bound_type,\n    self.upper_bound.bound_type,\n    fn() {\n      let is_open_interval =\n        !self.lower_bound.is_inclusive && !self.upper_bound.is_inclusive\n      if is_open_interval {\n        when (self.lower_bound.bound_type, self.upper_bound.bound_type) is {\n          (Finite(lower_bound), Finite(upper_bound)) ->\n            lower_bound + 1 == upper_bound\n          _ -> False\n        }\n      } else {\n        False\n      }\n    },\n    fn(_) { !(self.lower_bound.is_inclusive && self.upper_bound.is_inclusive) },\n    fn() { True },\n  )\n}"
        },
        {
          "name": "is_entirely_after",
          "signature": "pub fn is_entirely_after(self: Interval, point: Int) -> Bool {",
          "documentation": "Check whether the interval is entirely after a given point.\n\n```aiken\ninterval.is_entirely_after(interval.after(10), 5) == True\ninterval.is_entirely_after(interval.after(10), 10) == False\ninterval.is_entirely_after(interval.after(10), 15) == False\ninterval.is_entirely_after(interval.between(10, 20), 30) == False\ninterval.is_entirely_after(interval.between(10, 20), 5) == True\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Interval",
              "optional": false
            },
            {
              "name": "point",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 440,
          "raw": "pub fn is_entirely_after(self: Interval, point: Int) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn is_entirely_after(self: Interval, point: Int) -> Bool {\n  when self.lower_bound.bound_type is {\n    Finite(low) ->\n      if self.lower_bound.is_inclusive {\n        point < low\n      } else {\n        point <= low\n      }\n    NegativeInfinity -> False\n    PositiveInfinity -> True\n  }\n}",
          "tests": [
            "test is_entirely_after_1() {\n  is_entirely_after(after(10), 5)\n}",
            "test is_entirely_after_2() {\n  !is_entirely_after(after(10), 10)\n}",
            "test is_entirely_after_3() {\n  !is_entirely_after(after(10), 15)\n}",
            "test is_entirely_after_4() {\n  !is_entirely_after(between(10, 20), 30)\n}",
            "test is_entirely_after_5() {\n  is_entirely_after(between(10, 20), 5)\n}",
            "test is_entirely_after_6() {\n  is_entirely_after(entirely_after(10), 10)\n}",
            "test is_entirely_after_7() {\n  !is_entirely_after(before(10), 5)\n}",
            "test is_entirely_after_8() {\n  !is_entirely_after(before(10), 15)\n}",
            "test is_entirely_after_9() {\n  !is_entirely_after(entirely_before(10), 5)\n}",
            "test is_entirely_after_10() {\n  is_entirely_after(\n    Interval {\n      lower_bound: IntervalBound {\n        bound_type: PositiveInfinity,\n        is_inclusive: True,\n      },\n      upper_bound: IntervalBound {\n        bound_type: PositiveInfinity,\n        is_inclusive: False,\n      },\n    },\n    1,\n  )\n}"
          ]
        },
        {
          "name": "is_entirely_before",
          "signature": "pub fn is_entirely_before(self: Interval, point: Int) -> Bool {",
          "documentation": "Check whether the interval is entirely before a given point.\n\n```aiken\ninterval.is_entirely_before(interval.before(10), 15) == True\ninterval.is_entirely_before(interval.before(10), 10) == False\ninterval.is_entirely_before(interval.before(10), 5) == False\ninterval.is_entirely_before(interval.between(10, 20), 30) == True\ninterval.is_entirely_before(interval.between(10, 20), 5) == False\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Interval",
              "optional": false
            },
            {
              "name": "point",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 514,
          "raw": "pub fn is_entirely_before(self: Interval, point: Int) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn is_entirely_before(self: Interval, point: Int) -> Bool {\n  when self.upper_bound.bound_type is {\n    Finite(hi) ->\n      if self.upper_bound.is_inclusive {\n        hi < point\n      } else {\n        hi <= point\n      }\n    PositiveInfinity -> False\n    NegativeInfinity -> True\n  }\n}",
          "tests": [
            "test is_entirely_before_1() {\n  is_entirely_before(before(10), 15)\n}",
            "test is_entirely_before_2() {\n  !is_entirely_before(before(10), 10)\n}",
            "test is_entirely_before_3() {\n  !is_entirely_before(before(10), 5)\n}",
            "test is_entirely_before_4() {\n  is_entirely_before(between(10, 20), 30)\n}",
            "test is_entirely_before_5() {\n  !is_entirely_before(between(10, 20), 5)\n}",
            "test is_entirely_before_6() {\n  is_entirely_before(entirely_before(10), 10)\n}",
            "test is_entirely_before_7() {\n  !is_entirely_before(after(10), 15)\n}",
            "test is_entirely_before_8() {\n  !is_entirely_before(after(10), 5)\n}",
            "test is_entirely_before_9() {\n  !is_entirely_before(entirely_after(10), 5)\n}",
            "test is_entirely_before_10() {\n  is_entirely_before(\n    Interval {\n      lower_bound: IntervalBound {\n        bound_type: NegativeInfinity,\n        is_inclusive: True,\n      },\n      upper_bound: IntervalBound {\n        bound_type: NegativeInfinity,\n        is_inclusive: False,\n      },\n    },\n    1,\n  )\n}"
          ]
        },
        {
          "name": "to_string",
          "signature": "pub fn to_string(self: Interval) -> String {",
          "documentation": "Obtain a human-readable string representation of the interval. Useful for debugging.",
          "parameters": [
            {
              "name": "self",
              "type": "Interval",
              "optional": false
            }
          ],
          "returnType": "String",
          "line": 580,
          "raw": "pub fn to_string(self: Interval) -> String {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn to_string(self: Interval) -> String {\n  let lower_bracket =\n    if self.lower_bound.is_inclusive {\n      @\"[\"\n    } else {\n      @\"(\"\n    }\n\n  let lower_bound = bound_type_to_string(self.lower_bound.bound_type)\n\n  let upper_bound = bound_type_to_string(self.upper_bound.bound_type)\n\n  let upper_bracket =\n    if self.upper_bound.is_inclusive {\n      @\"]\"\n    } else {\n      @\")\"\n    }\n\n  lower_bracket\n    |> string.concat(lower_bound)\n    |> string.concat(@\", \")\n    |> string.concat(upper_bound)\n    |> string.concat(upper_bracket)\n}"
        },
        {
          "name": "hull",
          "signature": "pub fn hull(iv1: Interval, iv2: Interval) -> Interval {",
          "documentation": "Computes the smallest interval containing the two given intervals, if any\n\n```aiken\nlet iv1 = between(0, 10) // [0, 10]\nlet iv2 = between(2, 14) // [2, 14]\nhull(iv1, iv2) == between(0, 14)\n\nlet iv1 = between(5, 10) // [5, 10]\nlet iv2 = before(0) // [ْ-∞, 0]\nhull(iv1, iv2) == before(10)\n\nlet iv1 = entirely_after(0) // (0, +∞]\nlet iv2 = between(10, 42)  // [10, 42]\nhull(iv1, iv2) = entirely_after(0)\n```",
          "parameters": [
            {
              "name": "iv1",
              "type": "Interval",
              "optional": false
            },
            {
              "name": "iv2",
              "type": "Interval",
              "optional": false
            }
          ],
          "returnType": "Interval",
          "line": 631,
          "raw": "pub fn hull(iv1: Interval, iv2: Interval) -> Interval {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn hull(iv1: Interval, iv2: Interval) -> Interval {\n  Interval {\n    lower_bound: min(iv1.lower_bound, iv2.lower_bound),\n    upper_bound: max(iv1.upper_bound, iv2.upper_bound),\n  }\n}",
          "tests": [
            "test hull_1() {\n  let iv1 = between(0, 10)\n  let iv2 = between(2, 14)\n  hull(iv1, iv2) == between(0, 14)\n}",
            "test hull_2() {\n  let iv1 = between(5, 10)\n  let iv2 = before(0)\n  hull(iv1, iv2) == before(10)\n}",
            "test hull_3() {\n  let iv1 = entirely_after(0)\n  let iv2 = between(10, 42)\n  hull(iv1, iv2) == entirely_after(0)\n}"
          ]
        },
        {
          "name": "includes",
          "signature": "pub fn includes(self: Interval, other: Interval) -> Bool {",
          "documentation": "Checks whether the second interval is fully included in the first.\n\n```aiken\nbetween(-5, 5)  // [-5, 5]\n|> includes(between(0, 2)) // [0, 2]\n\nbetween(-5, 5)  // [-5, 5]\n|> includes(entirely_between(-5, 5)) // (-5, 5)\n\nafter(0) // [0, +∞]\n|> includes(after(1)) // [1, +∞]\n\nbefore(-1) // (-∞, -1]\n|> includes(entirely_before(-1)) // [-∞, -1)\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Interval",
              "optional": false
            },
            {
              "name": "other",
              "type": "Interval",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 671,
          "raw": "pub fn includes(self: Interval, other: Interval) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn includes(self: Interval, other: Interval) -> Bool {\n  and {\n    !is_empty(self),\n    or {\n      is_empty(other),\n      and {\n        compare_bound_type(\n          other.lower_bound.bound_type,\n          self.lower_bound.bound_type,\n          fn() { False },\n          fn(_) {\n            self.lower_bound.is_inclusive || !other.lower_bound.is_inclusive\n          },\n          fn() { True },\n        ),\n        compare_bound_type(\n          other.upper_bound.bound_type,\n          self.upper_bound.bound_type,\n          fn() { True },\n          fn(_) {\n            self.upper_bound.is_inclusive || !other.upper_bound.is_inclusive\n          },\n          fn() { False },\n        ),\n      },\n    },\n  }\n}",
          "tests": [
            "test includes_1() {\n  between(-5, 5) |> includes(between(-5, 5))\n}",
            "test includes_2() {\n  between(-5, 5) |> includes(between(0, 2))\n}",
            "test includes_3() {\n  between(-5, 5) |> includes(entirely_between(-5, 5))\n}",
            "test includes_4() {\n  !(entirely_between(-5, 5) |> includes(between(-5, 5)))\n}",
            "test includes_5() {\n  and {\n    after(0) |> includes(after(1)),\n    entirely_after(0) |> includes(entirely_after(1)),\n  }\n}",
            "test includes_6() {\n  and {\n    after(0) |> includes(after(1)),\n    entirely_after(0) |> includes(after(1)),\n  }\n}",
            "test includes_7() {\n  and {\n    before(0) |> includes(before(-1)),\n    entirely_before(0) |> includes(before(-1)),\n  }\n}",
            "test includes_8() {\n  and {\n    !(before(-1) |> includes(before(0))),\n    !(entirely_before(-1) |> includes(before(0))),\n  }\n}"
          ]
        },
        {
          "name": "intersection",
          "signature": "pub fn intersection(iv1: Interval, iv2: Interval) -> Interval {",
          "documentation": "Computes the largest interval contained in the two given intervals, if any.\n\n```aiken\nlet iv1 = interval.between(0, 10) // [0, 10]\nlet iv2 = interval.between(2, 14) // [2, 14]\ninterval.intersection(iv1, iv2) == interval.between(2, 10)\n\nlet iv1 = interval.entirely_before(10) // [-∞, 10)\nlet iv2 = interval.entirely_after(0) // (0, +∞]\ninterval.intersection(iv1, iv2) == interval.entirely_between(0, 10)\n\nlet iv1 = interval.between(0, 1) // [0, 1]\nlet iv2 = interval.between(2, 3) // [2, 3]\ninterval.intersection(iv1, iv2) |> interval.is_empty\n```",
          "parameters": [
            {
              "name": "iv1",
              "type": "Interval",
              "optional": false
            },
            {
              "name": "iv2",
              "type": "Interval",
              "optional": false
            }
          ],
          "returnType": "Interval",
          "line": 759,
          "raw": "pub fn intersection(iv1: Interval, iv2: Interval) -> Interval {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn intersection(iv1: Interval, iv2: Interval) -> Interval {\n  Interval {\n    lower_bound: max(iv1.lower_bound, iv2.lower_bound),\n    upper_bound: min(iv1.upper_bound, iv2.upper_bound),\n  }\n}",
          "tests": [
            "test intersection_1() {\n  let iv1 = between(0, 10)\n  let iv2 = between(2, 14)\n  intersection(iv1, iv2) == between(2, 10)\n}",
            "test intersection_2() {\n  let iv1 = between(0, 1)\n  let iv2 = between(1, 2)\n  intersection(iv1, iv2) == between(1, 1)\n}",
            "test intersection_3() {\n  let iv1 = between(0, 1)\n  let iv2 = entirely_between(1, 2)\n  intersection(iv1, iv2)\n    |> is_empty\n}",
            "test intersection_4() {\n  let iv1 = entirely_between(0, 1)\n  let iv2 = entirely_between(1, 2)\n  intersection(iv1, iv2)\n    |> is_empty\n}",
            "test intersection_5() {\n  let iv1 = between(0, 10)\n  let iv2 = before(4)\n  intersection(iv1, iv2) == between(0, 4)\n}",
            "test intersection_6() {\n  let iv1 = entirely_before(10)\n  let iv2 = entirely_after(0)\n  intersection(iv1, iv2) == entirely_between(0, 10)\n}"
          ]
        },
        {
          "name": "max",
          "signature": "pub fn max(left: IntervalBound, right: IntervalBound) -> IntervalBound {",
          "documentation": "Return the highest bound of the two. For equal `IntervalBoundType`,\nan inclusive `IntervalBound` is considered higher.\n\n```aiken\nlet ib1 = IntervalBound { bound_type: Finite(0), is_inclusive: False }\nlet ib2 = IntervalBound { bound_type: Finite(1), is_inclusive: False }\n\ninterval.max(ib1, ib2) == ib2\n```",
          "parameters": [
            {
              "name": "left",
              "type": "IntervalBound",
              "optional": false
            },
            {
              "name": "right",
              "type": "IntervalBound",
              "optional": false
            }
          ],
          "returnType": "IntervalBound",
          "line": 813,
          "raw": "pub fn max(left: IntervalBound, right: IntervalBound) -> IntervalBound {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn max(left: IntervalBound, right: IntervalBound) -> IntervalBound {\n  compare_bound_type(\n    left.bound_type,\n    right.bound_type,\n    fn() { right },\n    fn(is_negative) {\n      if left.is_inclusive == right.is_inclusive {\n        left\n      } else if is_negative {\n        if left.is_inclusive {\n          right\n        } else {\n          left\n        }\n      } else {\n        if left.is_inclusive {\n          left\n        } else {\n          right\n        }\n      }\n    },\n    fn() { left },\n  )\n}"
        },
        {
          "name": "min",
          "signature": "pub fn min(left: IntervalBound, right: IntervalBound) -> IntervalBound {",
          "documentation": "Return the smallest bound of the two. For equal `IntervalBoundType`,\nan inclusive `IntervalBound` is considered smaller.\n\n```aiken\nlet ib1 = IntervalBound { bound_type: Finite(0), is_inclusive: False }\nlet ib2 = IntervalBound { bound_type: Finite(1), is_inclusive: False }\n\ninterval.min(ib1, ib2) == ib1\n```",
          "parameters": [
            {
              "name": "left",
              "type": "IntervalBound",
              "optional": false
            },
            {
              "name": "right",
              "type": "IntervalBound",
              "optional": false
            }
          ],
          "returnType": "IntervalBound",
          "line": 848,
          "raw": "pub fn min(left: IntervalBound, right: IntervalBound) -> IntervalBound {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn min(left: IntervalBound, right: IntervalBound) -> IntervalBound {\n  compare_bound_type(\n    left.bound_type,\n    right.bound_type,\n    fn() { left },\n    fn(is_negative) {\n      if left.is_inclusive == right.is_inclusive {\n        left\n      } else if is_negative {\n        if left.is_inclusive {\n          left\n        } else {\n          right\n        }\n      } else {\n        if left.is_inclusive {\n          right\n        } else {\n          left\n        }\n      }\n    },\n    fn() { right },\n  )\n}"
        }
      ],
      "types": [
        {
          "name": "Interval",
          "definition": "{ lower_bound: IntervalBound, upper_bound: IntervalBound, }",
          "line": 94,
          "raw": "pub type Interval {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "IntervalBound",
          "definition": "{ bound_type: IntervalBoundType, is_inclusive: Bool, }",
          "line": 100,
          "raw": "pub type IntervalBound {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "IntervalBoundType",
          "definition": "{ NegativeInfinity Finite(Int) PositiveInfinity }",
          "line": 107,
          "raw": "pub type IntervalBoundType {",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "constants": [],
      "atoms": [
        {
          "name": "bound_type_to_string",
          "signature": "fn bound_type_to_string(self: IntervalBoundType) -> String {",
          "parameters": [
            {
              "name": "self",
              "type": "IntervalBoundType",
              "optional": false
            }
          ],
          "returnType": "String",
          "line": 606,
          "raw": "fn bound_type_to_string(self: IntervalBoundType) -> String {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn bound_type_to_string(self: IntervalBoundType) -> String {\n  when self is {\n    NegativeInfinity -> @\"-∞\"\n    Finite(i) -> string.from_int(i)\n    PositiveInfinity -> @\"+∞\"\n  }\n}"
        },
        {
          "name": "compare_bound_type",
          "signature": "fn compare_bound_type(fn compare_bound_type(left: IntervalBoundType, right: IntervalBoundType, less: fn() -> a, equal: fn(Bool) -> a, greater: fn() -> a,",
          "parameters": [],
          "returnType": "a, equal: fn(Bool) -> a, greater: fn() -> a,",
          "line": 874,
          "raw": "fn compare_bound_type(fn compare_bound_type(left: IntervalBoundType, right: IntervalBoundType, less: fn() -> a, equal: fn(Bool) -> a, greater: fn() -> a,",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn compare_bound_type(\n  left: IntervalBoundType,\n  right: IntervalBoundType,\n  less: fn() -> a,\n  equal: fn(Bool) -> a,\n  greater: fn() -> a,\n) -> a {\n  when left is {\n    NegativeInfinity ->\n      when right is {\n        NegativeInfinity -> equal(True)\n        _ -> less()\n      }\n    PositiveInfinity ->\n      when right is {\n        PositiveInfinity -> equal(False)\n        _ -> greater()\n      }\n    Finite(left) ->\n      when right is {\n        NegativeInfinity -> greater()\n        PositiveInfinity -> less()\n        Finite(right) ->\n          if left < right {\n            less()\n          } else if left == right {\n            equal(left < 0)\n          } else {\n            greater()\n          }\n      }\n  }\n}"
        }
      ],
      "privateTypes": [],
      "privateConstants": [],
      "content": "//// In a eUTxO-based blockchain like Cardano, the management of time can be\n//// finicky.\n////\n//// Indeed, in order to maintain a complete determinism in the execution of\n//// scripts, it is impossible to introduce a notion of _\"current time\"_ since\n//// the execution would then depend on factor that are external to the\n//// transaction itself: the ineluctable stream of time flowing in our universe.\n////\n//// Hence, to work around that, we typically define time intervals, which gives\n//// window -- a.k.a intervals -- within which the transaction can be executed.\n//// From within a script, it isn't possible to know when exactly the script is\n//// executed, but we can reason about the interval bounds to validate pieces of\n//// logic.\n////\n//// ## Example\n////\n//// Let's consider an example and assume an auction with a bidding period over\n//// an interval $biddingPeriod = [start_{bid}, end_{bid})$.\n////\n//// - Bidders for the auction must be whitelisted by an administrator before the\n//// bidding period starts.\n////\n//// - Once the bidding period is over, the auction winner may collect its due by\n//// paying the agreed price.\n////\n//// This scenario identifies three periods:\n////\n//// ```\n////    pre-bidding            bidding            post-bidding\n//// -----------------[-----------------------)----------------->\n////              start_bid                end_bid\n//// ```\n////\n//// If we call $validityRange = [start_{tx}, end_{tx})$ the validity interval\n//// of transactions during each period, we must then have:\n////\n//// > [!TIP]\n//// > In Plutus V3, transaction validity ranges are always semi-open intervals, open in their upper bound.\n////\n//// 1. Pre-bidding: $end_{tx} \\lt start_{bid}$\n////\n////    ```aiken\n////    validity_range |> interval.is_entirely_before(start_bid)\n////    ```\n////\n//// 2. Bidding: $validityRange \\subseteq biddingPeriod$\n////\n////    ```aiken\n////    bidding_period |> interval.includes(validity_range)\n////    ```\n////\n////    or alternatively $start_{tx} \\geq start_{bid}$ and $end_{tx} \\lt end_{bid}$:\n////\n////    ```aiken\n////    and {\n////      bidding_period |> interval.contains(start_tx),\n////      bidding_period |> interval.contains(end_tx),\n////    }\n////    ```\n////\n//// 3. Post-bidding: $start_{tx} \\gt end_{bid}$\n////\n////    ```aiken\n////    validity_range |> interval.is_entirely_after(end_bid)\n////    ```\n\nuse aiken/primitive/string\n\n///\n/// A type to represent intervals of values. Interval are inhabited by an\n/// integer value representing  have a finite lower-bound and/or upper-bound.\n///\n/// This allows to represent all kind of mathematical intervals:\n///\n/// ```aiken\n/// // [1; 10]\n/// let i0: Interval = Interval\n///   { lower_bound:\n///       IntervalBound { bound_type: Finite(1), is_inclusive: True }\n///   , upper_bound:\n///       IntervalBound { bound_type: Finite(10), is_inclusive: True }\n///   }\n/// ```\n///\n/// ```aiken\n/// // (20; infinity)\n/// let i1: Interval = Interval\n///   { lower_bound:\n///       IntervalBound { bound_type: Finite(20), is_inclusive: False }\n///   , upper_bound:\n///       IntervalBound { bound_type: PositiveInfinity, is_inclusive: False }\n///   }\n/// ```\npub type Interval {\n  lower_bound: IntervalBound,\n  upper_bound: IntervalBound,\n}\n\n/// An interval bound, either inclusive or exclusive.\npub type IntervalBound {\n  bound_type: IntervalBoundType,\n  is_inclusive: Bool,\n}\n\n/// A type of interval bound. The value for the `Finite` case typically\n/// represents a number of seconds or milliseconds.\npub type IntervalBoundType {\n  NegativeInfinity\n  Finite(Int)\n  PositiveInfinity\n}\n\n// ## Constructing\n\n/// Create an interval that includes all values greater than the given bound. i.e $[lower_bound, +∞]$\n///\n/// ```aiken\n/// interval.after(10) == Interval {\n///   lower_bound: IntervalBound { bound_type: Finite(10), is_inclusive: True },\n///   upper_bound: IntervalBound { bound_type: PositiveInfinity, is_inclusive: True },\n/// }\n/// ```\npub fn after(lower_bound: Int) -> Interval {\n  Interval {\n    lower_bound: IntervalBound {\n      bound_type: Finite(lower_bound),\n      is_inclusive: True,\n    },\n    upper_bound: IntervalBound {\n      bound_type: PositiveInfinity,\n      is_inclusive: True,\n    },\n  }\n}\n\n/// Create an interval that includes all values after (and not including) the given bound. i.e $(lower_bound, +∞]$\n///\n/// ```aiken\n/// interval.entirely_after(10) == Interval {\n///   lower_bound: IntervalBound { bound_type: Finite(10), is_inclusive: False },\n///   upper_bound: IntervalBound { bound_type: PositiveInfinity, is_inclusive: True },\n/// }\n/// ```\npub fn entirely_after(lower_bound: Int) -> Interval {\n  Interval {\n    lower_bound: IntervalBound {\n      bound_type: Finite(lower_bound),\n      is_inclusive: False,\n    },\n    upper_bound: IntervalBound {\n      bound_type: PositiveInfinity,\n      is_inclusive: True,\n    },\n  }\n}\n\n/// Create an interval that includes all values before (and including) the given bound. i.e $(-∞, upper_bound]$\n///\n/// ```aiken\n/// interval.before(100) == Interval {\n///   lower_bound: IntervalBound { bound_type: NegativeInfinity, is_inclusive: True },\n///   upper_bound: IntervalBound { bound_type: Finite(100), is_inclusive: True },\n/// }\n/// ```\npub fn before(upper_bound: Int) -> Interval {\n  Interval {\n    lower_bound: IntervalBound {\n      bound_type: NegativeInfinity,\n      is_inclusive: True,\n    },\n    upper_bound: IntervalBound {\n      bound_type: Finite(upper_bound),\n      is_inclusive: True,\n    },\n  }\n}\n\n/// Create an interval that includes all values before (and not including) the given bound. i.e $(-∞, upper_bound)$\n///\n/// ```aiken\n/// interval.entirely_before(10) == Interval {\n///   lower_bound: IntervalBound { bound_type: NegativeInfinity, is_inclusive: True },\n///   upper_bound: IntervalBound { bound_type: Finite(10), is_inclusive: False },\n/// }\n/// ```\npub fn entirely_before(upper_bound: Int) -> Interval {\n  Interval {\n    lower_bound: IntervalBound {\n      bound_type: NegativeInfinity,\n      is_inclusive: True,\n    },\n    upper_bound: IntervalBound {\n      bound_type: Finite(upper_bound),\n      is_inclusive: False,\n    },\n  }\n}\n\n/// Create an interval that includes all values between two bounds, including the bounds. i.e. $[lower_bound, upper_bound]$\n///\n/// ```aiken\n/// interval.between(10, 100) == Interval {\n///   lower_bound: IntervalBound { bound_type: Finite(10), is_inclusive: True },\n///   upper_bound: IntervalBound { bound_type: Finite(100), is_inclusive: True },\n/// }\n/// ```\npub fn between(lower_bound: Int, upper_bound: Int) -> Interval {\n  Interval {\n    lower_bound: IntervalBound {\n      bound_type: Finite(lower_bound),\n      is_inclusive: True,\n    },\n    upper_bound: IntervalBound {\n      bound_type: Finite(upper_bound),\n      is_inclusive: True,\n    },\n  }\n}\n\n/// Create an interval that includes all values between two bounds, excluding the bounds. i.e. $(lower_bound, upper_bound)$\n///\n/// ```aiken\n/// interval.entirely_between(10, 100) == Interval {\n///   lower_bound: IntervalBound { bound_type: Finite(10), is_inclusive: False },\n///   upper_bound: IntervalBound { bound_type: Finite(100), is_inclusive: False },\n/// }\n/// ```\npub fn entirely_between(lower_bound: Int, upper_bound: Int) -> Interval {\n  Interval {\n    lower_bound: IntervalBound {\n      bound_type: Finite(lower_bound),\n      is_inclusive: False,\n    },\n    upper_bound: IntervalBound {\n      bound_type: Finite(upper_bound),\n      is_inclusive: False,\n    },\n  }\n}\n\n/// Create an empty interval that contains no value.\n///\n/// ```aiken\n/// interval.contains(empty, 0) == False\n/// interval.contains(empty, 1000) == False\n/// ```\npub const empty: Interval =\n  Interval {\n    lower_bound: IntervalBound {\n      bound_type: PositiveInfinity,\n      is_inclusive: True,\n    },\n    upper_bound: IntervalBound {\n      bound_type: NegativeInfinity,\n      is_inclusive: True,\n    },\n  }\n\n/// Create an interval that contains every possible values. i.e. $(-∞, +∞)$\n///\n/// ```aiken\n/// interval.contains(everything, 0) == True\n/// interval.contains(everything, 1000) == True\n/// ```\npub const everything: Interval =\n  Interval {\n    lower_bound: IntervalBound {\n      bound_type: NegativeInfinity,\n      is_inclusive: True,\n    },\n    upper_bound: IntervalBound {\n      bound_type: PositiveInfinity,\n      is_inclusive: True,\n    },\n  }\n\n// ## Inspecting\n\n/// Checks whether an element is contained within the interval.\n///\n/// ```aiken\n/// let iv =\n///   Interval {\n///     lower_bound: IntervalBound {\n///       bound_type: Finite(14),\n///       is_inclusive: True\n///     },\n///     upper_bound: IntervalBound {\n///       bound_type: Finite(42),\n///       is_inclusive: False\n///     },\n///   }\n///\n/// interval.contains(iv, 25) == True\n/// interval.contains(iv, 0) == False\n/// interval.contains(iv, 14) == True\n/// interval.contains(iv, 42) == False\n/// ```\npub fn contains(self: Interval, elem: Int) -> Bool {\n  let is_greater_than_lower_bound =\n    when self.lower_bound.bound_type is {\n      NegativeInfinity -> True\n      Finite(lower_bound) ->\n        if self.lower_bound.is_inclusive {\n          elem >= lower_bound\n        } else {\n          elem > lower_bound\n        }\n      PositiveInfinity -> False\n    }\n\n  let is_smaller_than_upper_bound =\n    when self.upper_bound.bound_type is {\n      NegativeInfinity -> False\n      Finite(upper_bound) ->\n        if self.upper_bound.is_inclusive {\n          elem <= upper_bound\n        } else {\n          elem < upper_bound\n        }\n      PositiveInfinity -> True\n    }\n\n  is_greater_than_lower_bound && is_smaller_than_upper_bound\n}\n\ntest contains_1() {\n  let iv = everything\n  contains(iv, 14)\n}\n\ntest contains_2() {\n  let iv = entirely_before(15)\n  contains(iv, 14)\n}\n\ntest contains_3() {\n  let iv = before(14)\n  contains(iv, 14)\n}\n\ntest contains_4() {\n  let iv = entirely_before(14)\n  !contains(iv, 14)\n}\n\ntest contains_5() {\n  let iv = entirely_after(13)\n  contains(iv, 14)\n}\n\ntest contains_6() {\n  let iv = after(14)\n  contains(iv, 14)\n}\n\ntest contains_7() {\n  let iv = entirely_after(14)\n  !contains(iv, 14)\n}\n\ntest contains_8() {\n  let iv = between(42, 1337)\n  !contains(iv, 14)\n}\n\ntest contains_9() {\n  let iv = between(0, 42)\n  contains(iv, 14)\n}\n\ntest contains_10() {\n  let iv = between(0, 42)\n  contains(iv, 42)\n}\n\ntest contains_11() {\n  let iv = entirely_between(0, 42)\n  !contains(iv, 0)\n}\n\ntest contains_12() {\n  let iv = empty\n  !contains(iv, 14)\n}\n\n/// Tells whether an interval is empty; i.e. that is contains no value.\n///\n/// ```aiken\n/// let iv1 = interval.empty\n///\n/// let iv2 = Interval {\n///     lower_bound: IntervalBound { bound_type: Finite(0), is_inclusive: False },\n///     upper_bound: IntervalBound { bound_type: Finite(0), is_inclusive: False },\n///   }\n///\n/// let iv3 = Interval {\n///     lower_bound: IntervalBound { bound_type: Finite(0), is_inclusive: False },\n///     upper_bound: IntervalBound { bound_type: Finite(100), is_inclusive: False },\n///   }\n///\n/// interval.is_empty(iv1) == True\n/// interval.is_empty(iv2) == True\n/// interval.is_empty(iv3) == False\n///\n/// // Note: Two empty intervals are not necessarily equal.\n/// iv1 != iv2\n/// ```\npub fn is_empty(self: Interval) -> Bool {\n  compare_bound_type(\n    self.lower_bound.bound_type,\n    self.upper_bound.bound_type,\n    fn() {\n      let is_open_interval =\n        !self.lower_bound.is_inclusive && !self.upper_bound.is_inclusive\n      if is_open_interval {\n        when (self.lower_bound.bound_type, self.upper_bound.bound_type) is {\n          (Finite(lower_bound), Finite(upper_bound)) ->\n            lower_bound + 1 == upper_bound\n          _ -> False\n        }\n      } else {\n        False\n      }\n    },\n    fn(_) { !(self.lower_bound.is_inclusive && self.upper_bound.is_inclusive) },\n    fn() { True },\n  )\n}\n\n/// Check whether the interval is entirely after a given point.\n///\n/// ```aiken\n/// interval.is_entirely_after(interval.after(10), 5) == True\n/// interval.is_entirely_after(interval.after(10), 10) == False\n/// interval.is_entirely_after(interval.after(10), 15) == False\n/// interval.is_entirely_after(interval.between(10, 20), 30) == False\n/// interval.is_entirely_after(interval.between(10, 20), 5) == True\n/// ```\npub fn is_entirely_after(self: Interval, point: Int) -> Bool {\n  when self.lower_bound.bound_type is {\n    Finite(low) ->\n      if self.lower_bound.is_inclusive {\n        point < low\n      } else {\n        point <= low\n      }\n    NegativeInfinity -> False\n    PositiveInfinity -> True\n  }\n}\n\ntest is_entirely_after_1() {\n  is_entirely_after(after(10), 5)\n}\n\ntest is_entirely_after_2() {\n  !is_entirely_after(after(10), 10)\n}\n\ntest is_entirely_after_3() {\n  !is_entirely_after(after(10), 15)\n}\n\ntest is_entirely_after_4() {\n  !is_entirely_after(between(10, 20), 30)\n}\n\ntest is_entirely_after_5() {\n  is_entirely_after(between(10, 20), 5)\n}\n\ntest is_entirely_after_6() {\n  is_entirely_after(entirely_after(10), 10)\n}\n\ntest is_entirely_after_7() {\n  !is_entirely_after(before(10), 5)\n}\n\ntest is_entirely_after_8() {\n  !is_entirely_after(before(10), 15)\n}\n\ntest is_entirely_after_9() {\n  !is_entirely_after(entirely_before(10), 5)\n}\n\ntest is_entirely_after_10() {\n  is_entirely_after(\n    Interval {\n      lower_bound: IntervalBound {\n        bound_type: PositiveInfinity,\n        is_inclusive: True,\n      },\n      upper_bound: IntervalBound {\n        bound_type: PositiveInfinity,\n        is_inclusive: False,\n      },\n    },\n    1,\n  )\n}\n\n/// Check whether the interval is entirely before a given point.\n///\n/// ```aiken\n/// interval.is_entirely_before(interval.before(10), 15) == True\n/// interval.is_entirely_before(interval.before(10), 10) == False\n/// interval.is_entirely_before(interval.before(10), 5) == False\n/// interval.is_entirely_before(interval.between(10, 20), 30) == True\n/// interval.is_entirely_before(interval.between(10, 20), 5) == False\n/// ```\npub fn is_entirely_before(self: Interval, point: Int) -> Bool {\n  when self.upper_bound.bound_type is {\n    Finite(hi) ->\n      if self.upper_bound.is_inclusive {\n        hi < point\n      } else {\n        hi <= point\n      }\n    PositiveInfinity -> False\n    NegativeInfinity -> True\n  }\n}\n\ntest is_entirely_before_1() {\n  is_entirely_before(before(10), 15)\n}\n\ntest is_entirely_before_2() {\n  !is_entirely_before(before(10), 10)\n}\n\ntest is_entirely_before_3() {\n  !is_entirely_before(before(10), 5)\n}\n\ntest is_entirely_before_4() {\n  is_entirely_before(between(10, 20), 30)\n}\n\ntest is_entirely_before_5() {\n  !is_entirely_before(between(10, 20), 5)\n}\n\ntest is_entirely_before_6() {\n  is_entirely_before(entirely_before(10), 10)\n}\n\ntest is_entirely_before_7() {\n  !is_entirely_before(after(10), 15)\n}\n\ntest is_entirely_before_8() {\n  !is_entirely_before(after(10), 5)\n}\n\ntest is_entirely_before_9() {\n  !is_entirely_before(entirely_after(10), 5)\n}\n\ntest is_entirely_before_10() {\n  is_entirely_before(\n    Interval {\n      lower_bound: IntervalBound {\n        bound_type: NegativeInfinity,\n        is_inclusive: True,\n      },\n      upper_bound: IntervalBound {\n        bound_type: NegativeInfinity,\n        is_inclusive: False,\n      },\n    },\n    1,\n  )\n}\n\n/// Obtain a human-readable string representation of the interval. Useful for debugging.\npub fn to_string(self: Interval) -> String {\n  let lower_bracket =\n    if self.lower_bound.is_inclusive {\n      @\"[\"\n    } else {\n      @\"(\"\n    }\n\n  let lower_bound = bound_type_to_string(self.lower_bound.bound_type)\n\n  let upper_bound = bound_type_to_string(self.upper_bound.bound_type)\n\n  let upper_bracket =\n    if self.upper_bound.is_inclusive {\n      @\"]\"\n    } else {\n      @\")\"\n    }\n\n  lower_bracket\n    |> string.concat(lower_bound)\n    |> string.concat(@\", \")\n    |> string.concat(upper_bound)\n    |> string.concat(upper_bracket)\n}\n\nfn bound_type_to_string(self: IntervalBoundType) -> String {\n  when self is {\n    NegativeInfinity -> @\"-∞\"\n    Finite(i) -> string.from_int(i)\n    PositiveInfinity -> @\"+∞\"\n  }\n}\n\n// ## Combining\n\n/// Computes the smallest interval containing the two given intervals, if any\n///\n/// ```aiken\n/// let iv1 = between(0, 10) // [0, 10]\n/// let iv2 = between(2, 14) // [2, 14]\n/// hull(iv1, iv2) == between(0, 14)\n///\n/// let iv1 = between(5, 10) // [5, 10]\n/// let iv2 = before(0) // [ْ-∞, 0]\n/// hull(iv1, iv2) == before(10)\n///\n/// let iv1 = entirely_after(0) // (0, +∞]\n/// let iv2 = between(10, 42)  // [10, 42]\n/// hull(iv1, iv2) = entirely_after(0)\n/// ```\npub fn hull(iv1: Interval, iv2: Interval) -> Interval {\n  Interval {\n    lower_bound: min(iv1.lower_bound, iv2.lower_bound),\n    upper_bound: max(iv1.upper_bound, iv2.upper_bound),\n  }\n}\n\ntest hull_1() {\n  let iv1 = between(0, 10)\n  let iv2 = between(2, 14)\n  hull(iv1, iv2) == between(0, 14)\n}\n\ntest hull_2() {\n  let iv1 = between(5, 10)\n  let iv2 = before(0)\n  hull(iv1, iv2) == before(10)\n}\n\ntest hull_3() {\n  let iv1 = entirely_after(0)\n  let iv2 = between(10, 42)\n  hull(iv1, iv2) == entirely_after(0)\n}\n\n/// Checks whether the second interval is fully included in the first.\n///\n/// ```aiken\n/// between(-5, 5)  // [-5, 5]\n///   |> includes(between(0, 2)) // [0, 2]\n///\n/// between(-5, 5)  // [-5, 5]\n///   |> includes(entirely_between(-5, 5)) // (-5, 5)\n///\n/// after(0) // [0, +∞]\n///   |> includes(after(1)) // [1, +∞]\n///\n/// before(-1) // (-∞, -1]\n///   |> includes(entirely_before(-1)) // [-∞, -1)\n/// ```\npub fn includes(self: Interval, other: Interval) -> Bool {\n  and {\n    !is_empty(self),\n    or {\n      is_empty(other),\n      and {\n        compare_bound_type(\n          other.lower_bound.bound_type,\n          self.lower_bound.bound_type,\n          fn() { False },\n          fn(_) {\n            self.lower_bound.is_inclusive || !other.lower_bound.is_inclusive\n          },\n          fn() { True },\n        ),\n        compare_bound_type(\n          other.upper_bound.bound_type,\n          self.upper_bound.bound_type,\n          fn() { True },\n          fn(_) {\n            self.upper_bound.is_inclusive || !other.upper_bound.is_inclusive\n          },\n          fn() { False },\n        ),\n      },\n    },\n  }\n}\n\ntest includes_1() {\n  between(-5, 5) |> includes(between(-5, 5))\n}\n\ntest includes_2() {\n  between(-5, 5) |> includes(between(0, 2))\n}\n\ntest includes_3() {\n  between(-5, 5) |> includes(entirely_between(-5, 5))\n}\n\ntest includes_4() {\n  !(entirely_between(-5, 5) |> includes(between(-5, 5)))\n}\n\ntest includes_5() {\n  and {\n    after(0) |> includes(after(1)),\n    entirely_after(0) |> includes(entirely_after(1)),\n  }\n}\n\ntest includes_6() {\n  and {\n    after(0) |> includes(after(1)),\n    entirely_after(0) |> includes(after(1)),\n  }\n}\n\ntest includes_7() {\n  and {\n    before(0) |> includes(before(-1)),\n    entirely_before(0) |> includes(before(-1)),\n  }\n}\n\ntest includes_8() {\n  and {\n    !(before(-1) |> includes(before(0))),\n    !(entirely_before(-1) |> includes(before(0))),\n  }\n}\n\n/// Computes the largest interval contained in the two given intervals, if any.\n///\n/// ```aiken\n/// let iv1 = interval.between(0, 10) // [0, 10]\n/// let iv2 = interval.between(2, 14) // [2, 14]\n/// interval.intersection(iv1, iv2) == interval.between(2, 10)\n///\n/// let iv1 = interval.entirely_before(10) // [-∞, 10)\n/// let iv2 = interval.entirely_after(0) // (0, +∞]\n/// interval.intersection(iv1, iv2) == interval.entirely_between(0, 10)\n///\n/// let iv1 = interval.between(0, 1) // [0, 1]\n/// let iv2 = interval.between(2, 3) // [2, 3]\n/// interval.intersection(iv1, iv2) |> interval.is_empty\n/// ```\npub fn intersection(iv1: Interval, iv2: Interval) -> Interval {\n  Interval {\n    lower_bound: max(iv1.lower_bound, iv2.lower_bound),\n    upper_bound: min(iv1.upper_bound, iv2.upper_bound),\n  }\n}\n\ntest intersection_1() {\n  let iv1 = between(0, 10)\n  let iv2 = between(2, 14)\n  intersection(iv1, iv2) == between(2, 10)\n}\n\ntest intersection_2() {\n  let iv1 = between(0, 1)\n  let iv2 = between(1, 2)\n  intersection(iv1, iv2) == between(1, 1)\n}\n\ntest intersection_3() {\n  let iv1 = between(0, 1)\n  let iv2 = entirely_between(1, 2)\n  intersection(iv1, iv2)\n    |> is_empty\n}\n\ntest intersection_4() {\n  let iv1 = entirely_between(0, 1)\n  let iv2 = entirely_between(1, 2)\n  intersection(iv1, iv2)\n    |> is_empty\n}\n\ntest intersection_5() {\n  let iv1 = between(0, 10)\n  let iv2 = before(4)\n  intersection(iv1, iv2) == between(0, 4)\n}\n\ntest intersection_6() {\n  let iv1 = entirely_before(10)\n  let iv2 = entirely_after(0)\n  intersection(iv1, iv2) == entirely_between(0, 10)\n}\n\n/// Return the highest bound of the two. For equal `IntervalBoundType`,\n/// an inclusive `IntervalBound` is considered higher.\n///\n/// ```aiken\n/// let ib1 = IntervalBound { bound_type: Finite(0), is_inclusive: False }\n/// let ib2 = IntervalBound { bound_type: Finite(1), is_inclusive: False }\n///\n/// interval.max(ib1, ib2) == ib2\n/// ```\npub fn max(left: IntervalBound, right: IntervalBound) -> IntervalBound {\n  compare_bound_type(\n    left.bound_type,\n    right.bound_type,\n    fn() { right },\n    fn(is_negative) {\n      if left.is_inclusive == right.is_inclusive {\n        left\n      } else if is_negative {\n        if left.is_inclusive {\n          right\n        } else {\n          left\n        }\n      } else {\n        if left.is_inclusive {\n          left\n        } else {\n          right\n        }\n      }\n    },\n    fn() { left },\n  )\n}\n\n/// Return the smallest bound of the two. For equal `IntervalBoundType`,\n/// an inclusive `IntervalBound` is considered smaller.\n///\n/// ```aiken\n/// let ib1 = IntervalBound { bound_type: Finite(0), is_inclusive: False }\n/// let ib2 = IntervalBound { bound_type: Finite(1), is_inclusive: False }\n///\n/// interval.min(ib1, ib2) == ib1\n/// ```\npub fn min(left: IntervalBound, right: IntervalBound) -> IntervalBound {\n  compare_bound_type(\n    left.bound_type,\n    right.bound_type,\n    fn() { left },\n    fn(is_negative) {\n      if left.is_inclusive == right.is_inclusive {\n        left\n      } else if is_negative {\n        if left.is_inclusive {\n          left\n        } else {\n          right\n        }\n      } else {\n        if left.is_inclusive {\n          right\n        } else {\n          left\n        }\n      }\n    },\n    fn() { right },\n  )\n}\n\nfn compare_bound_type(\n  left: IntervalBoundType,\n  right: IntervalBoundType,\n  less: fn() -> a,\n  equal: fn(Bool) -> a,\n  greater: fn() -> a,\n) -> a {\n  when left is {\n    NegativeInfinity ->\n      when right is {\n        NegativeInfinity -> equal(True)\n        _ -> less()\n      }\n    PositiveInfinity ->\n      when right is {\n        PositiveInfinity -> equal(False)\n        _ -> greater()\n      }\n    Finite(left) ->\n      when right is {\n        NegativeInfinity -> greater()\n        PositiveInfinity -> less()\n        Finite(right) ->\n          if left < right {\n            less()\n          } else if left == right {\n            equal(left < 0)\n          } else {\n            greater()\n          }\n      }\n  }\n}\n",
      "dependencies": ["aiken/primitive/string"],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.math.rational",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/math/rational.ak",
      "name": "aiken.math.rational",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 14,
          "raw": "use aiken/builtin",
          "source": "stdlib"
        },
        {
          "module": "aiken/collection/list",
          "items": [],
          "line": 15,
          "raw": "use aiken/collection/list",
          "source": "stdlib"
        },
        {
          "module": "aiken/math",
          "items": [],
          "line": 16,
          "raw": "use aiken/math",
          "source": "stdlib"
        },
        {
          "module": "aiken/option",
          "items": [],
          "line": 17,
          "raw": "use aiken/option",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "from_int",
          "signature": "pub fn from_int(numerator: Int) -> Rational {",
          "documentation": "Create a new `Rational` from an `Int`.\n\n```aiken\nSome(rational.from_int(14)) == rational.new(14, 1)\nSome(rational.from_int(-5)) == rational.new(-5, 1)\nSome(rational.from_int(0)) == rational.new(0, 1)\n```",
          "parameters": [
            {
              "name": "numerator",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Rational",
          "line": 34,
          "raw": "pub fn from_int(numerator: Int) -> Rational {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_int(numerator: Int) -> Rational {\n  Rational { numerator, denominator: 1 }\n}",
          "tests": [
            "test from_int_1() {\n  and {\n    (from_int(14) == ratio(14, 1))?,\n    (from_int(-5) == ratio(-5, 1))?,\n    (from_int(0) == ratio(0, 1))?,\n  }\n}"
          ]
        },
        {
          "name": "new",
          "signature": "pub fn new(numerator: Int, denominator: Int) -> Option<Rational> {",
          "documentation": "Make a `Rational` number from the ratio of two integers.\n\nReturns `None` when the denominator is null.\n\n```aiken\nrational.new(14, 42) == Some(r)\nrational.new(14, 0) == None\n```",
          "parameters": [
            {
              "name": "numerator",
              "type": "Int",
              "optional": false
            },
            {
              "name": "denominator",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Option<Rational>",
          "line": 65,
          "raw": "pub fn new(numerator: Int, denominator: Int) -> Option<Rational> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn new(numerator: Int, denominator: Int) -> Option<Rational> {\n  if denominator == 0 {\n    None\n  } else if denominator < 0 {\n    Some(Rational { numerator: -numerator, denominator: -denominator })\n  } else {\n    Some(Rational { numerator, denominator })\n  }\n}",
          "tests": [
            "test new_1() {\n  and {\n    (new(2, 0) == None)?,\n    (new(2, 3) == Some(ratio(2, 3)))?,\n    (new(-2, 3) == Some(ratio(-2, 3)))?,\n    (new(2, -3) == Some(ratio(-2, 3)))?,\n    (new(2, 4) == Some(ratio(2, 4)))?,\n    (new(-2, -3) == Some(ratio(2, 3)))?,\n    (new(-2, -4) == Some(ratio(2, 4)))?,\n  }\n}"
          ]
        },
        {
          "name": "denominator",
          "signature": "pub fn denominator(self: Rational) -> Int {",
          "documentation": "Get the denominator of a rational value.\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nrational.denominator(x) == 3\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Rational",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 102,
          "raw": "pub fn denominator(self: Rational) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn denominator(self: Rational) -> Int {\n  self.denominator\n}",
          "tests": [
            "test denominator_1() {\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(-2, 3)\n  expect Some(z) = new(2, -3)\n  expect Some(w) = new(-2, -3)\n  and {\n    (denominator(x) == 3)?,\n    (denominator(y) == 3)?,\n    (denominator(z) == 3)?,\n    (denominator(w) == 3)?,\n  }\n}"
          ]
        },
        {
          "name": "numerator",
          "signature": "pub fn numerator(self: Rational) -> Int {",
          "documentation": "Get the numerator of a rational value.\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nrational.numerator(x) == 2\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Rational",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 125,
          "raw": "pub fn numerator(self: Rational) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn numerator(self: Rational) -> Int {\n  self.numerator\n}",
          "tests": [
            "test numerator_1() {\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(-2, 3)\n  expect Some(z) = new(2, -3)\n  expect Some(w) = new(-2, -3)\n\n  and {\n    (numerator(x) == 2)?,\n    (numerator(y) == -2)?,\n    (numerator(z) == -2)?,\n    (numerator(w) == 2)?,\n  }\n}"
          ]
        },
        {
          "name": "abs",
          "signature": "pub fn abs(self: Rational) -> Rational {",
          "documentation": "Absolute value of a `Rational`.\n\n```aiken\nexpect Some(x) = rational.new(3, 2)\nexpect Some(y) = rational.new(-3, 2)\n\nrational.abs(x) == x\nrational.abs(y) == x\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Rational",
              "optional": false
            }
          ],
          "returnType": "Rational",
          "line": 154,
          "raw": "pub fn abs(self: Rational) -> Rational {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn abs(self: Rational) -> Rational {\n  let Rational { numerator: a_n, denominator: a_d } = self\n  Rational { numerator: math.abs(a_n), denominator: a_d }\n}",
          "tests": [
            "test abs_examples() {\n  and {\n    (abs(ratio(5, 2)) == ratio(5, 2))?,\n    (abs(ratio(-5, 2)) == ratio(5, 2))?,\n    (abs(ratio(5, 2)) == abs(ratio(-5, 2)))?,\n  }\n}"
          ]
        },
        {
          "name": "negate",
          "signature": "pub fn negate(a: Rational) -> Rational {",
          "documentation": "Change the sign of a `Rational`.\n\n```aiken\nexpect Some(x) = rational.new(3, 2)\nexpect Some(y) = rational.new(-3, 2)\n\nrational.negate(x) == y\nrational.negate(y) == x\n```",
          "parameters": [
            {
              "name": "a",
              "type": "Rational",
              "optional": false
            }
          ],
          "returnType": "Rational",
          "line": 176,
          "raw": "pub fn negate(a: Rational) -> Rational {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn negate(a: Rational) -> Rational {\n  let Rational { numerator: a_n, denominator: a_d } = a\n  Rational { numerator: -a_n, denominator: a_d }\n}",
          "tests": [
            "test negate_1() {\n  and {\n    (negate(ratio(5, 2)) == ratio(-5, 2))?,\n    (negate(ratio(-5, 2)) == ratio(5, 2))?,\n    (negate(negate(ratio(5, 2))) == ratio(5, 2))?,\n  }\n}"
          ]
        },
        {
          "name": "reciprocal",
          "signature": "pub fn reciprocal(self: Rational) -> Option<Rational> {",
          "documentation": "Reciprocal of a `Rational` number. That is, a new `Rational` where the\nnumerator and denominator have been swapped.\n\n```aiken\nexpect Some(x) = rational.new(2, 5)\nrational.reciprocal(x) == rational.new(5, 2)\n\nlet y = rational.zero\nrational.reciprocal(y) == None\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Rational",
              "optional": false
            }
          ],
          "returnType": "Option<Rational>",
          "line": 199,
          "raw": "pub fn reciprocal(self: Rational) -> Option<Rational> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn reciprocal(self: Rational) -> Option<Rational> {\n  let Rational { numerator: a_n, denominator: a_d } = self\n  if a_n < 0 {\n    Some(Rational { numerator: -a_d, denominator: -a_n })\n  } else if a_n > 0 {\n    Some(Rational { numerator: a_d, denominator: a_n })\n  } else {\n    None\n  }\n}",
          "tests": [
            "test reciprocal_1() {\n  and {\n    (reciprocal(ratio(5, 2)) == new(2, 5))?,\n    (reciprocal(ratio(-5, 2)) == new(-2, 5))?,\n    (reciprocal(ratio(0, 2)) == None)?,\n    (reciprocal(ratio(2, 3)) == new(3, 2))?,\n    (reciprocal(ratio(-2, 3)) == new(-3, 2))?,\n  }\n}"
          ]
        },
        {
          "name": "reduce",
          "signature": "pub fn reduce(self: Rational) -> Rational {",
          "documentation": "Reduce a rational to its irreducible form. This operation makes the\nnumerator and denominator coprime.\n\n```aiken\nexpect Some(x) = rational.new(80, 200)\nSome(rational.reduce(x)) == rational.new(2, 5)\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Rational",
              "optional": false
            }
          ],
          "returnType": "Rational",
          "line": 227,
          "raw": "pub fn reduce(self: Rational) -> Rational {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn reduce(self: Rational) -> Rational {\n  let Rational { numerator: a_n, denominator: a_d } = self\n  let d = math.gcd(a_n, a_d)\n  Rational { numerator: a_n / d, denominator: a_d / d }\n}",
          "tests": [
            "test reduce_1() {\n  and {\n    (reduce(ratio(80, 200)) == ratio(2, 5))?,\n    (reduce(ratio(-5, 1)) == ratio(-5, 1))?,\n    (reduce(ratio(0, 3)) == ratio(0, 1))?,\n  }\n}"
          ]
        },
        {
          "name": "add",
          "signature": "pub fn add(left: Rational, right: Rational) -> Rational {",
          "documentation": "Addition: sum of two rational values\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nexpect Some(y) = rational.new(3, 4)\n\nSome(rational.add(x, y)) == rational.new(17, 12)\n```",
          "parameters": [
            {
              "name": "left",
              "type": "Rational",
              "optional": false
            },
            {
              "name": "right",
              "type": "Rational",
              "optional": false
            }
          ],
          "returnType": "Rational",
          "line": 253,
          "raw": "pub fn add(left: Rational, right: Rational) -> Rational {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn add(left: Rational, right: Rational) -> Rational {\n  let Rational { numerator: a_n, denominator: a_d } = left\n  let Rational { numerator: b_n, denominator: b_d } = right\n  Rational { numerator: a_n * b_d + b_n * a_d, denominator: a_d * b_d }\n}",
          "tests": [
            "test add_1() {\n  add(ratio(2, 3), ratio(3, 4)) == ratio(17, 12)\n}",
            "test add_2() {\n  add(ratio(-2, 3), ratio(3, 4)) == ratio(1, 12)\n}"
          ]
        },
        {
          "name": "div",
          "signature": "pub fn div(left: Rational, right: Rational) -> Option<Rational> {",
          "documentation": "Division: quotient of two rational values. Returns `None` when the second\nvalue is null.\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nexpect Some(y) = rational.new(3, 4)\n\nrational.div(x, y) == rational.new(8, 9)\n```",
          "parameters": [
            {
              "name": "left",
              "type": "Rational",
              "optional": false
            },
            {
              "name": "right",
              "type": "Rational",
              "optional": false
            }
          ],
          "returnType": "Option<Rational>",
          "line": 276,
          "raw": "pub fn div(left: Rational, right: Rational) -> Option<Rational> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn div(left: Rational, right: Rational) -> Option<Rational> {\n  reciprocal(right) |> option.map(mul(left, _))\n}",
          "tests": [
            "test div_1() {\n  div(ratio(2, 3), ratio(3, 4)) == new(8, 9)\n}",
            "test div_2() {\n  div(ratio(2, 3), ratio(-3, 4)) == new(-8, 9)\n}"
          ]
        },
        {
          "name": "mul",
          "signature": "pub fn mul(left: Rational, right: Rational) -> Rational {",
          "documentation": "Multiplication: the product of two rational values.\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nexpect Some(y) = rational.new(3, 4)\n\nSome(rational.mul(x, y)) == rational.new(6, 12)\n```",
          "parameters": [
            {
              "name": "left",
              "type": "Rational",
              "optional": false
            },
            {
              "name": "right",
              "type": "Rational",
              "optional": false
            }
          ],
          "returnType": "Rational",
          "line": 296,
          "raw": "pub fn mul(left: Rational, right: Rational) -> Rational {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn mul(left: Rational, right: Rational) -> Rational {\n  let Rational { numerator: a_n, denominator: a_d } = left\n  let Rational { numerator: b_n, denominator: b_d } = right\n  Rational { numerator: a_n * b_n, denominator: a_d * b_d }\n}",
          "tests": [
            "test mul_1() {\n  mul(ratio(2, 3), ratio(3, 4)) == ratio(6, 12)\n}",
            "test mul_2() {\n  mul(ratio(-2, 3), ratio(-3, 4)) == ratio(6, 12)\n}",
            "test mul_3() {\n  let result =\n    ratio(2, 5)\n      |> mul(ratio(1, 8))\n      |> mul(ratio(3, 10))\n      |> mul(ratio(21, 100))\n      |> mul(ratio(3, 5))\n      |> mul(ratio(2, 8))\n      |> mul(ratio(4, 10))\n      |> mul(ratio(22, 100))\n      |> reduce\n\n  result == ratio(2079, 50000000)\n}"
          ]
        },
        {
          "name": "sub",
          "signature": "pub fn sub(left: Rational, right: Rational) -> Rational {",
          "documentation": "Subtraction: difference of two rational values\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nexpect Some(y) = rational.new(3, 4)\n\nSome(rational.sub(x, y)) == rational.new(-1, 12)\n```",
          "parameters": [
            {
              "name": "left",
              "type": "Rational",
              "optional": false
            },
            {
              "name": "right",
              "type": "Rational",
              "optional": false
            }
          ],
          "returnType": "Rational",
          "line": 333,
          "raw": "pub fn sub(left: Rational, right: Rational) -> Rational {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sub(left: Rational, right: Rational) -> Rational {\n  let Rational { numerator: a_n, denominator: a_d } = left\n  let Rational { numerator: b_n, denominator: b_d } = right\n  Rational { numerator: a_n * b_d - b_n * a_d, denominator: a_d * b_d }\n}",
          "tests": [
            "test sub_1() {\n  sub(ratio(2, 3), ratio(3, 4)) == ratio(-1, 12)\n}",
            "test sub_2() {\n  sub(ratio(2, 3), ratio(-3, 4)) == ratio(17, 12)\n}",
            "test sub_3() {\n  sub(ratio(-2, 3), ratio(3, 4)) == ratio(-17, 12)\n}"
          ]
        },
        {
          "name": "compare",
          "signature": "pub fn compare(left: Rational, right: Rational) -> Ordering {",
          "documentation": "Compare two rationals for an ordering. This is safe to use even for\nnon-reduced rationals.\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nexpect Some(y) = rational.new(3, 4)\nexpect Some(z) = rational.new(4, 6)\n\ncompare(x, y) == Less\ncompare(y, x) == Greater\ncompare(x, x) == Equal\ncompare(x, z) == Equal\n```",
          "parameters": [
            {
              "name": "left",
              "type": "Rational",
              "optional": false
            },
            {
              "name": "right",
              "type": "Rational",
              "optional": false
            }
          ],
          "returnType": "Ordering",
          "line": 366,
          "raw": "pub fn compare(left: Rational, right: Rational) -> Ordering {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn compare(left: Rational, right: Rational) -> Ordering {\n  let Rational { numerator: a_n, denominator: a_d } = left\n  let Rational { numerator: b_n, denominator: b_d } = right\n\n  let l = a_n * b_d\n  let r = b_n * a_d\n\n  if l < r {\n    Less\n  } else if l > r {\n    Greater\n  } else {\n    Equal\n  }\n}",
          "tests": [
            "test compare_1() {\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n  expect Some(z) = new(4, 6)\n  and {\n    compare(x, y) == Less,\n    compare(y, x) == Greater,\n    compare(x, x) == Equal,\n    compare(x, z) == Equal,\n  }\n}"
          ]
        },
        {
          "name": "compare_with",
          "signature": "pub fn compare_with(pub fn compare_with(left: Rational, with: fn(Int, Int) -> Bool, right: Rational,",
          "documentation": "Comparison of two rational values using a chosen heuristic. For example:\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nexpect Some(y) = rational.new(3, 4)\n\nrational.compare_with(x, >, y) == False\nrational.compare_with(y, >, x) == True\nrational.compare_with(x, >, x) == False\nrational.compare_with(x, >=, x) == True\nrational.compare_with(x, ==, x) == True\nrational.compare_with(x, ==, y) == False\n```",
          "parameters": [],
          "returnType": "Bool, right: Rational,",
          "line": 407,
          "raw": "pub fn compare_with(pub fn compare_with(left: Rational, with: fn(Int, Int) -> Bool, right: Rational,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn compare_with(\n  left: Rational,\n  with: fn(Int, Int) -> Bool,\n  right: Rational,\n) -> Bool {\n  let Rational { numerator: a_n, denominator: a_d } = left\n  let Rational { numerator: b_n, denominator: b_d } = right\n  with(a_n * b_d, b_n * a_d)\n}",
          "tests": [
            "test compare_with_eq() {\n  let eq =\n    compare_with(_, fn(l, r) { l == r }, _)\n\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n\n  !eq(x, y)? && !eq(y, x)? && eq(x, x)?\n}",
            "test compare_with_neq() {\n  let neq =\n    compare_with(_, fn(l, r) { l != r }, _)\n\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n\n  neq(x, y)? && neq(y, x)? && !neq(x, x)?\n}",
            "test compare_with_gte() {\n  let gte =\n    compare_with(_, fn(l, r) { l >= r }, _)\n\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n\n  !gte(x, y)? && gte(y, x)? && gte(x, x)?\n}",
            "test compare_with_gt() {\n  let gt =\n    compare_with(_, fn(l, r) { l > r }, _)\n\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n\n  !gt(x, y)? && gt(y, x)? && !gt(x, x)?\n}",
            "test compare_with_lte() {\n  let lte =\n    compare_with(_, fn(l, r) { l <= r }, _)\n\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n\n  lte(x, y)? && !lte(y, x)? && lte(x, x)?\n}",
            "test compare_with_lt() {\n  let lt =\n    compare_with(_, fn(l, r) { l < r }, _)\n\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n\n  lt(x, y)? && !lt(y, x)? && !lt(x, x)?\n}"
          ]
        },
        {
          "name": "arithmetic_mean",
          "signature": "pub fn arithmetic_mean(self: List<Rational>) -> Option<Rational> {",
          "documentation": "Calculate the arithmetic mean between two `Rational` values.\n\n```aiken\nlet x = rational.from_int(0)\nlet y = rational.from_int(1)\nlet z = rational.from_int(2)\n\nexpect Some(result) = rational.arithmetic_mean([x, y, z])\n\nrational.compare(result, y) == Equal\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<Rational>",
              "optional": false
            }
          ],
          "returnType": "Option<Rational>",
          "line": 492,
          "raw": "pub fn arithmetic_mean(self: List<Rational>) -> Option<Rational> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn arithmetic_mean(self: List<Rational>) -> Option<Rational> {\n  div(list.foldr(self, zero, add), from_int(list.length(self)))\n}",
          "tests": [
            "test arithmetic_mean_1() {\n  let x = ratio(1, 2)\n  let y = ratio(1, 2)\n  expect Some(z) = arithmetic_mean([x, y])\n  reduce(z) == ratio(1, 2)\n}",
            "test arithmetic_mean_2() {\n  let x = ratio(1, 1)\n  let y = ratio(2, 1)\n  expect Some(z) = arithmetic_mean([x, y])\n  reduce(z) == ratio(3, 2)\n}",
            "test arithmetic_mean_3() {\n  let xs =\n    [\n      ratio(1, 1),\n      ratio(2, 1),\n      ratio(3, 1),\n      ratio(4, 1),\n      ratio(5, 1),\n      ratio(6, 1),\n    ]\n  expect Some(z) = arithmetic_mean(xs)\n  reduce(z) == ratio(7, 2)\n}"
          ]
        },
        {
          "name": "geometric_mean",
          "signature": "pub fn geometric_mean(left: Rational, right: Rational) -> Option<Rational> {",
          "documentation": "Calculate the geometric mean between two `Rational` values. This returns\neither the exact result or the smallest integer nearest to the square root\nfor the numerator and denominator.\n\n```aiken\nexpect Some(x) = rational.new(1, 3)\nexpect Some(y) = rational.new(1, 6)\n\nrational.geometric_mean(x, y) == rational.new(1, 4)\n```",
          "parameters": [
            {
              "name": "left",
              "type": "Rational",
              "optional": false
            },
            {
              "name": "right",
              "type": "Rational",
              "optional": false
            }
          ],
          "returnType": "Option<Rational>",
          "line": 534,
          "raw": "pub fn geometric_mean(left: Rational, right: Rational) -> Option<Rational> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn geometric_mean(left: Rational, right: Rational) -> Option<Rational> {\n  let Rational { numerator: a_n, denominator: a_d } = left\n  let Rational { numerator: b_n, denominator: b_d } = right\n  when math.sqrt(a_n * b_n) is {\n    Some(numerator) ->\n      when math.sqrt(a_d * b_d) is {\n        Some(denominator) -> Some(Rational { numerator, denominator })\n        None -> None\n      }\n    None -> None\n  }\n}",
          "tests": [
            "test geometric_mean1() {\n  expect Some(x) = new(1, 2)\n  expect Some(y) = new(1, 2)\n  geometric_mean(x, y) == new(1, 2)\n}",
            "test geometric_mean2() {\n  expect Some(x) = new(-1, 2)\n  expect Some(y) = new(1, 2)\n  geometric_mean(x, y) == None\n}",
            "test geometric_mean3() {\n  expect Some(x) = new(1, 2)\n  expect Some(y) = new(-1, 2)\n  geometric_mean(x, y) == None\n}",
            "test geometric_mean4() {\n  expect Some(x) = new(1, 3)\n  expect Some(y) = new(1, 6)\n  geometric_mean(x, y) == new(1, 4)\n}",
            "test geometric_mean5() {\n  expect Some(x) = new(67, 2500)\n  expect Some(y) = new(35331, 1000)\n  expect Some(yi) = reciprocal(y)\n  geometric_mean(x, yi) == new(258, 9398)\n}"
          ]
        },
        {
          "name": "ceil",
          "signature": "pub fn ceil(self: Rational) -> Int {",
          "documentation": "Returns the smallest `Int` not less than a given `Rational`\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nrational.ceil(x) == 1\n\nexpect Some(y) = rational.new(44, 14)\nrational.ceil(y) == 4\n\nexpect Some(z) = rational.new(-14, 3)\nrational.ceil(z) == -4\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Rational",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 592,
          "raw": "pub fn ceil(self: Rational) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn ceil(self: Rational) -> Int {\n  let Rational { numerator, denominator } = self\n  if builtin.remainder_integer(numerator, denominator) > 0 {\n    builtin.quotient_integer(numerator, denominator) + 1\n  } else {\n    builtin.quotient_integer(numerator, denominator)\n  }\n}",
          "tests": [
            "test ceil_1() {\n  and {\n    (ceil(ratio(13, 5)) == 3)?,\n    (ceil(ratio(15, 5)) == 3)?,\n    (ceil(ratio(16, 5)) == 4)?,\n    (ceil(ratio(-3, 5)) == 0)?,\n    (ceil(ratio(-5, 5)) == -1)?,\n    (ceil(ratio(-14, 3)) == -4)?,\n    (ceil(ratio(-14, 6)) == -2)?,\n    (ceil(ratio(44, 14)) == 4)?,\n  }\n}"
          ]
        },
        {
          "name": "floor",
          "signature": "pub fn floor(self: Rational) -> Int {",
          "documentation": "Returns the greatest `Int` no greater than a given `Rational`\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nrational.floor(x) == 0\n\nexpect Some(y) = rational.new(44, 14)\nrational.floor(y) == 3\n\nexpect Some(z) = rational.new(-14, 3)\nrational.floor(z) == -5\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Rational",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 626,
          "raw": "pub fn floor(self: Rational) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn floor(self: Rational) -> Int {\n  let Rational { numerator: a_n, denominator: a_d } = self\n  a_n / a_d\n}",
          "tests": [
            "test floor_1() {\n  and {\n    (floor(ratio(5, 2)) == 2)?,\n    (floor(ratio(5, 3)) == 1)?,\n    (floor(ratio(5, 4)) == 1)?,\n    (floor(ratio(5, 5)) == 1)?,\n    (floor(ratio(5, 6)) == 0)?,\n    (floor(ratio(8, 3)) == 2)?,\n    (floor(ratio(-14, 3)) == -5)?,\n  }\n}"
          ]
        },
        {
          "name": "pow",
          "signature": "pub fn pow(x: Rational, y: Int) -> Option<Rational> {",
          "documentation": "Computes the rational number x raised to the power y. Returns `None` for\ninvalid exponentiation.\n\n```aiken\nexpect Some(x) = rational.new(50, 2500)\nrational.reduce(rational.pow(x, 3)) == rational.new(1, 125000)\n\nexpect Some(x) = rational.new(50, 2500)\nrational.reduce(rational.pow(x, -3)) == rational.new(125000, 1)\n```",
          "parameters": [
            {
              "name": "x",
              "type": "Rational",
              "optional": false
            },
            {
              "name": "y",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Option<Rational>",
          "line": 653,
          "raw": "pub fn pow(x: Rational, y: Int) -> Option<Rational> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn pow(x: Rational, y: Int) -> Option<Rational> {\n  let Rational { numerator: a, denominator: b } = x\n\n  if a == 0 && y <= 0 {\n    None\n  } else if y > 0 {\n    Some(Rational { numerator: math.pow(a, y), denominator: math.pow(b, y) })\n  } else if y < 0 {\n    Some(Rational { numerator: math.pow(b, -y), denominator: math.pow(a, -y) })\n  } else {\n    Some(Rational { numerator: 1, denominator: 1 })\n  }\n}",
          "tests": [
            "test pow_negative_exponent_non_zero_fraction() {\n  expect Some(base) = new(50, 2500)\n  expect Some(calculated_result) = pow(base, -3)\n  expect Some(expected_result) = new(125000, 1)\n  reduce(calculated_result) == expected_result\n}",
            "test pow_positive_exponent() {\n  expect Some(base) = new(50, 2500)\n  expect Some(calculated_result) = pow(base, 3)\n  expect Some(expected_result) = new(1, 125000)\n  reduce(calculated_result) == expected_result\n}",
            "test pow_exponent_zero() {\n  expect Some(base) = new(50, 2500)\n  pow(base, 0) == new(1, 1)\n}",
            "test pow_rational_zero_exponent_zero() {\n  expect Some(base) = new(0, 1)\n  pow(base, 0) == None\n}"
          ]
        },
        {
          "name": "proper_fraction",
          "signature": "pub fn proper_fraction(self: Rational) -> (Int, Rational) {",
          "documentation": "Returns the proper fraction of a given `Rational` `r`. That is, a 2-tuple of\nan `Int` and `Rational` (n, f) such that:\n\n- `r = n + f`;\n- `n` and `f` have the same sign as `r`;\n- `f` has an absolute value less than 1.",
          "parameters": [
            {
              "name": "self",
              "type": "Rational",
              "optional": false
            }
          ],
          "returnType": "(Int, Rational)",
          "line": 697,
          "raw": "pub fn proper_fraction(self: Rational) -> (Int, Rational) {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn proper_fraction(self: Rational) -> (Int, Rational) {\n  let Rational { numerator, denominator } = self\n  (\n    builtin.quotient_integer(numerator, denominator),\n    Rational {\n      numerator: builtin.remainder_integer(numerator, denominator),\n      denominator,\n    },\n  )\n}",
          "tests": [
            "test proper_fraction_1() {\n  let r = ratio(10, 7)\n  let (n, f) = proper_fraction(r)\n  and {\n    (n == 1)?,\n    (f == ratio(3, 7))?,\n    (r == add(from_int(n), f))?,\n  }\n}",
            "test proper_fraction_2() {\n  let r = ratio(-10, 7)\n  let (n, f) = proper_fraction(r)\n  and {\n    (n == -1)?,\n    (f == ratio(-3, 7))?,\n    (r == add(from_int(n), f))?,\n  }\n}",
            "test proper_fraction_3() {\n  let r = ratio(4, 2)\n  let (n, f) = proper_fraction(r)\n  and {\n    (n == 2)?,\n    (f == ratio(0, 2))?,\n    (r == add(from_int(n), f))?,\n  }\n}"
          ]
        },
        {
          "name": "round",
          "signature": "pub fn round(self: Rational) -> Int {",
          "documentation": "Round the argument to the nearest whole number. If the argument is\nequidistant between two values, the greater value is returned (it\nrounds half towards positive infinity).\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nrational.round(x) == 1\n\nexpect Some(y) = rational.new(3, 2)\nrational.round(y) == 2\n\nexpect Some(z) = rational.new(-3, 2)\nrational.round(z) == -1\n```\n\n> [!CAUTION]\n> This behaves differently than _Haskell_. If you're coming from `PlutusTx`, beware that in Haskell, rounding on equidistant values depends on the whole number being odd or even.\n> If you need this behaviour, use [`round_even`](#round_even).",
          "parameters": [
            {
              "name": "self",
              "type": "Rational",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 756,
          "raw": "pub fn round(self: Rational) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn round(self: Rational) -> Int {\n  let (n, f) = proper_fraction(self)\n\n  let is_negative = f.numerator < 0\n\n  when compare(abs(f), ratio(1, 2)) is {\n    Less -> n\n    Equal ->\n      if is_negative {\n        n\n      } else {\n        n + 1\n      }\n    Greater ->\n      if is_negative {\n        n - 1\n      } else {\n        n + 1\n      }\n  }\n}",
          "tests": [
            "test round_1() {\n  and {\n    (round(ratio(10, 7)) == 1)?,\n    (round(ratio(11, 7)) == 2)?,\n    (round(ratio(3, 2)) == 2)?,\n    (round(ratio(5, 2)) == 3)?,\n    (round(ratio(-3, 2)) == -1)?,\n    (round(ratio(-2, 3)) == -1)?,\n    (round(ratio(-10, 7)) == -1)?,\n    (round(ratio(4, 2)) == 2)?,\n  }\n}"
          ]
        },
        {
          "name": "round_even",
          "signature": "pub fn round_even(self: Rational) -> Int {",
          "documentation": "Round the argument to the nearest whole number. If the argument is\nequidistant between two values, it returns the value that is even (it\nrounds half to even, also known as 'banker's rounding').\n\n```aiken\nexpect Some(w) = rational.new(2, 3)\nrational.round_even(w) == 1\n\nexpect Some(x) = rational.new(3, 2)\nrational.round_even(x) == 2\n\nexpect Some(y) = rational.new(5, 2)\nrational.round_even(y) == 2\n\nexpect Some(y) = rational.new(-3, 2)\nrational.round_even(y) == -2\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Rational",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 808,
          "raw": "pub fn round_even(self: Rational) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn round_even(self: Rational) -> Int {\n  let (n, f) = proper_fraction(self)\n\n  let m =\n    when compare(f, ratio(0, 1)) is {\n      Less -> -1\n      _ -> 1\n    }\n\n  let is_even = n % 2 == 0\n\n  when compare(abs(f), ratio(1, 2)) is {\n    Less -> n\n    Equal ->\n      if is_even {\n        n\n      } else {\n        n + m\n      }\n    Greater -> n + m\n  }\n}",
          "tests": [
            "test round_even_1() {\n  and {\n    (round_even(ratio(10, 7)) == 1)?,\n    (round_even(ratio(11, 7)) == 2)?,\n    (round_even(ratio(3, 2)) == 2)?,\n    (round_even(ratio(5, 2)) == 2)?,\n    (round_even(ratio(-3, 2)) == -2)?,\n    (round_even(ratio(-2, 3)) == -1)?,\n    (round_even(ratio(-10, 7)) == -1)?,\n    (round_even(ratio(4, 2)) == 2)?,\n  }\n}"
          ]
        },
        {
          "name": "truncate",
          "signature": "pub fn truncate(self: Rational) -> Int {",
          "documentation": "Returns the nearest `Int` between zero and a given `Rational`.\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nrational.truncate(x) == 0\n\nexpect Some(y) = rational.new(44, 14)\nrational.truncate(y) == 3\n\nexpect Some(z) = rational.new(-14, 3)\nrational.truncate(z) == -4\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Rational",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 856,
          "raw": "pub fn truncate(self: Rational) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn truncate(self: Rational) -> Int {\n  let Rational { numerator: a_n, denominator: a_d } = self\n  builtin.quotient_integer(a_n, a_d)\n}",
          "tests": [
            "test truncate_1() {\n  and {\n    (truncate(ratio(5, 2)) == 2)?,\n    (truncate(ratio(5, 3)) == 1)?,\n    (truncate(ratio(5, 4)) == 1)?,\n    (truncate(ratio(5, 5)) == 1)?,\n    (truncate(ratio(5, 6)) == 0)?,\n    (truncate(ratio(8, 3)) == 2)?,\n    (truncate(ratio(-14, 3)) == -4)?,\n  }\n}"
          ]
        }
      ],
      "types": [
        {
          "name": "Rational",
          "definition": "opaque { numerator: Int, denominator: Int, }",
          "line": 20,
          "raw": "pub opaque type Rational {",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "constants": [
        {
          "name": "zero",
          "type": "Rational",
          "value": "Rational { numerator: 0, denominator: 1 }",
          "line": 88,
          "raw": "pub const zero: Rational = Rational { numerator: 0, denominator: 1 }",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "atoms": [
        {
          "name": "ratio",
          "signature": "fn ratio(numerator: Int, denominator: Int) -> Rational {",
          "documentation": "An unsafe constructor for `Rational` values. Assumes that the following invariants are\nenforced:\n\n- the denominator is positive (the sign is managed in the numerator);\n- the denominator is not null.\n\nThis function is mainly used as a quick way to construct rationals from literal values.",
          "parameters": [
            {
              "name": "numerator",
              "type": "Int",
              "optional": false
            },
            {
              "name": "denominator",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Rational",
          "line": 53,
          "raw": "fn ratio(numerator: Int, denominator: Int) -> Rational {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn ratio(numerator: Int, denominator: Int) -> Rational {\n  Rational { numerator, denominator }\n}"
        }
      ],
      "privateTypes": [],
      "privateConstants": [],
      "content": "//// This module implements operations between rational numbers.\n////\n//// > [!CAUTION]\n//// > Internally, rational aren't automatically reduced as this is **only done on-demand**.\n//// >\n//// > Thus, for example:\n//// >\n//// > ```aiken\n//// > rational.new(2, 3) != rational.new(4, 6)\n//// > ```\n//// >\n//// > Comparing rational values should, therefore, only happen after reduction (see [reduce](#reduce)) or via the [compare](#compare) method.\n\nuse aiken/builtin\nuse aiken/collection/list\nuse aiken/math\nuse aiken/option\n\n/// Opaque type used to ensure the sign of the Rational is managed strictly in the numerator.\npub opaque type Rational {\n  numerator: Int,\n  denominator: Int,\n}\n\n// ## Constructing\n\n/// Create a new `Rational` from an `Int`.\n///\n/// ```aiken\n/// Some(rational.from_int(14)) == rational.new(14, 1)\n/// Some(rational.from_int(-5)) == rational.new(-5, 1)\n/// Some(rational.from_int(0)) == rational.new(0, 1)\n/// ```\npub fn from_int(numerator: Int) -> Rational {\n  Rational { numerator, denominator: 1 }\n}\n\ntest from_int_1() {\n  and {\n    (from_int(14) == ratio(14, 1))?,\n    (from_int(-5) == ratio(-5, 1))?,\n    (from_int(0) == ratio(0, 1))?,\n  }\n}\n\n/// An unsafe constructor for `Rational` values. Assumes that the following invariants are\n/// enforced:\n///\n/// - the denominator is positive (the sign is managed in the numerator);\n/// - the denominator is not null.\n///\n/// This function is mainly used as a quick way to construct rationals from literal values.\nfn ratio(numerator: Int, denominator: Int) -> Rational {\n  Rational { numerator, denominator }\n}\n\n/// Make a `Rational` number from the ratio of two integers.\n///\n/// Returns `None` when the denominator is null.\n///\n/// ```aiken\n/// rational.new(14, 42) == Some(r)\n/// rational.new(14, 0) == None\n/// ```\npub fn new(numerator: Int, denominator: Int) -> Option<Rational> {\n  if denominator == 0 {\n    None\n  } else if denominator < 0 {\n    Some(Rational { numerator: -numerator, denominator: -denominator })\n  } else {\n    Some(Rational { numerator, denominator })\n  }\n}\n\ntest new_1() {\n  and {\n    (new(2, 0) == None)?,\n    (new(2, 3) == Some(ratio(2, 3)))?,\n    (new(-2, 3) == Some(ratio(-2, 3)))?,\n    (new(2, -3) == Some(ratio(-2, 3)))?,\n    (new(2, 4) == Some(ratio(2, 4)))?,\n    (new(-2, -3) == Some(ratio(2, 3)))?,\n    (new(-2, -4) == Some(ratio(2, 4)))?,\n  }\n}\n\n/// A null `Rational`.\npub const zero: Rational = Rational { numerator: 0, denominator: 1 }\n\ntest zero_1() {\n  zero == ratio(0, 1)\n}\n\n// ## Inspecting\n\n/// Get the denominator of a rational value.\n///\n/// ```aiken\n/// expect Some(x) = rational.new(2, 3)\n/// rational.denominator(x) == 3\n/// ```\npub fn denominator(self: Rational) -> Int {\n  self.denominator\n}\n\ntest denominator_1() {\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(-2, 3)\n  expect Some(z) = new(2, -3)\n  expect Some(w) = new(-2, -3)\n  and {\n    (denominator(x) == 3)?,\n    (denominator(y) == 3)?,\n    (denominator(z) == 3)?,\n    (denominator(w) == 3)?,\n  }\n}\n\n/// Get the numerator of a rational value.\n///\n/// ```aiken\n/// expect Some(x) = rational.new(2, 3)\n/// rational.numerator(x) == 2\n/// ```\npub fn numerator(self: Rational) -> Int {\n  self.numerator\n}\n\ntest numerator_1() {\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(-2, 3)\n  expect Some(z) = new(2, -3)\n  expect Some(w) = new(-2, -3)\n\n  and {\n    (numerator(x) == 2)?,\n    (numerator(y) == -2)?,\n    (numerator(z) == -2)?,\n    (numerator(w) == 2)?,\n  }\n}\n\n// ## Modifying\n\n/// Absolute value of a `Rational`.\n///\n/// ```aiken\n/// expect Some(x) = rational.new(3, 2)\n/// expect Some(y) = rational.new(-3, 2)\n///\n/// rational.abs(x) == x\n/// rational.abs(y) == x\n/// ```\npub fn abs(self: Rational) -> Rational {\n  let Rational { numerator: a_n, denominator: a_d } = self\n  Rational { numerator: math.abs(a_n), denominator: a_d }\n}\n\ntest abs_examples() {\n  and {\n    (abs(ratio(5, 2)) == ratio(5, 2))?,\n    (abs(ratio(-5, 2)) == ratio(5, 2))?,\n    (abs(ratio(5, 2)) == abs(ratio(-5, 2)))?,\n  }\n}\n\n/// Change the sign of a `Rational`.\n///\n/// ```aiken\n/// expect Some(x) = rational.new(3, 2)\n/// expect Some(y) = rational.new(-3, 2)\n///\n/// rational.negate(x) == y\n/// rational.negate(y) == x\n/// ```\npub fn negate(a: Rational) -> Rational {\n  let Rational { numerator: a_n, denominator: a_d } = a\n  Rational { numerator: -a_n, denominator: a_d }\n}\n\ntest negate_1() {\n  and {\n    (negate(ratio(5, 2)) == ratio(-5, 2))?,\n    (negate(ratio(-5, 2)) == ratio(5, 2))?,\n    (negate(negate(ratio(5, 2))) == ratio(5, 2))?,\n  }\n}\n\n/// Reciprocal of a `Rational` number. That is, a new `Rational` where the\n/// numerator and denominator have been swapped.\n///\n/// ```aiken\n/// expect Some(x) = rational.new(2, 5)\n/// rational.reciprocal(x) == rational.new(5, 2)\n///\n/// let y = rational.zero\n/// rational.reciprocal(y) == None\n/// ```\npub fn reciprocal(self: Rational) -> Option<Rational> {\n  let Rational { numerator: a_n, denominator: a_d } = self\n  if a_n < 0 {\n    Some(Rational { numerator: -a_d, denominator: -a_n })\n  } else if a_n > 0 {\n    Some(Rational { numerator: a_d, denominator: a_n })\n  } else {\n    None\n  }\n}\n\ntest reciprocal_1() {\n  and {\n    (reciprocal(ratio(5, 2)) == new(2, 5))?,\n    (reciprocal(ratio(-5, 2)) == new(-2, 5))?,\n    (reciprocal(ratio(0, 2)) == None)?,\n    (reciprocal(ratio(2, 3)) == new(3, 2))?,\n    (reciprocal(ratio(-2, 3)) == new(-3, 2))?,\n  }\n}\n\n/// Reduce a rational to its irreducible form. This operation makes the\n/// numerator and denominator coprime.\n///\n/// ```aiken\n/// expect Some(x) = rational.new(80, 200)\n/// Some(rational.reduce(x)) == rational.new(2, 5)\n/// ```\npub fn reduce(self: Rational) -> Rational {\n  let Rational { numerator: a_n, denominator: a_d } = self\n  let d = math.gcd(a_n, a_d)\n  Rational { numerator: a_n / d, denominator: a_d / d }\n}\n\ntest reduce_1() {\n  and {\n    (reduce(ratio(80, 200)) == ratio(2, 5))?,\n    (reduce(ratio(-5, 1)) == ratio(-5, 1))?,\n    (reduce(ratio(0, 3)) == ratio(0, 1))?,\n  }\n}\n\n// ## Combining\n\n// ### Arithmetic operations\n\n/// Addition: sum of two rational values\n///\n/// ```aiken\n/// expect Some(x) = rational.new(2, 3)\n/// expect Some(y) = rational.new(3, 4)\n///\n/// Some(rational.add(x, y)) == rational.new(17, 12)\n/// ```\npub fn add(left: Rational, right: Rational) -> Rational {\n  let Rational { numerator: a_n, denominator: a_d } = left\n  let Rational { numerator: b_n, denominator: b_d } = right\n  Rational { numerator: a_n * b_d + b_n * a_d, denominator: a_d * b_d }\n}\n\ntest add_1() {\n  add(ratio(2, 3), ratio(3, 4)) == ratio(17, 12)\n}\n\ntest add_2() {\n  add(ratio(-2, 3), ratio(3, 4)) == ratio(1, 12)\n}\n\n/// Division: quotient of two rational values. Returns `None` when the second\n/// value is null.\n///\n/// ```aiken\n/// expect Some(x) = rational.new(2, 3)\n/// expect Some(y) = rational.new(3, 4)\n///\n/// rational.div(x, y) == rational.new(8, 9)\n/// ```\npub fn div(left: Rational, right: Rational) -> Option<Rational> {\n  reciprocal(right) |> option.map(mul(left, _))\n}\n\ntest div_1() {\n  div(ratio(2, 3), ratio(3, 4)) == new(8, 9)\n}\n\ntest div_2() {\n  div(ratio(2, 3), ratio(-3, 4)) == new(-8, 9)\n}\n\n/// Multiplication: the product of two rational values.\n///\n/// ```aiken\n/// expect Some(x) = rational.new(2, 3)\n/// expect Some(y) = rational.new(3, 4)\n///\n/// Some(rational.mul(x, y)) == rational.new(6, 12)\n/// ```\npub fn mul(left: Rational, right: Rational) -> Rational {\n  let Rational { numerator: a_n, denominator: a_d } = left\n  let Rational { numerator: b_n, denominator: b_d } = right\n  Rational { numerator: a_n * b_n, denominator: a_d * b_d }\n}\n\ntest mul_1() {\n  mul(ratio(2, 3), ratio(3, 4)) == ratio(6, 12)\n}\n\ntest mul_2() {\n  mul(ratio(-2, 3), ratio(-3, 4)) == ratio(6, 12)\n}\n\ntest mul_3() {\n  let result =\n    ratio(2, 5)\n      |> mul(ratio(1, 8))\n      |> mul(ratio(3, 10))\n      |> mul(ratio(21, 100))\n      |> mul(ratio(3, 5))\n      |> mul(ratio(2, 8))\n      |> mul(ratio(4, 10))\n      |> mul(ratio(22, 100))\n      |> reduce\n\n  result == ratio(2079, 50000000)\n}\n\n/// Subtraction: difference of two rational values\n///\n/// ```aiken\n/// expect Some(x) = rational.new(2, 3)\n/// expect Some(y) = rational.new(3, 4)\n///\n/// Some(rational.sub(x, y)) == rational.new(-1, 12)\n/// ```\npub fn sub(left: Rational, right: Rational) -> Rational {\n  let Rational { numerator: a_n, denominator: a_d } = left\n  let Rational { numerator: b_n, denominator: b_d } = right\n  Rational { numerator: a_n * b_d - b_n * a_d, denominator: a_d * b_d }\n}\n\ntest sub_1() {\n  sub(ratio(2, 3), ratio(3, 4)) == ratio(-1, 12)\n}\n\ntest sub_2() {\n  sub(ratio(2, 3), ratio(-3, 4)) == ratio(17, 12)\n}\n\ntest sub_3() {\n  sub(ratio(-2, 3), ratio(3, 4)) == ratio(-17, 12)\n}\n\n// ### Ordering\n\n/// Compare two rationals for an ordering. This is safe to use even for\n/// non-reduced rationals.\n///\n/// ```aiken\n/// expect Some(x) = rational.new(2, 3)\n/// expect Some(y) = rational.new(3, 4)\n/// expect Some(z) = rational.new(4, 6)\n///\n/// compare(x, y) == Less\n/// compare(y, x) == Greater\n/// compare(x, x) == Equal\n/// compare(x, z) == Equal\n/// ```\npub fn compare(left: Rational, right: Rational) -> Ordering {\n  let Rational { numerator: a_n, denominator: a_d } = left\n  let Rational { numerator: b_n, denominator: b_d } = right\n\n  let l = a_n * b_d\n  let r = b_n * a_d\n\n  if l < r {\n    Less\n  } else if l > r {\n    Greater\n  } else {\n    Equal\n  }\n}\n\ntest compare_1() {\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n  expect Some(z) = new(4, 6)\n  and {\n    compare(x, y) == Less,\n    compare(y, x) == Greater,\n    compare(x, x) == Equal,\n    compare(x, z) == Equal,\n  }\n}\n\n/// Comparison of two rational values using a chosen heuristic. For example:\n///\n/// ```aiken\n/// expect Some(x) = rational.new(2, 3)\n/// expect Some(y) = rational.new(3, 4)\n///\n/// rational.compare_with(x, >, y) == False\n/// rational.compare_with(y, >, x) == True\n/// rational.compare_with(x, >, x) == False\n/// rational.compare_with(x, >=, x) == True\n/// rational.compare_with(x, ==, x) == True\n/// rational.compare_with(x, ==, y) == False\n/// ```\npub fn compare_with(\n  left: Rational,\n  with: fn(Int, Int) -> Bool,\n  right: Rational,\n) -> Bool {\n  let Rational { numerator: a_n, denominator: a_d } = left\n  let Rational { numerator: b_n, denominator: b_d } = right\n  with(a_n * b_d, b_n * a_d)\n}\n\n// TODO: Rewrite tests using binary-operator as first-class functions once aiken-lang/aiken#619 is merged.\n\ntest compare_with_eq() {\n  let eq =\n    compare_with(_, fn(l, r) { l == r }, _)\n\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n\n  !eq(x, y)? && !eq(y, x)? && eq(x, x)?\n}\n\ntest compare_with_neq() {\n  let neq =\n    compare_with(_, fn(l, r) { l != r }, _)\n\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n\n  neq(x, y)? && neq(y, x)? && !neq(x, x)?\n}\n\ntest compare_with_gte() {\n  let gte =\n    compare_with(_, fn(l, r) { l >= r }, _)\n\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n\n  !gte(x, y)? && gte(y, x)? && gte(x, x)?\n}\n\ntest compare_with_gt() {\n  let gt =\n    compare_with(_, fn(l, r) { l > r }, _)\n\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n\n  !gt(x, y)? && gt(y, x)? && !gt(x, x)?\n}\n\ntest compare_with_lte() {\n  let lte =\n    compare_with(_, fn(l, r) { l <= r }, _)\n\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n\n  lte(x, y)? && !lte(y, x)? && lte(x, x)?\n}\n\ntest compare_with_lt() {\n  let lt =\n    compare_with(_, fn(l, r) { l < r }, _)\n\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n\n  lt(x, y)? && !lt(y, x)? && !lt(x, x)?\n}\n\n// ### Means\n\n/// Calculate the arithmetic mean between two `Rational` values.\n///\n/// ```aiken\n/// let x = rational.from_int(0)\n/// let y = rational.from_int(1)\n/// let z = rational.from_int(2)\n///\n/// expect Some(result) = rational.arithmetic_mean([x, y, z])\n///\n/// rational.compare(result, y) == Equal\n/// ```\npub fn arithmetic_mean(self: List<Rational>) -> Option<Rational> {\n  div(list.foldr(self, zero, add), from_int(list.length(self)))\n}\n\ntest arithmetic_mean_1() {\n  let x = ratio(1, 2)\n  let y = ratio(1, 2)\n  expect Some(z) = arithmetic_mean([x, y])\n  reduce(z) == ratio(1, 2)\n}\n\ntest arithmetic_mean_2() {\n  let x = ratio(1, 1)\n  let y = ratio(2, 1)\n  expect Some(z) = arithmetic_mean([x, y])\n  reduce(z) == ratio(3, 2)\n}\n\ntest arithmetic_mean_3() {\n  let xs =\n    [\n      ratio(1, 1),\n      ratio(2, 1),\n      ratio(3, 1),\n      ratio(4, 1),\n      ratio(5, 1),\n      ratio(6, 1),\n    ]\n  expect Some(z) = arithmetic_mean(xs)\n  reduce(z) == ratio(7, 2)\n}\n\n/// Calculate the geometric mean between two `Rational` values. This returns\n/// either the exact result or the smallest integer nearest to the square root\n/// for the numerator and denominator.\n///\n/// ```aiken\n/// expect Some(x) = rational.new(1, 3)\n/// expect Some(y) = rational.new(1, 6)\n///\n/// rational.geometric_mean(x, y) == rational.new(1, 4)\n/// ```\npub fn geometric_mean(left: Rational, right: Rational) -> Option<Rational> {\n  let Rational { numerator: a_n, denominator: a_d } = left\n  let Rational { numerator: b_n, denominator: b_d } = right\n  when math.sqrt(a_n * b_n) is {\n    Some(numerator) ->\n      when math.sqrt(a_d * b_d) is {\n        Some(denominator) -> Some(Rational { numerator, denominator })\n        None -> None\n      }\n    None -> None\n  }\n}\n\ntest geometric_mean1() {\n  expect Some(x) = new(1, 2)\n  expect Some(y) = new(1, 2)\n  geometric_mean(x, y) == new(1, 2)\n}\n\ntest geometric_mean2() {\n  expect Some(x) = new(-1, 2)\n  expect Some(y) = new(1, 2)\n  geometric_mean(x, y) == None\n}\n\ntest geometric_mean3() {\n  expect Some(x) = new(1, 2)\n  expect Some(y) = new(-1, 2)\n  geometric_mean(x, y) == None\n}\n\ntest geometric_mean4() {\n  expect Some(x) = new(1, 3)\n  expect Some(y) = new(1, 6)\n  geometric_mean(x, y) == new(1, 4)\n}\n\ntest geometric_mean5() {\n  expect Some(x) = new(67, 2500)\n  expect Some(y) = new(35331, 1000)\n  expect Some(yi) = reciprocal(y)\n  geometric_mean(x, yi) == new(258, 9398)\n}\n\n// ## Transforming\n\n/// Returns the smallest `Int` not less than a given `Rational`\n///\n/// ```aiken\n/// expect Some(x) = rational.new(2, 3)\n/// rational.ceil(x) == 1\n///\n/// expect Some(y) = rational.new(44, 14)\n/// rational.ceil(y) == 4\n///\n/// expect Some(z) = rational.new(-14, 3)\n/// rational.ceil(z) == -4\n/// ```\npub fn ceil(self: Rational) -> Int {\n  let Rational { numerator, denominator } = self\n  if builtin.remainder_integer(numerator, denominator) > 0 {\n    builtin.quotient_integer(numerator, denominator) + 1\n  } else {\n    builtin.quotient_integer(numerator, denominator)\n  }\n}\n\ntest ceil_1() {\n  and {\n    (ceil(ratio(13, 5)) == 3)?,\n    (ceil(ratio(15, 5)) == 3)?,\n    (ceil(ratio(16, 5)) == 4)?,\n    (ceil(ratio(-3, 5)) == 0)?,\n    (ceil(ratio(-5, 5)) == -1)?,\n    (ceil(ratio(-14, 3)) == -4)?,\n    (ceil(ratio(-14, 6)) == -2)?,\n    (ceil(ratio(44, 14)) == 4)?,\n  }\n}\n\n/// Returns the greatest `Int` no greater than a given `Rational`\n///\n/// ```aiken\n/// expect Some(x) = rational.new(2, 3)\n/// rational.floor(x) == 0\n///\n/// expect Some(y) = rational.new(44, 14)\n/// rational.floor(y) == 3\n///\n/// expect Some(z) = rational.new(-14, 3)\n/// rational.floor(z) == -5\n/// ```\npub fn floor(self: Rational) -> Int {\n  let Rational { numerator: a_n, denominator: a_d } = self\n  a_n / a_d\n}\n\ntest floor_1() {\n  and {\n    (floor(ratio(5, 2)) == 2)?,\n    (floor(ratio(5, 3)) == 1)?,\n    (floor(ratio(5, 4)) == 1)?,\n    (floor(ratio(5, 5)) == 1)?,\n    (floor(ratio(5, 6)) == 0)?,\n    (floor(ratio(8, 3)) == 2)?,\n    (floor(ratio(-14, 3)) == -5)?,\n  }\n}\n\n/// Computes the rational number x raised to the power y. Returns `None` for\n/// invalid exponentiation.\n///\n/// ```aiken\n/// expect Some(x) = rational.new(50, 2500)\n/// rational.reduce(rational.pow(x, 3)) == rational.new(1, 125000)\n///\n/// expect Some(x) = rational.new(50, 2500)\n/// rational.reduce(rational.pow(x, -3)) == rational.new(125000, 1)\n/// ```\npub fn pow(x: Rational, y: Int) -> Option<Rational> {\n  let Rational { numerator: a, denominator: b } = x\n\n  if a == 0 && y <= 0 {\n    None\n  } else if y > 0 {\n    Some(Rational { numerator: math.pow(a, y), denominator: math.pow(b, y) })\n  } else if y < 0 {\n    Some(Rational { numerator: math.pow(b, -y), denominator: math.pow(a, -y) })\n  } else {\n    Some(Rational { numerator: 1, denominator: 1 })\n  }\n}\n\ntest pow_negative_exponent_non_zero_fraction() {\n  expect Some(base) = new(50, 2500)\n  expect Some(calculated_result) = pow(base, -3)\n  expect Some(expected_result) = new(125000, 1)\n  reduce(calculated_result) == expected_result\n}\n\ntest pow_positive_exponent() {\n  expect Some(base) = new(50, 2500)\n  expect Some(calculated_result) = pow(base, 3)\n  expect Some(expected_result) = new(1, 125000)\n  reduce(calculated_result) == expected_result\n}\n\ntest pow_exponent_zero() {\n  expect Some(base) = new(50, 2500)\n  pow(base, 0) == new(1, 1)\n}\n\ntest pow_rational_zero_exponent_zero() {\n  expect Some(base) = new(0, 1)\n  pow(base, 0) == None\n}\n\n/// Returns the proper fraction of a given `Rational` `r`. That is, a 2-tuple of\n/// an `Int` and `Rational` (n, f) such that:\n///\n/// - `r = n + f`;\n/// - `n` and `f` have the same sign as `r`;\n/// - `f` has an absolute value less than 1.\npub fn proper_fraction(self: Rational) -> (Int, Rational) {\n  let Rational { numerator, denominator } = self\n  (\n    builtin.quotient_integer(numerator, denominator),\n    Rational {\n      numerator: builtin.remainder_integer(numerator, denominator),\n      denominator,\n    },\n  )\n}\n\ntest proper_fraction_1() {\n  let r = ratio(10, 7)\n  let (n, f) = proper_fraction(r)\n  and {\n    (n == 1)?,\n    (f == ratio(3, 7))?,\n    (r == add(from_int(n), f))?,\n  }\n}\n\ntest proper_fraction_2() {\n  let r = ratio(-10, 7)\n  let (n, f) = proper_fraction(r)\n  and {\n    (n == -1)?,\n    (f == ratio(-3, 7))?,\n    (r == add(from_int(n), f))?,\n  }\n}\n\ntest proper_fraction_3() {\n  let r = ratio(4, 2)\n  let (n, f) = proper_fraction(r)\n  and {\n    (n == 2)?,\n    (f == ratio(0, 2))?,\n    (r == add(from_int(n), f))?,\n  }\n}\n\n/// Round the argument to the nearest whole number. If the argument is\n/// equidistant between two values, the greater value is returned (it\n/// rounds half towards positive infinity).\n///\n/// ```aiken\n/// expect Some(x) = rational.new(2, 3)\n/// rational.round(x) == 1\n///\n/// expect Some(y) = rational.new(3, 2)\n/// rational.round(y) == 2\n///\n/// expect Some(z) = rational.new(-3, 2)\n/// rational.round(z) == -1\n/// ```\n///\n/// > [!CAUTION]\n/// > This behaves differently than _Haskell_. If you're coming from `PlutusTx`, beware that in Haskell, rounding on equidistant values depends on the whole number being odd or even.\n/// > If you need this behaviour, use [`round_even`](#round_even).\npub fn round(self: Rational) -> Int {\n  let (n, f) = proper_fraction(self)\n\n  let is_negative = f.numerator < 0\n\n  when compare(abs(f), ratio(1, 2)) is {\n    Less -> n\n    Equal ->\n      if is_negative {\n        n\n      } else {\n        n + 1\n      }\n    Greater ->\n      if is_negative {\n        n - 1\n      } else {\n        n + 1\n      }\n  }\n}\n\ntest round_1() {\n  and {\n    (round(ratio(10, 7)) == 1)?,\n    (round(ratio(11, 7)) == 2)?,\n    (round(ratio(3, 2)) == 2)?,\n    (round(ratio(5, 2)) == 3)?,\n    (round(ratio(-3, 2)) == -1)?,\n    (round(ratio(-2, 3)) == -1)?,\n    (round(ratio(-10, 7)) == -1)?,\n    (round(ratio(4, 2)) == 2)?,\n  }\n}\n\n/// Round the argument to the nearest whole number. If the argument is\n/// equidistant between two values, it returns the value that is even (it\n/// rounds half to even, also known as 'banker's rounding').\n///\n/// ```aiken\n/// expect Some(w) = rational.new(2, 3)\n/// rational.round_even(w) == 1\n///\n/// expect Some(x) = rational.new(3, 2)\n/// rational.round_even(x) == 2\n///\n/// expect Some(y) = rational.new(5, 2)\n/// rational.round_even(y) == 2\n///\n/// expect Some(y) = rational.new(-3, 2)\n/// rational.round_even(y) == -2\n/// ```\npub fn round_even(self: Rational) -> Int {\n  let (n, f) = proper_fraction(self)\n\n  let m =\n    when compare(f, ratio(0, 1)) is {\n      Less -> -1\n      _ -> 1\n    }\n\n  let is_even = n % 2 == 0\n\n  when compare(abs(f), ratio(1, 2)) is {\n    Less -> n\n    Equal ->\n      if is_even {\n        n\n      } else {\n        n + m\n      }\n    Greater -> n + m\n  }\n}\n\ntest round_even_1() {\n  and {\n    (round_even(ratio(10, 7)) == 1)?,\n    (round_even(ratio(11, 7)) == 2)?,\n    (round_even(ratio(3, 2)) == 2)?,\n    (round_even(ratio(5, 2)) == 2)?,\n    (round_even(ratio(-3, 2)) == -2)?,\n    (round_even(ratio(-2, 3)) == -1)?,\n    (round_even(ratio(-10, 7)) == -1)?,\n    (round_even(ratio(4, 2)) == 2)?,\n  }\n}\n\n/// Returns the nearest `Int` between zero and a given `Rational`.\n///\n/// ```aiken\n/// expect Some(x) = rational.new(2, 3)\n/// rational.truncate(x) == 0\n///\n/// expect Some(y) = rational.new(44, 14)\n/// rational.truncate(y) == 3\n///\n/// expect Some(z) = rational.new(-14, 3)\n/// rational.truncate(z) == -4\n/// ```\npub fn truncate(self: Rational) -> Int {\n  let Rational { numerator: a_n, denominator: a_d } = self\n  builtin.quotient_integer(a_n, a_d)\n}\n\ntest truncate_1() {\n  and {\n    (truncate(ratio(5, 2)) == 2)?,\n    (truncate(ratio(5, 3)) == 1)?,\n    (truncate(ratio(5, 4)) == 1)?,\n    (truncate(ratio(5, 5)) == 1)?,\n    (truncate(ratio(5, 6)) == 0)?,\n    (truncate(ratio(8, 3)) == 2)?,\n    (truncate(ratio(-14, 3)) == -4)?,\n  }\n}\n",
      "dependencies": [
        "aiken/builtin",
        "aiken/collection/list",
        "aiken/math",
        "aiken/option"
      ],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.math.rational.tests",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/math/rational.tests.ak",
      "name": "aiken.math.rational.tests",
      "imports": [
        {
          "module": "aiken/fuzz",
          "items": ["both", "either", "map"],
          "line": 1,
          "raw": "use aiken/fuzz.{both, either, map}",
          "source": "stdlib"
        },
        {
          "module": "aiken/math/rational",
          "items": ["Rational", "new", "pow"],
          "line": 2,
          "raw": "use aiken/math/rational.{Rational, new, pow}",
          "source": "stdlib"
        }
      ],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/fuzz.{both, either, map}\nuse aiken/math/rational.{Rational, new, pow}\n\nconst any_positive_rational: Fuzzer<Rational> =\n  either(\n    map(\n      both(fuzz.int_at_least(1), fuzz.int_at_least(1)),\n      fn((num, den)) {\n        expect Some(new_fraction) = new(num, den)\n        new_fraction\n      },\n    ),\n    map(\n      both(fuzz.int_at_most(-1), fuzz.int_at_most(-1)),\n      fn((num, den)) {\n        expect Some(new_fraction) = new(num, den)\n        new_fraction\n      },\n    ),\n  )\n\nconst any_negative_rational: Fuzzer<Rational> =\n  either(\n    map(\n      both(fuzz.int_at_most(-1), fuzz.int_at_least(1)),\n      fn((num, den)) {\n        expect Some(new_fraction) = new(num, den)\n        new_fraction\n      },\n    ),\n    map(\n      both(fuzz.int_at_least(1), fuzz.int_at_most(-1)),\n      fn((num, den)) {\n        expect Some(new_fraction) = new(num, den)\n        new_fraction\n      },\n    ),\n  )\n\nconst any_non_zero_rational: Fuzzer<Rational> =\n  either(any_negative_rational, any_positive_rational)\n\ntest prop_power_of_zero_returns_one(rational via any_non_zero_rational) {\n  expect Some(calculated_result) = pow(rational, 0)\n  expect Some(expected_result) = new(1, 1)\n  calculated_result == expected_result\n}\n\ntest prop_power_of_one_returns_same_fraction(rational via any_non_zero_rational) {\n  expect Some(calculated_result) = pow(rational, 1)\n  calculated_result == rational\n}\n\ntest prop_power_numerator_zero_exponent_negative_returns_none(\n  (denominator, exponent) via both(fuzz.int_at_least(1), fuzz.int_at_most(-1)),\n) {\n  expect Some(fraction) = new(0, denominator)\n  expect None = pow(fraction, exponent)\n}\n\ntest prop_power_unit_fraction_is_immutable(exponent via fuzz.int()) {\n  expect Some(unit) = new(1, 1)\n  expect Some(calculated_result) = pow(unit, exponent)\n  calculated_result == unit\n}\n",
      "dependencies": ["aiken/fuzz", "aiken/math/rational"],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.math",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/math.ak",
      "name": "aiken.math",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 21,
          "raw": "use aiken/builtin",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "abs",
          "signature": "pub fn abs(self: Int) -> Int {",
          "documentation": "Calculate the absolute value of an integer.\n\n```aiken\nmath.abs(-42) == 42\nmath.abs(14) == 14\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 29,
          "raw": "pub fn abs(self: Int) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn abs(self: Int) -> Int {\n  if self < 0 {\n    0 - self\n  } else {\n    self\n  }\n}",
          "tests": [
            "test abs_1() {\n  abs(14) == 14\n}",
            "test abs_2() {\n  abs(-42) == 42\n}"
          ]
        },
        {
          "name": "clamp",
          "signature": "pub fn clamp(self: Int, min: Int, max: Int) -> Int {",
          "documentation": "Restrict the value of an integer between two min and max bounds\n\n```aiken\nmath.clamp(14, min: 0, max: 10) == 10\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Int",
              "optional": false
            },
            {
              "name": "min",
              "type": "Int",
              "optional": false
            },
            {
              "name": "max",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 50,
          "raw": "pub fn clamp(self: Int, min: Int, max: Int) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn clamp(self: Int, min: Int, max: Int) -> Int {\n  if self < min {\n    min\n  } else {\n    if self > max {\n      max\n    } else {\n      self\n    }\n  }\n}",
          "tests": [
            "test clamp_1() {\n  clamp(14, min: 0, max: 10) == 10\n}",
            "test clamp_2() {\n  clamp(7, min: 0, max: 10) == 7\n}",
            "test clamp_3() {\n  clamp(7, min: 10, max: 100) == 10\n}"
          ]
        },
        {
          "name": "gcd",
          "signature": "pub fn gcd(x: Int, y: Int) -> Int {",
          "documentation": "The greatest common divisor of two integers.\n\n```aiken\nmath.gcd(42, 14) == 14\nmath.gcd(14, 42) == 14\nmath.gcd(0, 0) == 0\n```",
          "parameters": [
            {
              "name": "x",
              "type": "Int",
              "optional": false
            },
            {
              "name": "y",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 81,
          "raw": "pub fn gcd(x: Int, y: Int) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn gcd(x: Int, y: Int) -> Int {\n  abs(do_gcd(x, y))\n}"
        },
        {
          "name": "is_sqrt",
          "signature": "pub fn is_sqrt(self: Int, x: Int) -> Bool {",
          "documentation": "Checks if an integer has a given integer square root x.\nThe check has constant time complexity $O(1)$.\n\n```aiken\nmath.is_sqrt(0, 0)\nmath.is_sqrt(25, 5)\n!math.is_sqrt(25, -5)\nmath.is_sqrt(44203, 210)\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Int",
              "optional": false
            },
            {
              "name": "x",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 113,
          "raw": "pub fn is_sqrt(self: Int, x: Int) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn is_sqrt(self: Int, x: Int) -> Bool {\n  x * x <= self && ( x + 1 ) * ( x + 1 ) > self\n}",
          "tests": [
            "test is_sqrt1() {\n  is_sqrt(44203, 210)\n}",
            "test is_sqrt2() {\n  is_sqrt(975461057789971041, 987654321)\n}"
          ]
        },
        {
          "name": "log",
          "signature": "pub fn log(self: Int, base: Int) -> Int {",
          "documentation": "The logarithm in base `b` of an element using integer divisions.\n\n```aiken\nmath.log(10, base: 2) == 3\nmath.log(42, base: 2) == 5\nmath.log(42, base: 3) == 3\nmath.log(5, base: 0) == 0\nmath.log(4, base: 4) == 1\nmath.log(4, base: 42) == 0\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Int",
              "optional": false
            },
            {
              "name": "base",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 135,
          "raw": "pub fn log(self: Int, base: Int) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn log(self: Int, base: Int) -> Int {\n  if base <= 0 {\n    0\n  } else if self == base {\n    1\n  } else if self < base {\n    0\n  } else {\n    1 + log(self / base, base)\n  }\n}",
          "tests": [
            "test log_10_2() {\n  log(10, base: 2) == 3\n}",
            "test log_42_2() {\n  log(42, base: 2) == 5\n}",
            "test log_42_3() {\n  log(42, base: 3) == 3\n}",
            "test log_5_0() {\n  log(5, base: 0) == 0\n}",
            "test log_4_4() {\n  log(4, base: 4) == 1\n}",
            "test log_4_43() {\n  log(4, base: 43) == 0\n}"
          ]
        },
        {
          "name": "log2",
          "signature": "pub fn log2(x: Int) -> Int {",
          "documentation": "The integer logarithm in base 2. Faster than [`log`](#log) in this particular case.\n\n```aiken\nmath.log2(1) == 0\nmath.log2(2) == 1\nmath.log2(3) == 1\nmath.log2(4) == 2\nmath.log2(256) == 8\nmath.log2(257) == 8\nmath.log2(511) == 8\nmath.log2(1025) == 10\n```",
          "parameters": [
            {
              "name": "x",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 183,
          "raw": "pub fn log2(x: Int) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn log2(x: Int) -> Int {\n  expect x > 0\n  let s = builtin.integer_to_bytearray(True, 0, x)\n  let len = builtin.length_of_bytearray(s)\n  let b = builtin.index_bytearray(s, 0)\n  len * 8 - if b < 2 {\n    8\n  } else if b < 4 {\n    7\n  } else if b < 8 {\n    6\n  } else if b < 16 {\n    5\n  } else if b < 32 {\n    4\n  } else if b < 64 {\n    3\n  } else if b < 128 {\n    2\n  } else {\n    1\n  }\n}",
          "tests": [
            "test log2_matrix() {\n  and {\n    log2(1) == 0,\n    log2(2) == 1,\n    log2(3) == 1,\n    log2(4) == 2,\n    log2(256) == 8,\n    log2(257) == 8,\n    log2(511) == 8,\n    log2(1025) == 10,\n  }\n}"
          ]
        },
        {
          "name": "max",
          "signature": "pub fn max(a: Int, b: Int) -> Int {",
          "documentation": "Return the maximum of two integers.",
          "parameters": [
            {
              "name": "a",
              "type": "Int",
              "optional": false
            },
            {
              "name": "b",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 221,
          "raw": "pub fn max(a: Int, b: Int) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn max(a: Int, b: Int) -> Int {\n  if a > b {\n    a\n  } else {\n    b\n  }\n}",
          "tests": [
            "test max_1() {\n  max(0, 0) == 0\n}",
            "test max_2() {\n  max(14, 42) == 42\n}",
            "test max_3() {\n  max(42, 14) == 42\n}"
          ]
        },
        {
          "name": "min",
          "signature": "pub fn min(a: Int, b: Int) -> Int {",
          "documentation": "Return the minimum of two integers.",
          "parameters": [
            {
              "name": "a",
              "type": "Int",
              "optional": false
            },
            {
              "name": "b",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 242,
          "raw": "pub fn min(a: Int, b: Int) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn min(a: Int, b: Int) -> Int {\n  if a > b {\n    b\n  } else {\n    a\n  }\n}",
          "tests": [
            "test min_1() {\n  min(0, 0) == 0\n}",
            "test min_2() {\n  min(14, 42) == 14\n}",
            "test min_3() {\n  min(42, 14) == 14\n}"
          ]
        },
        {
          "name": "pow",
          "signature": "pub fn pow(self: Int, e: Int) -> Int {",
          "documentation": "Calculates a number to the power of `e` using the exponentiation by\nsquaring method.\n\n```aiken\nmath.pow(3, 5) == 243\nmath.pow(7, 2) == 49\nmath.pow(3, -4) == 0\nmath.pow(0, 0) == 1\nmath.pow(513, 3) == 135005697\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Int",
              "optional": false
            },
            {
              "name": "e",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 272,
          "raw": "pub fn pow(self: Int, e: Int) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn pow(self: Int, e: Int) -> Int {\n  if e < 0 {\n    0\n  } else if e == 0 {\n    1\n  } else if e % 2 == 0 {\n    pow(self * self, e / 2)\n  } else {\n    self * pow(self * self, ( e - 1 ) / 2)\n  }\n}",
          "tests": [
            "test pow_3_5() {\n  pow(3, 5) == 243\n}",
            "test pow_7_2() {\n  pow(7, 2) == 49\n}",
            "test pow_3__4() {\n  // negative powers round to zero\n  pow(3, -4) == 0\n}",
            "test pow_0_0() {\n  // sorry math\n  pow(0, 0) == 1\n}",
            "test pow_513_3() {\n  pow(513, 3) == 135005697\n}",
            "test pow_2_4() {\n  pow(2, 4) == 16\n}",
            "test pow_2_42() {\n  pow(2, 42) == 4398046511104\n}"
          ]
        },
        {
          "name": "pow2",
          "signature": "pub fn pow2(e: Int) -> Int {",
          "documentation": "Calculates the power of 2 for a given exponent `e`. Much cheaper than\nusing `pow(2, _)` for small exponents $0 < e < 256$.\n\n```aiken\nmath.pow2(-2) == 0\nmath.pow2(0) == 1\nmath.pow2(1) == 2\nmath.pow2(4) == 16\nmath.pow2(42) == 4398046511104\n```",
          "parameters": [
            {
              "name": "e",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 324,
          "raw": "pub fn pow2(e: Int) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn pow2(e: Int) -> Int {\n  // do_pow2(e, 1)\n  if e < 8 {\n    if e < 0 {\n      0\n    } else {\n      builtin.index_bytearray(#[1, 2, 4, 8, 16, 32, 64, 128], e)\n    }\n  } else if e < 32 {\n    256 * pow2(e - 8)\n  } else {\n    4294967296 * pow2(e - 32)\n  }\n}",
          "tests": [
            "test pow2_neg() {\n  pow2(-2) == 0\n}",
            "test pow2_0() {\n  pow2(0) == 1\n}",
            "test pow2_1() {\n  pow2(1) == 2\n}",
            "test pow2_4() {\n  pow2(4) == 16\n}",
            "test pow2_42() {\n  pow2(42) == 4398046511104\n}",
            "test pow2_256() {\n  pow2(256) == 115792089237316195423570985008687907853269984665640564039457584007913129639936\n}"
          ]
        },
        {
          "name": "sqrt",
          "signature": "pub fn sqrt(self: Int) -> Option<Int> {",
          "documentation": "Calculates the square root of an integer using the [Babylonian\nmethod](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method). This returns either the exact result or the smallest integer\nnearest to the square root.\n\nReturns `None` for negative values.\n\n```aiken\nmath.sqrt(0) == Some(0)\nmath.sqrt(25) == Some(5)\nmath.sqrt(44203) == Some(210)\nmath.sqrt(-42) == None\n```\n\n> [!TIP]\n> This function can be quite expensive to perform on-chain. Prefer using [`is_sqrt`](#is_sqrt) whenever possible.",
          "parameters": [
            {
              "name": "self",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Option<Int>",
          "line": 378,
          "raw": "pub fn sqrt(self: Int) -> Option<Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn sqrt(self: Int) -> Option<Int> {\n  if self < 0 {\n    None\n  } else if self <= 1 {\n    Some(self)\n  } else {\n    Some(sqrt_babylonian(self, self, ( self + 1 ) / 2))\n  }\n}"
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [
        {
          "name": "do_gcd",
          "signature": "fn do_gcd(x: Int, y: Int) -> Int {",
          "parameters": [
            {
              "name": "x",
              "type": "Int",
              "optional": false
            },
            {
              "name": "y",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 85,
          "raw": "fn do_gcd(x: Int, y: Int) -> Int {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_gcd(x: Int, y: Int) -> Int {\n  when y is {\n    0 -> x\n    _ -> do_gcd(y, x % y)\n  }\n}"
        },
        {
          "name": "sqrt_babylonian",
          "signature": "fn sqrt_babylonian(self: Int, x: Int, y: Int) -> Int {",
          "parameters": [
            {
              "name": "self",
              "type": "Int",
              "optional": false
            },
            {
              "name": "x",
              "type": "Int",
              "optional": false
            },
            {
              "name": "y",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 394,
          "raw": "fn sqrt_babylonian(self: Int, x: Int, y: Int) -> Int {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn sqrt_babylonian(self: Int, x: Int, y: Int) -> Int {\n  if y >= x {\n    x\n  } else {\n    sqrt_babylonian(self, y, ( y + self / y ) / 2)\n  }\n}"
        }
      ],
      "privateTypes": [],
      "privateConstants": [],
      "content": "//// This module contains some basic Math utilities. Standard arithmetic\n//// operations on integers are available through native operators:\n////\n//// Operator | Description\n//// ---      | :---\n//// `+`      | Arithmetic sum\n//// `-`      | Arithmetic difference\n//// `/`      | Whole division\n//// `*`      | Arithmetic multiplication\n//// `%`      | Remainder by whole division\n////\n//// Here are a few examples:\n////\n//// ```aiken\n//// 1 + 1   // 2\n//// 10 - 2  // 8\n//// 40 / 14 // 2\n//// 3 * 4   // 12\n//// 10 % 3  // 1\n\nuse aiken/builtin\n\n/// Calculate the absolute value of an integer.\n///\n/// ```aiken\n/// math.abs(-42) == 42\n/// math.abs(14) == 14\n/// ```\npub fn abs(self: Int) -> Int {\n  if self < 0 {\n    0 - self\n  } else {\n    self\n  }\n}\n\ntest abs_1() {\n  abs(14) == 14\n}\n\ntest abs_2() {\n  abs(-42) == 42\n}\n\n/// Restrict the value of an integer between two min and max bounds\n///\n/// ```aiken\n/// math.clamp(14, min: 0, max: 10) == 10\n/// ```\npub fn clamp(self: Int, min: Int, max: Int) -> Int {\n  if self < min {\n    min\n  } else {\n    if self > max {\n      max\n    } else {\n      self\n    }\n  }\n}\n\ntest clamp_1() {\n  clamp(14, min: 0, max: 10) == 10\n}\n\ntest clamp_2() {\n  clamp(7, min: 0, max: 10) == 7\n}\n\ntest clamp_3() {\n  clamp(7, min: 10, max: 100) == 10\n}\n\n/// The greatest common divisor of two integers.\n///\n/// ```aiken\n/// math.gcd(42, 14) == 14\n/// math.gcd(14, 42) == 14\n/// math.gcd(0, 0) == 0\n/// ```\npub fn gcd(x: Int, y: Int) -> Int {\n  abs(do_gcd(x, y))\n}\n\nfn do_gcd(x: Int, y: Int) -> Int {\n  when y is {\n    0 -> x\n    _ -> do_gcd(y, x % y)\n  }\n}\n\ntest gcd_test1() {\n  gcd(10, 300) == 10\n}\n\ntest gcd_test2() {\n  gcd(-10, 300) == 10\n}\n\ntest gcd_test3() {\n  gcd(42, 14) == 14\n}\n\n/// Checks if an integer has a given integer square root x.\n/// The check has constant time complexity $O(1)$.\n///\n/// ```aiken\n/// math.is_sqrt(0, 0)\n/// math.is_sqrt(25, 5)\n/// !math.is_sqrt(25, -5)\n/// math.is_sqrt(44203, 210)\n/// ```\npub fn is_sqrt(self: Int, x: Int) -> Bool {\n  x * x <= self && ( x + 1 ) * ( x + 1 ) > self\n}\n\ntest is_sqrt1() {\n  is_sqrt(44203, 210)\n}\n\ntest is_sqrt2() {\n  is_sqrt(975461057789971041, 987654321)\n}\n\n/// The logarithm in base `b` of an element using integer divisions.\n///\n/// ```aiken\n/// math.log(10, base: 2) == 3\n/// math.log(42, base: 2) == 5\n/// math.log(42, base: 3) == 3\n/// math.log(5, base: 0) == 0\n/// math.log(4, base: 4) == 1\n/// math.log(4, base: 42) == 0\n/// ```\npub fn log(self: Int, base: Int) -> Int {\n  if base <= 0 {\n    0\n  } else if self == base {\n    1\n  } else if self < base {\n    0\n  } else {\n    1 + log(self / base, base)\n  }\n}\n\ntest log_10_2() {\n  log(10, base: 2) == 3\n}\n\ntest log_42_2() {\n  log(42, base: 2) == 5\n}\n\ntest log_42_3() {\n  log(42, base: 3) == 3\n}\n\ntest log_5_0() {\n  log(5, base: 0) == 0\n}\n\ntest log_4_4() {\n  log(4, base: 4) == 1\n}\n\ntest log_4_43() {\n  log(4, base: 43) == 0\n}\n\n/// The integer logarithm in base 2. Faster than [`log`](#log) in this particular case.\n///\n/// ```aiken\n/// math.log2(1) == 0\n/// math.log2(2) == 1\n/// math.log2(3) == 1\n/// math.log2(4) == 2\n/// math.log2(256) == 8\n/// math.log2(257) == 8\n/// math.log2(511) == 8\n/// math.log2(1025) == 10\n/// ```\npub fn log2(x: Int) -> Int {\n  expect x > 0\n  let s = builtin.integer_to_bytearray(True, 0, x)\n  let len = builtin.length_of_bytearray(s)\n  let b = builtin.index_bytearray(s, 0)\n  len * 8 - if b < 2 {\n    8\n  } else if b < 4 {\n    7\n  } else if b < 8 {\n    6\n  } else if b < 16 {\n    5\n  } else if b < 32 {\n    4\n  } else if b < 64 {\n    3\n  } else if b < 128 {\n    2\n  } else {\n    1\n  }\n}\n\ntest log2_matrix() {\n  and {\n    log2(1) == 0,\n    log2(2) == 1,\n    log2(3) == 1,\n    log2(4) == 2,\n    log2(256) == 8,\n    log2(257) == 8,\n    log2(511) == 8,\n    log2(1025) == 10,\n  }\n}\n\n/// Return the maximum of two integers.\npub fn max(a: Int, b: Int) -> Int {\n  if a > b {\n    a\n  } else {\n    b\n  }\n}\n\ntest max_1() {\n  max(0, 0) == 0\n}\n\ntest max_2() {\n  max(14, 42) == 42\n}\n\ntest max_3() {\n  max(42, 14) == 42\n}\n\n/// Return the minimum of two integers.\npub fn min(a: Int, b: Int) -> Int {\n  if a > b {\n    b\n  } else {\n    a\n  }\n}\n\ntest min_1() {\n  min(0, 0) == 0\n}\n\ntest min_2() {\n  min(14, 42) == 14\n}\n\ntest min_3() {\n  min(42, 14) == 14\n}\n\n/// Calculates a number to the power of `e` using the exponentiation by\n/// squaring method.\n///\n/// ```aiken\n/// math.pow(3, 5) == 243\n/// math.pow(7, 2) == 49\n/// math.pow(3, -4) == 0\n/// math.pow(0, 0) == 1\n/// math.pow(513, 3) == 135005697\n/// ```\npub fn pow(self: Int, e: Int) -> Int {\n  if e < 0 {\n    0\n  } else if e == 0 {\n    1\n  } else if e % 2 == 0 {\n    pow(self * self, e / 2)\n  } else {\n    self * pow(self * self, ( e - 1 ) / 2)\n  }\n}\n\ntest pow_3_5() {\n  pow(3, 5) == 243\n}\n\ntest pow_7_2() {\n  pow(7, 2) == 49\n}\n\ntest pow_3__4() {\n  // negative powers round to zero\n  pow(3, -4) == 0\n}\n\ntest pow_0_0() {\n  // sorry math\n  pow(0, 0) == 1\n}\n\ntest pow_513_3() {\n  pow(513, 3) == 135005697\n}\n\ntest pow_2_4() {\n  pow(2, 4) == 16\n}\n\ntest pow_2_42() {\n  pow(2, 42) == 4398046511104\n}\n\n/// Calculates the power of 2 for a given exponent `e`. Much cheaper than\n/// using `pow(2, _)` for small exponents $0 < e < 256$.\n///\n/// ```aiken\n/// math.pow2(-2) == 0\n/// math.pow2(0) == 1\n/// math.pow2(1) == 2\n/// math.pow2(4) == 16\n/// math.pow2(42) == 4398046511104\n/// ```\npub fn pow2(e: Int) -> Int {\n  // do_pow2(e, 1)\n  if e < 8 {\n    if e < 0 {\n      0\n    } else {\n      builtin.index_bytearray(#[1, 2, 4, 8, 16, 32, 64, 128], e)\n    }\n  } else if e < 32 {\n    256 * pow2(e - 8)\n  } else {\n    4294967296 * pow2(e - 32)\n  }\n}\n\ntest pow2_neg() {\n  pow2(-2) == 0\n}\n\ntest pow2_0() {\n  pow2(0) == 1\n}\n\ntest pow2_1() {\n  pow2(1) == 2\n}\n\ntest pow2_4() {\n  pow2(4) == 16\n}\n\ntest pow2_42() {\n  pow2(42) == 4398046511104\n}\n\ntest pow2_256() {\n  pow2(256) == 115792089237316195423570985008687907853269984665640564039457584007913129639936\n}\n\n/// Calculates the square root of an integer using the [Babylonian\n/// method](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method). This returns either the exact result or the smallest integer\n/// nearest to the square root.\n///\n/// Returns `None` for negative values.\n///\n/// ```aiken\n/// math.sqrt(0) == Some(0)\n/// math.sqrt(25) == Some(5)\n/// math.sqrt(44203) == Some(210)\n/// math.sqrt(-42) == None\n/// ```\n///\n/// > [!TIP]\n/// > This function can be quite expensive to perform on-chain. Prefer using [`is_sqrt`](#is_sqrt) whenever possible.\npub fn sqrt(self: Int) -> Option<Int> {\n  if self < 0 {\n    None\n  } else if self <= 1 {\n    Some(self)\n  } else {\n    Some(sqrt_babylonian(self, self, ( self + 1 ) / 2))\n  }\n}\n\n// The basic idea is that if x is an overestimate to the square root of a\n// non-negative real number S then S/x will be an underestimate, or vice versa,\n// and so the average of these two numbers may reasonably be expected to provide a\n// better approximation (though the formal proof of that assertion depends on the\n// inequality of arithmetic and geometric means that shows this average is always\n// an overestimate of the square root.\nfn sqrt_babylonian(self: Int, x: Int, y: Int) -> Int {\n  if y >= x {\n    x\n  } else {\n    sqrt_babylonian(self, y, ( y + self / y ) / 2)\n  }\n}\n\ntest sqrt1() {\n  sqrt(0) == Some(0)\n}\n\ntest sqrt2() {\n  sqrt(1) == Some(1)\n}\n\ntest sqrt3() {\n  sqrt(25) == Some(5)\n}\n\ntest sqrt4() {\n  sqrt(44203) == Some(210)\n}\n\ntest sqrt5() {\n  sqrt(975461057789971041) == Some(987654321)\n}\n\ntest sqrt6() {\n  sqrt(-42) == None\n}\n",
      "dependencies": ["aiken/builtin"],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.option",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/option.ak",
      "name": "aiken.option",
      "imports": [],
      "functions": [
        {
          "name": "is_none",
          "signature": "pub fn is_none(self: Option<a>) -> Bool {",
          "documentation": "Asserts whether an option is `None`.",
          "parameters": [
            {
              "name": "self",
              "type": "Option<a>",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 8,
          "raw": "pub fn is_none(self: Option<a>) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn is_none(self: Option<a>) -> Bool {\n  when self is {\n    Some(_) -> False\n    _ -> True\n  }\n}",
          "tests": [
            "test is_none_1() {\n  is_none(Some(0)) == False\n}",
            "test is_none_2() {\n  is_none(None) == True\n}"
          ]
        },
        {
          "name": "is_some",
          "signature": "pub fn is_some(self: Option<a>) -> Bool {",
          "documentation": "Asserts whether an option is `Some`, irrespective of the value it contains.",
          "parameters": [
            {
              "name": "self",
              "type": "Option<a>",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 24,
          "raw": "pub fn is_some(self: Option<a>) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn is_some(self: Option<a>) -> Bool {\n  when self is {\n    Some(_) -> True\n    _ -> False\n  }\n}",
          "tests": [
            "test is_some_1() {\n  is_some(Some(0)) == True\n}",
            "test is_some_2() {\n  is_some(None) == False\n}"
          ]
        },
        {
          "name": "and_then",
          "signature": "pub fn and_then(pub fn and_then(self: Option<a>, then: fn(a) -> Option<result>,",
          "documentation": "Chain together many computations that may fail.\n\n```aiken\nself\n|> dict.get(policy_id)\n|> option.and_then(dict.get(_, asset_name))\n|> option.or_else(0)\n```",
          "parameters": [],
          "returnType": "Option<result>,",
          "line": 49,
          "raw": "pub fn and_then(pub fn and_then(self: Option<a>, then: fn(a) -> Option<result>,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn and_then(\n  self: Option<a>,\n  then: fn(a) -> Option<result>,\n) -> Option<result> {\n  when self is {\n    None -> None\n    Some(a) -> then(a)\n  }\n}"
        },
        {
          "name": "choice",
          "signature": "pub fn choice(self: List<Option<a>>) -> Option<a> {",
          "documentation": "Picks the first element which is not None. If there's no such element, return None.\n\n```aiken\noption.choice([]) == None\noption.choice([Some(14), Some(42)]) == Some(14)\noption.choice([None, Some(42)]) == Some(42)\noption.choice([None, None]) == None\n```",
          "parameters": [
            {
              "name": "self",
              "type": "List<Option<a>>",
              "optional": false
            }
          ],
          "returnType": "Option<a>",
          "line": 96,
          "raw": "pub fn choice(self: List<Option<a>>) -> Option<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn choice(self: List<Option<a>>) -> Option<a> {\n  when self is {\n    [] -> None\n    [head, ..others] ->\n      when head is {\n        None -> choice(others)\n        _ -> head\n      }\n  }\n}",
          "tests": [
            "test choice_1() {\n  Some(1) == choice([Some(1), Some(2)])\n}",
            "test choice_2() {\n  None == choice([])\n}",
            "test choice_3() {\n  Some(1) == choice([None, Some(1)])\n}"
          ]
        },
        {
          "name": "flatten",
          "signature": "pub fn flatten(opt: Option<Option<a>>) -> Option<a> {",
          "documentation": "Converts from `Option<Option<a>>` to `Option<a>`.\n\n```aiken\noption.flatten(Some(Some(42))) == Some(42)\noption.flatten(Some(None)) == None\noption.flatten(None) == None\n```\n\nFlattening only removes one level of nesting at a time:\n\n```aiken\nflatten(Some(Some(Some(42)))) == Some(Some(42))\nSome(Some(Some(42))) |> flatten |> flatten == Some(42)\n```",
          "parameters": [
            {
              "name": "opt",
              "type": "Option<Option<a>>",
              "optional": false
            }
          ],
          "returnType": "Option<a>",
          "line": 133,
          "raw": "pub fn flatten(opt: Option<Option<a>>) -> Option<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn flatten(opt: Option<Option<a>>) -> Option<a> {\n  when opt is {\n    Some(inner) -> inner\n    None -> None\n  }\n}",
          "tests": [
            "test flatten_1() {\n  let x: Option<Option<Int>> = Some(Some(6))\n  Some(6) == flatten(x)\n}",
            "test flatten_2() {\n  let x: Option<Option<Int>> = Some(None)\n  None == flatten(x)\n}",
            "test flatten_3() {\n  let x: Option<Option<Int>> = None\n  None == flatten(x)\n}",
            "test flatten_4() {\n  let x: Option<Option<Option<Int>>> = Some(Some(Some(6)))\n\n  let result =\n    x\n      |> flatten\n      |> flatten\n\n  Some(6) == result\n}"
          ]
        },
        {
          "name": "map",
          "signature": "pub fn map(self: Option<a>, with: fn(a) -> result) -> Option<result> {",
          "documentation": "Apply a function to the inner value of an [`Option`](#option)\n\n```aiken\noption.map(None, fn(n) { n * 2 }) == None\noption.map(Some(14), fn(n) { n * 2 }) == Some(28)\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Option<a>",
              "optional": false
            },
            {
              "name": "with",
              "type": "fn(a",
              "optional": false
            }
          ],
          "returnType": "result) -> Option<result>",
          "line": 172,
          "raw": "pub fn map(self: Option<a>, with: fn(a) -> result) -> Option<result> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn map(self: Option<a>, with: fn(a) -> result) -> Option<result> {\n  when self is {\n    None -> None\n    Some(a) -> Some(with(a))\n  }\n}",
          "tests": [
            "test map_1() {\n  map(None, fn(_) { Void }) == None\n}",
            "test map_2() {\n  map(Some(14), fn(n) { n + 1 }) == Some(15)\n}"
          ]
        },
        {
          "name": "map2",
          "signature": "pub fn map2(pub fn map2(opt_a: Option<a>, opt_b: Option<b>, with: fn(a, b) -> result,",
          "documentation": "Combine two [`Option`](#option) together.\n\n```aiken\ntype Foo {\nFoo(Int, Int)\n}\n\noption.map2(Some(14), Some(42), Foo) == Some(Foo(14, 42))\noption.map2(None, Some(42), Foo) == None\noption.map2(Some(14), None, Foo) == None\n```",
          "parameters": [],
          "returnType": "result,",
          "line": 198,
          "raw": "pub fn map2(pub fn map2(opt_a: Option<a>, opt_b: Option<b>, with: fn(a, b) -> result,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn map2(\n  opt_a: Option<a>,\n  opt_b: Option<b>,\n  with: fn(a, b) -> result,\n) -> Option<result> {\n  when opt_a is {\n    None -> None\n    Some(a) ->\n      when opt_b is {\n        None -> None\n        Some(b) -> Some(with(a, b))\n      }\n  }\n}",
          "tests": [
            "test map2_1() {\n  map2(None, Some(42), fn(_, _) { 14 }) == None\n}",
            "test map2_2() {\n  map2(Some(42), None, fn(_, _) { 14 }) == None\n}",
            "test map2_3() {\n  map2(Some(14), Some(42), fn(a, b) { (a, b) }) == Some((14, 42))\n}"
          ]
        },
        {
          "name": "map3",
          "signature": "pub fn map3(pub fn map3(opt_a: Option<a>, opt_b: Option<b>, opt_c: Option<c>, with: fn(a, b, c) -> result,",
          "documentation": "Combine three [`Option`](#option) together.\n\n```aiken\ntype Foo {\nFoo(Int, Int, Int)\n}\n\noption.map3(Some(14), Some(42), Some(1337), Foo) == Some(Foo(14, 42, 1337))\noption.map3(None, Some(42), Some(1337), Foo) == None\noption.map3(Some(14), None, None, Foo) == None\n```",
          "parameters": [],
          "returnType": "result,",
          "line": 236,
          "raw": "pub fn map3(pub fn map3(opt_a: Option<a>, opt_b: Option<b>, opt_c: Option<c>, with: fn(a, b, c) -> result,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn map3(\n  opt_a: Option<a>,\n  opt_b: Option<b>,\n  opt_c: Option<c>,\n  with: fn(a, b, c) -> result,\n) -> Option<result> {\n  when opt_a is {\n    None -> None\n    Some(a) ->\n      when opt_b is {\n        None -> None\n        Some(b) ->\n          when opt_c is {\n            None -> None\n            Some(c) -> Some(with(a, b, c))\n          }\n      }\n  }\n}",
          "tests": [
            "test map3_1() {\n  map3(None, Some(42), None, fn(_, _, _) { 14 }) == None\n}",
            "test map3_2() {\n  map3(Some(42), None, None, fn(_, _, _) { 14 }) == None\n}",
            "test map3_3() {\n  map3(Some(14), Some(42), Some(1337), fn(a, b, c) { c - a + b }) == Some(1365)\n}"
          ]
        },
        {
          "name": "or_try",
          "signature": "pub fn or_try(self: Option<a>, compute_default: fn() -> Option<a>) -> Option<a> {",
          "documentation": "Like [`or_else`](#or_else) but allows returning an `Option`.\nThis is effectively mapping the error branch.\n\n```aiken\noption.or_try(None, fn(_) { Some(\"aiken\") }) == Some(\"aiken\")\noption.or_try(Some(42), fn(_) { Some(14) }) == Some(42)\noption.or_try(None, fn (_) { fail }) => 💥\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Option<a>",
              "optional": false
            },
            {
              "name": "compute_default",
              "type": "fn(",
              "optional": false
            }
          ],
          "returnType": "Option<a>) -> Option<a>",
          "line": 276,
          "raw": "pub fn or_try(self: Option<a>, compute_default: fn() -> Option<a>) -> Option<a> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn or_try(self: Option<a>, compute_default: fn() -> Option<a>) -> Option<a> {\n  when self is {\n    None -> compute_default()\n    _ -> self\n  }\n}",
          "tests": [
            "test or_try_1() {\n  or_try(None, fn() { Some(\"aiken\") }) == Some(\"aiken\")\n}",
            "test or_try_2() {\n  or_try(Some(42), fn() { fail }) == Some(42)\n}"
          ]
        },
        {
          "name": "or_else",
          "signature": "pub fn or_else(self: Option<a>, default: a) -> a {",
          "documentation": "Provide a default value, turning an optional value into a normal value.\n\n```aiken\noption.or_else(None, \"aiken\") == \"aiken\"\noption.or_else(Some(42), 14) == 42\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Option<a>",
              "optional": false
            },
            {
              "name": "default",
              "type": "a",
              "optional": false
            }
          ],
          "returnType": "a",
          "line": 299,
          "raw": "pub fn or_else(self: Option<a>, default: a) -> a {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn or_else(self: Option<a>, default: a) -> a {\n  when self is {\n    None -> default\n    Some(a) -> a\n  }\n}",
          "tests": [
            "test or_else_1() {\n  or_else(None, \"aiken\") == \"aiken\"\n}",
            "test or_else_2() {\n  or_else(Some(42), 14) == 42\n}"
          ]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [
        {
          "name": "try_decrement",
          "signature": "fn try_decrement(n: Int) -> Option<Int> {",
          "parameters": [
            {
              "name": "n",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Option<Int>",
          "line": 59,
          "raw": "fn try_decrement(n: Int) -> Option<Int> {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn try_decrement(n: Int) -> Option<Int> {\n  if n > 0 {\n    Some(n - 1)\n  } else {\n    None\n  }\n}"
        }
      ],
      "privateTypes": [],
      "privateConstants": [],
      "content": "//// A type to capture optional results; useful for handling errors.\n////\n//// Note that the `Option` type and its constructors are readily available in Aiken. They are part of the [Prelude](https://aiken-lang.github.io/prelude/aiken.html#Option) module imported by default in every module.\n\n// ## Inspecting\n\n/// Asserts whether an option is `None`.\npub fn is_none(self: Option<a>) -> Bool {\n  when self is {\n    Some(_) -> False\n    _ -> True\n  }\n}\n\ntest is_none_1() {\n  is_none(Some(0)) == False\n}\n\ntest is_none_2() {\n  is_none(None) == True\n}\n\n/// Asserts whether an option is `Some`, irrespective of the value it contains.\npub fn is_some(self: Option<a>) -> Bool {\n  when self is {\n    Some(_) -> True\n    _ -> False\n  }\n}\n\ntest is_some_1() {\n  is_some(Some(0)) == True\n}\n\ntest is_some_2() {\n  is_some(None) == False\n}\n\n// ## Combining\n\n/// Chain together many computations that may fail.\n///\n/// ```aiken\n/// self\n///   |> dict.get(policy_id)\n///   |> option.and_then(dict.get(_, asset_name))\n///   |> option.or_else(0)\n/// ```\npub fn and_then(\n  self: Option<a>,\n  then: fn(a) -> Option<result>,\n) -> Option<result> {\n  when self is {\n    None -> None\n    Some(a) -> then(a)\n  }\n}\n\nfn try_decrement(n: Int) -> Option<Int> {\n  if n > 0 {\n    Some(n - 1)\n  } else {\n    None\n  }\n}\n\ntest and_then_1() {\n  let result =\n    None\n      |> and_then(try_decrement)\n  result == None\n}\n\ntest and_then_2() {\n  let result =\n    Some(14)\n      |> and_then(try_decrement)\n  result == Some(13)\n}\n\ntest and_then_3() {\n  let result =\n    Some(0)\n      |> and_then(try_decrement)\n  result == None\n}\n\n/// Picks the first element which is not None. If there's no such element, return None.\n///\n/// ```aiken\n/// option.choice([]) == None\n/// option.choice([Some(14), Some(42)]) == Some(14)\n/// option.choice([None, Some(42)]) == Some(42)\n/// option.choice([None, None]) == None\n/// ```\npub fn choice(self: List<Option<a>>) -> Option<a> {\n  when self is {\n    [] -> None\n    [head, ..others] ->\n      when head is {\n        None -> choice(others)\n        _ -> head\n      }\n  }\n}\n\ntest choice_1() {\n  Some(1) == choice([Some(1), Some(2)])\n}\n\ntest choice_2() {\n  None == choice([])\n}\n\ntest choice_3() {\n  Some(1) == choice([None, Some(1)])\n}\n\n/// Converts from `Option<Option<a>>` to `Option<a>`.\n///\n/// ```aiken\n/// option.flatten(Some(Some(42))) == Some(42)\n/// option.flatten(Some(None)) == None\n/// option.flatten(None) == None\n/// ```\n///\n/// Flattening only removes one level of nesting at a time:\n///\n/// ```aiken\n/// flatten(Some(Some(Some(42)))) == Some(Some(42))\n/// Some(Some(Some(42))) |> flatten |> flatten == Some(42)\n/// ```\npub fn flatten(opt: Option<Option<a>>) -> Option<a> {\n  when opt is {\n    Some(inner) -> inner\n    None -> None\n  }\n}\n\ntest flatten_1() {\n  let x: Option<Option<Int>> = Some(Some(6))\n  Some(6) == flatten(x)\n}\n\ntest flatten_2() {\n  let x: Option<Option<Int>> = Some(None)\n  None == flatten(x)\n}\n\ntest flatten_3() {\n  let x: Option<Option<Int>> = None\n  None == flatten(x)\n}\n\ntest flatten_4() {\n  let x: Option<Option<Option<Int>>> = Some(Some(Some(6)))\n\n  let result =\n    x\n      |> flatten\n      |> flatten\n\n  Some(6) == result\n}\n\n/// Apply a function to the inner value of an [`Option`](#option)\n///\n/// ```aiken\n/// option.map(None, fn(n) { n * 2 }) == None\n/// option.map(Some(14), fn(n) { n * 2 }) == Some(28)\n/// ```\npub fn map(self: Option<a>, with: fn(a) -> result) -> Option<result> {\n  when self is {\n    None -> None\n    Some(a) -> Some(with(a))\n  }\n}\n\ntest map_1() {\n  map(None, fn(_) { Void }) == None\n}\n\ntest map_2() {\n  map(Some(14), fn(n) { n + 1 }) == Some(15)\n}\n\n/// Combine two [`Option`](#option) together.\n///\n/// ```aiken\n/// type Foo {\n///   Foo(Int, Int)\n/// }\n///\n/// option.map2(Some(14), Some(42), Foo) == Some(Foo(14, 42))\n/// option.map2(None, Some(42), Foo) == None\n/// option.map2(Some(14), None, Foo) == None\n/// ```\npub fn map2(\n  opt_a: Option<a>,\n  opt_b: Option<b>,\n  with: fn(a, b) -> result,\n) -> Option<result> {\n  when opt_a is {\n    None -> None\n    Some(a) ->\n      when opt_b is {\n        None -> None\n        Some(b) -> Some(with(a, b))\n      }\n  }\n}\n\ntest map2_1() {\n  map2(None, Some(42), fn(_, _) { 14 }) == None\n}\n\ntest map2_2() {\n  map2(Some(42), None, fn(_, _) { 14 }) == None\n}\n\ntest map2_3() {\n  map2(Some(14), Some(42), fn(a, b) { (a, b) }) == Some((14, 42))\n}\n\n/// Combine three [`Option`](#option) together.\n///\n/// ```aiken\n/// type Foo {\n///   Foo(Int, Int, Int)\n/// }\n///\n/// option.map3(Some(14), Some(42), Some(1337), Foo) == Some(Foo(14, 42, 1337))\n/// option.map3(None, Some(42), Some(1337), Foo) == None\n/// option.map3(Some(14), None, None, Foo) == None\n/// ```\npub fn map3(\n  opt_a: Option<a>,\n  opt_b: Option<b>,\n  opt_c: Option<c>,\n  with: fn(a, b, c) -> result,\n) -> Option<result> {\n  when opt_a is {\n    None -> None\n    Some(a) ->\n      when opt_b is {\n        None -> None\n        Some(b) ->\n          when opt_c is {\n            None -> None\n            Some(c) -> Some(with(a, b, c))\n          }\n      }\n  }\n}\n\ntest map3_1() {\n  map3(None, Some(42), None, fn(_, _, _) { 14 }) == None\n}\n\ntest map3_2() {\n  map3(Some(42), None, None, fn(_, _, _) { 14 }) == None\n}\n\ntest map3_3() {\n  map3(Some(14), Some(42), Some(1337), fn(a, b, c) { c - a + b }) == Some(1365)\n}\n\n/// Like [`or_else`](#or_else) but allows returning an `Option`.\n/// This is effectively mapping the error branch.\n///\n/// ```aiken\n/// option.or_try(None, fn(_) { Some(\"aiken\") }) == Some(\"aiken\")\n/// option.or_try(Some(42), fn(_) { Some(14) }) == Some(42)\n/// option.or_try(None, fn (_) { fail }) => 💥\n/// ```\npub fn or_try(self: Option<a>, compute_default: fn() -> Option<a>) -> Option<a> {\n  when self is {\n    None -> compute_default()\n    _ -> self\n  }\n}\n\ntest or_try_1() {\n  or_try(None, fn() { Some(\"aiken\") }) == Some(\"aiken\")\n}\n\ntest or_try_2() {\n  or_try(Some(42), fn() { fail }) == Some(42)\n}\n\n// ## Transforming\n\n/// Provide a default value, turning an optional value into a normal value.\n///\n/// ```aiken\n/// option.or_else(None, \"aiken\") == \"aiken\"\n/// option.or_else(Some(42), 14) == 42\n/// ```\npub fn or_else(self: Option<a>, default: a) -> a {\n  when self is {\n    None -> default\n    Some(a) -> a\n  }\n}\n\ntest or_else_1() {\n  or_else(None, \"aiken\") == \"aiken\"\n}\n\ntest or_else_2() {\n  or_else(Some(42), 14) == 42\n}\n",
      "dependencies": [],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.primitive.bytearray",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/primitive/bytearray.ak",
      "name": "aiken.primitive.bytearray",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 1,
          "raw": "use aiken/builtin",
          "source": "stdlib"
        },
        {
          "module": "aiken/math",
          "items": [],
          "line": 2,
          "raw": "use aiken/math",
          "source": "stdlib"
        },
        {
          "module": "aiken/option",
          "items": [],
          "line": 3,
          "raw": "use aiken/option",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "from_int_big_endian",
          "signature": "pub fn from_int_big_endian(self: Int, size: Int) -> ByteArray {",
          "documentation": "Encode an integer value as a Big-Endian (most-significant bytes first) `ByteArray`.\nThe size is the expected size in number of bytes.\n\n> [!IMPORTANT]\n> This function fails (i.e. halts the program) if the value cannot fit in the given size. When the\n> size is _too large_, the array is left-padded with zeroes.\n\n```aiken\nbytearray.from_int_big_endian(1_000_000, 3) == #\"0f4240\"\nbytearray.from_int_big_endian(1_000_000, 5) == #\"00000f4240\"\nbytearray.from_int_big_endian(0, 8) == #\"0000000000000000\"\nbytearray.from_int_big_endian(1_000_000, 1) => 💥\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Int",
              "optional": false
            },
            {
              "name": "size",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 23,
          "raw": "pub fn from_int_big_endian(self: Int, size: Int) -> ByteArray {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_int_big_endian(self: Int, size: Int) -> ByteArray {\n  builtin.integer_to_bytearray(True, size, self)\n}",
          "tests": [
            "test from_int_big_endian_1() {\n  from_int_big_endian(1_000_000, 3) == #\"0f4240\"\n}",
            "test from_int_big_endian_2() {\n  from_int_big_endian(1_000_000, 5) == #\"00000f4240\"\n}",
            "test from_int_big_endian_3() {\n  from_int_big_endian(0, 8) == #\"0000000000000000\"\n}",
            "test from_int_big_endian_4() fail {\n  from_int_big_endian(1_000_000, 1) == #\"40\"\n}"
          ]
        },
        {
          "name": "from_int_little_endian",
          "signature": "pub fn from_int_little_endian(self: Int, size: Int) -> ByteArray {",
          "documentation": "Encode an integer value as a Little-Endian (least-significant bytes first) `ByteArray`.\nThe size is the expected size in number of bytes.\n\n> [!IMPORTANT]\n> This function fails (i.e. halts the program) if the value cannot fit in the given size. When the\n> size is _too large_, the array is right-padded with zeroes.\n\n```aiken\nbytearray.from_int_little_endian(1_000_000, 3) == #\"40420f\"\nbytearray.from_int_little_endian(1_000_000, 5) == #\"40420f0000\"\nbytearray.from_int_little_endian(0, 8) == #\"0000000000000000\"\nbytearray.from_int_little_endian(1_000_000, 1) => 💥\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Int",
              "optional": false
            },
            {
              "name": "size",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 56,
          "raw": "pub fn from_int_little_endian(self: Int, size: Int) -> ByteArray {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_int_little_endian(self: Int, size: Int) -> ByteArray {\n  builtin.integer_to_bytearray(False, size, self)\n}",
          "tests": [
            "test from_int_little_endian_1() {\n  from_int_little_endian(1_000_000, 3) == #\"40420f\"\n}",
            "test from_int_little_endian_2() {\n  from_int_little_endian(1_000_000, 5) == #\"40420f0000\"\n}",
            "test from_int_little_endian_3() {\n  from_int_little_endian(0, 8) == #\"0000000000000000\"\n}",
            "test from_int_little_endian_4() fail {\n  from_int_little_endian(1_000_000, 1) == #\"40\"\n}"
          ]
        },
        {
          "name": "from_string",
          "signature": "pub fn from_string(str: String) -> ByteArray {",
          "documentation": "Convert a `String` into a `ByteArray`.\n\n```aiken\nbytearray.from_string(@\"ABC\") == #\"414243\"\n```",
          "parameters": [
            {
              "name": "str",
              "type": "String",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 81,
          "raw": "pub fn from_string(str: String) -> ByteArray {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_string(str: String) -> ByteArray {\n  builtin.encode_utf8(str)\n}",
          "tests": [
            "test from_string_1() {\n  from_string(@\"\") == \"\"\n}",
            "test from_string_2() {\n  from_string(@\"ABC\") == #\"414243\"\n}"
          ]
        },
        {
          "name": "push",
          "signature": "pub fn push(self: ByteArray, byte: Byte) -> ByteArray {",
          "documentation": "Add a byte element in front of a `ByteArray`. When the given byte is\ngreater than 255, it wraps-around. **PlutusV2 behavior** So 256 is mapped to 0, 257 to 1, and so\nforth.\nIn PlutusV3 this will error instead of wrapping around.\n\n```aiken\nbytearray.push(#\"\", 0) == #\"00\"\nbytearray.push(#\"0203\", 1) == #\"010203\"\nbytearray.push(#\"0203\", 257) == #\"010203\"\n```",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "byte",
              "type": "Byte",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 103,
          "raw": "pub fn push(self: ByteArray, byte: Byte) -> ByteArray {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn push(self: ByteArray, byte: Byte) -> ByteArray {\n  builtin.cons_bytearray(byte, self)\n}",
          "tests": [
            "test push_1() {\n  push(#[], 0) == #[0]\n}",
            "test push_2() {\n  push(#[2, 3], 1) == #[1, 2, 3]\n}",
            "test push_3() fail {\n  let x = 257\n  push(#[2, 3], x) == #[1, 2, 3]\n}"
          ]
        },
        {
          "name": "at",
          "signature": "pub fn at(self: ByteArray, index: Int) -> Byte {",
          "documentation": "Get the `Byte` at the given index, or crash.\n\n> [!WARNING]\n> This functions fails (i.e. halts the program) if there's no byte at the given index.",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "index",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Byte",
          "line": 126,
          "raw": "pub fn at(self: ByteArray, index: Int) -> Byte {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn at(self: ByteArray, index: Int) -> Byte {\n  builtin.index_bytearray(self, index)\n}"
        },
        {
          "name": "index_of",
          "signature": "pub fn index_of(self: ByteArray, bytes: ByteArray) -> Option<(Int, Int)> {",
          "documentation": "Search the start and end positions of a sub-array in a `ByteArray`.\n\n```aiken\nbytearray.index_of(\"Hello, World!\", \"World\") == Some((7, 11))\nbytearray.index_of(\"Hello, World!\", \"foo\") == None\nbytearray.index_of(\"Hello, World!\", \"!\") == Some((12, 12))\nbytearray.index_of(\"Hello, World!\", \"o\") == Some((4, 4))\nbytearray.index_of(\"Hello, World!\", \"Hello, World!\") == Some((0, 12))\n```",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Option<(Int, Int)>",
          "line": 139,
          "raw": "pub fn index_of(self: ByteArray, bytes: ByteArray) -> Option<(Int, Int)> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn index_of(self: ByteArray, bytes: ByteArray) -> Option<(Int, Int)> {\n  let offset = length(bytes)\n\n  do_index_of(self, bytes, 0, offset, length(self))\n    |> option.map(fn(ix) { (ix, ix + offset - 1) })\n}"
        },
        {
          "name": "is_empty",
          "signature": "pub fn is_empty(self: ByteArray) -> Bool {",
          "documentation": "Returns `True` when the given `ByteArray` is empty.\n\n```aiken\nbytearray.is_empty(#\"\") == True\nbytearray.is_empty(#\"00ff\") == False\n```",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 190,
          "raw": "pub fn is_empty(self: ByteArray) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn is_empty(self: ByteArray) -> Bool {\n  builtin.length_of_bytearray(self) == 0\n}",
          "tests": [
            "test is_empty_1() {\n  is_empty(#\"\") == True\n}",
            "test is_empty_2() {\n  is_empty(#\"01\") == False\n}"
          ]
        },
        {
          "name": "length",
          "signature": "pub fn length(self: ByteArray) -> Int {",
          "documentation": "Returns the number of bytes in a `ByteArray`.\n\n```aiken\nbytearray.length(#[1, 2, 3]) == 3\n```",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 207,
          "raw": "pub fn length(self: ByteArray) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn length(self: ByteArray) -> Int {\n  builtin.length_of_bytearray(self)\n}",
          "tests": [
            "test length_1() {\n  length(#\"\") == 0\n}",
            "test length_2() {\n  length(#\"010203\") == 3\n}"
          ]
        },
        {
          "name": "test_bit",
          "signature": "pub fn test_bit(self: ByteArray, ix: Int) -> Bool {",
          "documentation": "Checks whether a bit (Most-Significant-Bit first) is set in the given 'ByteArray'.\n\nFor example, consider the following bytearray: `#\"8b765f\"`. It can also be written as the\nfollowing bits sequence:\n\n`8`    | `b`    | `7`    | `6`    | `5`    | `f`\n---    | ---    | ---    | ---    | ---    | ---\n`1000` | `1011` | `0111` | `0110` | `0101` | `1111`\n\nAnd thus, we have:\n\n```aiken\ntest_bit(#\"8b765f\", 0) == True\ntest_bit(#\"8b765f\", 1) == False\ntest_bit(#\"8b765f\", 2) == False\ntest_bit(#\"8b765f\", 3) == False\ntest_bit(#\"8b765f\", 7) == True\ntest_bit(#\"8b765f\", 8) == False\ntest_bit(#\"8b765f\", 20) == True\ntest_bit(#\"8b765f\", 21) == True\ntest_bit(#\"8b765f\", 22) == True\ntest_bit(#\"8b765f\", 23) == True\n```",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "ix",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 242,
          "raw": "pub fn test_bit(self: ByteArray, ix: Int) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn test_bit(self: ByteArray, ix: Int) -> Bool {\n  builtin.less_than_equals_bytearray(\n    #[128],\n    builtin.cons_bytearray(\n      builtin.index_bytearray(self, ix / 8) * math.pow2(ix % 8) % 256,\n      \"\",\n    ),\n  )\n}",
          "tests": [
            "test test_bit_0() {\n  test_bit(#\"8b765f\", 0)\n}",
            "test test_bit_1() {\n  !test_bit(#\"8b765f\", 1)\n}",
            "test test_bit_2() {\n  !test_bit(#\"8b765f\", 2)\n}",
            "test test_bit_3() {\n  !test_bit(#\"8b765f\", 3)\n}",
            "test test_bit_7() {\n  test_bit(#\"8b765f\", 7)\n}",
            "test test_bit_8() {\n  !test_bit(#\"8b765f\", 8)\n}",
            "test test_bit_20_21_22_23() {\n  and {\n    test_bit(#\"8b765f\", 20),\n    test_bit(#\"8b765f\", 21),\n    test_bit(#\"8b765f\", 22),\n    test_bit(#\"8b765f\", 23),\n  }\n}"
          ]
        },
        {
          "name": "drop",
          "signature": "pub fn drop(self: ByteArray, n: Int) -> ByteArray {",
          "documentation": "Returns the suffix of a `ByteArray` after `n` elements.\n\n```aiken\nbytearray.drop(#[1, 2, 3], n: 2) == #[3]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "n",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 292,
          "raw": "pub fn drop(self: ByteArray, n: Int) -> ByteArray {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn drop(self: ByteArray, n: Int) -> ByteArray {\n  builtin.slice_bytearray(n, builtin.length_of_bytearray(self) - n, self)\n}",
          "tests": [
            "test drop_1() {\n  let x = #\"01020304050607\"\n  drop(x, 2) == #\"0304050607\"\n}",
            "test drop_2() {\n  let x = #\"01020304050607\"\n  drop(x, 0) == x\n}",
            "test drop_3() {\n  let x = #\"01\"\n  drop(x, 1) == #\"\"\n}",
            "test drop_4() {\n  let x = #\"\"\n  drop(x, 2) == #\"\"\n}"
          ]
        },
        {
          "name": "slice",
          "signature": "pub fn slice(self: ByteArray, start: Int, end: Int) -> ByteArray {",
          "documentation": "Extract a `ByteArray` as a slice of another `ByteArray`.\n\nIndexes are 0-based and inclusive.\n\n```aiken\nbytearray.slice(#[0, 1, 2, 3, 4, 5, 6], start: 1, end: 3) == #[1, 2, 3]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "start",
              "type": "Int",
              "optional": false
            },
            {
              "name": "end",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 323,
          "raw": "pub fn slice(self: ByteArray, start: Int, end: Int) -> ByteArray {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn slice(self: ByteArray, start: Int, end: Int) -> ByteArray {\n  builtin.slice_bytearray(start, end - start + 1, self)\n}",
          "tests": [
            "test slice_1() {\n  slice(#\"\", 1, 2) == #\"\"\n}",
            "test slice_2() {\n  slice(#\"010203\", 1, 2) == #\"0203\"\n}",
            "test slice_3() {\n  slice(#\"010203\", 0, 42) == #\"010203\"\n}",
            "test slice_4() {\n  slice(#[0, 1, 2, 3, 4], 0, 3) == #[0, 1, 2, 3]\n}",
            "test slice_5() {\n  slice(#[0, 1, 2, 3, 4], 1, 2) == #[1, 2]\n}"
          ]
        },
        {
          "name": "take",
          "signature": "pub fn take(self: ByteArray, n: Int) -> ByteArray {",
          "documentation": "Returns the n-length prefix of a `ByteArray`.\n\n```aiken\nbytearray.take(#[1, 2, 3], n: 2) == #[1, 2]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "n",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 352,
          "raw": "pub fn take(self: ByteArray, n: Int) -> ByteArray {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn take(self: ByteArray, n: Int) -> ByteArray {\n  builtin.slice_bytearray(0, n, self)\n}",
          "tests": [
            "test take_1() {\n  let x = #\"01020304050607\"\n  take(x, 2) == #\"0102\"\n}",
            "test take_2() {\n  let x = #\"01020304050607\"\n  take(x, 0) == #\"\"\n}",
            "test take_3() {\n  let x = #\"01\"\n  take(x, 1) == x\n}",
            "test take_4() {\n  let x = #\"010203\"\n  take(x, 0) == #\"\"\n}"
          ]
        },
        {
          "name": "concat",
          "signature": "pub fn concat(left: ByteArray, right: ByteArray) -> ByteArray {",
          "documentation": "Combine two `ByteArray` together.\n\n```aiken\nbytearray.concat(left: #[1, 2, 3], right: #[4, 5, 6]) == #[1, 2, 3, 4, 5, 6]\n```",
          "parameters": [
            {
              "name": "left",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "right",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 383,
          "raw": "pub fn concat(left: ByteArray, right: ByteArray) -> ByteArray {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn concat(left: ByteArray, right: ByteArray) -> ByteArray {\n  builtin.append_bytearray(left, right)\n}",
          "tests": [
            "test concat_1() {\n  concat(#\"\", #\"\") == #\"\"\n}",
            "test concat_2() {\n  concat(#\"\", #\"01\") == #\"01\"\n}",
            "test concat_3() {\n  concat(#\"0102\", #\"\") == #\"0102\"\n}",
            "test concat_4() {\n  concat(#\"0102\", #\"0304\") == #\"01020304\"\n}"
          ]
        },
        {
          "name": "compare",
          "signature": "pub fn compare(left: ByteArray, right: ByteArray) -> Ordering {",
          "documentation": "Compare two bytearrays lexicographically.\n\n```aiken\nbytearray.compare(#\"00\", #\"FF\") == Less\nbytearray.compare(#\"42\", #\"42\") == Equal\nbytearray.compare(#\"FF\", #\"00\") == Greater\n```",
          "parameters": [
            {
              "name": "left",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "right",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Ordering",
          "line": 410,
          "raw": "pub fn compare(left: ByteArray, right: ByteArray) -> Ordering {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn compare(left: ByteArray, right: ByteArray) -> Ordering {\n  if builtin.less_than_bytearray(left, right) {\n    Less\n  } else if builtin.equals_bytearray(left, right) {\n    Equal\n  } else {\n    Greater\n  }\n}"
        },
        {
          "name": "foldl",
          "signature": "pub fn foldl(pub fn foldl(self: ByteArray, zero: result, with: fn(Int, result) -> result,",
          "documentation": "Left-fold over bytes of a [`ByteArray`](https://aiken-lang.github.io/prelude/aiken.html#ByteArray). Note that every byte given to the callback function is comprised between 0 and 255.\n\n```aiken\nbytearray.foldl(#\"acab\", 0, fn(byte, acc) { acc * 256 + byte }) == 44203\nbytearray.foldl(#[1, 2, 3], #\"\", flip(bytearray.push)) == #[3, 2, 1]\n```",
          "parameters": [],
          "returnType": "result,",
          "line": 428,
          "raw": "pub fn foldl(pub fn foldl(self: ByteArray, zero: result, with: fn(Int, result) -> result,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn foldl(\n  self: ByteArray,\n  zero: result,\n  with: fn(Int, result) -> result,\n) -> result {\n  do_foldl(self, zero, builtin.length_of_bytearray(self), 0, with)\n}"
        },
        {
          "name": "foldr",
          "signature": "pub fn foldr(pub fn foldr(self: ByteArray, zero: result, with: fn(Int, result) -> result,",
          "documentation": "Right-fold over bytes of a [`ByteArray`](https://aiken-lang.github.io/prelude/aiken.html#ByteArray). Note that every byte given to the callback function is comprised between 0 and 255.\n\n```aiken\nbytearray.foldr(#\"acab\", 0, fn(byte, acc) { acc * 256 + byte }) == 43948\nbytearray.foldl(#[1, 2, 3], #\"\", flip(bytearray.push)) == #[1, 2, 3]\n```",
          "parameters": [],
          "returnType": "result,",
          "line": 482,
          "raw": "pub fn foldr(pub fn foldr(self: ByteArray, zero: result, with: fn(Int, result) -> result,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn foldr(\n  self: ByteArray,\n  zero: result,\n  with: fn(Int, result) -> result,\n) -> result {\n  do_foldr(self, zero, builtin.length_of_bytearray(self) - 1, with)\n}"
        },
        {
          "name": "reduce",
          "signature": "pub fn reduce(pub fn reduce(self: ByteArray, zero: result, with: fn(result, Int) -> result,",
          "documentation": "Reduce bytes in a ByteArray from left to right using the accumulator as left operand.\nSaid differently, this is [`foldl`](#foldl) with callback arguments swapped.\n\n```aiken\nbytearray.reduce(#[1,2,3], #[], bytearray.push) == #[3, 2, 1]\n```",
          "parameters": [],
          "returnType": "result,",
          "line": 526,
          "raw": "pub fn reduce(pub fn reduce(self: ByteArray, zero: result, with: fn(result, Int) -> result,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn reduce(\n  self: ByteArray,\n  zero: result,\n  with: fn(result, Int) -> result,\n) -> result {\n  foldl(self, zero, flip(with))\n}",
          "tests": [
            "test reduce_1() {\n  reduce(#[], #[], push) == #[]\n}",
            "test reduce_2() {\n  reduce(#[1, 2, 3], #[], push) == #[3, 2, 1]\n}"
          ]
        },
        {
          "name": "to_int_big_endian",
          "signature": "pub fn to_int_big_endian(self: ByteArray) -> Int {",
          "documentation": "Interpret a Big-Endian (most-significant bytes first) `ByteArray` as an `Int`.\n\n```aiken\nbytearray.to_int_big_endian(#\"0f4240\") == 1_000_000\nbytearray.to_int_big_endian(#\"00000f4240\") == 1_000_000\nbytearray.to_int_big_endian(#\"0000000000000000\") == 0\n```",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 549,
          "raw": "pub fn to_int_big_endian(self: ByteArray) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn to_int_big_endian(self: ByteArray) -> Int {\n  builtin.bytearray_to_integer(True, self)\n}",
          "tests": [
            "test to_int_big_endian_1() {\n  to_int_big_endian(#\"0f4240\") == 1_000_000\n}",
            "test to_int_big_endian_2() {\n  to_int_big_endian(#\"00000f4240\") == 1_000_000\n}",
            "test to_int_big_endian_3() {\n  to_int_big_endian(#\"0000000000000000\") == 0\n}"
          ]
        },
        {
          "name": "to_int_little_endian",
          "signature": "pub fn to_int_little_endian(self: ByteArray) -> Int {",
          "documentation": "Interpret a Little-Endian (least-significant bytes first) `ByteArray` as an `Int`.\n\n```aiken\nbytearray.to_int_big_endian(#\"40420f\") == 1_000_000\nbytearray.to_int_big_endian(#\"40420f0000\") == 1_000_000\nbytearray.to_int_big_endian(#\"0000000000000000\") == 0\n```",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 572,
          "raw": "pub fn to_int_little_endian(self: ByteArray) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn to_int_little_endian(self: ByteArray) -> Int {\n  builtin.bytearray_to_integer(False, self)\n}",
          "tests": [
            "test to_int_little_endian_1() {\n  to_int_little_endian(#\"40420f\") == 1_000_000\n}",
            "test to_int_little_endian_2() {\n  to_int_little_endian(#\"40420f0000\") == 1_000_000\n}",
            "test to_int_little_endian_3() {\n  to_int_little_endian(#\"0000000000000000\") == 0\n}"
          ]
        },
        {
          "name": "to_string",
          "signature": "pub fn to_string(self: ByteArray) -> String {",
          "documentation": "Convert a `ByteArray` into a `String`.\n\n> [!WARNING]\n> This functions fails (i.e. halts the program) if the underlying `ByteArray` isn't UTF-8-encoded. In particular, you cannot convert arbitrary hash digests using this function.\n>\n> For converting arbitrary `ByteArray`s, use [bytearray.to_hex](#to_hex).\n\n```aiken\nbytearray.to_string(#\"414243\") == \"ABC\"\nbytearray.to_string(some_hash) => 💥\n```",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "String",
          "line": 599,
          "raw": "pub fn to_string(self: ByteArray) -> String {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn to_string(self: ByteArray) -> String {\n  builtin.decode_utf8(self)\n}",
          "tests": [
            "test to_string_1() {\n  to_string(\"\") == @\"\"\n}",
            "test to_string_2() {\n  to_string(\"ABC\") == @\"ABC\"\n}"
          ]
        },
        {
          "name": "to_hex",
          "signature": "pub fn to_hex(self: ByteArray) -> String {",
          "documentation": "Encode a `ByteArray` as a hexidecimal `String`.\n\n```aiken\nbytearray.to_hex(\"Hello world!\") == @\"48656c6c6f20776f726c6421\"\n```",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "String",
          "line": 616,
          "raw": "pub fn to_hex(self: ByteArray) -> String {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn to_hex(self: ByteArray) -> String {\n  self\n    |> encode_base16(builtin.length_of_bytearray(self) - 1, \"\")\n    |> builtin.decode_utf8\n}",
          "tests": [
            "test to_hex_1() {\n  to_hex(\"Hello world!\") == @\"48656C6C6F20776F726C6421\"\n}",
            "test to_hex_2() {\n  to_hex(\"The quick brown fox jumps over the lazy dog\") == @\"54686520717569636B2062726F776E20666F78206A756D7073206F76657220746865206C617A7920646F67\"\n}"
          ]
        },
        {
          "name": "starts_with",
          "signature": "pub fn starts_with(self: ByteArray, prefix: ByteArray) -> Bool {",
          "documentation": "Checks whether a `ByteArray` starts with a given prefix.\n\n```aiken\nbytearray.starts_with(\"Hello, World!\", prefix: \"Hello\") == True\nbytearray.starts_with(\"\", prefix: \"\") == True\nbytearray.starts_with(\"Hello\", prefix: \"Hello, World!\") == False\n```",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "prefix",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 637,
          "raw": "pub fn starts_with(self: ByteArray, prefix: ByteArray) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn starts_with(self: ByteArray, prefix: ByteArray) -> Bool {\n  let prefix_length = length(prefix)\n  if length(self) < prefix_length {\n    False\n  } else {\n    take(self, prefix_length) == prefix\n  }\n}",
          "tests": [
            "test starts_with_1() {\n  starts_with(\"\", \"\")\n}",
            "test starts_with_2() {\n  starts_with(\"Hello, World!\", \"Hello, World!\")\n}",
            "test starts_with_3() {\n  !starts_with(\"Hello, World!\", \"hello\")\n}",
            "test starts_with_4() {\n  !starts_with(\"\", \"World\")\n}",
            "test starts_with_5() {\n  starts_with(\"Hello, World\", \"Hello\")\n}",
            "test starts_with_6() {\n  !starts_with(\"foo\", \"foo_\")\n}"
          ]
        },
        {
          "name": "and_bytes",
          "signature": "pub fn and_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {",
          "parameters": [
            {
              "name": "left",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "right",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "pad_end",
              "type": "Bool",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 670,
          "raw": "pub fn and_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn and_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {\n  builtin.and_bytearray(pad_end, left, right)\n}"
        },
        {
          "name": "or_bytes",
          "signature": "pub fn or_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {",
          "parameters": [
            {
              "name": "left",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "right",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "pad_end",
              "type": "Bool",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 674,
          "raw": "pub fn or_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn or_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {\n  builtin.or_bytearray(pad_end, left, right)\n}"
        },
        {
          "name": "xor_bytes",
          "signature": "pub fn xor_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {",
          "parameters": [
            {
              "name": "left",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "right",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "pad_end",
              "type": "Bool",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 678,
          "raw": "pub fn xor_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn xor_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {\n  builtin.xor_bytearray(pad_end, left, right)\n}"
        }
      ],
      "types": [
        {
          "name": "Byte",
          "definition": "Int",
          "line": 5,
          "raw": "pub type Byte =",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "constants": [],
      "atoms": [
        {
          "name": "do_index_of",
          "signature": "fn do_index_of(fn do_index_of(self: ByteArray, bytes: ByteArray, cursor: Int, offset: Int, size: Int, ) -> Option<Int> {",
          "parameters": [],
          "returnType": "Option<Int>",
          "line": 146,
          "raw": "fn do_index_of(fn do_index_of(self: ByteArray, bytes: ByteArray, cursor: Int, offset: Int, size: Int, ) -> Option<Int> {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_index_of(\n  self: ByteArray,\n  bytes: ByteArray,\n  cursor: Int,\n  offset: Int,\n  size: Int,\n) -> Option<Int> {\n  if cursor + offset > size {\n    None\n  } else {\n    if builtin.slice_bytearray(cursor, offset, self) == bytes {\n      Some(cursor)\n    } else {\n      do_index_of(self, bytes, cursor + 1, offset, size)\n    }\n  }\n}"
        },
        {
          "name": "do_foldl",
          "signature": "fn do_foldl(fn do_foldl(self: ByteArray, zero: result, len: Int, cursor: Int, with: fn(Int, result) -> result,",
          "parameters": [],
          "returnType": "result,",
          "line": 436,
          "raw": "fn do_foldl(fn do_foldl(self: ByteArray, zero: result, len: Int, cursor: Int, with: fn(Int, result) -> result,",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_foldl(\n  self: ByteArray,\n  zero: result,\n  len: Int,\n  cursor: Int,\n  with: fn(Int, result) -> result,\n) -> result {\n  if cursor == len {\n    zero\n  } else {\n    do_foldl(\n      self,\n      with(builtin.index_bytearray(self, cursor), zero),\n      len,\n      cursor + 1,\n      with,\n    )\n  }\n}"
        },
        {
          "name": "do_foldr",
          "signature": "fn do_foldr(fn do_foldr(self: ByteArray, zero: result, cursor: Int, with: fn(Int, result) -> result,",
          "parameters": [],
          "returnType": "result,",
          "line": 490,
          "raw": "fn do_foldr(fn do_foldr(self: ByteArray, zero: result, cursor: Int, with: fn(Int, result) -> result,",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_foldr(\n  self: ByteArray,\n  zero: result,\n  cursor: Int,\n  with: fn(Int, result) -> result,\n) -> result {\n  if cursor < 0 {\n    zero\n  } else {\n    do_foldr(\n      self,\n      with(builtin.index_bytearray(self, cursor), zero),\n      cursor - 1,\n      with,\n    )\n  }\n}"
        }
      ],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/builtin\nuse aiken/math\nuse aiken/option\n\npub type Byte =\n  Int\n\n// ## Constructing\n\n/// Encode an integer value as a Big-Endian (most-significant bytes first) `ByteArray`.\n/// The size is the expected size in number of bytes.\n///\n/// > [!IMPORTANT]\n/// > This function fails (i.e. halts the program) if the value cannot fit in the given size. When the\n/// > size is _too large_, the array is left-padded with zeroes.\n///\n/// ```aiken\n/// bytearray.from_int_big_endian(1_000_000, 3) == #\"0f4240\"\n/// bytearray.from_int_big_endian(1_000_000, 5) == #\"00000f4240\"\n/// bytearray.from_int_big_endian(0, 8) == #\"0000000000000000\"\n/// bytearray.from_int_big_endian(1_000_000, 1) => 💥\n/// ```\npub fn from_int_big_endian(self: Int, size: Int) -> ByteArray {\n  builtin.integer_to_bytearray(True, size, self)\n}\n\ntest from_int_big_endian_1() {\n  from_int_big_endian(1_000_000, 3) == #\"0f4240\"\n}\n\ntest from_int_big_endian_2() {\n  from_int_big_endian(1_000_000, 5) == #\"00000f4240\"\n}\n\ntest from_int_big_endian_3() {\n  from_int_big_endian(0, 8) == #\"0000000000000000\"\n}\n\ntest from_int_big_endian_4() fail {\n  from_int_big_endian(1_000_000, 1) == #\"40\"\n}\n\n/// Encode an integer value as a Little-Endian (least-significant bytes first) `ByteArray`.\n/// The size is the expected size in number of bytes.\n///\n/// > [!IMPORTANT]\n/// > This function fails (i.e. halts the program) if the value cannot fit in the given size. When the\n/// > size is _too large_, the array is right-padded with zeroes.\n///\n/// ```aiken\n/// bytearray.from_int_little_endian(1_000_000, 3) == #\"40420f\"\n/// bytearray.from_int_little_endian(1_000_000, 5) == #\"40420f0000\"\n/// bytearray.from_int_little_endian(0, 8) == #\"0000000000000000\"\n/// bytearray.from_int_little_endian(1_000_000, 1) => 💥\n/// ```\npub fn from_int_little_endian(self: Int, size: Int) -> ByteArray {\n  builtin.integer_to_bytearray(False, size, self)\n}\n\ntest from_int_little_endian_1() {\n  from_int_little_endian(1_000_000, 3) == #\"40420f\"\n}\n\ntest from_int_little_endian_2() {\n  from_int_little_endian(1_000_000, 5) == #\"40420f0000\"\n}\n\ntest from_int_little_endian_3() {\n  from_int_little_endian(0, 8) == #\"0000000000000000\"\n}\n\ntest from_int_little_endian_4() fail {\n  from_int_little_endian(1_000_000, 1) == #\"40\"\n}\n\n/// Convert a `String` into a `ByteArray`.\n///\n/// ```aiken\n/// bytearray.from_string(@\"ABC\") == #\"414243\"\n/// ```\npub fn from_string(str: String) -> ByteArray {\n  builtin.encode_utf8(str)\n}\n\ntest from_string_1() {\n  from_string(@\"\") == \"\"\n}\n\ntest from_string_2() {\n  from_string(@\"ABC\") == #\"414243\"\n}\n\n/// Add a byte element in front of a `ByteArray`. When the given byte is\n/// greater than 255, it wraps-around. **PlutusV2 behavior** So 256 is mapped to 0, 257 to 1, and so\n/// forth.\n/// In PlutusV3 this will error instead of wrapping around.\n///\n/// ```aiken\n/// bytearray.push(#\"\", 0) == #\"00\"\n/// bytearray.push(#\"0203\", 1) == #\"010203\"\n/// bytearray.push(#\"0203\", 257) == #\"010203\"\n/// ```\npub fn push(self: ByteArray, byte: Byte) -> ByteArray {\n  builtin.cons_bytearray(byte, self)\n}\n\ntest push_1() {\n  push(#[], 0) == #[0]\n}\n\ntest push_2() {\n  push(#[2, 3], 1) == #[1, 2, 3]\n}\n\ntest push_3() fail {\n  let x = 257\n  push(#[2, 3], x) == #[1, 2, 3]\n}\n\n// ## Inspecting\n\n/// Get the `Byte` at the given index, or crash.\n///\n/// > [!WARNING]\n/// > This functions fails (i.e. halts the program) if there's no byte at the given index.\npub fn at(self: ByteArray, index: Int) -> Byte {\n  builtin.index_bytearray(self, index)\n}\n\n/// Search the start and end positions of a sub-array in a `ByteArray`.\n///\n/// ```aiken\n/// bytearray.index_of(\"Hello, World!\", \"World\") == Some((7, 11))\n/// bytearray.index_of(\"Hello, World!\", \"foo\") == None\n/// bytearray.index_of(\"Hello, World!\", \"!\") == Some((12, 12))\n/// bytearray.index_of(\"Hello, World!\", \"o\") == Some((4, 4))\n/// bytearray.index_of(\"Hello, World!\", \"Hello, World!\") == Some((0, 12))\n/// ```\npub fn index_of(self: ByteArray, bytes: ByteArray) -> Option<(Int, Int)> {\n  let offset = length(bytes)\n\n  do_index_of(self, bytes, 0, offset, length(self))\n    |> option.map(fn(ix) { (ix, ix + offset - 1) })\n}\n\nfn do_index_of(\n  self: ByteArray,\n  bytes: ByteArray,\n  cursor: Int,\n  offset: Int,\n  size: Int,\n) -> Option<Int> {\n  if cursor + offset > size {\n    None\n  } else {\n    if builtin.slice_bytearray(cursor, offset, self) == bytes {\n      Some(cursor)\n    } else {\n      do_index_of(self, bytes, cursor + 1, offset, size)\n    }\n  }\n}\n\ntest index_of_1() {\n  index_of(\"Hello, World!\", \"World\") == Some((7, 11))\n}\n\ntest index_of_2() {\n  index_of(\"Hello, World!\", \"foo\") == None\n}\n\ntest index_of_3() {\n  index_of(\"Hello, World!\", \"!\") == Some((12, 12))\n}\n\ntest index_of_4() {\n  index_of(\"Hello, World!\", \"o\") == Some((4, 4))\n}\n\ntest index_of_5() {\n  index_of(\"Hello, World!\", \"Hello, World!\") == Some((0, 12))\n}\n\n/// Returns `True` when the given `ByteArray` is empty.\n///\n/// ```aiken\n/// bytearray.is_empty(#\"\") == True\n/// bytearray.is_empty(#\"00ff\") == False\n/// ```\npub fn is_empty(self: ByteArray) -> Bool {\n  builtin.length_of_bytearray(self) == 0\n}\n\ntest is_empty_1() {\n  is_empty(#\"\") == True\n}\n\ntest is_empty_2() {\n  is_empty(#\"01\") == False\n}\n\n/// Returns the number of bytes in a `ByteArray`.\n///\n/// ```aiken\n/// bytearray.length(#[1, 2, 3]) == 3\n/// ```\npub fn length(self: ByteArray) -> Int {\n  builtin.length_of_bytearray(self)\n}\n\ntest length_1() {\n  length(#\"\") == 0\n}\n\ntest length_2() {\n  length(#\"010203\") == 3\n}\n\n/// Checks whether a bit (Most-Significant-Bit first) is set in the given 'ByteArray'.\n///\n/// For example, consider the following bytearray: `#\"8b765f\"`. It can also be written as the\n/// following bits sequence:\n///\n/// `8`    | `b`    | `7`    | `6`    | `5`    | `f`\n/// ---    | ---    | ---    | ---    | ---    | ---\n/// `1000` | `1011` | `0111` | `0110` | `0101` | `1111`\n///\n/// And thus, we have:\n///\n/// ```aiken\n/// test_bit(#\"8b765f\", 0) == True\n/// test_bit(#\"8b765f\", 1) == False\n/// test_bit(#\"8b765f\", 2) == False\n/// test_bit(#\"8b765f\", 3) == False\n/// test_bit(#\"8b765f\", 7) == True\n/// test_bit(#\"8b765f\", 8) == False\n/// test_bit(#\"8b765f\", 20) == True\n/// test_bit(#\"8b765f\", 21) == True\n/// test_bit(#\"8b765f\", 22) == True\n/// test_bit(#\"8b765f\", 23) == True\n/// ```\npub fn test_bit(self: ByteArray, ix: Int) -> Bool {\n  builtin.less_than_equals_bytearray(\n    #[128],\n    builtin.cons_bytearray(\n      builtin.index_bytearray(self, ix / 8) * math.pow2(ix % 8) % 256,\n      \"\",\n    ),\n  )\n}\n\ntest test_bit_0() {\n  test_bit(#\"8b765f\", 0)\n}\n\ntest test_bit_1() {\n  !test_bit(#\"8b765f\", 1)\n}\n\ntest test_bit_2() {\n  !test_bit(#\"8b765f\", 2)\n}\n\ntest test_bit_3() {\n  !test_bit(#\"8b765f\", 3)\n}\n\ntest test_bit_7() {\n  test_bit(#\"8b765f\", 7)\n}\n\ntest test_bit_8() {\n  !test_bit(#\"8b765f\", 8)\n}\n\ntest test_bit_20_21_22_23() {\n  and {\n    test_bit(#\"8b765f\", 20),\n    test_bit(#\"8b765f\", 21),\n    test_bit(#\"8b765f\", 22),\n    test_bit(#\"8b765f\", 23),\n  }\n}\n\n// ## Modifying\n\n/// Returns the suffix of a `ByteArray` after `n` elements.\n///\n/// ```aiken\n/// bytearray.drop(#[1, 2, 3], n: 2) == #[3]\n/// ```\npub fn drop(self: ByteArray, n: Int) -> ByteArray {\n  builtin.slice_bytearray(n, builtin.length_of_bytearray(self) - n, self)\n}\n\ntest drop_1() {\n  let x = #\"01020304050607\"\n  drop(x, 2) == #\"0304050607\"\n}\n\ntest drop_2() {\n  let x = #\"01020304050607\"\n  drop(x, 0) == x\n}\n\ntest drop_3() {\n  let x = #\"01\"\n  drop(x, 1) == #\"\"\n}\n\ntest drop_4() {\n  let x = #\"\"\n  drop(x, 2) == #\"\"\n}\n\n/// Extract a `ByteArray` as a slice of another `ByteArray`.\n///\n/// Indexes are 0-based and inclusive.\n///\n/// ```aiken\n/// bytearray.slice(#[0, 1, 2, 3, 4, 5, 6], start: 1, end: 3) == #[1, 2, 3]\n/// ```\npub fn slice(self: ByteArray, start: Int, end: Int) -> ByteArray {\n  builtin.slice_bytearray(start, end - start + 1, self)\n}\n\ntest slice_1() {\n  slice(#\"\", 1, 2) == #\"\"\n}\n\ntest slice_2() {\n  slice(#\"010203\", 1, 2) == #\"0203\"\n}\n\ntest slice_3() {\n  slice(#\"010203\", 0, 42) == #\"010203\"\n}\n\ntest slice_4() {\n  slice(#[0, 1, 2, 3, 4], 0, 3) == #[0, 1, 2, 3]\n}\n\ntest slice_5() {\n  slice(#[0, 1, 2, 3, 4], 1, 2) == #[1, 2]\n}\n\n/// Returns the n-length prefix of a `ByteArray`.\n///\n/// ```aiken\n/// bytearray.take(#[1, 2, 3], n: 2) == #[1, 2]\n/// ```\npub fn take(self: ByteArray, n: Int) -> ByteArray {\n  builtin.slice_bytearray(0, n, self)\n}\n\ntest take_1() {\n  let x = #\"01020304050607\"\n  take(x, 2) == #\"0102\"\n}\n\ntest take_2() {\n  let x = #\"01020304050607\"\n  take(x, 0) == #\"\"\n}\n\ntest take_3() {\n  let x = #\"01\"\n  take(x, 1) == x\n}\n\ntest take_4() {\n  let x = #\"010203\"\n  take(x, 0) == #\"\"\n}\n\n// ## Combining\n\n/// Combine two `ByteArray` together.\n///\n/// ```aiken\n/// bytearray.concat(left: #[1, 2, 3], right: #[4, 5, 6]) == #[1, 2, 3, 4, 5, 6]\n/// ```\npub fn concat(left: ByteArray, right: ByteArray) -> ByteArray {\n  builtin.append_bytearray(left, right)\n}\n\ntest concat_1() {\n  concat(#\"\", #\"\") == #\"\"\n}\n\ntest concat_2() {\n  concat(#\"\", #\"01\") == #\"01\"\n}\n\ntest concat_3() {\n  concat(#\"0102\", #\"\") == #\"0102\"\n}\n\ntest concat_4() {\n  concat(#\"0102\", #\"0304\") == #\"01020304\"\n}\n\n/// Compare two bytearrays lexicographically.\n///\n/// ```aiken\n/// bytearray.compare(#\"00\", #\"FF\") == Less\n/// bytearray.compare(#\"42\", #\"42\") == Equal\n/// bytearray.compare(#\"FF\", #\"00\") == Greater\n/// ```\npub fn compare(left: ByteArray, right: ByteArray) -> Ordering {\n  if builtin.less_than_bytearray(left, right) {\n    Less\n  } else if builtin.equals_bytearray(left, right) {\n    Equal\n  } else {\n    Greater\n  }\n}\n\n// ## Transforming\n\n/// Left-fold over bytes of a [`ByteArray`](https://aiken-lang.github.io/prelude/aiken.html#ByteArray). Note that every byte given to the callback function is comprised between 0 and 255.\n///\n/// ```aiken\n/// bytearray.foldl(#\"acab\", 0, fn(byte, acc) { acc * 256 + byte }) == 44203\n/// bytearray.foldl(#[1, 2, 3], #\"\", flip(bytearray.push)) == #[3, 2, 1]\n/// ```\npub fn foldl(\n  self: ByteArray,\n  zero: result,\n  with: fn(Int, result) -> result,\n) -> result {\n  do_foldl(self, zero, builtin.length_of_bytearray(self), 0, with)\n}\n\nfn do_foldl(\n  self: ByteArray,\n  zero: result,\n  len: Int,\n  cursor: Int,\n  with: fn(Int, result) -> result,\n) -> result {\n  if cursor == len {\n    zero\n  } else {\n    do_foldl(\n      self,\n      with(builtin.index_bytearray(self, cursor), zero),\n      len,\n      cursor + 1,\n      with,\n    )\n  }\n}\n\ntest foldl_1() {\n  foldl(#[], 42, fn(byte, acc) { byte + acc }) == 42\n}\n\ntest foldl_2() {\n  foldl(#\"acab\", 0, fn(byte, acc) { acc * 256 + byte }) == 44203\n}\n\ntest foldl_3() {\n  foldl(\n    #\"356cf088720a169dae0ce0bb1df8588944389fa43322f0d6ef4ed8c069bfd405\",\n    0,\n    fn(byte, acc) { acc * 256 + byte },\n  ) == 24165060555594911913195642527692216679757672038384202527929620681761931383813\n}\n\ntest foldl_4() {\n  foldl(#[1, 2, 3, 4, 5], #\"\", flip(push)) == #[5, 4, 3, 2, 1]\n}\n\n/// Right-fold over bytes of a [`ByteArray`](https://aiken-lang.github.io/prelude/aiken.html#ByteArray). Note that every byte given to the callback function is comprised between 0 and 255.\n///\n/// ```aiken\n/// bytearray.foldr(#\"acab\", 0, fn(byte, acc) { acc * 256 + byte }) == 43948\n/// bytearray.foldl(#[1, 2, 3], #\"\", flip(bytearray.push)) == #[1, 2, 3]\n/// ```\npub fn foldr(\n  self: ByteArray,\n  zero: result,\n  with: fn(Int, result) -> result,\n) -> result {\n  do_foldr(self, zero, builtin.length_of_bytearray(self) - 1, with)\n}\n\nfn do_foldr(\n  self: ByteArray,\n  zero: result,\n  cursor: Int,\n  with: fn(Int, result) -> result,\n) -> result {\n  if cursor < 0 {\n    zero\n  } else {\n    do_foldr(\n      self,\n      with(builtin.index_bytearray(self, cursor), zero),\n      cursor - 1,\n      with,\n    )\n  }\n}\n\ntest foldr_1() {\n  foldr(#[], 42, fn(byte, acc) { byte + acc }) == 42\n}\n\ntest foldr_2() {\n  foldr(#\"acab\", 0, fn(byte, acc) { acc * 256 + byte }) == 43948\n}\n\ntest foldr_3() {\n  foldr(#[1, 2, 3, 4, 5], #\"\", flip(push)) == #[1, 2, 3, 4, 5]\n}\n\n/// Reduce bytes in a ByteArray from left to right using the accumulator as left operand.\n/// Said differently, this is [`foldl`](#foldl) with callback arguments swapped.\n///\n/// ```aiken\n/// bytearray.reduce(#[1,2,3], #[], bytearray.push) == #[3, 2, 1]\n/// ```\npub fn reduce(\n  self: ByteArray,\n  zero: result,\n  with: fn(result, Int) -> result,\n) -> result {\n  foldl(self, zero, flip(with))\n}\n\ntest reduce_1() {\n  reduce(#[], #[], push) == #[]\n}\n\ntest reduce_2() {\n  reduce(#[1, 2, 3], #[], push) == #[3, 2, 1]\n}\n\n/// Interpret a Big-Endian (most-significant bytes first) `ByteArray` as an `Int`.\n///\n/// ```aiken\n/// bytearray.to_int_big_endian(#\"0f4240\") == 1_000_000\n/// bytearray.to_int_big_endian(#\"00000f4240\") == 1_000_000\n/// bytearray.to_int_big_endian(#\"0000000000000000\") == 0\n/// ```\npub fn to_int_big_endian(self: ByteArray) -> Int {\n  builtin.bytearray_to_integer(True, self)\n}\n\ntest to_int_big_endian_1() {\n  to_int_big_endian(#\"0f4240\") == 1_000_000\n}\n\ntest to_int_big_endian_2() {\n  to_int_big_endian(#\"00000f4240\") == 1_000_000\n}\n\ntest to_int_big_endian_3() {\n  to_int_big_endian(#\"0000000000000000\") == 0\n}\n\n/// Interpret a Little-Endian (least-significant bytes first) `ByteArray` as an `Int`.\n///\n/// ```aiken\n/// bytearray.to_int_big_endian(#\"40420f\") == 1_000_000\n/// bytearray.to_int_big_endian(#\"40420f0000\") == 1_000_000\n/// bytearray.to_int_big_endian(#\"0000000000000000\") == 0\n/// ```\npub fn to_int_little_endian(self: ByteArray) -> Int {\n  builtin.bytearray_to_integer(False, self)\n}\n\ntest to_int_little_endian_1() {\n  to_int_little_endian(#\"40420f\") == 1_000_000\n}\n\ntest to_int_little_endian_2() {\n  to_int_little_endian(#\"40420f0000\") == 1_000_000\n}\n\ntest to_int_little_endian_3() {\n  to_int_little_endian(#\"0000000000000000\") == 0\n}\n\n/// Convert a `ByteArray` into a `String`.\n///\n/// > [!WARNING]\n/// > This functions fails (i.e. halts the program) if the underlying `ByteArray` isn't UTF-8-encoded. In particular, you cannot convert arbitrary hash digests using this function.\n/// >\n/// > For converting arbitrary `ByteArray`s, use [bytearray.to_hex](#to_hex).\n///\n/// ```aiken\n/// bytearray.to_string(#\"414243\") == \"ABC\"\n/// bytearray.to_string(some_hash) => 💥\n/// ```\npub fn to_string(self: ByteArray) -> String {\n  builtin.decode_utf8(self)\n}\n\ntest to_string_1() {\n  to_string(\"\") == @\"\"\n}\n\ntest to_string_2() {\n  to_string(\"ABC\") == @\"ABC\"\n}\n\n/// Encode a `ByteArray` as a hexidecimal `String`.\n///\n/// ```aiken\n/// bytearray.to_hex(\"Hello world!\") == @\"48656c6c6f20776f726c6421\"\n/// ```\npub fn to_hex(self: ByteArray) -> String {\n  self\n    |> encode_base16(builtin.length_of_bytearray(self) - 1, \"\")\n    |> builtin.decode_utf8\n}\n\ntest to_hex_1() {\n  to_hex(\"Hello world!\") == @\"48656C6C6F20776F726C6421\"\n}\n\ntest to_hex_2() {\n  to_hex(\"The quick brown fox jumps over the lazy dog\") == @\"54686520717569636B2062726F776E20666F78206A756D7073206F76657220746865206C617A7920646F67\"\n}\n\n/// Checks whether a `ByteArray` starts with a given prefix.\n///\n/// ```aiken\n/// bytearray.starts_with(\"Hello, World!\", prefix: \"Hello\") == True\n/// bytearray.starts_with(\"\", prefix: \"\") == True\n/// bytearray.starts_with(\"Hello\", prefix: \"Hello, World!\") == False\n/// ```\npub fn starts_with(self: ByteArray, prefix: ByteArray) -> Bool {\n  let prefix_length = length(prefix)\n  if length(self) < prefix_length {\n    False\n  } else {\n    take(self, prefix_length) == prefix\n  }\n}\n\ntest starts_with_1() {\n  starts_with(\"\", \"\")\n}\n\ntest starts_with_2() {\n  starts_with(\"Hello, World!\", \"Hello, World!\")\n}\n\ntest starts_with_3() {\n  !starts_with(\"Hello, World!\", \"hello\")\n}\n\ntest starts_with_4() {\n  !starts_with(\"\", \"World\")\n}\n\ntest starts_with_5() {\n  starts_with(\"Hello, World\", \"Hello\")\n}\n\ntest starts_with_6() {\n  !starts_with(\"foo\", \"foo_\")\n}\n\npub fn and_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {\n  builtin.and_bytearray(pad_end, left, right)\n}\n\npub fn or_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {\n  builtin.or_bytearray(pad_end, left, right)\n}\n\npub fn xor_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {\n  builtin.xor_bytearray(pad_end, left, right)\n}\n",
      "dependencies": ["aiken/builtin", "aiken/math", "aiken/option"],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.primitive.int",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/primitive/int.ak",
      "name": "aiken.primitive.int",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": ["bytearray_to_integer", "decode_utf8"],
          "line": 1,
          "raw": "use aiken/builtin.{bytearray_to_integer, decode_utf8}",
          "source": "stdlib"
        },
        {
          "module": "aiken/math",
          "items": [],
          "line": 2,
          "raw": "use aiken/math",
          "source": "stdlib"
        },
        {
          "module": "aiken/option",
          "items": [],
          "line": 3,
          "raw": "use aiken/option",
          "source": "stdlib"
        },
        {
          "module": "aiken/primitive/bytearray",
          "items": [],
          "line": 4,
          "raw": "use aiken/primitive/bytearray",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "compare",
          "signature": "pub fn compare(left: Int, right: Int) -> Ordering {",
          "documentation": "Compare two integers.\n\n```aiken\nint.compare(14, 42) == Less\nint.compare(14, 14) == Equal\nint.compare(42, 14) == Greater\n```",
          "parameters": [
            {
              "name": "left",
              "type": "Int",
              "optional": false
            },
            {
              "name": "right",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Ordering",
          "line": 15,
          "raw": "pub fn compare(left: Int, right: Int) -> Ordering {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn compare(left: Int, right: Int) -> Ordering {\n  if left < right {\n    Less\n  } else if left > right {\n    Greater\n  } else {\n    Equal\n  }\n}"
        },
        {
          "name": "from_bytearray_big_endian",
          "signature": "pub fn from_bytearray_big_endian(self: ByteArray) -> Int {",
          "documentation": "Interpret a Big-Endian (most-significant bytes first) `ByteArray` as an `Int`.\n\n```aiken\nint.from_bytearray_big_endian(#\"0f4240\") == 1_000_000\nint.from_bytearray_big_endian(#\"00000f4240\") == 1_000_000\nint.from_bytearray_big_endian(#\"0000000000000000\") == 0\n```",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 34,
          "raw": "pub fn from_bytearray_big_endian(self: ByteArray) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_bytearray_big_endian(self: ByteArray) -> Int {\n  bytearray_to_integer(True, self)\n}",
          "tests": [
            "test from_bytearray_big_endian_1() {\n  from_bytearray_big_endian(#\"0f4240\") == 1_000_000\n}",
            "test from_bytearray_big_endian_2() {\n  from_bytearray_big_endian(#\"00000f4240\") == 1_000_000\n}",
            "test from_bytearray_big_endian_3() {\n  from_bytearray_big_endian(#\"0000000000000000\") == 0\n}"
          ]
        },
        {
          "name": "from_bytearray_little_endian",
          "signature": "pub fn from_bytearray_little_endian(self: ByteArray) -> Int {",
          "documentation": "Interpret a Little-Endian (least-significant bytes first) `ByteArray` as an `Int`.\n\n```aiken\nint.from_bytearray_big_endian(#\"40420f\") == 1_000_000\nint.from_bytearray_big_endian(#\"40420f0000\") == 1_000_000\nint.from_bytearray_big_endian(#\"0000000000000000\") == 0\n```",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 57,
          "raw": "pub fn from_bytearray_little_endian(self: ByteArray) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_bytearray_little_endian(self: ByteArray) -> Int {\n  bytearray_to_integer(False, self)\n}",
          "tests": [
            "test from_bytearray_little_endian_1() {\n  from_bytearray_little_endian(#\"40420f\") == 1_000_000\n}",
            "test from_bytearray_little_endian_2() {\n  from_bytearray_little_endian(#\"40420f0000\") == 1_000_000\n}",
            "test from_bytearray_little_endian_3() {\n  from_bytearray_little_endian(#\"0000000000000000\") == 0\n}"
          ]
        },
        {
          "name": "from_utf8",
          "signature": "pub fn from_utf8(bytes: ByteArray) -> Option<Int> {",
          "documentation": "Parse an integer from a utf-8 encoded `ByteArray`, when possible.\n\n```aiken\nint.from_utf8(\"14\") == Some(14)\nint.from_utf8(\"-42\") == Some(-42)\nint.from_utf8(\"007\") == Some(7)\nint.from_utf8(\"foo\") == None\nint.from_utf8(\"1.0\") == None\nint.from_utf8(\"1-2\") == None\n```",
          "parameters": [
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Option<Int>",
          "line": 83,
          "raw": "pub fn from_utf8(bytes: ByteArray) -> Option<Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_utf8(bytes: ByteArray) -> Option<Int> {\n  bytes\n    |> bytearray.foldr(\n        Some((0, 0)),\n        fn(byte, st) {\n          when st is {\n            None -> None\n            Some((n, e)) ->\n              if byte < 48 || byte > 57 {\n                if byte == 45 {\n                  Some((-n, 0))\n                } else {\n                  None\n                }\n              } else if n < 0 {\n                None\n              } else {\n                let digit = byte - 48\n                Some((n + digit * math.pow(10, e), e + 1))\n              }\n          }\n        },\n      )\n    |> option.map(fn(tuple) { tuple.1st })\n}",
          "tests": [
            "test from_utf8_1() {\n  from_utf8(\"0017\") == Some(17)\n}",
            "test from_utf8_2() {\n  from_utf8(\"42\") == Some(42)\n}",
            "test from_utf8_3() {\n  from_utf8(\"1337\") == Some(1337)\n}",
            "test from_utf8_4() {\n  from_utf8(\"-14\") == Some(-14)\n}",
            "test from_utf8_5() {\n  from_utf8(\"foo\") == None\n}",
            "test from_utf8_6() {\n  from_utf8(\"1-2\") == None\n}"
          ]
        },
        {
          "name": "to_string",
          "signature": "pub fn to_string(n: Int) -> String {",
          "documentation": "Convert an `Int` to its `String` representation.\n\n```aiken\nint.to_string(42) == @\"42\"\n```",
          "parameters": [
            {
              "name": "n",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "String",
          "line": 138,
          "raw": "pub fn to_string(n: Int) -> String {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn to_string(n: Int) -> String {\n  diagnostic(n, \"\") |> decode_utf8\n}",
          "tests": [
            "test to_string_1() {\n  to_string(0) == @\"0\"\n}",
            "test to_string_2() {\n  to_string(5) == @\"5\"\n}",
            "test to_string_3() {\n  to_string(42) == @\"42\"\n}",
            "test to_string_4() {\n  to_string(200) == @\"200\"\n}"
          ]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/builtin.{bytearray_to_integer, decode_utf8}\nuse aiken/math\nuse aiken/option\nuse aiken/primitive/bytearray\n\n// ## Combining\n\n/// Compare two integers.\n///\n/// ```aiken\n/// int.compare(14, 42) == Less\n/// int.compare(14, 14) == Equal\n/// int.compare(42, 14) == Greater\n/// ```\npub fn compare(left: Int, right: Int) -> Ordering {\n  if left < right {\n    Less\n  } else if left > right {\n    Greater\n  } else {\n    Equal\n  }\n}\n\n// ## Transforming\n\n/// Interpret a Big-Endian (most-significant bytes first) `ByteArray` as an `Int`.\n///\n/// ```aiken\n/// int.from_bytearray_big_endian(#\"0f4240\") == 1_000_000\n/// int.from_bytearray_big_endian(#\"00000f4240\") == 1_000_000\n/// int.from_bytearray_big_endian(#\"0000000000000000\") == 0\n/// ```\npub fn from_bytearray_big_endian(self: ByteArray) -> Int {\n  bytearray_to_integer(True, self)\n}\n\ntest from_bytearray_big_endian_1() {\n  from_bytearray_big_endian(#\"0f4240\") == 1_000_000\n}\n\ntest from_bytearray_big_endian_2() {\n  from_bytearray_big_endian(#\"00000f4240\") == 1_000_000\n}\n\ntest from_bytearray_big_endian_3() {\n  from_bytearray_big_endian(#\"0000000000000000\") == 0\n}\n\n/// Interpret a Little-Endian (least-significant bytes first) `ByteArray` as an `Int`.\n///\n/// ```aiken\n/// int.from_bytearray_big_endian(#\"40420f\") == 1_000_000\n/// int.from_bytearray_big_endian(#\"40420f0000\") == 1_000_000\n/// int.from_bytearray_big_endian(#\"0000000000000000\") == 0\n/// ```\npub fn from_bytearray_little_endian(self: ByteArray) -> Int {\n  bytearray_to_integer(False, self)\n}\n\ntest from_bytearray_little_endian_1() {\n  from_bytearray_little_endian(#\"40420f\") == 1_000_000\n}\n\ntest from_bytearray_little_endian_2() {\n  from_bytearray_little_endian(#\"40420f0000\") == 1_000_000\n}\n\ntest from_bytearray_little_endian_3() {\n  from_bytearray_little_endian(#\"0000000000000000\") == 0\n}\n\n/// Parse an integer from a utf-8 encoded `ByteArray`, when possible.\n///\n/// ```aiken\n/// int.from_utf8(\"14\") == Some(14)\n/// int.from_utf8(\"-42\") == Some(-42)\n/// int.from_utf8(\"007\") == Some(7)\n/// int.from_utf8(\"foo\") == None\n/// int.from_utf8(\"1.0\") == None\n/// int.from_utf8(\"1-2\") == None\n/// ```\npub fn from_utf8(bytes: ByteArray) -> Option<Int> {\n  bytes\n    |> bytearray.foldr(\n        Some((0, 0)),\n        fn(byte, st) {\n          when st is {\n            None -> None\n            Some((n, e)) ->\n              if byte < 48 || byte > 57 {\n                if byte == 45 {\n                  Some((-n, 0))\n                } else {\n                  None\n                }\n              } else if n < 0 {\n                None\n              } else {\n                let digit = byte - 48\n                Some((n + digit * math.pow(10, e), e + 1))\n              }\n          }\n        },\n      )\n    |> option.map(fn(tuple) { tuple.1st })\n}\n\ntest from_utf8_1() {\n  from_utf8(\"0017\") == Some(17)\n}\n\ntest from_utf8_2() {\n  from_utf8(\"42\") == Some(42)\n}\n\ntest from_utf8_3() {\n  from_utf8(\"1337\") == Some(1337)\n}\n\ntest from_utf8_4() {\n  from_utf8(\"-14\") == Some(-14)\n}\n\ntest from_utf8_5() {\n  from_utf8(\"foo\") == None\n}\n\ntest from_utf8_6() {\n  from_utf8(\"1-2\") == None\n}\n\n/// Convert an `Int` to its `String` representation.\n///\n/// ```aiken\n/// int.to_string(42) == @\"42\"\n/// ```\npub fn to_string(n: Int) -> String {\n  diagnostic(n, \"\") |> decode_utf8\n}\n\ntest to_string_1() {\n  to_string(0) == @\"0\"\n}\n\ntest to_string_2() {\n  to_string(5) == @\"5\"\n}\n\ntest to_string_3() {\n  to_string(42) == @\"42\"\n}\n\ntest to_string_4() {\n  to_string(200) == @\"200\"\n}\n",
      "dependencies": [
        "aiken/builtin",
        "aiken/math",
        "aiken/option",
        "aiken/primitive/bytearray"
      ],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:aiken.primitive.string",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/aiken/primitive/string.ak",
      "name": "aiken.primitive.string",
      "imports": [],
      "functions": [
        {
          "name": "from_bytearray",
          "signature": "pub fn from_bytearray(bytes: ByteArray) -> String {",
          "documentation": "Convert a `ByteArray` into a `String`\n\n> [!WARNING]\n> This functions fails if the underlying `ByteArray` isn't UTF-8-encoded. In particular, you cannot convert arbitrary hash digests using this function.\n>\n> For converting arbitrary `ByteArray`s, use [bytearray.to_hex](./bytearray.html#to_hex).\n\n```aiken\nstring.from_bytearray(\"foo\") == @\"foo\"\nstring.from_bytearray(#\"666f6f\") == @\"foo\"\nstring.from_bytearray(some_hash) -> fail\n```",
          "parameters": [
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "String",
          "line": 19,
          "raw": "pub fn from_bytearray(bytes: ByteArray) -> String {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_bytearray(bytes: ByteArray) -> String {\n  decode_utf8(bytes)\n}",
          "tests": [
            "test from_bytearray_1() {\n  from_bytearray(#[]) == @\"\"\n}",
            "test from_bytearray_2() {\n  from_bytearray(#[65, 66, 67]) == @\"ABC\"\n}",
            "test from_bytearray_3() {\n  from_bytearray(\"ABC\") == @\"ABC\"\n}"
          ]
        },
        {
          "name": "from_int",
          "signature": "pub fn from_int(n: Int) -> String {",
          "documentation": "Convert an `Int` to its `String` representation.\n\n```aiken\nstring.from_int(42) == @\"42\"\n```",
          "parameters": [
            {
              "name": "n",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "String",
          "line": 40,
          "raw": "pub fn from_int(n: Int) -> String {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_int(n: Int) -> String {\n  diagnostic(n, \"\") |> decode_utf8\n}",
          "tests": [
            "test from_int_1() {\n  from_int(0) == @\"0\"\n}",
            "test from_int_2() {\n  from_int(5) == @\"5\"\n}",
            "test from_int_3() {\n  from_int(42) == @\"42\"\n}",
            "test from_int_4() {\n  from_int(200) == @\"200\"\n}"
          ]
        },
        {
          "name": "concat",
          "signature": "pub fn concat(left: String, right: String) -> String {",
          "documentation": "Combine two `String` together.\n\n```aiken\nstring.concat(left: @\"Hello\", right: @\", World!\") == @\"Hello, World!\"\n```",
          "parameters": [
            {
              "name": "left",
              "type": "String",
              "optional": false
            },
            {
              "name": "right",
              "type": "String",
              "optional": false
            }
          ],
          "returnType": "String",
          "line": 67,
          "raw": "pub fn concat(left: String, right: String) -> String {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn concat(left: String, right: String) -> String {\n  append_string(left, right)\n}",
          "tests": [
            "test concat_1() {\n  concat(@\"\", @\"\") == @\"\"\n}",
            "test concat_2() {\n  concat(@\"\", @\"foo\") == concat(@\"foo\", @\"\")\n}",
            "test concat_3() {\n  concat(left: @\"Hello\", right: @\", World!\") == @\"Hello, World!\"\n}"
          ]
        },
        {
          "name": "join",
          "signature": "pub fn join(list: List<String>, delimiter: String) -> String {",
          "documentation": "Join a list of strings, separated by a given _delimiter_.\n\n```aiken\nstring.join([], @\"+\") == @\"\"\nstring.join([@\"a\", @\"b\", @\"c\"], @\",\") == @\"a,b,c\"\n```",
          "parameters": [
            {
              "name": "list",
              "type": "List<String>",
              "optional": false
            },
            {
              "name": "delimiter",
              "type": "String",
              "optional": false
            }
          ],
          "returnType": "String",
          "line": 89,
          "raw": "pub fn join(list: List<String>, delimiter: String) -> String {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn join(list: List<String>, delimiter: String) -> String {\n  do_join(list, encode_utf8(delimiter), #\"\")\n    |> decode_utf8\n}"
        },
        {
          "name": "to_bytearray",
          "signature": "pub fn to_bytearray(self: String) -> ByteArray {",
          "documentation": "Convert a `String` into a `ByteArray`\n\n```aiken\nstring.to_bytearray(@\"foo\") == \"foo\"\n```",
          "parameters": [
            {
              "name": "self",
              "type": "String",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 125,
          "raw": "pub fn to_bytearray(self: String) -> ByteArray {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn to_bytearray(self: String) -> ByteArray {\n  encode_utf8(self)\n}",
          "tests": [
            "test to_bytearray_1() {\n  to_bytearray(@\"\") == \"\"\n}",
            "test to_bytearray_2() {\n  to_bytearray(@\"ABC\") == #[65, 66, 67]\n}",
            "test to_bytearray_3() {\n  to_bytearray(@\"ABC\") == \"ABC\"\n}"
          ]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [
        {
          "name": "do_join",
          "signature": "fn do_join(xs, delimiter, bytes) {",
          "parameters": [
            {
              "name": "xs",
              "type": "Unknown",
              "optional": false
            },
            {
              "name": "delimiter",
              "type": "Unknown",
              "optional": false
            },
            {
              "name": "bytes",
              "type": "Unknown",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 94,
          "raw": "fn do_join(xs, delimiter, bytes) {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn do_join(xs, delimiter, bytes) {\n  when xs is {\n    [] -> bytes\n    [x, ..rest] ->\n      do_join(\n        rest,\n        delimiter,\n        if length_of_bytearray(bytes) == 0 {\n          encode_utf8(x)\n        } else {\n          append_bytearray(bytes, append_bytearray(delimiter, encode_utf8(x)))\n        },\n      )\n  }\n}"
        }
      ],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/builtin.{\n  append_bytearray, append_string, decode_utf8, encode_utf8, length_of_bytearray,\n}\n\n// ## Constructing\n\n/// Convert a `ByteArray` into a `String`\n///\n/// > [!WARNING]\n/// > This functions fails if the underlying `ByteArray` isn't UTF-8-encoded. In particular, you cannot convert arbitrary hash digests using this function.\n/// >\n/// > For converting arbitrary `ByteArray`s, use [bytearray.to_hex](./bytearray.html#to_hex).\n///\n/// ```aiken\n/// string.from_bytearray(\"foo\") == @\"foo\"\n/// string.from_bytearray(#\"666f6f\") == @\"foo\"\n/// string.from_bytearray(some_hash) -> fail\n/// ```\npub fn from_bytearray(bytes: ByteArray) -> String {\n  decode_utf8(bytes)\n}\n\ntest from_bytearray_1() {\n  from_bytearray(#[]) == @\"\"\n}\n\ntest from_bytearray_2() {\n  from_bytearray(#[65, 66, 67]) == @\"ABC\"\n}\n\ntest from_bytearray_3() {\n  from_bytearray(\"ABC\") == @\"ABC\"\n}\n\n/// Convert an `Int` to its `String` representation.\n///\n/// ```aiken\n/// string.from_int(42) == @\"42\"\n/// ```\npub fn from_int(n: Int) -> String {\n  diagnostic(n, \"\") |> decode_utf8\n}\n\ntest from_int_1() {\n  from_int(0) == @\"0\"\n}\n\ntest from_int_2() {\n  from_int(5) == @\"5\"\n}\n\ntest from_int_3() {\n  from_int(42) == @\"42\"\n}\n\ntest from_int_4() {\n  from_int(200) == @\"200\"\n}\n\n// ## Combining\n\n/// Combine two `String` together.\n///\n/// ```aiken\n/// string.concat(left: @\"Hello\", right: @\", World!\") == @\"Hello, World!\"\n/// ```\npub fn concat(left: String, right: String) -> String {\n  append_string(left, right)\n}\n\ntest concat_1() {\n  concat(@\"\", @\"\") == @\"\"\n}\n\ntest concat_2() {\n  concat(@\"\", @\"foo\") == concat(@\"foo\", @\"\")\n}\n\ntest concat_3() {\n  concat(left: @\"Hello\", right: @\", World!\") == @\"Hello, World!\"\n}\n\n/// Join a list of strings, separated by a given _delimiter_.\n///\n/// ```aiken\n/// string.join([], @\"+\") == @\"\"\n/// string.join([@\"a\", @\"b\", @\"c\"], @\",\") == @\"a,b,c\"\n/// ```\npub fn join(list: List<String>, delimiter: String) -> String {\n  do_join(list, encode_utf8(delimiter), #\"\")\n    |> decode_utf8\n}\n\nfn do_join(xs, delimiter, bytes) {\n  when xs is {\n    [] -> bytes\n    [x, ..rest] ->\n      do_join(\n        rest,\n        delimiter,\n        if length_of_bytearray(bytes) == 0 {\n          encode_utf8(x)\n        } else {\n          append_bytearray(bytes, append_bytearray(delimiter, encode_utf8(x)))\n        },\n      )\n  }\n}\n\ntest join_1() {\n  join([], @\",\") == @\"\"\n}\n\ntest join_2() {\n  join([@\"a\", @\"b\", @\"c\"], @\",\") == @\"a,b,c\"\n}\n\n// ## Transforming\n\n/// Convert a `String` into a `ByteArray`\n///\n/// ```aiken\n/// string.to_bytearray(@\"foo\") == \"foo\"\n/// ```\npub fn to_bytearray(self: String) -> ByteArray {\n  encode_utf8(self)\n}\n\ntest to_bytearray_1() {\n  to_bytearray(@\"\") == \"\"\n}\n\ntest to_bytearray_2() {\n  to_bytearray(@\"ABC\") == #[65, 66, 67]\n}\n\ntest to_bytearray_3() {\n  to_bytearray(@\"ABC\") == \"ABC\"\n}\n",
      "dependencies": [],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:cardano.address.credential",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/cardano/address/credential.ak",
      "name": "cardano.address.credential",
      "imports": [
        {
          "module": "aiken/primitive/bytearray",
          "items": [],
          "line": 1,
          "raw": "use aiken/primitive/bytearray",
          "source": "stdlib"
        },
        {
          "module": "cardano/address",
          "items": ["Credential", "Script", "VerificationKey"],
          "line": 2,
          "raw": "use cardano/address.{Credential, Script, VerificationKey}",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "compare",
          "signature": "pub fn compare(left: Credential, right: Credential) -> Ordering {",
          "parameters": [
            {
              "name": "left",
              "type": "Credential",
              "optional": false
            },
            {
              "name": "right",
              "type": "Credential",
              "optional": false
            }
          ],
          "returnType": "Ordering",
          "line": 4,
          "raw": "pub fn compare(left: Credential, right: Credential) -> Ordering {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn compare(left: Credential, right: Credential) -> Ordering {\n  when left is {\n    Script(left) ->\n      when right is {\n        Script(right) -> bytearray.compare(left, right)\n        _ -> Less\n      }\n    VerificationKey(left) ->\n      when right is {\n        Script(_) -> Greater\n        VerificationKey(right) -> bytearray.compare(left, right)\n      }\n  }\n}",
          "tests": [
            "test compare_matrix() {\n  and {\n    (compare(Script(\"\"), Script(\"\")) == Equal)?,\n    (compare(VerificationKey(\"\"), VerificationKey(\"\")) == Equal)?,\n    (compare(Script(\"\"), VerificationKey(\"\")) == Less)?,\n    (compare(VerificationKey(\"\"), Script(\"\")) == Greater)?,\n    (compare(Script(\"01\"), Script(\"02\")) == Less)?,\n    (compare(Script(\"02\"), Script(\"01\")) == Greater)?,\n    (compare(VerificationKey(\"01\"), VerificationKey(\"02\")) == Less)?,\n    (compare(VerificationKey(\"02\"), VerificationKey(\"01\")) == Greater)?,\n  }\n}"
          ]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/primitive/bytearray\nuse cardano/address.{Credential, Script, VerificationKey}\n\npub fn compare(left: Credential, right: Credential) -> Ordering {\n  when left is {\n    Script(left) ->\n      when right is {\n        Script(right) -> bytearray.compare(left, right)\n        _ -> Less\n      }\n    VerificationKey(left) ->\n      when right is {\n        Script(_) -> Greater\n        VerificationKey(right) -> bytearray.compare(left, right)\n      }\n  }\n}\n\ntest compare_matrix() {\n  and {\n    (compare(Script(\"\"), Script(\"\")) == Equal)?,\n    (compare(VerificationKey(\"\"), VerificationKey(\"\")) == Equal)?,\n    (compare(Script(\"\"), VerificationKey(\"\")) == Less)?,\n    (compare(VerificationKey(\"\"), Script(\"\")) == Greater)?,\n    (compare(Script(\"01\"), Script(\"02\")) == Less)?,\n    (compare(Script(\"02\"), Script(\"01\")) == Greater)?,\n    (compare(VerificationKey(\"01\"), VerificationKey(\"02\")) == Less)?,\n    (compare(VerificationKey(\"02\"), VerificationKey(\"01\")) == Greater)?,\n  }\n}\n",
      "dependencies": ["aiken/primitive/bytearray", "cardano/address"],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:cardano.address",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/cardano/address.ak",
      "name": "cardano.address",
      "imports": [],
      "functions": [
        {
          "name": "from_script",
          "signature": "pub fn from_script(script: Hash<Blake2b_224, Script>) -> Address {",
          "documentation": "Smart-constructor for an [Address](#Address) from a [script](#Script) hash. The address has no delegation rights whatsoever.",
          "parameters": [
            {
              "name": "script",
              "type": "Hash<Blake2b_224, Script>",
              "optional": false
            }
          ],
          "returnType": "Address",
          "line": 28,
          "raw": "pub fn from_script(script: Hash<Blake2b_224, Script>) -> Address {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_script(script: Hash<Blake2b_224, Script>) -> Address {\n  Address { payment_credential: Script(script), stake_credential: None }\n}"
        },
        {
          "name": "from_verification_key",
          "signature": "pub fn from_verification_key(vk: Hash<Blake2b_224, VerificationKey>) -> Address {",
          "documentation": "Smart-constructor for an [Address](#Address) from a [verification key](#VerificationKey) hash. The resulting address has no delegation rights whatsoever.",
          "parameters": [
            {
              "name": "vk",
              "type": "Hash<Blake2b_224, VerificationKey>",
              "optional": false
            }
          ],
          "returnType": "Address",
          "line": 33,
          "raw": "pub fn from_verification_key(vk: Hash<Blake2b_224, VerificationKey>) -> Address {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_verification_key(vk: Hash<Blake2b_224, VerificationKey>) -> Address {\n  Address { payment_credential: VerificationKey(vk), stake_credential: None }\n}"
        },
        {
          "name": "with_delegation_key",
          "signature": "pub fn with_delegation_key(pub fn with_delegation_key(self: Address, vk: Hash<Blake2b_224, VerificationKey>, ) -> Address {",
          "documentation": "Set (or reset) the delegation part of an [Address](#Address) using a [verification key](#VerificationKey) hash. This is useful when combined with [`from_verification_key`](#from_verification_key) and/or [`from_script`](#from_script).",
          "parameters": [],
          "returnType": "Address",
          "line": 38,
          "raw": "pub fn with_delegation_key(pub fn with_delegation_key(self: Address, vk: Hash<Blake2b_224, VerificationKey>, ) -> Address {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn with_delegation_key(\n  self: Address,\n  vk: Hash<Blake2b_224, VerificationKey>,\n) -> Address {\n  Address {\n    payment_credential: self.payment_credential,\n    stake_credential: Some(Inline(VerificationKey(vk))),\n  }\n}"
        },
        {
          "name": "with_delegation_script",
          "signature": "pub fn with_delegation_script(pub fn with_delegation_script(self: Address, script: Hash<Blake2b_224, Script>, ) -> Address {",
          "documentation": "Set (or reset) the delegation part of an [Address](#Address) using a [script](#Script) hash. This is useful when combined with [`from_verification_key`](#from_verification_key) and/or [`from_script`](#from_script).",
          "parameters": [],
          "returnType": "Address",
          "line": 49,
          "raw": "pub fn with_delegation_script(pub fn with_delegation_script(self: Address, script: Hash<Blake2b_224, Script>, ) -> Address {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn with_delegation_script(\n  self: Address,\n  script: Hash<Blake2b_224, Script>,\n) -> Address {\n  Address {\n    payment_credential: self.payment_credential,\n    stake_credential: Some(Inline(Script(script))),\n  }\n}"
        }
      ],
      "types": [
        {
          "name": "Credential",
          "definition": "{ VerificationKey(VerificationKeyHash) Script(ScriptHash) }",
          "line": 9,
          "raw": "pub type Credential {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Address",
          "definition": "{ payment_credential: PaymentCredential, stake_credential: Option<StakeCredential>, }",
          "line": 22,
          "raw": "pub type Address {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Referenced<a>",
          "definition": "{ Inline(a) Pointer { slot_number: Int, transaction_index: Int, certificate_index: Int } }",
          "line": 64,
          "raw": "pub type Referenced<a> {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "StakeCredential",
          "definition": "Referenced<Credential>",
          "line": 76,
          "raw": "pub type StakeCredential =",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "PaymentCredential",
          "definition": "Credential",
          "line": 85,
          "raw": "pub type PaymentCredential =",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/crypto.{\n  Blake2b_224, Hash, Script, ScriptHash, VerificationKey, VerificationKeyHash,\n}\n\n/// A general structure for representing an on-chain `Credential`.\n///\n/// Credentials are always one of two kinds: a direct public/private key\n/// pair, or a script (native or Plutus).\npub type Credential {\n  VerificationKey(VerificationKeyHash)\n  Script(ScriptHash)\n}\n\n// ## Constructing\n\n/// A Cardano `Address` typically holding one or two credential references.\n///\n/// Note that legacy bootstrap addresses (a.k.a. 'Byron addresses') are\n/// completely excluded from Plutus contexts. Thus, from an on-chain\n/// perspective only exists addresses of type 00, 01, ..., 07 as detailed\n/// in [CIP-0019 :: Shelley Addresses](https://github.com/cardano-foundation/CIPs/tree/master/CIP-0019/#shelley-addresses).\npub type Address {\n  payment_credential: PaymentCredential,\n  stake_credential: Option<StakeCredential>,\n}\n\n/// Smart-constructor for an [Address](#Address) from a [script](#Script) hash. The address has no delegation rights whatsoever.\npub fn from_script(script: Hash<Blake2b_224, Script>) -> Address {\n  Address { payment_credential: Script(script), stake_credential: None }\n}\n\n/// Smart-constructor for an [Address](#Address) from a [verification key](#VerificationKey) hash. The resulting address has no delegation rights whatsoever.\npub fn from_verification_key(vk: Hash<Blake2b_224, VerificationKey>) -> Address {\n  Address { payment_credential: VerificationKey(vk), stake_credential: None }\n}\n\n/// Set (or reset) the delegation part of an [Address](#Address) using a [verification key](#VerificationKey) hash. This is useful when combined with [`from_verification_key`](#from_verification_key) and/or [`from_script`](#from_script).\npub fn with_delegation_key(\n  self: Address,\n  vk: Hash<Blake2b_224, VerificationKey>,\n) -> Address {\n  Address {\n    payment_credential: self.payment_credential,\n    stake_credential: Some(Inline(VerificationKey(vk))),\n  }\n}\n\n/// Set (or reset) the delegation part of an [Address](#Address) using a [script](#Script) hash. This is useful when combined with [`from_verification_key`](#from_verification_key) and/or [`from_script`](#from_script).\npub fn with_delegation_script(\n  self: Address,\n  script: Hash<Blake2b_224, Script>,\n) -> Address {\n  Address {\n    payment_credential: self.payment_credential,\n    stake_credential: Some(Inline(Script(script))),\n  }\n}\n\n/// Represent a type of object that can be represented either inline (by hash)\n/// or via a reference (i.e. a pointer to an on-chain location).\n///\n/// This is mainly use for capturing pointers to a stake credential\n/// registration certificate in the case of so-called pointer addresses.\npub type Referenced<a> {\n  Inline(a)\n  Pointer { slot_number: Int, transaction_index: Int, certificate_index: Int }\n}\n\n/// A `StakeCredential` represents the delegation and rewards withdrawal conditions\n/// associated with some stake address / account.\n///\n/// A `StakeCredential` is either provided inline, or, by reference using an\n/// on-chain pointer.\n///\n/// Read more about pointers in [CIP-0019 :: Pointers](https://github.com/cardano-foundation/CIPs/tree/master/CIP-0019/#pointers).\npub type StakeCredential =\n  Referenced<Credential>\n\n/// A 'PaymentCredential' represents the spending conditions associated with\n/// some output. Hence,\n///\n/// - a `VerificationKey` captures an output locked by a public/private key pair;\n/// - and a `Script` captures an output locked by a native or Plutus script.\n///\npub type PaymentCredential =\n  Credential\n",
      "dependencies": [],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:cardano.assets.strategy",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/cardano/assets/strategy.ak",
      "name": "cardano.assets.strategy",
      "imports": [
        {
          "module": "aiken/crypto",
          "items": ["Blake2b_224", "Hash", "Script"],
          "line": 1,
          "raw": "use aiken/crypto.{Blake2b_224, Hash, Script}",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "triple",
          "signature": "pub fn triple() -> FlattenStrategy<(Hash<Blake2b_224, Script>, ByteArray, Int)> {",
          "documentation": "Keep all assets, combining them as a 3-tuple.\n\n```aiken\nfn(policy_id, asset_name, quantity, keep, _discard) {\nkeep((policy_id, asset_name, quantity))\n}\n```",
          "parameters": [],
          "returnType": "FlattenStrategy<(Hash<Blake2b_224, Script>, ByteArray, Int)>",
          "line": 31,
          "raw": "pub fn triple() -> FlattenStrategy<(Hash<Blake2b_224, Script>, ByteArray, Int)> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn triple() -> FlattenStrategy<(Hash<Blake2b_224, Script>, ByteArray, Int)> {\n  fn(policy_id, asset_name, quantity, keep, _discard) {\n    keep((policy_id, asset_name, quantity))\n  }\n}"
        }
      ],
      "types": [
        {
          "name": "FlattenStrategy<result>",
          "definition": "fn( Hash<Blake2b_224, Script>, ByteArray, Int, KeepResult<result>, DiscardResult<result>, ) ->",
          "line": 4,
          "raw": "pub type FlattenStrategy<result> =",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "KeepResult<result>",
          "definition": "fn(result) -> List<result>",
          "line": 15,
          "raw": "pub type KeepResult<result> =",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "DiscardResult<result>",
          "definition": "fn() -> List<result>",
          "line": 19,
          "raw": "pub type DiscardResult<result> =",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/crypto.{Blake2b_224, Hash, Script}\n\n/// A strategy for flattening an asset list.\npub type FlattenStrategy<result> =\n  fn(\n    Hash<Blake2b_224, Script>,\n    ByteArray,\n    Int,\n    KeepResult<result>,\n    DiscardResult<result>,\n  ) ->\n    List<result>\n\n/// A callback to keep result at a given key\npub type KeepResult<result> =\n  fn(result) -> List<result>\n\n/// A callback to discard result at a given key\npub type DiscardResult<result> =\n  fn() -> List<result>\n\n// ### Flatten strategies\n\n/// Keep all assets, combining them as a 3-tuple.\n///\n/// ```aiken\n/// fn(policy_id, asset_name, quantity, keep, _discard) {\n///   keep((policy_id, asset_name, quantity))\n/// }\n/// ```\npub fn triple() -> FlattenStrategy<(Hash<Blake2b_224, Script>, ByteArray, Int)> {\n  fn(policy_id, asset_name, quantity, keep, _discard) {\n    keep((policy_id, asset_name, quantity))\n  }\n}\n",
      "dependencies": ["aiken/crypto"],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:cardano.assets",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/cardano/assets.ak",
      "name": "cardano.assets",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 1,
          "raw": "use aiken/builtin",
          "source": "stdlib"
        },
        {
          "module": "aiken/collection/dict",
          "items": ["Dict", "from_ascending_pairs_with"],
          "line": 2,
          "raw": "use aiken/collection/dict.{Dict, from_ascending_pairs_with}",
          "source": "stdlib"
        },
        {
          "module": "aiken/collection/dict/strategy",
          "items": [],
          "alias": "dict_strategy",
          "line": 3,
          "raw": "use aiken/collection/dict/strategy as dict_strategy",
          "source": "stdlib"
        },
        {
          "module": "aiken/collection/list",
          "items": [],
          "line": 4,
          "raw": "use aiken/collection/list",
          "source": "stdlib"
        },
        {
          "module": "aiken/crypto",
          "items": ["Blake2b_224", "Hash", "Script"],
          "line": 5,
          "raw": "use aiken/crypto.{Blake2b_224, Hash, Script}",
          "source": "stdlib"
        },
        {
          "module": "aiken/option",
          "items": [],
          "line": 6,
          "raw": "use aiken/option",
          "source": "stdlib"
        },
        {
          "module": "cardano/assets/strategy",
          "items": ["FlattenStrategy"],
          "line": 7,
          "raw": "use cardano/assets/strategy.{FlattenStrategy}",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "from_asset",
          "signature": "pub fn from_asset(pub fn from_asset(policy_id: PolicyId, asset_name: AssetName, quantity: Int, ) -> Value {",
          "documentation": "Construct a `Value` from an asset identifier (i.e. `PolicyId` + `AssetName`)\nand a given quantity.",
          "parameters": [],
          "returnType": "Value",
          "line": 47,
          "raw": "pub fn from_asset(pub fn from_asset(policy_id: PolicyId, asset_name: AssetName, quantity: Int, ) -> Value {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_asset(\n  policy_id: PolicyId,\n  asset_name: AssetName,\n  quantity: Int,\n) -> Value {\n  if quantity == 0 {\n    zero\n  } else {\n    let asset =\n      dict.empty\n        |> dict.insert(asset_name, quantity)\n    dict.empty\n      |> dict.insert(policy_id, asset)\n      |> Value\n  }\n}"
        },
        {
          "name": "from_asset_list",
          "signature": "pub fn from_asset_list(xs: Pairs<PolicyId, Pairs<AssetName, Int>>) -> Value {",
          "documentation": "Promote an arbitrary list of assets into a `Value`. This function fails\n(i.e. halts the program execution) if:\n\n- there's any duplicate amongst `PolicyId`;\n- there's any duplicate amongst `AssetName`;\n- the `AssetName` aren't sorted in ascending lexicographic order; or\n- any asset quantity is null.\n\nThis function is meant to turn arbitrary user-defined `Data` into safe `Value`,\nwhile checking for internal invariants.",
          "parameters": [
            {
              "name": "xs",
              "type": "Pairs<PolicyId, Pairs<AssetName, Int>>",
              "optional": false
            }
          ],
          "returnType": "Value",
          "line": 74,
          "raw": "pub fn from_asset_list(xs: Pairs<PolicyId, Pairs<AssetName, Int>>) -> Value {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_asset_list(xs: Pairs<PolicyId, Pairs<AssetName, Int>>) -> Value {\n  xs\n    |> list.foldr(\n        dict.empty,\n        fn(inner, acc) {\n          expect Pair(p, [_, ..] as x) = inner\n          x\n            |> from_ascending_pairs_with(fn(v) { v != 0 })\n            |> dict.insert_with(acc, p, _, dict_strategy.expect_no_duplicate())\n        },\n      )\n    |> Value\n}",
          "tests": [
            "test from_asset_list_1() {\n  let v = from_asset_list([])\n  v == zero\n}",
            "test from_asset_list_2() fail {\n  let v = from_asset_list([Pair(#\"33\", [])])\n  v == zero\n}",
            "test from_asset_list_3() fail {\n  let v = from_asset_list([Pair(#\"33\", [Pair(#\"\", 0)])])\n  v != zero\n}",
            "test from_asset_list_4() {\n  let v = from_asset_list([Pair(#\"33\", [Pair(#\"\", 1)])])\n  flatten(v) == [(#\"33\", #\"\", 1)]\n}",
            "test from_asset_list_5() {\n  let v = from_asset_list([Pair(#\"33\", [Pair(#\"\", 1), Pair(#\"33\", 1)])])\n  flatten(v) == [(#\"33\", #\"\", 1), (#\"33\", #\"33\", 1)]\n}",
            "test from_asset_list_6() fail {\n  let v =\n    from_asset_list(\n      [\n        Pair(#\"33\", [Pair(#\"\", 1), Pair(#\"33\", 1)]),\n        Pair(#\"33\", [Pair(#\"\", 1), Pair(#\"33\", 1)]),\n      ],\n    )\n  v != zero\n}",
            "test from_asset_list_7() fail {\n  let v =\n    from_asset_list(\n      [\n        Pair(#\"33\", [Pair(#\"\", 1), Pair(#\"33\", 1)]),\n        Pair(#\"34\", [Pair(#\"\", 1), Pair(#\"\", 1)]),\n      ],\n    )\n  v != zero\n}",
            "test from_asset_list_8() {\n  let v =\n    from_asset_list(\n      [\n        Pair(#\"33\", [Pair(#\"\", 1), Pair(#\"33\", 1)]),\n        Pair(#\"34\", [Pair(#\"31\", 1)]), Pair(#\"35\", [Pair(#\"\", 1)]),\n      ],\n    )\n  flatten(v) == [\n    (#\"33\", #\"\", 1), (#\"33\", #\"33\", 1), (#\"34\", #\"31\", 1), (#\"35\", #\"\", 1),\n  ]\n}",
            "test from_asset_list_9() {\n  let v =\n    from_asset_list(\n      [\n        Pair(#\"35\", [Pair(#\"\", 1)]), Pair(#\"33\", [Pair(#\"\", 1), Pair(#\"33\", 1)]),\n        Pair(#\"34\", [Pair(#\"31\", 1)]),\n      ],\n    )\n  flatten(v) == [\n    (#\"33\", #\"\", 1), (#\"33\", #\"33\", 1), (#\"34\", #\"31\", 1), (#\"35\", #\"\", 1),\n  ]\n}"
          ]
        },
        {
          "name": "from_lovelace",
          "signature": "pub fn from_lovelace(quantity: Int) -> Value {",
          "documentation": "Construct a `Value` from a lovelace quantity.\n\nFriendly reminder: 1 Ada = 1.000.000 Lovelace",
          "parameters": [
            {
              "name": "quantity",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Value",
          "line": 164,
          "raw": "pub fn from_lovelace(quantity: Int) -> Value {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn from_lovelace(quantity: Int) -> Value {\n  from_asset(ada_policy_id, ada_asset_name, quantity)\n}"
        },
        {
          "name": "is_zero",
          "signature": "pub fn is_zero(self: Value) -> Bool {",
          "documentation": "Check is a `Value` is zero. That is, it has no assets and holds no Ada/Lovelace.",
          "parameters": [
            {
              "name": "self",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 174,
          "raw": "pub fn is_zero(self: Value) -> Bool {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn is_zero(self: Value) -> Bool {\n  self == zero\n}"
        },
        {
          "name": "match",
          "signature": "pub fn match(pub fn match(left: Value, right: Data, assert_lovelace: fn(Lovelace, Lovelace) -> Bool,",
          "documentation": "Efficiently compare two values together, allowing a custom behaviour for Ada/Lovelace.\nThe second parameter is provided as `Data`, allowing to conveniently compare serialized\ndatums or similar structurually equivalent types (such as `Pairs<PolicyId, Pairs<AssetName, Lovelace>>`).\n\nThe third argument is a callback function to assert the left and right lovelace\nquantities. Its first argument refers to the quantity of the first argument of\n`match`, and the second argument of the callback to the quantity of the second\nargument of `match`. In the absence of lovelace in any value, it defaults to `0`.\n\n```aiken\nconst value: Value =\nassets.from_lovelace(30)\n|> assets.add(\"foo\", \"bar\", 1)\n|> assets.add(\"foo\", \"baz\", 42)\n\nconst datum: Data =\nassets.from_lovelace(20)\n|> assets.add(\"foo\", \"bar\", 1)\n|> assets.add(\"foo\", \"baz\", 42)\n\nTrue == assets.match(value, datum, >=)\n\nFalse == assets.match(value, datum, ==)\n\nTrue == assets.match(value, datum, fn(value_lovelace, datum_lovelace) {\n2 * datum_lovelace >= value_lovelace\n})\n```",
          "parameters": [],
          "returnType": "Bool,",
          "line": 206,
          "raw": "pub fn match(pub fn match(left: Value, right: Data, assert_lovelace: fn(Lovelace, Lovelace) -> Bool,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn match(\n  left: Value,\n  right: Data,\n  assert_lovelace: fn(Lovelace, Lovelace) -> Bool,\n) -> Bool {\n  builtin.choose_data(\n    right,\n    False,\n    {\n      let (left_lovelace, left_assets) = dict.pop(left.inner, ada_policy_id)\n      let left_assets: Data = left_assets\n      let left_lovelace =\n        when left_lovelace is {\n          Some(tokens) -> builtin.head_list(dict.to_pairs(tokens)).2nd\n          None -> 0\n        }\n      when builtin.un_map_data(right) is {\n        [] -> left_assets == right && assert_lovelace(left_lovelace, 0)\n        [first_asset, ..right_assets] ->\n          if first_asset.1st == builtin.b_data(ada_policy_id) {\n            and {\n              assert_lovelace(\n                left_lovelace,\n                builtin.un_i_data(\n                  builtin.head_list(builtin.un_map_data(first_asset.2nd)).2nd,\n                ),\n              ),\n              left_assets == builtin.map_data(right_assets),\n            }\n          } else {\n            and {\n              assert_lovelace(left_lovelace, 0),\n              left_assets == right,\n            }\n          }\n      }\n    },\n    False,\n    False,\n    False,\n  )\n}",
          "tests": [
            "test match_1() {\n  match(fixture_match_value, fixture_match_data, fn(_, _) { True })\n}",
            "test match_2() {\n  !match(\n    fixture_match_value,\n    fixture_match_data,\n    fn(source, target) { source == target },\n  )\n}",
            "test match_3() {\n  !match(\n    fixture_match_value,\n    fixture_match_data_missing_foo_02,\n    fn(_, _) { True },\n  )\n}",
            "test match_4() {\n  !match(fixture_match_value, fixture_match_data_missing_bar, fn(_, _) { True })\n}",
            "test match_5() {\n  !match(\n    fixture_match_value,\n    fixture_match_data_altered_foo_01,\n    fn(_, _) { True },\n  )\n}",
            "test match_6() {\n  !match(\n    fixture_match_value,\n    fixture_match_data_extra_policy,\n    fn(_, _) { True },\n  )\n}",
            "test match_7() {\n  !match(fixture_match_value, fixture_match_data_extra_asset, fn(_, _) { True })\n}",
            "test match_8() {\n  !match(fixture_match_value, fixture_match_data_no_assets, fn(_, _) { True })\n}",
            "test match_9() {\n  match(zero, zero, ==)\n}",
            "test match_10() {\n  match(\n    without_lovelace(fixture_match_value),\n    without_lovelace(fixture_match_value),\n    fn(left, right) { left == 0 && right == 0 },\n  )\n}",
            "test match_11() {\n  match(\n    without_lovelace(fixture_match_value),\n    fixture_match_value,\n    fn(left, right) { left == 0 && right > 0 },\n  )\n}",
            "test match_12() {\n  match(\n    fixture_match_value,\n    without_lovelace(fixture_match_value),\n    fn(left, right) { left > 0 && right == 0 },\n  )\n}",
            "test match_13() {\n  match(\n    zero |> add(ada_policy_id, ada_asset_name, 42),\n    zero,\n    fn(left, right) { left == 42 && right == 0 },\n  )\n}",
            "test match_14() {\n  match(\n    zero,\n    zero |> add(ada_policy_id, ada_asset_name, 42),\n    fn(left, right) { left == 0 && right == 42 },\n  )\n}",
            "test match_benchmark() {\n  match(fixture_match_benchmark_left, fixture_match_benchmark_right, ==)\n}",
            "test match_benchmark_vs() {\n  let data: Data = fixture_match_benchmark_right\n  expect pairs: Pairs<PolicyId, Pairs<AssetName, Int>> = data\n  fixture_match_benchmark_left == from_asset_list(pairs)\n}"
          ]
        },
        {
          "name": "lovelace_of",
          "signature": "pub fn lovelace_of(self: Value) -> Int {",
          "documentation": "A specialized version of `quantity_of` for the Ada currency.",
          "parameters": [
            {
              "name": "self",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 511,
          "raw": "pub fn lovelace_of(self: Value) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn lovelace_of(self: Value) -> Int {\n  quantity_of(self, ada_policy_id, ada_asset_name)\n}"
        },
        {
          "name": "policies",
          "signature": "pub fn policies(self: Value) -> List<PolicyId> {",
          "documentation": "A list of all token policies in that Value with non-zero tokens.",
          "parameters": [
            {
              "name": "self",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "List<PolicyId>",
          "line": 516,
          "raw": "pub fn policies(self: Value) -> List<PolicyId> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn policies(self: Value) -> List<PolicyId> {\n  dict.keys(self.inner)\n}"
        },
        {
          "name": "quantity_of",
          "signature": "pub fn quantity_of(pub fn quantity_of(self: Value, policy_id: PolicyId, asset_name: AssetName, ) -> Int {",
          "documentation": "Extract the quantity of a given asset.",
          "parameters": [],
          "returnType": "Int",
          "line": 521,
          "raw": "pub fn quantity_of(pub fn quantity_of(self: Value, policy_id: PolicyId, asset_name: AssetName, ) -> Int {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn quantity_of(\n  self: Value,\n  policy_id: PolicyId,\n  asset_name: AssetName,\n) -> Int {\n  self.inner\n    |> dict.get(policy_id)\n    |> option.and_then(dict.get(_, asset_name))\n    |> option.or_else(0)\n}"
        },
        {
          "name": "tokens",
          "signature": "pub fn tokens(self: Value, policy_id: PolicyId) -> Dict<AssetName, Int> {",
          "documentation": "Get all tokens associated with a given policy.",
          "parameters": [
            {
              "name": "self",
              "type": "Value",
              "optional": false
            },
            {
              "name": "policy_id",
              "type": "PolicyId",
              "optional": false
            }
          ],
          "returnType": "Dict<AssetName, Int>",
          "line": 533,
          "raw": "pub fn tokens(self: Value, policy_id: PolicyId) -> Dict<AssetName, Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn tokens(self: Value, policy_id: PolicyId) -> Dict<AssetName, Int> {\n  self.inner\n    |> dict.get(policy_id)\n    |> option.or_else(dict.empty)\n}"
        },
        {
          "name": "add",
          "signature": "pub fn add(pub fn add(self: Value, policy_id: PolicyId, asset_name: AssetName, quantity: Int, ) -> Value {",
          "documentation": "Add a (positive or negative) quantity of a single token to a assets.\nThis is more efficient than [`merge`](#merge) for a single asset.",
          "parameters": [],
          "returnType": "Value",
          "line": 543,
          "raw": "pub fn add(pub fn add(self: Value, policy_id: PolicyId, asset_name: AssetName, quantity: Int, ) -> Value {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn add(\n  self: Value,\n  policy_id: PolicyId,\n  asset_name: AssetName,\n  quantity: Int,\n) -> Value {\n  if quantity == 0 {\n    self\n  } else {\n    let helper =\n      fn(_, left, _right, keep, discard) {\n        let inner_result =\n          dict.insert_with(\n            left,\n            asset_name,\n            quantity,\n            dict_strategy.sum_if_non_zero(),\n          )\n\n        if dict.is_empty(inner_result) {\n          discard()\n        } else {\n          keep(inner_result)\n        }\n      }\n\n    Value(\n      dict.insert_with(\n        self.inner,\n        policy_id,\n        dict.from_ascending_pairs([Pair(asset_name, quantity)]),\n        helper,\n      ),\n    )\n  }\n}",
          "tests": [
            "test add_1() {\n  let v =\n    zero\n      |> add(#\"acab\", #\"beef\", 321)\n      |> add(#\"acab\", #\"beef\", -321)\n  v == zero\n}",
            "test add_2() {\n  let v =\n    from_lovelace(123)\n      |> add(#\"acab\", #\"beef\", 321)\n      |> add(#\"acab\", #\"beef\", -1 * 321)\n  v == from_lovelace(123)\n}",
            "test add_3() {\n  let v =\n    from_lovelace(1)\n      |> add(ada_policy_id, ada_asset_name, 2)\n      |> add(ada_policy_id, ada_asset_name, 3)\n  v == from_lovelace(6)\n}",
            "test add_4() {\n  let v =\n    zero\n      |> add(#\"acab\", #\"beef\", 0)\n  v == zero\n}",
            "test add_5() {\n  let v =\n    zero\n      |> add(#\"acab\", #\"beef\", 0)\n      |> add(#\"acab\", #\"beef\", 0)\n  v == zero\n}"
          ]
        },
        {
          "name": "merge",
          "signature": "pub fn merge(left v0: Value, right v1: Value) -> Value {",
          "documentation": "Combine two `Value` together.",
          "parameters": [],
          "returnType": "Value",
          "line": 620,
          "raw": "pub fn merge(left v0: Value, right v1: Value) -> Value {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn merge(left v0: Value, right v1: Value) -> Value {\n  Value(\n    dict.union_with(\n      v0.inner,\n      v1.inner,\n      fn(_, a0, a1, keep, discard) {\n        let result = dict.union_with(a0, a1, dict_strategy.sum_if_non_zero())\n        if dict.is_empty(result) {\n          discard()\n        } else {\n          keep(result)\n        }\n      },\n    ),\n  )\n}",
          "tests": [
            "test merge_1() {\n  let v1 = from_lovelace(1)\n  let v2 = from_lovelace(-1)\n  merge(v1, v2) == zero\n}",
            "test merge_2() {\n  let v1 = from_asset(#\"00\", #\"\", 1)\n  let v2 = from_asset(#\"01\", #\"\", 2)\n  let v3 = from_asset(#\"02\", #\"\", 3)\n  let v =\n    from_lovelace(42)\n      |> merge(v3)\n      |> merge(v1)\n      |> merge(v2)\n\n  flatten(v) == [\n    (#\"\", #\"\", 42), (#\"00\", #\"\", 1), (#\"01\", #\"\", 2), (#\"02\", #\"\", 3),\n  ]\n}",
            "test merge_3() {\n  let v1 = from_asset(#\"00\", #\"\", 1)\n  let v2 = from_asset(#\"00\", #\"\", -1)\n  let v3 = from_asset(#\"01\", #\"\", 1)\n\n  let v =\n    zero\n      |> merge(v1)\n      |> merge(v2)\n      |> merge(v3)\n\n  flatten(v) == [(#\"01\", #\"\", 1)]\n}",
            "test merge_4() {\n  let v1 = from_asset(#\"00\", #\"\", 1)\n  let v2 = from_asset(#\"00\", #\"\", -1)\n\n  merge(v1, v2) == zero\n}",
            "test merge_5() {\n  let v =\n    zero\n      |> add(#\"acab\", #\"beef\", 0)\n\n  merge(zero, v) == zero\n}"
          ]
        },
        {
          "name": "negate",
          "signature": "pub fn negate(self: Value) -> Value {",
          "documentation": "Negates quantities of all tokens (including Ada) in that `Value`.\n\n```\nv1\n|> assets.negate\n|> assets.merge(v1)\n|> assets.is_zero\n// True\n```",
          "parameters": [
            {
              "name": "self",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "Value",
          "line": 696,
          "raw": "pub fn negate(self: Value) -> Value {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn negate(self: Value) -> Value {\n  dict.map(self.inner, fn(_, a) { dict.map(a, fn(_, q) { 0 - q }) })\n    |> Value\n}"
        },
        {
          "name": "restricted_to",
          "signature": "pub fn restricted_to(self: Value, mask: List<PolicyId>) -> Value {",
          "documentation": "Get a subset of the assets restricted to the given policies.",
          "parameters": [
            {
              "name": "self",
              "type": "Value",
              "optional": false
            },
            {
              "name": "mask",
              "type": "List<PolicyId>",
              "optional": false
            }
          ],
          "returnType": "Value",
          "line": 702,
          "raw": "pub fn restricted_to(self: Value, mask: List<PolicyId>) -> Value {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn restricted_to(self: Value, mask: List<PolicyId>) -> Value {\n  list.foldr(\n    policies(self),\n    zero,\n    fn(policy_id, value) {\n      if list.has(mask, policy_id) {\n        dict.foldr(\n          tokens(self, policy_id),\n          value,\n          fn(asset_name, quantity, value) {\n            add(value, policy_id, asset_name, quantity)\n          },\n        )\n      } else {\n        value\n      }\n    },\n  )\n}",
          "tests": [
            "test restricted_to_1() {\n  let self = from_lovelace(42) |> add(\"foo\", \"\", 1)\n  restricted_to(self, []) == zero\n}",
            "test restricted_to_2() {\n  let self = from_lovelace(42) |> add(\"foo\", \"\", 1)\n  restricted_to(self, [ada_policy_id]) == from_lovelace(42)\n}",
            "test restricted_to_3() {\n  let self = from_lovelace(42) |> add(\"foo\", \"\", 1) |> add(\"bar\", \"\", 1)\n  restricted_to(self, [\"foo\", \"bar\"]) == without_lovelace(self)\n}",
            "test restricted_to_4() {\n  let self = from_lovelace(42) |> add(\"foo\", \"bar\", 1) |> add(\"foo\", \"baz\", 1)\n  restricted_to(self, [\"foo\"]) == without_lovelace(self)\n}",
            "test restricted_to_5() {\n  let self = from_lovelace(42) |> add(\"foo\", \"bar\", 1) |> add(\"foo\", \"baz\", 1)\n  restricted_to(self, [ada_policy_id, \"foo\"]) == self\n}"
          ]
        },
        {
          "name": "without_lovelace",
          "signature": "pub fn without_lovelace(self: Value) -> Value {",
          "documentation": "Get a `Value` excluding Ada.",
          "parameters": [
            {
              "name": "self",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "Value",
          "line": 748,
          "raw": "pub fn without_lovelace(self: Value) -> Value {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn without_lovelace(self: Value) -> Value {\n  dict.delete(self.inner, ada_policy_id)\n    |> Value\n}",
          "tests": [
            "test without_lovelace_1() {\n  let v = from_lovelace(1000000)\n  without_lovelace(v) == zero\n}",
            "test without_lovelace_2() {\n  let v = from_lovelace(1000000)\n  let v2 = from_lovelace(50000000)\n  without_lovelace(v) == without_lovelace(v2)\n}",
            "test without_lovelace_3() {\n  let v =\n    from_asset(#\"010203\", #\"040506\", 100)\n      |> add(ada_policy_id, ada_asset_name, 100000000)\n  let v2 = from_asset(#\"010203\", #\"040506\", 100)\n  without_lovelace(v) == without_lovelace(v2) && without_lovelace(v) == v2\n}"
          ]
        },
        {
          "name": "flatten",
          "signature": "pub fn flatten(self: Value) -> List<(PolicyId, AssetName, Int)> {",
          "documentation": "Flatten a `Value` as list of 3-tuple `(PolicyId, AssetName, Quantity)`.\n\nHandy to manipulate values as uniform lists.",
          "parameters": [
            {
              "name": "self",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "List<(PolicyId, AssetName, Int)>",
          "line": 777,
          "raw": "pub fn flatten(self: Value) -> List<(PolicyId, AssetName, Int)> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn flatten(self: Value) -> List<(PolicyId, AssetName, Int)> {\n  dict.foldr(\n    self.inner,\n    [],\n    fn(policy_id, asset_list, value) {\n      dict.foldr(\n        asset_list,\n        value,\n        fn(asset_name, quantity, xs) {\n          [(policy_id, asset_name, quantity), ..xs]\n        },\n      )\n    },\n  )\n}"
        },
        {
          "name": "flatten_with",
          "signature": "pub fn flatten_with(self: Value, with: FlattenStrategy<result>) -> List<result> {",
          "documentation": "Flatten a `Value` as a list of results, possibly discarding some along the way.\n\nWhen the transform function returns `None`, the result is discarded altogether.",
          "parameters": [
            {
              "name": "self",
              "type": "Value",
              "optional": false
            },
            {
              "name": "with",
              "type": "FlattenStrategy<result>",
              "optional": false
            }
          ],
          "returnType": "List<result>",
          "line": 796,
          "raw": "pub fn flatten_with(self: Value, with: FlattenStrategy<result>) -> List<result> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn flatten_with(self: Value, with: FlattenStrategy<result>) -> List<result> {\n  dict.foldr(\n    self.inner,\n    [],\n    fn(policy_id, asset_list, value) {\n      dict.foldr(\n        asset_list,\n        value,\n        fn(asset_name, quantity, xs) {\n          with(\n            policy_id,\n            asset_name,\n            quantity,\n            fn(x) { [x, ..xs] },\n            fn() { xs },\n          )\n        },\n      )\n    },\n  )\n}",
          "tests": [
            "test flatten_with_1() {\n  flatten_with(zero, strategy.triple()) == []\n}",
            "test flatten_with_2() {\n  let v =\n    zero\n      |> add(\"a\", \"1\", 14)\n      |> add(\"b\", \"\", 42)\n      |> add(\"a\", \"2\", 42)\n\n  flatten_with(\n    v,\n    fn(p, a, q, keep, discard) {\n      if q == 42 {\n        keep((p, a))\n      } else {\n        discard()\n      }\n    },\n  ) == [(\"a\", \"2\"), (\"b\", \"\")]\n}"
          ]
        },
        {
          "name": "reduce",
          "signature": "pub fn reduce(pub fn reduce(self: Value, start: result, with: fn(PolicyId, AssetName, Int, result) -> result,",
          "documentation": "Reduce a value into a single result\n\n```\nassets.zero\n|> assets.add(\"a\", \"1\", 10)\n|> assets.add(\"b\", \"2\", 20)\n|> assets.reduce(v, 0, fn(_, _, quantity, acc) { acc + quantity })\n// 30\n```",
          "parameters": [],
          "returnType": "result,",
          "line": 850,
          "raw": "pub fn reduce(pub fn reduce(self: Value, start: result, with: fn(PolicyId, AssetName, Int, result) -> result,",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn reduce(\n  self: Value,\n  start: result,\n  with: fn(PolicyId, AssetName, Int, result) -> result,\n) -> result {\n  dict.foldr(\n    self.inner,\n    start,\n    fn(policy_id, asset_list, result) {\n      dict.foldr(asset_list, result, with(policy_id, _, _, _))\n    },\n  )\n}",
          "tests": [
            "test reduce_1() {\n  let v =\n    zero\n      |> add(\"a\", \"1\", 10)\n      |> add(\"b\", \"2\", 20)\n  let result = reduce(v, 0, fn(_, _, quantity, acc) { acc + quantity })\n  result == 30\n}",
            "test reduce_2() {\n  let v =\n    zero\n      |> add(\"a\", \"1\", 5)\n      |> add(\"a\", \"2\", 15)\n      |> add(\"b\", \"\", 10)\n  let result =\n    reduce(\n      v,\n      [],\n      fn(policy_id, asset_name, _, acc) { [(policy_id, asset_name), ..acc] },\n    )\n  result == [(\"a\", \"1\"), (\"a\", \"2\"), (\"b\", \"\")]\n}",
            "test reduce_3() {\n  let v = zero\n  let result = reduce(v, 1, fn(_, _, quantity, acc) { acc + quantity })\n  result == 1\n}"
          ]
        },
        {
          "name": "to_dict",
          "signature": "pub fn to_dict(self: Value) -> Dict<PolicyId, Dict<AssetName, Int>> {",
          "documentation": "Convert the value into a dictionary of dictionaries.",
          "parameters": [
            {
              "name": "self",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "Dict<PolicyId, Dict<AssetName, Int>>",
          "line": 895,
          "raw": "pub fn to_dict(self: Value) -> Dict<PolicyId, Dict<AssetName, Int>> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn to_dict(self: Value) -> Dict<PolicyId, Dict<AssetName, Int>> {\n  self.inner\n}"
        }
      ],
      "types": [
        {
          "name": "Lovelace",
          "definition": "Int",
          "line": 10,
          "raw": "pub type Lovelace =",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "PolicyId",
          "definition": "Hash<Blake2b_224, Script>",
          "line": 14,
          "raw": "pub type PolicyId =",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "AssetName",
          "definition": "ByteArray",
          "line": 25,
          "raw": "pub type AssetName =",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Value",
          "definition": "opaque { inner: Dict<PolicyId, Dict<AssetName, Int>>, }",
          "line": 39,
          "raw": "pub opaque type Value {",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "constants": [
        {
          "name": "ada_policy_id",
          "type": "Unknown",
          "value": "\"\"",
          "line": 21,
          "raw": "pub const ada_policy_id = \"\"",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "ada_asset_name",
          "type": "Unknown",
          "value": "\"\"",
          "line": 32,
          "raw": "pub const ada_asset_name = \"\"",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "zero",
          "type": "Value",
          "value": "Value { inner: dict.empty }",
          "line": 169,
          "raw": "pub const zero: Value = Value { inner: dict.empty }",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [
        {
          "name": "fixture_match_benchmark_right",
          "type": "Data",
          "value": "fixture_match_benchmark_left",
          "line": 498,
          "raw": "const fixture_match_benchmark_right: Data = fixture_match_benchmark_left",
          "isPublic": false,
          "source": "stdlib"
        }
      ],
      "content": "use aiken/builtin\nuse aiken/collection/dict.{Dict, from_ascending_pairs_with}\nuse aiken/collection/dict/strategy as dict_strategy\nuse aiken/collection/list\nuse aiken/crypto.{Blake2b_224, Hash, Script}\nuse aiken/option\nuse cardano/assets/strategy.{FlattenStrategy}\n\n/// Lovelace is now a type wrapper for Int.\npub type Lovelace =\n  Int\n\n/// A type-alias for a `PolicyId`. A `PolicyId` is always 28-byte long\npub type PolicyId =\n  Hash<Blake2b_224, Script>\n\n/// Ada, the native currency, isn't associated with any `PolicyId` (it's not\n/// possible to mint Ada!).\n///\n/// By convention, it is an empty `ByteArray`.\npub const ada_policy_id = \"\"\n\n/// A type-alias for 'AssetName`, which are free-form byte-arrays between\n/// 0 and 32 bytes.\npub type AssetName =\n  ByteArray\n\n/// Ada, the native currency, isn't associated with any `AssetName` (it's not\n/// possible to mint Ada!).\n///\n/// By convention, it is an empty `ByteArray`.\npub const ada_asset_name = \"\"\n\n/// A multi-asset output `Value`. Contains tokens indexed by [PolicyId](#PolicyId) and [AssetName](#AssetName).\n///\n/// > [!IMPORTANT]\n/// > This type maintain some invariants by construction; in particular, a `Value` will never contain a\n/// zero quantity of a particular token.\npub opaque type Value {\n  inner: Dict<PolicyId, Dict<AssetName, Int>>,\n}\n\n// ## Constructing\n\n/// Construct a `Value` from an asset identifier (i.e. `PolicyId` + `AssetName`)\n/// and a given quantity.\npub fn from_asset(\n  policy_id: PolicyId,\n  asset_name: AssetName,\n  quantity: Int,\n) -> Value {\n  if quantity == 0 {\n    zero\n  } else {\n    let asset =\n      dict.empty\n        |> dict.insert(asset_name, quantity)\n    dict.empty\n      |> dict.insert(policy_id, asset)\n      |> Value\n  }\n}\n\n/// Promote an arbitrary list of assets into a `Value`. This function fails\n/// (i.e. halts the program execution) if:\n///\n/// - there's any duplicate amongst `PolicyId`;\n/// - there's any duplicate amongst `AssetName`;\n/// - the `AssetName` aren't sorted in ascending lexicographic order; or\n/// - any asset quantity is null.\n///\n/// This function is meant to turn arbitrary user-defined `Data` into safe `Value`,\n/// while checking for internal invariants.\npub fn from_asset_list(xs: Pairs<PolicyId, Pairs<AssetName, Int>>) -> Value {\n  xs\n    |> list.foldr(\n        dict.empty,\n        fn(inner, acc) {\n          expect Pair(p, [_, ..] as x) = inner\n          x\n            |> from_ascending_pairs_with(fn(v) { v != 0 })\n            |> dict.insert_with(acc, p, _, dict_strategy.expect_no_duplicate())\n        },\n      )\n    |> Value\n}\n\ntest from_asset_list_1() {\n  let v = from_asset_list([])\n  v == zero\n}\n\ntest from_asset_list_2() fail {\n  let v = from_asset_list([Pair(#\"33\", [])])\n  v == zero\n}\n\ntest from_asset_list_3() fail {\n  let v = from_asset_list([Pair(#\"33\", [Pair(#\"\", 0)])])\n  v != zero\n}\n\ntest from_asset_list_4() {\n  let v = from_asset_list([Pair(#\"33\", [Pair(#\"\", 1)])])\n  flatten(v) == [(#\"33\", #\"\", 1)]\n}\n\ntest from_asset_list_5() {\n  let v = from_asset_list([Pair(#\"33\", [Pair(#\"\", 1), Pair(#\"33\", 1)])])\n  flatten(v) == [(#\"33\", #\"\", 1), (#\"33\", #\"33\", 1)]\n}\n\ntest from_asset_list_6() fail {\n  let v =\n    from_asset_list(\n      [\n        Pair(#\"33\", [Pair(#\"\", 1), Pair(#\"33\", 1)]),\n        Pair(#\"33\", [Pair(#\"\", 1), Pair(#\"33\", 1)]),\n      ],\n    )\n  v != zero\n}\n\ntest from_asset_list_7() fail {\n  let v =\n    from_asset_list(\n      [\n        Pair(#\"33\", [Pair(#\"\", 1), Pair(#\"33\", 1)]),\n        Pair(#\"34\", [Pair(#\"\", 1), Pair(#\"\", 1)]),\n      ],\n    )\n  v != zero\n}\n\ntest from_asset_list_8() {\n  let v =\n    from_asset_list(\n      [\n        Pair(#\"33\", [Pair(#\"\", 1), Pair(#\"33\", 1)]),\n        Pair(#\"34\", [Pair(#\"31\", 1)]), Pair(#\"35\", [Pair(#\"\", 1)]),\n      ],\n    )\n  flatten(v) == [\n    (#\"33\", #\"\", 1), (#\"33\", #\"33\", 1), (#\"34\", #\"31\", 1), (#\"35\", #\"\", 1),\n  ]\n}\n\ntest from_asset_list_9() {\n  let v =\n    from_asset_list(\n      [\n        Pair(#\"35\", [Pair(#\"\", 1)]), Pair(#\"33\", [Pair(#\"\", 1), Pair(#\"33\", 1)]),\n        Pair(#\"34\", [Pair(#\"31\", 1)]),\n      ],\n    )\n  flatten(v) == [\n    (#\"33\", #\"\", 1), (#\"33\", #\"33\", 1), (#\"34\", #\"31\", 1), (#\"35\", #\"\", 1),\n  ]\n}\n\n/// Construct a `Value` from a lovelace quantity.\n///\n/// Friendly reminder: 1 Ada = 1.000.000 Lovelace\npub fn from_lovelace(quantity: Int) -> Value {\n  from_asset(ada_policy_id, ada_asset_name, quantity)\n}\n\n/// Construct an empty `Value` with nothing in it.\npub const zero: Value = Value { inner: dict.empty }\n\n// ## Inspecting\n\n/// Check is a `Value` is zero. That is, it has no assets and holds no Ada/Lovelace.\npub fn is_zero(self: Value) -> Bool {\n  self == zero\n}\n\n/// Efficiently compare two values together, allowing a custom behaviour for Ada/Lovelace.\n/// The second parameter is provided as `Data`, allowing to conveniently compare serialized\n/// datums or similar structurually equivalent types (such as `Pairs<PolicyId, Pairs<AssetName, Lovelace>>`).\n///\n/// The third argument is a callback function to assert the left and right lovelace\n/// quantities. Its first argument refers to the quantity of the first argument of\n/// `match`, and the second argument of the callback to the quantity of the second\n/// argument of `match`. In the absence of lovelace in any value, it defaults to `0`.\n///\n/// ```aiken\n/// const value: Value =\n///   assets.from_lovelace(30)\n///     |> assets.add(\"foo\", \"bar\", 1)\n///     |> assets.add(\"foo\", \"baz\", 42)\n///\n/// const datum: Data =\n///   assets.from_lovelace(20)\n///     |> assets.add(\"foo\", \"bar\", 1)\n///     |> assets.add(\"foo\", \"baz\", 42)\n///\n/// True == assets.match(value, datum, >=)\n///\n/// False == assets.match(value, datum, ==)\n///\n/// True == assets.match(value, datum, fn(value_lovelace, datum_lovelace) {\n///   2 * datum_lovelace >= value_lovelace\n/// })\n/// ```\npub fn match(\n  left: Value,\n  right: Data,\n  assert_lovelace: fn(Lovelace, Lovelace) -> Bool,\n) -> Bool {\n  builtin.choose_data(\n    right,\n    False,\n    {\n      let (left_lovelace, left_assets) = dict.pop(left.inner, ada_policy_id)\n      let left_assets: Data = left_assets\n      let left_lovelace =\n        when left_lovelace is {\n          Some(tokens) -> builtin.head_list(dict.to_pairs(tokens)).2nd\n          None -> 0\n        }\n      when builtin.un_map_data(right) is {\n        [] -> left_assets == right && assert_lovelace(left_lovelace, 0)\n        [first_asset, ..right_assets] ->\n          if first_asset.1st == builtin.b_data(ada_policy_id) {\n            and {\n              assert_lovelace(\n                left_lovelace,\n                builtin.un_i_data(\n                  builtin.head_list(builtin.un_map_data(first_asset.2nd)).2nd,\n                ),\n              ),\n              left_assets == builtin.map_data(right_assets),\n            }\n          } else {\n            and {\n              assert_lovelace(left_lovelace, 0),\n              left_assets == right,\n            }\n          }\n      }\n    },\n    False,\n    False,\n    False,\n  )\n}\n\nconst fixture_match_value: Value =\n  zero\n    |> add(ada_policy_id, ada_asset_name, 42)\n    |> add(\"foo\", \"01\", 1)\n    |> add(\"foo\", \"02\", 1)\n    |> add(\"bar\", \"01\", 42)\n\nconst fixture_match_data: Data =\n  zero\n    |> add(ada_policy_id, ada_asset_name, 14)\n    |> add(\"foo\", \"01\", 1)\n    |> add(\"foo\", \"02\", 1)\n    |> add(\"bar\", \"01\", 42)\n\nconst fixture_match_data_missing_foo_02: Data =\n  zero\n    |> add(ada_policy_id, ada_asset_name, 14)\n    |> add(\"foo\", \"01\", 1)\n    |> add(\"bar\", \"01\", 42)\n\nconst fixture_match_data_altered_foo_01: Data =\n  zero\n    |> add(ada_policy_id, ada_asset_name, 14)\n    |> add(\"foo\", \"01\", 14)\n    |> add(\"foo\", \"02\", 1)\n    |> add(\"bar\", \"01\", 42)\n\nconst fixture_match_data_missing_bar: Data =\n  zero\n    |> add(ada_policy_id, ada_asset_name, 14)\n    |> add(\"foo\", \"01\", 1)\n    |> add(\"foo\", \"02\", 1)\n\nconst fixture_match_data_extra_policy: Data =\n  zero\n    |> add(ada_policy_id, ada_asset_name, 14)\n    |> add(\"foo\", \"01\", 1)\n    |> add(\"foo\", \"02\", 1)\n    |> add(\"bar\", \"01\", 42)\n    |> add(\"baz\", \"01\", 1)\n\nconst fixture_match_data_extra_asset: Data =\n  zero\n    |> add(ada_policy_id, ada_asset_name, 14)\n    |> add(\"foo\", \"01\", 1)\n    |> add(\"foo\", \"02\", 1)\n    |> add(\"foo\", \"03\", 1)\n    |> add(\"bar\", \"01\", 42)\n\nconst fixture_match_data_no_assets: Data =\n  zero\n    |> add(ada_policy_id, ada_asset_name, 14)\n\ntest match_1() {\n  match(fixture_match_value, fixture_match_data, fn(_, _) { True })\n}\n\ntest match_2() {\n  !match(\n    fixture_match_value,\n    fixture_match_data,\n    fn(source, target) { source == target },\n  )\n}\n\ntest match_3() {\n  !match(\n    fixture_match_value,\n    fixture_match_data_missing_foo_02,\n    fn(_, _) { True },\n  )\n}\n\ntest match_4() {\n  !match(fixture_match_value, fixture_match_data_missing_bar, fn(_, _) { True })\n}\n\ntest match_5() {\n  !match(\n    fixture_match_value,\n    fixture_match_data_altered_foo_01,\n    fn(_, _) { True },\n  )\n}\n\ntest match_6() {\n  !match(\n    fixture_match_value,\n    fixture_match_data_extra_policy,\n    fn(_, _) { True },\n  )\n}\n\ntest match_7() {\n  !match(fixture_match_value, fixture_match_data_extra_asset, fn(_, _) { True })\n}\n\ntest match_8() {\n  !match(fixture_match_value, fixture_match_data_no_assets, fn(_, _) { True })\n}\n\ntest match_9() {\n  match(zero, zero, ==)\n}\n\ntest match_10() {\n  match(\n    without_lovelace(fixture_match_value),\n    without_lovelace(fixture_match_value),\n    fn(left, right) { left == 0 && right == 0 },\n  )\n}\n\ntest match_11() {\n  match(\n    without_lovelace(fixture_match_value),\n    fixture_match_value,\n    fn(left, right) { left == 0 && right > 0 },\n  )\n}\n\ntest match_12() {\n  match(\n    fixture_match_value,\n    without_lovelace(fixture_match_value),\n    fn(left, right) { left > 0 && right == 0 },\n  )\n}\n\ntest match_13() {\n  match(\n    zero |> add(ada_policy_id, ada_asset_name, 42),\n    zero,\n    fn(left, right) { left == 42 && right == 0 },\n  )\n}\n\ntest match_14() {\n  match(\n    zero,\n    zero |> add(ada_policy_id, ada_asset_name, 42),\n    fn(left, right) { left == 0 && right == 42 },\n  )\n}\n\nconst fixture_match_benchmark_left: Value =\n  zero\n    |> add(ada_policy_id, ada_asset_name, 1337)\n    |> add(\n        #\"0246a14d04c3a0e9b65f6b90a3d1aa5faee5d56ab1e30ec7e8b02f29\",\n        \"MATTR\",\n        200,\n      )\n    |> add(\n        #\"0a9e126256cb38c4865cdac6eb2ada51c328ba0df2ebde22ae126c0d\",\n        \"ProphecyPoster076\",\n        1,\n      )\n    |> add(\n        #\"1774343241680e4daef7cbfe3536fc857ce23fb66cd0b66320b2e3dd\",\n        \"BISON\",\n        12_004_999_999,\n      )\n    |> add(\n        #\"279c909f348e533da5808898f87f9a14bb2c3dfbbacccd631d927a3f\",\n        \"SNEK\",\n        1486,\n      )\n    |> add(\n        #\"651dfc074202423585996ffa717cb45237d307e705e2cc3dab1ccabd\",\n        \"MAYZSilverFoundersEdition0035\",\n        1,\n      )\n    |> add(\n        #\"63df49056617dd14034986cf7c250bad6552fd2f0f9c71d797932008\",\n        \"CardanoSpaceSession\",\n        20,\n      )\n    |> add(\n        #\"5b01968867e13432afaa2f814e1d15e332d6cd0aa77e350972b0967d\",\n        \"ADAOGovernanceToken\",\n        1,\n      )\n    |> add(\n        #\"a0028f350aaabe0545fdcb56b039bfb08e4bb4d8c4d7c3c7d481c235\",\n        \"HOSKY\",\n        400_001_000,\n      )\n    |> add(\n        #\"da8c30857834c6ae7203935b89278c532b3995245295456f993e1d24\",\n        \"LQ\",\n        10_635_899,\n      )\n    |> add(\n        #\"95d9a98c2f7999a3d5e0f4d795cb1333837c09eb0f24835cd2ce954c\",\n        \"GrandmasterAdventurer659\",\n        1,\n      )\n    |> add(\n        #\"702cbdb06a81ef2fa4f85f9e32159c03f502539d762a71194fc11eb3\",\n        \"AdventurerOfThiolden8105\",\n        1,\n      )\n    |> add(\n        #\"d0112837f8f856b2ca14f69b375bc394e73d146fdadcc993bb993779\",\n        \"DiscoSolaris3725\",\n        1,\n      )\n    |> add(\n        #\"8dd5717e7d4d993019dbd788c19837910e3fcf647ab282f828c80a7a\",\n        \"CardaWorld535\",\n        1,\n      )\n    |> add(\n        #\"8dd5717e7d4d993019dbd788c19837910e3fcf647ab282f828c80a7a\",\n        \"CardaWorld1213\",\n        1,\n      )\n    |> add(\n        #\"8dd5717e7d4d993019dbd788c19837910e3fcf647ab282f828c80a7a\",\n        \"CardaWorld1518\",\n        1,\n      )\n    |> add(\n        #\"8dd5717e7d4d993019dbd788c19837910e3fcf647ab282f828c80a7a\",\n        \"CardaWorld1537\",\n        1,\n      )\n    |> add(\n        #\"8dd5717e7d4d993019dbd788c19837910e3fcf647ab282f828c80a7a\",\n        \"CardaWorld4199\",\n        1,\n      )\n    |> add(\n        #\"8dd5717e7d4d993019dbd788c19837910e3fcf647ab282f828c80a7a\",\n        \"CardaWorld3767\",\n        1,\n      )\n    |> add(\n        #\"7597444754551a8c17edbf7291cdaeca898ca02ee4e732b09a949396\",\n        \"Algae1\",\n        1,\n      )\n    |> add(\n        #\"7597444754551a8c17edbf7291cdaeca898ca02ee4e732b09a949396\",\n        \"Algae2\",\n        1,\n      )\n\nconst fixture_match_benchmark_right: Data = fixture_match_benchmark_left\n\ntest match_benchmark() {\n  match(fixture_match_benchmark_left, fixture_match_benchmark_right, ==)\n}\n\ntest match_benchmark_vs() {\n  let data: Data = fixture_match_benchmark_right\n  expect pairs: Pairs<PolicyId, Pairs<AssetName, Int>> = data\n  fixture_match_benchmark_left == from_asset_list(pairs)\n}\n\n/// A specialized version of `quantity_of` for the Ada currency.\npub fn lovelace_of(self: Value) -> Int {\n  quantity_of(self, ada_policy_id, ada_asset_name)\n}\n\n/// A list of all token policies in that Value with non-zero tokens.\npub fn policies(self: Value) -> List<PolicyId> {\n  dict.keys(self.inner)\n}\n\n/// Extract the quantity of a given asset.\npub fn quantity_of(\n  self: Value,\n  policy_id: PolicyId,\n  asset_name: AssetName,\n) -> Int {\n  self.inner\n    |> dict.get(policy_id)\n    |> option.and_then(dict.get(_, asset_name))\n    |> option.or_else(0)\n}\n\n/// Get all tokens associated with a given policy.\npub fn tokens(self: Value, policy_id: PolicyId) -> Dict<AssetName, Int> {\n  self.inner\n    |> dict.get(policy_id)\n    |> option.or_else(dict.empty)\n}\n\n// ## Combining\n\n/// Add a (positive or negative) quantity of a single token to a assets.\n/// This is more efficient than [`merge`](#merge) for a single asset.\npub fn add(\n  self: Value,\n  policy_id: PolicyId,\n  asset_name: AssetName,\n  quantity: Int,\n) -> Value {\n  if quantity == 0 {\n    self\n  } else {\n    let helper =\n      fn(_, left, _right, keep, discard) {\n        let inner_result =\n          dict.insert_with(\n            left,\n            asset_name,\n            quantity,\n            dict_strategy.sum_if_non_zero(),\n          )\n\n        if dict.is_empty(inner_result) {\n          discard()\n        } else {\n          keep(inner_result)\n        }\n      }\n\n    Value(\n      dict.insert_with(\n        self.inner,\n        policy_id,\n        dict.from_ascending_pairs([Pair(asset_name, quantity)]),\n        helper,\n      ),\n    )\n  }\n}\n\ntest add_1() {\n  let v =\n    zero\n      |> add(#\"acab\", #\"beef\", 321)\n      |> add(#\"acab\", #\"beef\", -321)\n  v == zero\n}\n\ntest add_2() {\n  let v =\n    from_lovelace(123)\n      |> add(#\"acab\", #\"beef\", 321)\n      |> add(#\"acab\", #\"beef\", -1 * 321)\n  v == from_lovelace(123)\n}\n\ntest add_3() {\n  let v =\n    from_lovelace(1)\n      |> add(ada_policy_id, ada_asset_name, 2)\n      |> add(ada_policy_id, ada_asset_name, 3)\n  v == from_lovelace(6)\n}\n\ntest add_4() {\n  let v =\n    zero\n      |> add(#\"acab\", #\"beef\", 0)\n  v == zero\n}\n\ntest add_5() {\n  let v =\n    zero\n      |> add(#\"acab\", #\"beef\", 0)\n      |> add(#\"acab\", #\"beef\", 0)\n  v == zero\n}\n\n/// Combine two `Value` together.\npub fn merge(left v0: Value, right v1: Value) -> Value {\n  Value(\n    dict.union_with(\n      v0.inner,\n      v1.inner,\n      fn(_, a0, a1, keep, discard) {\n        let result = dict.union_with(a0, a1, dict_strategy.sum_if_non_zero())\n        if dict.is_empty(result) {\n          discard()\n        } else {\n          keep(result)\n        }\n      },\n    ),\n  )\n}\n\ntest merge_1() {\n  let v1 = from_lovelace(1)\n  let v2 = from_lovelace(-1)\n  merge(v1, v2) == zero\n}\n\ntest merge_2() {\n  let v1 = from_asset(#\"00\", #\"\", 1)\n  let v2 = from_asset(#\"01\", #\"\", 2)\n  let v3 = from_asset(#\"02\", #\"\", 3)\n  let v =\n    from_lovelace(42)\n      |> merge(v3)\n      |> merge(v1)\n      |> merge(v2)\n\n  flatten(v) == [\n    (#\"\", #\"\", 42), (#\"00\", #\"\", 1), (#\"01\", #\"\", 2), (#\"02\", #\"\", 3),\n  ]\n}\n\ntest merge_3() {\n  let v1 = from_asset(#\"00\", #\"\", 1)\n  let v2 = from_asset(#\"00\", #\"\", -1)\n  let v3 = from_asset(#\"01\", #\"\", 1)\n\n  let v =\n    zero\n      |> merge(v1)\n      |> merge(v2)\n      |> merge(v3)\n\n  flatten(v) == [(#\"01\", #\"\", 1)]\n}\n\ntest merge_4() {\n  let v1 = from_asset(#\"00\", #\"\", 1)\n  let v2 = from_asset(#\"00\", #\"\", -1)\n\n  merge(v1, v2) == zero\n}\n\ntest merge_5() {\n  let v =\n    zero\n      |> add(#\"acab\", #\"beef\", 0)\n\n  merge(zero, v) == zero\n}\n\n/// Negates quantities of all tokens (including Ada) in that `Value`.\n///\n/// ```\n/// v1\n///   |> assets.negate\n///   |> assets.merge(v1)\n///   |> assets.is_zero\n/// // True\n/// ```\npub fn negate(self: Value) -> Value {\n  dict.map(self.inner, fn(_, a) { dict.map(a, fn(_, q) { 0 - q }) })\n    |> Value\n}\n\n/// Get a subset of the assets restricted to the given policies.\npub fn restricted_to(self: Value, mask: List<PolicyId>) -> Value {\n  list.foldr(\n    policies(self),\n    zero,\n    fn(policy_id, value) {\n      if list.has(mask, policy_id) {\n        dict.foldr(\n          tokens(self, policy_id),\n          value,\n          fn(asset_name, quantity, value) {\n            add(value, policy_id, asset_name, quantity)\n          },\n        )\n      } else {\n        value\n      }\n    },\n  )\n}\n\ntest restricted_to_1() {\n  let self = from_lovelace(42) |> add(\"foo\", \"\", 1)\n  restricted_to(self, []) == zero\n}\n\ntest restricted_to_2() {\n  let self = from_lovelace(42) |> add(\"foo\", \"\", 1)\n  restricted_to(self, [ada_policy_id]) == from_lovelace(42)\n}\n\ntest restricted_to_3() {\n  let self = from_lovelace(42) |> add(\"foo\", \"\", 1) |> add(\"bar\", \"\", 1)\n  restricted_to(self, [\"foo\", \"bar\"]) == without_lovelace(self)\n}\n\ntest restricted_to_4() {\n  let self = from_lovelace(42) |> add(\"foo\", \"bar\", 1) |> add(\"foo\", \"baz\", 1)\n  restricted_to(self, [\"foo\"]) == without_lovelace(self)\n}\n\ntest restricted_to_5() {\n  let self = from_lovelace(42) |> add(\"foo\", \"bar\", 1) |> add(\"foo\", \"baz\", 1)\n  restricted_to(self, [ada_policy_id, \"foo\"]) == self\n}\n\n/// Get a `Value` excluding Ada.\npub fn without_lovelace(self: Value) -> Value {\n  dict.delete(self.inner, ada_policy_id)\n    |> Value\n}\n\ntest without_lovelace_1() {\n  let v = from_lovelace(1000000)\n  without_lovelace(v) == zero\n}\n\ntest without_lovelace_2() {\n  let v = from_lovelace(1000000)\n  let v2 = from_lovelace(50000000)\n  without_lovelace(v) == without_lovelace(v2)\n}\n\ntest without_lovelace_3() {\n  let v =\n    from_asset(#\"010203\", #\"040506\", 100)\n      |> add(ada_policy_id, ada_asset_name, 100000000)\n  let v2 = from_asset(#\"010203\", #\"040506\", 100)\n  without_lovelace(v) == without_lovelace(v2) && without_lovelace(v) == v2\n}\n\n// ## Transforming\n\n/// Flatten a `Value` as list of 3-tuple `(PolicyId, AssetName, Quantity)`.\n///\n/// Handy to manipulate values as uniform lists.\npub fn flatten(self: Value) -> List<(PolicyId, AssetName, Int)> {\n  dict.foldr(\n    self.inner,\n    [],\n    fn(policy_id, asset_list, value) {\n      dict.foldr(\n        asset_list,\n        value,\n        fn(asset_name, quantity, xs) {\n          [(policy_id, asset_name, quantity), ..xs]\n        },\n      )\n    },\n  )\n}\n\n/// Flatten a `Value` as a list of results, possibly discarding some along the way.\n///\n/// When the transform function returns `None`, the result is discarded altogether.\npub fn flatten_with(self: Value, with: FlattenStrategy<result>) -> List<result> {\n  dict.foldr(\n    self.inner,\n    [],\n    fn(policy_id, asset_list, value) {\n      dict.foldr(\n        asset_list,\n        value,\n        fn(asset_name, quantity, xs) {\n          with(\n            policy_id,\n            asset_name,\n            quantity,\n            fn(x) { [x, ..xs] },\n            fn() { xs },\n          )\n        },\n      )\n    },\n  )\n}\n\ntest flatten_with_1() {\n  flatten_with(zero, strategy.triple()) == []\n}\n\ntest flatten_with_2() {\n  let v =\n    zero\n      |> add(\"a\", \"1\", 14)\n      |> add(\"b\", \"\", 42)\n      |> add(\"a\", \"2\", 42)\n\n  flatten_with(\n    v,\n    fn(p, a, q, keep, discard) {\n      if q == 42 {\n        keep((p, a))\n      } else {\n        discard()\n      }\n    },\n  ) == [(\"a\", \"2\"), (\"b\", \"\")]\n}\n\n/// Reduce a value into a single result\n///\n/// ```\n/// assets.zero\n///  |> assets.add(\"a\", \"1\", 10)\n///  |> assets.add(\"b\", \"2\", 20)\n///  |> assets.reduce(v, 0, fn(_, _, quantity, acc) { acc + quantity })\n/// // 30\n/// ```\npub fn reduce(\n  self: Value,\n  start: result,\n  with: fn(PolicyId, AssetName, Int, result) -> result,\n) -> result {\n  dict.foldr(\n    self.inner,\n    start,\n    fn(policy_id, asset_list, result) {\n      dict.foldr(asset_list, result, with(policy_id, _, _, _))\n    },\n  )\n}\n\ntest reduce_1() {\n  let v =\n    zero\n      |> add(\"a\", \"1\", 10)\n      |> add(\"b\", \"2\", 20)\n  let result = reduce(v, 0, fn(_, _, quantity, acc) { acc + quantity })\n  result == 30\n}\n\ntest reduce_2() {\n  let v =\n    zero\n      |> add(\"a\", \"1\", 5)\n      |> add(\"a\", \"2\", 15)\n      |> add(\"b\", \"\", 10)\n  let result =\n    reduce(\n      v,\n      [],\n      fn(policy_id, asset_name, _, acc) { [(policy_id, asset_name), ..acc] },\n    )\n  result == [(\"a\", \"1\"), (\"a\", \"2\"), (\"b\", \"\")]\n}\n\ntest reduce_3() {\n  let v = zero\n  let result = reduce(v, 1, fn(_, _, quantity, acc) { acc + quantity })\n  result == 1\n}\n\n/// Convert the value into a dictionary of dictionaries.\npub fn to_dict(self: Value) -> Dict<PolicyId, Dict<AssetName, Int>> {\n  self.inner\n}\n",
      "dependencies": [
        "aiken/builtin",
        "aiken/collection/dict",
        "aiken/collection/dict/strategy",
        "aiken/collection/list",
        "aiken/crypto",
        "aiken/option",
        "cardano/assets/strategy"
      ],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:cardano.certificate",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/cardano/certificate.ak",
      "name": "cardano.certificate",
      "imports": [
        {
          "module": "aiken/crypto",
          "items": [
            "Blake2b_224",
            "Hash",
            "VerificationKey",
            "VerificationKeyHash"
          ],
          "line": 1,
          "raw": "use aiken/crypto.{Blake2b_224, Hash, VerificationKey, VerificationKeyHash}",
          "source": "stdlib"
        },
        {
          "module": "cardano/address",
          "items": ["Credential"],
          "line": 2,
          "raw": "use cardano/address.{Credential}",
          "source": "stdlib"
        },
        {
          "module": "cardano/assets",
          "items": ["Lovelace"],
          "line": 3,
          "raw": "use cardano/assets.{Lovelace}",
          "source": "stdlib"
        }
      ],
      "functions": [],
      "types": [
        {
          "name": "StakePoolId",
          "definition": "Hash<Blake2b_224, VerificationKey>",
          "line": 5,
          "raw": "pub type StakePoolId =",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Certificate",
          "definition": "{ /// Register a stake credential with an optional deposit amount. /// The deposit is always present when using the new registration certificate /// format available since the Conway era. RegisterCredential { credential: Credential, /// > [!NOTE] /// > The `deposit` ought to be an `Option<Lovelace>`, but due to unfortunate /// > circumstances it will always be instantiated to `None` even when set in /// > the host transaction. This is what the `Never` type captures here. deposit: Never, } /// Un-Register a stake credential with an optional refund amount /// The deposit is always present when using the new de-registration certificate /// format available since the Conway era. UnregisterCredential { credential: Credential, /// > [!NOTE] /// > The `refund` ought to be an `Option<Lovelace>`, but due to unfortunate /// > circumstances it will always be instantiated to `None` even when set in /// > the host transaction. This is what the `Never` type captures here. refund: Never, } /// Delegate stake to a [Delegate](#Delegate). DelegateCredential { credential: Credential, delegate: Delegate } /// Register and delegate staking credential to a Delegatee in one certificate. RegisterAndDelegateCredential { credential: Credential, delegate: Delegate, deposit: Lovelace, } /// Register a delegate representative (a.k.a DRep). The deposit is explicit and /// is refunded when the delegate steps down (unregister). RegisterDelegateRepresentative { delegate_representative: Credential, deposit: Lovelace, } /// Update a delegate representative (a.k.a DRep). The certificate also contains /// metadata which aren't visible on-chain. UpdateDelegateRepresentative { delegate_representative: Credential } /// UnRegister a delegate representative, and refund back its past deposit. UnregisterDelegateRepresentative { delegate_representative: Credential, refund: Lovelace, } /// Register a new stake pool RegisterStakePool { /// The hash digest of the stake pool's cold (public) key stake_pool: StakePoolId, /// The hash digest of the stake pool's VRF (public) key vrf: VerificationKeyHash, } /// Retire a stake pool. 'at_epoch' indicates in which the retirement will take place RetireStakePool { stake_pool: StakePoolId, at_epoch: Int } /// Authorize a Hot credential for a specific Committee member's cold credential AuthorizeConstitutionalCommitteeProxy { constitutional_committee_member: Credential, proxy: Credential, } /// Step down from the constitutional committee as a member. RetireFromConstitutionalCommittee { constitutional_committee_member: Credential, } }",
          "line": 11,
          "raw": "pub type Certificate {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Delegate",
          "definition": "{ DelegateBlockProduction { stake_pool: StakePoolId } DelegateVote { delegate_representative: DelegateRepresentative } DelegateBoth { stake_pool: StakePoolId, delegate_representative: DelegateRepresentative, } }",
          "line": 80,
          "raw": "pub type Delegate {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "DelegateRepresentative",
          "definition": "{ Registered(Credential) AlwaysAbstain AlwaysNoConfidence }",
          "line": 89,
          "raw": "pub type DelegateRepresentative {",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/crypto.{Blake2b_224, Hash, VerificationKey, VerificationKeyHash}\nuse cardano/address.{Credential}\nuse cardano/assets.{Lovelace}\n\npub type StakePoolId =\n  Hash<Blake2b_224, VerificationKey>\n\n/// An on-chain certificate attesting of some operation. Publishing\n/// certificates triggers different kind of rules; most of the time,\n/// they require signatures from specific keys.\npub type Certificate {\n  /// Register a stake credential with an optional deposit amount.\n  /// The deposit is always present when using the new registration certificate\n  /// format available since the Conway era.\n  RegisterCredential {\n    credential: Credential,\n    /// > [!NOTE]\n    /// > The `deposit` ought to be an `Option<Lovelace>`, but due to unfortunate\n    /// > circumstances it will always be instantiated to `None` even when set in\n    /// > the host transaction. This is what the `Never` type captures here.\n    deposit: Never,\n  }\n  /// Un-Register a stake credential with an optional refund amount\n  /// The deposit is always present when using the new de-registration certificate\n  /// format available since the Conway era.\n  UnregisterCredential {\n    credential: Credential,\n    /// > [!NOTE]\n    /// > The `refund` ought to be an `Option<Lovelace>`, but due to unfortunate\n    /// > circumstances it will always be instantiated to `None` even when set in\n    /// > the host transaction. This is what the `Never` type captures here.\n    refund: Never,\n  }\n  /// Delegate stake to a [Delegate](#Delegate).\n  DelegateCredential { credential: Credential, delegate: Delegate }\n  /// Register and delegate staking credential to a Delegatee in one certificate.\n  RegisterAndDelegateCredential {\n    credential: Credential,\n    delegate: Delegate,\n    deposit: Lovelace,\n  }\n  /// Register a delegate representative (a.k.a DRep). The deposit is explicit and\n  /// is refunded when the delegate steps down (unregister).\n  RegisterDelegateRepresentative {\n    delegate_representative: Credential,\n    deposit: Lovelace,\n  }\n  /// Update a delegate representative (a.k.a DRep). The certificate also contains\n  /// metadata which aren't visible on-chain.\n  UpdateDelegateRepresentative { delegate_representative: Credential }\n  /// UnRegister a delegate representative, and refund back its past deposit.\n  UnregisterDelegateRepresentative {\n    delegate_representative: Credential,\n    refund: Lovelace,\n  }\n  /// Register a new stake pool\n  RegisterStakePool {\n    /// The hash digest of the stake pool's cold (public) key\n    stake_pool: StakePoolId,\n    /// The hash digest of the stake pool's VRF (public) key\n    vrf: VerificationKeyHash,\n  }\n  /// Retire a stake pool. 'at_epoch' indicates in which the retirement will take place\n  RetireStakePool { stake_pool: StakePoolId, at_epoch: Int }\n  /// Authorize a Hot credential for a specific Committee member's cold credential\n  AuthorizeConstitutionalCommitteeProxy {\n    constitutional_committee_member: Credential,\n    proxy: Credential,\n  }\n  /// Step down from the constitutional committee as a member.\n  RetireFromConstitutionalCommittee {\n    constitutional_committee_member: Credential,\n  }\n}\n\n/// A type of stake delegation that can be either block-production, vote or\n/// both. Note that delegation types aren't cancelling one another, so it is\n/// possible to delegate block production in one transaction, and delegate vote\n/// in another. This second delegation **does NOT** invalidate the first one.\npub type Delegate {\n  DelegateBlockProduction { stake_pool: StakePoolId }\n  DelegateVote { delegate_representative: DelegateRepresentative }\n  DelegateBoth {\n    stake_pool: StakePoolId,\n    delegate_representative: DelegateRepresentative,\n  }\n}\n\npub type DelegateRepresentative {\n  Registered(Credential)\n  AlwaysAbstain\n  AlwaysNoConfidence\n}\n",
      "dependencies": ["aiken/crypto", "cardano/address", "cardano/assets"],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/cardano/governance/protocol_parameters.ak",
      "name": "cardano.governance.protocol_parameters",
      "imports": [
        {
          "module": "aiken/math/rational",
          "items": ["Rational"],
          "line": 1,
          "raw": "use aiken/math/rational.{Rational}",
          "source": "stdlib"
        },
        {
          "module": "cardano/assets",
          "items": ["Lovelace"],
          "line": 2,
          "raw": "use cardano/assets.{Lovelace}",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "min_fee_coefficient",
          "signature": "pub fn min_fee_coefficient(self: ProtocolParametersUpdate) -> Option<Int> {",
          "documentation": "The linear coefficient that intervenes in the transaction fee calculation.\nIt is multiplied by the size of the transaction in bytes to obtain a Lovelace value.",
          "parameters": [
            {
              "name": "self",
              "type": "ProtocolParametersUpdate",
              "optional": false
            }
          ],
          "returnType": "Option<Int>",
          "line": 67,
          "raw": "pub fn min_fee_coefficient(self: ProtocolParametersUpdate) -> Option<Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn min_fee_coefficient(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 0, into_int)\n}"
        },
        {
          "name": "min_fee_constant",
          "signature": "pub fn min_fee_constant(self: ProtocolParametersUpdate) -> Option<Int> {",
          "documentation": "The constant factor that intervenes in the transaction fee calculation. It is\na flat cost of lovelace that is added to every fee calculation.",
          "parameters": [
            {
              "name": "self",
              "type": "ProtocolParametersUpdate",
              "optional": false
            }
          ],
          "returnType": "Option<Int>",
          "line": 73,
          "raw": "pub fn min_fee_constant(self: ProtocolParametersUpdate) -> Option<Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn min_fee_constant(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 1, into_int)\n}"
        },
        {
          "name": "max_block_body_size",
          "signature": "pub fn max_block_body_size(self: ProtocolParametersUpdate) -> Option<Int> {",
          "documentation": "The maximum size of a serialized block body, expressed in bytes.",
          "parameters": [
            {
              "name": "self",
              "type": "ProtocolParametersUpdate",
              "optional": false
            }
          ],
          "returnType": "Option<Int>",
          "line": 78,
          "raw": "pub fn max_block_body_size(self: ProtocolParametersUpdate) -> Option<Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn max_block_body_size(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 2, into_int)\n}"
        },
        {
          "name": "max_transaction_size",
          "signature": "pub fn max_transaction_size(self: ProtocolParametersUpdate) -> Option<Int> {",
          "documentation": "The maximum size of a serialized transaction (body + witnesses), expressed in bytes.",
          "parameters": [
            {
              "name": "self",
              "type": "ProtocolParametersUpdate",
              "optional": false
            }
          ],
          "returnType": "Option<Int>",
          "line": 83,
          "raw": "pub fn max_transaction_size(self: ProtocolParametersUpdate) -> Option<Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn max_transaction_size(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 3, into_int)\n}"
        },
        {
          "name": "max_block_header_size",
          "signature": "pub fn max_block_header_size(self: ProtocolParametersUpdate) -> Option<Int> {",
          "documentation": "The maximum size of a serialized block header, expressed in bytes.",
          "parameters": [
            {
              "name": "self",
              "type": "ProtocolParametersUpdate",
              "optional": false
            }
          ],
          "returnType": "Option<Int>",
          "line": 88,
          "raw": "pub fn max_block_header_size(self: ProtocolParametersUpdate) -> Option<Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn max_block_header_size(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 4, into_int)\n}"
        },
        {
          "name": "stake_credential_deposit",
          "signature": "pub fn stake_credential_deposit(pub fn stake_credential_deposit(self: ProtocolParametersUpdate, ) -> Option<Lovelace> {",
          "documentation": "The required deposit amount when registering stake credentials, expressed in Lovelace.",
          "parameters": [],
          "returnType": "Option<Lovelace>",
          "line": 93,
          "raw": "pub fn stake_credential_deposit(pub fn stake_credential_deposit(self: ProtocolParametersUpdate, ) -> Option<Lovelace> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn stake_credential_deposit(\n  self: ProtocolParametersUpdate,\n) -> Option<Lovelace> {\n  get_protocol_param(self.inner, 5, into_int)\n}"
        },
        {
          "name": "stake_pool_deposit",
          "signature": "pub fn stake_pool_deposit(self: ProtocolParametersUpdate) -> Option<Lovelace> {",
          "documentation": "The required deposit amount when registering a stake pool, expressed in Lovelace.",
          "parameters": [
            {
              "name": "self",
              "type": "ProtocolParametersUpdate",
              "optional": false
            }
          ],
          "returnType": "Option<Lovelace>",
          "line": 100,
          "raw": "pub fn stake_pool_deposit(self: ProtocolParametersUpdate) -> Option<Lovelace> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn stake_pool_deposit(self: ProtocolParametersUpdate) -> Option<Lovelace> {\n  get_protocol_param(self.inner, 6, into_int)\n}"
        },
        {
          "name": "stake_pool_retirement_horizon",
          "signature": "pub fn stake_pool_retirement_horizon(pub fn stake_pool_retirement_horizon(self: ProtocolParametersUpdate, ) -> Option<Int> {",
          "documentation": "The maximum number of epoch in the future allowed for a stake pool retirement to be scheduled.",
          "parameters": [],
          "returnType": "Option<Int>",
          "line": 105,
          "raw": "pub fn stake_pool_retirement_horizon(pub fn stake_pool_retirement_horizon(self: ProtocolParametersUpdate, ) -> Option<Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn stake_pool_retirement_horizon(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 7, into_int)\n}"
        },
        {
          "name": "desired_number_of_stake_pools",
          "signature": "pub fn desired_number_of_stake_pools(pub fn desired_number_of_stake_pools(self: ProtocolParametersUpdate, ) -> Option<Int> {",
          "documentation": "The desired/optimal number of fully saturated stake pools in the system. Also known as the _'k-parameter'_.",
          "parameters": [],
          "returnType": "Option<Int>",
          "line": 112,
          "raw": "pub fn desired_number_of_stake_pools(pub fn desired_number_of_stake_pools(self: ProtocolParametersUpdate, ) -> Option<Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn desired_number_of_stake_pools(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 8, into_int)\n}"
        },
        {
          "name": "stake_pool_pledge_influence",
          "signature": "pub fn stake_pool_pledge_influence(pub fn stake_pool_pledge_influence(self: ProtocolParametersUpdate, ) -> Option<Rational> {",
          "documentation": "A parameter controlling the influence of an pool owner's pledge on the rewards. Also known as _'a0'_.",
          "parameters": [],
          "returnType": "Option<Rational>",
          "line": 119,
          "raw": "pub fn stake_pool_pledge_influence(pub fn stake_pool_pledge_influence(self: ProtocolParametersUpdate, ) -> Option<Rational> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn stake_pool_pledge_influence(\n  self: ProtocolParametersUpdate,\n) -> Option<Rational> {\n  get_protocol_param(self.inner, 9, into_rational)\n}"
        },
        {
          "name": "monetary_expansion",
          "signature": "pub fn monetary_expansion(self: ProtocolParametersUpdate) -> Option<Rational> {",
          "documentation": "The monetary expansion parameter, controlling the fraction of Ada put in circulation on every epoch through the incentivies model. Also known as _'ρ'_.",
          "parameters": [
            {
              "name": "self",
              "type": "ProtocolParametersUpdate",
              "optional": false
            }
          ],
          "returnType": "Option<Rational>",
          "line": 126,
          "raw": "pub fn monetary_expansion(self: ProtocolParametersUpdate) -> Option<Rational> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn monetary_expansion(self: ProtocolParametersUpdate) -> Option<Rational> {\n  get_protocol_param(self.inner, 10, into_rational)\n}"
        },
        {
          "name": "treasury_expansion",
          "signature": "pub fn treasury_expansion(self: ProtocolParametersUpdate) -> Option<Rational> {",
          "documentation": "The parameter controlling what fraction (%) of available rewards is sent to the treasury on every epoch. Also known as _'τ'_.",
          "parameters": [
            {
              "name": "self",
              "type": "ProtocolParametersUpdate",
              "optional": false
            }
          ],
          "returnType": "Option<Rational>",
          "line": 131,
          "raw": "pub fn treasury_expansion(self: ProtocolParametersUpdate) -> Option<Rational> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn treasury_expansion(self: ProtocolParametersUpdate) -> Option<Rational> {\n  get_protocol_param(self.inner, 11, into_rational)\n}"
        },
        {
          "name": "min_stake_pool_cost",
          "signature": "pub fn min_stake_pool_cost(self: ProtocolParametersUpdate) -> Option<Lovelace> {",
          "documentation": "Minimum authorized constant cost that stake pools can declare when registering, expressed in Lovelace.",
          "parameters": [
            {
              "name": "self",
              "type": "ProtocolParametersUpdate",
              "optional": false
            }
          ],
          "returnType": "Option<Lovelace>",
          "line": 136,
          "raw": "pub fn min_stake_pool_cost(self: ProtocolParametersUpdate) -> Option<Lovelace> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn min_stake_pool_cost(self: ProtocolParametersUpdate) -> Option<Lovelace> {\n  get_protocol_param(self.inner, 16, into_int)\n}"
        },
        {
          "name": "min_utxo_deposit_coefficient",
          "signature": "pub fn min_utxo_deposit_coefficient(pub fn min_utxo_deposit_coefficient(self: ProtocolParametersUpdate, ) -> Option<Int> {",
          "documentation": "The linear coefficient that intervenes in the calculation of the minimum Ada value that any UTxO must hold. It is expressed in Lovelace per Byte, and is also known as the 'coins per utxo byte' parameter.",
          "parameters": [],
          "returnType": "Option<Int>",
          "line": 141,
          "raw": "pub fn min_utxo_deposit_coefficient(pub fn min_utxo_deposit_coefficient(self: ProtocolParametersUpdate, ) -> Option<Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn min_utxo_deposit_coefficient(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 17, into_int)\n}"
        },
        {
          "name": "cost_models",
          "signature": "pub fn cost_models(self: ProtocolParametersUpdate) -> Option<Data> {",
          "documentation": "The costs associated with the various operations of the Plutus Virtual Machine, which can be different for each Plutus version.",
          "parameters": [
            {
              "name": "self",
              "type": "ProtocolParametersUpdate",
              "optional": false
            }
          ],
          "returnType": "Option<Data>",
          "line": 148,
          "raw": "pub fn cost_models(self: ProtocolParametersUpdate) -> Option<Data> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn cost_models(self: ProtocolParametersUpdate) -> Option<Data> {\n  get_protocol_param(self.inner, 18, identity)\n}"
        },
        {
          "name": "script_execution_prices",
          "signature": "pub fn script_execution_prices(pub fn script_execution_prices(self: ProtocolParametersUpdate, ) -> Option<ScriptExecutionPrices> {",
          "documentation": "The price, in Lovelace per unit, of the execution units corresponding to cpu and memory usage of on-chain scripts.",
          "parameters": [],
          "returnType": "Option<ScriptExecutionPrices>",
          "line": 153,
          "raw": "pub fn script_execution_prices(pub fn script_execution_prices(self: ProtocolParametersUpdate, ) -> Option<ScriptExecutionPrices> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn script_execution_prices(\n  self: ProtocolParametersUpdate,\n) -> Option<ScriptExecutionPrices> {\n  get_protocol_param(self.inner, 19, into_script_execution_prices)\n}"
        },
        {
          "name": "max_transaction_execution_units",
          "signature": "pub fn max_transaction_execution_units(pub fn max_transaction_execution_units(self: ProtocolParametersUpdate, ) -> Option<ExecutionUnits> {",
          "documentation": "The maximum execution units allowed for a single transaction.",
          "parameters": [],
          "returnType": "Option<ExecutionUnits>",
          "line": 160,
          "raw": "pub fn max_transaction_execution_units(pub fn max_transaction_execution_units(self: ProtocolParametersUpdate, ) -> Option<ExecutionUnits> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn max_transaction_execution_units(\n  self: ProtocolParametersUpdate,\n) -> Option<ExecutionUnits> {\n  get_protocol_param(self.inner, 20, into_execution_units)\n}"
        },
        {
          "name": "max_block_execution_units",
          "signature": "pub fn max_block_execution_units(pub fn max_block_execution_units(self: ProtocolParametersUpdate, ) -> Option<ExecutionUnits> {",
          "documentation": "The maximum execution units allowed for a single block.",
          "parameters": [],
          "returnType": "Option<ExecutionUnits>",
          "line": 167,
          "raw": "pub fn max_block_execution_units(pub fn max_block_execution_units(self: ProtocolParametersUpdate, ) -> Option<ExecutionUnits> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn max_block_execution_units(\n  self: ProtocolParametersUpdate,\n) -> Option<ExecutionUnits> {\n  get_protocol_param(self.inner, 21, into_execution_units)\n}"
        },
        {
          "name": "max_value_size",
          "signature": "pub fn max_value_size(self: ProtocolParametersUpdate) -> Option<Int> {",
          "documentation": "The maximum size of a serialized value in a transaction output. This effectively limits\nthe maximum kinds of assets that can be sent in a single output. It is expressed in bytes.",
          "parameters": [
            {
              "name": "self",
              "type": "ProtocolParametersUpdate",
              "optional": false
            }
          ],
          "returnType": "Option<Int>",
          "line": 175,
          "raw": "pub fn max_value_size(self: ProtocolParametersUpdate) -> Option<Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn max_value_size(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 22, into_int)\n}"
        },
        {
          "name": "collateral_percentage",
          "signature": "pub fn collateral_percentage(self: ProtocolParametersUpdate) -> Option<Int> {",
          "documentation": "The scaling factor applied to the transaction cost for defining the minimum collateral\namount. It is expressed in percent points (so 100 = 100%).",
          "parameters": [
            {
              "name": "self",
              "type": "ProtocolParametersUpdate",
              "optional": false
            }
          ],
          "returnType": "Option<Int>",
          "line": 181,
          "raw": "pub fn collateral_percentage(self: ProtocolParametersUpdate) -> Option<Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn collateral_percentage(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 23, into_int)\n}"
        },
        {
          "name": "max_collateral_inputs",
          "signature": "pub fn max_collateral_inputs(self: ProtocolParametersUpdate) -> Option<Int> {",
          "documentation": "The maximum number of collateral inputs allowed in the transaction.",
          "parameters": [
            {
              "name": "self",
              "type": "ProtocolParametersUpdate",
              "optional": false
            }
          ],
          "returnType": "Option<Int>",
          "line": 186,
          "raw": "pub fn max_collateral_inputs(self: ProtocolParametersUpdate) -> Option<Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn max_collateral_inputs(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 24, into_int)\n}"
        },
        {
          "name": "stake_pool_operator_voting_thresholds",
          "signature": "pub fn stake_pool_operator_voting_thresholds(pub fn stake_pool_operator_voting_thresholds(self: ProtocolParametersUpdate, ) -> Option<StakePoolOperatorVotingThresholds> {",
          "documentation": "The various governance voting thresholds pertaining to stake pool operators.",
          "parameters": [],
          "returnType": "Option<StakePoolOperatorVotingThresholds>",
          "line": 191,
          "raw": "pub fn stake_pool_operator_voting_thresholds(pub fn stake_pool_operator_voting_thresholds(self: ProtocolParametersUpdate, ) -> Option<StakePoolOperatorVotingThresholds> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn stake_pool_operator_voting_thresholds(\n  self: ProtocolParametersUpdate,\n) -> Option<StakePoolOperatorVotingThresholds> {\n  get_protocol_param(self.inner, 25, into_spo_voting_thresholds)\n}"
        },
        {
          "name": "delegate_representative_voting_thresholds",
          "signature": "pub fn delegate_representative_voting_thresholds(pub fn delegate_representative_voting_thresholds(self: ProtocolParametersUpdate, ) -> Option<DelegateRepresentativeVotingThresholds> {",
          "documentation": "The various governance voting thresholds pertaining to delegate representatives\n(a.k.a DReps).",
          "parameters": [],
          "returnType": "Option<DelegateRepresentativeVotingThresholds>",
          "line": 199,
          "raw": "pub fn delegate_representative_voting_thresholds(pub fn delegate_representative_voting_thresholds(self: ProtocolParametersUpdate, ) -> Option<DelegateRepresentativeVotingThresholds> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn delegate_representative_voting_thresholds(\n  self: ProtocolParametersUpdate,\n) -> Option<DelegateRepresentativeVotingThresholds> {\n  get_protocol_param(self.inner, 26, into_drep_voting_thresholds)\n}"
        },
        {
          "name": "min_constitutional_committee_size",
          "signature": "pub fn min_constitutional_committee_size(pub fn min_constitutional_committee_size(self: ProtocolParametersUpdate, ) -> Option<Int> {",
          "documentation": "The minimum number of members in the constitutional committee. Any updates of the committee\nmust leave at least this number of members.",
          "parameters": [],
          "returnType": "Option<Int>",
          "line": 207,
          "raw": "pub fn min_constitutional_committee_size(pub fn min_constitutional_committee_size(self: ProtocolParametersUpdate, ) -> Option<Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn min_constitutional_committee_size(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 27, into_int)\n}"
        },
        {
          "name": "max_constitutional_committee_mandate",
          "signature": "pub fn max_constitutional_committee_mandate(pub fn max_constitutional_committee_mandate(self: ProtocolParametersUpdate, ) -> Option<Int> {",
          "documentation": "The maximum length of a constitutional committee member, expressed in number of epochs.",
          "parameters": [],
          "returnType": "Option<Int>",
          "line": 214,
          "raw": "pub fn max_constitutional_committee_mandate(pub fn max_constitutional_committee_mandate(self: ProtocolParametersUpdate, ) -> Option<Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn max_constitutional_committee_mandate(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 28, into_int)\n}"
        },
        {
          "name": "governance_proposal_lifetime",
          "signature": "pub fn governance_proposal_lifetime(pub fn governance_proposal_lifetime(self: ProtocolParametersUpdate, ) -> Option<Int> {",
          "documentation": "The lifetime of any governance proposal. An action that hasn't been approved beyond that\nperiod is considered inactive and discarded. It is expressed in number of epochs.",
          "parameters": [],
          "returnType": "Option<Int>",
          "line": 222,
          "raw": "pub fn governance_proposal_lifetime(pub fn governance_proposal_lifetime(self: ProtocolParametersUpdate, ) -> Option<Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn governance_proposal_lifetime(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 29, into_int)\n}"
        },
        {
          "name": "governance_proposal_deposit",
          "signature": "pub fn governance_proposal_deposit(pub fn governance_proposal_deposit(self: ProtocolParametersUpdate, ) -> Option<Lovelace> {",
          "documentation": "The required deposit amount for governance proposal procedures, expressed in Lovelace.",
          "parameters": [],
          "returnType": "Option<Lovelace>",
          "line": 229,
          "raw": "pub fn governance_proposal_deposit(pub fn governance_proposal_deposit(self: ProtocolParametersUpdate, ) -> Option<Lovelace> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn governance_proposal_deposit(\n  self: ProtocolParametersUpdate,\n) -> Option<Lovelace> {\n  get_protocol_param(self.inner, 30, into_int)\n}"
        },
        {
          "name": "delegate_representative_deposit",
          "signature": "pub fn delegate_representative_deposit(pub fn delegate_representative_deposit(self: ProtocolParametersUpdate, ) -> Option<Lovelace> {",
          "documentation": "The required deposit amount when registering as a delegate representative, expressed in\nLovelace.",
          "parameters": [],
          "returnType": "Option<Lovelace>",
          "line": 237,
          "raw": "pub fn delegate_representative_deposit(pub fn delegate_representative_deposit(self: ProtocolParametersUpdate, ) -> Option<Lovelace> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn delegate_representative_deposit(\n  self: ProtocolParametersUpdate,\n) -> Option<Lovelace> {\n  get_protocol_param(self.inner, 31, into_int)\n}"
        },
        {
          "name": "delegate_representative_max_idle_time",
          "signature": "pub fn delegate_representative_max_idle_time(pub fn delegate_representative_max_idle_time(self: ProtocolParametersUpdate, ) -> Option<Int> {",
          "documentation": "The maximum number of epochs that a delegate representative can stay inactive (i.e. no\nvoting) without becoming _inactive_ and removed from thresholds calculations.",
          "parameters": [],
          "returnType": "Option<Int>",
          "line": 245,
          "raw": "pub fn delegate_representative_max_idle_time(pub fn delegate_representative_max_idle_time(self: ProtocolParametersUpdate, ) -> Option<Int> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn delegate_representative_max_idle_time(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 32, into_int)\n}"
        },
        {
          "name": "reference_scripts_tier_fee_initial_factor",
          "signature": "pub fn reference_scripts_tier_fee_initial_factor(pub fn reference_scripts_tier_fee_initial_factor(self: ProtocolParametersUpdate, ) -> Option<Rational> {",
          "documentation": "The base tier fee coefficient for reference scripts. Reference scripts gets increasingly\nmore expensives every ~24KB, the base coefficient is a multiplicating factor which grows\nexponentially with each tier.",
          "parameters": [],
          "returnType": "Option<Rational>",
          "line": 254,
          "raw": "pub fn reference_scripts_tier_fee_initial_factor(pub fn reference_scripts_tier_fee_initial_factor(self: ProtocolParametersUpdate, ) -> Option<Rational> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn reference_scripts_tier_fee_initial_factor(\n  self: ProtocolParametersUpdate,\n) -> Option<Rational> {\n  get_protocol_param(self.inner, 33, into_rational)\n}"
        }
      ],
      "types": [
        {
          "name": "ProtocolParametersUpdate",
          "definition": "opaque { inner: Pairs<ProtocolParametersIndex, Data>, }",
          "line": 4,
          "raw": "pub opaque type ProtocolParametersUpdate {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "ScriptExecutionPrices",
          "definition": "{ memory: Rational, cpu: Rational, }",
          "line": 8,
          "raw": "pub type ScriptExecutionPrices {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "ExecutionUnits",
          "definition": "{ memory: Int, cpu: Int, }",
          "line": 13,
          "raw": "pub type ExecutionUnits {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "StakePoolOperatorVotingThresholds",
          "definition": "{ motion_of_no_confidence: Rational, constitutional_committee: ConstitutionalCommitteeThresholds, hard_fork: Rational, protocol_parameters: ProtocolParametersThresholds< Rational, Void, Void, Void, Void, >, }",
          "line": 18,
          "raw": "pub type StakePoolOperatorVotingThresholds {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "DelegateRepresentativeVotingThresholds",
          "definition": "{ motion_of_no_confidence: Rational, constitutional_committee: ConstitutionalCommitteeThresholds, constitution: Rational, hard_fork: Rational, protocol_parameters: ProtocolParametersThresholds< Void, Rational, Rational, Rational, Rational, >, treasury_withdrawal: Rational, }",
          "line": 31,
          "raw": "pub type DelegateRepresentativeVotingThresholds {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "ConstitutionalCommitteeThresholds",
          "definition": "{ default: Rational, under_no_confidence: Rational, }",
          "line": 60,
          "raw": "pub type ConstitutionalCommitteeThresholds {",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "constants": [],
      "atoms": [
        {
          "name": "get_protocol_param",
          "signature": "fn get_protocol_param(fn get_protocol_param(self: Pairs<ProtocolParametersIndex, Data>, ix: ProtocolParametersIndex, into: fn(Data) -> a,",
          "parameters": [],
          "returnType": "a,",
          "line": 265,
          "raw": "fn get_protocol_param(fn get_protocol_param(self: Pairs<ProtocolParametersIndex, Data>, ix: ProtocolParametersIndex, into: fn(Data) -> a,",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn get_protocol_param(\n  self: Pairs<ProtocolParametersIndex, Data>,\n  ix: ProtocolParametersIndex,\n  into: fn(Data) -> a,\n) -> Option<a> {\n  when self is {\n    [] -> None\n    [Pair(jx, param), ..tail] ->\n      if ix == jx {\n        Some(into(param))\n      } else {\n        get_protocol_param(tail, ix, into)\n      }\n  }\n}"
        },
        {
          "name": "into_int",
          "signature": "fn into_int(param: Data) -> Int {",
          "parameters": [
            {
              "name": "param",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 281,
          "raw": "fn into_int(param: Data) -> Int {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn into_int(param: Data) -> Int {\n  expect param: Int = param\n  param\n}"
        },
        {
          "name": "into_rational",
          "signature": "fn into_rational(param: Data) -> Rational {",
          "parameters": [
            {
              "name": "param",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "Rational",
          "line": 286,
          "raw": "fn into_rational(param: Data) -> Rational {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn into_rational(param: Data) -> Rational {\n  expect [numerator, denominator]: List<Int> = param\n  expect Some(r) = rational.new(numerator, denominator)\n  r\n}"
        },
        {
          "name": "into_execution_units",
          "signature": "fn into_execution_units(param: Data) -> ExecutionUnits {",
          "parameters": [
            {
              "name": "param",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "ExecutionUnits",
          "line": 292,
          "raw": "fn into_execution_units(param: Data) -> ExecutionUnits {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn into_execution_units(param: Data) -> ExecutionUnits {\n  expect [memory, cpu]: List<Int> = param\n  ExecutionUnits { memory, cpu }\n}"
        },
        {
          "name": "into_script_execution_prices",
          "signature": "fn into_script_execution_prices(param: Data) -> ScriptExecutionPrices {",
          "parameters": [
            {
              "name": "param",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "ScriptExecutionPrices",
          "line": 297,
          "raw": "fn into_script_execution_prices(param: Data) -> ScriptExecutionPrices {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn into_script_execution_prices(param: Data) -> ScriptExecutionPrices {\n  expect [memory, cpu]: List<Data> = param\n  let memory = into_rational(memory)\n  let cpu = into_rational(cpu)\n  ScriptExecutionPrices { memory, cpu }\n}"
        },
        {
          "name": "into_spo_voting_thresholds",
          "signature": "fn into_spo_voting_thresholds(param: Data) -> StakePoolOperatorVotingThresholds {",
          "parameters": [
            {
              "name": "param",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "StakePoolOperatorVotingThresholds",
          "line": 304,
          "raw": "fn into_spo_voting_thresholds(param: Data) -> StakePoolOperatorVotingThresholds {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn into_spo_voting_thresholds(param: Data) -> StakePoolOperatorVotingThresholds {\n  expect [\n    motion_of_no_confidence, constitutional_committee,\n    constitutional_committee_under_no_confidence, hard_fork,\n    protocol_parameters_security_group,\n  ]: List<Data> = param\n\n  StakePoolOperatorVotingThresholds {\n    motion_of_no_confidence: into_rational(motion_of_no_confidence),\n    constitutional_committee: ConstitutionalCommitteeThresholds {\n      default: into_rational(constitutional_committee),\n      under_no_confidence: into_rational(\n        constitutional_committee_under_no_confidence,\n      ),\n    },\n    hard_fork: into_rational(hard_fork),\n    protocol_parameters: ProtocolParametersThresholds {\n      security_group: into_rational(protocol_parameters_security_group),\n      network_group: Void,\n      economic_group: Void,\n      technical_group: Void,\n      governance_group: Void,\n    },\n  }\n}"
        },
        {
          "name": "into_drep_voting_thresholds",
          "signature": "fn into_drep_voting_thresholds(fn into_drep_voting_thresholds(param: Data, ) -> DelegateRepresentativeVotingThresholds {",
          "parameters": [],
          "returnType": "DelegateRepresentativeVotingThresholds",
          "line": 330,
          "raw": "fn into_drep_voting_thresholds(fn into_drep_voting_thresholds(param: Data, ) -> DelegateRepresentativeVotingThresholds {",
          "isPublic": false,
          "source": "stdlib",
          "implementation": "fn into_drep_voting_thresholds(\n  param: Data,\n) -> DelegateRepresentativeVotingThresholds {\n  expect [\n    motion_of_no_confidence, constitutional_committee,\n    constitutional_committee_under_no_confidence, constitution, hard_fork,\n    protocol_parameters_network_group, protocol_parameters_economic_group,\n    protocol_parameters_technical_group, protocol_parameters_governance_group,\n    treasury_withdrawal,\n  ]: List<Data> = param\n\n  DelegateRepresentativeVotingThresholds {\n    motion_of_no_confidence: into_rational(motion_of_no_confidence),\n    constitutional_committee: ConstitutionalCommitteeThresholds {\n      default: into_rational(constitutional_committee),\n      under_no_confidence: into_rational(\n        constitutional_committee_under_no_confidence,\n      ),\n    },\n    constitution: into_rational(constitution),\n    hard_fork: into_rational(hard_fork),\n    protocol_parameters: ProtocolParametersThresholds {\n      security_group: Void,\n      network_group: into_rational(protocol_parameters_network_group),\n      economic_group: into_rational(protocol_parameters_economic_group),\n      technical_group: into_rational(protocol_parameters_technical_group),\n      governance_group: into_rational(protocol_parameters_governance_group),\n    },\n    treasury_withdrawal: into_rational(treasury_withdrawal),\n  }\n}"
        }
      ],
      "privateTypes": [
        {
          "name": "ProtocolParametersIndex",
          "definition": "Int",
          "line": 262,
          "raw": "type ProtocolParametersIndex =",
          "isPublic": false,
          "source": "stdlib"
        }
      ],
      "privateConstants": [],
      "content": "use aiken/math/rational.{Rational}\nuse cardano/assets.{Lovelace}\n\npub opaque type ProtocolParametersUpdate {\n  inner: Pairs<ProtocolParametersIndex, Data>,\n}\n\npub type ScriptExecutionPrices {\n  memory: Rational,\n  cpu: Rational,\n}\n\npub type ExecutionUnits {\n  memory: Int,\n  cpu: Int,\n}\n\npub type StakePoolOperatorVotingThresholds {\n  motion_of_no_confidence: Rational,\n  constitutional_committee: ConstitutionalCommitteeThresholds,\n  hard_fork: Rational,\n  protocol_parameters: ProtocolParametersThresholds<\n    Rational,\n    Void,\n    Void,\n    Void,\n    Void,\n  >,\n}\n\npub type DelegateRepresentativeVotingThresholds {\n  motion_of_no_confidence: Rational,\n  constitutional_committee: ConstitutionalCommitteeThresholds,\n  constitution: Rational,\n  hard_fork: Rational,\n  protocol_parameters: ProtocolParametersThresholds<\n    Void,\n    Rational,\n    Rational,\n    Rational,\n    Rational,\n  >,\n  treasury_withdrawal: Rational,\n}\n\npub type ProtocolParametersThresholds<\n  security,\n  network,\n  economic,\n  technical,\n  governance,\n> {\n  security_group: security,\n  network_group: network,\n  economic_group: economic,\n  technical_group: technical,\n  governance_group: governance,\n}\n\npub type ConstitutionalCommitteeThresholds {\n  default: Rational,\n  under_no_confidence: Rational,\n}\n\n/// The linear coefficient that intervenes in the transaction fee calculation.\n/// It is multiplied by the size of the transaction in bytes to obtain a Lovelace value.\npub fn min_fee_coefficient(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 0, into_int)\n}\n\n/// The constant factor that intervenes in the transaction fee calculation. It is\n/// a flat cost of lovelace that is added to every fee calculation.\npub fn min_fee_constant(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 1, into_int)\n}\n\n/// The maximum size of a serialized block body, expressed in bytes.\npub fn max_block_body_size(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 2, into_int)\n}\n\n/// The maximum size of a serialized transaction (body + witnesses), expressed in bytes.\npub fn max_transaction_size(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 3, into_int)\n}\n\n/// The maximum size of a serialized block header, expressed in bytes.\npub fn max_block_header_size(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 4, into_int)\n}\n\n/// The required deposit amount when registering stake credentials, expressed in Lovelace.\npub fn stake_credential_deposit(\n  self: ProtocolParametersUpdate,\n) -> Option<Lovelace> {\n  get_protocol_param(self.inner, 5, into_int)\n}\n\n/// The required deposit amount when registering a stake pool, expressed in Lovelace.\npub fn stake_pool_deposit(self: ProtocolParametersUpdate) -> Option<Lovelace> {\n  get_protocol_param(self.inner, 6, into_int)\n}\n\n/// The maximum number of epoch in the future allowed for a stake pool retirement to be scheduled.\npub fn stake_pool_retirement_horizon(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 7, into_int)\n}\n\n/// The desired/optimal number of fully saturated stake pools in the system. Also known as the _'k-parameter'_.\npub fn desired_number_of_stake_pools(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 8, into_int)\n}\n\n/// A parameter controlling the influence of an pool owner's pledge on the rewards. Also known as _'a0'_.\npub fn stake_pool_pledge_influence(\n  self: ProtocolParametersUpdate,\n) -> Option<Rational> {\n  get_protocol_param(self.inner, 9, into_rational)\n}\n\n/// The monetary expansion parameter, controlling the fraction of Ada put in circulation on every epoch through the incentivies model. Also known as _'ρ'_.\npub fn monetary_expansion(self: ProtocolParametersUpdate) -> Option<Rational> {\n  get_protocol_param(self.inner, 10, into_rational)\n}\n\n/// The parameter controlling what fraction (%) of available rewards is sent to the treasury on every epoch. Also known as _'τ'_.\npub fn treasury_expansion(self: ProtocolParametersUpdate) -> Option<Rational> {\n  get_protocol_param(self.inner, 11, into_rational)\n}\n\n/// Minimum authorized constant cost that stake pools can declare when registering, expressed in Lovelace.\npub fn min_stake_pool_cost(self: ProtocolParametersUpdate) -> Option<Lovelace> {\n  get_protocol_param(self.inner, 16, into_int)\n}\n\n/// The linear coefficient that intervenes in the calculation of the minimum Ada value that any UTxO must hold. It is expressed in Lovelace per Byte, and is also known as the 'coins per utxo byte' parameter.\npub fn min_utxo_deposit_coefficient(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 17, into_int)\n}\n\n/// The costs associated with the various operations of the Plutus Virtual Machine, which can be different for each Plutus version.\npub fn cost_models(self: ProtocolParametersUpdate) -> Option<Data> {\n  get_protocol_param(self.inner, 18, identity)\n}\n\n/// The price, in Lovelace per unit, of the execution units corresponding to cpu and memory usage of on-chain scripts.\npub fn script_execution_prices(\n  self: ProtocolParametersUpdate,\n) -> Option<ScriptExecutionPrices> {\n  get_protocol_param(self.inner, 19, into_script_execution_prices)\n}\n\n/// The maximum execution units allowed for a single transaction.\npub fn max_transaction_execution_units(\n  self: ProtocolParametersUpdate,\n) -> Option<ExecutionUnits> {\n  get_protocol_param(self.inner, 20, into_execution_units)\n}\n\n/// The maximum execution units allowed for a single block.\npub fn max_block_execution_units(\n  self: ProtocolParametersUpdate,\n) -> Option<ExecutionUnits> {\n  get_protocol_param(self.inner, 21, into_execution_units)\n}\n\n/// The maximum size of a serialized value in a transaction output. This effectively limits\n/// the maximum kinds of assets that can be sent in a single output. It is expressed in bytes.\npub fn max_value_size(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 22, into_int)\n}\n\n/// The scaling factor applied to the transaction cost for defining the minimum collateral\n/// amount. It is expressed in percent points (so 100 = 100%).\npub fn collateral_percentage(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 23, into_int)\n}\n\n/// The maximum number of collateral inputs allowed in the transaction.\npub fn max_collateral_inputs(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 24, into_int)\n}\n\n/// The various governance voting thresholds pertaining to stake pool operators.\npub fn stake_pool_operator_voting_thresholds(\n  self: ProtocolParametersUpdate,\n) -> Option<StakePoolOperatorVotingThresholds> {\n  get_protocol_param(self.inner, 25, into_spo_voting_thresholds)\n}\n\n/// The various governance voting thresholds pertaining to delegate representatives\n/// (a.k.a DReps).\npub fn delegate_representative_voting_thresholds(\n  self: ProtocolParametersUpdate,\n) -> Option<DelegateRepresentativeVotingThresholds> {\n  get_protocol_param(self.inner, 26, into_drep_voting_thresholds)\n}\n\n/// The minimum number of members in the constitutional committee. Any updates of the committee\n/// must leave at least this number of members.\npub fn min_constitutional_committee_size(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 27, into_int)\n}\n\n/// The maximum length of a constitutional committee member, expressed in number of epochs.\npub fn max_constitutional_committee_mandate(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 28, into_int)\n}\n\n/// The lifetime of any governance proposal. An action that hasn't been approved beyond that\n/// period is considered inactive and discarded. It is expressed in number of epochs.\npub fn governance_proposal_lifetime(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 29, into_int)\n}\n\n/// The required deposit amount for governance proposal procedures, expressed in Lovelace.\npub fn governance_proposal_deposit(\n  self: ProtocolParametersUpdate,\n) -> Option<Lovelace> {\n  get_protocol_param(self.inner, 30, into_int)\n}\n\n/// The required deposit amount when registering as a delegate representative, expressed in\n/// Lovelace.\npub fn delegate_representative_deposit(\n  self: ProtocolParametersUpdate,\n) -> Option<Lovelace> {\n  get_protocol_param(self.inner, 31, into_int)\n}\n\n/// The maximum number of epochs that a delegate representative can stay inactive (i.e. no\n/// voting) without becoming _inactive_ and removed from thresholds calculations.\npub fn delegate_representative_max_idle_time(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 32, into_int)\n}\n\n/// The base tier fee coefficient for reference scripts. Reference scripts gets increasingly\n/// more expensives every ~24KB, the base coefficient is a multiplicating factor which grows\n/// exponentially with each tier.\npub fn reference_scripts_tier_fee_initial_factor(\n  self: ProtocolParametersUpdate,\n) -> Option<Rational> {\n  get_protocol_param(self.inner, 33, into_rational)\n}\n\n// Internals -------------------------------------------------------------------\n\ntype ProtocolParametersIndex =\n  Int\n\nfn get_protocol_param(\n  self: Pairs<ProtocolParametersIndex, Data>,\n  ix: ProtocolParametersIndex,\n  into: fn(Data) -> a,\n) -> Option<a> {\n  when self is {\n    [] -> None\n    [Pair(jx, param), ..tail] ->\n      if ix == jx {\n        Some(into(param))\n      } else {\n        get_protocol_param(tail, ix, into)\n      }\n  }\n}\n\nfn into_int(param: Data) -> Int {\n  expect param: Int = param\n  param\n}\n\nfn into_rational(param: Data) -> Rational {\n  expect [numerator, denominator]: List<Int> = param\n  expect Some(r) = rational.new(numerator, denominator)\n  r\n}\n\nfn into_execution_units(param: Data) -> ExecutionUnits {\n  expect [memory, cpu]: List<Int> = param\n  ExecutionUnits { memory, cpu }\n}\n\nfn into_script_execution_prices(param: Data) -> ScriptExecutionPrices {\n  expect [memory, cpu]: List<Data> = param\n  let memory = into_rational(memory)\n  let cpu = into_rational(cpu)\n  ScriptExecutionPrices { memory, cpu }\n}\n\nfn into_spo_voting_thresholds(param: Data) -> StakePoolOperatorVotingThresholds {\n  expect [\n    motion_of_no_confidence, constitutional_committee,\n    constitutional_committee_under_no_confidence, hard_fork,\n    protocol_parameters_security_group,\n  ]: List<Data> = param\n\n  StakePoolOperatorVotingThresholds {\n    motion_of_no_confidence: into_rational(motion_of_no_confidence),\n    constitutional_committee: ConstitutionalCommitteeThresholds {\n      default: into_rational(constitutional_committee),\n      under_no_confidence: into_rational(\n        constitutional_committee_under_no_confidence,\n      ),\n    },\n    hard_fork: into_rational(hard_fork),\n    protocol_parameters: ProtocolParametersThresholds {\n      security_group: into_rational(protocol_parameters_security_group),\n      network_group: Void,\n      economic_group: Void,\n      technical_group: Void,\n      governance_group: Void,\n    },\n  }\n}\n\nfn into_drep_voting_thresholds(\n  param: Data,\n) -> DelegateRepresentativeVotingThresholds {\n  expect [\n    motion_of_no_confidence, constitutional_committee,\n    constitutional_committee_under_no_confidence, constitution, hard_fork,\n    protocol_parameters_network_group, protocol_parameters_economic_group,\n    protocol_parameters_technical_group, protocol_parameters_governance_group,\n    treasury_withdrawal,\n  ]: List<Data> = param\n\n  DelegateRepresentativeVotingThresholds {\n    motion_of_no_confidence: into_rational(motion_of_no_confidence),\n    constitutional_committee: ConstitutionalCommitteeThresholds {\n      default: into_rational(constitutional_committee),\n      under_no_confidence: into_rational(\n        constitutional_committee_under_no_confidence,\n      ),\n    },\n    constitution: into_rational(constitution),\n    hard_fork: into_rational(hard_fork),\n    protocol_parameters: ProtocolParametersThresholds {\n      security_group: Void,\n      network_group: into_rational(protocol_parameters_network_group),\n      economic_group: into_rational(protocol_parameters_economic_group),\n      technical_group: into_rational(protocol_parameters_technical_group),\n      governance_group: into_rational(protocol_parameters_governance_group),\n    },\n    treasury_withdrawal: into_rational(treasury_withdrawal),\n  }\n}\n",
      "dependencies": ["aiken/math/rational", "cardano/assets"],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:cardano.governance.voter",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/cardano/governance/voter.ak",
      "name": "cardano.governance.voter",
      "imports": [
        {
          "module": "aiken/primitive/bytearray",
          "items": [],
          "line": 1,
          "raw": "use aiken/primitive/bytearray",
          "source": "stdlib"
        },
        {
          "module": "cardano/address",
          "items": ["Script"],
          "line": 2,
          "raw": "use cardano/address.{Script}",
          "source": "stdlib"
        },
        {
          "module": "cardano/address/credential",
          "items": [],
          "line": 3,
          "raw": "use cardano/address/credential",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "compare",
          "signature": "pub fn compare(left: Voter, right: Voter) -> Ordering {",
          "parameters": [
            {
              "name": "left",
              "type": "Voter",
              "optional": false
            },
            {
              "name": "right",
              "type": "Voter",
              "optional": false
            }
          ],
          "returnType": "Ordering",
          "line": 8,
          "raw": "pub fn compare(left: Voter, right: Voter) -> Ordering {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn compare(left: Voter, right: Voter) -> Ordering {\n  when left is {\n    ConstitutionalCommitteeMember(left) ->\n      when right is {\n        ConstitutionalCommitteeMember(right) -> credential.compare(left, right)\n        _ -> Less\n      }\n    DelegateRepresentative(left) ->\n      when right is {\n        DelegateRepresentative(right) -> credential.compare(left, right)\n        ConstitutionalCommitteeMember(_) -> Greater\n        _ -> Less\n      }\n    StakePool(left) ->\n      when right is {\n        StakePool(right) -> bytearray.compare(left, right)\n        _ -> Greater\n      }\n  }\n}",
          "tests": [
            "test compare_matrix() {\n  let cc0 = ConstitutionalCommitteeMember(Script(\"0\"))\n  let cc1 = ConstitutionalCommitteeMember(Script(\"1\"))\n\n  let drep0 = DelegateRepresentative(Script(\"0\"))\n  let drep1 = DelegateRepresentative(Script(\"1\"))\n\n  let spo0 = StakePool(\"0\")\n  let spo1 = StakePool(\"1\")\n\n  and {\n    (compare(cc0, cc0) == Equal)?,\n    (compare(cc0, cc1) == Less)?,\n    (compare(cc1, cc0) == Greater)?,\n    (compare(drep0, drep0) == Equal)?,\n    (compare(drep0, drep1) == Less)?,\n    (compare(drep1, drep0) == Greater)?,\n    (compare(spo0, spo0) == Equal)?,\n    (compare(spo0, spo1) == Less)?,\n    (compare(spo1, spo0) == Greater)?,\n    (compare(cc0, drep0) == Less)?,\n    (compare(cc0, drep1) == Less)?,\n    (compare(cc0, spo0) == Less)?,\n    (compare(cc0, spo1) == Less)?,\n    (compare(drep0, cc0) == Greater)?,\n    (compare(drep0, cc1) == Greater)?,\n    (compare(drep0, spo0) == Less)?,\n    (compare(drep0, spo1) == Less)?,\n    (compare(spo0, cc0) == Greater)?,\n    (compare(spo0, cc1) == Greater)?,\n    (compare(spo0, drep0) == Greater)?,\n    (compare(spo0, drep1) == Greater)?,\n  }\n}"
          ]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/primitive/bytearray\nuse cardano/address.{Script}\nuse cardano/address/credential\nuse cardano/governance.{\n  ConstitutionalCommitteeMember, DelegateRepresentative, StakePool, Voter,\n}\n\npub fn compare(left: Voter, right: Voter) -> Ordering {\n  when left is {\n    ConstitutionalCommitteeMember(left) ->\n      when right is {\n        ConstitutionalCommitteeMember(right) -> credential.compare(left, right)\n        _ -> Less\n      }\n    DelegateRepresentative(left) ->\n      when right is {\n        DelegateRepresentative(right) -> credential.compare(left, right)\n        ConstitutionalCommitteeMember(_) -> Greater\n        _ -> Less\n      }\n    StakePool(left) ->\n      when right is {\n        StakePool(right) -> bytearray.compare(left, right)\n        _ -> Greater\n      }\n  }\n}\n\ntest compare_matrix() {\n  let cc0 = ConstitutionalCommitteeMember(Script(\"0\"))\n  let cc1 = ConstitutionalCommitteeMember(Script(\"1\"))\n\n  let drep0 = DelegateRepresentative(Script(\"0\"))\n  let drep1 = DelegateRepresentative(Script(\"1\"))\n\n  let spo0 = StakePool(\"0\")\n  let spo1 = StakePool(\"1\")\n\n  and {\n    (compare(cc0, cc0) == Equal)?,\n    (compare(cc0, cc1) == Less)?,\n    (compare(cc1, cc0) == Greater)?,\n    (compare(drep0, drep0) == Equal)?,\n    (compare(drep0, drep1) == Less)?,\n    (compare(drep1, drep0) == Greater)?,\n    (compare(spo0, spo0) == Equal)?,\n    (compare(spo0, spo1) == Less)?,\n    (compare(spo1, spo0) == Greater)?,\n    (compare(cc0, drep0) == Less)?,\n    (compare(cc0, drep1) == Less)?,\n    (compare(cc0, spo0) == Less)?,\n    (compare(cc0, spo1) == Less)?,\n    (compare(drep0, cc0) == Greater)?,\n    (compare(drep0, cc1) == Greater)?,\n    (compare(drep0, spo0) == Less)?,\n    (compare(drep0, spo1) == Less)?,\n    (compare(spo0, cc0) == Greater)?,\n    (compare(spo0, cc1) == Greater)?,\n    (compare(spo0, drep0) == Greater)?,\n    (compare(spo0, drep1) == Greater)?,\n  }\n}\n",
      "dependencies": [
        "aiken/primitive/bytearray",
        "cardano/address",
        "cardano/address/credential"
      ],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:cardano.governance",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/cardano/governance.ak",
      "name": "cardano.governance",
      "imports": [
        {
          "module": "aiken/collection",
          "items": ["Index"],
          "line": 1,
          "raw": "use aiken/collection.{Index}",
          "source": "stdlib"
        },
        {
          "module": "aiken/crypto",
          "items": ["Blake2b_256", "Hash", "ScriptHash", "VerificationKeyHash"],
          "line": 2,
          "raw": "use aiken/crypto.{Blake2b_256, Hash, ScriptHash, VerificationKeyHash}",
          "source": "stdlib"
        },
        {
          "module": "aiken/math/rational",
          "items": ["Rational"],
          "line": 3,
          "raw": "use aiken/math/rational.{Rational}",
          "source": "stdlib"
        },
        {
          "module": "cardano/address",
          "items": ["Credential"],
          "line": 4,
          "raw": "use cardano/address.{Credential}",
          "source": "stdlib"
        },
        {
          "module": "cardano/assets",
          "items": ["Lovelace"],
          "line": 5,
          "raw": "use cardano/assets.{Lovelace}",
          "source": "stdlib"
        },
        {
          "module": "cardano/governance/protocol_parameters",
          "items": ["ProtocolParametersUpdate"],
          "line": 6,
          "raw": "use cardano/governance/protocol_parameters.{ProtocolParametersUpdate}",
          "source": "stdlib"
        }
      ],
      "functions": [],
      "types": [
        {
          "name": "ProposalProcedure",
          "definition": "{ deposit: Lovelace, return_address: Credential, governance_action: GovernanceAction, }",
          "line": 8,
          "raw": "pub type ProposalProcedure {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "GovernanceAction",
          "definition": "{ ProtocolParameters { /// The last governance action of type 'ProtocolParameters'. They must all /// form a chain. ancestor: Option<GovernanceActionId>, /// The new proposed protocol parameters. Only values set to `Some` are relevant. new_parameters: ProtocolParametersUpdate, /// The optional guardrails script defined in the constitution. The script /// is executed by the ledger in addition to the hard-coded ledger rules. /// /// It must pass for the new protocol parameters to be deemed valid. guardrails: Option<ScriptHash>, } HardFork { /// The last governance action of type `HardFork`. They must all /// form a chain. ancestor: Option<GovernanceActionId>, /// The new proposed version. Few rules apply to proposing new versions: /// /// - The `major` component, if incremented, must be exactly one more than the current. /// - The `minor` component, if incremented, must be exactly one more than the current. /// - If the `major` component is incremented, `minor` must be set to `0`. /// - Neither `minor` nor `major` can be decremented. new_version: ProtocolVersion, } TreasuryWithdrawal { /// A collection of beneficiaries, which can be plain verification key /// hashes or script hashes (e.g. DAO). beneficiaries: Pairs<Credential, Lovelace>, /// The optional guardrails script defined in the constitution. The script /// is executed by the ledger in addition to the hard-coded ledger rules. /// /// It must pass for the withdrawals to be authorized. guardrails: Option<ScriptHash>, } NoConfidence { /// The last governance action of type `NoConfidence` or /// `ConstitutionalCommittee`. They must all / form a chain. ancestor: Option<GovernanceActionId>, } ConstitutionalCommittee { /// The last governance action of type `NoConfidence` or /// `ConstitutionalCommittee`. They must all / form a chain. ancestor: Option<GovernanceActionId>, /// Constitutional members to be removed. evicted_members: List<Credential>, /// Constitutional members to be added. added_members: Pairs<Credential, Mandate>, /// The new quorum value, as a ratio of a numerator and a denominator. The /// quorum specifies the threshold of 'Yes' votes necessary for the /// constitutional committee to accept a proposal procedure. quorum: Rational, } NewConstitution { /// The last governance action of type `Constitution` or /// `ConstitutionalCommittee`. They must all / form a chain. ancestor: Option<GovernanceActionId>, /// The new proposed constitution. constitution: Constitution, } NicePoll }",
          "line": 14,
          "raw": "pub type GovernanceAction {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Vote",
          "definition": "{ No Yes Abstain }",
          "line": 77,
          "raw": "pub type Vote {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "TransactionId",
          "definition": "Hash<Blake2b_256, ByteArray>",
          "line": 83,
          "raw": "pub type TransactionId =",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "GovernanceActionId",
          "definition": "{ transaction: TransactionId, proposal_procedure: Index, }",
          "line": 86,
          "raw": "pub type GovernanceActionId {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "ProtocolVersion",
          "definition": "{ major: Int, minor: Int, }",
          "line": 91,
          "raw": "pub type ProtocolVersion {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Constitution",
          "definition": "{ guardrails: Option<ScriptHash>, }",
          "line": 96,
          "raw": "pub type Constitution {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Mandate",
          "definition": "Int",
          "line": 102,
          "raw": "pub type Mandate =",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Voter",
          "definition": "{ ConstitutionalCommitteeMember(Credential) DelegateRepresentative(Credential) StakePool(VerificationKeyHash) }",
          "line": 105,
          "raw": "pub type Voter {",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/collection.{Index}\nuse aiken/crypto.{Blake2b_256, Hash, ScriptHash, VerificationKeyHash}\nuse aiken/math/rational.{Rational}\nuse cardano/address.{Credential}\nuse cardano/assets.{Lovelace}\nuse cardano/governance/protocol_parameters.{ProtocolParametersUpdate}\n\npub type ProposalProcedure {\n  deposit: Lovelace,\n  return_address: Credential,\n  governance_action: GovernanceAction,\n}\n\npub type GovernanceAction {\n  ProtocolParameters {\n    /// The last governance action of type 'ProtocolParameters'. They must all\n    /// form a chain.\n    ancestor: Option<GovernanceActionId>,\n    /// The new proposed protocol parameters. Only values set to `Some` are relevant.\n    new_parameters: ProtocolParametersUpdate,\n    /// The optional guardrails script defined in the constitution. The script\n    /// is executed by the ledger in addition to the hard-coded ledger rules.\n    ///\n    /// It must pass for the new protocol parameters to be deemed valid.\n    guardrails: Option<ScriptHash>,\n  }\n  HardFork {\n    /// The last governance action of type `HardFork`. They must all\n    /// form a chain.\n    ancestor: Option<GovernanceActionId>,\n    /// The new proposed version. Few rules apply to proposing new versions:\n    ///\n    /// - The `major` component, if incremented, must be exactly one more than the current.\n    /// - The `minor` component, if incremented, must be exactly one more than the current.\n    /// - If the `major` component is incremented, `minor` must be set to `0`.\n    /// - Neither `minor` nor `major` can be decremented.\n    new_version: ProtocolVersion,\n  }\n  TreasuryWithdrawal {\n    /// A collection of beneficiaries, which can be plain verification key\n    /// hashes or script hashes (e.g. DAO).\n    beneficiaries: Pairs<Credential, Lovelace>,\n    /// The optional guardrails script defined in the constitution. The script\n    /// is executed by the ledger in addition to the hard-coded ledger rules.\n    ///\n    /// It must pass for the withdrawals to be authorized.\n    guardrails: Option<ScriptHash>,\n  }\n  NoConfidence {\n    /// The last governance action of type `NoConfidence` or\n    /// `ConstitutionalCommittee`. They must all / form a chain.\n    ancestor: Option<GovernanceActionId>,\n  }\n  ConstitutionalCommittee {\n    /// The last governance action of type `NoConfidence` or\n    /// `ConstitutionalCommittee`. They must all / form a chain.\n    ancestor: Option<GovernanceActionId>,\n    /// Constitutional members to be removed.\n    evicted_members: List<Credential>,\n    /// Constitutional members to be added.\n    added_members: Pairs<Credential, Mandate>,\n    /// The new quorum value, as a ratio of a numerator and a denominator. The\n    /// quorum specifies the threshold of 'Yes' votes necessary for the\n    /// constitutional committee to accept a proposal procedure.\n    quorum: Rational,\n  }\n  NewConstitution {\n    /// The last governance action of type `Constitution` or\n    /// `ConstitutionalCommittee`. They must all / form a chain.\n    ancestor: Option<GovernanceActionId>,\n    /// The new proposed constitution.\n    constitution: Constitution,\n  }\n  NicePoll\n}\n\npub type Vote {\n  No\n  Yes\n  Abstain\n}\n\npub type TransactionId =\n  Hash<Blake2b_256, ByteArray>\n\npub type GovernanceActionId {\n  transaction: TransactionId,\n  proposal_procedure: Index,\n}\n\npub type ProtocolVersion {\n  major: Int,\n  minor: Int,\n}\n\npub type Constitution {\n  guardrails: Option<ScriptHash>,\n}\n\n/// An epoch number after which constitutional committee member\n/// mandate expires.\npub type Mandate =\n  Int\n\npub type Voter {\n  ConstitutionalCommitteeMember(Credential)\n  DelegateRepresentative(Credential)\n  StakePool(VerificationKeyHash)\n}\n",
      "dependencies": [
        "aiken/collection",
        "aiken/crypto",
        "aiken/math/rational",
        "cardano/address",
        "cardano/assets",
        "cardano/governance/protocol_parameters"
      ],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:cardano.script_context",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/cardano/script_context.ak",
      "name": "cardano.script_context",
      "imports": [
        {
          "module": "aiken/collection",
          "items": ["Index"],
          "line": 13,
          "raw": "use aiken/collection.{Index}",
          "source": "stdlib"
        },
        {
          "module": "cardano/address",
          "items": ["Credential"],
          "line": 14,
          "raw": "use cardano/address.{Credential}",
          "source": "stdlib"
        },
        {
          "module": "cardano/assets",
          "items": ["PolicyId"],
          "line": 15,
          "raw": "use cardano/assets.{PolicyId}",
          "source": "stdlib"
        },
        {
          "module": "cardano/certificate",
          "items": ["Certificate"],
          "line": 16,
          "raw": "use cardano/certificate.{Certificate}",
          "source": "stdlib"
        },
        {
          "module": "cardano/governance",
          "items": ["ProposalProcedure", "Voter"],
          "line": 17,
          "raw": "use cardano/governance.{ProposalProcedure, Voter}",
          "source": "stdlib"
        },
        {
          "module": "cardano/transaction",
          "items": ["OutputReference", "Redeemer", "Transaction"],
          "line": 18,
          "raw": "use cardano/transaction.{OutputReference, Redeemer, Transaction}",
          "source": "stdlib"
        }
      ],
      "functions": [],
      "types": [
        {
          "name": "ScriptContext",
          "definition": "{ transaction: Transaction, redeemer: Redeemer, info: ScriptInfo, }",
          "line": 27,
          "raw": "pub type ScriptContext {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "ScriptInfo",
          "definition": "{ /// For scripts executed as minting/burning policies, to insert /// or remove assets from circulation. It's parameterized by the identifier /// of the associated policy. Minting(PolicyId) /// For scripts that are used as payment credentials for addresses in /// transaction outputs. They govern the rule by which the output they /// reference can be spent. Spending { output: OutputReference, datum: Option<Data> } /// For scripts that validate reward withdrawals from a reward account. /// /// The argument identifies the target reward account. Withdrawing(Credential) /// Needed when delegating to a pool using stake credentials defined as a /// custom script. This purpose is also triggered when de-registering such /// stake credentials. /// /// The Int is a 0-based index of the given `Certificate` in `certificates`. Publishing { at: Index, certificate: Certificate } /// Voting for a type of voter using a governance action id to vote /// yes / no / abstain inside a transaction. /// /// The voter is who is doing the governance action. Voting(Voter) /// Used to propose a governance action. /// /// A 0-based index of the given `ProposalProcedure` in `proposal_procedures`. Proposing { at: Index, proposal_procedure: ProposalProcedure } }",
          "line": 34,
          "raw": "pub type ScriptInfo {",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "//// This module contains utilities for manually dealing with [`ScriptContext`](#ScriptContext). This is only ever useful for writing custom `else` handlers in validators.\n////\n//// > [!NOTE]\n//// > Unless you know what you're doing, you should prefer using named handlers:\n//// >\n//// > - `mint`\n//// > - `spend`\n//// > - `withdraw`\n//// > - `publish`\n//// > - `vote`\n//// > - `propose`\n\nuse aiken/collection.{Index}\nuse cardano/address.{Credential}\nuse cardano/assets.{PolicyId}\nuse cardano/certificate.{Certificate}\nuse cardano/governance.{ProposalProcedure, Voter}\nuse cardano/transaction.{OutputReference, Redeemer, Transaction}\n\n/// A context given to a script by the Cardano ledger when being executed.\n///\n/// The context contains information about the entire transaction that contains\n/// the script. The transaction may also contain other scripts; to distinguish\n/// between multiple scripts, the [`ScriptContext`](#ScriptContext) contains a\n/// [`ScriptInfo`](#ScriptInfo) which indicates which script (or, for what\n/// purpose) the transaction is being executed.\npub type ScriptContext {\n  transaction: Transaction,\n  redeemer: Redeemer,\n  info: ScriptInfo,\n}\n\n/// Characterizes the script information. The main (and only) difference with [`ScriptPurpose`](./transaction.html#ScriptPurpose) resides in the `Spending` variant which here contains a second field `datum: Option<Data>`.\npub type ScriptInfo {\n  /// For scripts executed as minting/burning policies, to insert\n  /// or remove assets from circulation. It's parameterized by the identifier\n  /// of the associated policy.\n  Minting(PolicyId)\n  /// For scripts that are used as payment credentials for addresses in\n  /// transaction outputs. They govern the rule by which the output they\n  /// reference can be spent.\n  Spending { output: OutputReference, datum: Option<Data> }\n  /// For scripts that validate reward withdrawals from a reward account.\n  ///\n  /// The argument identifies the target reward account.\n  Withdrawing(Credential)\n  /// Needed when delegating to a pool using stake credentials defined as a\n  /// custom script. This purpose is also triggered when de-registering such\n  /// stake credentials.\n  ///\n  /// The Int is a 0-based index of the given `Certificate` in `certificates`.\n  Publishing { at: Index, certificate: Certificate }\n  /// Voting for a type of voter using a governance action id to vote\n  /// yes / no / abstain inside a transaction.\n  ///\n  /// The voter is who is doing the governance action.\n  Voting(Voter)\n  /// Used to propose a governance action.\n  ///\n  /// A 0-based index of the given `ProposalProcedure` in `proposal_procedures`.\n  Proposing { at: Index, proposal_procedure: ProposalProcedure }\n}\n",
      "dependencies": [
        "aiken/collection",
        "cardano/address",
        "cardano/assets",
        "cardano/certificate",
        "cardano/governance",
        "cardano/transaction"
      ],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:cardano.transaction.output_reference",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/cardano/transaction/output_reference.ak",
      "name": "cardano.transaction.output_reference",
      "imports": [
        {
          "module": "aiken/primitive/bytearray",
          "items": [],
          "line": 1,
          "raw": "use aiken/primitive/bytearray",
          "source": "stdlib"
        },
        {
          "module": "aiken/primitive/int",
          "items": [],
          "line": 2,
          "raw": "use aiken/primitive/int",
          "source": "stdlib"
        },
        {
          "module": "cardano/transaction",
          "items": ["OutputReference"],
          "line": 3,
          "raw": "use cardano/transaction.{OutputReference}",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "compare",
          "signature": "pub fn compare(left: OutputReference, right: OutputReference) -> Ordering {",
          "parameters": [
            {
              "name": "left",
              "type": "OutputReference",
              "optional": false
            },
            {
              "name": "right",
              "type": "OutputReference",
              "optional": false
            }
          ],
          "returnType": "Ordering",
          "line": 5,
          "raw": "pub fn compare(left: OutputReference, right: OutputReference) -> Ordering {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn compare(left: OutputReference, right: OutputReference) -> Ordering {\n  when bytearray.compare(left.transaction_id, right.transaction_id) is {\n    Equal -> int.compare(left.output_index, right.output_index)\n    ordering -> ordering\n  }\n}",
          "tests": [
            "test compare_matrix() {\n  and {\n    (compare(OutputReference(\"\", 0), OutputReference(\"\", 0)) == Equal)?,\n    (compare(OutputReference(\"00\", 42), OutputReference(\"00\", 42)) == Equal)?,\n    (compare(OutputReference(\"00\", 0), OutputReference(\"01\", 0)) == Less)?,\n    (compare(OutputReference(\"01\", 0), OutputReference(\"00\", 0)) == Greater)?,\n    (compare(OutputReference(\"00\", 42), OutputReference(\"01\", 14)) == Less)?,\n    (compare(OutputReference(\"01\", 14), OutputReference(\"00\", 42)) == Greater)?,\n    (compare(OutputReference(\"\", 42), OutputReference(\"\", 14)) == Greater)?,\n    (compare(OutputReference(\"\", 14), OutputReference(\"\", 42)) == Less)?,\n  }\n}"
          ]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/primitive/bytearray\nuse aiken/primitive/int\nuse cardano/transaction.{OutputReference}\n\npub fn compare(left: OutputReference, right: OutputReference) -> Ordering {\n  when bytearray.compare(left.transaction_id, right.transaction_id) is {\n    Equal -> int.compare(left.output_index, right.output_index)\n    ordering -> ordering\n  }\n}\n\ntest compare_matrix() {\n  and {\n    (compare(OutputReference(\"\", 0), OutputReference(\"\", 0)) == Equal)?,\n    (compare(OutputReference(\"00\", 42), OutputReference(\"00\", 42)) == Equal)?,\n    (compare(OutputReference(\"00\", 0), OutputReference(\"01\", 0)) == Less)?,\n    (compare(OutputReference(\"01\", 0), OutputReference(\"00\", 0)) == Greater)?,\n    (compare(OutputReference(\"00\", 42), OutputReference(\"01\", 14)) == Less)?,\n    (compare(OutputReference(\"01\", 14), OutputReference(\"00\", 42)) == Greater)?,\n    (compare(OutputReference(\"\", 42), OutputReference(\"\", 14)) == Greater)?,\n    (compare(OutputReference(\"\", 14), OutputReference(\"\", 42)) == Less)?,\n  }\n}\n",
      "dependencies": [
        "aiken/primitive/bytearray",
        "aiken/primitive/int",
        "cardano/transaction"
      ],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:cardano.transaction.script_purpose",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/cardano/transaction/script_purpose.ak",
      "name": "cardano.transaction.script_purpose",
      "imports": [
        {
          "module": "aiken/primitive/bytearray",
          "items": [],
          "line": 1,
          "raw": "use aiken/primitive/bytearray",
          "source": "stdlib"
        },
        {
          "module": "aiken/primitive/int",
          "items": [],
          "line": 2,
          "raw": "use aiken/primitive/int",
          "source": "stdlib"
        },
        {
          "module": "cardano/address",
          "items": ["Script", "VerificationKey"],
          "line": 3,
          "raw": "use cardano/address.{Script, VerificationKey}",
          "source": "stdlib"
        },
        {
          "module": "cardano/address/credential",
          "items": [],
          "line": 4,
          "raw": "use cardano/address/credential",
          "source": "stdlib"
        },
        {
          "module": "cardano/certificate",
          "items": ["RegisterCredential"],
          "line": 5,
          "raw": "use cardano/certificate.{RegisterCredential}",
          "source": "stdlib"
        },
        {
          "module": "cardano/governance",
          "items": ["NicePoll", "ProposalProcedure", "StakePool"],
          "line": 6,
          "raw": "use cardano/governance.{NicePoll, ProposalProcedure, StakePool}",
          "source": "stdlib"
        },
        {
          "module": "cardano/governance/voter",
          "items": [],
          "line": 7,
          "raw": "use cardano/governance/voter",
          "source": "stdlib"
        },
        {
          "module": "cardano/transaction/output_reference",
          "items": [],
          "line": 11,
          "raw": "use cardano/transaction/output_reference",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "compare",
          "signature": "pub fn compare(left: ScriptPurpose, right: ScriptPurpose) -> Ordering {",
          "parameters": [
            {
              "name": "left",
              "type": "ScriptPurpose",
              "optional": false
            },
            {
              "name": "right",
              "type": "ScriptPurpose",
              "optional": false
            }
          ],
          "returnType": "Ordering",
          "line": 13,
          "raw": "pub fn compare(left: ScriptPurpose, right: ScriptPurpose) -> Ordering {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn compare(left: ScriptPurpose, right: ScriptPurpose) -> Ordering {\n  when left is {\n    Mint(left) ->\n      when right is {\n        Mint(right) -> bytearray.compare(left, right)\n        _ -> Less\n      }\n\n    Spend(left) ->\n      when right is {\n        Spend(right) -> output_reference.compare(left, right)\n        Mint(_) -> Greater\n        _ -> Less\n      }\n\n    Withdraw(left) ->\n      when right is {\n        Withdraw(right) -> credential.compare(left, right)\n        Spend(_) | Mint(_) -> Greater\n        _ -> Less\n      }\n\n    Publish { at: left, .. } ->\n      when right is {\n        Publish { at: right, .. } -> int.compare(left, right)\n        Spend(_) | Mint(_) | Withdraw(_) -> Greater\n        _ -> Less\n      }\n\n    Vote(left) ->\n      when right is {\n        Vote(right) -> voter.compare(left, right)\n        Propose { .. } -> Less\n        _ -> Greater\n      }\n\n    Propose { at: left, .. } ->\n      when right is {\n        Propose { at: right, .. } -> int.compare(left, right)\n        _ -> Greater\n      }\n  }\n}",
          "tests": [
            "test compare_matrix() {\n  let mint0 = Mint(\"0\")\n  let mint1 = Mint(\"1\")\n\n  let spend0 = Spend(OutputReference(\"\", 0))\n  let spend1 = Spend(OutputReference(\"\", 1))\n\n  let withdraw0 = Withdraw(VerificationKey(\"0\"))\n  let withdraw1 = Withdraw(VerificationKey(\"1\"))\n\n  let publish0 = Publish(0, RegisterCredential(Script(\"\"), Never))\n  let publish1 = Publish(1, RegisterCredential(Script(\"\"), Never))\n\n  let vote0 = Vote(StakePool(\"0\"))\n  let vote1 = Vote(StakePool(\"1\"))\n\n  let propose0 = Propose(0, ProposalProcedure(0, Script(\"\"), NicePoll))\n  let propose1 = Propose(1, ProposalProcedure(0, Script(\"\"), NicePoll))\n\n  and {\n    (compare(mint0, mint0) == Equal)?,\n    (compare(mint0, mint1) == Less)?,\n    (compare(mint1, mint0) == Greater)?,\n    (compare(mint0, spend0) == Less)?,\n    (compare(mint0, withdraw0) == Less)?,\n    (compare(mint0, publish0) == Less)?,\n    (compare(mint0, vote0) == Less)?,\n    (compare(mint0, propose0) == Less)?,\n    (compare(spend0, spend0) == Equal)?,\n    (compare(spend0, spend1) == Less)?,\n    (compare(spend1, spend0) == Greater)?,\n    (compare(spend0, mint0) == Greater)?,\n    (compare(spend0, withdraw0) == Less)?,\n    (compare(spend0, publish0) == Less)?,\n    (compare(spend0, vote0) == Less)?,\n    (compare(spend0, propose0) == Less)?,\n    (compare(withdraw0, withdraw0) == Equal)?,\n    (compare(withdraw0, withdraw1) == Less)?,\n    (compare(withdraw1, withdraw0) == Greater)?,\n    (compare(withdraw0, mint0) == Greater)?,\n    (compare(withdraw0, spend0) == Greater)?,\n    (compare(withdraw0, publish0) == Less)?,\n    (compare(withdraw0, vote0) == Less)?,\n    (compare(withdraw0, propose0) == Less)?,\n    (compare(publish0, publish0) == Equal)?,\n    (compare(publish0, publish1) == Less)?,\n    (compare(publish1, publish0) == Greater)?,\n    (compare(publish0, mint0) == Greater)?,\n    (compare(publish0, spend0) == Greater)?,\n    (compare(publish0, withdraw0) == Greater)?,\n    (compare(publish0, vote0) == Less)?,\n    (compare(publish0, propose0) == Less)?,\n    (compare(vote0, vote0) == Equal)?,\n    (compare(vote0, vote1) == Less)?,\n    (compare(vote1, vote0) == Greater)?,\n    (compare(vote0, mint0) == Greater)?,\n    (compare(vote0, spend0) == Greater)?,\n    (compare(vote0, withdraw0) == Greater)?,\n    (compare(vote0, publish0) == Greater)?,\n    (compare(vote0, propose0) == Less)?,\n    (compare(propose0, propose0) == Equal)?,\n    (compare(propose0, propose1) == Less)?,\n    (compare(propose1, propose0) == Greater)?,\n    (compare(propose0, mint0) == Greater)?,\n    (compare(propose0, spend0) == Greater)?,\n    (compare(propose0, withdraw0) == Greater)?,\n    (compare(propose0, publish0) == Greater)?,\n    (compare(propose0, vote0) == Greater)?,\n  }\n}"
          ]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/primitive/bytearray\nuse aiken/primitive/int\nuse cardano/address.{Script, VerificationKey}\nuse cardano/address/credential\nuse cardano/certificate.{RegisterCredential}\nuse cardano/governance.{NicePoll, ProposalProcedure, StakePool}\nuse cardano/governance/voter\nuse cardano/transaction.{\n  Mint, OutputReference, Propose, Publish, ScriptPurpose, Spend, Vote, Withdraw,\n}\nuse cardano/transaction/output_reference\n\npub fn compare(left: ScriptPurpose, right: ScriptPurpose) -> Ordering {\n  when left is {\n    Mint(left) ->\n      when right is {\n        Mint(right) -> bytearray.compare(left, right)\n        _ -> Less\n      }\n\n    Spend(left) ->\n      when right is {\n        Spend(right) -> output_reference.compare(left, right)\n        Mint(_) -> Greater\n        _ -> Less\n      }\n\n    Withdraw(left) ->\n      when right is {\n        Withdraw(right) -> credential.compare(left, right)\n        Spend(_) | Mint(_) -> Greater\n        _ -> Less\n      }\n\n    Publish { at: left, .. } ->\n      when right is {\n        Publish { at: right, .. } -> int.compare(left, right)\n        Spend(_) | Mint(_) | Withdraw(_) -> Greater\n        _ -> Less\n      }\n\n    Vote(left) ->\n      when right is {\n        Vote(right) -> voter.compare(left, right)\n        Propose { .. } -> Less\n        _ -> Greater\n      }\n\n    Propose { at: left, .. } ->\n      when right is {\n        Propose { at: right, .. } -> int.compare(left, right)\n        _ -> Greater\n      }\n  }\n}\n\ntest compare_matrix() {\n  let mint0 = Mint(\"0\")\n  let mint1 = Mint(\"1\")\n\n  let spend0 = Spend(OutputReference(\"\", 0))\n  let spend1 = Spend(OutputReference(\"\", 1))\n\n  let withdraw0 = Withdraw(VerificationKey(\"0\"))\n  let withdraw1 = Withdraw(VerificationKey(\"1\"))\n\n  let publish0 = Publish(0, RegisterCredential(Script(\"\"), Never))\n  let publish1 = Publish(1, RegisterCredential(Script(\"\"), Never))\n\n  let vote0 = Vote(StakePool(\"0\"))\n  let vote1 = Vote(StakePool(\"1\"))\n\n  let propose0 = Propose(0, ProposalProcedure(0, Script(\"\"), NicePoll))\n  let propose1 = Propose(1, ProposalProcedure(0, Script(\"\"), NicePoll))\n\n  and {\n    (compare(mint0, mint0) == Equal)?,\n    (compare(mint0, mint1) == Less)?,\n    (compare(mint1, mint0) == Greater)?,\n    (compare(mint0, spend0) == Less)?,\n    (compare(mint0, withdraw0) == Less)?,\n    (compare(mint0, publish0) == Less)?,\n    (compare(mint0, vote0) == Less)?,\n    (compare(mint0, propose0) == Less)?,\n    (compare(spend0, spend0) == Equal)?,\n    (compare(spend0, spend1) == Less)?,\n    (compare(spend1, spend0) == Greater)?,\n    (compare(spend0, mint0) == Greater)?,\n    (compare(spend0, withdraw0) == Less)?,\n    (compare(spend0, publish0) == Less)?,\n    (compare(spend0, vote0) == Less)?,\n    (compare(spend0, propose0) == Less)?,\n    (compare(withdraw0, withdraw0) == Equal)?,\n    (compare(withdraw0, withdraw1) == Less)?,\n    (compare(withdraw1, withdraw0) == Greater)?,\n    (compare(withdraw0, mint0) == Greater)?,\n    (compare(withdraw0, spend0) == Greater)?,\n    (compare(withdraw0, publish0) == Less)?,\n    (compare(withdraw0, vote0) == Less)?,\n    (compare(withdraw0, propose0) == Less)?,\n    (compare(publish0, publish0) == Equal)?,\n    (compare(publish0, publish1) == Less)?,\n    (compare(publish1, publish0) == Greater)?,\n    (compare(publish0, mint0) == Greater)?,\n    (compare(publish0, spend0) == Greater)?,\n    (compare(publish0, withdraw0) == Greater)?,\n    (compare(publish0, vote0) == Less)?,\n    (compare(publish0, propose0) == Less)?,\n    (compare(vote0, vote0) == Equal)?,\n    (compare(vote0, vote1) == Less)?,\n    (compare(vote1, vote0) == Greater)?,\n    (compare(vote0, mint0) == Greater)?,\n    (compare(vote0, spend0) == Greater)?,\n    (compare(vote0, withdraw0) == Greater)?,\n    (compare(vote0, publish0) == Greater)?,\n    (compare(vote0, propose0) == Less)?,\n    (compare(propose0, propose0) == Equal)?,\n    (compare(propose0, propose1) == Less)?,\n    (compare(propose1, propose0) == Greater)?,\n    (compare(propose0, mint0) == Greater)?,\n    (compare(propose0, spend0) == Greater)?,\n    (compare(propose0, withdraw0) == Greater)?,\n    (compare(propose0, publish0) == Greater)?,\n    (compare(propose0, vote0) == Greater)?,\n  }\n}\n",
      "dependencies": [
        "aiken/primitive/bytearray",
        "aiken/primitive/int",
        "cardano/address",
        "cardano/address/credential",
        "cardano/certificate",
        "cardano/governance",
        "cardano/governance/voter",
        "cardano/transaction/output_reference"
      ],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "stdlib:cardano.transaction",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-stdlib/cardano/transaction.ak",
      "name": "cardano.transaction",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 1,
          "raw": "use aiken/builtin",
          "source": "stdlib"
        },
        {
          "module": "aiken/collection",
          "items": ["Index"],
          "line": 2,
          "raw": "use aiken/collection.{Index}",
          "source": "stdlib"
        },
        {
          "module": "aiken/collection/dict",
          "items": ["Dict"],
          "line": 3,
          "raw": "use aiken/collection/dict.{Dict}",
          "source": "stdlib"
        },
        {
          "module": "aiken/collection/list",
          "items": [],
          "line": 4,
          "raw": "use aiken/collection/list",
          "source": "stdlib"
        },
        {
          "module": "aiken/interval",
          "items": ["Interval"],
          "line": 8,
          "raw": "use aiken/interval.{Interval}",
          "source": "stdlib"
        },
        {
          "module": "aiken/option",
          "items": [],
          "line": 9,
          "raw": "use aiken/option",
          "source": "stdlib"
        },
        {
          "module": "cardano/address",
          "items": ["Address", "Credential", "Script", "VerificationKey"],
          "line": 10,
          "raw": "use cardano/address.{Address, Credential, Script, VerificationKey}",
          "source": "stdlib"
        },
        {
          "module": "cardano/assets",
          "items": ["Lovelace", "PolicyId", "Value"],
          "line": 11,
          "raw": "use cardano/assets.{Lovelace, PolicyId, Value}",
          "source": "stdlib"
        },
        {
          "module": "cardano/certificate",
          "items": ["Certificate"],
          "line": 12,
          "raw": "use cardano/certificate.{Certificate}",
          "source": "stdlib"
        },
        {
          "module": "cardano/governance",
          "items": ["GovernanceActionId", "ProposalProcedure", "Vote", "Voter"],
          "line": 13,
          "raw": "use cardano/governance.{GovernanceActionId, ProposalProcedure, Vote, Voter}",
          "source": "stdlib"
        }
      ],
      "functions": [
        {
          "name": "find_input",
          "signature": "pub fn find_input(pub fn find_input(inputs: List<Input>, output_reference: OutputReference, ) -> Option<Input> {",
          "documentation": "Find an input by its [`OutputReference`](#OutputReference). This is typically used in\ncombination with the `Spend` [`ScriptPurpose`](#ScriptPurpose) to find a script's own\ninput.\n\n```aiken\nvalidator {\nspend(datum, redeemer, my_output_reference, self) {\nexpect Some(input) =\nself.inputs\n|> transaction.find_input(my_output_reference)\n}\n}\n```",
          "parameters": [],
          "returnType": "Option<Input>",
          "line": 136,
          "raw": "pub fn find_input(pub fn find_input(inputs: List<Input>, output_reference: OutputReference, ) -> Option<Input> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn find_input(\n  inputs: List<Input>,\n  output_reference: OutputReference,\n) -> Option<Input> {\n  inputs\n    |> list.find(fn(input) { input.output_reference == output_reference })\n}"
        },
        {
          "name": "find_datum",
          "signature": "pub fn find_datum(pub fn find_datum(outputs: List<Output>, datums: Dict<DataHash, Data>, datum_hash: DataHash, ) -> Option<Data> {",
          "documentation": "Find a [`Datum`](#Datum) by its hash, if present. The function looks first for\ndatums in the witness set, and then for inline datums if it doesn't find any in\nwitnesses.",
          "parameters": [],
          "returnType": "Option<Data>",
          "line": 147,
          "raw": "pub fn find_datum(pub fn find_datum(outputs: List<Output>, datums: Dict<DataHash, Data>, datum_hash: DataHash, ) -> Option<Data> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn find_datum(\n  outputs: List<Output>,\n  datums: Dict<DataHash, Data>,\n  datum_hash: DataHash,\n) -> Option<Data> {\n  datums\n    |> dict.get(datum_hash)\n    |> option.or_try(\n        fn() {\n          outputs\n            |> list.filter_map(\n                fn(output) {\n                  when output.datum is {\n                    InlineDatum(data) ->\n                      if blake2b_256(builtin.serialise_data(data)) == datum_hash {\n                        Some(data)\n                      } else {\n                        None\n                      }\n                    _ -> None\n                  }\n                },\n              )\n            |> list.head\n        },\n      )\n}"
        },
        {
          "name": "find_script_outputs",
          "signature": "pub fn find_script_outputs(pub fn find_script_outputs(outputs: List<Output>, script_hash: ScriptHash, ) -> List<Output> {",
          "documentation": "Find all outputs that are paying into the given script hash, if any. This is useful for\ncontracts running over multiple transactions.",
          "parameters": [],
          "returnType": "List<Output>",
          "line": 177,
          "raw": "pub fn find_script_outputs(pub fn find_script_outputs(outputs: List<Output>, script_hash: ScriptHash, ) -> List<Output> {",
          "isPublic": true,
          "source": "stdlib",
          "implementation": "pub fn find_script_outputs(\n  outputs: List<Output>,\n  script_hash: ScriptHash,\n) -> List<Output> {\n  outputs\n    |> list.filter(\n        fn(output) {\n          when output.address.payment_credential is {\n            Script(addr_script_hash) -> script_hash == addr_script_hash\n            VerificationKey(_) -> False\n          }\n        },\n      )\n}"
        }
      ],
      "types": [
        {
          "name": "TransactionId",
          "definition": "Hash<Blake2b_256, Transaction>",
          "line": 15,
          "raw": "pub type TransactionId =",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "ScriptPurpose",
          "definition": "{ /// For scripts executed as minting/burning policies, to insert /// or remove assets from circulation. It's parameterized by the identifier /// of the associated policy. Mint(PolicyId) /// For scripts that are used as payment credentials for addresses in /// transaction outputs. They govern the rule by which the output they /// reference can be spent. Spend(OutputReference) /// For scripts that validate reward withdrawals from a reward account. /// /// The argument identifies the target reward account. Withdraw(Credential) /// Needed when delegating to a pool using stake credentials defined as a /// custom script. This purpose is also triggered when de-registering such /// stake credentials. /// /// The Int is a 0-based index of the given `Certificate` in `certificates`. Publish { at: Index, certificate: Certificate } /// Voting for a type of voter using a governance action id to vote /// yes / no / abstain inside a transaction. /// /// The voter is who is doing the governance action. Vote(Voter) /// Used to propose a governance action. /// /// A 0-based index of the given `ProposalProcedure` in `proposal_procedures`. Propose { at: Index, proposal_procedure: ProposalProcedure } }",
          "line": 19,
          "raw": "pub type ScriptPurpose {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Transaction",
          "definition": "{ inputs: List<Input>, reference_inputs: List<Input>, outputs: List<Output>, fee: Lovelace, mint: Value, certificates: List<Certificate>, /// > [!IMPORTANT] /// > Withdrawals are ordered by ascending [Credential](./credential.html#Credential). Yet, note that [`Script`](./credential.html#Credential) credentials are treated as **lower values** than [`VerificationKey`](./credential.html#Credential) credentials. withdrawals: Pairs<Credential, Lovelace>, validity_range: ValidityRange, extra_signatories: List<VerificationKeyHash>, /// > [!IMPORTANT] /// > Redeemers are ordered by ascending [ScriptPurpose](./transaction.html#ScriptPurpose). redeemers: Pairs<ScriptPurpose, Redeemer>, datums: Dict<DataHash, Data>, id: TransactionId, /// > [!IMPORTANT] /// > Votes are ordered by ascending [Voter](./governance.html#Voter) and [GovernanceActionId](./governance.html#GovernanceActionId).<br/>First constructor variants in a type are treated as lower indices; except for [Credential](./credential.html#Credential) where [`Script`](./credential.html#Credential) credentials are treated as **lower values** than [`VerificationKey`](./credential.html#Credential) credentials. votes: Pairs<Voter, Pairs<GovernanceActionId, Vote>>, proposal_procedures: List<ProposalProcedure>, current_treasury_amount: Option<Lovelace>, treasury_donation: Option<Lovelace>, }",
          "line": 55,
          "raw": "pub type Transaction {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "ValidityRange",
          "definition": "Interval",
          "line": 81,
          "raw": "pub type ValidityRange =",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Input",
          "definition": "{ output_reference: OutputReference, output: Output, }",
          "line": 85,
          "raw": "pub type Input {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "OutputReference",
          "definition": "{ transaction_id: Hash<Blake2b_256, Transaction>, output_index: Int, }",
          "line": 93,
          "raw": "pub type OutputReference {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Output",
          "definition": "{ address: Address, value: Value, datum: Datum, reference_script: Option<ScriptHash>, }",
          "line": 99,
          "raw": "pub type Output {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Datum",
          "definition": "{ NoDatum /// A datum referenced by its hash digest. DatumHash(DataHash) /// A datum completely inlined in the output. InlineDatum(Data) }",
          "line": 107,
          "raw": "pub type Datum {",
          "isPublic": true,
          "source": "stdlib"
        },
        {
          "name": "Redeemer",
          "definition": "Data",
          "line": 118,
          "raw": "pub type Redeemer =",
          "isPublic": true,
          "source": "stdlib"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/builtin\nuse aiken/collection.{Index}\nuse aiken/collection/dict.{Dict}\nuse aiken/collection/list\nuse aiken/crypto.{\n  Blake2b_256, DataHash, Hash, ScriptHash, VerificationKeyHash, blake2b_256,\n}\nuse aiken/interval.{Interval}\nuse aiken/option\nuse cardano/address.{Address, Credential, Script, VerificationKey}\nuse cardano/assets.{Lovelace, PolicyId, Value}\nuse cardano/certificate.{Certificate}\nuse cardano/governance.{GovernanceActionId, ProposalProcedure, Vote, Voter}\n\npub type TransactionId =\n  Hash<Blake2b_256, Transaction>\n\n/// Characterizes the script purpose.\npub type ScriptPurpose {\n  /// For scripts executed as minting/burning policies, to insert\n  /// or remove assets from circulation. It's parameterized by the identifier\n  /// of the associated policy.\n  Mint(PolicyId)\n  /// For scripts that are used as payment credentials for addresses in\n  /// transaction outputs. They govern the rule by which the output they\n  /// reference can be spent.\n  Spend(OutputReference)\n  /// For scripts that validate reward withdrawals from a reward account.\n  ///\n  /// The argument identifies the target reward account.\n  Withdraw(Credential)\n  /// Needed when delegating to a pool using stake credentials defined as a\n  /// custom script. This purpose is also triggered when de-registering such\n  /// stake credentials.\n  ///\n  /// The Int is a 0-based index of the given `Certificate` in `certificates`.\n  Publish { at: Index, certificate: Certificate }\n  /// Voting for a type of voter using a governance action id to vote\n  /// yes / no / abstain inside a transaction.\n  ///\n  /// The voter is who is doing the governance action.\n  Vote(Voter)\n  /// Used to propose a governance action.\n  ///\n  /// A 0-based index of the given `ProposalProcedure` in `proposal_procedures`.\n  Propose { at: Index, proposal_procedure: ProposalProcedure }\n}\n\n/// A Cardano `Transaction`, as seen by on-chain scripts.\n///\n/// Note that this is a representation of a transaction, and not the 1:1\n/// translation of the transaction as seen by the ledger. In particular,\n/// on-chain scripts can't see inputs locked by bootstrap addresses, outputs\n/// to bootstrap addresses or just transaction metadata.\npub type Transaction {\n  inputs: List<Input>,\n  reference_inputs: List<Input>,\n  outputs: List<Output>,\n  fee: Lovelace,\n  mint: Value,\n  certificates: List<Certificate>,\n  /// > [!IMPORTANT]\n  /// > Withdrawals are ordered by ascending [Credential](./credential.html#Credential). Yet, note that [`Script`](./credential.html#Credential) credentials are treated as **lower values** than [`VerificationKey`](./credential.html#Credential) credentials.\n  withdrawals: Pairs<Credential, Lovelace>,\n  validity_range: ValidityRange,\n  extra_signatories: List<VerificationKeyHash>,\n  /// > [!IMPORTANT]\n  /// > Redeemers are ordered by ascending [ScriptPurpose](./transaction.html#ScriptPurpose).\n  redeemers: Pairs<ScriptPurpose, Redeemer>,\n  datums: Dict<DataHash, Data>,\n  id: TransactionId,\n  /// > [!IMPORTANT]\n  /// > Votes are ordered by ascending [Voter](./governance.html#Voter) and [GovernanceActionId](./governance.html#GovernanceActionId).<br/>First constructor variants in a type are treated as lower indices; except for [Credential](./credential.html#Credential) where [`Script`](./credential.html#Credential) credentials are treated as **lower values** than [`VerificationKey`](./credential.html#Credential) credentials.\n  votes: Pairs<Voter, Pairs<GovernanceActionId, Vote>>,\n  proposal_procedures: List<ProposalProcedure>,\n  current_treasury_amount: Option<Lovelace>,\n  treasury_donation: Option<Lovelace>,\n}\n\n/// An interval of POSIX time, measured in **number of milliseconds** since 1970-01-01T00:00:00Z.\npub type ValidityRange =\n  Interval\n\n/// An `Input` made of an output reference and, the resolved value associated with that output.\npub type Input {\n  output_reference: OutputReference,\n  output: Output,\n}\n\n/// An `OutputReference` is a unique reference to an output on-chain. The `output_index`\n/// corresponds to the position in the output list of the transaction (identified by its id)\n/// that produced that output\npub type OutputReference {\n  transaction_id: Hash<Blake2b_256, Transaction>,\n  output_index: Int,\n}\n\n/// A transaction `Output`, with an address, a value and optional datums and script references.\npub type Output {\n  address: Address,\n  value: Value,\n  datum: Datum,\n  reference_script: Option<ScriptHash>,\n}\n\n/// An output `Datum`.\npub type Datum {\n  NoDatum\n  /// A datum referenced by its hash digest.\n  DatumHash(DataHash)\n  /// A datum completely inlined in the output.\n  InlineDatum(Data)\n}\n\n/// A type-alias for Redeemers, passed to scripts for validation. The `Data` is\n/// opaque because it is user-defined and it is the script's responsibility to\n/// parse it into its expected form.\npub type Redeemer =\n  Data\n\n// ## Querying\n\n/// Find an input by its [`OutputReference`](#OutputReference). This is typically used in\n/// combination with the `Spend` [`ScriptPurpose`](#ScriptPurpose) to find a script's own\n/// input.\n///\n/// ```aiken\n/// validator {\n///   spend(datum, redeemer, my_output_reference, self) {\n///     expect Some(input) =\n///       self.inputs\n///         |> transaction.find_input(my_output_reference)\n///   }\n/// }\n/// ```\npub fn find_input(\n  inputs: List<Input>,\n  output_reference: OutputReference,\n) -> Option<Input> {\n  inputs\n    |> list.find(fn(input) { input.output_reference == output_reference })\n}\n\n/// Find a [`Datum`](#Datum) by its hash, if present. The function looks first for\n/// datums in the witness set, and then for inline datums if it doesn't find any in\n/// witnesses.\npub fn find_datum(\n  outputs: List<Output>,\n  datums: Dict<DataHash, Data>,\n  datum_hash: DataHash,\n) -> Option<Data> {\n  datums\n    |> dict.get(datum_hash)\n    |> option.or_try(\n        fn() {\n          outputs\n            |> list.filter_map(\n                fn(output) {\n                  when output.datum is {\n                    InlineDatum(data) ->\n                      if blake2b_256(builtin.serialise_data(data)) == datum_hash {\n                        Some(data)\n                      } else {\n                        None\n                      }\n                    _ -> None\n                  }\n                },\n              )\n            |> list.head\n        },\n      )\n}\n\n/// Find all outputs that are paying into the given script hash, if any. This is useful for\n/// contracts running over multiple transactions.\npub fn find_script_outputs(\n  outputs: List<Output>,\n  script_hash: ScriptHash,\n) -> List<Output> {\n  outputs\n    |> list.filter(\n        fn(output) {\n          when output.address.payment_credential is {\n            Script(addr_script_hash) -> script_hash == addr_script_hash\n            VerificationKey(_) -> False\n          }\n        },\n      )\n}\n\n// ## Testing\n\n/// A placeholder / empty `Transaction` to serve as a base in a transaction\n/// builder. This is particularly useful for constructing test transactions.\n///\n/// Every field is empty or null, and we have in particular:\n///\n/// ```aiken\n/// use aiken/interval\n///\n/// transaction.placeholder.id ==\n///   #\"0000000000000000000000000000000000000000000000000000000000000000\"\n///\n/// transaction.placeholder.validity_range == interval.everything\n/// ```\npub const placeholder: Transaction =\n  Transaction {\n    inputs: [],\n    reference_inputs: [],\n    outputs: [],\n    fee: 0,\n    mint: assets.zero,\n    certificates: [],\n    withdrawals: [],\n    validity_range: interval.everything,\n    extra_signatories: [],\n    redeemers: [],\n    datums: dict.empty,\n    id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n    votes: [],\n    proposal_procedures: [],\n    current_treasury_amount: None,\n    treasury_donation: None,\n  }\n",
      "dependencies": [
        "aiken/builtin",
        "aiken/collection",
        "aiken/collection/dict",
        "aiken/collection/list",
        "aiken/interval",
        "aiken/option",
        "cardano/address",
        "cardano/assets",
        "cardano/certificate",
        "cardano/governance"
      ],
      "source": "stdlib",
      "isReExportFile": false
    },
    {
      "key": "prelude:aiken.builtin",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-prelude/lib/aiken/builtin.ak",
      "name": "aiken.builtin",
      "imports": [],
      "functions": [
        {
          "name": "add_integer",
          "signature": "pub fn add_integer(left: Int, right: Int) -> Int {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nAdds two integers (+).",
          "parameters": [
            {
              "name": "left",
              "type": "Int",
              "optional": false
            },
            {
              "name": "right",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 13,
          "raw": "pub fn add_integer(left: Int, right: Int) -> Int {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn add_integer(left: Int, right: Int) -> Int {\n  fail\n}"
        },
        {
          "name": "subtract_integer",
          "signature": "pub fn subtract_integer(left: Int, right: Int) -> Int {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nSubtract two integers (-).",
          "parameters": [
            {
              "name": "left",
              "type": "Int",
              "optional": false
            },
            {
              "name": "right",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 21,
          "raw": "pub fn subtract_integer(left: Int, right: Int) -> Int {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn subtract_integer(left: Int, right: Int) -> Int {\n  fail\n}"
        },
        {
          "name": "multiply_integer",
          "signature": "pub fn multiply_integer(left: Int, right: Int) -> Int {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nMultiple two integers (*).",
          "parameters": [
            {
              "name": "left",
              "type": "Int",
              "optional": false
            },
            {
              "name": "right",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 29,
          "raw": "pub fn multiply_integer(left: Int, right: Int) -> Int {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn multiply_integer(left: Int, right: Int) -> Int {\n  fail\n}"
        },
        {
          "name": "divide_integer",
          "signature": "pub fn divide_integer(numerator: Int, denominator: Int) -> Int {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInteger division truncated towards negative infinity (/).",
          "parameters": [
            {
              "name": "numerator",
              "type": "Int",
              "optional": false
            },
            {
              "name": "denominator",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 37,
          "raw": "pub fn divide_integer(numerator: Int, denominator: Int) -> Int {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn divide_integer(numerator: Int, denominator: Int) -> Int {\n  fail\n}"
        },
        {
          "name": "quotient_integer",
          "signature": "pub fn quotient_integer(numerator: Int, denominator: Int) -> Int {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInteger division truncated towards zero.",
          "parameters": [
            {
              "name": "numerator",
              "type": "Int",
              "optional": false
            },
            {
              "name": "denominator",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 45,
          "raw": "pub fn quotient_integer(numerator: Int, denominator: Int) -> Int {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn quotient_integer(numerator: Int, denominator: Int) -> Int {\n  fail\n}"
        },
        {
          "name": "remainder_integer",
          "signature": "pub fn remainder_integer(numerator: Int, denominator: Int) -> Int {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInteger remainder, satisfying\n\n```aiken\nquotient_integer(x, y) * y + remainder_integer(x, y) == x\n```",
          "parameters": [
            {
              "name": "numerator",
              "type": "Int",
              "optional": false
            },
            {
              "name": "denominator",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 57,
          "raw": "pub fn remainder_integer(numerator: Int, denominator: Int) -> Int {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn remainder_integer(numerator: Int, denominator: Int) -> Int {\n  fail\n}"
        },
        {
          "name": "mod_integer",
          "signature": "pub fn mod_integer(numerator: Int, denominator: Int) -> Int {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInteger modulus (%), satisfying\n\n```aiken\ndivide_integer(x, y) * y + mod_integer(x, y) == x\n```",
          "parameters": [
            {
              "name": "numerator",
              "type": "Int",
              "optional": false
            },
            {
              "name": "denominator",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 69,
          "raw": "pub fn mod_integer(numerator: Int, denominator: Int) -> Int {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn mod_integer(numerator: Int, denominator: Int) -> Int {\n  fail\n}"
        },
        {
          "name": "equals_integer",
          "signature": "pub fn equals_integer(left: Int, right: Int) -> Bool {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInteger equality.",
          "parameters": [
            {
              "name": "left",
              "type": "Int",
              "optional": false
            },
            {
              "name": "right",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 77,
          "raw": "pub fn equals_integer(left: Int, right: Int) -> Bool {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn equals_integer(left: Int, right: Int) -> Bool {\n  fail\n}"
        },
        {
          "name": "less_than_integer",
          "signature": "pub fn less_than_integer(left: Int, right: Int) -> Bool {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInteger strict inequality.",
          "parameters": [
            {
              "name": "left",
              "type": "Int",
              "optional": false
            },
            {
              "name": "right",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 85,
          "raw": "pub fn less_than_integer(left: Int, right: Int) -> Bool {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn less_than_integer(left: Int, right: Int) -> Bool {\n  fail\n}"
        },
        {
          "name": "less_than_equals_integer",
          "signature": "pub fn less_than_equals_integer(left: Int, right: Int) -> Bool {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInteger inequality.",
          "parameters": [
            {
              "name": "left",
              "type": "Int",
              "optional": false
            },
            {
              "name": "right",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 93,
          "raw": "pub fn less_than_equals_integer(left: Int, right: Int) -> Bool {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn less_than_equals_integer(left: Int, right: Int) -> Bool {\n  fail\n}"
        },
        {
          "name": "integer_to_bytearray",
          "signature": "pub fn integer_to_bytearray(pub fn integer_to_bytearray(endianness: Bool, size: Int, value: Int, ) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nConvert an integer value into a [ByteArray](../aiken.html#ByteArray).\n\n- The first arguments / specifies the endianness:\n\nboolean value | endianness\n----          | ----\nTrue          | Big endian\nFalse         | Little endian\n\n- The second argument indicates the target `size` (in bytes) of the final [ByteArray](../aiken.html#ByteArray). This allows to allocate a specific number of bytes in advance. The function fails if the given value cannot fit in the requested size or if the `value` is negative. However, a size of 0 will yield a [ByteArray](../aiken.html#ByteArray) that is precisely as large as necessary to fit the `value`.",
          "parameters": [],
          "returnType": "ByteArray",
          "line": 110,
          "raw": "pub fn integer_to_bytearray(pub fn integer_to_bytearray(endianness: Bool, size: Int, value: Int, ) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn integer_to_bytearray(\n  endianness: Bool,\n  size: Int,\n  value: Int,\n) -> ByteArray {\n  fail\n}"
        },
        {
          "name": "append_bytearray",
          "signature": "pub fn append_bytearray(left: ByteArray, right: ByteArray) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConcatenate two bytearrays together.",
          "parameters": [
            {
              "name": "left",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "right",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 126,
          "raw": "pub fn append_bytearray(left: ByteArray, right: ByteArray) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn append_bytearray(left: ByteArray, right: ByteArray) -> ByteArray {\n  fail\n}"
        },
        {
          "name": "cons_bytearray",
          "signature": "pub fn cons_bytearray(byte: Int, bytes: ByteArray) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nPush a byte in front of a bytearray.",
          "parameters": [
            {
              "name": "byte",
              "type": "Int",
              "optional": false
            },
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 134,
          "raw": "pub fn cons_bytearray(byte: Int, bytes: ByteArray) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn cons_bytearray(byte: Int, bytes: ByteArray) -> ByteArray {\n  fail\n}"
        },
        {
          "name": "replicate_byte",
          "signature": "pub fn replicate_byte(length: Int, byte: Int) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nConstruct a `ByteArray` from the repetition of the same byte a specific number of times. Fails if the byte is out-of-bound or if the length is negative.",
          "parameters": [
            {
              "name": "length",
              "type": "Int",
              "optional": false
            },
            {
              "name": "byte",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 142,
          "raw": "pub fn replicate_byte(length: Int, byte: Int) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn replicate_byte(length: Int, byte: Int) -> ByteArray {\n  todo\n}"
        },
        {
          "name": "count_set_bits",
          "signature": "pub fn count_set_bits(self: ByteArray) -> Int {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nCount the number of bits set in the given `ByteArray`.",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 152,
          "raw": "pub fn count_set_bits(self: ByteArray) -> Int {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn count_set_bits(self: ByteArray) -> Int {\n  todo\n}"
        },
        {
          "name": "find_first_set_bit",
          "signature": "pub fn find_first_set_bit(self: ByteArray) -> Int {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nFind the index of the first bit set. Note that bits are indexed _from the end_ (see also [`read_bit`](#read_bit) for more details).",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 160,
          "raw": "pub fn find_first_set_bit(self: ByteArray) -> Int {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn find_first_set_bit(self: ByteArray) -> Int {\n  todo\n}"
        },
        {
          "name": "index_bytearray",
          "signature": "pub fn index_bytearray(bytes: ByteArray, index: Int) -> Int {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nAccess the byte at the given index in the bytearray.",
          "parameters": [
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "index",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 168,
          "raw": "pub fn index_bytearray(bytes: ByteArray, index: Int) -> Int {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn index_bytearray(bytes: ByteArray, index: Int) -> Int {\n  fail\n}"
        },
        {
          "name": "length_of_bytearray",
          "signature": "pub fn length_of_bytearray(bytes: ByteArray) -> Int {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nNumber of bytes in a bytearray.",
          "parameters": [
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 176,
          "raw": "pub fn length_of_bytearray(bytes: ByteArray) -> Int {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn length_of_bytearray(bytes: ByteArray) -> Int {\n  fail\n}"
        },
        {
          "name": "read_bit",
          "signature": "pub fn read_bit(self: ByteArray, index: Int) -> Bool {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nRead a particular bit (`True` if set) at the given index. Fails if the\nindex is out-of-bounds. Note that the index reads _from the end_. For\nexample, consider the byte `0xF4` and an index `i`:\n\ni=7 | i=6 | i=5 | i=4 | i=3 | i=2 | i=1 | i=0\n--- | --- | --- | --- | --- | --- | --- | ---\n1  |  1  |  1  |  1  |  0  |  1  |  0  |  0\n\nSo, we have:\n\n```aiken\nread_bit(#[0xF4], 0) == False\nread_bit(#[0xF4], 1) == False\nread_bit(#[0xF4], 2) == True\nread_bit(#[0xF4], 3) == False\nread_bit(#[0xF4], 4) == True\nread_bit(#[0xF4], 5) == True\nread_bit(#[0xF4], 6) == True\nread_bit(#[0xF4], 7) == True\nread_bit(#[0xF4, 0xF4], 8) == False\n```",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "index",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 204,
          "raw": "pub fn read_bit(self: ByteArray, index: Int) -> Bool {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn read_bit(self: ByteArray, index: Int) -> Bool {\n  fail\n}"
        },
        {
          "name": "slice_bytearray",
          "signature": "pub fn slice_bytearray(start: Int, len: Int, bytes: ByteArray) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nExtract a sub-array from a bytearray given starting and length of the sub-array.",
          "parameters": [
            {
              "name": "start",
              "type": "Int",
              "optional": false
            },
            {
              "name": "len",
              "type": "Int",
              "optional": false
            },
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 212,
          "raw": "pub fn slice_bytearray(start: Int, len: Int, bytes: ByteArray) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn slice_bytearray(start: Int, len: Int, bytes: ByteArray) -> ByteArray {\n  fail\n}"
        },
        {
          "name": "write_bits",
          "signature": "pub fn write_bits(self: ByteArray, indices: List<Int>, value: Bool) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nWrite a bit each index in the list of indices. Writes 1 if value is True and 0 if value is False.\nFails if the index is out-of-bounds. Note that the index reads _from the end_.\nFor example, consider the byte `0xF4` and an index `i`:\n\ni=7 | i=6 | i=5 | i=4 | i=3 | i=2 | i=1 | i=0\n--- | --- | --- | --- | --- | --- | --- | ---\n1  |  1  |  1  |  1  |  0  |  1  |  0  |  0\n\nSo, we have:\n\n```aiken\nwrite_bits(#[0xF4], [0, 1], True) == #[0xF7]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "indices",
              "type": "List<Int>",
              "optional": false
            },
            {
              "name": "value",
              "type": "Bool",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 232,
          "raw": "pub fn write_bits(self: ByteArray, indices: List<Int>, value: Bool) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn write_bits(self: ByteArray, indices: List<Int>, value: Bool) -> ByteArray {\n  fail\n}"
        },
        {
          "name": "equals_bytearray",
          "signature": "pub fn equals_bytearray(left: ByteArray, right: ByteArray) -> Bool {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nBytearray equality.",
          "parameters": [
            {
              "name": "left",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "right",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 242,
          "raw": "pub fn equals_bytearray(left: ByteArray, right: ByteArray) -> Bool {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn equals_bytearray(left: ByteArray, right: ByteArray) -> Bool {\n  fail\n}"
        },
        {
          "name": "less_than_bytearray",
          "signature": "pub fn less_than_bytearray(left: ByteArray, right: ByteArray) -> Bool {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nBytearray strict inequality.",
          "parameters": [
            {
              "name": "left",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "right",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 250,
          "raw": "pub fn less_than_bytearray(left: ByteArray, right: ByteArray) -> Bool {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn less_than_bytearray(left: ByteArray, right: ByteArray) -> Bool {\n  fail\n}"
        },
        {
          "name": "less_than_equals_bytearray",
          "signature": "pub fn less_than_equals_bytearray(left: ByteArray, right: ByteArray) -> Bool {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nBytearray inequality.",
          "parameters": [
            {
              "name": "left",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "right",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 258,
          "raw": "pub fn less_than_equals_bytearray(left: ByteArray, right: ByteArray) -> Bool {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn less_than_equals_bytearray(left: ByteArray, right: ByteArray) -> Bool {\n  fail\n}"
        },
        {
          "name": "and_bytearray",
          "signature": "pub fn and_bytearray(pub fn and_bytearray(padding: Bool, left: ByteArray, right: ByteArray, ) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nLogical AND applied to two bytearrays. The first argument indicates whether padding semantics should be used. If this argument is `False`, truncation semantics are used instead.\n\n> [!NOTE]\n> All bitwise operations are processed in little-endian bit order. For\n> example, ANDing `#\"F0\"` with `#\"0FFF\"` will yield a `#\"00\"` (or `#\"00FF\"`\n> if `padding` is `True`).",
          "parameters": [],
          "returnType": "ByteArray",
          "line": 273,
          "raw": "pub fn and_bytearray(pub fn and_bytearray(padding: Bool, left: ByteArray, right: ByteArray, ) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn and_bytearray(\n  padding: Bool,\n  left: ByteArray,\n  right: ByteArray,\n) -> ByteArray {\n  todo\n}"
        },
        {
          "name": "or_bytearray",
          "signature": "pub fn or_bytearray(pub fn or_bytearray(padding: Bool, left: ByteArray, right: ByteArray, ) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nLogical OR applied to two bytearrays. The first argument indicates whether padding semantics should be used. If this argument is `False`, truncation semantics are used instead.\n\n> [!NOTE]\n> All bitwise operations are processed in little-endian bit order. For\n> example, ORing `#\"FF\"` with `#\"00FF\"` will yield a `#\"FF\"` (or `#\"FFFF\"`\n> if `padding` is `True`).",
          "parameters": [],
          "returnType": "ByteArray",
          "line": 290,
          "raw": "pub fn or_bytearray(pub fn or_bytearray(padding: Bool, left: ByteArray, right: ByteArray, ) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn or_bytearray(\n  padding: Bool,\n  left: ByteArray,\n  right: ByteArray,\n) -> ByteArray {\n  todo\n}"
        },
        {
          "name": "xor_bytearray",
          "signature": "pub fn xor_bytearray(pub fn xor_bytearray(padding: Bool, left: ByteArray, right: ByteArray, ) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nLogical XOR applied to two bytearrays. The first argument indicates whether padding semantics should be used. If this argument is `False`, truncation semantics are used instead.\n\n> [!NOTE]\n> All bitwise operations are processed in little-endian bit order. For\n> example, XORing `#\"0F\"` with `#\"0000\"` will yield a `#\"0F\"` (or `#\"0F00\"`\n> if `padding` is `True`).",
          "parameters": [],
          "returnType": "ByteArray",
          "line": 307,
          "raw": "pub fn xor_bytearray(pub fn xor_bytearray(padding: Bool, left: ByteArray, right: ByteArray, ) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn xor_bytearray(\n  padding: Bool,\n  left: ByteArray,\n  right: ByteArray,\n) -> ByteArray {\n  todo\n}"
        },
        {
          "name": "complement_bytearray",
          "signature": "pub fn complement_bytearray(self: ByteArray) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nLogical bitwise complement of the bytearray (set becomes unset, and unset becomes set).",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 319,
          "raw": "pub fn complement_bytearray(self: ByteArray) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn complement_bytearray(self: ByteArray) -> ByteArray {\n  todo\n}"
        },
        {
          "name": "rotate_bytearray",
          "signature": "pub fn rotate_bytearray(self: ByteArray, offset: Int) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nLike [`shift_bytearray`](#shift_bytearray) but instead of introducing zeroes in holes, use the bits that are dropped from either ends.\n\n```aiken\nrotate_bytearray(#[0xEB, 0xFC], 5) == #[0x7F, 0x9D]\nrotate_bytearray(#[0xEB, 0xFC], -8) == #[0xFC, 0xEB]\nrotate_bytearray(#[0xEB, 0xFC], 8) == #[0xFC, 0xEB]\n```",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "offset",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 335,
          "raw": "pub fn rotate_bytearray(self: ByteArray, offset: Int) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn rotate_bytearray(self: ByteArray, offset: Int) -> ByteArray {\n  todo\n}"
        },
        {
          "name": "shift_bytearray",
          "signature": "pub fn shift_bytearray(self: ByteArray, offset: Int) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nShift bits in a `ByteArray` by the given offset, replacing holes with zeroes. The offset can be positive (left-shift) or negative (right-shift).\n\n```aiken\nshift_bytearray(#[0xEB, 0xFC], 5) == #[0x7F, 0x80]\nshift_bytearray(#[0xEB, 0xFC], -8) == #[0x00, 0xEB]\nshift_bytearray(#[0xEB, 0xFC], 8) == #[0xFC, 0x00]\n```\n> [!NOTE]\n> Size of the given `ByteArray` remains unchanged, e.g. performing a\n> left-shift of `1` on `#\"80\"` results in `#\"00\"`.",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "offset",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 352,
          "raw": "pub fn shift_bytearray(self: ByteArray, offset: Int) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn shift_bytearray(self: ByteArray, offset: Int) -> ByteArray {\n  todo\n}"
        },
        {
          "name": "bytearray_to_integer",
          "signature": "pub fn bytearray_to_integer(endianness: Bool, bytes: ByteArray) -> Int {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nConvert a [ByteArray](../aiken.html#ByteArray) to an integer value. The first argument\nspecifies the endianness:\n\nboolean value | endianness\n----          | ----\nTrue          | Big endian\nFalse         | Little endian",
          "parameters": [
            {
              "name": "endianness",
              "type": "Bool",
              "optional": false
            },
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 368,
          "raw": "pub fn bytearray_to_integer(endianness: Bool, bytes: ByteArray) -> Int {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn bytearray_to_integer(endianness: Bool, bytes: ByteArray) -> Int {\n  fail\n}"
        },
        {
          "name": "append_string",
          "signature": "pub fn append_string(left: String, right: String) -> String {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConcatenate two strings.",
          "parameters": [
            {
              "name": "left",
              "type": "String",
              "optional": false
            },
            {
              "name": "right",
              "type": "String",
              "optional": false
            }
          ],
          "returnType": "String",
          "line": 378,
          "raw": "pub fn append_string(left: String, right: String) -> String {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn append_string(left: String, right: String) -> String {\n  fail\n}"
        },
        {
          "name": "equals_string",
          "signature": "pub fn equals_string(left: String, right: String) -> Bool {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nString equality.",
          "parameters": [
            {
              "name": "left",
              "type": "String",
              "optional": false
            },
            {
              "name": "right",
              "type": "String",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 386,
          "raw": "pub fn equals_string(left: String, right: String) -> Bool {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn equals_string(left: String, right: String) -> Bool {\n  fail\n}"
        },
        {
          "name": "encode_utf8",
          "signature": "pub fn encode_utf8(str: String) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConvert a string into a UTF-8 encoded array of bytes.",
          "parameters": [
            {
              "name": "str",
              "type": "String",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 394,
          "raw": "pub fn encode_utf8(str: String) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn encode_utf8(str: String) -> ByteArray {\n  fail\n}"
        },
        {
          "name": "decode_utf8",
          "signature": "pub fn decode_utf8(bytes: ByteArray) -> String {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInterpret a UTF-8 encoded array of bytes as a String. Fails if the bytes aren't UTF-8 encoded.",
          "parameters": [
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "String",
          "line": 402,
          "raw": "pub fn decode_utf8(bytes: ByteArray) -> String {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn decode_utf8(bytes: ByteArray) -> String {\n  fail\n}"
        },
        {
          "name": "new_list",
          "signature": "pub fn new_list() -> List<Data> {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConstruct an empty list of Data.",
          "parameters": [],
          "returnType": "List<Data>",
          "line": 412,
          "raw": "pub fn new_list() -> List<Data> {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn new_list() -> List<Data> {\n  fail\n}"
        },
        {
          "name": "cons_list",
          "signature": "pub fn cons_list(elem: a, list: List<a>) -> List<a> {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nPush an element in front of a list.",
          "parameters": [
            {
              "name": "elem",
              "type": "a",
              "optional": false
            },
            {
              "name": "list",
              "type": "List<a>",
              "optional": false
            }
          ],
          "returnType": "List<a>",
          "line": 420,
          "raw": "pub fn cons_list(elem: a, list: List<a>) -> List<a> {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn cons_list(elem: a, list: List<a>) -> List<a> {\n  fail\n}"
        },
        {
          "name": "head_list",
          "signature": "pub fn head_list(list: List<a>) -> a {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nThe head of a list. Fails if empty.",
          "parameters": [
            {
              "name": "list",
              "type": "List<a>",
              "optional": false
            }
          ],
          "returnType": "a",
          "line": 428,
          "raw": "pub fn head_list(list: List<a>) -> a {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn head_list(list: List<a>) -> a {\n  fail\n}"
        },
        {
          "name": "tail_list",
          "signature": "pub fn tail_list(list: List<a>) -> List<a> {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nThe tail of a list. Fails if empty.",
          "parameters": [
            {
              "name": "list",
              "type": "List<a>",
              "optional": false
            }
          ],
          "returnType": "List<a>",
          "line": 436,
          "raw": "pub fn tail_list(list: List<a>) -> List<a> {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn tail_list(list: List<a>) -> List<a> {\n  fail\n}"
        },
        {
          "name": "null_list",
          "signature": "pub fn null_list(list: List<a>) -> Bool {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nTrue when a list is empty.",
          "parameters": [
            {
              "name": "list",
              "type": "List<a>",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 444,
          "raw": "pub fn null_list(list: List<a>) -> Bool {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn null_list(list: List<a>) -> Bool {\n  fail\n}"
        },
        {
          "name": "choose_list",
          "signature": "pub fn choose_list(list: List<a>, when_empty: b, when_non_empty: b) -> b {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nSelect a branch to continue with depending on whether the list is empty or not.",
          "parameters": [
            {
              "name": "list",
              "type": "List<a>",
              "optional": false
            },
            {
              "name": "when_empty",
              "type": "b",
              "optional": false
            },
            {
              "name": "when_non_empty",
              "type": "b",
              "optional": false
            }
          ],
          "returnType": "b",
          "line": 452,
          "raw": "pub fn choose_list(list: List<a>, when_empty: b, when_non_empty: b) -> b {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn choose_list(list: List<a>, when_empty: b, when_non_empty: b) -> b {\n  fail\n}"
        },
        {
          "name": "constr_data",
          "signature": "pub fn constr_data(index: Int, fields: List<Data>) -> Data {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConstruct a `Data` from a constructor index and a list of fields.",
          "parameters": [
            {
              "name": "index",
              "type": "Int",
              "optional": false
            },
            {
              "name": "fields",
              "type": "List<Data>",
              "optional": false
            }
          ],
          "returnType": "Data",
          "line": 462,
          "raw": "pub fn constr_data(index: Int, fields: List<Data>) -> Data {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn constr_data(index: Int, fields: List<Data>) -> Data {\n  fail\n}"
        },
        {
          "name": "un_constr_data",
          "signature": "pub fn un_constr_data(data: Data) -> Pair<Int, List<Data>> {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInterpret a `Data` as a constructor. Fails if it's not a constructor.",
          "parameters": [
            {
              "name": "data",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "Pair<Int, List<Data>>",
          "line": 470,
          "raw": "pub fn un_constr_data(data: Data) -> Pair<Int, List<Data>> {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn un_constr_data(data: Data) -> Pair<Int, List<Data>> {\n  fail\n}"
        },
        {
          "name": "unconstr_fields",
          "signature": "pub fn unconstr_fields(data: Data) -> List<Data> {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInterpret a `Data` as a constructor and extract its fields. Slightly more efficient than using [`un_constr_data`](#un_constr_data).",
          "parameters": [
            {
              "name": "data",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "List<Data>",
          "line": 478,
          "raw": "pub fn unconstr_fields(data: Data) -> List<Data> {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn unconstr_fields(data: Data) -> List<Data> {\n  fail\n}"
        },
        {
          "name": "unconstr_index",
          "signature": "pub fn unconstr_index(data: Data) -> Int {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInterpret a `Data` as a constructor and extract its index. Slightly more efficient than using [`un_constr_data`](#un_constr_data).",
          "parameters": [
            {
              "name": "data",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 486,
          "raw": "pub fn unconstr_index(data: Data) -> Int {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn unconstr_index(data: Data) -> Int {\n  fail\n}"
        },
        {
          "name": "map_data",
          "signature": "pub fn map_data(items: List<Pair<Data, Data>>) -> Data {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConstruct a `Data` from a list of pairs.",
          "parameters": [
            {
              "name": "items",
              "type": "List<Pair<Data, Data>>",
              "optional": false
            }
          ],
          "returnType": "Data",
          "line": 494,
          "raw": "pub fn map_data(items: List<Pair<Data, Data>>) -> Data {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn map_data(items: List<Pair<Data, Data>>) -> Data {\n  fail\n}"
        },
        {
          "name": "un_map_data",
          "signature": "pub fn un_map_data(data: Data) -> List<Pair<Data, Data>> {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInterpret a `Data` as a map. Fails if it's not a map.",
          "parameters": [
            {
              "name": "data",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "List<Pair<Data, Data>>",
          "line": 502,
          "raw": "pub fn un_map_data(data: Data) -> List<Pair<Data, Data>> {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn un_map_data(data: Data) -> List<Pair<Data, Data>> {\n  fail\n}"
        },
        {
          "name": "list_data",
          "signature": "pub fn list_data(items: List<Data>) -> Data {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConstruct a `Data` from a list of elements.",
          "parameters": [
            {
              "name": "items",
              "type": "List<Data>",
              "optional": false
            }
          ],
          "returnType": "Data",
          "line": 510,
          "raw": "pub fn list_data(items: List<Data>) -> Data {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn list_data(items: List<Data>) -> Data {\n  fail\n}"
        },
        {
          "name": "un_list_data",
          "signature": "pub fn un_list_data(data: Data) -> List<Data> {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInterpret a `Data` as a list. Fails if it's not a list.",
          "parameters": [
            {
              "name": "data",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "List<Data>",
          "line": 518,
          "raw": "pub fn un_list_data(data: Data) -> List<Data> {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn un_list_data(data: Data) -> List<Data> {\n  fail\n}"
        },
        {
          "name": "i_data",
          "signature": "pub fn i_data(i: Int) -> Data {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConstruct a `Data` from an integer.",
          "parameters": [
            {
              "name": "i",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Data",
          "line": 526,
          "raw": "pub fn i_data(i: Int) -> Data {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn i_data(i: Int) -> Data {\n  fail\n}"
        },
        {
          "name": "un_i_data",
          "signature": "pub fn un_i_data(data: Data) -> Int {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInterpret a `Data` as a integer. Fails if it's not an integer.",
          "parameters": [
            {
              "name": "data",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 534,
          "raw": "pub fn un_i_data(data: Data) -> Int {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn un_i_data(data: Data) -> Int {\n  fail\n}"
        },
        {
          "name": "b_data",
          "signature": "pub fn b_data(bytes: ByteArray) -> Data {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConstruct a `Data` from a ByteArray",
          "parameters": [
            {
              "name": "bytes",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Data",
          "line": 542,
          "raw": "pub fn b_data(bytes: ByteArray) -> Data {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn b_data(bytes: ByteArray) -> Data {\n  fail\n}"
        },
        {
          "name": "un_b_data",
          "signature": "pub fn un_b_data(data: Data) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInterpret a `Data` as a bytearray. Fails if it's not a bytearray.",
          "parameters": [
            {
              "name": "data",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 550,
          "raw": "pub fn un_b_data(data: Data) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn un_b_data(data: Data) -> ByteArray {\n  fail\n}"
        },
        {
          "name": "equals_data",
          "signature": "pub fn equals_data(left: Data, right: Data) -> Bool {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nEquality on Data.",
          "parameters": [
            {
              "name": "left",
              "type": "Data",
              "optional": false
            },
            {
              "name": "right",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 558,
          "raw": "pub fn equals_data(left: Data, right: Data) -> Bool {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn equals_data(left: Data, right: Data) -> Bool {\n  fail\n}"
        },
        {
          "name": "serialise_data",
          "signature": "pub fn serialise_data(data: Data) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>2</small>\n---                                   | ---\n\nSerialise a Data to bytes, using CBOR.",
          "parameters": [
            {
              "name": "data",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 566,
          "raw": "pub fn serialise_data(data: Data) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn serialise_data(data: Data) -> ByteArray {\n  fail\n}"
        },
        {
          "name": "choose_data",
          "signature": "pub fn choose_data(pub fn choose_data(data: Data, when_constr: a, when_map: a, when_list: a, when_int: a, when_bytearray: a, ) -> a {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nSelect a branch to continue with based on what the Data actually is.",
          "parameters": [],
          "returnType": "a",
          "line": 574,
          "raw": "pub fn choose_data(pub fn choose_data(data: Data, when_constr: a, when_map: a, when_list: a, when_int: a, when_bytearray: a, ) -> a {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn choose_data(\n  data: Data,\n  when_constr: a,\n  when_map: a,\n  when_list: a,\n  when_int: a,\n  when_bytearray: a,\n) -> a {\n  fail\n}"
        },
        {
          "name": "new_pair",
          "signature": "pub fn new_pair(left: Data, right: Data) -> Pair<Data, Data> {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConstruct a Data from a pair of elements.",
          "parameters": [
            {
              "name": "left",
              "type": "Data",
              "optional": false
            },
            {
              "name": "right",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "Pair<Data, Data>",
          "line": 591,
          "raw": "pub fn new_pair(left: Data, right: Data) -> Pair<Data, Data> {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn new_pair(left: Data, right: Data) -> Pair<Data, Data> {\n  fail\n}"
        },
        {
          "name": "new_pairs",
          "signature": "pub fn new_pairs() -> Pairs<Data, Data> {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConstruct an empty list of pairs of data.",
          "parameters": [],
          "returnType": "Pairs<Data, Data>",
          "line": 599,
          "raw": "pub fn new_pairs() -> Pairs<Data, Data> {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn new_pairs() -> Pairs<Data, Data> {\n  fail\n}"
        },
        {
          "name": "fst_pair",
          "signature": "pub fn fst_pair(pair: Pair<a, b>) -> a {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nGet the first element of a pair.",
          "parameters": [
            {
              "name": "pair",
              "type": "Pair<a, b>",
              "optional": false
            }
          ],
          "returnType": "a",
          "line": 607,
          "raw": "pub fn fst_pair(pair: Pair<a, b>) -> a {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn fst_pair(pair: Pair<a, b>) -> a {\n  fail\n}"
        },
        {
          "name": "snd_pair",
          "signature": "pub fn snd_pair(pair: Pair<a, b>) -> b {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nGet the second element of a pair.",
          "parameters": [
            {
              "name": "pair",
              "type": "Pair<a, b>",
              "optional": false
            }
          ],
          "returnType": "b",
          "line": 615,
          "raw": "pub fn snd_pair(pair: Pair<a, b>) -> b {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn snd_pair(pair: Pair<a, b>) -> b {\n  fail\n}"
        },
        {
          "name": "blake2b_256",
          "signature": "pub fn blake2b_256(preimage: ByteArray) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nCalculate the blake2b-256 hash digest value of a given bytearray. Output is always 32-byte long.",
          "parameters": [
            {
              "name": "preimage",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 627,
          "raw": "pub fn blake2b_256(preimage: ByteArray) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn blake2b_256(preimage: ByteArray) -> ByteArray {\n  fail\n}"
        },
        {
          "name": "blake2b_224",
          "signature": "pub fn blake2b_224(preimage: ByteArray) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nCalculate the blake2b-224 hash digest value of a given bytearray. Output is always 28-byte long.",
          "parameters": [
            {
              "name": "preimage",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 635,
          "raw": "pub fn blake2b_224(preimage: ByteArray) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn blake2b_224(preimage: ByteArray) -> ByteArray {\n  fail\n}"
        },
        {
          "name": "keccak_256",
          "signature": "pub fn keccak_256(preimage: ByteArray) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nCalculate the keccak-256 hash digest value of a given bytearray. Output is always 32-byte long.",
          "parameters": [
            {
              "name": "preimage",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 643,
          "raw": "pub fn keccak_256(preimage: ByteArray) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn keccak_256(preimage: ByteArray) -> ByteArray {\n  fail\n}"
        },
        {
          "name": "ripemd_160",
          "signature": "pub fn ripemd_160(preimage: ByteArray) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nCalculate the ripemd-160 hash digest value of a given bytearray. Output is always 20-byte long.",
          "parameters": [
            {
              "name": "preimage",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 651,
          "raw": "pub fn ripemd_160(preimage: ByteArray) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn ripemd_160(preimage: ByteArray) -> ByteArray {\n  fail\n}"
        },
        {
          "name": "sha2_256",
          "signature": "pub fn sha2_256(preimage: ByteArray) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nCalculate the SHA2-256 hash digest value of a given bytearray. Output is always 32-byte long.",
          "parameters": [
            {
              "name": "preimage",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 659,
          "raw": "pub fn sha2_256(preimage: ByteArray) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn sha2_256(preimage: ByteArray) -> ByteArray {\n  fail\n}"
        },
        {
          "name": "sha3_256",
          "signature": "pub fn sha3_256(preimage: ByteArray) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nCalculate the SHA3-256 hash digest value of a given bytearray. Output is always 32-byte long.",
          "parameters": [
            {
              "name": "preimage",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 667,
          "raw": "pub fn sha3_256(preimage: ByteArray) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn sha3_256(preimage: ByteArray) -> ByteArray {\n  fail\n}"
        },
        {
          "name": "verify_ed25519_signature",
          "signature": "pub fn verify_ed25519_signature(pub fn verify_ed25519_signature(verification_key: ByteArray, message: ByteArray, signature: ByteArray, ) -> Bool {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nVerify an Ed25519 signature from a associated verification key.",
          "parameters": [],
          "returnType": "Bool",
          "line": 677,
          "raw": "pub fn verify_ed25519_signature(pub fn verify_ed25519_signature(verification_key: ByteArray, message: ByteArray, signature: ByteArray, ) -> Bool {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn verify_ed25519_signature(\n  verification_key: ByteArray,\n  message: ByteArray,\n  signature: ByteArray,\n) -> Bool {\n  fail\n}"
        },
        {
          "name": "verify_ecdsa_secp256k1_signature",
          "signature": "pub fn verify_ecdsa_secp256k1_signature(pub fn verify_ecdsa_secp256k1_signature(verification_key: ByteArray, message: ByteArray, signature: ByteArray, ) -> Bool {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>2</small>\n---                                   | ---\n\nVerify an ECDSA-SECP256k1 signature from a associated verification key.",
          "parameters": [],
          "returnType": "Bool",
          "line": 689,
          "raw": "pub fn verify_ecdsa_secp256k1_signature(pub fn verify_ecdsa_secp256k1_signature(verification_key: ByteArray, message: ByteArray, signature: ByteArray, ) -> Bool {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn verify_ecdsa_secp256k1_signature(\n  verification_key: ByteArray,\n  message: ByteArray,\n  signature: ByteArray,\n) -> Bool {\n  fail\n}"
        },
        {
          "name": "verify_schnorr_secp256k1_signature",
          "signature": "pub fn verify_schnorr_secp256k1_signature(pub fn verify_schnorr_secp256k1_signature(verification_key: ByteArray, message: ByteArray, signature: ByteArray, ) -> Bool {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>2</small>\n---                                   | ---\n\nVerify a SCHNORR-SECP256k1 signature from a associated verification key.",
          "parameters": [],
          "returnType": "Bool",
          "line": 701,
          "raw": "pub fn verify_schnorr_secp256k1_signature(pub fn verify_schnorr_secp256k1_signature(verification_key: ByteArray, message: ByteArray, signature: ByteArray, ) -> Bool {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn verify_schnorr_secp256k1_signature(\n  verification_key: ByteArray,\n  message: ByteArray,\n  signature: ByteArray,\n) -> Bool {\n  fail\n}"
        },
        {
          "name": "bls12_381_g1_add",
          "signature": "pub fn bls12_381_g1_add(a: G1Element, b: G1Element) -> G1Element {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
          "parameters": [
            {
              "name": "a",
              "type": "G1Element",
              "optional": false
            },
            {
              "name": "b",
              "type": "G1Element",
              "optional": false
            }
          ],
          "returnType": "G1Element",
          "line": 713,
          "raw": "pub fn bls12_381_g1_add(a: G1Element, b: G1Element) -> G1Element {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn bls12_381_g1_add(a: G1Element, b: G1Element) -> G1Element {\n  fail\n}"
        },
        {
          "name": "bls12_381_g1_neg",
          "signature": "pub fn bls12_381_g1_neg(self: G1Element) -> G1Element {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
          "parameters": [
            {
              "name": "self",
              "type": "G1Element",
              "optional": false
            }
          ],
          "returnType": "G1Element",
          "line": 719,
          "raw": "pub fn bls12_381_g1_neg(self: G1Element) -> G1Element {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn bls12_381_g1_neg(self: G1Element) -> G1Element {\n  fail\n}"
        },
        {
          "name": "bls12_381_g1_scalar_mul",
          "signature": "pub fn bls12_381_g1_scalar_mul(scalar: Int, self: G1Element) -> G1Element {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
          "parameters": [
            {
              "name": "scalar",
              "type": "Int",
              "optional": false
            },
            {
              "name": "self",
              "type": "G1Element",
              "optional": false
            }
          ],
          "returnType": "G1Element",
          "line": 725,
          "raw": "pub fn bls12_381_g1_scalar_mul(scalar: Int, self: G1Element) -> G1Element {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn bls12_381_g1_scalar_mul(scalar: Int, self: G1Element) -> G1Element {\n  fail\n}"
        },
        {
          "name": "bls12_381_g1_equal",
          "signature": "pub fn bls12_381_g1_equal(self: G1Element, other: G1Element) -> Bool {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
          "parameters": [
            {
              "name": "self",
              "type": "G1Element",
              "optional": false
            },
            {
              "name": "other",
              "type": "G1Element",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 731,
          "raw": "pub fn bls12_381_g1_equal(self: G1Element, other: G1Element) -> Bool {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn bls12_381_g1_equal(self: G1Element, other: G1Element) -> Bool {\n  fail\n}"
        },
        {
          "name": "bls12_381_g1_compress",
          "signature": "pub fn bls12_381_g1_compress(self: G1Element) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
          "parameters": [
            {
              "name": "self",
              "type": "G1Element",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 737,
          "raw": "pub fn bls12_381_g1_compress(self: G1Element) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn bls12_381_g1_compress(self: G1Element) -> ByteArray {\n  fail\n}"
        },
        {
          "name": "bls12_381_g1_uncompress",
          "signature": "pub fn bls12_381_g1_uncompress(self: ByteArray) -> G1Element {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "G1Element",
          "line": 743,
          "raw": "pub fn bls12_381_g1_uncompress(self: ByteArray) -> G1Element {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn bls12_381_g1_uncompress(self: ByteArray) -> G1Element {\n  fail\n}"
        },
        {
          "name": "bls12_381_g1_hash_to_group",
          "signature": "pub fn bls12_381_g1_hash_to_group(pub fn bls12_381_g1_hash_to_group(group: ByteArray, domain_separation_tag: ByteArray, ) -> G1Element {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
          "parameters": [],
          "returnType": "G1Element",
          "line": 749,
          "raw": "pub fn bls12_381_g1_hash_to_group(pub fn bls12_381_g1_hash_to_group(group: ByteArray, domain_separation_tag: ByteArray, ) -> G1Element {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn bls12_381_g1_hash_to_group(\n  group: ByteArray,\n  domain_separation_tag: ByteArray,\n) -> G1Element {\n  fail\n}"
        },
        {
          "name": "bls12_381_g2_add",
          "signature": "pub fn bls12_381_g2_add(a: G2Element, b: G2Element) -> G2Element {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
          "parameters": [
            {
              "name": "a",
              "type": "G2Element",
              "optional": false
            },
            {
              "name": "b",
              "type": "G2Element",
              "optional": false
            }
          ],
          "returnType": "G2Element",
          "line": 758,
          "raw": "pub fn bls12_381_g2_add(a: G2Element, b: G2Element) -> G2Element {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn bls12_381_g2_add(a: G2Element, b: G2Element) -> G2Element {\n  fail\n}"
        },
        {
          "name": "bls12_381_g2_neg",
          "signature": "pub fn bls12_381_g2_neg(self: G2Element) -> G2Element {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
          "parameters": [
            {
              "name": "self",
              "type": "G2Element",
              "optional": false
            }
          ],
          "returnType": "G2Element",
          "line": 764,
          "raw": "pub fn bls12_381_g2_neg(self: G2Element) -> G2Element {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn bls12_381_g2_neg(self: G2Element) -> G2Element {\n  fail\n}"
        },
        {
          "name": "bls12_381_g2_scalar_mul",
          "signature": "pub fn bls12_381_g2_scalar_mul(scalar: Int, self: G2Element) -> G2Element {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
          "parameters": [
            {
              "name": "scalar",
              "type": "Int",
              "optional": false
            },
            {
              "name": "self",
              "type": "G2Element",
              "optional": false
            }
          ],
          "returnType": "G2Element",
          "line": 770,
          "raw": "pub fn bls12_381_g2_scalar_mul(scalar: Int, self: G2Element) -> G2Element {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn bls12_381_g2_scalar_mul(scalar: Int, self: G2Element) -> G2Element {\n  fail\n}"
        },
        {
          "name": "bls12_381_g2_equal",
          "signature": "pub fn bls12_381_g2_equal(self: G2Element, other: G2Element) -> Bool {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
          "parameters": [
            {
              "name": "self",
              "type": "G2Element",
              "optional": false
            },
            {
              "name": "other",
              "type": "G2Element",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 776,
          "raw": "pub fn bls12_381_g2_equal(self: G2Element, other: G2Element) -> Bool {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn bls12_381_g2_equal(self: G2Element, other: G2Element) -> Bool {\n  fail\n}"
        },
        {
          "name": "bls12_381_g2_compress",
          "signature": "pub fn bls12_381_g2_compress(self: G2Element) -> ByteArray {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
          "parameters": [
            {
              "name": "self",
              "type": "G2Element",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 782,
          "raw": "pub fn bls12_381_g2_compress(self: G2Element) -> ByteArray {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn bls12_381_g2_compress(self: G2Element) -> ByteArray {\n  fail\n}"
        },
        {
          "name": "bls12_381_g2_uncompress",
          "signature": "pub fn bls12_381_g2_uncompress(self: ByteArray) -> G2Element {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
          "parameters": [
            {
              "name": "self",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "G2Element",
          "line": 788,
          "raw": "pub fn bls12_381_g2_uncompress(self: ByteArray) -> G2Element {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn bls12_381_g2_uncompress(self: ByteArray) -> G2Element {\n  fail\n}"
        },
        {
          "name": "bls12_381_g2_hash_to_group",
          "signature": "pub fn bls12_381_g2_hash_to_group(pub fn bls12_381_g2_hash_to_group(group: ByteArray, domain_separation_tag: ByteArray, ) -> G2Element {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
          "parameters": [],
          "returnType": "G2Element",
          "line": 794,
          "raw": "pub fn bls12_381_g2_hash_to_group(pub fn bls12_381_g2_hash_to_group(group: ByteArray, domain_separation_tag: ByteArray, ) -> G2Element {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn bls12_381_g2_hash_to_group(\n  group: ByteArray,\n  domain_separation_tag: ByteArray,\n) -> G2Element {\n  fail\n}"
        },
        {
          "name": "bls12_381_miller_loop",
          "signature": "pub fn bls12_381_miller_loop(g1: G1Element, g2: G2Element) -> MillerLoopResult {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
          "parameters": [
            {
              "name": "g1",
              "type": "G1Element",
              "optional": false
            },
            {
              "name": "g2",
              "type": "G2Element",
              "optional": false
            }
          ],
          "returnType": "MillerLoopResult",
          "line": 803,
          "raw": "pub fn bls12_381_miller_loop(g1: G1Element, g2: G2Element) -> MillerLoopResult {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn bls12_381_miller_loop(g1: G1Element, g2: G2Element) -> MillerLoopResult {\n  fail\n}"
        },
        {
          "name": "bls12_381_mul_miller_loop_result",
          "signature": "pub fn bls12_381_mul_miller_loop_result(pub fn bls12_381_mul_miller_loop_result(a: MillerLoopResult, b: MillerLoopResult, ) -> MillerLoopResult {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
          "parameters": [],
          "returnType": "MillerLoopResult",
          "line": 809,
          "raw": "pub fn bls12_381_mul_miller_loop_result(pub fn bls12_381_mul_miller_loop_result(a: MillerLoopResult, b: MillerLoopResult, ) -> MillerLoopResult {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn bls12_381_mul_miller_loop_result(\n  a: MillerLoopResult,\n  b: MillerLoopResult,\n) -> MillerLoopResult {\n  fail\n}"
        },
        {
          "name": "bls12_381_final_verify",
          "signature": "pub fn bls12_381_final_verify(a: MillerLoopResult, b: MillerLoopResult) -> Bool {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
          "parameters": [
            {
              "name": "a",
              "type": "MillerLoopResult",
              "optional": false
            },
            {
              "name": "b",
              "type": "MillerLoopResult",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 818,
          "raw": "pub fn bls12_381_final_verify(a: MillerLoopResult, b: MillerLoopResult) -> Bool {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn bls12_381_final_verify(a: MillerLoopResult, b: MillerLoopResult) -> Bool {\n  fail\n}"
        },
        {
          "name": "choose_void",
          "signature": "pub fn choose_void(void: Void, when_void: a) -> a {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nContinue with the continuation when the given term is Void.",
          "parameters": [
            {
              "name": "void",
              "type": "Void",
              "optional": false
            },
            {
              "name": "when_void",
              "type": "a",
              "optional": false
            }
          ],
          "returnType": "a",
          "line": 828,
          "raw": "pub fn choose_void(void: Void, when_void: a) -> a {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn choose_void(void: Void, when_void: a) -> a {\n  fail\n}"
        },
        {
          "name": "debug",
          "signature": "pub fn debug(message: String, continuation: a) -> a {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nTrace the provided message, and continue with the continuation.",
          "parameters": [
            {
              "name": "message",
              "type": "String",
              "optional": false
            },
            {
              "name": "continuation",
              "type": "a",
              "optional": false
            }
          ],
          "returnType": "a",
          "line": 836,
          "raw": "pub fn debug(message: String, continuation: a) -> a {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn debug(message: String, continuation: a) -> a {\n  fail\n}"
        },
        {
          "name": "if_then_else",
          "signature": "pub fn if_then_else(condition: Bool, when_true: a, when_false: a) -> a {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nReturn first computation when the condition is true, and the second otherwise.",
          "parameters": [
            {
              "name": "condition",
              "type": "Bool",
              "optional": false
            },
            {
              "name": "when_true",
              "type": "a",
              "optional": false
            },
            {
              "name": "when_false",
              "type": "a",
              "optional": false
            }
          ],
          "returnType": "a",
          "line": 844,
          "raw": "pub fn if_then_else(condition: Bool, when_true: a, when_false: a) -> a {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn if_then_else(condition: Bool, when_true: a, when_false: a) -> a {\n  fail\n}"
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "//// This modules contains all the Plutus builtins recognized by Aiken.\n////\n//// It's important to note that many of those functions are partial and will halt the execution\n//// of the Plutus virtual machine on failure. They also all rely on call-by-value, which means\n//// that function arguments are eagerly evaluated.\n\n// ## Integer\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Adds two integers (+).\npub fn add_integer(left: Int, right: Int) -> Int {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Subtract two integers (-).\npub fn subtract_integer(left: Int, right: Int) -> Int {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Multiple two integers (*).\npub fn multiply_integer(left: Int, right: Int) -> Int {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Integer division truncated towards negative infinity (/).\npub fn divide_integer(numerator: Int, denominator: Int) -> Int {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Integer division truncated towards zero.\npub fn quotient_integer(numerator: Int, denominator: Int) -> Int {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Integer remainder, satisfying\n///\n/// ```aiken\n/// quotient_integer(x, y) * y + remainder_integer(x, y) == x\n/// ```\npub fn remainder_integer(numerator: Int, denominator: Int) -> Int {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Integer modulus (%), satisfying\n///\n/// ```aiken\n/// divide_integer(x, y) * y + mod_integer(x, y) == x\n/// ```\npub fn mod_integer(numerator: Int, denominator: Int) -> Int {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Integer equality.\npub fn equals_integer(left: Int, right: Int) -> Bool {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Integer strict inequality.\npub fn less_than_integer(left: Int, right: Int) -> Bool {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Integer inequality.\npub fn less_than_equals_integer(left: Int, right: Int) -> Bool {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\n///\n/// Convert an integer value into a [ByteArray](../aiken.html#ByteArray).\n///\n/// - The first arguments / specifies the endianness:\n///\n///   boolean value | endianness\n///   ----          | ----\n///   True          | Big endian\n///   False         | Little endian\n///\n/// - The second argument indicates the target `size` (in bytes) of the final [ByteArray](../aiken.html#ByteArray). This allows to allocate a specific number of bytes in advance. The function fails if the given value cannot fit in the requested size or if the `value` is negative. However, a size of 0 will yield a [ByteArray](../aiken.html#ByteArray) that is precisely as large as necessary to fit the `value`.\npub fn integer_to_bytearray(\n  endianness: Bool,\n  size: Int,\n  value: Int,\n) -> ByteArray {\n  fail\n}\n\n// ## Bytearray\n\n// ### Constructing\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Concatenate two bytearrays together.\npub fn append_bytearray(left: ByteArray, right: ByteArray) -> ByteArray {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Push a byte in front of a bytearray.\npub fn cons_bytearray(byte: Int, bytes: ByteArray) -> ByteArray {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\n///\n/// Construct a `ByteArray` from the repetition of the same byte a specific number of times. Fails if the byte is out-of-bound or if the length is negative.\npub fn replicate_byte(length: Int, byte: Int) -> ByteArray {\n  todo\n}\n\n// ### Inspecting\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\n///\n/// Count the number of bits set in the given `ByteArray`.\npub fn count_set_bits(self: ByteArray) -> Int {\n  todo\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\n///\n/// Find the index of the first bit set. Note that bits are indexed _from the end_ (see also [`read_bit`](#read_bit) for more details).\npub fn find_first_set_bit(self: ByteArray) -> Int {\n  todo\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Access the byte at the given index in the bytearray.\npub fn index_bytearray(bytes: ByteArray, index: Int) -> Int {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Number of bytes in a bytearray.\npub fn length_of_bytearray(bytes: ByteArray) -> Int {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\n///\n/// Read a particular bit (`True` if set) at the given index. Fails if the\n/// index is out-of-bounds. Note that the index reads _from the end_. For\n/// example, consider the byte `0xF4` and an index `i`:\n///\n/// i=7 | i=6 | i=5 | i=4 | i=3 | i=2 | i=1 | i=0\n/// --- | --- | --- | --- | --- | --- | --- | ---\n///  1  |  1  |  1  |  1  |  0  |  1  |  0  |  0\n///\n/// So, we have:\n///\n/// ```aiken\n/// read_bit(#[0xF4], 0) == False\n/// read_bit(#[0xF4], 1) == False\n/// read_bit(#[0xF4], 2) == True\n/// read_bit(#[0xF4], 3) == False\n/// read_bit(#[0xF4], 4) == True\n/// read_bit(#[0xF4], 5) == True\n/// read_bit(#[0xF4], 6) == True\n/// read_bit(#[0xF4], 7) == True\n/// read_bit(#[0xF4, 0xF4], 8) == False\n/// ```\npub fn read_bit(self: ByteArray, index: Int) -> Bool {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Extract a sub-array from a bytearray given starting and length of the sub-array.\npub fn slice_bytearray(start: Int, len: Int, bytes: ByteArray) -> ByteArray {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\n///\n/// Write a bit each index in the list of indices. Writes 1 if value is True and 0 if value is False.\n/// Fails if the index is out-of-bounds. Note that the index reads _from the end_.\n/// For example, consider the byte `0xF4` and an index `i`:\n///\n/// i=7 | i=6 | i=5 | i=4 | i=3 | i=2 | i=1 | i=0\n/// --- | --- | --- | --- | --- | --- | --- | ---\n///  1  |  1  |  1  |  1  |  0  |  1  |  0  |  0\n///\n/// So, we have:\n///\n/// ```aiken\n/// write_bits(#[0xF4], [0, 1], True) == #[0xF7]\n/// ```\npub fn write_bits(self: ByteArray, indices: List<Int>, value: Bool) -> ByteArray {\n  fail\n}\n\n// ### Comparing\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Bytearray equality.\npub fn equals_bytearray(left: ByteArray, right: ByteArray) -> Bool {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Bytearray strict inequality.\npub fn less_than_bytearray(left: ByteArray, right: ByteArray) -> Bool {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Bytearray inequality.\npub fn less_than_equals_bytearray(left: ByteArray, right: ByteArray) -> Bool {\n  fail\n}\n\n// ### Bitwise\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\n///\n/// Logical AND applied to two bytearrays. The first argument indicates whether padding semantics should be used. If this argument is `False`, truncation semantics are used instead.\n/// \n/// > [!NOTE]\n/// > All bitwise operations are processed in little-endian bit order. For\n/// > example, ANDing `#\"F0\"` with `#\"0FFF\"` will yield a `#\"00\"` (or `#\"00FF\"`\n/// > if `padding` is `True`).\npub fn and_bytearray(\n  padding: Bool,\n  left: ByteArray,\n  right: ByteArray,\n) -> ByteArray {\n  todo\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\n///\n/// Logical OR applied to two bytearrays. The first argument indicates whether padding semantics should be used. If this argument is `False`, truncation semantics are used instead.\n/// \n/// > [!NOTE]\n/// > All bitwise operations are processed in little-endian bit order. For\n/// > example, ORing `#\"FF\"` with `#\"00FF\"` will yield a `#\"FF\"` (or `#\"FFFF\"`\n/// > if `padding` is `True`).\npub fn or_bytearray(\n  padding: Bool,\n  left: ByteArray,\n  right: ByteArray,\n) -> ByteArray {\n  todo\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\n///\n/// Logical XOR applied to two bytearrays. The first argument indicates whether padding semantics should be used. If this argument is `False`, truncation semantics are used instead.\n/// \n/// > [!NOTE]\n/// > All bitwise operations are processed in little-endian bit order. For\n/// > example, XORing `#\"0F\"` with `#\"0000\"` will yield a `#\"0F\"` (or `#\"0F00\"`\n/// > if `padding` is `True`).\npub fn xor_bytearray(\n  padding: Bool,\n  left: ByteArray,\n  right: ByteArray,\n) -> ByteArray {\n  todo\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\n///\n/// Logical bitwise complement of the bytearray (set becomes unset, and unset becomes set).\npub fn complement_bytearray(self: ByteArray) -> ByteArray {\n  todo\n}\n\n// ### Shifting\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\n///\n/// Like [`shift_bytearray`](#shift_bytearray) but instead of introducing zeroes in holes, use the bits that are dropped from either ends.\n///\n/// ```aiken\n/// rotate_bytearray(#[0xEB, 0xFC], 5) == #[0x7F, 0x9D]\n/// rotate_bytearray(#[0xEB, 0xFC], -8) == #[0xFC, 0xEB]\n/// rotate_bytearray(#[0xEB, 0xFC], 8) == #[0xFC, 0xEB]\n/// ```\npub fn rotate_bytearray(self: ByteArray, offset: Int) -> ByteArray {\n  todo\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\n///\n/// Shift bits in a `ByteArray` by the given offset, replacing holes with zeroes. The offset can be positive (left-shift) or negative (right-shift).\n///\n/// ```aiken\n/// shift_bytearray(#[0xEB, 0xFC], 5) == #[0x7F, 0x80]\n/// shift_bytearray(#[0xEB, 0xFC], -8) == #[0x00, 0xEB]\n/// shift_bytearray(#[0xEB, 0xFC], 8) == #[0xFC, 0x00]\n/// ```\n/// > [!NOTE]\n/// > Size of the given `ByteArray` remains unchanged, e.g. performing a\n/// > left-shift of `1` on `#\"80\"` results in `#\"00\"`.\npub fn shift_bytearray(self: ByteArray, offset: Int) -> ByteArray {\n  todo\n}\n\n// ### Transforming\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\n///\n/// Convert a [ByteArray](../aiken.html#ByteArray) to an integer value. The first argument\n/// specifies the endianness:\n///\n/// boolean value | endianness\n/// ----          | ----\n/// True          | Big endian\n/// False         | Little endian\npub fn bytearray_to_integer(endianness: Bool, bytes: ByteArray) -> Int {\n  fail\n}\n\n// ## String\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Concatenate two strings.\npub fn append_string(left: String, right: String) -> String {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// String equality.\npub fn equals_string(left: String, right: String) -> Bool {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Convert a string into a UTF-8 encoded array of bytes.\npub fn encode_utf8(str: String) -> ByteArray {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Interpret a UTF-8 encoded array of bytes as a String. Fails if the bytes aren't UTF-8 encoded.\npub fn decode_utf8(bytes: ByteArray) -> String {\n  fail\n}\n\n// ## List\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Construct an empty list of Data.\npub fn new_list() -> List<Data> {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Push an element in front of a list.\npub fn cons_list(elem: a, list: List<a>) -> List<a> {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// The head of a list. Fails if empty.\npub fn head_list(list: List<a>) -> a {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// The tail of a list. Fails if empty.\npub fn tail_list(list: List<a>) -> List<a> {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// True when a list is empty.\npub fn null_list(list: List<a>) -> Bool {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Select a branch to continue with depending on whether the list is empty or not.\npub fn choose_list(list: List<a>, when_empty: b, when_non_empty: b) -> b {\n  fail\n}\n\n// ## Data\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Construct a `Data` from a constructor index and a list of fields.\npub fn constr_data(index: Int, fields: List<Data>) -> Data {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Interpret a `Data` as a constructor. Fails if it's not a constructor.\npub fn un_constr_data(data: Data) -> Pair<Int, List<Data>> {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Interpret a `Data` as a constructor and extract its fields. Slightly more efficient than using [`un_constr_data`](#un_constr_data).\npub fn unconstr_fields(data: Data) -> List<Data> {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Interpret a `Data` as a constructor and extract its index. Slightly more efficient than using [`un_constr_data`](#un_constr_data).\npub fn unconstr_index(data: Data) -> Int {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Construct a `Data` from a list of pairs.\npub fn map_data(items: List<Pair<Data, Data>>) -> Data {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Interpret a `Data` as a map. Fails if it's not a map.\npub fn un_map_data(data: Data) -> List<Pair<Data, Data>> {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Construct a `Data` from a list of elements.\npub fn list_data(items: List<Data>) -> Data {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Interpret a `Data` as a list. Fails if it's not a list.\npub fn un_list_data(data: Data) -> List<Data> {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Construct a `Data` from an integer.\npub fn i_data(i: Int) -> Data {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Interpret a `Data` as a integer. Fails if it's not an integer.\npub fn un_i_data(data: Data) -> Int {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Construct a `Data` from a ByteArray\npub fn b_data(bytes: ByteArray) -> Data {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Interpret a `Data` as a bytearray. Fails if it's not a bytearray.\npub fn un_b_data(data: Data) -> ByteArray {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Equality on Data.\npub fn equals_data(left: Data, right: Data) -> Bool {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>2</small>\n/// ---                                   | ---\n///\n/// Serialise a Data to bytes, using CBOR.\npub fn serialise_data(data: Data) -> ByteArray {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Select a branch to continue with based on what the Data actually is.\npub fn choose_data(\n  data: Data,\n  when_constr: a,\n  when_map: a,\n  when_list: a,\n  when_int: a,\n  when_bytearray: a,\n) -> a {\n  fail\n}\n\n// ## Pair\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Construct a Data from a pair of elements.\npub fn new_pair(left: Data, right: Data) -> Pair<Data, Data> {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Construct an empty list of pairs of data.\npub fn new_pairs() -> Pairs<Data, Data> {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Get the first element of a pair.\npub fn fst_pair(pair: Pair<a, b>) -> a {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Get the second element of a pair.\npub fn snd_pair(pair: Pair<a, b>) -> b {\n  fail\n}\n\n// ## Crypto\n\n// ### Hashing\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Calculate the blake2b-256 hash digest value of a given bytearray. Output is always 32-byte long.\npub fn blake2b_256(preimage: ByteArray) -> ByteArray {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\n///\n/// Calculate the blake2b-224 hash digest value of a given bytearray. Output is always 28-byte long.\npub fn blake2b_224(preimage: ByteArray) -> ByteArray {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\n///\n/// Calculate the keccak-256 hash digest value of a given bytearray. Output is always 32-byte long.\npub fn keccak_256(preimage: ByteArray) -> ByteArray {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\n///\n/// Calculate the ripemd-160 hash digest value of a given bytearray. Output is always 20-byte long.\npub fn ripemd_160(preimage: ByteArray) -> ByteArray {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Calculate the SHA2-256 hash digest value of a given bytearray. Output is always 32-byte long.\npub fn sha2_256(preimage: ByteArray) -> ByteArray {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Calculate the SHA3-256 hash digest value of a given bytearray. Output is always 32-byte long.\npub fn sha3_256(preimage: ByteArray) -> ByteArray {\n  fail\n}\n\n// ### ECDSA\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Verify an Ed25519 signature from a associated verification key.\npub fn verify_ed25519_signature(\n  verification_key: ByteArray,\n  message: ByteArray,\n  signature: ByteArray,\n) -> Bool {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>2</small>\n/// ---                                   | ---\n///\n/// Verify an ECDSA-SECP256k1 signature from a associated verification key.\npub fn verify_ecdsa_secp256k1_signature(\n  verification_key: ByteArray,\n  message: ByteArray,\n  signature: ByteArray,\n) -> Bool {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>2</small>\n/// ---                                   | ---\n///\n/// Verify a SCHNORR-SECP256k1 signature from a associated verification key.\npub fn verify_schnorr_secp256k1_signature(\n  verification_key: ByteArray,\n  message: ByteArray,\n  signature: ByteArray,\n) -> Bool {\n  fail\n}\n\n// ### Pairing\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\npub fn bls12_381_g1_add(a: G1Element, b: G1Element) -> G1Element {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\npub fn bls12_381_g1_neg(self: G1Element) -> G1Element {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\npub fn bls12_381_g1_scalar_mul(scalar: Int, self: G1Element) -> G1Element {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\npub fn bls12_381_g1_equal(self: G1Element, other: G1Element) -> Bool {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\npub fn bls12_381_g1_compress(self: G1Element) -> ByteArray {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\npub fn bls12_381_g1_uncompress(self: ByteArray) -> G1Element {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\npub fn bls12_381_g1_hash_to_group(\n  group: ByteArray,\n  domain_separation_tag: ByteArray,\n) -> G1Element {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\npub fn bls12_381_g2_add(a: G2Element, b: G2Element) -> G2Element {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\npub fn bls12_381_g2_neg(self: G2Element) -> G2Element {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\npub fn bls12_381_g2_scalar_mul(scalar: Int, self: G2Element) -> G2Element {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\npub fn bls12_381_g2_equal(self: G2Element, other: G2Element) -> Bool {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\npub fn bls12_381_g2_compress(self: G2Element) -> ByteArray {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\npub fn bls12_381_g2_uncompress(self: ByteArray) -> G2Element {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\npub fn bls12_381_g2_hash_to_group(\n  group: ByteArray,\n  domain_separation_tag: ByteArray,\n) -> G2Element {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\npub fn bls12_381_miller_loop(g1: G1Element, g2: G2Element) -> MillerLoopResult {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\npub fn bls12_381_mul_miller_loop_result(\n  a: MillerLoopResult,\n  b: MillerLoopResult,\n) -> MillerLoopResult {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\npub fn bls12_381_final_verify(a: MillerLoopResult, b: MillerLoopResult) -> Bool {\n  fail\n}\n\n// ## Miscellaneous\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Continue with the continuation when the given term is Void.\npub fn choose_void(void: Void, when_void: a) -> a {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Trace the provided message, and continue with the continuation.\npub fn debug(message: String, continuation: a) -> a {\n  fail\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Return first computation when the condition is true, and the second otherwise.\npub fn if_then_else(condition: Bool, when_true: a, when_false: a) -> a {\n  fail\n}\n",
      "dependencies": [],
      "source": "prelude",
      "isReExportFile": false
    },
    {
      "key": "prelude:aiken",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-prelude/lib/aiken.ak",
      "name": "aiken",
      "imports": [],
      "functions": [
        {
          "name": "not",
          "signature": "pub fn not(self: Bool) -> Bool {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nLike `!`, but as a function. Handy for chaining using the pipe operator `|>` or to pass as a function.",
          "parameters": [
            {
              "name": "self",
              "type": "Bool",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 173,
          "raw": "pub fn not(self: Bool) -> Bool {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn not(self: Bool) -> Bool {\n  when self is {\n    True -> False\n    False -> True\n  }\n}"
        },
        {
          "name": "always",
          "signature": "pub fn always(a: a, b _b: b) -> a {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nA function that always return its first argument. Handy in folds and maps.\n\n```aiken\nlet always_14 = always(14, _)\nalways_14(42) == 14\nalways_14(1337) == 14\nalways_14(0) == 14\n```",
          "parameters": [
            {
              "name": "a",
              "type": "a",
              "optional": false
            }
          ],
          "returnType": "a",
          "line": 191,
          "raw": "pub fn always(a: a, b _b: b) -> a {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn always(a: a, b _b: b) -> a {\n  a\n}"
        },
        {
          "name": "as_data",
          "signature": "pub fn as_data(data: Data) -> Data {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nAn identity function to upcast any serialisable type into `Data`, in places where the compiler cannot implicitly infer it.\n\n```aiken\nlet my_uniform_list: List<Data> = [as_data(Foo(14)), as_data(Bar(True))]\n```",
          "parameters": [
            {
              "name": "data",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "Data",
          "line": 203,
          "raw": "pub fn as_data(data: Data) -> Data {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn as_data(data: Data) -> Data {\n  data\n}"
        },
        {
          "name": "identity",
          "signature": "pub fn identity(a: a) -> a {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nA function that returns its argument. Handy as a default behavior sometimes.",
          "parameters": [
            {
              "name": "a",
              "type": "a",
              "optional": false
            }
          ],
          "returnType": "a",
          "line": 211,
          "raw": "pub fn identity(a: a) -> a {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn identity(a: a) -> a {\n  a\n}"
        },
        {
          "name": "flip",
          "signature": "pub fn flip(f: fn(a, b) -> c) -> fn(b, a) -> c {",
          "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nA function that flips the arguments of a function.\n\n```aiken\npub fn titleize(left: String, right: String) {}\n\ntitleize(\"Hello\", \"World\") // \"Hello, World!\"\n\nflip(titleize)(\"Hello\", \"World\") // \"World, Hello!\"\n```",
          "parameters": [
            {
              "name": "f",
              "type": "fn(a, b",
              "optional": false
            }
          ],
          "returnType": "c) -> fn(b, a) -> c",
          "line": 227,
          "raw": "pub fn flip(f: fn(a, b) -> c) -> fn(b, a) -> c {",
          "isPublic": true,
          "source": "prelude",
          "implementation": "pub fn flip(f: fn(a, b) -> c) -> fn(b, a) -> c {\n  fn(b, a) { f(a, b) }\n}"
        }
      ],
      "types": [
        {
          "name": "Bool",
          "definition": "{ False True }",
          "line": 5,
          "raw": "pub type Bool {",
          "isPublic": true,
          "source": "prelude"
        },
        {
          "name": "Ordering",
          "definition": "{ Less Equal Greater }",
          "line": 26,
          "raw": "pub type Ordering {",
          "isPublic": true,
          "source": "prelude"
        },
        {
          "name": "ByteArray",
          "definition": "opaque { ByteArray }",
          "line": 36,
          "raw": "pub opaque type ByteArray {",
          "isPublic": true,
          "source": "prelude"
        },
        {
          "name": "Data",
          "definition": "opaque { Data }",
          "line": 44,
          "raw": "pub opaque type Data {",
          "isPublic": true,
          "source": "prelude"
        },
        {
          "name": "Int",
          "definition": "opaque { Int }",
          "line": 54,
          "raw": "pub opaque type Int {",
          "isPublic": true,
          "source": "prelude"
        },
        {
          "name": "String",
          "definition": "opaque { String }",
          "line": 62,
          "raw": "pub opaque type String {",
          "isPublic": true,
          "source": "prelude"
        },
        {
          "name": "Void",
          "definition": "opaque { Void }",
          "line": 70,
          "raw": "pub opaque type Void {",
          "isPublic": true,
          "source": "prelude"
        },
        {
          "name": "List<a>",
          "definition": "opaque { List }",
          "line": 78,
          "raw": "pub opaque type List<a> {",
          "isPublic": true,
          "source": "prelude"
        },
        {
          "name": "Pair<k, v>",
          "definition": "opaque { Pair }",
          "line": 86,
          "raw": "pub opaque type Pair<k, v> {",
          "isPublic": true,
          "source": "prelude"
        },
        {
          "name": "Pairs<k, v>",
          "definition": "List<Pair<k, v>>",
          "line": 94,
          "raw": "pub type Pairs<k, v> =",
          "isPublic": true,
          "source": "prelude"
        },
        {
          "name": "G1Element",
          "definition": "opaque { G1Element }",
          "line": 101,
          "raw": "pub opaque type G1Element {",
          "isPublic": true,
          "source": "prelude"
        },
        {
          "name": "G2Element",
          "definition": "opaque { G2Element }",
          "line": 109,
          "raw": "pub opaque type G2Element {",
          "isPublic": true,
          "source": "prelude"
        },
        {
          "name": "MillerLoopResult",
          "definition": "opaque { MillerLoopResult }",
          "line": 117,
          "raw": "pub opaque type MillerLoopResult {",
          "isPublic": true,
          "source": "prelude"
        },
        {
          "name": "Option<a>",
          "definition": "{ Some(a) None }",
          "line": 125,
          "raw": "pub type Option<a> {",
          "isPublic": true,
          "source": "prelude"
        },
        {
          "name": "Never",
          "definition": "{ Never }",
          "line": 140,
          "raw": "pub type Never {",
          "isPublic": true,
          "source": "prelude"
        },
        {
          "name": "PRNG",
          "definition": "{ Seeded { seed: ByteArray, choices: ByteArray } Replayed { cursor: Int, choices: ByteArray } }",
          "line": 148,
          "raw": "pub type PRNG {",
          "isPublic": true,
          "source": "prelude"
        },
        {
          "name": "Fuzzer<a>",
          "definition": "fn(PRNG) -> Option<(PRNG, a)>",
          "line": 158,
          "raw": "pub type Fuzzer<a> =",
          "isPublic": true,
          "source": "prelude"
        },
        {
          "name": "Sampler<a>",
          "definition": "fn(Int) -> Fuzzer<a>",
          "line": 166,
          "raw": "pub type Sampler<a> =",
          "isPublic": true,
          "source": "prelude"
        }
      ],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// A type for booleans values. See [Primitive Types :: Bool](https://aiken-lang.org/language-tour/primitive-types#bool) for details.\npub type Bool {\n  False\n  True\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// A type to compare values.\n///\n/// ```aiken\n/// pub fn compare(left: Int, right: Int) -> Ordering {\n///   if left < right {\n///     Less\n///   } else if less > right {\n///     Greater\n///   } else {\n///     Equal\n///   }\n/// }\n/// ```\npub type Ordering {\n  Less\n  Equal\n  Greater\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// A type for representing bytes. See [Primitive Types :: ByteArray](https://aiken-lang.org/language-tour/primitive-types#bytearray) for details.\npub opaque type ByteArray {\n  ByteArray\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// A type for opaque Plutus data. See [Primitive Types :: Data](https://aiken-lang.org/language-tour/primitive-types#data) for details.\npub opaque type Data {\n  Data\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// A type for signed integers. See [Primitive Types :: Int](https://aiken-lang.org/language-tour/primitive-types#int) for details.\n///\n/// Note: there's no floating numbers in Aiken.\npub opaque type Int {\n  Int\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// A type for text strings. See [Primitive Types :: String](https://aiken-lang.org/language-tour/primitive-types#string) for details.\npub opaque type String {\n  String\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// A type for nullary constructors. See [Primitive Types :: Void](https://aiken-lang.org/language-tour/primitive-types#void) for details.\npub opaque type Void {\n  Void\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// A type for generic lists. See [Primitive Types :: List](https://aiken-lang.org/language-tour/primitive-types#list) for details.\npub opaque type List<a> {\n  List\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// An pair of 2 elements.\npub opaque type Pair<k, v> {\n  Pair\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// A associative list as a list of pairs of 2 elements.\npub type Pairs<k, v> =\n  List<Pair<k, v>>\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\n///\n/// A type for representing G1 element of BLS12_381 curves.\npub opaque type G1Element {\n  G1Element\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\n///\n/// A type for representing G2 element of BLS12_381 curves.\npub opaque type G2Element {\n  G2Element\n}\n\n/// <small>Minimum Plutus Version</small> | <small>3</small>\n/// ---                                   | ---\n///\n/// A type for representing Miller-loop results.\npub opaque type MillerLoopResult {\n  MillerLoopResult\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// A type for returning optional results. See also [stdlib/option](https://aiken-lang.github.io/stdlib/aiken/option.html).\npub type Option<a> {\n  Some(a)\n  None\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// A type that like [`Option`](#Option) but that is always `None`. Fundamentally, we have:\n///\n/// ```aiken\n/// let never: Data = Never\n/// let none: Data = None\n/// never == none\n/// ```\npub type Never {\n  Never\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// A type that represent Pseudo-random generated values.\npub type PRNG {\n  Seeded { seed: ByteArray, choices: ByteArray }\n  Replayed { cursor: Int, choices: ByteArray }\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// A type to capture random computation that may depend on one another. Useful\n/// for constructing (pseudo-)random values for property-based test.\npub type Fuzzer<a> =\n  fn(PRNG) -> Option<(PRNG, a)>\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// A type to capture scaled fuzzers. Useful for constructing (pseudo-)random\n/// for benchmarks from a controlled monotically increasing size.\npub type Sampler<a> =\n  fn(Int) -> Fuzzer<a>\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// Like `!`, but as a function. Handy for chaining using the pipe operator `|>` or to pass as a function.\npub fn not(self: Bool) -> Bool {\n  when self is {\n    True -> False\n    False -> True\n  }\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// A function that always return its first argument. Handy in folds and maps.\n///\n/// ```aiken\n/// let always_14 = always(14, _)\n/// always_14(42) == 14\n/// always_14(1337) == 14\n/// always_14(0) == 14\n/// ```\npub fn always(a: a, b _b: b) -> a {\n  a\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// An identity function to upcast any serialisable type into `Data`, in places where the compiler cannot implicitly infer it.\n///\n/// ```aiken\n/// let my_uniform_list: List<Data> = [as_data(Foo(14)), as_data(Bar(True))]\n/// ```\npub fn as_data(data: Data) -> Data {\n  data\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// A function that returns its argument. Handy as a default behavior sometimes.\npub fn identity(a: a) -> a {\n  a\n}\n\n/// <small>Minimum Plutus Version</small> | <small>1</small>\n/// ---                                   | ---\n///\n/// A function that flips the arguments of a function.\n///\n/// ```aiken\n/// pub fn titleize(left: String, right: String) {}\n///\n/// titleize(\"Hello\", \"World\") // \"Hello, World!\"\n///\n/// flip(titleize)(\"Hello\", \"World\") // \"World, Hello!\"\n/// ```\npub fn flip(f: fn(a, b) -> c) -> fn(b, a) -> c {\n  fn(b, a) { f(a, b) }\n}\n",
      "dependencies": [],
      "source": "prelude",
      "isReExportFile": false
    },
    {
      "key": "vodka:cip",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-vodka/lib/cip.ak",
      "name": "cip",
      "imports": [
        {
          "module": "aiken/primitive/bytearray",
          "items": ["concat"],
          "line": 13,
          "raw": "use aiken/primitive/bytearray.{concat}",
          "source": "vodka"
        },
        {
          "module": "cardano/assets",
          "items": ["AssetName"],
          "line": 14,
          "raw": "use cardano/assets.{AssetName}",
          "source": "vodka"
        }
      ],
      "functions": [
        {
          "name": "drop_cip68_prefix",
          "signature": "pub fn drop_cip68_prefix(cip_68_asset_name: AssetName) -> AssetName {",
          "parameters": [
            {
              "name": "cip_68_asset_name",
              "type": "AssetName",
              "optional": false
            }
          ],
          "returnType": "AssetName",
          "line": 28,
          "raw": "pub fn drop_cip68_prefix(cip_68_asset_name: AssetName) -> AssetName {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn drop_cip68_prefix(cip_68_asset_name: AssetName) -> AssetName {\n  cip_68_asset_name |> bytearray.drop(4)\n}",
          "tests": [
            "test test_drop_cip68_prefix() {\n  let cip68_100_asset_name = #\"000643b012345678\"\n  drop_cip68_prefix(cip68_100_asset_name) == #\"12345678\"\n}"
          ]
        },
        {
          "name": "cip68_100",
          "signature": "pub fn cip68_100(asset_name: AssetName) -> AssetName {",
          "documentation": "Obtain the asset name for CIP-68 asset - Reference Token\n```aiken\nlet cip68_100_asset_name = cip68_100(asset_name)\n```",
          "parameters": [
            {
              "name": "asset_name",
              "type": "AssetName",
              "optional": false
            }
          ],
          "returnType": "AssetName",
          "line": 41,
          "raw": "pub fn cip68_100(asset_name: AssetName) -> AssetName {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn cip68_100(asset_name: AssetName) -> AssetName {\n  concat(cip68_100_prefix, asset_name)\n}"
        },
        {
          "name": "cip68_222",
          "signature": "pub fn cip68_222(asset_name: AssetName) -> AssetName {",
          "documentation": "Obtain the asset name for CIP-68 asset - Non-Fungible Token\n```aiken\nlet cip68_222_asset_name = cip68_222(asset_name)\n```",
          "parameters": [
            {
              "name": "asset_name",
              "type": "AssetName",
              "optional": false
            }
          ],
          "returnType": "AssetName",
          "line": 49,
          "raw": "pub fn cip68_222(asset_name: AssetName) -> AssetName {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn cip68_222(asset_name: AssetName) -> AssetName {\n  concat(cip68_222_prefix, asset_name)\n}"
        },
        {
          "name": "cip68_333",
          "signature": "pub fn cip68_333(asset_name: AssetName) -> AssetName {",
          "documentation": "Obtain the asset name for CIP-68 asset - Fungible Token\n```aiken\nlet cip68_333_asset_name = cip68_333(asset_name)\n```",
          "parameters": [
            {
              "name": "asset_name",
              "type": "AssetName",
              "optional": false
            }
          ],
          "returnType": "AssetName",
          "line": 57,
          "raw": "pub fn cip68_333(asset_name: AssetName) -> AssetName {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn cip68_333(asset_name: AssetName) -> AssetName {\n  concat(cip68_333_prefix, asset_name)\n}"
        },
        {
          "name": "cip68_444",
          "signature": "pub fn cip68_444(asset_name: AssetName) -> AssetName {",
          "documentation": "Obtain the asset name for CIP-68 asset - Rich-Fungible Token\n```aiken\nlet cip68_444_asset_name = cip68_444(asset_name)\n```",
          "parameters": [
            {
              "name": "asset_name",
              "type": "AssetName",
              "optional": false
            }
          ],
          "returnType": "AssetName",
          "line": 65,
          "raw": "pub fn cip68_444(asset_name: AssetName) -> AssetName {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn cip68_444(asset_name: AssetName) -> AssetName {\n  concat(cip68_444_prefix, asset_name)\n}"
        }
      ],
      "types": [
        {
          "name": "CIP68Metadata",
          "definition": "{ metadata: Pairs<Data, Data>, version: Int, }",
          "line": 70,
          "raw": "pub type CIP68Metadata {",
          "isPublic": true,
          "source": "vodka"
        }
      ],
      "constants": [
        {
          "name": "cip68_100_prefix",
          "type": "ByteArray",
          "value": "#\"000643b0\"",
          "line": 17,
          "raw": "pub const cip68_100_prefix: ByteArray = #\"000643b0\"",
          "isPublic": true,
          "source": "vodka"
        },
        {
          "name": "cip68_222_prefix",
          "type": "ByteArray",
          "value": "#\"000de140\"",
          "line": 20,
          "raw": "pub const cip68_222_prefix: ByteArray = #\"000de140\"",
          "isPublic": true,
          "source": "vodka"
        },
        {
          "name": "cip68_333_prefix",
          "type": "ByteArray",
          "value": "#\"0014df10\"",
          "line": 23,
          "raw": "pub const cip68_333_prefix: ByteArray = #\"0014df10\"",
          "isPublic": true,
          "source": "vodka"
        },
        {
          "name": "cip68_444_prefix",
          "type": "ByteArray",
          "value": "#\"001bc280\"",
          "line": 26,
          "raw": "pub const cip68_444_prefix: ByteArray = #\"001bc280\"",
          "isPublic": true,
          "source": "vodka"
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "//// Vodka provides utility functions to build CIP onchain code\n//// \n//// ### Example usage\n//// ```aiken\n//// use cip\n//// use cardano/assets.{AssetName}\n////\n//// let cip68_100_asset_name = cip.cip68_100(asset_name)\n//// let cip68_222_asset_name = cip.cip68_222(asset_name)\n//// let cip68_333_asset_name = cip.cip68_333(asset_name)\n//// let cip68_444_asset_name = cip.cip68_444(asset_name)\n\nuse aiken/primitive/bytearray.{concat}\nuse cardano/assets.{AssetName}\n\n/// The byte prefix for CIP-68 asset - Reference Token\npub const cip68_100_prefix: ByteArray = #\"000643b0\"\n\n/// The byte prefix for CIP-68 asset - Non-Fungible Token\npub const cip68_222_prefix: ByteArray = #\"000de140\"\n\n/// The byte prefix for CIP-68 asset - Fungible Token\npub const cip68_333_prefix: ByteArray = #\"0014df10\"\n\n/// The byte prefix for CIP-68 asset - Rich-Fungible Token\npub const cip68_444_prefix: ByteArray = #\"001bc280\"\n\npub fn drop_cip68_prefix(cip_68_asset_name: AssetName) -> AssetName {\n  cip_68_asset_name |> bytearray.drop(4)\n}\n\ntest test_drop_cip68_prefix() {\n  let cip68_100_asset_name = #\"000643b012345678\"\n  drop_cip68_prefix(cip68_100_asset_name) == #\"12345678\"\n}\n\n/// Obtain the asset name for CIP-68 asset - Reference Token\n/// ```aiken\n/// let cip68_100_asset_name = cip68_100(asset_name)\n/// ```\npub fn cip68_100(asset_name: AssetName) -> AssetName {\n  concat(cip68_100_prefix, asset_name)\n}\n\n/// Obtain the asset name for CIP-68 asset - Non-Fungible Token\n/// ```aiken\n/// let cip68_222_asset_name = cip68_222(asset_name)\n/// ```\npub fn cip68_222(asset_name: AssetName) -> AssetName {\n  concat(cip68_222_prefix, asset_name)\n}\n\n/// Obtain the asset name for CIP-68 asset - Fungible Token\n/// ```aiken\n/// let cip68_333_asset_name = cip68_333(asset_name)\n/// ```\npub fn cip68_333(asset_name: AssetName) -> AssetName {\n  concat(cip68_333_prefix, asset_name)\n}\n\n/// Obtain the asset name for CIP-68 asset - Rich-Fungible Token\n/// ```aiken\n/// let cip68_444_asset_name = cip68_444(asset_name)\n/// ```\npub fn cip68_444(asset_name: AssetName) -> AssetName {\n  concat(cip68_444_prefix, asset_name)\n}\n\n/// The metadata attached with CIP-68 reference token (100)\npub type CIP68Metadata {\n  metadata: Pairs<Data, Data>,\n  version: Int,\n}\n",
      "dependencies": ["aiken/primitive/bytearray", "cardano/assets"],
      "source": "vodka",
      "isReExportFile": false
    },
    {
      "key": "vodka:cocktail.vodka_address",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-vodka/lib/cocktail/vodka_address.ak",
      "name": "cocktail.vodka_address",
      "imports": [
        {
          "module": "aiken/crypto",
          "items": ["Blake2b_224", "Hash", "ScriptHash", "VerificationKeyHash"],
          "line": 1,
          "raw": "use aiken/crypto.{Blake2b_224, Hash, ScriptHash, VerificationKeyHash}",
          "source": "vodka"
        },
        {
          "module": "aiken/primitive/bytearray",
          "items": [],
          "line": 2,
          "raw": "use aiken/primitive/bytearray",
          "source": "vodka"
        },
        {
          "module": "cardano/address",
          "items": ["Address", "Script", "VerificationKey"],
          "line": 3,
          "raw": "use cardano/address.{Address, Script, VerificationKey}",
          "source": "vodka"
        }
      ],
      "functions": [
        {
          "name": "compare_script_address",
          "signature": "pub fn compare_script_address(x: Address, y: Address) -> Ordering {",
          "documentation": "Compare two script addresses",
          "parameters": [
            {
              "name": "x",
              "type": "Address",
              "optional": false
            },
            {
              "name": "y",
              "type": "Address",
              "optional": false
            }
          ],
          "returnType": "Ordering",
          "line": 6,
          "raw": "pub fn compare_script_address(x: Address, y: Address) -> Ordering {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn compare_script_address(x: Address, y: Address) -> Ordering {\n  expect Script(x_hash) = x.payment_credential\n  expect Script(y_hash) = y.payment_credential\n  bytearray.compare(x_hash, y_hash)\n}",
          "reExportedAs": ["cocktail.compare_script_address"]
        },
        {
          "name": "compare_address",
          "signature": "pub fn compare_address(x: Address, y: Address) -> Ordering {",
          "documentation": "Compare two addresses",
          "parameters": [
            {
              "name": "x",
              "type": "Address",
              "optional": false
            },
            {
              "name": "y",
              "type": "Address",
              "optional": false
            }
          ],
          "returnType": "Ordering",
          "line": 13,
          "raw": "pub fn compare_address(x: Address, y: Address) -> Ordering {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn compare_address(x: Address, y: Address) -> Ordering {\n  let x_hash = x.payment_credential\n  let y_hash = y.payment_credential\n  when (x_hash, y_hash) is {\n    (Script(x_script_hash), Script(y_script_hash)) ->\n      bytearray.compare(x_script_hash, y_script_hash)\n    (VerificationKey(x_key_hash), VerificationKey(y_key_hash)) ->\n      bytearray.compare(x_key_hash, y_key_hash)\n    _ -> Equal\n  }\n}",
          "reExportedAs": ["cocktail.compare_address"]
        },
        {
          "name": "address_payment_key",
          "signature": "pub fn address_payment_key(address: Address) -> Hash<Blake2b_224, ByteArray> {",
          "documentation": "Obtain the payment key of an address, it can be either a script hash or a verification key\n```aiken\nlet payment_key_hash = address_payment_key(address)\n```",
          "parameters": [
            {
              "name": "address",
              "type": "Address",
              "optional": false
            }
          ],
          "returnType": "Hash<Blake2b_224, ByteArray>",
          "line": 29,
          "raw": "pub fn address_payment_key(address: Address) -> Hash<Blake2b_224, ByteArray> {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn address_payment_key(address: Address) -> Hash<Blake2b_224, ByteArray> {\n  when address.payment_credential is {\n    Script(hash) -> hash\n    VerificationKey(key_hash) -> key_hash\n  }\n}",
          "reExportedAs": ["cocktail.address_payment_key"]
        },
        {
          "name": "address_pub_key",
          "signature": "pub fn address_pub_key(address: Address) -> Option<VerificationKeyHash> {",
          "documentation": "Obtain the verification key of an address, None if it is a script address\n```aiken\nexpect Some(pub_key_hash) = address_pub_key(address)\n```",
          "parameters": [
            {
              "name": "address",
              "type": "Address",
              "optional": false
            }
          ],
          "returnType": "Option<VerificationKeyHash>",
          "line": 40,
          "raw": "pub fn address_pub_key(address: Address) -> Option<VerificationKeyHash> {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn address_pub_key(address: Address) -> Option<VerificationKeyHash> {\n  when address.payment_credential is {\n    VerificationKey(key_hash) -> Some(key_hash)\n    _ -> None\n  }\n}",
          "reExportedAs": ["cocktail.address_pub_key"]
        },
        {
          "name": "address_script_hash",
          "signature": "pub fn address_script_hash(address: Address) -> Option<ScriptHash> {",
          "documentation": "Obtain the script hash of an address, None if it is a verification key address\n```aiken\nexpect Some(script_hash) = address_pub_key(address)\n```",
          "parameters": [
            {
              "name": "address",
              "type": "Address",
              "optional": false
            }
          ],
          "returnType": "Option<ScriptHash>",
          "line": 51,
          "raw": "pub fn address_script_hash(address: Address) -> Option<ScriptHash> {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn address_script_hash(address: Address) -> Option<ScriptHash> {\n  when address.payment_credential is {\n    Script(script_hash) -> Some(script_hash)\n    _ -> None\n  }\n}",
          "reExportedAs": ["cocktail.address_script_hash"]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/crypto.{Blake2b_224, Hash, ScriptHash, VerificationKeyHash}\nuse aiken/primitive/bytearray\nuse cardano/address.{Address, Script, VerificationKey}\n\n/// Compare two script addresses \npub fn compare_script_address(x: Address, y: Address) -> Ordering {\n  expect Script(x_hash) = x.payment_credential\n  expect Script(y_hash) = y.payment_credential\n  bytearray.compare(x_hash, y_hash)\n}\n\n/// Compare two addresses\npub fn compare_address(x: Address, y: Address) -> Ordering {\n  let x_hash = x.payment_credential\n  let y_hash = y.payment_credential\n  when (x_hash, y_hash) is {\n    (Script(x_script_hash), Script(y_script_hash)) ->\n      bytearray.compare(x_script_hash, y_script_hash)\n    (VerificationKey(x_key_hash), VerificationKey(y_key_hash)) ->\n      bytearray.compare(x_key_hash, y_key_hash)\n    _ -> Equal\n  }\n}\n\n/// Obtain the payment key of an address, it can be either a script hash or a verification key\n/// ```aiken\n/// let payment_key_hash = address_payment_key(address)\n/// ```\npub fn address_payment_key(address: Address) -> Hash<Blake2b_224, ByteArray> {\n  when address.payment_credential is {\n    Script(hash) -> hash\n    VerificationKey(key_hash) -> key_hash\n  }\n}\n\n/// Obtain the verification key of an address, None if it is a script address\n/// ```aiken\n/// expect Some(pub_key_hash) = address_pub_key(address)\n/// ```\npub fn address_pub_key(address: Address) -> Option<VerificationKeyHash> {\n  when address.payment_credential is {\n    VerificationKey(key_hash) -> Some(key_hash)\n    _ -> None\n  }\n}\n\n/// Obtain the script hash of an address, None if it is a verification key address\n/// ```aiken\n/// expect Some(script_hash) = address_pub_key(address)\n/// ```\npub fn address_script_hash(address: Address) -> Option<ScriptHash> {\n  when address.payment_credential is {\n    Script(script_hash) -> Some(script_hash)\n    _ -> None\n  }\n}\n",
      "dependencies": [
        "aiken/crypto",
        "aiken/primitive/bytearray",
        "cardano/address"
      ],
      "source": "vodka",
      "isReExportFile": false
    },
    {
      "key": "vodka:cocktail.vodka_certificate",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-vodka/lib/cocktail/vodka_certificate.ak",
      "name": "cocktail.vodka_certificate",
      "imports": [
        {
          "module": "aiken/collection/list",
          "items": [],
          "line": 1,
          "raw": "use aiken/collection/list",
          "source": "vodka"
        },
        {
          "module": "cardano/address",
          "items": ["Credential", "Script"],
          "line": 2,
          "raw": "use cardano/address.{Credential, Script}",
          "source": "vodka"
        },
        {
          "module": "cardano/assets",
          "items": ["Lovelace"],
          "line": 3,
          "raw": "use cardano/assets.{Lovelace}",
          "source": "vodka"
        }
      ],
      "functions": [
        {
          "name": "register_stake_certificate",
          "signature": "pub fn register_stake_certificate(pub fn register_stake_certificate(certificates: List<Certificate>, credential: Credential, ) {",
          "documentation": "Check if a certain stake registration certificate exists in certificates.\n```aiken\nlet is_stake_registerd = register_stake_certificate(certificates, stake_credential)\n```",
          "parameters": [],
          "returnType": "Unknown",
          "line": 15,
          "raw": "pub fn register_stake_certificate(pub fn register_stake_certificate(certificates: List<Certificate>, credential: Credential, ) {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn register_stake_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n) {\n  list.has(certificates, RegisterCredential { credential, deposit: Never })\n}",
          "tests": [
            "test register_stake_certificate_found() {\n  let certificates =\n    [\n      RegisterCredential { credential: Script(\"\"), deposit: Never },\n      UnregisterCredential { credential: Script(\"\"), refund: Never },\n    ]\n\n  register_stake_certificate(certificates, Script(\"\")) == True\n}",
            "test register_stake_certificate_not_found() {\n  let certificates =\n    [\n      RegisterCredential { credential: Script(\"Not Found\"), deposit: Never },\n      UnregisterCredential { credential: Script(\"Not Found\"), refund: Never },\n    ]\n\n  register_stake_certificate(certificates, Script(\"\")) == False\n}"
          ]
        },
        {
          "name": "unregister_stake_certificate",
          "signature": "pub fn unregister_stake_certificate(pub fn unregister_stake_certificate(certificates: List<Certificate>, credential: Credential, ) {",
          "documentation": "Check if a certain stake unregistration certificate exists in certificates.\n```aiken\nlet is_stake_unregisterd = unregister_stake_certificate(certificates, stake_credential)\n```",
          "parameters": [],
          "returnType": "Unknown",
          "line": 46,
          "raw": "pub fn unregister_stake_certificate(pub fn unregister_stake_certificate(certificates: List<Certificate>, credential: Credential, ) {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn unregister_stake_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n) {\n  list.has(certificates, UnregisterCredential { credential, refund: Never })\n}",
          "tests": [
            "test unregister_stake_certificate_found() {\n  let certificates =\n    [\n      RegisterCredential { credential: Script(\"\"), deposit: Never },\n      UnregisterCredential { credential: Script(\"\"), refund: Never },\n    ]\n\n  unregister_stake_certificate(certificates, Script(\"\")) == True\n}",
            "test unregister_stake_certificate_not_found() {\n  let certificates =\n    [\n      RegisterCredential { credential: Script(\"Not Found\"), deposit: Never },\n      UnregisterCredential { credential: Script(\"Not Found\"), refund: Never },\n    ]\n\n  unregister_stake_certificate(certificates, Script(\"\")) == False\n}"
          ]
        },
        {
          "name": "register_drep_certificate",
          "signature": "pub fn register_drep_certificate(pub fn register_drep_certificate(certificates: List<Certificate>, credential: Credential, deposit: Lovelace, ) {",
          "documentation": "Check if a certain drep registration with specified deposit certificate exists in certificates.\n```aiken\nlet is_drep_registerd = register_drep_certificate(certificates, stake_credential, deposit)\n```",
          "parameters": [],
          "returnType": "Unknown",
          "line": 77,
          "raw": "pub fn register_drep_certificate(pub fn register_drep_certificate(certificates: List<Certificate>, credential: Credential, deposit: Lovelace, ) {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn register_drep_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n  deposit: Lovelace,\n) {\n  list.has(\n    certificates,\n    RegisterDelegateRepresentative {\n      delegate_representative: credential,\n      deposit,\n    },\n  )\n}",
          "tests": [
            "test register_drep_certificate_found() {\n  let certificates =\n    [\n      RegisterDelegateRepresentative {\n        delegate_representative: Script(\"\"),\n        deposit: 10,\n      },\n      UnregisterDelegateRepresentative {\n        delegate_representative: Script(\"\"),\n        refund: 10,\n      },\n    ]\n\n  register_drep_certificate(certificates, Script(\"\"), 10) == True\n}",
            "test register_drep_certificate_not_found_with_diff_cred() {\n  let certificates =\n    [\n      RegisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        deposit: 10,\n      },\n      UnregisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        refund: 10,\n      },\n    ]\n\n  register_drep_certificate(certificates, Script(\"\"), 10) == False\n}",
            "test register_drep_certificate_not_found_with_diff_deposit() {\n  let certificates =\n    [\n      RegisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        deposit: 0,\n      },\n      UnregisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        refund: 0,\n      },\n    ]\n\n  register_drep_certificate(certificates, Script(\"\"), 10) == False\n}"
          ]
        },
        {
          "name": "unregister_drep_certificate",
          "signature": "pub fn unregister_drep_certificate(pub fn unregister_drep_certificate(certificates: List<Certificate>, credential: Credential, refund: Lovelace, ) {",
          "documentation": "Check if a certain drep unregistration with specified refund certificate exists in certificates.\n```aiken\nlet is_drep_unregisterd = unregister_drep_certificate(certificates, stake_credential, refund)\n```",
          "parameters": [],
          "returnType": "Unknown",
          "line": 143,
          "raw": "pub fn unregister_drep_certificate(pub fn unregister_drep_certificate(certificates: List<Certificate>, credential: Credential, refund: Lovelace, ) {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn unregister_drep_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n  refund: Lovelace,\n) {\n  list.has(\n    certificates,\n    UnregisterDelegateRepresentative {\n      delegate_representative: credential,\n      refund,\n    },\n  )\n}",
          "tests": [
            "test unregister_drep_certificate_found() {\n  let certificates =\n    [\n      RegisterDelegateRepresentative {\n        delegate_representative: Script(\"\"),\n        deposit: 10,\n      },\n      UnregisterDelegateRepresentative {\n        delegate_representative: Script(\"\"),\n        refund: 10,\n      },\n    ]\n\n  unregister_drep_certificate(certificates, Script(\"\"), 10) == True\n}",
            "test unregister_drep_certificate_not_found_with_diff_cred() {\n  let certificates =\n    [\n      RegisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        deposit: 10,\n      },\n      UnregisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        refund: 10,\n      },\n    ]\n\n  unregister_drep_certificate(certificates, Script(\"\"), 10) == False\n}",
            "test unregister_drep_certificate_not_found_with_diff_refund() {\n  let certificates =\n    [\n      RegisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        deposit: 0,\n      },\n      UnregisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        refund: 0,\n      },\n    ]\n\n  unregister_drep_certificate(certificates, Script(\"\"), 10) == False\n}"
          ]
        },
        {
          "name": "delegate_stake_certificate",
          "signature": "pub fn delegate_stake_certificate(pub fn delegate_stake_certificate(certificates: List<Certificate>, credential: Credential, stake_pool: StakePoolId, ) {",
          "documentation": "Check if a certain stake delegation to a specificed pool certificate exists in certificates.\n```aiken\nlet is_stake_delegated = delegate_stake_certificate(certificates, stake_credential, stake_pool)\n```",
          "parameters": [],
          "returnType": "Unknown",
          "line": 209,
          "raw": "pub fn delegate_stake_certificate(pub fn delegate_stake_certificate(certificates: List<Certificate>, credential: Credential, stake_pool: StakePoolId, ) {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn delegate_stake_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n  stake_pool: StakePoolId,\n) {\n  list.has(\n    certificates,\n    DelegateCredential {\n      credential,\n      delegate: DelegateBlockProduction { stake_pool },\n    },\n  )\n}",
          "tests": [
            "test delegate_stake_certificate_found() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_stake_certificate(certificates, Script(\"\"), \"\") == True\n}",
            "test delegate_stake_certificate_not_found_with_diff_cred() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_stake_certificate(certificates, Script(\"\"), \"\") == False\n}",
            "test delegate_stake_certificate_not_found_with_diff_pool() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"Not Found\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_stake_certificate(certificates, Script(\"\"), \"\") == False\n}"
          ]
        },
        {
          "name": "delegate_vote_certificate",
          "signature": "pub fn delegate_vote_certificate(pub fn delegate_vote_certificate(certificates: List<Certificate>, credential: Credential, delegate_representative: DelegateRepresentative, ) {",
          "documentation": "Check if a certain voting power delegation to a specificed drep certificate exists in certificates.\n```aiken\nlet is_vote_delegated = delegate_vote_certificate(certificates, stake_credential, delegate_representative)\n```",
          "parameters": [],
          "returnType": "Unknown",
          "line": 281,
          "raw": "pub fn delegate_vote_certificate(pub fn delegate_vote_certificate(certificates: List<Certificate>, credential: Credential, delegate_representative: DelegateRepresentative, ) {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn delegate_vote_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n  delegate_representative: DelegateRepresentative,\n) {\n  list.has(\n    certificates,\n    DelegateCredential {\n      credential,\n      delegate: DelegateVote { delegate_representative },\n    },\n  )\n}",
          "tests": [
            "test delegate_vote_certificate_found() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_vote_certificate(certificates, Script(\"\"), Registered(Script(\"\"))) == True\n}",
            "test delegate_vote_certificate_not_found_with_diff_cred() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_vote_certificate(certificates, Script(\"\"), Registered(Script(\"\"))) == False\n}",
            "test delegate_vote_certificate_not_found_with_diff_drep() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"Not Found\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"Not Found\")),\n        },\n      },\n    ]\n\n  delegate_vote_certificate(certificates, Script(\"\"), Registered(Script(\"\"))) == False\n}"
          ]
        },
        {
          "name": "delegate_stake_and_vote_certificate",
          "signature": "pub fn delegate_stake_and_vote_certificate(pub fn delegate_stake_and_vote_certificate(certificates: List<Certificate>, credential: Credential, stake_pool: StakePoolId, delegate_representative: DelegateRepresentative, ) {",
          "documentation": "Check if a certain delegation to a specificed pool and drep certificate exists in certificates.\n```aiken\nlet is_stake_and_vote_delegated = delegate_stake_and_vote_certificate(certificates, stake_credential, stake_pool, delegate_representative)\n```",
          "parameters": [],
          "returnType": "Unknown",
          "line": 353,
          "raw": "pub fn delegate_stake_and_vote_certificate(pub fn delegate_stake_and_vote_certificate(certificates: List<Certificate>, credential: Credential, stake_pool: StakePoolId, delegate_representative: DelegateRepresentative, ) {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn delegate_stake_and_vote_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n  stake_pool: StakePoolId,\n  delegate_representative: DelegateRepresentative,\n) {\n  list.has(\n    certificates,\n    DelegateCredential {\n      credential,\n      delegate: DelegateBoth { stake_pool, delegate_representative },\n    },\n  )\n}",
          "tests": [
            "test delegate_stake_and_vote_certificate_found() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBoth {\n          stake_pool: \"\",\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_stake_and_vote_certificate(\n    certificates,\n    Script(\"\"),\n    \"\",\n    Registered(Script(\"\")),\n  ) == True\n}",
            "test delegate_stake_and_vote_certificate_not_found_with_diff_cred() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateBoth {\n          stake_pool: \"\",\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_stake_and_vote_certificate(\n    certificates,\n    Script(\"\"),\n    \"\",\n    Registered(Script(\"\")),\n  ) == False\n}",
            "test delegate_stake_and_vote_certificate_not_found_with_diff_drep() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBoth {\n          stake_pool: \"\",\n          delegate_representative: Registered(Script(\"Not Found\")),\n        },\n      },\n    ]\n\n  delegate_stake_and_vote_certificate(\n    certificates,\n    Script(\"\"),\n    \"\",\n    Registered(Script(\"\")),\n  ) == False\n}",
            "test delegate_stake_and_vote_certificate_not_found_with_diff_pool() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBoth {\n          stake_pool: \"Not Found\",\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_stake_and_vote_certificate(\n    certificates,\n    Script(\"\"),\n    \"\",\n    Registered(Script(\"\")),\n  ) == False\n}"
          ]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/collection/list\nuse cardano/address.{Credential, Script}\nuse cardano/assets.{Lovelace}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateBoth, DelegateCredential,\n  DelegateRepresentative, DelegateVote, RegisterCredential,\n  RegisterDelegateRepresentative, Registered, StakePoolId, UnregisterCredential,\n  UnregisterDelegateRepresentative,\n}\n\n/// Check if a certain stake registration certificate exists in certificates.\n/// ```aiken\n/// let is_stake_registerd = register_stake_certificate(certificates, stake_credential)\n/// ```\npub fn register_stake_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n) {\n  list.has(certificates, RegisterCredential { credential, deposit: Never })\n}\n\ntest register_stake_certificate_found() {\n  let certificates =\n    [\n      RegisterCredential { credential: Script(\"\"), deposit: Never },\n      UnregisterCredential { credential: Script(\"\"), refund: Never },\n    ]\n\n  register_stake_certificate(certificates, Script(\"\")) == True\n}\n\ntest register_stake_certificate_not_found() {\n  let certificates =\n    [\n      RegisterCredential { credential: Script(\"Not Found\"), deposit: Never },\n      UnregisterCredential { credential: Script(\"Not Found\"), refund: Never },\n    ]\n\n  register_stake_certificate(certificates, Script(\"\")) == False\n}\n\n/// Check if a certain stake unregistration certificate exists in certificates.\n/// ```aiken\n/// let is_stake_unregisterd = unregister_stake_certificate(certificates, stake_credential)\n/// ```\npub fn unregister_stake_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n) {\n  list.has(certificates, UnregisterCredential { credential, refund: Never })\n}\n\ntest unregister_stake_certificate_found() {\n  let certificates =\n    [\n      RegisterCredential { credential: Script(\"\"), deposit: Never },\n      UnregisterCredential { credential: Script(\"\"), refund: Never },\n    ]\n\n  unregister_stake_certificate(certificates, Script(\"\")) == True\n}\n\ntest unregister_stake_certificate_not_found() {\n  let certificates =\n    [\n      RegisterCredential { credential: Script(\"Not Found\"), deposit: Never },\n      UnregisterCredential { credential: Script(\"Not Found\"), refund: Never },\n    ]\n\n  unregister_stake_certificate(certificates, Script(\"\")) == False\n}\n\n/// Check if a certain drep registration with specified deposit certificate exists in certificates.\n/// ```aiken\n/// let is_drep_registerd = register_drep_certificate(certificates, stake_credential, deposit)\n/// ```\npub fn register_drep_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n  deposit: Lovelace,\n) {\n  list.has(\n    certificates,\n    RegisterDelegateRepresentative {\n      delegate_representative: credential,\n      deposit,\n    },\n  )\n}\n\ntest register_drep_certificate_found() {\n  let certificates =\n    [\n      RegisterDelegateRepresentative {\n        delegate_representative: Script(\"\"),\n        deposit: 10,\n      },\n      UnregisterDelegateRepresentative {\n        delegate_representative: Script(\"\"),\n        refund: 10,\n      },\n    ]\n\n  register_drep_certificate(certificates, Script(\"\"), 10) == True\n}\n\ntest register_drep_certificate_not_found_with_diff_cred() {\n  let certificates =\n    [\n      RegisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        deposit: 10,\n      },\n      UnregisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        refund: 10,\n      },\n    ]\n\n  register_drep_certificate(certificates, Script(\"\"), 10) == False\n}\n\ntest register_drep_certificate_not_found_with_diff_deposit() {\n  let certificates =\n    [\n      RegisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        deposit: 0,\n      },\n      UnregisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        refund: 0,\n      },\n    ]\n\n  register_drep_certificate(certificates, Script(\"\"), 10) == False\n}\n\n/// Check if a certain drep unregistration with specified refund certificate exists in certificates.\n/// ```aiken\n/// let is_drep_unregisterd = unregister_drep_certificate(certificates, stake_credential, refund)\n/// ```\npub fn unregister_drep_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n  refund: Lovelace,\n) {\n  list.has(\n    certificates,\n    UnregisterDelegateRepresentative {\n      delegate_representative: credential,\n      refund,\n    },\n  )\n}\n\ntest unregister_drep_certificate_found() {\n  let certificates =\n    [\n      RegisterDelegateRepresentative {\n        delegate_representative: Script(\"\"),\n        deposit: 10,\n      },\n      UnregisterDelegateRepresentative {\n        delegate_representative: Script(\"\"),\n        refund: 10,\n      },\n    ]\n\n  unregister_drep_certificate(certificates, Script(\"\"), 10) == True\n}\n\ntest unregister_drep_certificate_not_found_with_diff_cred() {\n  let certificates =\n    [\n      RegisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        deposit: 10,\n      },\n      UnregisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        refund: 10,\n      },\n    ]\n\n  unregister_drep_certificate(certificates, Script(\"\"), 10) == False\n}\n\ntest unregister_drep_certificate_not_found_with_diff_refund() {\n  let certificates =\n    [\n      RegisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        deposit: 0,\n      },\n      UnregisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        refund: 0,\n      },\n    ]\n\n  unregister_drep_certificate(certificates, Script(\"\"), 10) == False\n}\n\n/// Check if a certain stake delegation to a specificed pool certificate exists in certificates.\n/// ```aiken\n/// let is_stake_delegated = delegate_stake_certificate(certificates, stake_credential, stake_pool)\n/// ```\npub fn delegate_stake_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n  stake_pool: StakePoolId,\n) {\n  list.has(\n    certificates,\n    DelegateCredential {\n      credential,\n      delegate: DelegateBlockProduction { stake_pool },\n    },\n  )\n}\n\ntest delegate_stake_certificate_found() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_stake_certificate(certificates, Script(\"\"), \"\") == True\n}\n\ntest delegate_stake_certificate_not_found_with_diff_cred() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_stake_certificate(certificates, Script(\"\"), \"\") == False\n}\n\ntest delegate_stake_certificate_not_found_with_diff_pool() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"Not Found\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_stake_certificate(certificates, Script(\"\"), \"\") == False\n}\n\n/// Check if a certain voting power delegation to a specificed drep certificate exists in certificates.\n/// ```aiken\n/// let is_vote_delegated = delegate_vote_certificate(certificates, stake_credential, delegate_representative)\n/// ```\npub fn delegate_vote_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n  delegate_representative: DelegateRepresentative,\n) {\n  list.has(\n    certificates,\n    DelegateCredential {\n      credential,\n      delegate: DelegateVote { delegate_representative },\n    },\n  )\n}\n\ntest delegate_vote_certificate_found() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_vote_certificate(certificates, Script(\"\"), Registered(Script(\"\"))) == True\n}\n\ntest delegate_vote_certificate_not_found_with_diff_cred() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_vote_certificate(certificates, Script(\"\"), Registered(Script(\"\"))) == False\n}\n\ntest delegate_vote_certificate_not_found_with_diff_drep() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"Not Found\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"Not Found\")),\n        },\n      },\n    ]\n\n  delegate_vote_certificate(certificates, Script(\"\"), Registered(Script(\"\"))) == False\n}\n\n/// Check if a certain delegation to a specificed pool and drep certificate exists in certificates.\n/// ```aiken\n/// let is_stake_and_vote_delegated = delegate_stake_and_vote_certificate(certificates, stake_credential, stake_pool, delegate_representative)\n/// ```\npub fn delegate_stake_and_vote_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n  stake_pool: StakePoolId,\n  delegate_representative: DelegateRepresentative,\n) {\n  list.has(\n    certificates,\n    DelegateCredential {\n      credential,\n      delegate: DelegateBoth { stake_pool, delegate_representative },\n    },\n  )\n}\n\ntest delegate_stake_and_vote_certificate_found() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBoth {\n          stake_pool: \"\",\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_stake_and_vote_certificate(\n    certificates,\n    Script(\"\"),\n    \"\",\n    Registered(Script(\"\")),\n  ) == True\n}\n\ntest delegate_stake_and_vote_certificate_not_found_with_diff_cred() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateBoth {\n          stake_pool: \"\",\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_stake_and_vote_certificate(\n    certificates,\n    Script(\"\"),\n    \"\",\n    Registered(Script(\"\")),\n  ) == False\n}\n\ntest delegate_stake_and_vote_certificate_not_found_with_diff_drep() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBoth {\n          stake_pool: \"\",\n          delegate_representative: Registered(Script(\"Not Found\")),\n        },\n      },\n    ]\n\n  delegate_stake_and_vote_certificate(\n    certificates,\n    Script(\"\"),\n    \"\",\n    Registered(Script(\"\")),\n  ) == False\n}\n\ntest delegate_stake_and_vote_certificate_not_found_with_diff_pool() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBoth {\n          stake_pool: \"Not Found\",\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_stake_and_vote_certificate(\n    certificates,\n    Script(\"\"),\n    \"\",\n    Registered(Script(\"\")),\n  ) == False\n}\n",
      "dependencies": [
        "aiken/collection/list",
        "cardano/address",
        "cardano/assets"
      ],
      "source": "vodka",
      "isReExportFile": false
    },
    {
      "key": "vodka:cocktail.vodka_converter",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-vodka/lib/cocktail/vodka_converter.ak",
      "name": "cocktail.vodka_converter",
      "imports": [
        {
          "module": "aiken/primitive/bytearray",
          "items": [],
          "line": 1,
          "raw": "use aiken/primitive/bytearray",
          "source": "vodka"
        }
      ],
      "functions": [
        {
          "name": "convert_int_to_bytes",
          "signature": "pub fn convert_int_to_bytes(i: Int) -> ByteArray {",
          "documentation": "Convert an integer to a \"stringify\" ByteArray value\n```aiken\nlet int_bytes = convert_int_to_bytes(123)\nlet this_is_true = int_bytes == \"123\"\n```",
          "parameters": [
            {
              "name": "i",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 8,
          "raw": "pub fn convert_int_to_bytes(i: Int) -> ByteArray {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn convert_int_to_bytes(i: Int) -> ByteArray {\n  convert_int_to_bytes_go(i, get_number_digit(i))\n}",
          "reExportedAs": ["cocktail.convert_int_to_bytes"]
        },
        {
          "name": "get_number_digit",
          "signature": "pub fn get_number_digit(i: Int) -> Int {",
          "documentation": "Get the number of digits in an integer",
          "parameters": [
            {
              "name": "i",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 24,
          "raw": "pub fn get_number_digit(i: Int) -> Int {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn get_number_digit(i: Int) -> Int {\n  go_get_number_digit(i, 1)\n}",
          "reExportedAs": ["cocktail.get_number_digit"]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [
        {
          "name": "convert_int_to_bytes_go",
          "signature": "fn convert_int_to_bytes_go(newInt: Int, digit: Int) -> ByteArray {",
          "parameters": [
            {
              "name": "newInt",
              "type": "Int",
              "optional": false
            },
            {
              "name": "digit",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 12,
          "raw": "fn convert_int_to_bytes_go(newInt: Int, digit: Int) -> ByteArray {",
          "isPublic": false,
          "source": "vodka",
          "implementation": "fn convert_int_to_bytes_go(newInt: Int, digit: Int) -> ByteArray {\n  if digit == 1 {\n    bytearray.push(\"\", newInt + 48)\n  } else {\n    bytearray.push(\n      convert_int_to_bytes_go(newInt % digit, digit / 10),\n      newInt / digit + 48,\n    )\n  }\n}"
        },
        {
          "name": "go_get_number_digit",
          "signature": "fn go_get_number_digit(newInt: Int, digit: Int) -> Int {",
          "parameters": [
            {
              "name": "newInt",
              "type": "Int",
              "optional": false
            },
            {
              "name": "digit",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 28,
          "raw": "fn go_get_number_digit(newInt: Int, digit: Int) -> Int {",
          "isPublic": false,
          "source": "vodka",
          "implementation": "fn go_get_number_digit(newInt: Int, digit: Int) -> Int {\n  if newInt < 10 {\n    digit\n  } else {\n    go_get_number_digit(newInt / 10, digit * 10)\n  }\n}"
        }
      ],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/primitive/bytearray\n\n/// Convert an integer to a \"stringify\" ByteArray value\n/// ```aiken\n/// let int_bytes = convert_int_to_bytes(123)\n/// let this_is_true = int_bytes == \"123\"\n/// ```\npub fn convert_int_to_bytes(i: Int) -> ByteArray {\n  convert_int_to_bytes_go(i, get_number_digit(i))\n}\n\nfn convert_int_to_bytes_go(newInt: Int, digit: Int) -> ByteArray {\n  if digit == 1 {\n    bytearray.push(\"\", newInt + 48)\n  } else {\n    bytearray.push(\n      convert_int_to_bytes_go(newInt % digit, digit / 10),\n      newInt / digit + 48,\n    )\n  }\n}\n\n/// Get the number of digits in an integer\npub fn get_number_digit(i: Int) -> Int {\n  go_get_number_digit(i, 1)\n}\n\nfn go_get_number_digit(newInt: Int, digit: Int) -> Int {\n  if newInt < 10 {\n    digit\n  } else {\n    go_get_number_digit(newInt / 10, digit * 10)\n  }\n}\n\ntest byte_conversion() {\n  convert_int_to_bytes(1) == \"1\" && convert_int_to_bytes(123) == \"123\" && convert_int_to_bytes(\n    672912,\n  ) == \"672912\"\n}\n",
      "dependencies": ["aiken/primitive/bytearray"],
      "source": "vodka",
      "isReExportFile": false
    },
    {
      "key": "vodka:cocktail.vodka_extra_signatories",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-vodka/lib/cocktail/vodka_extra_signatories.ak",
      "name": "cocktail.vodka_extra_signatories",
      "imports": [
        {
          "module": "aiken/collection/list",
          "items": [],
          "line": 1,
          "raw": "use aiken/collection/list",
          "source": "vodka"
        }
      ],
      "functions": [
        {
          "name": "key_signed",
          "signature": "pub fn key_signed(extra_signatories: List<ByteArray>, key: ByteArray) {",
          "documentation": "Check if a key is signed by any of the extra_signatories\n```aiken\nlet extra_signatories = [\"key1\", \"key2\", \"key3\"]\n\nlet key_to_test_1 = \"key2\"\nlet this_is_true = key_signed(extra_signatories, key_to_test_1)\n\nlet key_to_test_2 = \"key4\"\nlet this_is_false = key_signed(extra_signatories, key_to_test_2)\n```",
          "parameters": [
            {
              "name": "extra_signatories",
              "type": "List<ByteArray>",
              "optional": false
            },
            {
              "name": "key",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 13,
          "raw": "pub fn key_signed(extra_signatories: List<ByteArray>, key: ByteArray) {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn key_signed(extra_signatories: List<ByteArray>, key: ByteArray) {\n  list.has(extra_signatories, key)\n}",
          "reExportedAs": ["cocktail.key_signed"]
        },
        {
          "name": "one_of_keys_signed",
          "signature": "pub fn one_of_keys_signed(pub fn one_of_keys_signed(extra_signatories: List<ByteArray>, keys: List<ByteArray>, ) {",
          "documentation": "Check if any of the keys are signed by the extra_signatories\n```aiken\nlet extra_signatories = [\"key1\", \"key2\", \"key3\"]\n\nlet keys_to_test_1 = [\"key4\", \"key2\", \"key5\"]\nlet this_is_true = one_of_keys_signed(extra_signatories, keys_to_test_1)\n\nlet keys_to_test_2 = [\"key4\", \"key5\"]\nlet this_is_false = one_of_keys_signed(extra_signatories, keys_to_test_2)\n```",
          "parameters": [],
          "returnType": "Unknown",
          "line": 27,
          "raw": "pub fn one_of_keys_signed(pub fn one_of_keys_signed(extra_signatories: List<ByteArray>, keys: List<ByteArray>, ) {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn one_of_keys_signed(\n  extra_signatories: List<ByteArray>,\n  keys: List<ByteArray>,\n) {\n  list.any(keys, fn(key) { key_signed(extra_signatories, key) })\n}",
          "reExportedAs": ["cocktail.one_of_keys_signed"]
        },
        {
          "name": "all_key_signed",
          "signature": "pub fn all_key_signed(extra_signatories: List<ByteArray>, keys: List<ByteArray>) {",
          "documentation": "Check if all of the keys are signed by the extra_signatories\n```aiken\nlet extra_signatories = [\"key1\", \"key2\", \"key3\"]\n\nlet keys_to_test_1 = [\"key2\", \"key3\"]\nlet this_is_true = all_keys_signed(extra_signatories, keys_to_test_1)\n\nlet keys_to_test_2 = [\"key2\", \"key4\"]\nlet this_is_false = all_keys_signed(extra_signatories, keys_to_test_2)\n```",
          "parameters": [
            {
              "name": "extra_signatories",
              "type": "List<ByteArray>",
              "optional": false
            },
            {
              "name": "keys",
              "type": "List<ByteArray>",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 44,
          "raw": "pub fn all_key_signed(extra_signatories: List<ByteArray>, keys: List<ByteArray>) {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn all_key_signed(extra_signatories: List<ByteArray>, keys: List<ByteArray>) {\n  list.all(keys, fn(key) { key_signed(extra_signatories, key) })\n}",
          "reExportedAs": ["cocktail.all_key_signed"]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/collection/list\n\n/// Check if a key is signed by any of the extra_signatories\n/// ```aiken\n/// let extra_signatories = [\"key1\", \"key2\", \"key3\"]\n/// \n/// let key_to_test_1 = \"key2\"\n/// let this_is_true = key_signed(extra_signatories, key_to_test_1)\n///\n/// let key_to_test_2 = \"key4\"\n/// let this_is_false = key_signed(extra_signatories, key_to_test_2)\n/// ```\npub fn key_signed(extra_signatories: List<ByteArray>, key: ByteArray) {\n  list.has(extra_signatories, key)\n}\n\n/// Check if any of the keys are signed by the extra_signatories\n/// ```aiken\n/// let extra_signatories = [\"key1\", \"key2\", \"key3\"]\n/// \n/// let keys_to_test_1 = [\"key4\", \"key2\", \"key5\"]\n/// let this_is_true = one_of_keys_signed(extra_signatories, keys_to_test_1)\n/// \n/// let keys_to_test_2 = [\"key4\", \"key5\"]\n/// let this_is_false = one_of_keys_signed(extra_signatories, keys_to_test_2)\n/// ```\npub fn one_of_keys_signed(\n  extra_signatories: List<ByteArray>,\n  keys: List<ByteArray>,\n) {\n  list.any(keys, fn(key) { key_signed(extra_signatories, key) })\n}\n\n/// Check if all of the keys are signed by the extra_signatories\n/// ```aiken\n/// let extra_signatories = [\"key1\", \"key2\", \"key3\"]\n///\n/// let keys_to_test_1 = [\"key2\", \"key3\"]\n/// let this_is_true = all_keys_signed(extra_signatories, keys_to_test_1)\n///\n/// let keys_to_test_2 = [\"key2\", \"key4\"]\n/// let this_is_false = all_keys_signed(extra_signatories, keys_to_test_2)\n/// ```\npub fn all_key_signed(extra_signatories: List<ByteArray>, keys: List<ByteArray>) {\n  list.all(keys, fn(key) { key_signed(extra_signatories, key) })\n}\n",
      "dependencies": ["aiken/collection/list"],
      "source": "vodka",
      "isReExportFile": false
    },
    {
      "key": "vodka:cocktail.vodka_inputs",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-vodka/lib/cocktail/vodka_inputs.ak",
      "name": "cocktail.vodka_inputs",
      "imports": [
        {
          "module": "aiken/collection/list",
          "items": [],
          "line": 1,
          "raw": "use aiken/collection/list",
          "source": "vodka"
        },
        {
          "module": "cardano/address",
          "items": ["Address"],
          "line": 2,
          "raw": "use cardano/address.{Address}",
          "source": "vodka"
        },
        {
          "module": "cardano/assets",
          "items": ["AssetName", "PolicyId", "flatten", "quantity_of"],
          "line": 3,
          "raw": "use cardano/assets.{AssetName, PolicyId, flatten, quantity_of}",
          "source": "vodka"
        },
        {
          "module": "cardano/transaction",
          "items": ["InlineDatum", "Input"],
          "line": 4,
          "raw": "use cardano/transaction.{InlineDatum, Input}",
          "source": "vodka"
        }
      ],
      "functions": [
        {
          "name": "input_inline_datum",
          "signature": "pub fn input_inline_datum(input: Input) {",
          "documentation": "Extracts the inline datum from an input.\n```aiken\nexpect inline_datum: MyDatumType = input_inline_datum(input)\n```",
          "parameters": [
            {
              "name": "input",
              "type": "Input",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 10,
          "raw": "pub fn input_inline_datum(input: Input) {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn input_inline_datum(input: Input) {\n  expect InlineDatum(raw_datum) = input.output.datum\n  raw_datum\n}",
          "reExportedAs": ["cocktail.input_inline_datum"]
        },
        {
          "name": "only_input_datum_with",
          "signature": "pub fn only_input_datum_with(pub fn only_input_datum_with(inputs: List<Input>, policy: PolicyId, name: AssetName, ) {",
          "documentation": "Extract the inline datum by locating the first input in a list of inputs by Address and PolicyId.\n```aiken\nexpect inline_datum: MyDatumType = only_input_datum_with(inputs, policy, name)\n```",
          "parameters": [],
          "returnType": "Unknown",
          "line": 19,
          "raw": "pub fn only_input_datum_with(pub fn only_input_datum_with(inputs: List<Input>, policy: PolicyId, name: AssetName, ) {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn only_input_datum_with(\n  inputs: List<Input>,\n  policy: PolicyId,\n  name: AssetName,\n) {\n  expect Some(input) =\n    list.find(\n      inputs,\n      fn(input) { quantity_of(input.output.value, policy, name) == 1 },\n    )\n  input_inline_datum(input)\n}",
          "reExportedAs": ["cocktail.only_input_datum_with"]
        },
        {
          "name": "inputs_at",
          "signature": "pub fn inputs_at(inputs: List<Input>, address: Address) -> List<Input> {",
          "documentation": "Filters inputs by Address.\n```aiken\nlet filtered_inputs = inputs_at(inputs, address)\n```",
          "parameters": [
            {
              "name": "inputs",
              "type": "List<Input>",
              "optional": false
            },
            {
              "name": "address",
              "type": "Address",
              "optional": false
            }
          ],
          "returnType": "List<Input>",
          "line": 36,
          "raw": "pub fn inputs_at(inputs: List<Input>, address: Address) -> List<Input> {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn inputs_at(inputs: List<Input>, address: Address) -> List<Input> {\n  list.filter(inputs, fn(input) { input.output.address == address })\n}",
          "reExportedAs": ["cocktail.inputs_at"]
        },
        {
          "name": "inputs_with",
          "signature": "pub fn inputs_with(pub fn inputs_with(inputs: List<Input>, policy: PolicyId, name: AssetName, ) -> List<Input> {",
          "documentation": "Filters inputs by PolicyId and AssetName.\n```aiken\nlet filtered_inputs = inputs_with(inputs, policy, name)\n```",
          "parameters": [],
          "returnType": "List<Input>",
          "line": 44,
          "raw": "pub fn inputs_with(pub fn inputs_with(inputs: List<Input>, policy: PolicyId, name: AssetName, ) -> List<Input> {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn inputs_with(\n  inputs: List<Input>,\n  policy: PolicyId,\n  name: AssetName,\n) -> List<Input> {\n  list.filter(\n    inputs,\n    fn(input) { quantity_of(input.output.value, policy, name) == 1 },\n  )\n}",
          "reExportedAs": ["cocktail.inputs_with"]
        },
        {
          "name": "inputs_with_policy",
          "signature": "pub fn inputs_with_policy(inputs: List<Input>, policy: PolicyId) -> List<Input> {",
          "documentation": "Filters inputs by token policy.\n```aiken\nlet filtered_inputs = inputs_with_policy(inputs, policy)\n```",
          "parameters": [
            {
              "name": "inputs",
              "type": "List<Input>",
              "optional": false
            },
            {
              "name": "policy",
              "type": "PolicyId",
              "optional": false
            }
          ],
          "returnType": "List<Input>",
          "line": 59,
          "raw": "pub fn inputs_with_policy(inputs: List<Input>, policy: PolicyId) -> List<Input> {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn inputs_with_policy(inputs: List<Input>, policy: PolicyId) -> List<Input> {\n  list.filter(\n    inputs,\n    fn(input) {\n      list.any(flatten(input.output.value), fn(token) { token.1st == policy })\n    },\n  )\n}",
          "reExportedAs": ["cocktail.inputs_with_policy"]
        },
        {
          "name": "inputs_at_with",
          "signature": "pub fn inputs_at_with(pub fn inputs_at_with(inputs: List<Input>, address: Address, policy: PolicyId, name: AssetName, ) -> List<Input> {",
          "documentation": "Filters inputs by Address, PolicyId, and AssetName.\n```aiken\nlet filtered_inputs = inputs_at_with(inputs, address, policy, name)\n```",
          "parameters": [],
          "returnType": "List<Input>",
          "line": 72,
          "raw": "pub fn inputs_at_with(pub fn inputs_at_with(inputs: List<Input>, address: Address, policy: PolicyId, name: AssetName, ) -> List<Input> {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn inputs_at_with(\n  inputs: List<Input>,\n  address: Address,\n  policy: PolicyId,\n  name: AssetName,\n) -> List<Input> {\n  list.filter(\n    inputs,\n    fn(input) {\n      input.output.address == address && quantity_of(\n        input.output.value,\n        policy,\n        name,\n      ) == 1\n    },\n  )\n}",
          "reExportedAs": ["cocktail.inputs_at_with"]
        },
        {
          "name": "inputs_at_with_policy",
          "signature": "pub fn inputs_at_with_policy(pub fn inputs_at_with_policy(inputs: List<Input>, address: Address, policy: PolicyId, ) -> List<Input> {",
          "documentation": "Filters inputs by Address and PolicyId.\n```aiken\nlet filtered_inputs = inputs_at_with_policy(inputs, address, policy)\n```",
          "parameters": [],
          "returnType": "List<Input>",
          "line": 94,
          "raw": "pub fn inputs_at_with_policy(pub fn inputs_at_with_policy(inputs: List<Input>, address: Address, policy: PolicyId, ) -> List<Input> {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn inputs_at_with_policy(\n  inputs: List<Input>,\n  address: Address,\n  policy: PolicyId,\n) -> List<Input> {\n  list.filter(\n    inputs,\n    fn(input) {\n      input.output.address == address && list.any(\n        flatten(input.output.value),\n        fn(token) { token.1st == policy },\n      )\n    },\n  )\n}",
          "reExportedAs": ["cocktail.inputs_at_with_policy"]
        },
        {
          "name": "inputs_token_quantity",
          "signature": "pub fn inputs_token_quantity(pub fn inputs_token_quantity(inputs: List<Input>, token: (PolicyId, AssetName),",
          "documentation": "Calculate the total quantity of a token in a list of inputs.\n```aiken\nlet total_quantity = inputs_token_quantity(inputs, token)\n```",
          "parameters": [],
          "returnType": "Unknown",
          "line": 114,
          "raw": "pub fn inputs_token_quantity(pub fn inputs_token_quantity(inputs: List<Input>, token: (PolicyId, AssetName),",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn inputs_token_quantity(\n  inputs: List<Input>,\n  token: (PolicyId, AssetName),\n) -> Int {\n  list.map(\n    inputs,\n    fn(input) { quantity_of(input.output.value, token.1st, token.2nd) },\n  )\n    |> list.foldr(0, fn(n, total) { n + total })\n}",
          "reExportedAs": ["cocktail.inputs_token_quantity"]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/collection/list\nuse cardano/address.{Address}\nuse cardano/assets.{AssetName, PolicyId, flatten, quantity_of}\nuse cardano/transaction.{InlineDatum, Input}\n\n/// Extracts the inline datum from an input.\n/// ```aiken\n/// expect inline_datum: MyDatumType = input_inline_datum(input)\n/// ```\npub fn input_inline_datum(input: Input) {\n  expect InlineDatum(raw_datum) = input.output.datum\n  raw_datum\n}\n\n/// Extract the inline datum by locating the first input in a list of inputs by Address and PolicyId.\n/// ```aiken\n/// expect inline_datum: MyDatumType = only_input_datum_with(inputs, policy, name)\n/// ```\npub fn only_input_datum_with(\n  inputs: List<Input>,\n  policy: PolicyId,\n  name: AssetName,\n) {\n  expect Some(input) =\n    list.find(\n      inputs,\n      fn(input) { quantity_of(input.output.value, policy, name) == 1 },\n    )\n  input_inline_datum(input)\n}\n\n/// Filters inputs by Address.\n/// ```aiken\n/// let filtered_inputs = inputs_at(inputs, address)\n/// ```\npub fn inputs_at(inputs: List<Input>, address: Address) -> List<Input> {\n  list.filter(inputs, fn(input) { input.output.address == address })\n}\n\n/// Filters inputs by PolicyId and AssetName.\n/// ```aiken\n/// let filtered_inputs = inputs_with(inputs, policy, name)\n/// ```\npub fn inputs_with(\n  inputs: List<Input>,\n  policy: PolicyId,\n  name: AssetName,\n) -> List<Input> {\n  list.filter(\n    inputs,\n    fn(input) { quantity_of(input.output.value, policy, name) == 1 },\n  )\n}\n\n/// Filters inputs by token policy.\n/// ```aiken\n/// let filtered_inputs = inputs_with_policy(inputs, policy)\n/// ```\npub fn inputs_with_policy(inputs: List<Input>, policy: PolicyId) -> List<Input> {\n  list.filter(\n    inputs,\n    fn(input) {\n      list.any(flatten(input.output.value), fn(token) { token.1st == policy })\n    },\n  )\n}\n\n/// Filters inputs by Address, PolicyId, and AssetName.\n/// ```aiken\n/// let filtered_inputs = inputs_at_with(inputs, address, policy, name)\n/// ```\npub fn inputs_at_with(\n  inputs: List<Input>,\n  address: Address,\n  policy: PolicyId,\n  name: AssetName,\n) -> List<Input> {\n  list.filter(\n    inputs,\n    fn(input) {\n      input.output.address == address && quantity_of(\n        input.output.value,\n        policy,\n        name,\n      ) == 1\n    },\n  )\n}\n\n/// Filters inputs by Address and PolicyId.\n/// ```aiken\n/// let filtered_inputs = inputs_at_with_policy(inputs, address, policy)\n/// ```\npub fn inputs_at_with_policy(\n  inputs: List<Input>,\n  address: Address,\n  policy: PolicyId,\n) -> List<Input> {\n  list.filter(\n    inputs,\n    fn(input) {\n      input.output.address == address && list.any(\n        flatten(input.output.value),\n        fn(token) { token.1st == policy },\n      )\n    },\n  )\n}\n\n/// Calculate the total quantity of a token in a list of inputs.\n/// ```aiken\n/// let total_quantity = inputs_token_quantity(inputs, token)\n/// ```\npub fn inputs_token_quantity(\n  inputs: List<Input>,\n  token: (PolicyId, AssetName),\n) -> Int {\n  list.map(\n    inputs,\n    fn(input) { quantity_of(input.output.value, token.1st, token.2nd) },\n  )\n    |> list.foldr(0, fn(n, total) { n + total })\n}\n",
      "dependencies": [
        "aiken/collection/list",
        "cardano/address",
        "cardano/assets",
        "cardano/transaction"
      ],
      "source": "vodka",
      "isReExportFile": false
    },
    {
      "key": "vodka:cocktail.vodka_mints",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-vodka/lib/cocktail/vodka_mints.ak",
      "name": "cocktail.vodka_mints",
      "imports": [
        {
          "module": "aiken/collection/list",
          "items": [],
          "line": 1,
          "raw": "use aiken/collection/list",
          "source": "vodka"
        },
        {
          "module": "cardano/assets",
          "items": ["AssetName", "PolicyId", "Value", "flatten"],
          "line": 2,
          "raw": "use cardano/assets.{AssetName, PolicyId, Value, flatten}",
          "source": "vodka"
        }
      ],
      "functions": [
        {
          "name": "check_policy_only_burn",
          "signature": "pub fn check_policy_only_burn(mint: Value, policy: PolicyId) -> Bool {",
          "documentation": "Check if a certain PolicyId is burning only if exists in the minted value.\n```aiken\nlet is_policy_only_burn = check_policy_only_burn(minted_value, policy)\n```",
          "parameters": [
            {
              "name": "mint",
              "type": "Value",
              "optional": false
            },
            {
              "name": "policy",
              "type": "PolicyId",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 8,
          "raw": "pub fn check_policy_only_burn(mint: Value, policy: PolicyId) -> Bool {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn check_policy_only_burn(mint: Value, policy: PolicyId) -> Bool {\n  let mint_value = flatten(mint)\n  list.all(\n    mint_value,\n    fn(x) {\n      if x.1st == policy {\n        x.3rd < 0\n      } else {\n        True\n      }\n    },\n  )\n}",
          "reExportedAs": ["cocktail.check_policy_only_burn"]
        },
        {
          "name": "policy_only_minted_token",
          "signature": "pub fn policy_only_minted_token(pub fn policy_only_minted_token(mint: Value, policy: PolicyId, name: AssetName, quantity: Int, ) {",
          "documentation": "Check if a certain policy has only minted this token.\n```aiken\nlet is_policy_only_minted = check_policy_only_minted(minted_value, policy, name, quantity)\n```",
          "parameters": [],
          "returnType": "Unknown",
          "line": 26,
          "raw": "pub fn policy_only_minted_token(pub fn policy_only_minted_token(mint: Value, policy: PolicyId, name: AssetName, quantity: Int, ) {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn policy_only_minted_token(\n  mint: Value,\n  policy: PolicyId,\n  name: AssetName,\n  quantity: Int,\n) {\n  when flatten(mint) |> list.filter(fn(asset) { asset.1st == policy }) is {\n    [(_, minted_asset_name, minted_quantity)] ->\n      minted_asset_name == name && minted_quantity == quantity\n    _ -> False\n  }\n}",
          "reExportedAs": ["cocktail.policy_only_minted_token"]
        },
        {
          "name": "only_minted_token",
          "signature": "pub fn only_minted_token(pub fn only_minted_token(mint: Value, policy: PolicyId, name: AssetName, quantity: Int, ) {",
          "documentation": "Check if the minted value contains only one distinct asset with particular PolicyId.\n```aiken\nlet is_only_minted_token = only_minted_token(minted_value, policy, name, quantity)\n```",
          "parameters": [],
          "returnType": "Unknown",
          "line": 43,
          "raw": "pub fn only_minted_token(pub fn only_minted_token(mint: Value, policy: PolicyId, name: AssetName, quantity: Int, ) {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn only_minted_token(\n  mint: Value,\n  policy: PolicyId,\n  name: AssetName,\n  quantity: Int,\n) {\n  when flatten(mint) is {\n    [(minted_policy, minted_asset_name, minted_quantity)] ->\n      minted_policy == policy && minted_asset_name == name && minted_quantity == quantity\n    _ -> False\n  }\n}",
          "reExportedAs": ["cocktail.only_minted_token"]
        },
        {
          "name": "token_minted",
          "signature": "pub fn token_minted(pub fn token_minted(mint: Value, policy: PolicyId, name: AssetName, quantity: Int, ) {",
          "documentation": "Check if the minted value contains a token with particular PolicyId, AssetName, and quantity.\n```aiken\nlet is_token_minted = token_minted(minted_value, policy, name, quantity)\n```",
          "parameters": [],
          "returnType": "Unknown",
          "line": 60,
          "raw": "pub fn token_minted(pub fn token_minted(mint: Value, policy: PolicyId, name: AssetName, quantity: Int, ) {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn token_minted(\n  mint: Value,\n  policy: PolicyId,\n  name: AssetName,\n  quantity: Int,\n) {\n  flatten(mint)\n    |> list.any(fn(x) { x.1st == policy && x.2nd == name && x.3rd == quantity })\n}",
          "reExportedAs": ["cocktail.token_minted"]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/collection/list\nuse cardano/assets.{AssetName, PolicyId, Value, flatten}\n\n/// Check if a certain PolicyId is burning only if exists in the minted value.\n/// ```aiken\n/// let is_policy_only_burn = check_policy_only_burn(minted_value, policy)\n/// ```\npub fn check_policy_only_burn(mint: Value, policy: PolicyId) -> Bool {\n  let mint_value = flatten(mint)\n  list.all(\n    mint_value,\n    fn(x) {\n      if x.1st == policy {\n        x.3rd < 0\n      } else {\n        True\n      }\n    },\n  )\n}\n\n/// Check if a certain policy has only minted this token.\n/// ```aiken\n/// let is_policy_only_minted = check_policy_only_minted(minted_value, policy, name, quantity)\n/// ```\npub fn policy_only_minted_token(\n  mint: Value,\n  policy: PolicyId,\n  name: AssetName,\n  quantity: Int,\n) {\n  when flatten(mint) |> list.filter(fn(asset) { asset.1st == policy }) is {\n    [(_, minted_asset_name, minted_quantity)] ->\n      minted_asset_name == name && minted_quantity == quantity\n    _ -> False\n  }\n}\n\n/// Check if the minted value contains only one distinct asset with particular PolicyId.\n/// ```aiken\n/// let is_only_minted_token = only_minted_token(minted_value, policy, name, quantity)\n/// ```\npub fn only_minted_token(\n  mint: Value,\n  policy: PolicyId,\n  name: AssetName,\n  quantity: Int,\n) {\n  when flatten(mint) is {\n    [(minted_policy, minted_asset_name, minted_quantity)] ->\n      minted_policy == policy && minted_asset_name == name && minted_quantity == quantity\n    _ -> False\n  }\n}\n\n/// Check if the minted value contains a token with particular PolicyId, AssetName, and quantity.\n/// ```aiken\n/// let is_token_minted = token_minted(minted_value, policy, name, quantity)\n/// ```\npub fn token_minted(\n  mint: Value,\n  policy: PolicyId,\n  name: AssetName,\n  quantity: Int,\n) {\n  flatten(mint)\n    |> list.any(fn(x) { x.1st == policy && x.2nd == name && x.3rd == quantity })\n}\n",
      "dependencies": ["aiken/collection/list", "cardano/assets"],
      "source": "vodka",
      "isReExportFile": false
    },
    {
      "key": "vodka:cocktail.vodka_outputs",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-vodka/lib/cocktail/vodka_outputs.ak",
      "name": "cocktail.vodka_outputs",
      "imports": [
        {
          "module": "aiken/collection/list",
          "items": [],
          "line": 1,
          "raw": "use aiken/collection/list",
          "source": "vodka"
        },
        {
          "module": "cardano/address",
          "items": ["Address"],
          "line": 2,
          "raw": "use cardano/address.{Address}",
          "source": "vodka"
        },
        {
          "module": "cardano/assets",
          "items": ["AssetName", "PolicyId", "flatten", "quantity_of"],
          "line": 3,
          "raw": "use cardano/assets.{AssetName, PolicyId, flatten, quantity_of}",
          "source": "vodka"
        },
        {
          "module": "cardano/transaction",
          "items": ["InlineDatum", "Output"],
          "line": 4,
          "raw": "use cardano/transaction.{InlineDatum, Output}",
          "source": "vodka"
        }
      ],
      "functions": [
        {
          "name": "output_inline_datum",
          "signature": "pub fn output_inline_datum(output: Output) {",
          "documentation": "Extracts the inline datum from an output.\n```aiken\nexpect inline_datum: MyDatumType = output_inline_datum(output)\n```",
          "parameters": [
            {
              "name": "output",
              "type": "Output",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 10,
          "raw": "pub fn output_inline_datum(output: Output) {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn output_inline_datum(output: Output) {\n  expect InlineDatum(raw_datum) = output.datum\n  raw_datum\n}",
          "reExportedAs": ["cocktail.output_inline_datum"]
        },
        {
          "name": "outputs_at",
          "signature": "pub fn outputs_at(outputs: List<Output>, address: Address) -> List<Output> {",
          "documentation": "Filters outputs by Address.\n```aiken\nlet filtered_outputs = outputs_at(outputs, address)\n```",
          "parameters": [
            {
              "name": "outputs",
              "type": "List<Output>",
              "optional": false
            },
            {
              "name": "address",
              "type": "Address",
              "optional": false
            }
          ],
          "returnType": "List<Output>",
          "line": 19,
          "raw": "pub fn outputs_at(outputs: List<Output>, address: Address) -> List<Output> {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn outputs_at(outputs: List<Output>, address: Address) -> List<Output> {\n  list.filter(outputs, fn(output) { output.address == address })\n}",
          "reExportedAs": ["cocktail.outputs_at"]
        },
        {
          "name": "outputs_with",
          "signature": "pub fn outputs_with(pub fn outputs_with(outputs: List<Output>, policy: PolicyId, name: AssetName, ) -> List<Output> {",
          "documentation": "Filters outputs by PolicyId and AssetName.\n```aiken\nlet filtered_outputs = outputs_with(outputs, policy, name)\n```",
          "parameters": [],
          "returnType": "List<Output>",
          "line": 27,
          "raw": "pub fn outputs_with(pub fn outputs_with(outputs: List<Output>, policy: PolicyId, name: AssetName, ) -> List<Output> {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn outputs_with(\n  outputs: List<Output>,\n  policy: PolicyId,\n  name: AssetName,\n) -> List<Output> {\n  list.filter(\n    outputs,\n    fn(output) { quantity_of(output.value, policy, name) == 1 },\n  )\n}",
          "reExportedAs": ["cocktail.outputs_with"]
        },
        {
          "name": "outputs_with_policy",
          "signature": "pub fn outputs_with_policy(pub fn outputs_with_policy(outputs: List<Output>, policy: PolicyId, ) -> List<Output> {",
          "documentation": "Filters outputs by token policy.\n```aiken\nlet filtered_outputs = outputs_with_policy(outputs, policy)\n```",
          "parameters": [],
          "returnType": "List<Output>",
          "line": 42,
          "raw": "pub fn outputs_with_policy(pub fn outputs_with_policy(outputs: List<Output>, policy: PolicyId, ) -> List<Output> {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn outputs_with_policy(\n  outputs: List<Output>,\n  policy: PolicyId,\n) -> List<Output> {\n  list.filter(\n    outputs,\n    fn(output) {\n      list.any(flatten(output.value), fn(token) { token.1st == policy })\n    },\n  )\n}",
          "reExportedAs": ["cocktail.outputs_with_policy"]
        },
        {
          "name": "outputs_at_with",
          "signature": "pub fn outputs_at_with(pub fn outputs_at_with(outputs: List<Output>, address: Address, policy: PolicyId, name: AssetName, ) -> List<Output> {",
          "documentation": "Filters outputs by Address, PolicyId, and AssetName.\n```aiken\nlet filtered_outputs = outputs_at_with(outputs, address, policy, name)\n```",
          "parameters": [],
          "returnType": "List<Output>",
          "line": 58,
          "raw": "pub fn outputs_at_with(pub fn outputs_at_with(outputs: List<Output>, address: Address, policy: PolicyId, name: AssetName, ) -> List<Output> {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn outputs_at_with(\n  outputs: List<Output>,\n  address: Address,\n  policy: PolicyId,\n  name: AssetName,\n) -> List<Output> {\n  list.filter(\n    outputs,\n    fn(output) {\n      output.address == address && quantity_of(output.value, policy, name) == 1\n    },\n  )\n}",
          "reExportedAs": ["cocktail.outputs_at_with"]
        },
        {
          "name": "outputs_at_with_policy",
          "signature": "pub fn outputs_at_with_policy(pub fn outputs_at_with_policy(outputs: List<Output>, address: Address, policy: PolicyId, ) -> List<Output> {",
          "documentation": "Filters outputs by Address and PolicyId.\n```aiken\nlet filtered_outputs = outputs_at_with_policy(outputs, address, policy)\n```",
          "parameters": [],
          "returnType": "List<Output>",
          "line": 76,
          "raw": "pub fn outputs_at_with_policy(pub fn outputs_at_with_policy(outputs: List<Output>, address: Address, policy: PolicyId, ) -> List<Output> {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn outputs_at_with_policy(\n  outputs: List<Output>,\n  address: Address,\n  policy: PolicyId,\n) -> List<Output> {\n  list.filter(\n    outputs,\n    fn(output) {\n      output.address == address && list.any(\n        flatten(output.value),\n        fn(token) { token.1st == policy },\n      )\n    },\n  )\n}",
          "reExportedAs": ["cocktail.outputs_at_with_policy"]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/collection/list\nuse cardano/address.{Address}\nuse cardano/assets.{AssetName, PolicyId, flatten, quantity_of}\nuse cardano/transaction.{InlineDatum, Output}\n\n/// Extracts the inline datum from an output.\n/// ```aiken\n/// expect inline_datum: MyDatumType = output_inline_datum(output)\n/// ```\npub fn output_inline_datum(output: Output) {\n  expect InlineDatum(raw_datum) = output.datum\n  raw_datum\n}\n\n/// Filters outputs by Address.\n/// ```aiken\n/// let filtered_outputs = outputs_at(outputs, address)\n/// ```\npub fn outputs_at(outputs: List<Output>, address: Address) -> List<Output> {\n  list.filter(outputs, fn(output) { output.address == address })\n}\n\n/// Filters outputs by PolicyId and AssetName.\n/// ```aiken\n/// let filtered_outputs = outputs_with(outputs, policy, name)\n/// ```\npub fn outputs_with(\n  outputs: List<Output>,\n  policy: PolicyId,\n  name: AssetName,\n) -> List<Output> {\n  list.filter(\n    outputs,\n    fn(output) { quantity_of(output.value, policy, name) == 1 },\n  )\n}\n\n/// Filters outputs by token policy.\n/// ```aiken\n/// let filtered_outputs = outputs_with_policy(outputs, policy)\n/// ```\npub fn outputs_with_policy(\n  outputs: List<Output>,\n  policy: PolicyId,\n) -> List<Output> {\n  list.filter(\n    outputs,\n    fn(output) {\n      list.any(flatten(output.value), fn(token) { token.1st == policy })\n    },\n  )\n}\n\n/// Filters outputs by Address, PolicyId, and AssetName.\n/// ```aiken\n/// let filtered_outputs = outputs_at_with(outputs, address, policy, name)\n/// ```\npub fn outputs_at_with(\n  outputs: List<Output>,\n  address: Address,\n  policy: PolicyId,\n  name: AssetName,\n) -> List<Output> {\n  list.filter(\n    outputs,\n    fn(output) {\n      output.address == address && quantity_of(output.value, policy, name) == 1\n    },\n  )\n}\n\n/// Filters outputs by Address and PolicyId.\n/// ```aiken\n/// let filtered_outputs = outputs_at_with_policy(outputs, address, policy)\n/// ```\npub fn outputs_at_with_policy(\n  outputs: List<Output>,\n  address: Address,\n  policy: PolicyId,\n) -> List<Output> {\n  list.filter(\n    outputs,\n    fn(output) {\n      output.address == address && list.any(\n        flatten(output.value),\n        fn(token) { token.1st == policy },\n      )\n    },\n  )\n}\n",
      "dependencies": [
        "aiken/collection/list",
        "cardano/address",
        "cardano/assets",
        "cardano/transaction"
      ],
      "source": "vodka",
      "isReExportFile": false
    },
    {
      "key": "vodka:cocktail.vodka_redeemers",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-vodka/lib/cocktail/vodka_redeemers.ak",
      "name": "cocktail.vodka_redeemers",
      "imports": [
        {
          "module": "aiken/collection/pairs",
          "items": [],
          "line": 1,
          "raw": "use aiken/collection/pairs",
          "source": "vodka"
        },
        {
          "module": "aiken/primitive/bytearray",
          "items": [],
          "line": 2,
          "raw": "use aiken/primitive/bytearray",
          "source": "vodka"
        },
        {
          "module": "cardano/address",
          "items": ["Address", "Script"],
          "line": 3,
          "raw": "use cardano/address.{Address, Script}",
          "source": "vodka"
        }
      ],
      "functions": [
        {
          "name": "redeemer_from",
          "signature": "pub fn redeemer_from(pub fn redeemer_from(redeemers: Pairs<ScriptPurpose, Redeemer>, inputs: List<Input>, output_reference: OutputReference, input_address: Address, ) -> Option<Data> {",
          "documentation": "Obtain the redeemer for a given output reference and address\n```aiken\nexpect Some(redeemer) = redeemer_from(redeemers, inputs, output_reference, input_address)\n```",
          "parameters": [],
          "returnType": "Option<Data>",
          "line": 12,
          "raw": "pub fn redeemer_from(pub fn redeemer_from(redeemers: Pairs<ScriptPurpose, Redeemer>, inputs: List<Input>, output_reference: OutputReference, input_address: Address, ) -> Option<Data> {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn redeemer_from(\n  redeemers: Pairs<ScriptPurpose, Redeemer>,\n  inputs: List<Input>,\n  output_reference: OutputReference,\n  input_address: Address,\n) -> Option<Data> {\n  expect Some(redeemer) = redeemers |> pairs.get_first(Spend(output_reference))\n  expect Some(input) = find_input(inputs, output_reference)\n  if input.output.address == input_address {\n    Some(redeemer)\n  } else {\n    None\n  }\n}",
          "reExportedAs": ["cocktail.redeemer_from"]
        },
        {
          "name": "withdrawal_redeemer",
          "signature": "pub fn withdrawal_redeemer(pub fn withdrawal_redeemer(redeemers: Pairs<ScriptPurpose, Redeemer>, withdrawal_script_hash: ByteArray, ) -> Option<Data> {",
          "documentation": "Obtain the first redeemer for a given withdrawal script hash\n```aiken\nexpect Some(raw_redeemer) = withdrawal_redeemer(redeemers, withdrawal_script_hash)\nexpect my_redeemer: MyRedeemerType = raw_redeemer;\n```",
          "parameters": [],
          "returnType": "Option<Data>",
          "line": 32,
          "raw": "pub fn withdrawal_redeemer(pub fn withdrawal_redeemer(redeemers: Pairs<ScriptPurpose, Redeemer>, withdrawal_script_hash: ByteArray, ) -> Option<Data> {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn withdrawal_redeemer(\n  redeemers: Pairs<ScriptPurpose, Redeemer>,\n  withdrawal_script_hash: ByteArray,\n) -> Option<Data> {\n  redeemers\n    |> pairs.get_first(Withdraw(Script(withdrawal_script_hash)))\n}",
          "reExportedAs": ["cocktail.withdrawal_redeemer"]
        },
        {
          "name": "compare_output_reference",
          "signature": "pub fn compare_output_reference(x, y) {",
          "documentation": "Compare the output reference of two spend transactions",
          "parameters": [
            {
              "name": "x",
              "type": "Unknown",
              "optional": false
            },
            {
              "name": "y",
              "type": "Unknown",
              "optional": false
            }
          ],
          "returnType": "Unknown",
          "line": 41,
          "raw": "pub fn compare_output_reference(x, y) {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn compare_output_reference(x, y) {\n  expect Spend(out_ref_x) = x\n  expect Spend(out_ref_y) = y\n  bytearray.compare(out_ref_x.transaction_id, out_ref_y.transaction_id)\n}",
          "reExportedAs": ["cocktail.compare_output_reference"]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/collection/pairs\nuse aiken/primitive/bytearray\nuse cardano/address.{Address, Script}\nuse cardano/transaction.{\n  Input, OutputReference, Redeemer, ScriptPurpose, Spend, Withdraw, find_input,\n}\n\n/// Obtain the redeemer for a given output reference and address\n/// ```aiken\n/// expect Some(redeemer) = redeemer_from(redeemers, inputs, output_reference, input_address)\n/// ```\npub fn redeemer_from(\n  redeemers: Pairs<ScriptPurpose, Redeemer>,\n  inputs: List<Input>,\n  output_reference: OutputReference,\n  input_address: Address,\n) -> Option<Data> {\n  expect Some(redeemer) = redeemers |> pairs.get_first(Spend(output_reference))\n  expect Some(input) = find_input(inputs, output_reference)\n  if input.output.address == input_address {\n    Some(redeemer)\n  } else {\n    None\n  }\n}\n\n/// Obtain the first redeemer for a given withdrawal script hash\n/// ```aiken\n/// expect Some(raw_redeemer) = withdrawal_redeemer(redeemers, withdrawal_script_hash)\n/// expect my_redeemer: MyRedeemerType = raw_redeemer;\n/// ```\npub fn withdrawal_redeemer(\n  redeemers: Pairs<ScriptPurpose, Redeemer>,\n  withdrawal_script_hash: ByteArray,\n) -> Option<Data> {\n  redeemers\n    |> pairs.get_first(Withdraw(Script(withdrawal_script_hash)))\n}\n\n/// Compare the output reference of two spend transactions\npub fn compare_output_reference(x, y) {\n  expect Spend(out_ref_x) = x\n  expect Spend(out_ref_y) = y\n  bytearray.compare(out_ref_x.transaction_id, out_ref_y.transaction_id)\n}\n",
      "dependencies": [
        "aiken/collection/pairs",
        "aiken/primitive/bytearray",
        "cardano/address"
      ],
      "source": "vodka",
      "isReExportFile": false
    },
    {
      "key": "vodka:cocktail.vodka_validity_range",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-vodka/lib/cocktail/vodka_validity_range.ak",
      "name": "cocktail.vodka_validity_range",
      "imports": [
        {
          "module": "aiken/interval",
          "items": ["Finite", "IntervalBound"],
          "line": 1,
          "raw": "use aiken/interval.{Finite, IntervalBound}",
          "source": "vodka"
        },
        {
          "module": "cardano/transaction",
          "items": ["ValidityRange"],
          "line": 2,
          "raw": "use cardano/transaction.{ValidityRange}",
          "source": "vodka"
        }
      ],
      "functions": [
        {
          "name": "valid_after",
          "signature": "pub fn valid_after(pub fn valid_after(validity_range: ValidityRange, required_timestamp: Int, ) -> Bool {",
          "documentation": "Check if the validity range is after the required timestamp.\n```aiken\nlet is_valid_after = valid_after(transaction.validity_range, required_timestamp)\n```",
          "parameters": [],
          "returnType": "Bool",
          "line": 8,
          "raw": "pub fn valid_after(pub fn valid_after(validity_range: ValidityRange, required_timestamp: Int, ) -> Bool {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn valid_after(\n  validity_range: ValidityRange,\n  required_timestamp: Int,\n) -> Bool {\n  let IntervalBound { bound_type, is_inclusive } = validity_range.lower_bound\n  when (bound_type, is_inclusive) is {\n    (Finite(lower_bound), True) -> lower_bound > required_timestamp\n    (Finite(lower_bound), False) -> lower_bound >= required_timestamp\n    _ -> False\n  }\n}",
          "reExportedAs": ["cocktail.valid_after"]
        },
        {
          "name": "valid_before",
          "signature": "pub fn valid_before(pub fn valid_before(validity_range: ValidityRange, required_timestamp: Int, ) -> Bool {",
          "documentation": "Check if the validity range is before the required timestamp.\n```aiken\nlet is_valid_before = valid_before(transaction.validity_range, required_timestamp)\n```",
          "parameters": [],
          "returnType": "Bool",
          "line": 24,
          "raw": "pub fn valid_before(pub fn valid_before(validity_range: ValidityRange, required_timestamp: Int, ) -> Bool {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn valid_before(\n  validity_range: ValidityRange,\n  required_timestamp: Int,\n) -> Bool {\n  let IntervalBound { bound_type, is_inclusive } = validity_range.upper_bound\n  when (bound_type, is_inclusive) is {\n    (Finite(upper_bound), True) -> upper_bound < required_timestamp\n    (Finite(upper_bound), False) -> upper_bound <= required_timestamp\n    _ -> False\n  }\n}",
          "reExportedAs": ["cocktail.valid_before"]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/interval.{Finite, IntervalBound}\nuse cardano/transaction.{ValidityRange}\n\n/// Check if the validity range is after the required timestamp.\n/// ```aiken\n/// let is_valid_after = valid_after(transaction.validity_range, required_timestamp)\n/// ```\npub fn valid_after(\n  validity_range: ValidityRange,\n  required_timestamp: Int,\n) -> Bool {\n  let IntervalBound { bound_type, is_inclusive } = validity_range.lower_bound\n  when (bound_type, is_inclusive) is {\n    (Finite(lower_bound), True) -> lower_bound > required_timestamp\n    (Finite(lower_bound), False) -> lower_bound >= required_timestamp\n    _ -> False\n  }\n}\n\n/// Check if the validity range is before the required timestamp.\n/// ```aiken\n/// let is_valid_before = valid_before(transaction.validity_range, required_timestamp)\n/// ```\npub fn valid_before(\n  validity_range: ValidityRange,\n  required_timestamp: Int,\n) -> Bool {\n  let IntervalBound { bound_type, is_inclusive } = validity_range.upper_bound\n  when (bound_type, is_inclusive) is {\n    (Finite(upper_bound), True) -> upper_bound < required_timestamp\n    (Finite(upper_bound), False) -> upper_bound <= required_timestamp\n    _ -> False\n  }\n}\n",
      "dependencies": ["aiken/interval", "cardano/transaction"],
      "source": "vodka",
      "isReExportFile": false
    },
    {
      "key": "vodka:cocktail.vodka_value",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-vodka/lib/cocktail/vodka_value.ak",
      "name": "cocktail.vodka_value",
      "imports": [
        {
          "module": "aiken/collection/list",
          "items": [],
          "line": 1,
          "raw": "use aiken/collection/list",
          "source": "vodka"
        },
        {
          "module": "cardano/address",
          "items": ["Address"],
          "line": 2,
          "raw": "use cardano/address.{Address}",
          "source": "vodka"
        },
        {
          "module": "cardano/transaction",
          "items": ["Input", "Output"],
          "line": 6,
          "raw": "use cardano/transaction.{Input, Output}",
          "source": "vodka"
        }
      ],
      "functions": [
        {
          "name": "value_length",
          "signature": "pub fn value_length(value: Value) -> Int {",
          "documentation": "Calulate the length of a value\n```aiken\nlet value_length = value_length(value)\n```",
          "parameters": [
            {
              "name": "value",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 12,
          "raw": "pub fn value_length(value: Value) -> Int {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn value_length(value: Value) -> Int {\n  list.length(flatten(value))\n}",
          "reExportedAs": ["cocktail.value_length"]
        },
        {
          "name": "get_all_value_to",
          "signature": "pub fn get_all_value_to(outputs: List<Output>, address: Address) -> Value {",
          "documentation": "Get the value send to a particular address in a list of outputs\n```aiken\nlet value_to = get_all_value_to(outputs, address)\n```",
          "parameters": [
            {
              "name": "outputs",
              "type": "List<Output>",
              "optional": false
            },
            {
              "name": "address",
              "type": "Address",
              "optional": false
            }
          ],
          "returnType": "Value",
          "line": 20,
          "raw": "pub fn get_all_value_to(outputs: List<Output>, address: Address) -> Value {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn get_all_value_to(outputs: List<Output>, address: Address) -> Value {\n  list.foldr(\n    outputs,\n    zero,\n    fn(output, acc_value) {\n      if output.address == address {\n        merge(acc_value, output.value)\n      } else {\n        acc_value\n      }\n    },\n  )\n}",
          "reExportedAs": ["cocktail.get_all_value_to"]
        },
        {
          "name": "get_all_value_from",
          "signature": "pub fn get_all_value_from(inputs: List<Input>, address: Address) -> Value {",
          "documentation": "Get the value coming from a particular address in a list of inputs\n```aiken\nlet value_from = get_all_value_from(inputs, address)\n```",
          "parameters": [
            {
              "name": "inputs",
              "type": "List<Input>",
              "optional": false
            },
            {
              "name": "address",
              "type": "Address",
              "optional": false
            }
          ],
          "returnType": "Value",
          "line": 38,
          "raw": "pub fn get_all_value_from(inputs: List<Input>, address: Address) -> Value {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn get_all_value_from(inputs: List<Input>, address: Address) -> Value {\n  list.foldr(\n    inputs,\n    zero,\n    fn(input, acc_value) {\n      if input.output.address == address {\n        merge(acc_value, input.output.value)\n      } else {\n        acc_value\n      }\n    },\n  )\n}",
          "reExportedAs": ["cocktail.get_all_value_from"]
        },
        {
          "name": "value_geq",
          "signature": "pub fn value_geq(greater: Value, smaller: Value) -> Bool {",
          "documentation": "Check if the first value provided is greater than or equal to the second value\n```aiken\nlet is_geq = value_geq(supposed_greater, supposed_smaller)\n```",
          "parameters": [
            {
              "name": "greater",
              "type": "Value",
              "optional": false
            },
            {
              "name": "smaller",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 56,
          "raw": "pub fn value_geq(greater: Value, smaller: Value) -> Bool {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn value_geq(greater: Value, smaller: Value) -> Bool {\n  list.all(\n    flatten(smaller),\n    fn(token) { quantity_of(greater, token.1st, token.2nd) >= token.3rd },\n  )\n}",
          "reExportedAs": ["cocktail.value_geq"]
        },
        {
          "name": "value_policy_info",
          "signature": "pub fn value_policy_info(pub fn value_policy_info(value: Value, policy: ByteArray, ) -> Option<(ByteArray, ByteArray, Int)> {",
          "documentation": "Obtain the information (i.e. flattened value) of a policy in a value\n```aiken\nexpect Some((policyId, assetName, quantity)) = value_policy_info(value, policy)\n```",
          "parameters": [],
          "returnType": "Option<(ByteArray, ByteArray, Int)>",
          "line": 67,
          "raw": "pub fn value_policy_info(pub fn value_policy_info(value: Value, policy: ByteArray, ) -> Option<(ByteArray, ByteArray, Int)> {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn value_policy_info(\n  value: Value,\n  policy: ByteArray,\n) -> Option<(ByteArray, ByteArray, Int)> {\n  list.find(flatten(value), fn(t) { t.1st == policy })\n}",
          "reExportedAs": ["cocktail.value_policy_info"]
        },
        {
          "name": "value_tokens",
          "signature": "pub fn value_tokens(value: Value) -> List<(PolicyId, AssetName, Int)> {",
          "documentation": "Obtain the non-lovelace information (i.e. flattened value) of a policy in a value\n```aiken\nlet tokens = value_tokens(value)\n```",
          "parameters": [
            {
              "name": "value",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "List<(PolicyId, AssetName, Int)>",
          "line": 78,
          "raw": "pub fn value_tokens(value: Value) -> List<(PolicyId, AssetName, Int)> {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn value_tokens(value: Value) -> List<(PolicyId, AssetName, Int)> {\n  list.filter(flatten(value), fn(t) { t.1st != \"\" })\n}",
          "reExportedAs": ["cocktail.value_tokens"]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/collection/list\nuse cardano/address.{Address}\nuse cardano/assets.{\n  AssetName, PolicyId, Value, flatten, merge, quantity_of, zero,\n}\nuse cardano/transaction.{Input, Output}\n\n/// Calulate the length of a value\n/// ```aiken\n/// let value_length = value_length(value)\n/// ```\npub fn value_length(value: Value) -> Int {\n  list.length(flatten(value))\n}\n\n/// Get the value send to a particular address in a list of outputs\n/// ```aiken\n/// let value_to = get_all_value_to(outputs, address)\n/// ```\npub fn get_all_value_to(outputs: List<Output>, address: Address) -> Value {\n  list.foldr(\n    outputs,\n    zero,\n    fn(output, acc_value) {\n      if output.address == address {\n        merge(acc_value, output.value)\n      } else {\n        acc_value\n      }\n    },\n  )\n}\n\n/// Get the value coming from a particular address in a list of inputs\n/// ```aiken\n/// let value_from = get_all_value_from(inputs, address)\n/// ```\npub fn get_all_value_from(inputs: List<Input>, address: Address) -> Value {\n  list.foldr(\n    inputs,\n    zero,\n    fn(input, acc_value) {\n      if input.output.address == address {\n        merge(acc_value, input.output.value)\n      } else {\n        acc_value\n      }\n    },\n  )\n}\n\n/// Check if the first value provided is greater than or equal to the second value\n/// ```aiken\n/// let is_geq = value_geq(supposed_greater, supposed_smaller)\n/// ```\npub fn value_geq(greater: Value, smaller: Value) -> Bool {\n  list.all(\n    flatten(smaller),\n    fn(token) { quantity_of(greater, token.1st, token.2nd) >= token.3rd },\n  )\n}\n\n/// Obtain the information (i.e. flattened value) of a policy in a value \n/// ```aiken\n/// expect Some((policyId, assetName, quantity)) = value_policy_info(value, policy)\n/// ```\npub fn value_policy_info(\n  value: Value,\n  policy: ByteArray,\n) -> Option<(ByteArray, ByteArray, Int)> {\n  list.find(flatten(value), fn(t) { t.1st == policy })\n}\n\n/// Obtain the non-lovelace information (i.e. flattened value) of a policy in a value\n/// ```aiken\n/// let tokens = value_tokens(value)\n/// ```\npub fn value_tokens(value: Value) -> List<(PolicyId, AssetName, Int)> {\n  list.filter(flatten(value), fn(t) { t.1st != \"\" })\n}\n",
      "dependencies": [
        "aiken/collection/list",
        "cardano/address",
        "cardano/transaction"
      ],
      "source": "vodka",
      "isReExportFile": false
    },
    {
      "key": "vodka:cocktail",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-vodka/lib/cocktail.ak",
      "name": "cocktail",
      "imports": [
        {
          "module": "cocktail/vodka_address",
          "items": [],
          "line": 18,
          "raw": "use cocktail/vodka_address",
          "source": "vodka"
        },
        {
          "module": "cocktail/vodka_certificate",
          "items": [],
          "line": 19,
          "raw": "use cocktail/vodka_certificate",
          "source": "vodka"
        },
        {
          "module": "cocktail/vodka_converter",
          "items": [],
          "line": 20,
          "raw": "use cocktail/vodka_converter",
          "source": "vodka"
        },
        {
          "module": "cocktail/vodka_extra_signatories",
          "items": [],
          "line": 21,
          "raw": "use cocktail/vodka_extra_signatories",
          "source": "vodka"
        },
        {
          "module": "cocktail/vodka_inputs",
          "items": [],
          "line": 22,
          "raw": "use cocktail/vodka_inputs",
          "source": "vodka"
        },
        {
          "module": "cocktail/vodka_mints",
          "items": [],
          "line": 23,
          "raw": "use cocktail/vodka_mints",
          "source": "vodka"
        },
        {
          "module": "cocktail/vodka_outputs",
          "items": [],
          "line": 24,
          "raw": "use cocktail/vodka_outputs",
          "source": "vodka"
        },
        {
          "module": "cocktail/vodka_redeemers",
          "items": [],
          "line": 25,
          "raw": "use cocktail/vodka_redeemers",
          "source": "vodka"
        },
        {
          "module": "cocktail/vodka_validity_range",
          "items": [],
          "line": 26,
          "raw": "use cocktail/vodka_validity_range",
          "source": "vodka"
        },
        {
          "module": "cocktail/vodka_value",
          "items": [],
          "line": 27,
          "raw": "use cocktail/vodka_value",
          "source": "vodka"
        }
      ],
      "functions": [],
      "types": [],
      "constants": [
        {
          "name": "compare_script_address",
          "type": "Unknown",
          "value": "vodka_address.compare_script_address",
          "line": 32,
          "raw": "pub const compare_script_address = vodka_address.compare_script_address",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["compare_script_address"]
        },
        {
          "name": "compare_address",
          "type": "Unknown",
          "value": "vodka_address.compare_address",
          "line": 35,
          "raw": "pub const compare_address = vodka_address.compare_address",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["compare_address"]
        },
        {
          "name": "address_payment_key",
          "type": "Unknown",
          "value": "vodka_address.address_payment_key",
          "line": 38,
          "raw": "pub const address_payment_key = vodka_address.address_payment_key",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["address_payment_key"]
        },
        {
          "name": "address_pub_key",
          "type": "Unknown",
          "value": "vodka_address.address_pub_key",
          "line": 41,
          "raw": "pub const address_pub_key = vodka_address.address_pub_key",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["address_pub_key"]
        },
        {
          "name": "address_script_hash",
          "type": "Unknown",
          "value": "vodka_address.address_script_hash",
          "line": 44,
          "raw": "pub const address_script_hash = vodka_address.address_script_hash",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["address_script_hash"]
        },
        {
          "name": "convert_int_to_bytes",
          "type": "Unknown",
          "value": "vodka_converter.convert_int_to_bytes",
          "line": 49,
          "raw": "pub const convert_int_to_bytes = vodka_converter.convert_int_to_bytes",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["convert_int_to_bytes"]
        },
        {
          "name": "get_number_digit",
          "type": "Unknown",
          "value": "vodka_converter.get_number_digit",
          "line": 52,
          "raw": "pub const get_number_digit = vodka_converter.get_number_digit",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["get_number_digit"]
        },
        {
          "name": "key_signed",
          "type": "Unknown",
          "value": "vodka_extra_signatories.key_signed",
          "line": 57,
          "raw": "pub const key_signed = vodka_extra_signatories.key_signed",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["key_signed"]
        },
        {
          "name": "one_of_keys_signed",
          "type": "Unknown",
          "value": "vodka_extra_signatories.one_of_keys_signed",
          "line": 60,
          "raw": "pub const one_of_keys_signed = vodka_extra_signatories.one_of_keys_signed",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["one_of_keys_signed"]
        },
        {
          "name": "all_key_signed",
          "type": "Unknown",
          "value": "vodka_extra_signatories.all_key_signed",
          "line": 63,
          "raw": "pub const all_key_signed = vodka_extra_signatories.all_key_signed",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["all_key_signed"]
        },
        {
          "name": "input_inline_datum",
          "type": "Unknown",
          "value": "vodka_inputs.input_inline_datum",
          "line": 68,
          "raw": "pub const input_inline_datum = vodka_inputs.input_inline_datum",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["input_inline_datum"]
        },
        {
          "name": "only_input_datum_with",
          "type": "Unknown",
          "value": "vodka_inputs.only_input_datum_with",
          "line": 71,
          "raw": "pub const only_input_datum_with = vodka_inputs.only_input_datum_with",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["only_input_datum_with"]
        },
        {
          "name": "inputs_at",
          "type": "Unknown",
          "value": "vodka_inputs.inputs_at",
          "line": 74,
          "raw": "pub const inputs_at = vodka_inputs.inputs_at",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["inputs_at"]
        },
        {
          "name": "inputs_with",
          "type": "Unknown",
          "value": "vodka_inputs.inputs_with",
          "line": 77,
          "raw": "pub const inputs_with = vodka_inputs.inputs_with",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["inputs_with"]
        },
        {
          "name": "inputs_with_policy",
          "type": "Unknown",
          "value": "vodka_inputs.inputs_with_policy",
          "line": 80,
          "raw": "pub const inputs_with_policy = vodka_inputs.inputs_with_policy",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["inputs_with_policy"]
        },
        {
          "name": "inputs_at_with",
          "type": "Unknown",
          "value": "vodka_inputs.inputs_at_with",
          "line": 83,
          "raw": "pub const inputs_at_with = vodka_inputs.inputs_at_with",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["inputs_at_with"]
        },
        {
          "name": "inputs_at_with_policy",
          "type": "Unknown",
          "value": "vodka_inputs.inputs_at_with_policy",
          "line": 86,
          "raw": "pub const inputs_at_with_policy = vodka_inputs.inputs_at_with_policy",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["inputs_at_with_policy"]
        },
        {
          "name": "inputs_token_quantity",
          "type": "Unknown",
          "value": "vodka_inputs.inputs_token_quantity",
          "line": 89,
          "raw": "pub const inputs_token_quantity = vodka_inputs.inputs_token_quantity",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["inputs_token_quantity"]
        },
        {
          "name": "check_policy_only_burn",
          "type": "Unknown",
          "value": "vodka_mints.check_policy_only_burn",
          "line": 94,
          "raw": "pub const check_policy_only_burn = vodka_mints.check_policy_only_burn",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["check_policy_only_burn"]
        },
        {
          "name": "only_minted_token",
          "type": "Unknown",
          "value": "vodka_mints.only_minted_token",
          "line": 97,
          "raw": "pub const only_minted_token = vodka_mints.only_minted_token",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["only_minted_token"]
        },
        {
          "name": "policy_only_minted_token",
          "type": "Unknown",
          "value": "vodka_mints.policy_only_minted_token",
          "line": 100,
          "raw": "pub const policy_only_minted_token = vodka_mints.policy_only_minted_token",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["policy_only_minted_token"]
        },
        {
          "name": "token_minted",
          "type": "Unknown",
          "value": "vodka_mints.token_minted",
          "line": 103,
          "raw": "pub const token_minted = vodka_mints.token_minted",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["token_minted"]
        },
        {
          "name": "output_inline_datum",
          "type": "Unknown",
          "value": "vodka_outputs.output_inline_datum",
          "line": 108,
          "raw": "pub const output_inline_datum = vodka_outputs.output_inline_datum",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["output_inline_datum"]
        },
        {
          "name": "outputs_at",
          "type": "Unknown",
          "value": "vodka_outputs.outputs_at",
          "line": 111,
          "raw": "pub const outputs_at = vodka_outputs.outputs_at",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["outputs_at"]
        },
        {
          "name": "outputs_with",
          "type": "Unknown",
          "value": "vodka_outputs.outputs_with",
          "line": 114,
          "raw": "pub const outputs_with = vodka_outputs.outputs_with",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["outputs_with"]
        },
        {
          "name": "outputs_with_policy",
          "type": "Unknown",
          "value": "vodka_outputs.outputs_with_policy",
          "line": 117,
          "raw": "pub const outputs_with_policy = vodka_outputs.outputs_with_policy",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["outputs_with_policy"]
        },
        {
          "name": "outputs_at_with",
          "type": "Unknown",
          "value": "vodka_outputs.outputs_at_with",
          "line": 120,
          "raw": "pub const outputs_at_with = vodka_outputs.outputs_at_with",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["outputs_at_with"]
        },
        {
          "name": "outputs_at_with_policy",
          "type": "Unknown",
          "value": "vodka_outputs.outputs_at_with_policy",
          "line": 123,
          "raw": "pub const outputs_at_with_policy = vodka_outputs.outputs_at_with_policy",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["outputs_at_with_policy"]
        },
        {
          "name": "redeemer_from",
          "type": "Unknown",
          "value": "vodka_redeemers.redeemer_from",
          "line": 128,
          "raw": "pub const redeemer_from = vodka_redeemers.redeemer_from",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["redeemer_from"]
        },
        {
          "name": "withdrawal_redeemer",
          "type": "Unknown",
          "value": "vodka_redeemers.withdrawal_redeemer",
          "line": 131,
          "raw": "pub const withdrawal_redeemer = vodka_redeemers.withdrawal_redeemer",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["withdrawal_redeemer"]
        },
        {
          "name": "compare_output_reference",
          "type": "Unknown",
          "value": "vodka_redeemers.compare_output_reference",
          "line": 134,
          "raw": "pub const compare_output_reference = vodka_redeemers.compare_output_reference",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["compare_output_reference"]
        },
        {
          "name": "valid_after",
          "type": "Unknown",
          "value": "vodka_validity_range.valid_after",
          "line": 139,
          "raw": "pub const valid_after = vodka_validity_range.valid_after",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["valid_after"]
        },
        {
          "name": "valid_before",
          "type": "Unknown",
          "value": "vodka_validity_range.valid_before",
          "line": 142,
          "raw": "pub const valid_before = vodka_validity_range.valid_before",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["valid_before"]
        },
        {
          "name": "value_length",
          "type": "Unknown",
          "value": "vodka_value.value_length",
          "line": 147,
          "raw": "pub const value_length = vodka_value.value_length",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["value_length"]
        },
        {
          "name": "get_all_value_to",
          "type": "Unknown",
          "value": "vodka_value.get_all_value_to",
          "line": 150,
          "raw": "pub const get_all_value_to = vodka_value.get_all_value_to",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["get_all_value_to"]
        },
        {
          "name": "get_all_value_from",
          "type": "Unknown",
          "value": "vodka_value.get_all_value_from",
          "line": 153,
          "raw": "pub const get_all_value_from = vodka_value.get_all_value_from",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["get_all_value_from"]
        },
        {
          "name": "value_geq",
          "type": "Unknown",
          "value": "vodka_value.value_geq",
          "line": 156,
          "raw": "pub const value_geq = vodka_value.value_geq",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["value_geq"]
        },
        {
          "name": "value_policy_info",
          "type": "Unknown",
          "value": "vodka_value.value_policy_info",
          "line": 159,
          "raw": "pub const value_policy_info = vodka_value.value_policy_info",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["value_policy_info"]
        },
        {
          "name": "value_tokens",
          "type": "Unknown",
          "value": "vodka_value.value_tokens",
          "line": 162,
          "raw": "pub const value_tokens = vodka_value.value_tokens",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["value_tokens"]
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "//// Vodka cocktail provides utility functions to build Aiken onchain code\n////\n//// All onchain utility functions are grouped with a naming convention of `vodka_<type>`, \n//// and all can be imported directly with `use cocktail`\n//// \n//// ### Cardano data types\n//// - `Address` - [`use vodka_address`](./cocktail/vodka_address.html) \n//// - `Value` - [`use vodka_value`](./cocktail/vodka_value.html)\n////\n//// ### Transaction types \n//// - `extra_signatories` - [Documentation](./cocktail/vodka_extra_signatories.html)\n//// - `inputs` - [Documentation](./cocktail/vodka_inputs.html)\n//// - `outputs` - [Documentation](./cocktail/vodka_outputs.html)\n//// - `mints` - [Documentation](./cocktail/vodka_mints.html)\n//// - `validity_range` - [Documentation](./cocktail/vodka_validity_range.html)\n//// - `Redeemers` - [Documentation](./cocktail/vodka_redeemers.html)\n\nuse cocktail/vodka_address\nuse cocktail/vodka_certificate\nuse cocktail/vodka_converter\nuse cocktail/vodka_extra_signatories\nuse cocktail/vodka_inputs\nuse cocktail/vodka_mints\nuse cocktail/vodka_outputs\nuse cocktail/vodka_redeemers\nuse cocktail/vodka_validity_range\nuse cocktail/vodka_value\n\n// Address\n\n/// Documentation please refer to [`vodka_address`](./cocktail/vodka_address.html)\npub const compare_script_address = vodka_address.compare_script_address\n\n/// Documentation please refer to [`vodka_address`](./cocktail/vodka_address.html)\npub const compare_address = vodka_address.compare_address\n\n/// Documentation please refer to [`vodka_address`](./cocktail/vodka_address.html)\npub const address_payment_key = vodka_address.address_payment_key\n\n/// Documentation please refer to [`vodka_address`](./cocktail/vodka_address.html)\npub const address_pub_key = vodka_address.address_pub_key\n\n/// Documentation please refer to [`vodka_address`](./cocktail/vodka_address.html)\npub const address_script_hash = vodka_address.address_script_hash\n\n// Converter\n\n/// Documentation please refer to [`vodka_converter`](./cocktail/vodka_converter.html)\npub const convert_int_to_bytes = vodka_converter.convert_int_to_bytes\n\n/// Documentation please refer to [`vodka_converter`](./cocktail/vodka_converter.html)\npub const get_number_digit = vodka_converter.get_number_digit\n\n// Extra Signatories\n\n/// Documentation please refer to [`vodka_extra_signatories`](./cocktail/vodka_extra_signatories.html)\npub const key_signed = vodka_extra_signatories.key_signed\n\n/// Documentation please refer to [`vodka_extra_signatories`](./cocktail/vodka_extra_signatories.html)\npub const one_of_keys_signed = vodka_extra_signatories.one_of_keys_signed\n\n/// Documentation please refer to [`vodka_extra_signatories`](./cocktail/vodka_extra_signatories.html)\npub const all_key_signed = vodka_extra_signatories.all_key_signed\n\n// Inputs\n\n/// Documentation please refer to [`vodka_inputs`](./cocktail/vodka_inputs.html)\npub const input_inline_datum = vodka_inputs.input_inline_datum\n\n/// Documentation please refer to [`vodka_inputs`](./cocktail/vodka_inputs.html)\npub const only_input_datum_with = vodka_inputs.only_input_datum_with\n\n/// Documentation please refer to [`vodka_inputs`](./cocktail/vodka_inputs.html)\npub const inputs_at = vodka_inputs.inputs_at\n\n/// Documentation please refer to [`vodka_inputs`](./cocktail/vodka_inputs.html)\npub const inputs_with = vodka_inputs.inputs_with\n\n/// Documentation please refer to [`vodka_inputs`](./cocktail/vodka_inputs.html)\npub const inputs_with_policy = vodka_inputs.inputs_with_policy\n\n/// Documentation please refer to [`vodka_inputs`](./cocktail/vodka_inputs.html)\npub const inputs_at_with = vodka_inputs.inputs_at_with\n\n/// Documentation please refer to [`vodka_inputs`](./cocktail/vodka_inputs.html)\npub const inputs_at_with_policy = vodka_inputs.inputs_at_with_policy\n\n/// Documentation please refer to [`vodka_inputs`](./cocktail/vodka_inputs.html)\npub const inputs_token_quantity = vodka_inputs.inputs_token_quantity\n\n// Mints\n\n/// Documentation please refer to [`vodka_mints`](./cocktail/vodka_mints.html)\npub const check_policy_only_burn = vodka_mints.check_policy_only_burn\n\n/// Documentation please refer to [`vodka_mints`](./cocktail/vodka_mints.html)\npub const only_minted_token = vodka_mints.only_minted_token\n\n/// Documentation please refer to [`vodka_mints`](./cocktail/vodka_mints.html)\npub const policy_only_minted_token = vodka_mints.policy_only_minted_token\n\n/// Documentation please refer to [`vodka_mints`](./cocktail/vodka_mints.html)\npub const token_minted = vodka_mints.token_minted\n\n// Outputs\n\n/// Documentation please refer to [`vodka_outputs`](./cocktail/vodka_outputs.html)\npub const output_inline_datum = vodka_outputs.output_inline_datum\n\n/// Documentation please refer to [`vodka_outputs`](./cocktail/vodka_outputs.html)\npub const outputs_at = vodka_outputs.outputs_at\n\n/// Documentation please refer to [`vodka_outputs`](./cocktail/vodka_outputs.html)\npub const outputs_with = vodka_outputs.outputs_with\n\n/// Documentation please refer to [`vodka_outputs`](./cocktail/vodka_outputs.html)\npub const outputs_with_policy = vodka_outputs.outputs_with_policy\n\n/// Documentation please refer to [`vodka_outputs`](./cocktail/vodka_outputs.html)\npub const outputs_at_with = vodka_outputs.outputs_at_with\n\n/// Documentation please refer to [`vodka_outputs`](./cocktail/vodka_outputs.html)\npub const outputs_at_with_policy = vodka_outputs.outputs_at_with_policy\n\n// Redeemers\n\n/// Documentation please refer to [`vodka_redeemers`](./cocktail/vodka_redeemers.html)\npub const redeemer_from = vodka_redeemers.redeemer_from\n\n/// Documentation please refer to [`vodka_redeemers`](./cocktail/vodka_redeemers.html)\npub const withdrawal_redeemer = vodka_redeemers.withdrawal_redeemer\n\n/// Documentation please refer to [`vodka_redeemers`](./cocktail/vodka_redeemers.html)\npub const compare_output_reference = vodka_redeemers.compare_output_reference\n\n// Validity Range\n\n/// Documentation please refer to [`vodka_validity_range`](./cocktail/vodka_validity_range.html)\npub const valid_after = vodka_validity_range.valid_after\n\n/// Documentation please refer to [`vodka_validity_range`](./cocktail/vodka_validity_range.html)\npub const valid_before = vodka_validity_range.valid_before\n\n// Value\n\n/// Documentation please refer to [`vodka_value`](./cocktail/vodka_value.html)\npub const value_length = vodka_value.value_length\n\n/// Documentation please refer to [`vodka_value`](./cocktail/vodka_value.html)\npub const get_all_value_to = vodka_value.get_all_value_to\n\n/// Documentation please refer to [`vodka_value`](./cocktail/vodka_value.html)\npub const get_all_value_from = vodka_value.get_all_value_from\n\n/// Documentation please refer to [`vodka_value`](./cocktail/vodka_value.html)\npub const value_geq = vodka_value.value_geq\n\n/// Documentation please refer to [`vodka_value`](./cocktail/vodka_value.html)\npub const value_policy_info = vodka_value.value_policy_info\n\n/// Documentation please refer to [`vodka_value`](./cocktail/vodka_value.html)\npub const value_tokens = vodka_value.value_tokens\n\n// Certificate\n\n/// Documentation please refer to [`vodka_certificate`](./cocktail/vodka_certificate.html)\npub const register_stake_certificate =\n  vodka_certificate.register_stake_certificate\n\n/// Documentation please refer to [`vodka_certificate`](./cocktail/vodka_certificate.html)\npub const unregister_stake_certificate =\n  vodka_certificate.unregister_stake_certificate\n\n/// Documentation please refer to [`vodka_certificate`](./cocktail/vodka_certificate.html)\npub const register_drep_certificate =\n  vodka_certificate.register_drep_certificate\n\n/// Documentation please refer to [`vodka_certificate`](./cocktail/vodka_certificate.html)\npub const unregister_drep_certificate =\n  vodka_certificate.unregister_drep_certificate\n\n/// Documentation please refer to [`vodka_certificate`](./cocktail/vodka_certificate.html)\npub const delegate_stake_certificate =\n  vodka_certificate.delegate_stake_certificate\n\n/// Documentation please refer to [`vodka_certificate`](./cocktail/vodka_certificate.html)\npub const delegate_vote_certificate =\n  vodka_certificate.delegate_vote_certificate\n\n/// Documentation please refer to [`vodka_certificate`](./cocktail/vodka_certificate.html)\npub const delegate_stake_and_vote_certificate =\n  vodka_certificate.delegate_stake_and_vote_certificate\n",
      "dependencies": [
        "cocktail/vodka_address",
        "cocktail/vodka_certificate",
        "cocktail/vodka_converter",
        "cocktail/vodka_extra_signatories",
        "cocktail/vodka_inputs",
        "cocktail/vodka_mints",
        "cocktail/vodka_outputs",
        "cocktail/vodka_redeemers",
        "cocktail/vodka_validity_range",
        "cocktail/vodka_value"
      ],
      "source": "vodka",
      "isReExportFile": true
    },
    {
      "key": "vodka:mocktail.virgin_address",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-vodka/lib/mocktail/virgin_address.ak",
      "name": "mocktail.virgin_address",
      "imports": [],
      "functions": [
        {
          "name": "mock_verfication_key_credential",
          "signature": "pub fn mock_verfication_key_credential(variation: Int) -> Credential {",
          "documentation": "Mock a pub key credential\n`variation` same the same index as `mock_pub_key_hash`",
          "parameters": [
            {
              "name": "variation",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Credential",
          "line": 11,
          "raw": "pub fn mock_verfication_key_credential(variation: Int) -> Credential {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn mock_verfication_key_credential(variation: Int) -> Credential {\n  VerificationKey(mock_pub_key_hash(variation))\n}"
        },
        {
          "name": "mock_pub_key_address",
          "signature": "pub fn mock_pub_key_address(pub fn mock_pub_key_address(variation: Int, stake_credential: Option<StakeCredential>, ) -> Address {",
          "documentation": "Mock a pub key address\n`variation` same the same index as `mock_pub_key_hash`\n`stake_credential` is optional",
          "parameters": [],
          "returnType": "Address",
          "line": 18,
          "raw": "pub fn mock_pub_key_address(pub fn mock_pub_key_address(variation: Int, stake_credential: Option<StakeCredential>, ) -> Address {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn mock_pub_key_address(\n  variation: Int,\n  stake_credential: Option<StakeCredential>,\n) -> Address {\n  Address {\n    payment_credential: mock_verfication_key_credential(variation),\n    stake_credential,\n  }\n}",
          "reExportedAs": ["mocktail.mock_pub_key_address"]
        },
        {
          "name": "mock_script_credential",
          "signature": "pub fn mock_script_credential(variation: Int) -> Credential {",
          "documentation": "Mock a script credential\n`variation` same the same index as `mock_script_hash`",
          "parameters": [
            {
              "name": "variation",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Credential",
          "line": 30,
          "raw": "pub fn mock_script_credential(variation: Int) -> Credential {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn mock_script_credential(variation: Int) -> Credential {\n  Script(mock_script_hash(variation))\n}",
          "reExportedAs": ["mocktail.mock_script_credential"]
        },
        {
          "name": "mock_script_address",
          "signature": "pub fn mock_script_address(pub fn mock_script_address(variation: Int, stake_credential: Option<StakeCredential>, ) -> Address {",
          "documentation": "Mock a script address\n`variation` same the same index as `mock_script_hash`\n`stake_credential` is optional",
          "parameters": [],
          "returnType": "Address",
          "line": 37,
          "raw": "pub fn mock_script_address(pub fn mock_script_address(variation: Int, stake_credential: Option<StakeCredential>, ) -> Address {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn mock_script_address(\n  variation: Int,\n  stake_credential: Option<StakeCredential>,\n) -> Address {\n  Address {\n    payment_credential: mock_script_credential(variation),\n    stake_credential,\n  }\n}",
          "reExportedAs": ["mocktail.mock_script_address"]
        },
        {
          "name": "mock_pub_key_stake_cred",
          "signature": "pub fn mock_pub_key_stake_cred(variation: Int) -> StakeCredential {",
          "documentation": "Mock a pub key stake credential\n`variation` same the same index as `mock_stake_key_hash`",
          "parameters": [
            {
              "name": "variation",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "StakeCredential",
          "line": 49,
          "raw": "pub fn mock_pub_key_stake_cred(variation: Int) -> StakeCredential {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn mock_pub_key_stake_cred(variation: Int) -> StakeCredential {\n  Inline(VerificationKey(mock_stake_key_hash(variation)))\n}"
        },
        {
          "name": "mock_script_stake_cred",
          "signature": "pub fn mock_script_stake_cred(variation: Int) -> StakeCredential {",
          "documentation": "Mock a script stake credential\n`variation` same the same index as `mock_script_stake_key_hash`",
          "parameters": [
            {
              "name": "variation",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "StakeCredential",
          "line": 55,
          "raw": "pub fn mock_script_stake_cred(variation: Int) -> StakeCredential {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn mock_script_stake_cred(variation: Int) -> StakeCredential {\n  Inline(Script(mock_script_stake_key_hash(variation)))\n}"
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use cardano/address.{\n  Address, Credential, Inline, Script, StakeCredential, VerificationKey,\n}\nuse mocktail/virgin_key_hash.{\n  mock_pub_key_hash, mock_script_hash, mock_script_stake_key_hash,\n  mock_stake_key_hash,\n}\n\n/// Mock a pub key credential\n/// `variation` same the same index as `mock_pub_key_hash`\npub fn mock_verfication_key_credential(variation: Int) -> Credential {\n  VerificationKey(mock_pub_key_hash(variation))\n}\n\n/// Mock a pub key address\n/// `variation` same the same index as `mock_pub_key_hash`\n/// `stake_credential` is optional\npub fn mock_pub_key_address(\n  variation: Int,\n  stake_credential: Option<StakeCredential>,\n) -> Address {\n  Address {\n    payment_credential: mock_verfication_key_credential(variation),\n    stake_credential,\n  }\n}\n\n/// Mock a script credential\n/// `variation` same the same index as `mock_script_hash`\npub fn mock_script_credential(variation: Int) -> Credential {\n  Script(mock_script_hash(variation))\n}\n\n/// Mock a script address\n/// `variation` same the same index as `mock_script_hash`\n/// `stake_credential` is optional\npub fn mock_script_address(\n  variation: Int,\n  stake_credential: Option<StakeCredential>,\n) -> Address {\n  Address {\n    payment_credential: mock_script_credential(variation),\n    stake_credential,\n  }\n}\n\n/// Mock a pub key stake credential\n/// `variation` same the same index as `mock_stake_key_hash`\npub fn mock_pub_key_stake_cred(variation: Int) -> StakeCredential {\n  Inline(VerificationKey(mock_stake_key_hash(variation)))\n}\n\n/// Mock a script stake credential\n/// `variation` same the same index as `mock_script_stake_key_hash`\npub fn mock_script_stake_cred(variation: Int) -> StakeCredential {\n  Inline(Script(mock_script_stake_key_hash(variation)))\n}\n",
      "dependencies": [],
      "source": "vodka",
      "isReExportFile": false
    },
    {
      "key": "vodka:mocktail.virgin_key_hash",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-vodka/lib/mocktail/virgin_key_hash.ak",
      "name": "mocktail.virgin_key_hash",
      "imports": [
        {
          "module": "aiken/cbor",
          "items": ["serialise"],
          "line": 1,
          "raw": "use aiken/cbor.{serialise}",
          "source": "vodka"
        },
        {
          "module": "aiken/crypto",
          "items": ["ScriptHash", "VerificationKeyHash", "blake2b_224"],
          "line": 2,
          "raw": "use aiken/crypto.{ScriptHash, VerificationKeyHash, blake2b_224}",
          "source": "vodka"
        },
        {
          "module": "aiken/primitive/bytearray",
          "items": ["concat"],
          "line": 3,
          "raw": "use aiken/primitive/bytearray.{concat}",
          "source": "vodka"
        },
        {
          "module": "cardano/assets",
          "items": ["PolicyId"],
          "line": 4,
          "raw": "use cardano/assets.{PolicyId}",
          "source": "vodka"
        }
      ],
      "functions": [
        {
          "name": "mock_key_hash",
          "signature": "pub fn mock_key_hash(variation: Int) -> ByteArray {",
          "documentation": "Mock a key in hexadecimal format",
          "parameters": [
            {
              "name": "variation",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 10,
          "raw": "pub fn mock_key_hash(variation: Int) -> ByteArray {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn mock_key_hash(variation: Int) -> ByteArray {\n  serialise(variation) |> concat(root_hash) |> blake2b_224()\n}",
          "reExportedAs": ["mocktail.mock_key_hash"]
        },
        {
          "name": "mock_policy_id",
          "signature": "pub fn mock_policy_id(variation: Int) -> PolicyId {",
          "documentation": "Mock a PolicyID\nThe variation is used to distinguish between different PolicyIDs\nUse this but not other `mock_key_hash` functions to avoid hash collision",
          "parameters": [
            {
              "name": "variation",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "PolicyId",
          "line": 17,
          "raw": "pub fn mock_policy_id(variation: Int) -> PolicyId {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn mock_policy_id(variation: Int) -> PolicyId {\n  mock_key_hash(variation)\n}",
          "reExportedAs": ["mocktail.mock_policy_id"]
        },
        {
          "name": "mock_pub_key_hash",
          "signature": "pub fn mock_pub_key_hash(variation: Int) -> VerificationKeyHash {",
          "documentation": "Mock a public key hash\nThe variation is used to distinguish between different public keys\nUse this but not other `mock_key_hash` functions to avoid hash collision",
          "parameters": [
            {
              "name": "variation",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "VerificationKeyHash",
          "line": 24,
          "raw": "pub fn mock_pub_key_hash(variation: Int) -> VerificationKeyHash {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn mock_pub_key_hash(variation: Int) -> VerificationKeyHash {\n  mock_key_hash(variation + 1000)\n}",
          "reExportedAs": ["mocktail.mock_pub_key_hash"]
        },
        {
          "name": "mock_script_hash",
          "signature": "pub fn mock_script_hash(variation: Int) -> ScriptHash {",
          "documentation": "Mock a script hash\nThe variation is used to distinguish between different scripts\nUse this but not other `mock_key_hash` functions to avoid hash collision",
          "parameters": [
            {
              "name": "variation",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "ScriptHash",
          "line": 31,
          "raw": "pub fn mock_script_hash(variation: Int) -> ScriptHash {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn mock_script_hash(variation: Int) -> ScriptHash {\n  mock_key_hash(variation + 2000)\n}",
          "reExportedAs": ["mocktail.mock_script_hash"]
        },
        {
          "name": "mock_stake_key_hash",
          "signature": "pub fn mock_stake_key_hash(variation: Int) -> VerificationKeyHash {",
          "documentation": "Mock a stake key hash\nThe variation is used to distinguish between different stake keys\nUse this but not other `mock_key_hash` functions to avoid hash collision",
          "parameters": [
            {
              "name": "variation",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "VerificationKeyHash",
          "line": 38,
          "raw": "pub fn mock_stake_key_hash(variation: Int) -> VerificationKeyHash {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn mock_stake_key_hash(variation: Int) -> VerificationKeyHash {\n  mock_key_hash(variation + 3000)\n}",
          "reExportedAs": ["mocktail.mock_stake_key_hash"]
        },
        {
          "name": "mock_script_stake_key_hash",
          "signature": "pub fn mock_script_stake_key_hash(variation: Int) -> ScriptHash {",
          "documentation": "Mock a script stake key hash\nThe variation is used to distinguish between different scripts\nUse this but not other `mock_key_hash` functions to avoid hash collision",
          "parameters": [
            {
              "name": "variation",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "ScriptHash",
          "line": 45,
          "raw": "pub fn mock_script_stake_key_hash(variation: Int) -> ScriptHash {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn mock_script_stake_key_hash(variation: Int) -> ScriptHash {\n  mock_key_hash(variation + 4000)\n}"
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/cbor.{serialise}\nuse aiken/crypto.{ScriptHash, VerificationKeyHash, blake2b_224}\nuse aiken/primitive/bytearray.{concat}\nuse cardano/assets.{PolicyId}\n\npub const root_hash =\n  #\"a2c20c77887ace1cd986193e4e75babd8993cfd56995cd5cfce609c2\"\n\n/// Mock a key in hexadecimal format\npub fn mock_key_hash(variation: Int) -> ByteArray {\n  serialise(variation) |> concat(root_hash) |> blake2b_224()\n}\n\n/// Mock a PolicyID\n/// The variation is used to distinguish between different PolicyIDs\n/// Use this but not other `mock_key_hash` functions to avoid hash collision\npub fn mock_policy_id(variation: Int) -> PolicyId {\n  mock_key_hash(variation)\n}\n\n/// Mock a public key hash\n/// The variation is used to distinguish between different public keys\n/// Use this but not other `mock_key_hash` functions to avoid hash collision\npub fn mock_pub_key_hash(variation: Int) -> VerificationKeyHash {\n  mock_key_hash(variation + 1000)\n}\n\n/// Mock a script hash\n/// The variation is used to distinguish between different scripts\n/// Use this but not other `mock_key_hash` functions to avoid hash collision\npub fn mock_script_hash(variation: Int) -> ScriptHash {\n  mock_key_hash(variation + 2000)\n}\n\n/// Mock a stake key hash\n/// The variation is used to distinguish between different stake keys\n/// Use this but not other `mock_key_hash` functions to avoid hash collision\npub fn mock_stake_key_hash(variation: Int) -> VerificationKeyHash {\n  mock_key_hash(variation + 3000)\n}\n\n/// Mock a script stake key hash\n/// The variation is used to distinguish between different scripts\n/// Use this but not other `mock_key_hash` functions to avoid hash collision\npub fn mock_script_stake_key_hash(variation: Int) -> ScriptHash {\n  mock_key_hash(variation + 4000)\n}\n",
      "dependencies": [
        "aiken/cbor",
        "aiken/crypto",
        "aiken/primitive/bytearray",
        "cardano/assets"
      ],
      "source": "vodka",
      "isReExportFile": false
    },
    {
      "key": "vodka:mocktail.virgin_output_reference",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-vodka/lib/mocktail/virgin_output_reference.ak",
      "name": "mocktail.virgin_output_reference",
      "imports": [
        {
          "module": "aiken/cbor",
          "items": ["serialise"],
          "line": 1,
          "raw": "use aiken/cbor.{serialise}",
          "source": "vodka"
        },
        {
          "module": "aiken/crypto",
          "items": ["Blake2b_256", "Hash", "blake2b_256"],
          "line": 2,
          "raw": "use aiken/crypto.{Blake2b_256, Hash, blake2b_256}",
          "source": "vodka"
        },
        {
          "module": "aiken/primitive/bytearray",
          "items": ["concat"],
          "line": 3,
          "raw": "use aiken/primitive/bytearray.{concat}",
          "source": "vodka"
        },
        {
          "module": "cardano/transaction",
          "items": ["OutputReference", "Transaction"],
          "line": 4,
          "raw": "use cardano/transaction.{OutputReference, Transaction}",
          "source": "vodka"
        }
      ],
      "functions": [
        {
          "name": "mock_tx_hash",
          "signature": "pub fn mock_tx_hash(variation: Int) -> Hash<Blake2b_256, Transaction> {",
          "parameters": [
            {
              "name": "variation",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Hash<Blake2b_256, Transaction>",
          "line": 9,
          "raw": "pub fn mock_tx_hash(variation: Int) -> Hash<Blake2b_256, Transaction> {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn mock_tx_hash(variation: Int) -> Hash<Blake2b_256, Transaction> {\n  serialise(variation) |> concat(root_hash) |> blake2b_256()\n}",
          "reExportedAs": ["mocktail.mock_tx_hash"]
        },
        {
          "name": "mock_utxo_ref",
          "signature": "pub fn mock_utxo_ref(variation: Int, output_index: Int) -> OutputReference {",
          "documentation": "Mock an output reference",
          "parameters": [
            {
              "name": "variation",
              "type": "Int",
              "optional": false
            },
            {
              "name": "output_index",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "OutputReference",
          "line": 14,
          "raw": "pub fn mock_utxo_ref(variation: Int, output_index: Int) -> OutputReference {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn mock_utxo_ref(variation: Int, output_index: Int) -> OutputReference {\n  OutputReference { transaction_id: mock_tx_hash(variation), output_index }\n}",
          "reExportedAs": ["mocktail.mock_utxo_ref"]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/cbor.{serialise}\nuse aiken/crypto.{Blake2b_256, Hash, blake2b_256}\nuse aiken/primitive/bytearray.{concat}\nuse cardano/transaction.{OutputReference, Transaction}\n\nconst root_hash =\n  #\"5a077cbcdffb88b104f292aacb9687ce93e2191e103a30a0cc5505c18b719f98\"\n\npub fn mock_tx_hash(variation: Int) -> Hash<Blake2b_256, Transaction> {\n  serialise(variation) |> concat(root_hash) |> blake2b_256()\n}\n\n/// Mock an output reference\npub fn mock_utxo_ref(variation: Int, output_index: Int) -> OutputReference {\n  OutputReference { transaction_id: mock_tx_hash(variation), output_index }\n}\n",
      "dependencies": [
        "aiken/cbor",
        "aiken/crypto",
        "aiken/primitive/bytearray",
        "cardano/transaction"
      ],
      "source": "vodka",
      "isReExportFile": false
    },
    {
      "key": "vodka:mocktail.virgin_outputs",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-vodka/lib/mocktail/virgin_outputs.ak",
      "name": "mocktail.virgin_outputs",
      "imports": [
        {
          "module": "aiken/crypto",
          "items": ["ScriptHash"],
          "line": 1,
          "raw": "use aiken/crypto.{ScriptHash}",
          "source": "vodka"
        },
        {
          "module": "cardano/address",
          "items": ["Address"],
          "line": 2,
          "raw": "use cardano/address.{Address}",
          "source": "vodka"
        },
        {
          "module": "cardano/assets",
          "items": ["Value"],
          "line": 3,
          "raw": "use cardano/assets.{Value}",
          "source": "vodka"
        },
        {
          "module": "cardano/transaction",
          "items": ["Datum", "NoDatum", "Output"],
          "line": 4,
          "raw": "use cardano/transaction.{Datum, NoDatum, Output}",
          "source": "vodka"
        }
      ],
      "functions": [
        {
          "name": "mock_output",
          "signature": "pub fn mock_output(pub fn mock_output(address: Address, value: Value, datum: Datum, reference_script: Option<ScriptHash>, ) -> Output {",
          "documentation": "Mock an output",
          "parameters": [],
          "returnType": "Output",
          "line": 7,
          "raw": "pub fn mock_output(pub fn mock_output(address: Address, value: Value, datum: Datum, reference_script: Option<ScriptHash>, ) -> Output {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn mock_output(\n  address: Address,\n  value: Value,\n  datum: Datum,\n  reference_script: Option<ScriptHash>,\n) -> Output {\n  Output { address, value, datum, reference_script }\n}",
          "reExportedAs": ["mocktail.mock_output"]
        },
        {
          "name": "mock_pub_key_output",
          "signature": "pub fn mock_pub_key_output(address: Address, value: Value) -> Output {",
          "documentation": "Mock an output with a public key address\n`datum` and `reference_script` is omitted as it is seldom used in practice",
          "parameters": [
            {
              "name": "address",
              "type": "Address",
              "optional": false
            },
            {
              "name": "value",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "Output",
          "line": 18,
          "raw": "pub fn mock_pub_key_output(address: Address, value: Value) -> Output {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn mock_pub_key_output(address: Address, value: Value) -> Output {\n  mock_output(address, value, NoDatum, reference_script: None)\n}",
          "reExportedAs": ["mocktail.mock_pub_key_output"]
        },
        {
          "name": "mock_script_output",
          "signature": "pub fn mock_script_output(pub fn mock_script_output(address: Address, value: Value, datum: Datum, ) -> Output {",
          "documentation": "Mock an output with a script address\n`reference_script` is omitted as it is seldom used in practice",
          "parameters": [],
          "returnType": "Output",
          "line": 24,
          "raw": "pub fn mock_script_output(pub fn mock_script_output(address: Address, value: Value, datum: Datum, ) -> Output {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn mock_script_output(\n  address: Address,\n  value: Value,\n  datum: Datum,\n) -> Output {\n  mock_output(address, value, datum, reference_script: None)\n}",
          "reExportedAs": ["mocktail.mock_script_output"]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/crypto.{ScriptHash}\nuse cardano/address.{Address}\nuse cardano/assets.{Value}\nuse cardano/transaction.{Datum, NoDatum, Output}\n\n/// Mock an output\npub fn mock_output(\n  address: Address,\n  value: Value,\n  datum: Datum,\n  reference_script: Option<ScriptHash>,\n) -> Output {\n  Output { address, value, datum, reference_script }\n}\n\n/// Mock an output with a public key address\n/// `datum` and `reference_script` is omitted as it is seldom used in practice\npub fn mock_pub_key_output(address: Address, value: Value) -> Output {\n  mock_output(address, value, NoDatum, reference_script: None)\n}\n\n/// Mock an output with a script address\n/// `reference_script` is omitted as it is seldom used in practice\npub fn mock_script_output(\n  address: Address,\n  value: Value,\n  datum: Datum,\n) -> Output {\n  mock_output(address, value, datum, reference_script: None)\n}\n",
      "dependencies": [
        "aiken/crypto",
        "cardano/address",
        "cardano/assets",
        "cardano/transaction"
      ],
      "source": "vodka",
      "isReExportFile": false
    },
    {
      "key": "vodka:mocktail.virgin_validity_range",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-vodka/lib/mocktail/virgin_validity_range.ak",
      "name": "mocktail.virgin_validity_range",
      "imports": [
        {
          "module": "cardano/transaction",
          "items": ["ValidityRange"],
          "line": 4,
          "raw": "use cardano/transaction.{ValidityRange}",
          "source": "vodka"
        }
      ],
      "functions": [
        {
          "name": "mock_interval",
          "signature": "pub fn mock_interval(lower: Option<Int>, upper: Option<Int>) -> ValidityRange {",
          "documentation": "Mock a validity range with the given lower and upper bounds.",
          "parameters": [
            {
              "name": "lower",
              "type": "Option<Int>",
              "optional": false
            },
            {
              "name": "upper",
              "type": "Option<Int>",
              "optional": false
            }
          ],
          "returnType": "ValidityRange",
          "line": 7,
          "raw": "pub fn mock_interval(lower: Option<Int>, upper: Option<Int>) -> ValidityRange {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn mock_interval(lower: Option<Int>, upper: Option<Int>) -> ValidityRange {\n  let lower_bound =\n    when lower is {\n      Some(lower_bound_number) ->\n        IntervalBound {\n          bound_type: Finite(lower_bound_number),\n          is_inclusive: True,\n        }\n      None -> IntervalBound { bound_type: NegativeInfinity, is_inclusive: True }\n    }\n  let upper_bound =\n    when upper is {\n      Some(upper_bound_number) ->\n        IntervalBound {\n          bound_type: Finite(upper_bound_number),\n          is_inclusive: True,\n        }\n      None -> IntervalBound { bound_type: PositiveInfinity, is_inclusive: True }\n    }\n\n  Interval { lower_bound, upper_bound }\n}",
          "reExportedAs": ["mocktail.mock_interval"]
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/interval.{\n  Finite, Interval, IntervalBound, NegativeInfinity, PositiveInfinity,\n}\nuse cardano/transaction.{ValidityRange}\n\n/// Mock a validity range with the given lower and upper bounds.\npub fn mock_interval(lower: Option<Int>, upper: Option<Int>) -> ValidityRange {\n  let lower_bound =\n    when lower is {\n      Some(lower_bound_number) ->\n        IntervalBound {\n          bound_type: Finite(lower_bound_number),\n          is_inclusive: True,\n        }\n      None -> IntervalBound { bound_type: NegativeInfinity, is_inclusive: True }\n    }\n  let upper_bound =\n    when upper is {\n      Some(upper_bound_number) ->\n        IntervalBound {\n          bound_type: Finite(upper_bound_number),\n          is_inclusive: True,\n        }\n      None -> IntervalBound { bound_type: PositiveInfinity, is_inclusive: True }\n    }\n\n  Interval { lower_bound, upper_bound }\n}\n",
      "dependencies": ["cardano/transaction"],
      "source": "vodka",
      "isReExportFile": false
    },
    {
      "key": "vodka:mocktail",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-vodka/lib/mocktail.ak",
      "name": "mocktail",
      "imports": [
        {
          "module": "aiken/cbor",
          "items": [],
          "line": 27,
          "raw": "use aiken/cbor",
          "source": "vodka"
        },
        {
          "module": "aiken/collection/dict",
          "items": [],
          "line": 28,
          "raw": "use aiken/collection/dict",
          "source": "vodka"
        },
        {
          "module": "aiken/collection/list",
          "items": [],
          "line": 29,
          "raw": "use aiken/collection/list",
          "source": "vodka"
        },
        {
          "module": "aiken/crypto",
          "items": ["VerificationKeyHash", "blake2b_256"],
          "line": 30,
          "raw": "use aiken/crypto.{VerificationKeyHash, blake2b_256}",
          "source": "vodka"
        },
        {
          "module": "aiken/interval",
          "items": ["Finite", "Interval"],
          "line": 31,
          "raw": "use aiken/interval.{Finite, Interval}",
          "source": "vodka"
        },
        {
          "module": "cardano/address",
          "items": ["Address", "Credential", "Script"],
          "line": 32,
          "raw": "use cardano/address.{Address, Credential, Script}",
          "source": "vodka"
        },
        {
          "module": "cardano/assets",
          "items": ["Value", "from_asset", "merge", "zero"],
          "line": 33,
          "raw": "use cardano/assets.{Value, from_asset, merge, zero}",
          "source": "vodka"
        },
        {
          "module": "cardano/certificate",
          "items": ["Certificate"],
          "line": 34,
          "raw": "use cardano/certificate.{Certificate}",
          "source": "vodka"
        },
        {
          "module": "mocktail/virgin_address",
          "items": [],
          "line": 39,
          "raw": "use mocktail/virgin_address",
          "source": "vodka"
        },
        {
          "module": "mocktail/virgin_key_hash",
          "items": [],
          "line": 40,
          "raw": "use mocktail/virgin_key_hash",
          "source": "vodka"
        },
        {
          "module": "mocktail/virgin_output_reference",
          "items": [],
          "line": 41,
          "raw": "use mocktail/virgin_output_reference",
          "source": "vodka"
        },
        {
          "module": "mocktail/virgin_outputs",
          "items": [],
          "line": 42,
          "raw": "use mocktail/virgin_outputs",
          "source": "vodka"
        },
        {
          "module": "mocktail/virgin_validity_range",
          "items": [],
          "line": 43,
          "raw": "use mocktail/virgin_validity_range",
          "source": "vodka"
        }
      ],
      "functions": [
        {
          "name": "mocktail_tx",
          "signature": "pub fn mocktail_tx() -> MocktailTx {",
          "documentation": "Initialize a new mock transaction builder, and output a built transaction wiht [`.complete().`](./mocktail.html#complete)\n```aiken\nlet tx = mocktail_tx()\n|> ...other tx building methods\n|> complete()\n```",
          "parameters": [],
          "returnType": "MocktailTx",
          "line": 59,
          "raw": "pub fn mocktail_tx() -> MocktailTx {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn mocktail_tx() -> MocktailTx {\n  MocktailTx {\n    tx: placeholder,\n    queue_input: None,\n    queue_output: None,\n    queue_ref_input: None,\n  }\n}"
        },
        {
          "name": "tx_in",
          "signature": "pub fn tx_in(pub fn tx_in(mocktail_tx: MocktailTx, condition: Bool, tx_hash: ByteArray, tx_index: Int, amount: Value, address: Address, ) -> MocktailTx {",
          "documentation": "Tx building method - Add an input to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> tx_in(condition, tx_hash, tx_index, amount, address)\n|> ...other tx building methods\n|> complete()\n```",
          "parameters": [],
          "returnType": "MocktailTx",
          "line": 76,
          "raw": "pub fn tx_in(pub fn tx_in(mocktail_tx: MocktailTx, condition: Bool, tx_hash: ByteArray, tx_index: Int, amount: Value, address: Address, ) -> MocktailTx {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn tx_in(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  tx_hash: ByteArray,\n  tx_index: Int,\n  amount: Value,\n  address: Address,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let queue_input =\n      Some(\n        Input {\n          output_reference: OutputReference {\n            transaction_id: tx_hash,\n            output_index: tx_index,\n          },\n          output: mock_pub_key_output(address, amount),\n        },\n      )\n    when mocktail_tx.queue_input is {\n      Some(input) ->\n        MocktailTx {\n          ..mocktail_tx,\n          queue_input: queue_input,\n          tx: mocktail_tx.tx |> add_input(True, input),\n        }\n      None -> MocktailTx { ..mocktail_tx, queue_input: queue_input }\n    }\n  }\n}"
        },
        {
          "name": "tx_in_inline_datum",
          "signature": "pub fn tx_in_inline_datum(pub fn tx_in_inline_datum(mocktail_tx: MocktailTx, condition: Bool, datum: Data, ) -> MocktailTx {",
          "documentation": "Tx building method - Add an input with inline datum to the transaction.\nThis can only be used right after [`tx_in`](./mocktail.html#tx_in).\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> tx_in(condition, tx_hash, tx_index, amount, address)\n|> tx_in_inline_datum(condition, datum)\n|> ...other tx building methods\n|> complete()\n```",
          "parameters": [],
          "returnType": "MocktailTx",
          "line": 119,
          "raw": "pub fn tx_in_inline_datum(pub fn tx_in_inline_datum(mocktail_tx: MocktailTx, condition: Bool, datum: Data, ) -> MocktailTx {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn tx_in_inline_datum(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  datum: Data,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let queue_input =\n      when mocktail_tx.queue_input is {\n        Some(input) -> {\n          let Input { output_reference, output } = input\n          Some(\n            Input {\n              output_reference,\n              output: Output { ..output, datum: InlineDatum(datum) },\n            },\n          )\n        }\n        None ->\n          Some(\n            Input {\n              output_reference: mock_utxo_ref(0, 0),\n              output: mock_script_output(\n                mock_script_address(0, None),\n                zero,\n                InlineDatum(datum),\n              ),\n            },\n          )\n      }\n    MocktailTx { ..mocktail_tx, queue_input: queue_input }\n  }\n}"
        },
        {
          "name": "tx_out",
          "signature": "pub fn tx_out(pub fn tx_out(mocktail_tx: MocktailTx, condition: Bool, address: Address, amount: Value, ) -> MocktailTx {",
          "documentation": "Tx building method - Add an output to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> tx_out(condition, address, amount)\n|> ...other tx building methods\n|> complete()\n```",
          "parameters": [],
          "returnType": "MocktailTx",
          "line": 162,
          "raw": "pub fn tx_out(pub fn tx_out(mocktail_tx: MocktailTx, condition: Bool, address: Address, amount: Value, ) -> MocktailTx {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn tx_out(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  address: Address,\n  amount: Value,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let queue_output = Some(mock_pub_key_output(address, amount))\n    when mocktail_tx.queue_output is {\n      Some(output) ->\n        MocktailTx {\n          ..mocktail_tx,\n          queue_output: queue_output,\n          tx: mocktail_tx.tx |> add_output(True, output),\n        }\n      None -> MocktailTx { ..mocktail_tx, queue_output: queue_output }\n    }\n  }\n}"
        },
        {
          "name": "tx_out_inline_datum",
          "signature": "pub fn tx_out_inline_datum(pub fn tx_out_inline_datum(mocktail_tx: MocktailTx, condition: Bool, datum: Data, ) -> MocktailTx {",
          "documentation": "Tx building method - Add an output with inline datum to the transaction.\nThis can only be used right after [`tx_out`](./mocktail.html#tx_out).\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> tx_out(condition, address, amount)\n|> tx_out_inline_datum(condition, datum)\n|> ...other tx building methods\n|> complete()\n```",
          "parameters": [],
          "returnType": "MocktailTx",
          "line": 194,
          "raw": "pub fn tx_out_inline_datum(pub fn tx_out_inline_datum(mocktail_tx: MocktailTx, condition: Bool, datum: Data, ) -> MocktailTx {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn tx_out_inline_datum(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  datum: Data,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let queue_output =\n      when mocktail_tx.queue_output is {\n        Some(output) -> Some(Output { ..output, datum: InlineDatum(datum) })\n        None ->\n          Some(\n            mock_script_output(\n              mock_script_address(0, None),\n              zero,\n              InlineDatum(datum),\n            ),\n          )\n      }\n    MocktailTx { ..mocktail_tx, queue_output: queue_output }\n  }\n}"
        },
        {
          "name": "mint",
          "signature": "pub fn mint(pub fn mint(mocktail_tx: MocktailTx, condition: Bool, quantity: Int, policy_id: ByteArray, token_name: ByteArray, ) -> MocktailTx {",
          "documentation": "Tx building method - Add a mint to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> mint(condition, quantity, policy_id, token_name)\n|> ...other tx building methods\n|> complete()\n```",
          "parameters": [],
          "returnType": "MocktailTx",
          "line": 226,
          "raw": "pub fn mint(pub fn mint(mocktail_tx: MocktailTx, condition: Bool, quantity: Int, policy_id: ByteArray, token_name: ByteArray, ) -> MocktailTx {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn mint(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  quantity: Int,\n  policy_id: ByteArray,\n  token_name: ByteArray,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    MocktailTx {\n      ..mocktail_tx,\n      tx: mocktail_tx.tx\n        |> add_mint(True, from_asset(policy_id, token_name, quantity)),\n    }\n  }\n}"
        },
        {
          "name": "ref_tx_in",
          "signature": "pub fn ref_tx_in(pub fn ref_tx_in(mocktail_tx: MocktailTx, condition: Bool, tx_hash: ByteArray, tx_index: Int, amount: Value, address: Address, ) -> MocktailTx {",
          "documentation": "Tx building method - Add a reference input to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ref_tx_in(condition, tx_hash, tx_index, amount, address)\n|> ...other tx building methods\n|> complete()\n```",
          "parameters": [],
          "returnType": "MocktailTx",
          "line": 252,
          "raw": "pub fn ref_tx_in(pub fn ref_tx_in(mocktail_tx: MocktailTx, condition: Bool, tx_hash: ByteArray, tx_index: Int, amount: Value, address: Address, ) -> MocktailTx {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn ref_tx_in(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  tx_hash: ByteArray,\n  tx_index: Int,\n  amount: Value,\n  address: Address,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let queue_ref_input =\n      Some(\n        Input {\n          output_reference: OutputReference {\n            transaction_id: tx_hash,\n            output_index: tx_index,\n          },\n          output: mock_pub_key_output(address, amount),\n        },\n      )\n    when mocktail_tx.queue_ref_input is {\n      Some(input) ->\n        MocktailTx {\n          ..mocktail_tx,\n          queue_ref_input: queue_ref_input,\n          tx: mocktail_tx.tx |> add_reference_input(True, input),\n        }\n      None -> MocktailTx { ..mocktail_tx, queue_ref_input: queue_ref_input }\n    }\n  }\n}"
        },
        {
          "name": "ref_tx_in_inline_datum",
          "signature": "pub fn ref_tx_in_inline_datum(pub fn ref_tx_in_inline_datum(mocktail_tx: MocktailTx, condition: Bool, datum: Data, ) -> MocktailTx {",
          "documentation": "Tx building method - Add an inline datum to last reference input in the transaction.\nThis can only be used right after [`ref_tx_in`](./mocktail.html#ref_tx_in).\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ref_tx_in(condition, tx_hash, tx_index, amount, address)\n|> ref_tx_in_inline_datum(condition, datum)\n|> ...other tx building methods\n|> complete()\n```",
          "parameters": [],
          "returnType": "MocktailTx",
          "line": 295,
          "raw": "pub fn ref_tx_in_inline_datum(pub fn ref_tx_in_inline_datum(mocktail_tx: MocktailTx, condition: Bool, datum: Data, ) -> MocktailTx {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn ref_tx_in_inline_datum(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  datum: Data,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let queue_ref_input =\n      when mocktail_tx.queue_ref_input is {\n        Some(input) -> {\n          let Input { output_reference, output } = input\n          Some(\n            Input {\n              output_reference,\n              output: Output { ..output, datum: InlineDatum(datum) },\n            },\n          )\n        }\n        None ->\n          Some(\n            Input {\n              output_reference: mock_utxo_ref(0, 0),\n              output: mock_script_output(\n                mock_script_address(0, None),\n                zero,\n                InlineDatum(datum),\n              ),\n            },\n          )\n      }\n    MocktailTx { ..mocktail_tx, queue_ref_input: queue_ref_input }\n  }\n}"
        },
        {
          "name": "invalid_before",
          "signature": "pub fn invalid_before(pub fn invalid_before(mocktail_tx: MocktailTx, condition: Bool, time: Int, ) -> MocktailTx {",
          "documentation": "Tx building method - Add a a lower bound validity range to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> invalid_before(condition, time)\n|> ...other tx building methods\n|> complete()\n```",
          "parameters": [],
          "returnType": "MocktailTx",
          "line": 338,
          "raw": "pub fn invalid_before(pub fn invalid_before(mocktail_tx: MocktailTx, condition: Bool, time: Int, ) -> MocktailTx {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn invalid_before(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  time: Int,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let tx = mocktail_tx.tx\n    let upper_bound =\n      when tx.validity_range.upper_bound.bound_type is {\n        Finite(x) -> Some(x)\n        _ -> None\n      }\n    MocktailTx {\n      ..mocktail_tx,\n      tx: Transaction {\n        ..tx,\n        validity_range: mock_interval(Some(time), upper_bound),\n      },\n    }\n  }\n}"
        },
        {
          "name": "invalid_hereafter",
          "signature": "pub fn invalid_hereafter(pub fn invalid_hereafter(mocktail_tx: MocktailTx, condition: Bool, time: Int, ) -> MocktailTx {",
          "documentation": "Tx building method - Add a a upper bound validity range to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> invalid_hereafter(condition, time)\n|> ...other tx building methods\n|> complete()\n```",
          "parameters": [],
          "returnType": "MocktailTx",
          "line": 370,
          "raw": "pub fn invalid_hereafter(pub fn invalid_hereafter(mocktail_tx: MocktailTx, condition: Bool, time: Int, ) -> MocktailTx {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn invalid_hereafter(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  time: Int,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let tx = mocktail_tx.tx\n    let lower_bound =\n      when tx.validity_range.lower_bound.bound_type is {\n        Finite(x) -> Some(x)\n        _ -> None\n      }\n    MocktailTx {\n      ..mocktail_tx,\n      tx: Transaction {\n        ..tx,\n        validity_range: mock_interval(lower_bound, Some(time)),\n      },\n    }\n  }\n}"
        },
        {
          "name": "required_signer_hash",
          "signature": "pub fn required_signer_hash(pub fn required_signer_hash(mocktail_tx: MocktailTx, condition: Bool, key: ByteArray, ) -> MocktailTx {",
          "documentation": "Tx building method - Add a required signer hash to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> required_signer_hash(condition, key)\n|> ...other tx building methods\n|> complete()\n```",
          "parameters": [],
          "returnType": "MocktailTx",
          "line": 402,
          "raw": "pub fn required_signer_hash(pub fn required_signer_hash(mocktail_tx: MocktailTx, condition: Bool, key: ByteArray, ) -> MocktailTx {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn required_signer_hash(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  key: ByteArray,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    MocktailTx {\n      ..mocktail_tx,\n      tx: mocktail_tx.tx |> add_extra_signatory(True, key),\n    }\n  }\n}"
        },
        {
          "name": "script_withdrawal",
          "signature": "pub fn script_withdrawal(pub fn script_withdrawal(mocktail_tx: MocktailTx, condition: Bool, script_hash: ByteArray, withdrawal_amount: Int, ) -> MocktailTx {",
          "documentation": "Tx building method - Add a script withdrawal to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> script_withdrawal(condition, script_hash, withdrawal_amount)\n|> ...other tx building methods\n|> complete()\n```",
          "parameters": [],
          "returnType": "MocktailTx",
          "line": 425,
          "raw": "pub fn script_withdrawal(pub fn script_withdrawal(mocktail_tx: MocktailTx, condition: Bool, script_hash: ByteArray, withdrawal_amount: Int, ) -> MocktailTx {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn script_withdrawal(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  script_hash: ByteArray,\n  withdrawal_amount: Int,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    MocktailTx {\n      ..mocktail_tx,\n      tx: mocktail_tx.tx\n        |> add_withdrawal(True, Pair(Script(script_hash), withdrawal_amount)),\n    }\n  }\n}"
        },
        {
          "name": "complete",
          "signature": "pub fn complete(mocktail_tx: MocktailTx) -> Transaction {",
          "documentation": "Tx building method - Conclude the transaction building process, and return the built transaction.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()",
          "parameters": [
            {
              "name": "mocktail_tx",
              "type": "MocktailTx",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "line": 447,
          "raw": "pub fn complete(mocktail_tx: MocktailTx) -> Transaction {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn complete(mocktail_tx: MocktailTx) -> Transaction {\n  let tx = mocktail_tx.tx\n  let tx =\n    when mocktail_tx.queue_input is {\n      Some(input) -> tx |> add_input(True, input)\n      None -> tx\n    }\n  let tx =\n    when mocktail_tx.queue_output is {\n      Some(output) -> tx |> add_output(True, output)\n      None -> tx\n    }\n  let tx =\n    when mocktail_tx.queue_ref_input is {\n      Some(input) -> tx |> add_reference_input(True, input)\n      None -> tx\n    }\n  tx\n}"
        },
        {
          "name": "add_input",
          "signature": "pub fn add_input(tx: Transaction, condition: Bool, input: Input) -> Transaction {",
          "documentation": "Tx maniputlator - Add an input to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> add_input(condition, input)\n|> ...other tx maniputlator methods\n```",
          "parameters": [
            {
              "name": "tx",
              "type": "Transaction",
              "optional": false
            },
            {
              "name": "condition",
              "type": "Bool",
              "optional": false
            },
            {
              "name": "input",
              "type": "Input",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "line": 476,
          "raw": "pub fn add_input(tx: Transaction, condition: Bool, input: Input) -> Transaction {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn add_input(tx: Transaction, condition: Bool, input: Input) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction { ..tx, inputs: tx.inputs |> list.concat([input]) }\n  }\n}"
        },
        {
          "name": "add_reference_input",
          "signature": "pub fn add_reference_input(pub fn add_reference_input(tx: Transaction, condition: Bool, input: Input, ) -> Transaction {",
          "documentation": "Tx maniputlator - Add a reference input to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> add_reference_input(condition, input)\n|> ...other tx maniputlator methods\n```",
          "parameters": [],
          "returnType": "Transaction",
          "line": 493,
          "raw": "pub fn add_reference_input(pub fn add_reference_input(tx: Transaction, condition: Bool, input: Input, ) -> Transaction {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn add_reference_input(\n  tx: Transaction,\n  condition: Bool,\n  input: Input,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction {\n      ..tx,\n      reference_inputs: tx.reference_inputs |> list.concat([input]),\n    }\n  }\n}"
        },
        {
          "name": "add_output",
          "signature": "pub fn add_output(pub fn add_output(tx: Transaction, condition: Bool, output: Output, ) -> Transaction {",
          "documentation": "Tx maniputlator - Add an output to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet t = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> add_output(condition, output)\n|> ...other tx maniputlator methods\n```",
          "parameters": [],
          "returnType": "Transaction",
          "line": 517,
          "raw": "pub fn add_output(pub fn add_output(tx: Transaction, condition: Bool, output: Output, ) -> Transaction {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn add_output(\n  tx: Transaction,\n  condition: Bool,\n  output: Output,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction { ..tx, outputs: tx.outputs |> list.concat([output]) }\n  }\n}"
        },
        {
          "name": "set_fee",
          "signature": "pub fn set_fee(pub fn set_fee(tx: Transaction, condition: Bool, lovelace_fee: Int, ) -> Transaction {",
          "documentation": "Tx maniputlator - Set a fee to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> set_fee(condition, lovelace_fee)\n|> ...other tx maniputlator methods\n```",
          "parameters": [],
          "returnType": "Transaction",
          "line": 538,
          "raw": "pub fn set_fee(pub fn set_fee(tx: Transaction, condition: Bool, lovelace_fee: Int, ) -> Transaction {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn set_fee(\n  tx: Transaction,\n  condition: Bool,\n  lovelace_fee: Int,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction { ..tx, fee: lovelace_fee }\n  }\n}"
        },
        {
          "name": "add_mint",
          "signature": "pub fn add_mint(tx: Transaction, condition: Bool, mint: Value) -> Transaction {",
          "documentation": "Tx maniputlator - Add a mint to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> add_mint(condition, mint)\n|> ...other tx maniputlator methods\n```",
          "parameters": [
            {
              "name": "tx",
              "type": "Transaction",
              "optional": false
            },
            {
              "name": "condition",
              "type": "Bool",
              "optional": false
            },
            {
              "name": "mint",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "line": 559,
          "raw": "pub fn add_mint(tx: Transaction, condition: Bool, mint: Value) -> Transaction {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn add_mint(tx: Transaction, condition: Bool, mint: Value) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction {\n      ..tx,\n      mint: tx.mint\n        |> merge(mint),\n    }\n  }\n}"
        },
        {
          "name": "add_certificate",
          "signature": "pub fn add_certificate(pub fn add_certificate(tx: Transaction, condition: Bool, certificate: Certificate, ) -> Transaction {",
          "documentation": "Tx maniputlator - Add a certificate to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> add_certificate(condition, certificate)\n|> ...other tx maniputlator methods\n```",
          "parameters": [],
          "returnType": "Transaction",
          "line": 580,
          "raw": "pub fn add_certificate(pub fn add_certificate(tx: Transaction, condition: Bool, certificate: Certificate, ) -> Transaction {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn add_certificate(\n  tx: Transaction,\n  condition: Bool,\n  certificate: Certificate,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction {\n      ..tx,\n      certificates: tx.certificates |> list.concat([certificate]),\n    }\n  }\n}"
        },
        {
          "name": "add_withdrawal",
          "signature": "pub fn add_withdrawal(pub fn add_withdrawal(tx: Transaction, condition: Bool, withdrawal: Pair<Credential, Int>, ) -> Transaction {",
          "documentation": "Tx maniputlator - Add a withdrawal to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> add_withdrawal(condition, stake_credential, amount)\n|> ...other tx maniputlator methods\n```",
          "parameters": [],
          "returnType": "Transaction",
          "line": 604,
          "raw": "pub fn add_withdrawal(pub fn add_withdrawal(tx: Transaction, condition: Bool, withdrawal: Pair<Credential, Int>, ) -> Transaction {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn add_withdrawal(\n  tx: Transaction,\n  condition: Bool,\n  withdrawal: Pair<Credential, Int>,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction {\n      ..tx,\n      withdrawals: tx.withdrawals |> list.concat([withdrawal]),\n    }\n  }\n}"
        },
        {
          "name": "add_extra_signatory",
          "signature": "pub fn add_extra_signatory(pub fn add_extra_signatory(tx: Transaction, condition: Bool, signatory: VerificationKeyHash, ) -> Transaction {",
          "documentation": "Tx maniputlator - Add an extra signatory to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> add_extra_signatory(condition, signatory)\n|> ...other tx maniputlator methods\n```",
          "parameters": [],
          "returnType": "Transaction",
          "line": 628,
          "raw": "pub fn add_extra_signatory(pub fn add_extra_signatory(tx: Transaction, condition: Bool, signatory: VerificationKeyHash, ) -> Transaction {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn add_extra_signatory(\n  tx: Transaction,\n  condition: Bool,\n  signatory: VerificationKeyHash,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction {\n      ..tx,\n      extra_signatories: tx.extra_signatories |> list.concat([signatory]),\n    }\n  }\n}"
        },
        {
          "name": "add_redeemer",
          "signature": "pub fn add_redeemer(pub fn add_redeemer(tx: Transaction, condition: Bool, redeemer: Pair<ScriptPurpose, Redeemer>, ) -> Transaction {",
          "documentation": "Tx maniputlator - Add a redeemer to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> add_redeemer(condition, redeemer)\n|> ...other tx maniputlator methods\n```",
          "parameters": [],
          "returnType": "Transaction",
          "line": 652,
          "raw": "pub fn add_redeemer(pub fn add_redeemer(tx: Transaction, condition: Bool, redeemer: Pair<ScriptPurpose, Redeemer>, ) -> Transaction {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn add_redeemer(\n  tx: Transaction,\n  condition: Bool,\n  redeemer: Pair<ScriptPurpose, Redeemer>,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction { ..tx, redeemers: tx.redeemers |> list.concat([redeemer]) }\n  }\n}"
        },
        {
          "name": "add_datum",
          "signature": "pub fn add_datum(tx: Transaction, condition: Bool, datum: Data) -> Transaction {",
          "documentation": "Tx maniputlator - Add a datum to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> add_datum(condition, datum)\n|> ...other tx maniputlator methods\n```",
          "parameters": [
            {
              "name": "tx",
              "type": "Transaction",
              "optional": false
            },
            {
              "name": "condition",
              "type": "Bool",
              "optional": false
            },
            {
              "name": "datum",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "Transaction",
          "line": 673,
          "raw": "pub fn add_datum(tx: Transaction, condition: Bool, datum: Data) -> Transaction {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn add_datum(tx: Transaction, condition: Bool, datum: Data) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    let datum_hash = blake2b_256(cbor.serialise(datum))\n    Transaction { ..tx, datums: tx.datums |> dict.insert(datum_hash, datum) }\n  }\n}"
        },
        {
          "name": "set_transaction_id",
          "signature": "pub fn set_transaction_id(pub fn set_transaction_id(tx: Transaction, condition: Bool, transaction_id: TransactionId, ) -> Transaction {",
          "documentation": "Tx maniputlator - Set the transaction id.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> set_transaction_id(condition, transaction_id)\n|> ...other tx maniputlator methods\n```",
          "parameters": [],
          "returnType": "Transaction",
          "line": 691,
          "raw": "pub fn set_transaction_id(pub fn set_transaction_id(tx: Transaction, condition: Bool, transaction_id: TransactionId, ) -> Transaction {",
          "isPublic": true,
          "source": "vodka",
          "implementation": "pub fn set_transaction_id(\n  tx: Transaction,\n  condition: Bool,\n  transaction_id: TransactionId,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction { ..tx, id: transaction_id }\n  }\n}"
        }
      ],
      "types": [
        {
          "name": "MocktailTx",
          "definition": "{ tx: Transaction, queue_input: Option<Input>, queue_output: Option<Output>, queue_ref_input: Option<Input>, }",
          "line": 46,
          "raw": "pub type MocktailTx {",
          "isPublic": true,
          "source": "vodka"
        }
      ],
      "constants": [
        {
          "name": "mock_pub_key_address",
          "type": "Unknown",
          "value": "virgin_address.mock_pub_key_address",
          "line": 710,
          "raw": "pub const mock_pub_key_address = virgin_address.mock_pub_key_address",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["mock_pub_key_address"]
        },
        {
          "name": "mock_script_credential",
          "type": "Unknown",
          "value": "virgin_address.mock_script_credential",
          "line": 713,
          "raw": "pub const mock_script_credential = virgin_address.mock_script_credential",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["mock_script_credential"]
        },
        {
          "name": "mock_script_address",
          "type": "Unknown",
          "value": "virgin_address.mock_script_address",
          "line": 716,
          "raw": "pub const mock_script_address = virgin_address.mock_script_address",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["mock_script_address"]
        },
        {
          "name": "mock_key_hash",
          "type": "Unknown",
          "value": "virgin_key_hash.mock_key_hash",
          "line": 721,
          "raw": "pub const mock_key_hash = virgin_key_hash.mock_key_hash",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["mock_key_hash"]
        },
        {
          "name": "mock_policy_id",
          "type": "Unknown",
          "value": "virgin_key_hash.mock_policy_id",
          "line": 724,
          "raw": "pub const mock_policy_id = virgin_key_hash.mock_policy_id",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["mock_policy_id"]
        },
        {
          "name": "mock_pub_key_hash",
          "type": "Unknown",
          "value": "virgin_key_hash.mock_pub_key_hash",
          "line": 727,
          "raw": "pub const mock_pub_key_hash = virgin_key_hash.mock_pub_key_hash",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["mock_pub_key_hash"]
        },
        {
          "name": "mock_script_hash",
          "type": "Unknown",
          "value": "virgin_key_hash.mock_script_hash",
          "line": 730,
          "raw": "pub const mock_script_hash = virgin_key_hash.mock_script_hash",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["mock_script_hash"]
        },
        {
          "name": "mock_stake_key_hash",
          "type": "Unknown",
          "value": "virgin_key_hash.mock_stake_key_hash",
          "line": 733,
          "raw": "pub const mock_stake_key_hash = virgin_key_hash.mock_stake_key_hash",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["mock_stake_key_hash"]
        },
        {
          "name": "mock_tx_hash",
          "type": "Unknown",
          "value": "virgin_output_reference.mock_tx_hash",
          "line": 742,
          "raw": "pub const mock_tx_hash = virgin_output_reference.mock_tx_hash",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["mock_tx_hash"]
        },
        {
          "name": "mock_utxo_ref",
          "type": "Unknown",
          "value": "virgin_output_reference.mock_utxo_ref",
          "line": 745,
          "raw": "pub const mock_utxo_ref = virgin_output_reference.mock_utxo_ref",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["mock_utxo_ref"]
        },
        {
          "name": "mock_output",
          "type": "Unknown",
          "value": "virgin_outputs.mock_output",
          "line": 750,
          "raw": "pub const mock_output = virgin_outputs.mock_output",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["mock_output"]
        },
        {
          "name": "mock_pub_key_output",
          "type": "Unknown",
          "value": "virgin_outputs.mock_pub_key_output",
          "line": 753,
          "raw": "pub const mock_pub_key_output = virgin_outputs.mock_pub_key_output",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["mock_pub_key_output"]
        },
        {
          "name": "mock_script_output",
          "type": "Unknown",
          "value": "virgin_outputs.mock_script_output",
          "line": 756,
          "raw": "pub const mock_script_output = virgin_outputs.mock_script_output",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["mock_script_output"]
        },
        {
          "name": "mock_interval",
          "type": "Unknown",
          "value": "virgin_validity_range.mock_interval",
          "line": 761,
          "raw": "pub const mock_interval = virgin_validity_range.mock_interval",
          "isPublic": true,
          "source": "vodka",
          "reExportedAs": ["mock_interval"]
        }
      ],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "//// Mocktail contains a set of functions to build transactions for testing purposes.\n//// \n//// To use Mocktail Tx, there are 4 steps\n//// 1. Starts with [`mocktail_tx()`](./mocktail.html#mocktail_tx) to create a new transaction builder.\n//// 2. Use tx building methods similar to MeshJS lower level APIs to build the transaction.\n//// 3. Call [`complete`](./mocktail.html#complete) to complete building transaction.\n//// 4. Finally, if there is any whole items to be added to the transaction, use the `add` functions.\n//// \n//// Mocktail is built with devex and multiple test cases compatibility in mind.\n//// 1. It is pipable.\n//// 2. For every tx building and adding methods, it takes first param as condition. that function will only run when this condition is `True`.\n////\n//// ## Example\n//// ```aiken\n//// let tx: Transaction =\n////   mocktail_tx()\n////     |> required_signer_hash(is_signature_provided, mock_pub_key_hash(0))\n////     |> script_withdrawal(True, mock_script_hash(0), 0)\n////     |> script_withdrawal(True, mock_script_hash(1), 0)\n////     |> required_signer_hash(True, mock_pub_key_hash(1))\n////     |> complete()\n////     |> add_reference_input(True, mock_oracle_ref_input_1())\n////     |> add_reference_input(True, mock_oracle_ref_input_2())\n////     |> add_output(True, mock_pub_key_output(mock_fee_collection_address, mock_fee))\n//// ```\n\nuse aiken/cbor\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{VerificationKeyHash, blake2b_256}\nuse aiken/interval.{Finite, Interval}\nuse cardano/address.{Address, Credential, Script}\nuse cardano/assets.{Value, from_asset, merge, zero}\nuse cardano/certificate.{Certificate}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Redeemer, ScriptPurpose,\n  Transaction, TransactionId, placeholder,\n}\nuse mocktail/virgin_address\nuse mocktail/virgin_key_hash\nuse mocktail/virgin_output_reference\nuse mocktail/virgin_outputs\nuse mocktail/virgin_validity_range\n\n/// A mock transaction builder. It can be initialized with `mocktail_tx()`.\npub type MocktailTx {\n  tx: Transaction,\n  queue_input: Option<Input>,\n  queue_output: Option<Output>,\n  queue_ref_input: Option<Input>,\n}\n\n/// Initialize a new mock transaction builder, and output a built transaction wiht [`.complete().`](./mocktail.html#complete)\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> ...other tx building methods\n///   |> complete()\n/// ```\npub fn mocktail_tx() -> MocktailTx {\n  MocktailTx {\n    tx: placeholder,\n    queue_input: None,\n    queue_output: None,\n    queue_ref_input: None,\n  }\n}\n\n/// Tx building method - Add an input to the transaction.\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> tx_in(condition, tx_hash, tx_index, amount, address)\n///   |> ...other tx building methods\n///   |> complete()\n/// ```\npub fn tx_in(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  tx_hash: ByteArray,\n  tx_index: Int,\n  amount: Value,\n  address: Address,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let queue_input =\n      Some(\n        Input {\n          output_reference: OutputReference {\n            transaction_id: tx_hash,\n            output_index: tx_index,\n          },\n          output: mock_pub_key_output(address, amount),\n        },\n      )\n    when mocktail_tx.queue_input is {\n      Some(input) ->\n        MocktailTx {\n          ..mocktail_tx,\n          queue_input: queue_input,\n          tx: mocktail_tx.tx |> add_input(True, input),\n        }\n      None -> MocktailTx { ..mocktail_tx, queue_input: queue_input }\n    }\n  }\n}\n\n/// Tx building method - Add an input with inline datum to the transaction.\n/// This can only be used right after [`tx_in`](./mocktail.html#tx_in).\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> tx_in(condition, tx_hash, tx_index, amount, address)\n///   |> tx_in_inline_datum(condition, datum)\n///   |> ...other tx building methods\n///   |> complete()\n/// ```\npub fn tx_in_inline_datum(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  datum: Data,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let queue_input =\n      when mocktail_tx.queue_input is {\n        Some(input) -> {\n          let Input { output_reference, output } = input\n          Some(\n            Input {\n              output_reference,\n              output: Output { ..output, datum: InlineDatum(datum) },\n            },\n          )\n        }\n        None ->\n          Some(\n            Input {\n              output_reference: mock_utxo_ref(0, 0),\n              output: mock_script_output(\n                mock_script_address(0, None),\n                zero,\n                InlineDatum(datum),\n              ),\n            },\n          )\n      }\n    MocktailTx { ..mocktail_tx, queue_input: queue_input }\n  }\n}\n\n/// Tx building method - Add an output to the transaction.\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> tx_out(condition, address, amount)\n///   |> ...other tx building methods\n///   |> complete()\n/// ```\npub fn tx_out(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  address: Address,\n  amount: Value,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let queue_output = Some(mock_pub_key_output(address, amount))\n    when mocktail_tx.queue_output is {\n      Some(output) ->\n        MocktailTx {\n          ..mocktail_tx,\n          queue_output: queue_output,\n          tx: mocktail_tx.tx |> add_output(True, output),\n        }\n      None -> MocktailTx { ..mocktail_tx, queue_output: queue_output }\n    }\n  }\n}\n\n/// Tx building method - Add an output with inline datum to the transaction.\n/// This can only be used right after [`tx_out`](./mocktail.html#tx_out).\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> tx_out(condition, address, amount)\n///   |> tx_out_inline_datum(condition, datum)\n///   |> ...other tx building methods\n///   |> complete()\n/// ```\npub fn tx_out_inline_datum(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  datum: Data,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let queue_output =\n      when mocktail_tx.queue_output is {\n        Some(output) -> Some(Output { ..output, datum: InlineDatum(datum) })\n        None ->\n          Some(\n            mock_script_output(\n              mock_script_address(0, None),\n              zero,\n              InlineDatum(datum),\n            ),\n          )\n      }\n    MocktailTx { ..mocktail_tx, queue_output: queue_output }\n  }\n}\n\n/// Tx building method - Add a mint to the transaction.\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> mint(condition, quantity, policy_id, token_name)\n///   |> ...other tx building methods\n///   |> complete()\n/// ```\npub fn mint(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  quantity: Int,\n  policy_id: ByteArray,\n  token_name: ByteArray,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    MocktailTx {\n      ..mocktail_tx,\n      tx: mocktail_tx.tx\n        |> add_mint(True, from_asset(policy_id, token_name, quantity)),\n    }\n  }\n}\n\n/// Tx building method - Add a reference input to the transaction.\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> ref_tx_in(condition, tx_hash, tx_index, amount, address)\n///   |> ...other tx building methods\n///   |> complete()\n/// ```\npub fn ref_tx_in(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  tx_hash: ByteArray,\n  tx_index: Int,\n  amount: Value,\n  address: Address,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let queue_ref_input =\n      Some(\n        Input {\n          output_reference: OutputReference {\n            transaction_id: tx_hash,\n            output_index: tx_index,\n          },\n          output: mock_pub_key_output(address, amount),\n        },\n      )\n    when mocktail_tx.queue_ref_input is {\n      Some(input) ->\n        MocktailTx {\n          ..mocktail_tx,\n          queue_ref_input: queue_ref_input,\n          tx: mocktail_tx.tx |> add_reference_input(True, input),\n        }\n      None -> MocktailTx { ..mocktail_tx, queue_ref_input: queue_ref_input }\n    }\n  }\n}\n\n/// Tx building method - Add an inline datum to last reference input in the transaction.\n/// This can only be used right after [`ref_tx_in`](./mocktail.html#ref_tx_in).\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> ref_tx_in(condition, tx_hash, tx_index, amount, address)\n///   |> ref_tx_in_inline_datum(condition, datum)\n///   |> ...other tx building methods\n///   |> complete()\n/// ```\npub fn ref_tx_in_inline_datum(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  datum: Data,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let queue_ref_input =\n      when mocktail_tx.queue_ref_input is {\n        Some(input) -> {\n          let Input { output_reference, output } = input\n          Some(\n            Input {\n              output_reference,\n              output: Output { ..output, datum: InlineDatum(datum) },\n            },\n          )\n        }\n        None ->\n          Some(\n            Input {\n              output_reference: mock_utxo_ref(0, 0),\n              output: mock_script_output(\n                mock_script_address(0, None),\n                zero,\n                InlineDatum(datum),\n              ),\n            },\n          )\n      }\n    MocktailTx { ..mocktail_tx, queue_ref_input: queue_ref_input }\n  }\n}\n\n/// Tx building method - Add a a lower bound validity range to the transaction.\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> invalid_before(condition, time)\n///   |> ...other tx building methods\n///   |> complete()\n/// ```\npub fn invalid_before(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  time: Int,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let tx = mocktail_tx.tx\n    let upper_bound =\n      when tx.validity_range.upper_bound.bound_type is {\n        Finite(x) -> Some(x)\n        _ -> None\n      }\n    MocktailTx {\n      ..mocktail_tx,\n      tx: Transaction {\n        ..tx,\n        validity_range: mock_interval(Some(time), upper_bound),\n      },\n    }\n  }\n}\n\n/// Tx building method - Add a a upper bound validity range to the transaction.\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> invalid_hereafter(condition, time)\n///   |> ...other tx building methods\n///   |> complete()\n/// ```\npub fn invalid_hereafter(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  time: Int,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let tx = mocktail_tx.tx\n    let lower_bound =\n      when tx.validity_range.lower_bound.bound_type is {\n        Finite(x) -> Some(x)\n        _ -> None\n      }\n    MocktailTx {\n      ..mocktail_tx,\n      tx: Transaction {\n        ..tx,\n        validity_range: mock_interval(lower_bound, Some(time)),\n      },\n    }\n  }\n}\n\n/// Tx building method - Add a required signer hash to the transaction.\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> required_signer_hash(condition, key)\n///   |> ...other tx building methods\n///   |> complete()\n/// ```\npub fn required_signer_hash(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  key: ByteArray,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    MocktailTx {\n      ..mocktail_tx,\n      tx: mocktail_tx.tx |> add_extra_signatory(True, key),\n    }\n  }\n}\n\n/// Tx building method - Add a script withdrawal to the transaction.\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///  |> script_withdrawal(condition, script_hash, withdrawal_amount)\n///  |> ...other tx building methods\n///  |> complete()\n/// ```\npub fn script_withdrawal(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  script_hash: ByteArray,\n  withdrawal_amount: Int,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    MocktailTx {\n      ..mocktail_tx,\n      tx: mocktail_tx.tx\n        |> add_withdrawal(True, Pair(Script(script_hash), withdrawal_amount)),\n    }\n  }\n}\n\n/// Tx building method - Conclude the transaction building process, and return the built transaction.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> ...tx building methods\n///   |> complete()\npub fn complete(mocktail_tx: MocktailTx) -> Transaction {\n  let tx = mocktail_tx.tx\n  let tx =\n    when mocktail_tx.queue_input is {\n      Some(input) -> tx |> add_input(True, input)\n      None -> tx\n    }\n  let tx =\n    when mocktail_tx.queue_output is {\n      Some(output) -> tx |> add_output(True, output)\n      None -> tx\n    }\n  let tx =\n    when mocktail_tx.queue_ref_input is {\n      Some(input) -> tx |> add_reference_input(True, input)\n      None -> tx\n    }\n  tx\n}\n\n/// Tx maniputlator - Add an input to the transaction.\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> ...tx building methods\n///   |> complete()\n///   |> add_input(condition, input)\n///   |> ...other tx maniputlator methods\n/// ```\npub fn add_input(tx: Transaction, condition: Bool, input: Input) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction { ..tx, inputs: tx.inputs |> list.concat([input]) }\n  }\n}\n\n/// Tx maniputlator - Add a reference input to the transaction.\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> ...tx building methods\n///   |> complete()\n///   |> add_reference_input(condition, input)\n///   |> ...other tx maniputlator methods\n/// ```\npub fn add_reference_input(\n  tx: Transaction,\n  condition: Bool,\n  input: Input,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction {\n      ..tx,\n      reference_inputs: tx.reference_inputs |> list.concat([input]),\n    }\n  }\n}\n\n/// Tx maniputlator - Add an output to the transaction.\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let t = mocktail_tx()\n///   |> ...tx building methods\n///   |> complete()\n///   |> add_output(condition, output)\n///   |> ...other tx maniputlator methods\n/// ```\npub fn add_output(\n  tx: Transaction,\n  condition: Bool,\n  output: Output,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction { ..tx, outputs: tx.outputs |> list.concat([output]) }\n  }\n}\n\n/// Tx maniputlator - Set a fee to the transaction.\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> ...tx building methods\n///   |> complete()\n///   |> set_fee(condition, lovelace_fee)\n///   |> ...other tx maniputlator methods\n/// ```\npub fn set_fee(\n  tx: Transaction,\n  condition: Bool,\n  lovelace_fee: Int,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction { ..tx, fee: lovelace_fee }\n  }\n}\n\n/// Tx maniputlator - Add a mint to the transaction.\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> ...tx building methods\n///   |> complete()\n///   |> add_mint(condition, mint)\n///   |> ...other tx maniputlator methods\n/// ```\npub fn add_mint(tx: Transaction, condition: Bool, mint: Value) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction {\n      ..tx,\n      mint: tx.mint\n        |> merge(mint),\n    }\n  }\n}\n\n/// Tx maniputlator - Add a certificate to the transaction.\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> ...tx building methods\n///   |> complete()\n///   |> add_certificate(condition, certificate)\n///   |> ...other tx maniputlator methods\n/// ```\npub fn add_certificate(\n  tx: Transaction,\n  condition: Bool,\n  certificate: Certificate,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction {\n      ..tx,\n      certificates: tx.certificates |> list.concat([certificate]),\n    }\n  }\n}\n\n/// Tx maniputlator - Add a withdrawal to the transaction.\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> ...tx building methods\n///   |> complete()\n///   |> add_withdrawal(condition, stake_credential, amount)\n///   |> ...other tx maniputlator methods\n/// ```\npub fn add_withdrawal(\n  tx: Transaction,\n  condition: Bool,\n  withdrawal: Pair<Credential, Int>,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction {\n      ..tx,\n      withdrawals: tx.withdrawals |> list.concat([withdrawal]),\n    }\n  }\n}\n\n/// Tx maniputlator - Add an extra signatory to the transaction.\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> ...tx building methods\n///   |> complete()\n///   |> add_extra_signatory(condition, signatory)\n///   |> ...other tx maniputlator methods\n/// ```\npub fn add_extra_signatory(\n  tx: Transaction,\n  condition: Bool,\n  signatory: VerificationKeyHash,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction {\n      ..tx,\n      extra_signatories: tx.extra_signatories |> list.concat([signatory]),\n    }\n  }\n}\n\n/// Tx maniputlator - Add a redeemer to the transaction.\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> ...tx building methods\n///   |> complete()\n///   |> add_redeemer(condition, redeemer)\n///   |> ...other tx maniputlator methods\n/// ```\npub fn add_redeemer(\n  tx: Transaction,\n  condition: Bool,\n  redeemer: Pair<ScriptPurpose, Redeemer>,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction { ..tx, redeemers: tx.redeemers |> list.concat([redeemer]) }\n  }\n}\n\n/// Tx maniputlator - Add a datum to the transaction.\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> ...tx building methods\n///   |> complete()\n///   |> add_datum(condition, datum)\n///   |> ...other tx maniputlator methods\n/// ```\npub fn add_datum(tx: Transaction, condition: Bool, datum: Data) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    let datum_hash = blake2b_256(cbor.serialise(datum))\n    Transaction { ..tx, datums: tx.datums |> dict.insert(datum_hash, datum) }\n  }\n}\n\n/// Tx maniputlator - Set the transaction id.\n/// This function will only run when the condition is `True`.\n/// ```aiken\n/// let tx = mocktail_tx()\n///   |> ...tx building methods\n///   |> complete()\n///   |> set_transaction_id(condition, transaction_id)\n///   |> ...other tx maniputlator methods\n/// ```\npub fn set_transaction_id(\n  tx: Transaction,\n  condition: Bool,\n  transaction_id: TransactionId,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction { ..tx, id: transaction_id }\n  }\n}\n\n// Address\n\n/// Documentation please refer to [`virgin_address`](./mocktail/virgin_address.html)\npub const mock_verfication_key_credential =\n  virgin_address.mock_verfication_key_credential\n\n/// Documentation please refer to [`virgin_address`](./mocktail/virgin_address.html)\npub const mock_pub_key_address = virgin_address.mock_pub_key_address\n\n/// Documentation please refer to [`virgin_address`](./mocktail/virgin_address.html)\npub const mock_script_credential = virgin_address.mock_script_credential\n\n/// Documentation please refer to [`virgin_address`](./mocktail/virgin_address.html)\npub const mock_script_address = virgin_address.mock_script_address\n\n// Key hash\n\n/// Documentation please refer to [`virgin_key_hash`](./mocktail/virgin_key_hash.html)\npub const mock_key_hash = virgin_key_hash.mock_key_hash\n\n/// Documentation please refer to [`virgin_key_hash`](./mocktail/virgin_key_hash.html)\npub const mock_policy_id = virgin_key_hash.mock_policy_id\n\n/// Documentation please refer to [`virgin_key_hash`](./mocktail/virgin_key_hash.html)\npub const mock_pub_key_hash = virgin_key_hash.mock_pub_key_hash\n\n/// Documentation please refer to [`virgin_key_hash`](./mocktail/virgin_key_hash.html)\npub const mock_script_hash = virgin_key_hash.mock_script_hash\n\n/// Documentation please refer to [`virgin_key_hash`](./mocktail/virgin_key_hash.html)\npub const mock_stake_key_hash = virgin_key_hash.mock_stake_key_hash\n\n/// Documentation please refer to [`virgin_key_hash`](./mocktail/virgin_key_hash.html)\npub const mock_script_stake_key_hash =\n  virgin_key_hash.mock_script_stake_key_hash\n\n// Output reference\n\n/// Documentation please refer to [`virgin_output_reference`](./mocktail/virgin_output_reference.html)\npub const mock_tx_hash = virgin_output_reference.mock_tx_hash\n\n/// Documentation please refer to [`virgin_output_reference`](./mocktail/virgin_output_reference.html)\npub const mock_utxo_ref = virgin_output_reference.mock_utxo_ref\n\n// Outputs\n\n/// Documentation please refer to [`virgin_outputs`](./mocktail/virgin_outputs.html)\npub const mock_output = virgin_outputs.mock_output\n\n/// Documentation please refer to [`virgin_outputs`](./mocktail/virgin_outputs.html)\npub const mock_pub_key_output = virgin_outputs.mock_pub_key_output\n\n/// Documentation please refer to [`virgin_outputs`](./mocktail/virgin_outputs.html)\npub const mock_script_output = virgin_outputs.mock_script_output\n\n// Validity range\n\n/// Documentation please refer to [`virgin_validity_range`](./mocktail/virgin_validity_range.html)\npub const mock_interval = virgin_validity_range.mock_interval\n\ntest preserve_tx_in_order() {\n  let tx: Transaction =\n    mocktail_tx()\n      |> tx_in(True, mock_tx_hash(0), 0, zero, mock_pub_key_address(0, None))\n      |> tx_in(True, mock_tx_hash(1), 1, zero, mock_pub_key_address(1, None))\n      |> complete()\n  expect [input1, input2] = tx.inputs\n  and {\n    input1.output_reference.transaction_id == mock_tx_hash(0),\n    input1.output_reference.output_index == 0,\n    input2.output_reference.transaction_id == mock_tx_hash(1),\n    input2.output_reference.output_index == 1,\n  }\n}\n",
      "dependencies": [
        "aiken/cbor",
        "aiken/collection/dict",
        "aiken/collection/list",
        "aiken/crypto",
        "aiken/interval",
        "cardano/address",
        "cardano/assets",
        "cardano/certificate",
        "mocktail/virgin_address",
        "mocktail/virgin_key_hash",
        "mocktail/virgin_output_reference",
        "mocktail/virgin_outputs",
        "mocktail/virgin_validity_range"
      ],
      "source": "vodka",
      "isReExportFile": true
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-design-patterns/lib/aiken-design-patterns/linked-list/ordered.ak",
      "name": "aiken-design-patterns.linked-list.ordered",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 1,
          "raw": "use aiken/builtin",
          "source": "anastasia"
        },
        {
          "module": "aiken/collection/dict",
          "items": ["Dict", "has_key"],
          "line": 2,
          "raw": "use aiken/collection/dict.{Dict, has_key}",
          "source": "anastasia"
        },
        {
          "module": "aiken/collection/list",
          "items": [],
          "line": 3,
          "raw": "use aiken/collection/list",
          "source": "anastasia"
        },
        {
          "module": "aiken/primitive/bytearray",
          "items": [],
          "line": 4,
          "raw": "use aiken/primitive/bytearray",
          "source": "anastasia"
        },
        {
          "module": "cardano/assets",
          "items": [
            "AssetName",
            "PolicyId",
            "Value",
            "flatten",
            "quantity_of",
            "to_dict"
          ],
          "line": 5,
          "raw": "use cardano/assets.{AssetName, PolicyId, Value, flatten, quantity_of, to_dict}",
          "source": "anastasia"
        },
        {
          "module": "cardano/transaction",
          "items": ["InlineDatum", "Input", "Output"],
          "line": 6,
          "raw": "use cardano/transaction.{InlineDatum, Input, Output}",
          "source": "anastasia"
        }
      ],
      "functions": [
        {
          "name": "get_raw_key_and_link",
          "signature": "pub fn get_raw_key_and_link(node_output: Output) -> (Data, Data) {",
          "parameters": [
            {
              "name": "node_output",
              "type": "Output",
              "optional": false
            }
          ],
          "returnType": "(Data, Data)",
          "line": 30,
          "raw": "pub fn get_raw_key_and_link(node_output: Output) -> (Data, Data) {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn get_raw_key_and_link(node_output: Output) -> (Data, Data) {\n  expect InlineDatum(node_output_datum) = node_output.datum\n  let constr = builtin.un_constr_data(node_output_datum).2nd\n  let key = builtin.head_list(constr)\n  let link = builtin.head_list(builtin.tail_list(constr))\n  (key, link)\n}"
        },
        {
          "name": "get_key",
          "signature": "pub fn get_key(raw_key_and_link: (Data, Data)) -> NodeKey {",
          "parameters": [
            {
              "name": "raw_key_and_link",
              "type": "(Data, Data",
              "optional": false
            }
          ],
          "returnType": "NodeKey",
          "line": 38,
          "raw": "pub fn get_key(raw_key_and_link: (Data, Data)) -> NodeKey {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn get_key(raw_key_and_link: (Data, Data)) -> NodeKey {\n  expect key: NodeKey = raw_key_and_link.1st\n  key\n}"
        },
        {
          "name": "get_link",
          "signature": "pub fn get_link(raw_key_and_link: (Data, Data)) -> NodeKey {",
          "parameters": [
            {
              "name": "raw_key_and_link",
              "type": "(Data, Data",
              "optional": false
            }
          ],
          "returnType": "NodeKey",
          "line": 43,
          "raw": "pub fn get_link(raw_key_and_link: (Data, Data)) -> NodeKey {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn get_link(raw_key_and_link: (Data, Data)) -> NodeKey {\n  expect link: NodeKey = raw_key_and_link.2nd\n  link\n}"
        },
        {
          "name": "get_key_and_link",
          "signature": "pub fn get_key_and_link(node_output: Output) -> (NodeKey, NodeKey) {",
          "parameters": [
            {
              "name": "node_output",
              "type": "Output",
              "optional": false
            }
          ],
          "returnType": "(NodeKey, NodeKey)",
          "line": 48,
          "raw": "pub fn get_key_and_link(node_output: Output) -> (NodeKey, NodeKey) {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn get_key_and_link(node_output: Output) -> (NodeKey, NodeKey) {\n  let raw = get_raw_key_and_link(node_output)\n  (get_key(raw), get_link(raw))\n}"
        },
        {
          "name": "serialize_key",
          "signature": "pub fn serialize_key(key: NodeKey) -> ByteArray {",
          "parameters": [
            {
              "name": "key",
              "type": "NodeKey",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 53,
          "raw": "pub fn serialize_key(key: NodeKey) -> ByteArray {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn serialize_key(key: NodeKey) -> ByteArray {\n  when key is {\n    Empty -> node_prefix\n    Key(actual_key) -> bytearray.concat(node_prefix, actual_key)\n  }\n}"
        },
        {
          "name": "get_node_outputs",
          "signature": "pub fn get_node_outputs(pub fn get_node_outputs(outputs: List<Output>, policy_id: PolicyId, ) -> List<Output> {",
          "parameters": [],
          "returnType": "List<Output>",
          "line": 60,
          "raw": "pub fn get_node_outputs(pub fn get_node_outputs(outputs: List<Output>, policy_id: PolicyId, ) -> List<Output> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn get_node_outputs(\n  outputs: List<Output>,\n  policy_id: PolicyId,\n) -> List<Output> {\n  outputs\n    |> list.filter(\n        fn(output) {\n          let Output { value, .. } = output\n          has_data_cs(policy_id, value)\n        },\n      )\n}"
        },
        {
          "name": "get_node_inputs",
          "signature": "pub fn get_node_inputs(inputs: List<Input>, policy_id: PolicyId) -> List<Output> {",
          "parameters": [
            {
              "name": "inputs",
              "type": "List<Input>",
              "optional": false
            },
            {
              "name": "policy_id",
              "type": "PolicyId",
              "optional": false
            }
          ],
          "returnType": "List<Output>",
          "line": 73,
          "raw": "pub fn get_node_inputs(inputs: List<Input>, policy_id: PolicyId) -> List<Output> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn get_node_inputs(inputs: List<Input>, policy_id: PolicyId) -> List<Output> {\n  filter_map_pre(\n    inputs,\n    fn(output) {\n      let Output { value, .. } = output\n      has_data_cs(policy_id, value)\n    },\n    fn(input) {\n      let Input { output, .. } = input\n      output\n    },\n  )\n}"
        },
        {
          "name": "prove_is_root_node",
          "signature": "pub fn prove_is_root_node(policy_id: PolicyId, node: Output) -> Bool {",
          "documentation": "Prove that a node belongs to the given list and is its root.",
          "parameters": [
            {
              "name": "policy_id",
              "type": "PolicyId",
              "optional": false
            },
            {
              "name": "node",
              "type": "Output",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 90,
          "raw": "pub fn prove_is_root_node(policy_id: PolicyId, node: Output) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn prove_is_root_node(policy_id: PolicyId, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_root_node(node_datum.key)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, node_prefix) == 1\n  // Done.\n  True\n}"
        },
        {
          "name": "prove_is_last_node",
          "signature": "pub fn prove_is_last_node(policy_id: PolicyId, node: Output) -> Bool {",
          "documentation": "Prove that a node belongs to the given list and is its last node.",
          "parameters": [
            {
              "name": "policy_id",
              "type": "PolicyId",
              "optional": false
            },
            {
              "name": "node",
              "type": "Output",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 102,
          "raw": "pub fn prove_is_last_node(policy_id: PolicyId, node: Output) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn prove_is_last_node(policy_id: PolicyId, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_last_node(node_datum.link)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, serialize_key(node_datum.key)) == 1\n  // Done.\n  True\n}"
        },
        {
          "name": "prove_is_empty_list",
          "signature": "pub fn prove_is_empty_list(policy_id: PolicyId, node: Output) -> Bool {",
          "documentation": "Prove that the given list is empty, as witnessed by a node that\nis both the root and last node of the list.",
          "parameters": [
            {
              "name": "policy_id",
              "type": "PolicyId",
              "optional": false
            },
            {
              "name": "node",
              "type": "Output",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 115,
          "raw": "pub fn prove_is_empty_list(policy_id: PolicyId, node: Output) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn prove_is_empty_list(policy_id: PolicyId, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_empty_list(node_datum.key, node_datum.link)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, node_prefix) == 1\n  // Done.\n  True\n}"
        },
        {
          "name": "prove_is_member",
          "signature": "pub fn prove_is_member(policy_id: PolicyId, key: NodeKey, node: Output) -> Bool {",
          "documentation": "Prove that a key is a member of the given list, as witnessed by a node\nthat satisfies the membership predicate with the key.",
          "parameters": [
            {
              "name": "policy_id",
              "type": "PolicyId",
              "optional": false
            },
            {
              "name": "key",
              "type": "NodeKey",
              "optional": false
            },
            {
              "name": "node",
              "type": "Output",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 128,
          "raw": "pub fn prove_is_member(policy_id: PolicyId, key: NodeKey, node: Output) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn prove_is_member(policy_id: PolicyId, key: NodeKey, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_member(key, node_datum.key)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, serialize_key(key)) == 1\n  // Done.\n  True\n}"
        },
        {
          "name": "prove_is_not_member",
          "signature": "pub fn prove_is_not_member(pub fn prove_is_not_member(policy_id: PolicyId, key: NodeKey, node: Output, ) -> Bool {",
          "documentation": "Prove that a key is a member of the given list, as witnessed by a node\nthat satisfies the non-membership predicate with the key.",
          "parameters": [],
          "returnType": "Bool",
          "line": 141,
          "raw": "pub fn prove_is_not_member(pub fn prove_is_not_member(policy_id: PolicyId, key: NodeKey, node: Output, ) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn prove_is_not_member(\n  policy_id: PolicyId,\n  key: NodeKey,\n  node: Output,\n) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_not_member(key, node_datum.key, node_datum.link)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, serialize_key(node_datum.key)) == 1\n  // Done.\n  True\n}"
        },
        {
          "name": "list_state_transition",
          "signature": "pub fn list_state_transition(node_mint: Dict<AssetName, Int>) -> Bool {",
          "documentation": "Detect whether the list's minting policy is invoked in the transaction,\nso that the spending validator can forward to it.",
          "parameters": [
            {
              "name": "node_mint",
              "type": "Dict<AssetName, Int>",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 160,
          "raw": "pub fn list_state_transition(node_mint: Dict<AssetName, Int>) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn list_state_transition(node_mint: Dict<AssetName, Int>) -> Bool {\n  // 1. Tokens of the list's minting policy must be minted or burned.\n  dict.is_empty(node_mint) == False\n}"
        },
        {
          "name": "modify_data",
          "signature": "pub fn modify_data(pub fn modify_data(node_mint: Dict<AssetName, Int>, own_input: Output, own_output: Output, node_nft_policy_id: ByteArray, node_nft_asset_name: ByteArray, ) -> Bool {",
          "documentation": "Modify the `data` field of a list node without changing the `key` and\n`link` fields.",
          "parameters": [],
          "returnType": "Bool",
          "line": 167,
          "raw": "pub fn modify_data(pub fn modify_data(node_mint: Dict<AssetName, Int>, own_input: Output, own_output: Output, node_nft_policy_id: ByteArray, node_nft_asset_name: ByteArray, ) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn modify_data(\n  node_mint: Dict<AssetName, Int>,\n  own_input: Output,\n  own_output: Output,\n  node_nft_policy_id: ByteArray,\n  node_nft_asset_name: ByteArray,\n) -> Bool {\n  // 1. Tokens of the list's minting policy must *not* be minted or burned.\n  expect dict.is_empty(node_mint)\n\n  // 2. Let own_input be the node utxo input for which this rule is evaluated.\n  // 3. Let own_output be an output of the transaction indicated by the redeemer\n  //    of the spending validator.\n  // 4. The node NFT of the list must be present in own_input.\n  expect\n    quantity_of(own_input.value, node_nft_policy_id, node_nft_asset_name) == 1\n\n  // 5. The value must match in own_input and own_output.\n  expect own_input.value == own_output.value\n\n  // 6. The key and link fields must match in own_input and own_output.\n  let input_key_and_link = get_raw_key_and_link(own_input)\n  let output_key_and_link = get_raw_key_and_link(own_output)\n  expect input_key_and_link == output_key_and_link\n\n  // Done.\n  True\n}"
        },
        {
          "name": "init",
          "signature": "pub fn init(pub fn init(node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, node_cs: ByteArray, ) -> Bool {",
          "documentation": "Initialize an empty unordered list.\n\nApplication code must ensure that this action can happen only once.",
          "parameters": [],
          "returnType": "Bool",
          "line": 201,
          "raw": "pub fn init(pub fn init(node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, node_cs: ByteArray, ) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn init(\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n  node_cs: ByteArray,\n) -> Bool {\n  // 1. The transaction's sole effect on the list is to add the root key.\n  expect key_added(Empty, node_mint)\n\n  // 2. The list must be empty after the transaction, as proved by an output\n  // root_node that holds the minted root node NFT.\n  expect Some(root_node) = list.head(node_outputs)\n  let raw_key_and_link = get_raw_key_and_link(root_node)\n  expect is_empty_list(get_key(raw_key_and_link), get_link(raw_key_and_link))\n  expect quantity_of(root_node.value, node_cs, node_prefix) == 1\n\n  // 3. The root_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(root_node.value)) == 2\n\n  // Done.\n  True\n}"
        },
        {
          "name": "deinit",
          "signature": "pub fn deinit(pub fn deinit(node_inputs: List<Output>, node_mint: Dict<AssetName, Int>, node_cs: ByteArray, ) -> Bool {",
          "documentation": "Deinitialize an empty unordered list.",
          "parameters": [],
          "returnType": "Bool",
          "line": 224,
          "raw": "pub fn deinit(pub fn deinit(node_inputs: List<Output>, node_mint: Dict<AssetName, Int>, node_cs: ByteArray, ) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn deinit(\n  node_inputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n  node_cs: ByteArray,\n) -> Bool {\n  // 1. The transaction's sole effect on the list is to remove the root key.\n  expect key_removed(Empty, node_mint)\n\n  // 2. The list must be empty before the transaction, as proved by an input\n  //    root_node that holds the minted root node NFT.\n  expect Some(root_node) = list.head(node_inputs)\n  let raw_key_and_link = get_raw_key_and_link(root_node)\n  expect is_empty_list(get_key(raw_key_and_link), get_link(raw_key_and_link))\n  expect quantity_of(root_node.value, node_cs, node_prefix) == 1\n\n  // Done.\n  True\n}"
        },
        {
          "name": "prepend",
          "signature": "pub fn prepend(pub fn prepend(key_to_prepend: NodeKey, prepended_node_index: Int, anchor_node_output_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
          "documentation": "Prepend a new node to the beginning of the list.\n\nThe index arguments in this function are relative to the node_inputs\nand node_outputs. They are NOT absolute.",
          "parameters": [],
          "returnType": "Bool",
          "line": 247,
          "raw": "pub fn prepend(pub fn prepend(key_to_prepend: NodeKey, prepended_node_index: Int, anchor_node_output_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn prepend(\n  key_to_prepend: NodeKey,\n  prepended_node_index: Int,\n  anchor_node_output_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify the mint:\n  // 1. Let key_to_prepend be the key being prepended.\n  // 2. The transaction's sole effect on the list is to add key_to_prepend.\n  expect key_added(key_to_prepend, node_mint)\n\n  // Verify the inputs:\n  // 3. node_inputs must be a singleton. Let anchor_node_input be its sole node.\n  expect list.length(node_inputs) == 1\n  expect Some(anchor_node_input) = list.head(node_inputs)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n\n  // 4. anchor_node_input must be the root node of the list.\n  expect is_root_node(parsed_anchor_node_input_datum.key)\n\n  // Verify the outputs:\n  // 5. node_outputs must have exactly two nodes: prepended_node and anchor_node_output.\n  expect list.length(node_outputs) == 2\n  expect Some(prepended_node) = list.at(node_outputs, prepended_node_index)\n  let prepended_node_raw_key_and_link = get_raw_key_and_link(prepended_node)\n  expect Some(anchor_node_output) =\n    list.at(node_outputs, anchor_node_output_index)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 6. key_to_prepend must be a member of the list after the transaction,\n  //    as witnessed by prepended_node.\n  expect is_member(key_to_prepend, get_key(prepended_node_raw_key_and_link))\n\n  // 7. anchor_node input and prepended node must match on the link_field.\n  //    In other words, they must both link to the same key.\n  expect\n    parsed_anchor_node_input_datum.link == get_link(\n      prepended_node_raw_key_and_link,\n    )\n\n  // 8. anchor_node_output must link to key_to_prepend.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: key_to_prepend,\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // 9. prepended_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(prepended_node.value)) == 2\n\n  // Verify immutable data:\n  // 10. anchor node input must match anchor node output on address, value,\n  //     and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // 11. prepended_node must match anchor_node_output on address.\n  expect prepended_node.address == anchor_node_output.address\n\n  // 12. key_to_prepend must not be a member of the list before the transaction,\n  //     as witnessed by anchor_node_input.\n  expect\n    is_not_member(\n      key_to_prepend,\n      node_key: parsed_anchor_node_input_datum.key,\n      node_link: parsed_anchor_node_input_datum.link,\n    )\n\n  // Done.\n  True\n}"
        },
        {
          "name": "append",
          "signature": "pub fn append(pub fn append(key_to_append: NodeKey, appended_node_index: Int, anchor_node_output_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
          "documentation": "Append a new node to the end of the list.\n\nThe index arguments in this function are relative to the node_inputs\nand node_outputs. They are NOT absolute.",
          "parameters": [],
          "returnType": "Bool",
          "line": 329,
          "raw": "pub fn append(pub fn append(key_to_append: NodeKey, appended_node_index: Int, anchor_node_output_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn append(\n  key_to_append: NodeKey,\n  appended_node_index: Int,\n  anchor_node_output_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify the mint:\n  // 1. Let key_to_append be the key being appended.\n  // 2. The transaction's sole effect on the list is to add key_to_append.\n  expect key_added(key_to_append, node_mint)\n\n  // 3. node_inputs must be a singleton. Let anchor_node_input be its sole node.\n  expect list.length(node_inputs) == 1\n  expect Some(anchor_node_input) = list.head(node_inputs)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n  let anchor_node_raw_key_and_link = get_raw_key_and_link(anchor_node_input)\n\n  // 4. anchor_node_input must be the last node of the list before the transaction.\n  expect is_last_node(get_link(anchor_node_raw_key_and_link))\n\n  // Verify the outputs:\n  // 5. node_outputs must have exactly two nodes: appended_node and anchor_node_output.\n  expect list.length(node_outputs) == 2\n  expect Some(appended_node) = list.at(node_outputs, appended_node_index)\n  let appended_node_raw_key_and_link = get_raw_key_and_link(appended_node)\n  expect Some(anchor_node_output) =\n    list.at(node_outputs, anchor_node_output_index)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 6. key_to_append must be a member of the list after the transaction,\n  //    as witnessed by appended_node.\n  expect is_member(key_to_append, get_key(appended_node_raw_key_and_link))\n\n  // 7. appended_node must be the last node of the list after the transaction.\n  expect is_last_node(get_link(appended_node_raw_key_and_link))\n\n  // 8. anchor node output must link to key to append.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: key_to_append,\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // 9. appended_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(appended_node.value)) == 2\n\n  // Verify immutable data:\n  // 10. anchor_node input must match anchor_node output on address, value,\n  //     and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // 11. appended_node must match anchor_node_output on address.\n  expect appended_node.address == anchor_node_output.address\n\n  // 12. key_to_append must not be a member of the list before the transaction,\n  //     as witnessed by anchor_node_input.\n  expect\n    is_not_member(\n      key_to_append,\n      node_key: parsed_anchor_node_input_datum.key,\n      node_link: parsed_anchor_node_input_datum.link,\n    )\n\n  // Done.\n  True\n}"
        },
        {
          "name": "insert",
          "signature": "pub fn insert(pub fn insert(key_to_insert: NodeKey, inserted_node_output_index: Int, anchor_node_output_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
          "documentation": "Insert a node into the list.\n\nThe index arguments in this function are relative to the node_inputs\nand node_outputs. They are NOT absolute.",
          "parameters": [],
          "returnType": "Bool",
          "line": 407,
          "raw": "pub fn insert(pub fn insert(key_to_insert: NodeKey, inserted_node_output_index: Int, anchor_node_output_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn insert(\n  key_to_insert: NodeKey,\n  inserted_node_output_index: Int,\n  anchor_node_output_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify mint:\n  // 1. Let key_to_insert be the key being inserted.\n  // 2. The transaction’s sole effect on the list is to add key_to_insert.\n  expect key_added(key_to_insert, node_mint)\n\n  // Verify inputs:\n  // 3. node_inputs must be a singleton. Let anchor_node_input be its sole node.\n  expect list.length(node_inputs) == 1\n  expect Some(anchor_node_input) = list.head(node_inputs)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n\n  // 4. key_to_insert must not be a member of the list before the transaction,\n  //    as witnessed by anchor_node_input.\n  expect\n    is_not_member(\n      key_to_insert,\n      parsed_anchor_node_input_datum.key,\n      parsed_anchor_node_input_datum.link,\n    )\n\n  // Verify outputs:\n  // 5. node_outputs must have exactly two nodes: inserted_node and anchor_node_output.\n  expect list.length(node_outputs) == 2\n  expect Some(inserted_node_output) =\n    list.at(node_outputs, inserted_node_output_index)\n  let inserted_node_output_raw_key_and_link =\n    get_raw_key_and_link(inserted_node_output)\n  expect Some(anchor_node_output) =\n    list.at(node_outputs, anchor_node_output_index)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 6. key_to_insert must be a member of the list after the transaction,\n  //    as witnessed by inserted_node.\n  expect\n    is_member(key_to_insert, get_key(inserted_node_output_raw_key_and_link))\n\n  // 7. anchor_node output must link to key_to_insert.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: key_to_insert,\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // 8. anchor_node_input and inserted_node must match on the link field.\n  //    In other words, they must both link to the same key.\n  expect\n    parsed_anchor_node_input_datum.link == get_link(\n      inserted_node_output_raw_key_and_link,\n    )\n\n  // 9. inserted_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(inserted_node_output.value)) == 2\n\n  // Verify immutable data:\n  // 10. anchor_node_input must match anchor node output on address, value,\n  //     and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // 11. inserted_node must match anchor_node_output on address.\n  expect inserted_node_output.address == anchor_node_output.address\n\n  // Done.\n  True\n}"
        },
        {
          "name": "remove",
          "signature": "pub fn remove(pub fn remove(key_to_remove: NodeKey, removed_node_input_index: Int, anchor_node_input_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
          "documentation": "Remove a non-root node from the list.\n\nThe index arguments in this function are relative to the node_inputs\nand node_outputs. They are NOT absolute.",
          "parameters": [],
          "returnType": "Bool",
          "line": 489,
          "raw": "pub fn remove(pub fn remove(key_to_remove: NodeKey, removed_node_input_index: Int, anchor_node_input_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn remove(\n  key_to_remove: NodeKey,\n  removed_node_input_index: Int,\n  anchor_node_input_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify the mint:\n  // 1. Let key_to_remove be the key being removed.\n  // 2. The transaction's sole effect on the list is to remove key_to_remove.\n  expect key_removed(key_to_remove, node_mint)\n\n  // Verify the inputs:\n  // 3. node_inputs must have exactly two nodes: removed_node and anchor_node_input.\n  expect list.length(node_inputs) == 2\n  expect Some(removed_node_input) =\n    list.at(node_inputs, removed_node_input_index)\n  let removed_node_raw_key_and_link = get_raw_key_and_link(removed_node_input)\n  expect Some(anchor_node_input) = list.at(node_inputs, anchor_node_input_index)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n\n  // 4. key_to_remove must be a member of the list before the transaction,\n  //    as witnessed by removed_node.\n  expect is_member(key_to_remove, get_key(removed_node_raw_key_and_link))\n\n  // 5. anchor_node_input must link to key_to_remove.\n  expect parsed_anchor_node_input_datum.link == key_to_remove\n\n  // Verify the outputs:\n  // 6. node_outputs must be a singleton. Let anchor_node_output be its sole node.\n  expect list.length(node_outputs) == 1\n  expect Some(anchor_node_output) = list.head(node_outputs)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 7. anchor_node_output and removed_node must match on the link field.\n  //    In other words, they must both link to the same key.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: get_link(removed_node_raw_key_and_link),\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // Verify immutable data:\n  // 8. anchor_node_input must match anchor_node_output on address, value,\n  //    and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // Done.\n  True\n}"
        }
      ],
      "types": [
        {
          "name": "NodeDatum",
          "definition": "{ key: NodeKey, link: NodeKey, data: Data, }",
          "line": 18,
          "raw": "pub type NodeDatum {",
          "isPublic": true,
          "source": "anastasia"
        },
        {
          "name": "NodeKey",
          "definition": "{ Key { key: ByteArray } Empty }",
          "line": 25,
          "raw": "pub type NodeKey {",
          "isPublic": true,
          "source": "anastasia"
        }
      ],
      "constants": [
        {
          "name": "node_prefix",
          "type": "ByteArray",
          "value": "\"Node\"",
          "line": 11,
          "raw": "pub const node_prefix: ByteArray = \"Node\"",
          "isPublic": true,
          "source": "anastasia"
        }
      ],
      "atoms": [
        {
          "name": "filter_map_pre",
          "signature": "fn filter_map_pre(fn filter_map_pre(self: List<a>, predicate: fn(b) -> Bool, transform: fn(a) -> b,",
          "parameters": [],
          "returnType": "Bool, transform: fn(a) -> b,",
          "line": 553,
          "raw": "fn filter_map_pre(fn filter_map_pre(self: List<a>, predicate: fn(b) -> Bool, transform: fn(a) -> b,",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn filter_map_pre(\n  self: List<a>,\n  predicate: fn(b) -> Bool,\n  transform: fn(a) -> b,\n) -> List<b> {\n  when self is {\n    [] -> []\n    [x, ..xs] -> {\n      let y = transform(x)\n      if predicate(y) {\n        [y, ..filter_map_pre(xs, predicate, transform)]\n      } else {\n        filter_map_pre(xs, predicate, transform)\n      }\n    }\n  }\n}"
        },
        {
          "name": "filter_map_post",
          "signature": "fn filter_map_post(fn filter_map_post(self: List<a>, predicate: fn(a) -> Bool, transform: fn(a) -> b,",
          "parameters": [],
          "returnType": "Bool, transform: fn(a) -> b,",
          "line": 572,
          "raw": "fn filter_map_post(fn filter_map_post(self: List<a>, predicate: fn(a) -> Bool, transform: fn(a) -> b,",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn filter_map_post(\n  self: List<a>,\n  predicate: fn(a) -> Bool,\n  transform: fn(a) -> b,\n) -> List<b> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      if predicate(x) {\n        [transform(x), ..filter_map_post(xs, predicate, transform)]\n      } else {\n        filter_map_post(xs, predicate, transform)\n      }\n  }\n}"
        },
        {
          "name": "has_data_cs",
          "signature": "fn has_data_cs(cs: PolicyId, value: Value) -> Bool {",
          "parameters": [
            {
              "name": "cs",
              "type": "PolicyId",
              "optional": false
            },
            {
              "name": "value",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 589,
          "raw": "fn has_data_cs(cs: PolicyId, value: Value) -> Bool {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn has_data_cs(cs: PolicyId, value: Value) -> Bool {\n  value\n    |> to_dict()\n    |> has_key(cs)\n}"
        },
        {
          "name": "is_root_node",
          "signature": "fn is_root_node(node_key: NodeKey) -> Bool {",
          "parameters": [
            {
              "name": "node_key",
              "type": "NodeKey",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 595,
          "raw": "fn is_root_node(node_key: NodeKey) -> Bool {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn is_root_node(node_key: NodeKey) -> Bool {\n  node_key == Empty\n}"
        },
        {
          "name": "is_last_node",
          "signature": "fn is_last_node(node_link: NodeKey) -> Bool {",
          "parameters": [
            {
              "name": "node_link",
              "type": "NodeKey",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 599,
          "raw": "fn is_last_node(node_link: NodeKey) -> Bool {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn is_last_node(node_link: NodeKey) -> Bool {\n  node_link == Empty\n}"
        },
        {
          "name": "is_empty_list",
          "signature": "fn is_empty_list(node_key: NodeKey, node_link: NodeKey) -> Bool {",
          "parameters": [
            {
              "name": "node_key",
              "type": "NodeKey",
              "optional": false
            },
            {
              "name": "node_link",
              "type": "NodeKey",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 603,
          "raw": "fn is_empty_list(node_key: NodeKey, node_link: NodeKey) -> Bool {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn is_empty_list(node_key: NodeKey, node_link: NodeKey) -> Bool {\n  and {\n    is_root_node(node_key),\n    is_last_node(node_link),\n  }\n}"
        },
        {
          "name": "key_added",
          "signature": "fn key_added(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {",
          "parameters": [
            {
              "name": "key",
              "type": "NodeKey",
              "optional": false
            },
            {
              "name": "node_mint",
              "type": "Dict<AssetName, Int>",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 610,
          "raw": "fn key_added(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn key_added(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {\n  and {\n    dict.size(node_mint) == 1,\n    dict.get(node_mint, serialize_key(key)) == Some(1),\n  }\n}"
        },
        {
          "name": "key_removed",
          "signature": "fn key_removed(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {",
          "parameters": [
            {
              "name": "key",
              "type": "NodeKey",
              "optional": false
            },
            {
              "name": "node_mint",
              "type": "Dict<AssetName, Int>",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 617,
          "raw": "fn key_removed(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn key_removed(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {\n  and {\n    dict.size(node_mint) == 1,\n    dict.get(node_mint, serialize_key(key)) == Some(-1),\n  }\n}"
        },
        {
          "name": "is_member",
          "signature": "fn is_member(k: NodeKey, node_key: NodeKey) -> Bool {",
          "parameters": [
            {
              "name": "k",
              "type": "NodeKey",
              "optional": false
            },
            {
              "name": "node_key",
              "type": "NodeKey",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 624,
          "raw": "fn is_member(k: NodeKey, node_key: NodeKey) -> Bool {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn is_member(k: NodeKey, node_key: NodeKey) -> Bool {\n  k == node_key\n}"
        },
        {
          "name": "is_not_member",
          "signature": "fn is_not_member(k: NodeKey, node_key: NodeKey, node_link: NodeKey) -> Bool {",
          "parameters": [
            {
              "name": "k",
              "type": "NodeKey",
              "optional": false
            },
            {
              "name": "node_key",
              "type": "NodeKey",
              "optional": false
            },
            {
              "name": "node_link",
              "type": "NodeKey",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 628,
          "raw": "fn is_not_member(k: NodeKey, node_key: NodeKey, node_link: NodeKey) -> Bool {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn is_not_member(k: NodeKey, node_key: NodeKey, node_link: NodeKey) -> Bool {\n  // k must contain a key.\n  expect Key(actual_k) = k\n  // k must be \"between\" the node's key and link.\n  and {\n    // The node is either the root node or its key is less than k.\n    when node_key is {\n      Empty -> True\n      Key(actual_node_key) ->\n        bytearray.compare(actual_node_key, actual_k) == Less\n    },\n    // The node is either the last node or k is less than its link.\n    when node_link is {\n      Empty -> True\n      Key(actual_node_link) ->\n        bytearray.compare(actual_k, actual_node_link) == Less\n    },\n  }\n}"
        }
      ],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/builtin\nuse aiken/collection/dict.{Dict, has_key}\nuse aiken/collection/list\nuse aiken/primitive/bytearray\nuse cardano/assets.{AssetName, PolicyId, Value, flatten, quantity_of, to_dict}\nuse cardano/transaction.{InlineDatum, Input, Output}\n\n// # Data types, constants, and accessors\n\n/// Every list node's token name starts with this prefix.\npub const node_prefix: ByteArray = \"Node\"\n\n/// Every list node utxo:\n/// - has a unique `key` (unless it's the root node)\n/// - has a unique `link` to another node's key \n///   (unless it's the last node of the list)\n/// - holds some app-specific `data`\npub type NodeDatum {\n  key: NodeKey,\n  link: NodeKey,\n  data: Data,\n}\n\n/// Same as `Option`, but with more informative constructor names.\npub type NodeKey {\n  Key { key: ByteArray }\n  Empty\n}\n\npub fn get_raw_key_and_link(node_output: Output) -> (Data, Data) {\n  expect InlineDatum(node_output_datum) = node_output.datum\n  let constr = builtin.un_constr_data(node_output_datum).2nd\n  let key = builtin.head_list(constr)\n  let link = builtin.head_list(builtin.tail_list(constr))\n  (key, link)\n}\n\npub fn get_key(raw_key_and_link: (Data, Data)) -> NodeKey {\n  expect key: NodeKey = raw_key_and_link.1st\n  key\n}\n\npub fn get_link(raw_key_and_link: (Data, Data)) -> NodeKey {\n  expect link: NodeKey = raw_key_and_link.2nd\n  link\n}\n\npub fn get_key_and_link(node_output: Output) -> (NodeKey, NodeKey) {\n  let raw = get_raw_key_and_link(node_output)\n  (get_key(raw), get_link(raw))\n}\n\npub fn serialize_key(key: NodeKey) -> ByteArray {\n  when key is {\n    Empty -> node_prefix\n    Key(actual_key) -> bytearray.concat(node_prefix, actual_key)\n  }\n}\n\npub fn get_node_outputs(\n  outputs: List<Output>,\n  policy_id: PolicyId,\n) -> List<Output> {\n  outputs\n    |> list.filter(\n        fn(output) {\n          let Output { value, .. } = output\n          has_data_cs(policy_id, value)\n        },\n      )\n}\n\npub fn get_node_inputs(inputs: List<Input>, policy_id: PolicyId) -> List<Output> {\n  filter_map_pre(\n    inputs,\n    fn(output) {\n      let Output { value, .. } = output\n      has_data_cs(policy_id, value)\n    },\n    fn(input) {\n      let Input { output, .. } = input\n      output\n    },\n  )\n}\n\n// ## Predicates (used outside of list validators)\n\n/// Prove that a node belongs to the given list and is its root.\npub fn prove_is_root_node(policy_id: PolicyId, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_root_node(node_datum.key)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, node_prefix) == 1\n  // Done.\n  True\n}\n\n/// Prove that a node belongs to the given list and is its last node.\npub fn prove_is_last_node(policy_id: PolicyId, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_last_node(node_datum.link)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, serialize_key(node_datum.key)) == 1\n  // Done.\n  True\n}\n\n/// Prove that the given list is empty, as witnessed by a node that\n/// is both the root and last node of the list.\npub fn prove_is_empty_list(policy_id: PolicyId, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_empty_list(node_datum.key, node_datum.link)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, node_prefix) == 1\n  // Done.\n  True\n}\n\n/// Prove that a key is a member of the given list, as witnessed by a node\n/// that satisfies the membership predicate with the key.\npub fn prove_is_member(policy_id: PolicyId, key: NodeKey, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_member(key, node_datum.key)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, serialize_key(key)) == 1\n  // Done.\n  True\n}\n\n/// Prove that a key is a member of the given list, as witnessed by a node\n/// that satisfies the non-membership predicate with the key.\npub fn prove_is_not_member(\n  policy_id: PolicyId,\n  key: NodeKey,\n  node: Output,\n) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_not_member(key, node_datum.key, node_datum.link)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, serialize_key(node_datum.key)) == 1\n  // Done.\n  True\n}\n\n// ## State integrity handlers (used in list spending validator)\n\n/// Detect whether the list's minting policy is invoked in the transaction,\n/// so that the spending validator can forward to it.\npub fn list_state_transition(node_mint: Dict<AssetName, Int>) -> Bool {\n  // 1. Tokens of the list's minting policy must be minted or burned.\n  dict.is_empty(node_mint) == False\n}\n\n/// Modify the `data` field of a list node without changing the `key` and\n/// `link` fields.\npub fn modify_data(\n  node_mint: Dict<AssetName, Int>,\n  own_input: Output,\n  own_output: Output,\n  node_nft_policy_id: ByteArray,\n  node_nft_asset_name: ByteArray,\n) -> Bool {\n  // 1. Tokens of the list's minting policy must *not* be minted or burned.\n  expect dict.is_empty(node_mint)\n\n  // 2. Let own_input be the node utxo input for which this rule is evaluated.\n  // 3. Let own_output be an output of the transaction indicated by the redeemer\n  //    of the spending validator.\n  // 4. The node NFT of the list must be present in own_input.\n  expect\n    quantity_of(own_input.value, node_nft_policy_id, node_nft_asset_name) == 1\n\n  // 5. The value must match in own_input and own_output.\n  expect own_input.value == own_output.value\n\n  // 6. The key and link fields must match in own_input and own_output.\n  let input_key_and_link = get_raw_key_and_link(own_input)\n  let output_key_and_link = get_raw_key_and_link(own_output)\n  expect input_key_and_link == output_key_and_link\n\n  // Done.\n  True\n}\n\n// ## State transition handlers (used in list minting policy)\n\n/// Initialize an empty unordered list.\n///\n/// Application code must ensure that this action can happen only once.\npub fn init(\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n  node_cs: ByteArray,\n) -> Bool {\n  // 1. The transaction's sole effect on the list is to add the root key.\n  expect key_added(Empty, node_mint)\n\n  // 2. The list must be empty after the transaction, as proved by an output\n  // root_node that holds the minted root node NFT.\n  expect Some(root_node) = list.head(node_outputs)\n  let raw_key_and_link = get_raw_key_and_link(root_node)\n  expect is_empty_list(get_key(raw_key_and_link), get_link(raw_key_and_link))\n  expect quantity_of(root_node.value, node_cs, node_prefix) == 1\n\n  // 3. The root_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(root_node.value)) == 2\n\n  // Done.\n  True\n}\n\n/// Deinitialize an empty unordered list.\npub fn deinit(\n  node_inputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n  node_cs: ByteArray,\n) -> Bool {\n  // 1. The transaction's sole effect on the list is to remove the root key.\n  expect key_removed(Empty, node_mint)\n\n  // 2. The list must be empty before the transaction, as proved by an input\n  //    root_node that holds the minted root node NFT.\n  expect Some(root_node) = list.head(node_inputs)\n  let raw_key_and_link = get_raw_key_and_link(root_node)\n  expect is_empty_list(get_key(raw_key_and_link), get_link(raw_key_and_link))\n  expect quantity_of(root_node.value, node_cs, node_prefix) == 1\n\n  // Done.\n  True\n}\n\n/// Prepend a new node to the beginning of the list.\n///\n/// The index arguments in this function are relative to the node_inputs\n/// and node_outputs. They are NOT absolute.\npub fn prepend(\n  key_to_prepend: NodeKey,\n  prepended_node_index: Int,\n  anchor_node_output_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify the mint:\n  // 1. Let key_to_prepend be the key being prepended.\n  // 2. The transaction's sole effect on the list is to add key_to_prepend.\n  expect key_added(key_to_prepend, node_mint)\n\n  // Verify the inputs:\n  // 3. node_inputs must be a singleton. Let anchor_node_input be its sole node.\n  expect list.length(node_inputs) == 1\n  expect Some(anchor_node_input) = list.head(node_inputs)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n\n  // 4. anchor_node_input must be the root node of the list.\n  expect is_root_node(parsed_anchor_node_input_datum.key)\n\n  // Verify the outputs:\n  // 5. node_outputs must have exactly two nodes: prepended_node and anchor_node_output.\n  expect list.length(node_outputs) == 2\n  expect Some(prepended_node) = list.at(node_outputs, prepended_node_index)\n  let prepended_node_raw_key_and_link = get_raw_key_and_link(prepended_node)\n  expect Some(anchor_node_output) =\n    list.at(node_outputs, anchor_node_output_index)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 6. key_to_prepend must be a member of the list after the transaction,\n  //    as witnessed by prepended_node.\n  expect is_member(key_to_prepend, get_key(prepended_node_raw_key_and_link))\n\n  // 7. anchor_node input and prepended node must match on the link_field.\n  //    In other words, they must both link to the same key.\n  expect\n    parsed_anchor_node_input_datum.link == get_link(\n      prepended_node_raw_key_and_link,\n    )\n\n  // 8. anchor_node_output must link to key_to_prepend.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: key_to_prepend,\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // 9. prepended_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(prepended_node.value)) == 2\n\n  // Verify immutable data:\n  // 10. anchor node input must match anchor node output on address, value,\n  //     and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // 11. prepended_node must match anchor_node_output on address.\n  expect prepended_node.address == anchor_node_output.address\n\n  // 12. key_to_prepend must not be a member of the list before the transaction,\n  //     as witnessed by anchor_node_input.\n  expect\n    is_not_member(\n      key_to_prepend,\n      node_key: parsed_anchor_node_input_datum.key,\n      node_link: parsed_anchor_node_input_datum.link,\n    )\n\n  // Done.\n  True\n}\n\n/// Append a new node to the end of the list.\n///\n/// The index arguments in this function are relative to the node_inputs\n/// and node_outputs. They are NOT absolute.\npub fn append(\n  key_to_append: NodeKey,\n  appended_node_index: Int,\n  anchor_node_output_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify the mint:\n  // 1. Let key_to_append be the key being appended.\n  // 2. The transaction's sole effect on the list is to add key_to_append.\n  expect key_added(key_to_append, node_mint)\n\n  // 3. node_inputs must be a singleton. Let anchor_node_input be its sole node.\n  expect list.length(node_inputs) == 1\n  expect Some(anchor_node_input) = list.head(node_inputs)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n  let anchor_node_raw_key_and_link = get_raw_key_and_link(anchor_node_input)\n\n  // 4. anchor_node_input must be the last node of the list before the transaction.\n  expect is_last_node(get_link(anchor_node_raw_key_and_link))\n\n  // Verify the outputs:\n  // 5. node_outputs must have exactly two nodes: appended_node and anchor_node_output.\n  expect list.length(node_outputs) == 2\n  expect Some(appended_node) = list.at(node_outputs, appended_node_index)\n  let appended_node_raw_key_and_link = get_raw_key_and_link(appended_node)\n  expect Some(anchor_node_output) =\n    list.at(node_outputs, anchor_node_output_index)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 6. key_to_append must be a member of the list after the transaction,\n  //    as witnessed by appended_node.\n  expect is_member(key_to_append, get_key(appended_node_raw_key_and_link))\n\n  // 7. appended_node must be the last node of the list after the transaction.\n  expect is_last_node(get_link(appended_node_raw_key_and_link))\n\n  // 8. anchor node output must link to key to append.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: key_to_append,\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // 9. appended_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(appended_node.value)) == 2\n\n  // Verify immutable data:\n  // 10. anchor_node input must match anchor_node output on address, value,\n  //     and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // 11. appended_node must match anchor_node_output on address.\n  expect appended_node.address == anchor_node_output.address\n\n  // 12. key_to_append must not be a member of the list before the transaction,\n  //     as witnessed by anchor_node_input.\n  expect\n    is_not_member(\n      key_to_append,\n      node_key: parsed_anchor_node_input_datum.key,\n      node_link: parsed_anchor_node_input_datum.link,\n    )\n\n  // Done.\n  True\n}\n\n/// Insert a node into the list.\n///\n/// The index arguments in this function are relative to the node_inputs\n/// and node_outputs. They are NOT absolute.\npub fn insert(\n  key_to_insert: NodeKey,\n  inserted_node_output_index: Int,\n  anchor_node_output_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify mint:\n  // 1. Let key_to_insert be the key being inserted.\n  // 2. The transaction’s sole effect on the list is to add key_to_insert.\n  expect key_added(key_to_insert, node_mint)\n\n  // Verify inputs:\n  // 3. node_inputs must be a singleton. Let anchor_node_input be its sole node.\n  expect list.length(node_inputs) == 1\n  expect Some(anchor_node_input) = list.head(node_inputs)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n\n  // 4. key_to_insert must not be a member of the list before the transaction,\n  //    as witnessed by anchor_node_input.\n  expect\n    is_not_member(\n      key_to_insert,\n      parsed_anchor_node_input_datum.key,\n      parsed_anchor_node_input_datum.link,\n    )\n\n  // Verify outputs:\n  // 5. node_outputs must have exactly two nodes: inserted_node and anchor_node_output.\n  expect list.length(node_outputs) == 2\n  expect Some(inserted_node_output) =\n    list.at(node_outputs, inserted_node_output_index)\n  let inserted_node_output_raw_key_and_link =\n    get_raw_key_and_link(inserted_node_output)\n  expect Some(anchor_node_output) =\n    list.at(node_outputs, anchor_node_output_index)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 6. key_to_insert must be a member of the list after the transaction,\n  //    as witnessed by inserted_node.\n  expect\n    is_member(key_to_insert, get_key(inserted_node_output_raw_key_and_link))\n\n  // 7. anchor_node output must link to key_to_insert.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: key_to_insert,\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // 8. anchor_node_input and inserted_node must match on the link field.\n  //    In other words, they must both link to the same key.\n  expect\n    parsed_anchor_node_input_datum.link == get_link(\n      inserted_node_output_raw_key_and_link,\n    )\n\n  // 9. inserted_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(inserted_node_output.value)) == 2\n\n  // Verify immutable data:\n  // 10. anchor_node_input must match anchor node output on address, value,\n  //     and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // 11. inserted_node must match anchor_node_output on address.\n  expect inserted_node_output.address == anchor_node_output.address\n\n  // Done.\n  True\n}\n\n/// Remove a non-root node from the list.\n///\n/// The index arguments in this function are relative to the node_inputs\n/// and node_outputs. They are NOT absolute.\npub fn remove(\n  key_to_remove: NodeKey,\n  removed_node_input_index: Int,\n  anchor_node_input_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify the mint:\n  // 1. Let key_to_remove be the key being removed.\n  // 2. The transaction's sole effect on the list is to remove key_to_remove.\n  expect key_removed(key_to_remove, node_mint)\n\n  // Verify the inputs:\n  // 3. node_inputs must have exactly two nodes: removed_node and anchor_node_input.\n  expect list.length(node_inputs) == 2\n  expect Some(removed_node_input) =\n    list.at(node_inputs, removed_node_input_index)\n  let removed_node_raw_key_and_link = get_raw_key_and_link(removed_node_input)\n  expect Some(anchor_node_input) = list.at(node_inputs, anchor_node_input_index)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n\n  // 4. key_to_remove must be a member of the list before the transaction,\n  //    as witnessed by removed_node.\n  expect is_member(key_to_remove, get_key(removed_node_raw_key_and_link))\n\n  // 5. anchor_node_input must link to key_to_remove.\n  expect parsed_anchor_node_input_datum.link == key_to_remove\n\n  // Verify the outputs:\n  // 6. node_outputs must be a singleton. Let anchor_node_output be its sole node.\n  expect list.length(node_outputs) == 1\n  expect Some(anchor_node_output) = list.head(node_outputs)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 7. anchor_node_output and removed_node must match on the link field.\n  //    In other words, they must both link to the same key.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: get_link(removed_node_raw_key_and_link),\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // Verify immutable data:\n  // 8. anchor_node_input must match anchor_node_output on address, value,\n  //    and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // Done.\n  True\n}\n\n// # Internal functions\n\n// Adapted from Aiken stdlib.collection.list.filter_map\n// Instead of using (predicate: fn(a) -> Option<a>)\n// We decompose it into two arguments.\n\n// In this variant, we apply the transform before the predicate.\nfn filter_map_pre(\n  self: List<a>,\n  predicate: fn(b) -> Bool,\n  transform: fn(a) -> b,\n) -> List<b> {\n  when self is {\n    [] -> []\n    [x, ..xs] -> {\n      let y = transform(x)\n      if predicate(y) {\n        [y, ..filter_map_pre(xs, predicate, transform)]\n      } else {\n        filter_map_pre(xs, predicate, transform)\n      }\n    }\n  }\n}\n\n// In this variant, we apply the transform after the predicate.\nfn filter_map_post(\n  self: List<a>,\n  predicate: fn(a) -> Bool,\n  transform: fn(a) -> b,\n) -> List<b> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      if predicate(x) {\n        [transform(x), ..filter_map_post(xs, predicate, transform)]\n      } else {\n        filter_map_post(xs, predicate, transform)\n      }\n  }\n}\n\n// Checks if a Currency Symbol is held within a Value\nfn has_data_cs(cs: PolicyId, value: Value) -> Bool {\n  value\n    |> to_dict()\n    |> has_key(cs)\n}\n\nfn is_root_node(node_key: NodeKey) -> Bool {\n  node_key == Empty\n}\n\nfn is_last_node(node_link: NodeKey) -> Bool {\n  node_link == Empty\n}\n\nfn is_empty_list(node_key: NodeKey, node_link: NodeKey) -> Bool {\n  and {\n    is_root_node(node_key),\n    is_last_node(node_link),\n  }\n}\n\nfn key_added(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {\n  and {\n    dict.size(node_mint) == 1,\n    dict.get(node_mint, serialize_key(key)) == Some(1),\n  }\n}\n\nfn key_removed(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {\n  and {\n    dict.size(node_mint) == 1,\n    dict.get(node_mint, serialize_key(key)) == Some(-1),\n  }\n}\n\nfn is_member(k: NodeKey, node_key: NodeKey) -> Bool {\n  k == node_key\n}\n\nfn is_not_member(k: NodeKey, node_key: NodeKey, node_link: NodeKey) -> Bool {\n  // k must contain a key.\n  expect Key(actual_k) = k\n  // k must be \"between\" the node's key and link.\n  and {\n    // The node is either the root node or its key is less than k.\n    when node_key is {\n      Empty -> True\n      Key(actual_node_key) ->\n        bytearray.compare(actual_node_key, actual_k) == Less\n    },\n    // The node is either the last node or k is less than its link.\n    when node_link is {\n      Empty -> True\n      Key(actual_node_link) ->\n        bytearray.compare(actual_k, actual_node_link) == Less\n    },\n  }\n}\n",
      "dependencies": [
        "aiken/builtin",
        "aiken/collection/dict",
        "aiken/collection/list",
        "aiken/primitive/bytearray",
        "cardano/assets",
        "cardano/transaction"
      ],
      "source": "anastasia",
      "isReExportFile": false
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-design-patterns/lib/aiken-design-patterns/linked-list/unordered.ak",
      "name": "aiken-design-patterns.linked-list.unordered",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 1,
          "raw": "use aiken/builtin",
          "source": "anastasia"
        },
        {
          "module": "aiken/collection/dict",
          "items": ["Dict", "has_key"],
          "line": 2,
          "raw": "use aiken/collection/dict.{Dict, has_key}",
          "source": "anastasia"
        },
        {
          "module": "aiken/collection/list",
          "items": [],
          "line": 3,
          "raw": "use aiken/collection/list",
          "source": "anastasia"
        },
        {
          "module": "aiken/primitive/bytearray",
          "items": [],
          "line": 4,
          "raw": "use aiken/primitive/bytearray",
          "source": "anastasia"
        },
        {
          "module": "cardano/assets",
          "items": [
            "AssetName",
            "PolicyId",
            "Value",
            "flatten",
            "quantity_of",
            "to_dict"
          ],
          "line": 5,
          "raw": "use cardano/assets.{AssetName, PolicyId, Value, flatten, quantity_of, to_dict}",
          "source": "anastasia"
        },
        {
          "module": "cardano/transaction",
          "items": ["InlineDatum", "Input", "Output"],
          "line": 6,
          "raw": "use cardano/transaction.{InlineDatum, Input, Output}",
          "source": "anastasia"
        }
      ],
      "functions": [
        {
          "name": "get_raw_key_and_link",
          "signature": "pub fn get_raw_key_and_link(node_output: Output) -> (Data, Data) {",
          "parameters": [
            {
              "name": "node_output",
              "type": "Output",
              "optional": false
            }
          ],
          "returnType": "(Data, Data)",
          "line": 30,
          "raw": "pub fn get_raw_key_and_link(node_output: Output) -> (Data, Data) {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn get_raw_key_and_link(node_output: Output) -> (Data, Data) {\n  expect InlineDatum(node_output_datum) = node_output.datum\n  let constr = builtin.un_constr_data(node_output_datum).2nd\n  let key = builtin.head_list(constr)\n  let link = builtin.head_list(builtin.tail_list(constr))\n  (key, link)\n}"
        },
        {
          "name": "get_key",
          "signature": "pub fn get_key(raw_key_and_link: (Data, Data)) -> NodeKey {",
          "parameters": [
            {
              "name": "raw_key_and_link",
              "type": "(Data, Data",
              "optional": false
            }
          ],
          "returnType": "NodeKey",
          "line": 38,
          "raw": "pub fn get_key(raw_key_and_link: (Data, Data)) -> NodeKey {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn get_key(raw_key_and_link: (Data, Data)) -> NodeKey {\n  expect key: NodeKey = raw_key_and_link.1st\n  key\n}"
        },
        {
          "name": "get_link",
          "signature": "pub fn get_link(raw_key_and_link: (Data, Data)) -> NodeKey {",
          "parameters": [
            {
              "name": "raw_key_and_link",
              "type": "(Data, Data",
              "optional": false
            }
          ],
          "returnType": "NodeKey",
          "line": 43,
          "raw": "pub fn get_link(raw_key_and_link: (Data, Data)) -> NodeKey {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn get_link(raw_key_and_link: (Data, Data)) -> NodeKey {\n  expect link: NodeKey = raw_key_and_link.2nd\n  link\n}"
        },
        {
          "name": "get_key_and_link",
          "signature": "pub fn get_key_and_link(node_output: Output) -> (NodeKey, NodeKey) {",
          "parameters": [
            {
              "name": "node_output",
              "type": "Output",
              "optional": false
            }
          ],
          "returnType": "(NodeKey, NodeKey)",
          "line": 48,
          "raw": "pub fn get_key_and_link(node_output: Output) -> (NodeKey, NodeKey) {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn get_key_and_link(node_output: Output) -> (NodeKey, NodeKey) {\n  let raw = get_raw_key_and_link(node_output)\n  (get_key(raw), get_link(raw))\n}"
        },
        {
          "name": "serialize_key",
          "signature": "pub fn serialize_key(key: NodeKey) -> ByteArray {",
          "parameters": [
            {
              "name": "key",
              "type": "NodeKey",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 53,
          "raw": "pub fn serialize_key(key: NodeKey) -> ByteArray {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn serialize_key(key: NodeKey) -> ByteArray {\n  when key is {\n    Empty -> node_prefix\n    Key(actual_key) -> bytearray.concat(node_prefix, actual_key)\n  }\n}"
        },
        {
          "name": "get_node_outputs",
          "signature": "pub fn get_node_outputs(pub fn get_node_outputs(outputs: List<Output>, policy_id: PolicyId, ) -> List<Output> {",
          "parameters": [],
          "returnType": "List<Output>",
          "line": 60,
          "raw": "pub fn get_node_outputs(pub fn get_node_outputs(outputs: List<Output>, policy_id: PolicyId, ) -> List<Output> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn get_node_outputs(\n  outputs: List<Output>,\n  policy_id: PolicyId,\n) -> List<Output> {\n  outputs\n    |> list.filter(\n        fn(output) {\n          let Output { value, .. } = output\n          has_data_cs(policy_id, value)\n        },\n      )\n}"
        },
        {
          "name": "get_node_inputs",
          "signature": "pub fn get_node_inputs(inputs: List<Input>, policy_id: PolicyId) -> List<Output> {",
          "parameters": [
            {
              "name": "inputs",
              "type": "List<Input>",
              "optional": false
            },
            {
              "name": "policy_id",
              "type": "PolicyId",
              "optional": false
            }
          ],
          "returnType": "List<Output>",
          "line": 73,
          "raw": "pub fn get_node_inputs(inputs: List<Input>, policy_id: PolicyId) -> List<Output> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn get_node_inputs(inputs: List<Input>, policy_id: PolicyId) -> List<Output> {\n  filter_map_pre(\n    inputs,\n    fn(output) {\n      let Output { value, .. } = output\n      has_data_cs(policy_id, value)\n    },\n    fn(input) {\n      let Input { output, .. } = input\n      output\n    },\n  )\n}"
        },
        {
          "name": "prove_is_root_node",
          "signature": "pub fn prove_is_root_node(policy_id: PolicyId, node: Output) -> Bool {",
          "documentation": "Prove that a node belongs to the given list and is its root.",
          "parameters": [
            {
              "name": "policy_id",
              "type": "PolicyId",
              "optional": false
            },
            {
              "name": "node",
              "type": "Output",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 90,
          "raw": "pub fn prove_is_root_node(policy_id: PolicyId, node: Output) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn prove_is_root_node(policy_id: PolicyId, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_root_node(node_datum.key)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, node_prefix) == 1\n  // Done.\n  True\n}"
        },
        {
          "name": "prove_is_last_node",
          "signature": "pub fn prove_is_last_node(policy_id: PolicyId, node: Output) -> Bool {",
          "documentation": "Prove that a node belongs to the given list and is its last node.",
          "parameters": [
            {
              "name": "policy_id",
              "type": "PolicyId",
              "optional": false
            },
            {
              "name": "node",
              "type": "Output",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 102,
          "raw": "pub fn prove_is_last_node(policy_id: PolicyId, node: Output) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn prove_is_last_node(policy_id: PolicyId, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_last_node(node_datum.link)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, serialize_key(node_datum.key)) == 1\n  // Done.\n  True\n}"
        },
        {
          "name": "prove_is_empty_list",
          "signature": "pub fn prove_is_empty_list(policy_id: PolicyId, node: Output) -> Bool {",
          "documentation": "Prove that the given list is empty, as witnessed by a node that\nis both the root and last node of the list.",
          "parameters": [
            {
              "name": "policy_id",
              "type": "PolicyId",
              "optional": false
            },
            {
              "name": "node",
              "type": "Output",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 115,
          "raw": "pub fn prove_is_empty_list(policy_id: PolicyId, node: Output) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn prove_is_empty_list(policy_id: PolicyId, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_empty_list(node_datum.key, node_datum.link)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, node_prefix) == 1\n  // Done.\n  True\n}"
        },
        {
          "name": "prove_is_member",
          "signature": "pub fn prove_is_member(policy_id: PolicyId, key: NodeKey, node: Output) -> Bool {",
          "documentation": "Prove that a key is a member of the given list, as witnessed by a node\nthat satisfies the membership predicate with the key.",
          "parameters": [
            {
              "name": "policy_id",
              "type": "PolicyId",
              "optional": false
            },
            {
              "name": "key",
              "type": "NodeKey",
              "optional": false
            },
            {
              "name": "node",
              "type": "Output",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 128,
          "raw": "pub fn prove_is_member(policy_id: PolicyId, key: NodeKey, node: Output) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn prove_is_member(policy_id: PolicyId, key: NodeKey, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_member(key, node_datum.key)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, serialize_key(key)) == 1\n  // Done.\n  True\n}"
        },
        {
          "name": "list_state_transition",
          "signature": "pub fn list_state_transition(node_mint: Dict<AssetName, Int>) -> Bool {",
          "documentation": "Detect whether the list's minting policy is invoked in the transaction,\nso that the spending validator can forward to it.",
          "parameters": [
            {
              "name": "node_mint",
              "type": "Dict<AssetName, Int>",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 143,
          "raw": "pub fn list_state_transition(node_mint: Dict<AssetName, Int>) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn list_state_transition(node_mint: Dict<AssetName, Int>) -> Bool {\n  // 1. Tokens of the list's minting policy must be minted or burned.\n  dict.is_empty(node_mint) == False\n}"
        },
        {
          "name": "modify_data",
          "signature": "pub fn modify_data(pub fn modify_data(node_mint: Dict<AssetName, Int>, own_input: Output, own_output: Output, node_nft_policy_id: ByteArray, node_nft_asset_name: ByteArray, ) -> Bool {",
          "documentation": "Modify the `data` field of a list node without changing the `key` and\n`link` fields.",
          "parameters": [],
          "returnType": "Bool",
          "line": 150,
          "raw": "pub fn modify_data(pub fn modify_data(node_mint: Dict<AssetName, Int>, own_input: Output, own_output: Output, node_nft_policy_id: ByteArray, node_nft_asset_name: ByteArray, ) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn modify_data(\n  node_mint: Dict<AssetName, Int>,\n  own_input: Output,\n  own_output: Output,\n  node_nft_policy_id: ByteArray,\n  node_nft_asset_name: ByteArray,\n) -> Bool {\n  // 1. Tokens of the list's minting policy must *not* be minted or burned.\n  expect dict.is_empty(node_mint)\n\n  // 2. Let own_input be the node utxo input for which this rule is evaluated.\n  // 3. Let own_output be an output of the transaction indicated by the redeemer\n  //    of the spending validator.\n  // 4. The node NFT of the list must be present in own_input.\n  expect\n    quantity_of(own_input.value, node_nft_policy_id, node_nft_asset_name) == 1\n\n  // 5. The value must match in own_input and own_output.\n  expect own_input.value == own_output.value\n\n  // 6. The key and link fields must match in own_input and own_output.\n  let input_key_and_link = get_raw_key_and_link(own_input)\n  let output_key_and_link = get_raw_key_and_link(own_output)\n  expect input_key_and_link == output_key_and_link\n\n  // Done.\n  True\n}"
        },
        {
          "name": "init",
          "signature": "pub fn init(pub fn init(node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, node_cs: ByteArray, ) -> Bool {",
          "documentation": "Initialize an empty unordered list.\n\nApplication code must ensure that this action can happen only once.",
          "parameters": [],
          "returnType": "Bool",
          "line": 184,
          "raw": "pub fn init(pub fn init(node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, node_cs: ByteArray, ) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn init(\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n  node_cs: ByteArray,\n) -> Bool {\n  // 1. The transaction's sole effect on the list is to add the root key.\n  expect key_added(Empty, node_mint)\n\n  // 2. The list must be empty after the transaction, as proved by an output\n  // root_node that holds the minted root node NFT.\n  expect Some(root_node) = list.head(node_outputs)\n  let raw_key_and_link = get_raw_key_and_link(root_node)\n  expect is_empty_list(get_key(raw_key_and_link), get_link(raw_key_and_link))\n  expect quantity_of(root_node.value, node_cs, node_prefix) == 1\n\n  // 3. The root_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(root_node.value)) == 2\n\n  // Done.\n  True\n}"
        },
        {
          "name": "deinit",
          "signature": "pub fn deinit(pub fn deinit(node_inputs: List<Output>, node_mint: Dict<AssetName, Int>, node_cs: ByteArray, ) -> Bool {",
          "documentation": "Deinitialize an empty unordered list.",
          "parameters": [],
          "returnType": "Bool",
          "line": 207,
          "raw": "pub fn deinit(pub fn deinit(node_inputs: List<Output>, node_mint: Dict<AssetName, Int>, node_cs: ByteArray, ) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn deinit(\n  node_inputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n  node_cs: ByteArray,\n) -> Bool {\n  // 1. The transaction's sole effect on the list is to remove the root key.\n  expect key_removed(Empty, node_mint)\n\n  // 2. The list must be empty before the transaction, as proved by an input\n  //    root_node that holds the minted root node NFT.\n  expect Some(root_node) = list.head(node_inputs)\n  let raw_key_and_link = get_raw_key_and_link(root_node)\n  expect is_empty_list(get_key(raw_key_and_link), get_link(raw_key_and_link))\n  expect quantity_of(root_node.value, node_cs, node_prefix) == 1\n\n  // Done.\n  True\n}"
        },
        {
          "name": "prepend_unsafe",
          "signature": "pub fn prepend_unsafe(pub fn prepend_unsafe(key_to_prepend: NodeKey, prepended_node_index: Int, anchor_node_output_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
          "documentation": "Prepend a new node to the beginning of the list.\n\nWARNING: An application using a key-unordered list MUST only add nodes with\nunique keys to the list. Duplicate keys break the linked list data structure.\n\nThe index arguments in this function are relative to the node_inputs\nand node_outputs. They are NOT absolute.",
          "parameters": [],
          "returnType": "Bool",
          "line": 233,
          "raw": "pub fn prepend_unsafe(pub fn prepend_unsafe(key_to_prepend: NodeKey, prepended_node_index: Int, anchor_node_output_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn prepend_unsafe(\n  key_to_prepend: NodeKey,\n  prepended_node_index: Int,\n  anchor_node_output_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify the mint:\n  // 1. Let key_to_prepend be the key being prepended.\n  // 2. The transaction's sole effect on the list is to add key_to_prepend.\n  expect key_added(key_to_prepend, node_mint)\n\n  // Verify the inputs:\n  // 3. node_inputs must be a singleton. Let anchor_node_input be its sole node.\n  expect list.length(node_inputs) == 1\n  expect Some(anchor_node_input) = list.head(node_inputs)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n\n  // 4. anchor_node_input must be the root node of the list.\n  expect is_root_node(parsed_anchor_node_input_datum.key)\n\n  // Verify the outputs:\n  // 5. node_outputs must have exactly two nodes: prepended_node and anchor_node_output.\n  expect list.length(node_outputs) == 2\n  expect Some(prepended_node) = list.at(node_outputs, prepended_node_index)\n  let prepended_node_raw_key_and_link = get_raw_key_and_link(prepended_node)\n  expect Some(anchor_node_output) =\n    list.at(node_outputs, anchor_node_output_index)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 6. key_to_prepend must be a member of the list after the transaction,\n  //    as witnessed by prepended_node.\n  expect is_member(key_to_prepend, get_key(prepended_node_raw_key_and_link))\n\n  // 7. anchor_node input and prepended node must match on the link_field.\n  //    In other words, they must both link to the same key.\n  expect\n    parsed_anchor_node_input_datum.link == get_link(\n      prepended_node_raw_key_and_link,\n    )\n\n  // 8. anchor_node_output must link to key_to_prepend.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: key_to_prepend,\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // 9. prepended_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(prepended_node.value)) == 2\n\n  // Verify immutable data:\n  // 10. anchor node input must match anchor node output on address, value,\n  //     and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // 11. prepended_node must match anchor_node_output on address.\n  expect prepended_node.address == anchor_node_output.address\n\n  // Done.\n  True\n}"
        },
        {
          "name": "append_unsafe",
          "signature": "pub fn append_unsafe(pub fn append_unsafe(key_to_append: NodeKey, appended_node_index: Int, anchor_node_output_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
          "documentation": "Append a new node to the end of the list.\n\nWARNING: An application using a key-unordered list MUST only add nodes with\nunique keys to the list. Duplicate keys break the linked list data structure.\n\nThe index arguments in this function are relative to the node_inputs\nand node_outputs. They are NOT absolute.",
          "parameters": [],
          "returnType": "Bool",
          "line": 309,
          "raw": "pub fn append_unsafe(pub fn append_unsafe(key_to_append: NodeKey, appended_node_index: Int, anchor_node_output_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn append_unsafe(\n  key_to_append: NodeKey,\n  appended_node_index: Int,\n  anchor_node_output_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify the mint:\n  // 1. Let key_to_append be the key being appended.\n  // 2. The transaction's sole effect on the list is to add key_to_append.\n  expect key_added(key_to_append, node_mint)\n\n  // 3. node_inputs must be a singleton. Let anchor_node_input be its sole node.\n  expect list.length(node_inputs) == 1\n  expect Some(anchor_node_input) = list.head(node_inputs)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n  let anchor_node_raw_key_and_link = get_raw_key_and_link(anchor_node_input)\n\n  // 4. anchor_node_input must be the last node of the list before the transaction.\n  expect is_last_node(get_link(anchor_node_raw_key_and_link))\n\n  // Verify the outputs:\n  // 5. node_outputs must have exactly two nodes: appended_node and anchor_node_output.\n  expect list.length(node_outputs) == 2\n  expect Some(appended_node) = list.at(node_outputs, appended_node_index)\n  let appended_node_raw_key_and_link = get_raw_key_and_link(appended_node)\n  expect Some(anchor_node_output) =\n    list.at(node_outputs, anchor_node_output_index)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 6. key_to_append must be a member of the list after the transaction,\n  //    as witnessed by appended_node.\n  expect is_member(key_to_append, get_key(appended_node_raw_key_and_link))\n\n  // 7. appended_node must be the last node of the list after the transaction.\n  expect is_last_node(get_link(appended_node_raw_key_and_link))\n\n  // 8. anchor node output must link to key to append.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: key_to_append,\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // 9. appended_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(appended_node.value)) == 2\n\n  // Verify immutable data:\n  // 10. anchor_node input must match anchor_node output on address, value,\n  //     and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // 11. appended_node must match anchor_node_output on address.\n  expect appended_node.address == anchor_node_output.address\n\n  // Done.\n  True\n}"
        },
        {
          "name": "remove",
          "signature": "pub fn remove(pub fn remove(key_to_remove: NodeKey, removed_node_input_index: Int, anchor_node_input_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
          "documentation": "Remove a non-root node from the list.\n\nThe index arguments in this function are relative to the node_inputs\nand node_outputs. They are NOT absolute.",
          "parameters": [],
          "returnType": "Bool",
          "line": 378,
          "raw": "pub fn remove(pub fn remove(key_to_remove: NodeKey, removed_node_input_index: Int, anchor_node_input_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn remove(\n  key_to_remove: NodeKey,\n  removed_node_input_index: Int,\n  anchor_node_input_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify the mint:\n  // 1. Let key_to_remove be the key being removed.\n  // 2. The transaction's sole effect on the list is to remove key_to_remove.\n  expect key_removed(key_to_remove, node_mint)\n\n  // Verify the inputs:\n  // 3. node_inputs must have exactly two nodes: removed_node and anchor_node_input.\n  expect list.length(node_inputs) == 2\n  expect Some(removed_node_input) =\n    list.at(node_inputs, removed_node_input_index)\n  let removed_node_raw_key_and_link = get_raw_key_and_link(removed_node_input)\n  expect Some(anchor_node_input) = list.at(node_inputs, anchor_node_input_index)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n\n  // 4. key_to_remove must be a member of the list before the transaction,\n  //    as witnessed by removed_node.\n  expect is_member(key_to_remove, get_key(removed_node_raw_key_and_link))\n\n  // 5. anchor_node_input must link to key_to_remove.\n  expect parsed_anchor_node_input_datum.link == key_to_remove\n\n  // Verify the outputs:\n  // 6. node_outputs must be a singleton. Let anchor_node_output be its sole node.\n  expect list.length(node_outputs) == 1\n  expect Some(anchor_node_output) = list.head(node_outputs)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 7. anchor_node_output and removed_node must match on the link field.\n  //    In other words, they must both link to the same key.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: get_link(removed_node_raw_key_and_link),\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // Verify immutable data:\n  // 8. anchor_node_input must match anchor_node_output on address, value,\n  //    and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // Done.\n  True\n}"
        }
      ],
      "types": [
        {
          "name": "NodeDatum",
          "definition": "{ key: NodeKey, link: NodeKey, data: Data, }",
          "line": 18,
          "raw": "pub type NodeDatum {",
          "isPublic": true,
          "source": "anastasia"
        },
        {
          "name": "NodeKey",
          "definition": "{ Key { key: ByteArray } Empty }",
          "line": 25,
          "raw": "pub type NodeKey {",
          "isPublic": true,
          "source": "anastasia"
        }
      ],
      "constants": [
        {
          "name": "node_prefix",
          "type": "ByteArray",
          "value": "\"Node\"",
          "line": 11,
          "raw": "pub const node_prefix: ByteArray = \"Node\"",
          "isPublic": true,
          "source": "anastasia"
        }
      ],
      "atoms": [
        {
          "name": "filter_map_pre",
          "signature": "fn filter_map_pre(fn filter_map_pre(self: List<a>, predicate: fn(b) -> Bool, transform: fn(a) -> b,",
          "parameters": [],
          "returnType": "Bool, transform: fn(a) -> b,",
          "line": 442,
          "raw": "fn filter_map_pre(fn filter_map_pre(self: List<a>, predicate: fn(b) -> Bool, transform: fn(a) -> b,",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn filter_map_pre(\n  self: List<a>,\n  predicate: fn(b) -> Bool,\n  transform: fn(a) -> b,\n) -> List<b> {\n  when self is {\n    [] -> []\n    [x, ..xs] -> {\n      let y = transform(x)\n      if predicate(y) {\n        [y, ..filter_map_pre(xs, predicate, transform)]\n      } else {\n        filter_map_pre(xs, predicate, transform)\n      }\n    }\n  }\n}"
        },
        {
          "name": "filter_map_post",
          "signature": "fn filter_map_post(fn filter_map_post(self: List<a>, predicate: fn(a) -> Bool, transform: fn(a) -> b,",
          "parameters": [],
          "returnType": "Bool, transform: fn(a) -> b,",
          "line": 461,
          "raw": "fn filter_map_post(fn filter_map_post(self: List<a>, predicate: fn(a) -> Bool, transform: fn(a) -> b,",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn filter_map_post(\n  self: List<a>,\n  predicate: fn(a) -> Bool,\n  transform: fn(a) -> b,\n) -> List<b> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      if predicate(x) {\n        [transform(x), ..filter_map_post(xs, predicate, transform)]\n      } else {\n        filter_map_post(xs, predicate, transform)\n      }\n  }\n}"
        },
        {
          "name": "has_data_cs",
          "signature": "fn has_data_cs(cs: PolicyId, value: Value) -> Bool {",
          "parameters": [
            {
              "name": "cs",
              "type": "PolicyId",
              "optional": false
            },
            {
              "name": "value",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 478,
          "raw": "fn has_data_cs(cs: PolicyId, value: Value) -> Bool {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn has_data_cs(cs: PolicyId, value: Value) -> Bool {\n  value\n    |> to_dict()\n    |> has_key(cs)\n}"
        },
        {
          "name": "is_root_node",
          "signature": "fn is_root_node(node_key: NodeKey) -> Bool {",
          "parameters": [
            {
              "name": "node_key",
              "type": "NodeKey",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 484,
          "raw": "fn is_root_node(node_key: NodeKey) -> Bool {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn is_root_node(node_key: NodeKey) -> Bool {\n  node_key == Empty\n}"
        },
        {
          "name": "is_last_node",
          "signature": "fn is_last_node(node_link: NodeKey) -> Bool {",
          "parameters": [
            {
              "name": "node_link",
              "type": "NodeKey",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 488,
          "raw": "fn is_last_node(node_link: NodeKey) -> Bool {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn is_last_node(node_link: NodeKey) -> Bool {\n  node_link == Empty\n}"
        },
        {
          "name": "is_empty_list",
          "signature": "fn is_empty_list(node_key: NodeKey, node_link: NodeKey) -> Bool {",
          "parameters": [
            {
              "name": "node_key",
              "type": "NodeKey",
              "optional": false
            },
            {
              "name": "node_link",
              "type": "NodeKey",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 492,
          "raw": "fn is_empty_list(node_key: NodeKey, node_link: NodeKey) -> Bool {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn is_empty_list(node_key: NodeKey, node_link: NodeKey) -> Bool {\n  and {\n    is_root_node(node_key),\n    is_last_node(node_link),\n  }\n}"
        },
        {
          "name": "key_added",
          "signature": "fn key_added(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {",
          "parameters": [
            {
              "name": "key",
              "type": "NodeKey",
              "optional": false
            },
            {
              "name": "node_mint",
              "type": "Dict<AssetName, Int>",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 499,
          "raw": "fn key_added(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn key_added(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {\n  and {\n    dict.size(node_mint) == 1,\n    dict.get(node_mint, serialize_key(key)) == Some(1),\n  }\n}"
        },
        {
          "name": "key_removed",
          "signature": "fn key_removed(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {",
          "parameters": [
            {
              "name": "key",
              "type": "NodeKey",
              "optional": false
            },
            {
              "name": "node_mint",
              "type": "Dict<AssetName, Int>",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 506,
          "raw": "fn key_removed(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn key_removed(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {\n  and {\n    dict.size(node_mint) == 1,\n    dict.get(node_mint, serialize_key(key)) == Some(-1),\n  }\n}"
        },
        {
          "name": "is_member",
          "signature": "fn is_member(k: NodeKey, node_key: NodeKey) -> Bool {",
          "parameters": [
            {
              "name": "k",
              "type": "NodeKey",
              "optional": false
            },
            {
              "name": "node_key",
              "type": "NodeKey",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 513,
          "raw": "fn is_member(k: NodeKey, node_key: NodeKey) -> Bool {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn is_member(k: NodeKey, node_key: NodeKey) -> Bool {\n  k == node_key\n}"
        }
      ],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/builtin\nuse aiken/collection/dict.{Dict, has_key}\nuse aiken/collection/list\nuse aiken/primitive/bytearray\nuse cardano/assets.{AssetName, PolicyId, Value, flatten, quantity_of, to_dict}\nuse cardano/transaction.{InlineDatum, Input, Output}\n\n// # Data types, constants, and accessors\n\n/// Every list node's token name starts with this prefix.\npub const node_prefix: ByteArray = \"Node\"\n\n/// Every list node utxo:\n/// - has a unique `key` (unless it's the root node)\n/// - has a unique `link` to another node's key \n///   (unless it's the last node of the list)\n/// - holds some app-specific `data`\npub type NodeDatum {\n  key: NodeKey,\n  link: NodeKey,\n  data: Data,\n}\n\n/// Same as `Option`, but with more informative constructor names.\npub type NodeKey {\n  Key { key: ByteArray }\n  Empty\n}\n\npub fn get_raw_key_and_link(node_output: Output) -> (Data, Data) {\n  expect InlineDatum(node_output_datum) = node_output.datum\n  let constr = builtin.un_constr_data(node_output_datum).2nd\n  let key = builtin.head_list(constr)\n  let link = builtin.head_list(builtin.tail_list(constr))\n  (key, link)\n}\n\npub fn get_key(raw_key_and_link: (Data, Data)) -> NodeKey {\n  expect key: NodeKey = raw_key_and_link.1st\n  key\n}\n\npub fn get_link(raw_key_and_link: (Data, Data)) -> NodeKey {\n  expect link: NodeKey = raw_key_and_link.2nd\n  link\n}\n\npub fn get_key_and_link(node_output: Output) -> (NodeKey, NodeKey) {\n  let raw = get_raw_key_and_link(node_output)\n  (get_key(raw), get_link(raw))\n}\n\npub fn serialize_key(key: NodeKey) -> ByteArray {\n  when key is {\n    Empty -> node_prefix\n    Key(actual_key) -> bytearray.concat(node_prefix, actual_key)\n  }\n}\n\npub fn get_node_outputs(\n  outputs: List<Output>,\n  policy_id: PolicyId,\n) -> List<Output> {\n  outputs\n    |> list.filter(\n        fn(output) {\n          let Output { value, .. } = output\n          has_data_cs(policy_id, value)\n        },\n      )\n}\n\npub fn get_node_inputs(inputs: List<Input>, policy_id: PolicyId) -> List<Output> {\n  filter_map_pre(\n    inputs,\n    fn(output) {\n      let Output { value, .. } = output\n      has_data_cs(policy_id, value)\n    },\n    fn(input) {\n      let Input { output, .. } = input\n      output\n    },\n  )\n}\n\n// ## Predicates (used outside of list validators)\n\n/// Prove that a node belongs to the given list and is its root.\npub fn prove_is_root_node(policy_id: PolicyId, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_root_node(node_datum.key)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, node_prefix) == 1\n  // Done.\n  True\n}\n\n/// Prove that a node belongs to the given list and is its last node.\npub fn prove_is_last_node(policy_id: PolicyId, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_last_node(node_datum.link)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, serialize_key(node_datum.key)) == 1\n  // Done.\n  True\n}\n\n/// Prove that the given list is empty, as witnessed by a node that\n/// is both the root and last node of the list.\npub fn prove_is_empty_list(policy_id: PolicyId, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_empty_list(node_datum.key, node_datum.link)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, node_prefix) == 1\n  // Done.\n  True\n}\n\n/// Prove that a key is a member of the given list, as witnessed by a node\n/// that satisfies the membership predicate with the key.\npub fn prove_is_member(policy_id: PolicyId, key: NodeKey, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_member(key, node_datum.key)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, serialize_key(key)) == 1\n  // Done.\n  True\n}\n\n// ## State integrity handlers (used in list spending validator)\n\n/// Detect whether the list's minting policy is invoked in the transaction,\n/// so that the spending validator can forward to it.\npub fn list_state_transition(node_mint: Dict<AssetName, Int>) -> Bool {\n  // 1. Tokens of the list's minting policy must be minted or burned.\n  dict.is_empty(node_mint) == False\n}\n\n/// Modify the `data` field of a list node without changing the `key` and\n/// `link` fields.\npub fn modify_data(\n  node_mint: Dict<AssetName, Int>,\n  own_input: Output,\n  own_output: Output,\n  node_nft_policy_id: ByteArray,\n  node_nft_asset_name: ByteArray,\n) -> Bool {\n  // 1. Tokens of the list's minting policy must *not* be minted or burned.\n  expect dict.is_empty(node_mint)\n\n  // 2. Let own_input be the node utxo input for which this rule is evaluated.\n  // 3. Let own_output be an output of the transaction indicated by the redeemer\n  //    of the spending validator.\n  // 4. The node NFT of the list must be present in own_input.\n  expect\n    quantity_of(own_input.value, node_nft_policy_id, node_nft_asset_name) == 1\n\n  // 5. The value must match in own_input and own_output.\n  expect own_input.value == own_output.value\n\n  // 6. The key and link fields must match in own_input and own_output.\n  let input_key_and_link = get_raw_key_and_link(own_input)\n  let output_key_and_link = get_raw_key_and_link(own_output)\n  expect input_key_and_link == output_key_and_link\n\n  // Done.\n  True\n}\n\n// ## State transition handlers (used in list minting policy)\n\n/// Initialize an empty unordered list.\n///\n/// Application code must ensure that this action can happen only once.\npub fn init(\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n  node_cs: ByteArray,\n) -> Bool {\n  // 1. The transaction's sole effect on the list is to add the root key.\n  expect key_added(Empty, node_mint)\n\n  // 2. The list must be empty after the transaction, as proved by an output\n  // root_node that holds the minted root node NFT.\n  expect Some(root_node) = list.head(node_outputs)\n  let raw_key_and_link = get_raw_key_and_link(root_node)\n  expect is_empty_list(get_key(raw_key_and_link), get_link(raw_key_and_link))\n  expect quantity_of(root_node.value, node_cs, node_prefix) == 1\n\n  // 3. The root_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(root_node.value)) == 2\n\n  // Done.\n  True\n}\n\n/// Deinitialize an empty unordered list.\npub fn deinit(\n  node_inputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n  node_cs: ByteArray,\n) -> Bool {\n  // 1. The transaction's sole effect on the list is to remove the root key.\n  expect key_removed(Empty, node_mint)\n\n  // 2. The list must be empty before the transaction, as proved by an input\n  //    root_node that holds the minted root node NFT.\n  expect Some(root_node) = list.head(node_inputs)\n  let raw_key_and_link = get_raw_key_and_link(root_node)\n  expect is_empty_list(get_key(raw_key_and_link), get_link(raw_key_and_link))\n  expect quantity_of(root_node.value, node_cs, node_prefix) == 1\n\n  // Done.\n  True\n}\n\n/// Prepend a new node to the beginning of the list.\n///\n/// WARNING: An application using a key-unordered list MUST only add nodes with\n/// unique keys to the list. Duplicate keys break the linked list data structure.\n/// \n/// The index arguments in this function are relative to the node_inputs\n/// and node_outputs. They are NOT absolute.\npub fn prepend_unsafe(\n  key_to_prepend: NodeKey,\n  prepended_node_index: Int,\n  anchor_node_output_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify the mint:\n  // 1. Let key_to_prepend be the key being prepended.\n  // 2. The transaction's sole effect on the list is to add key_to_prepend.\n  expect key_added(key_to_prepend, node_mint)\n\n  // Verify the inputs:\n  // 3. node_inputs must be a singleton. Let anchor_node_input be its sole node.\n  expect list.length(node_inputs) == 1\n  expect Some(anchor_node_input) = list.head(node_inputs)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n\n  // 4. anchor_node_input must be the root node of the list.\n  expect is_root_node(parsed_anchor_node_input_datum.key)\n\n  // Verify the outputs:\n  // 5. node_outputs must have exactly two nodes: prepended_node and anchor_node_output.\n  expect list.length(node_outputs) == 2\n  expect Some(prepended_node) = list.at(node_outputs, prepended_node_index)\n  let prepended_node_raw_key_and_link = get_raw_key_and_link(prepended_node)\n  expect Some(anchor_node_output) =\n    list.at(node_outputs, anchor_node_output_index)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 6. key_to_prepend must be a member of the list after the transaction,\n  //    as witnessed by prepended_node.\n  expect is_member(key_to_prepend, get_key(prepended_node_raw_key_and_link))\n\n  // 7. anchor_node input and prepended node must match on the link_field.\n  //    In other words, they must both link to the same key.\n  expect\n    parsed_anchor_node_input_datum.link == get_link(\n      prepended_node_raw_key_and_link,\n    )\n\n  // 8. anchor_node_output must link to key_to_prepend.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: key_to_prepend,\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // 9. prepended_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(prepended_node.value)) == 2\n\n  // Verify immutable data:\n  // 10. anchor node input must match anchor node output on address, value,\n  //     and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // 11. prepended_node must match anchor_node_output on address.\n  expect prepended_node.address == anchor_node_output.address\n\n  // Done.\n  True\n}\n\n/// Append a new node to the end of the list.\n///\n/// WARNING: An application using a key-unordered list MUST only add nodes with\n/// unique keys to the list. Duplicate keys break the linked list data structure.\n/// \n/// The index arguments in this function are relative to the node_inputs\n/// and node_outputs. They are NOT absolute.\npub fn append_unsafe(\n  key_to_append: NodeKey,\n  appended_node_index: Int,\n  anchor_node_output_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify the mint:\n  // 1. Let key_to_append be the key being appended.\n  // 2. The transaction's sole effect on the list is to add key_to_append.\n  expect key_added(key_to_append, node_mint)\n\n  // 3. node_inputs must be a singleton. Let anchor_node_input be its sole node.\n  expect list.length(node_inputs) == 1\n  expect Some(anchor_node_input) = list.head(node_inputs)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n  let anchor_node_raw_key_and_link = get_raw_key_and_link(anchor_node_input)\n\n  // 4. anchor_node_input must be the last node of the list before the transaction.\n  expect is_last_node(get_link(anchor_node_raw_key_and_link))\n\n  // Verify the outputs:\n  // 5. node_outputs must have exactly two nodes: appended_node and anchor_node_output.\n  expect list.length(node_outputs) == 2\n  expect Some(appended_node) = list.at(node_outputs, appended_node_index)\n  let appended_node_raw_key_and_link = get_raw_key_and_link(appended_node)\n  expect Some(anchor_node_output) =\n    list.at(node_outputs, anchor_node_output_index)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 6. key_to_append must be a member of the list after the transaction,\n  //    as witnessed by appended_node.\n  expect is_member(key_to_append, get_key(appended_node_raw_key_and_link))\n\n  // 7. appended_node must be the last node of the list after the transaction.\n  expect is_last_node(get_link(appended_node_raw_key_and_link))\n\n  // 8. anchor node output must link to key to append.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: key_to_append,\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // 9. appended_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(appended_node.value)) == 2\n\n  // Verify immutable data:\n  // 10. anchor_node input must match anchor_node output on address, value,\n  //     and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // 11. appended_node must match anchor_node_output on address.\n  expect appended_node.address == anchor_node_output.address\n\n  // Done.\n  True\n}\n\n/// Remove a non-root node from the list.\n///\n/// The index arguments in this function are relative to the node_inputs\n/// and node_outputs. They are NOT absolute.\npub fn remove(\n  key_to_remove: NodeKey,\n  removed_node_input_index: Int,\n  anchor_node_input_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify the mint:\n  // 1. Let key_to_remove be the key being removed.\n  // 2. The transaction's sole effect on the list is to remove key_to_remove.\n  expect key_removed(key_to_remove, node_mint)\n\n  // Verify the inputs:\n  // 3. node_inputs must have exactly two nodes: removed_node and anchor_node_input.\n  expect list.length(node_inputs) == 2\n  expect Some(removed_node_input) =\n    list.at(node_inputs, removed_node_input_index)\n  let removed_node_raw_key_and_link = get_raw_key_and_link(removed_node_input)\n  expect Some(anchor_node_input) = list.at(node_inputs, anchor_node_input_index)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n\n  // 4. key_to_remove must be a member of the list before the transaction,\n  //    as witnessed by removed_node.\n  expect is_member(key_to_remove, get_key(removed_node_raw_key_and_link))\n\n  // 5. anchor_node_input must link to key_to_remove.\n  expect parsed_anchor_node_input_datum.link == key_to_remove\n\n  // Verify the outputs:\n  // 6. node_outputs must be a singleton. Let anchor_node_output be its sole node.\n  expect list.length(node_outputs) == 1\n  expect Some(anchor_node_output) = list.head(node_outputs)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 7. anchor_node_output and removed_node must match on the link field.\n  //    In other words, they must both link to the same key.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: get_link(removed_node_raw_key_and_link),\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // Verify immutable data:\n  // 8. anchor_node_input must match anchor_node_output on address, value,\n  //    and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // Done.\n  True\n}\n\n// # Internal functions\n\n// Adapted from Aiken stdlib.collection.list.filter_map\n// Instead of using (predicate: fn(a) -> Option<a>)\n// We decompose it into two arguments.\n\n// In this variant, we apply the transform before the predicate.\nfn filter_map_pre(\n  self: List<a>,\n  predicate: fn(b) -> Bool,\n  transform: fn(a) -> b,\n) -> List<b> {\n  when self is {\n    [] -> []\n    [x, ..xs] -> {\n      let y = transform(x)\n      if predicate(y) {\n        [y, ..filter_map_pre(xs, predicate, transform)]\n      } else {\n        filter_map_pre(xs, predicate, transform)\n      }\n    }\n  }\n}\n\n// In this variant, we apply the transform after the predicate.\nfn filter_map_post(\n  self: List<a>,\n  predicate: fn(a) -> Bool,\n  transform: fn(a) -> b,\n) -> List<b> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      if predicate(x) {\n        [transform(x), ..filter_map_post(xs, predicate, transform)]\n      } else {\n        filter_map_post(xs, predicate, transform)\n      }\n  }\n}\n\n// Checks if a Currency Symbol is held within a Value\nfn has_data_cs(cs: PolicyId, value: Value) -> Bool {\n  value\n    |> to_dict()\n    |> has_key(cs)\n}\n\nfn is_root_node(node_key: NodeKey) -> Bool {\n  node_key == Empty\n}\n\nfn is_last_node(node_link: NodeKey) -> Bool {\n  node_link == Empty\n}\n\nfn is_empty_list(node_key: NodeKey, node_link: NodeKey) -> Bool {\n  and {\n    is_root_node(node_key),\n    is_last_node(node_link),\n  }\n}\n\nfn key_added(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {\n  and {\n    dict.size(node_mint) == 1,\n    dict.get(node_mint, serialize_key(key)) == Some(1),\n  }\n}\n\nfn key_removed(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {\n  and {\n    dict.size(node_mint) == 1,\n    dict.get(node_mint, serialize_key(key)) == Some(-1),\n  }\n}\n\nfn is_member(k: NodeKey, node_key: NodeKey) -> Bool {\n  k == node_key\n}\n",
      "dependencies": [
        "aiken/builtin",
        "aiken/collection/dict",
        "aiken/collection/list",
        "aiken/primitive/bytearray",
        "cardano/assets",
        "cardano/transaction"
      ],
      "source": "anastasia",
      "isReExportFile": false
    },
    {
      "key": "anastasia:aiken-design-patterns.merkelized-validator",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-design-patterns/lib/aiken-design-patterns/merkelized-validator.ak",
      "name": "aiken-design-patterns.merkelized-validator",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 17,
          "raw": "use aiken/builtin",
          "source": "anastasia"
        },
        {
          "module": "aiken/collection/pairs",
          "items": [],
          "line": 18,
          "raw": "use aiken/collection/pairs",
          "source": "anastasia"
        },
        {
          "module": "aiken/crypto",
          "items": ["ScriptHash", "blake2b_224"],
          "line": 19,
          "raw": "use aiken/crypto.{ScriptHash, blake2b_224}",
          "source": "anastasia"
        },
        {
          "module": "aiken/fuzz",
          "items": [],
          "line": 20,
          "raw": "use aiken/fuzz",
          "source": "anastasia"
        },
        {
          "module": "aiken_design_patterns/utils",
          "items": ["sum_of_squares"],
          "line": 21,
          "raw": "use aiken_design_patterns/utils.{sum_of_squares}",
          "source": "anastasia"
        },
        {
          "module": "cardano/address",
          "items": ["Script"],
          "line": 22,
          "raw": "use cardano/address.{Script}",
          "source": "anastasia"
        },
        {
          "module": "cardano/transaction",
          "items": ["Redeemer", "ScriptPurpose", "Withdraw"],
          "line": 23,
          "raw": "use cardano/transaction.{Redeemer, ScriptPurpose, Withdraw}",
          "source": "anastasia"
        }
      ],
      "functions": [
        {
          "name": "delegated_compute",
          "signature": "pub fn delegated_compute(pub fn delegated_compute(function_input: a, staking_validator: ScriptHash, input_data_coercer: fn(Data) -> a, output_data_coercer: fn(Data) -> b, redeemers: Pairs<ScriptPurpose, Redeemer>,",
          "documentation": "Given an arbitrary `Data` as input, this function expects to find\na `Withdraw` script purpose in `redeemers` for `staking_validator`, with a\nredeemer of type [`WithdrawRedeemer<Data, Data>`](#withdrawredeemera-b),\nwhich will be coerced into your custom datatypes using your provided `Data`\nvalidators (`input_data_coercer` and `output_data_coercer`).",
          "parameters": [],
          "returnType": "a, output_data_coercer: fn(Data) -> b, redeemers: Pairs<ScriptPurpose, Redeemer>,",
          "line": 56,
          "raw": "pub fn delegated_compute(pub fn delegated_compute(function_input: a, staking_validator: ScriptHash, input_data_coercer: fn(Data) -> a, output_data_coercer: fn(Data) -> b, redeemers: Pairs<ScriptPurpose, Redeemer>,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn delegated_compute(\n  function_input: a,\n  staking_validator: ScriptHash,\n  input_data_coercer: fn(Data) -> a,\n  output_data_coercer: fn(Data) -> b,\n  redeemers: Pairs<ScriptPurpose, Redeemer>,\n) -> b {\n  expect Some(rdmr) =\n    redeemers\n      |> pairs.get_first(Withdraw(Script(staking_validator)))\n  expect WithdrawRedeemerIO { input_arg, result }: WithdrawRedeemerIO<\n    Data,\n    Data,\n  > = rdmr\n\n  let coerced_input = input_data_coercer(input_arg)\n\n  // Given input argument must be identical to the one provided to the\n  // withdrawal validator.\n  expect (coerced_input == function_input)?\n\n  // Return coerced result\n  output_data_coercer(result)\n}"
        },
        {
          "name": "delegated_validation",
          "signature": "pub fn delegated_validation(pub fn delegated_validation(function_input: a, staking_validator: ScriptHash, input_data_coercer: fn(Data) -> a, redeemers: Pairs<ScriptPurpose, Redeemer>,",
          "documentation": "Similar to [`delegated_compute`](#delegated_compute), with the difference\nthat now values are expected to be returned by the staking script.",
          "parameters": [],
          "returnType": "a, redeemers: Pairs<ScriptPurpose, Redeemer>,",
          "line": 83,
          "raw": "pub fn delegated_validation(pub fn delegated_validation(function_input: a, staking_validator: ScriptHash, input_data_coercer: fn(Data) -> a, redeemers: Pairs<ScriptPurpose, Redeemer>,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn delegated_validation(\n  function_input: a,\n  staking_validator: ScriptHash,\n  input_data_coercer: fn(Data) -> a,\n  redeemers: Pairs<ScriptPurpose, Redeemer>,\n) -> Bool {\n  expect Some(rdmr) =\n    redeemers\n      |> pairs.get_first(Withdraw(Script(staking_validator)))\n  expect WithdrawRedeemer { input_arg }: WithdrawRedeemer<Data> = rdmr\n\n  let coerced_input = input_data_coercer(input_arg)\n\n  // Given input argument must be identical to the one provided to the\n  // withdrawal validator.\n  coerced_input == function_input\n}"
        },
        {
          "name": "generic_delegated_validation",
          "signature": "pub fn generic_delegated_validation(pub fn generic_delegated_validation(staking_validator: ScriptHash, withdraw_redeemer_validator: fn(Data) -> Bool, redeemers: Pairs<ScriptPurpose, Redeemer>,",
          "parameters": [],
          "returnType": "Bool, redeemers: Pairs<ScriptPurpose, Redeemer>,",
          "line": 101,
          "raw": "pub fn generic_delegated_validation(pub fn generic_delegated_validation(staking_validator: ScriptHash, withdraw_redeemer_validator: fn(Data) -> Bool, redeemers: Pairs<ScriptPurpose, Redeemer>,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn generic_delegated_validation(\n  staking_validator: ScriptHash,\n  withdraw_redeemer_validator: fn(Data) -> Bool,\n  redeemers: Pairs<ScriptPurpose, Redeemer>,\n) -> Bool {\n  expect Some(rdmr) =\n    redeemers\n      |> pairs.get_first(Withdraw(Script(staking_validator)))\n  withdraw_redeemer_validator(rdmr)\n}"
        },
        {
          "name": "withdraw_io",
          "signature": "pub fn withdraw_io(pub fn withdraw_io(function: fn(a) -> b, redeemer: WithdrawRedeemerIO<a, b>,",
          "documentation": "Helper function for defining your \"computation stake validator.\" The\nresulting stake validator will carry out the provided `function`'s logic,\nand `redeemer` must contain the input(s) and expected output(s).",
          "parameters": [],
          "returnType": "b, redeemer: WithdrawRedeemerIO<a, b>,",
          "line": 115,
          "raw": "pub fn withdraw_io(pub fn withdraw_io(function: fn(a) -> b, redeemer: WithdrawRedeemerIO<a, b>,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn withdraw_io(\n  function: fn(a) -> b,\n  redeemer: WithdrawRedeemerIO<a, b>,\n) -> Bool {\n  let WithdrawRedeemerIO { input_arg, result } = redeemer\n  let computed_result = function(input_arg)\n  result == computed_result\n}"
        },
        {
          "name": "withdraw",
          "signature": "pub fn withdraw(pub fn withdraw(validation: fn(a) -> Bool, redeemer: WithdrawRedeemer<a>,",
          "documentation": "Helper function for defining your delegated validation. The resulting stake\nvalidator will carry out the provided `validation`'s logic with given\ninput(s) through its redeemer.",
          "parameters": [],
          "returnType": "Bool, redeemer: WithdrawRedeemer<a>,",
          "line": 127,
          "raw": "pub fn withdraw(pub fn withdraw(validation: fn(a) -> Bool, redeemer: WithdrawRedeemer<a>,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn withdraw(\n  validation: fn(a) -> Bool,\n  redeemer: WithdrawRedeemer<a>,\n) -> Bool {\n  let WithdrawRedeemer { input_arg } = redeemer\n  validation(input_arg)\n}"
        }
      ],
      "types": [
        {
          "name": "WithdrawRedeemerIO<a, b>",
          "definition": "{ input_arg: a, result: b, }",
          "line": 39,
          "raw": "pub type WithdrawRedeemerIO<a, b> {",
          "isPublic": true,
          "source": "anastasia"
        },
        {
          "name": "WithdrawRedeemer<a>",
          "definition": "{ input_arg: a, }",
          "line": 47,
          "raw": "pub type WithdrawRedeemer<a> {",
          "isPublic": true,
          "source": "anastasia"
        }
      ],
      "constants": [],
      "atoms": [
        {
          "name": "data_to_ints",
          "signature": "fn data_to_ints(d: Data) -> List<Int> {",
          "parameters": [
            {
              "name": "d",
              "type": "Data",
              "optional": false
            }
          ],
          "returnType": "List<Int>",
          "line": 135,
          "raw": "fn data_to_ints(d: Data) -> List<Int> {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn data_to_ints(d: Data) -> List<Int> {\n  expect ints: List<Int> = d\n  ints\n}"
        }
      ],
      "privateTypes": [],
      "privateConstants": [],
      "content": "//// Since transaction size is limited in Cardano, some validators benefit from a\n//// solution which allows them to delegate parts of their logics. This becomes more\n//// prominent in cases where such logics can greatly benefit from optimization\n//// solutions that trade computation resources for script sizes (e.g. table\n//// lookups can take up more space so that costly computations can be averted).\n//// \n//// This design pattern offers an interface for off-loading such logics into an\n//// external withdrawal script, so that the size of the validator itself can stay\n//// within the limits of Cardano.\n//// \n//// > [!NOTE]\n//// > Be aware that total size of reference scripts is currently limited to 200KiB\n//// > (204800 bytes), and they also impose additional fees in an exponential manner.\n//// > See [here](https://github.com/IntersectMBO/cardano-ledger/issues/3952) and [here](https://github.com/CardanoSolutions/ogmios/releases/tag/v6.5.0) for\n//// > more info.\n\nuse aiken/builtin\nuse aiken/collection/pairs\nuse aiken/crypto.{ScriptHash, blake2b_224}\nuse aiken/fuzz\nuse aiken_design_patterns/utils.{sum_of_squares}\nuse cardano/address.{Script}\nuse cardano/transaction.{Redeemer, ScriptPurpose, Withdraw}\n\n/// Datatype for redeemer of the \"computation stake validator\" to represent\n/// input argument(s) and output value(s).\n///\n/// As a simple example, a summation logic where it adds all its inputs\n/// together, can work with a redeemer of\n/// type `WithdrawRedeemerIO<List<Int>, Int>`, and a valid redeemer data would\n/// be:\n/// ```aiken\n/// let valid_summation_io =\n///   WithdrawRedeemerIO {\n///     input_arg: [1, 2, 3, 4, 5],\n///     result: 15,\n///   }\n/// ```\npub type WithdrawRedeemerIO<a, b> {\n  input_arg: a,\n  result: b,\n}\n\n/// Datatype for a delegated validation. Compared to `WithdrawRedeemerIO`, this\n/// datatype only carries input argument(s), and simply validates whether the\n/// computation passes.\npub type WithdrawRedeemer<a> {\n  input_arg: a,\n}\n\n/// Given an arbitrary `Data` as input, this function expects to find\n/// a `Withdraw` script purpose in `redeemers` for `staking_validator`, with a\n/// redeemer of type [`WithdrawRedeemer<Data, Data>`](#withdrawredeemera-b),\n/// which will be coerced into your custom datatypes using your provided `Data`\n/// validators (`input_data_coercer` and `output_data_coercer`).\npub fn delegated_compute(\n  function_input: a,\n  staking_validator: ScriptHash,\n  input_data_coercer: fn(Data) -> a,\n  output_data_coercer: fn(Data) -> b,\n  redeemers: Pairs<ScriptPurpose, Redeemer>,\n) -> b {\n  expect Some(rdmr) =\n    redeemers\n      |> pairs.get_first(Withdraw(Script(staking_validator)))\n  expect WithdrawRedeemerIO { input_arg, result }: WithdrawRedeemerIO<\n    Data,\n    Data,\n  > = rdmr\n\n  let coerced_input = input_data_coercer(input_arg)\n\n  // Given input argument must be identical to the one provided to the\n  // withdrawal validator.\n  expect (coerced_input == function_input)?\n\n  // Return coerced result\n  output_data_coercer(result)\n}\n\n/// Similar to [`delegated_compute`](#delegated_compute), with the difference\n/// that now values are expected to be returned by the staking script.\npub fn delegated_validation(\n  function_input: a,\n  staking_validator: ScriptHash,\n  input_data_coercer: fn(Data) -> a,\n  redeemers: Pairs<ScriptPurpose, Redeemer>,\n) -> Bool {\n  expect Some(rdmr) =\n    redeemers\n      |> pairs.get_first(Withdraw(Script(staking_validator)))\n  expect WithdrawRedeemer { input_arg }: WithdrawRedeemer<Data> = rdmr\n\n  let coerced_input = input_data_coercer(input_arg)\n\n  // Given input argument must be identical to the one provided to the\n  // withdrawal validator.\n  coerced_input == function_input\n}\n\npub fn generic_delegated_validation(\n  staking_validator: ScriptHash,\n  withdraw_redeemer_validator: fn(Data) -> Bool,\n  redeemers: Pairs<ScriptPurpose, Redeemer>,\n) -> Bool {\n  expect Some(rdmr) =\n    redeemers\n      |> pairs.get_first(Withdraw(Script(staking_validator)))\n  withdraw_redeemer_validator(rdmr)\n}\n\n/// Helper function for defining your \"computation stake validator.\" The\n/// resulting stake validator will carry out the provided `function`'s logic,\n/// and `redeemer` must contain the input(s) and expected output(s).\npub fn withdraw_io(\n  function: fn(a) -> b,\n  redeemer: WithdrawRedeemerIO<a, b>,\n) -> Bool {\n  let WithdrawRedeemerIO { input_arg, result } = redeemer\n  let computed_result = function(input_arg)\n  result == computed_result\n}\n\n/// Helper function for defining your delegated validation. The resulting stake\n/// validator will carry out the provided `validation`'s logic with given\n/// input(s) through its redeemer.\npub fn withdraw(\n  validation: fn(a) -> Bool,\n  redeemer: WithdrawRedeemer<a>,\n) -> Bool {\n  let WithdrawRedeemer { input_arg } = redeemer\n  validation(input_arg)\n}\n\nfn data_to_ints(d: Data) -> List<Int> {\n  expect ints: List<Int> = d\n  ints\n}\n\ntest success_delegated_compute(script_hash via fuzz.bytearray_fixed(28)) {\n  let redeemer = WithdrawRedeemerIO([0, 1, 2, 3, 4], 30)\n  let redeemer_data: Data = redeemer\n  let result =\n    delegated_compute(\n      [0, 1, 2, 3, 4],\n      script_hash,\n      data_to_ints,\n      builtin.un_i_data,\n      [Pair(Withdraw(Script(script_hash)), redeemer_data)],\n    )\n  and {\n    result == 30,\n    withdraw_io(sum_of_squares, redeemer),\n  }\n}\n\ntest fail_delegated_compute(script_hash via fuzz.bytearray_fixed(28)) fail {\n  let redeemer = WithdrawRedeemerIO([0, 1, 2, 3, 4], 30)\n  let redeemer_data: Data = redeemer\n  let result =\n    delegated_compute(\n      [0, 1, 2, 3, 4],\n      script_hash,\n      data_to_ints,\n      builtin.un_i_data,\n      [Pair(Withdraw(Script(blake2b_224(script_hash))), redeemer_data)],\n    )\n  and {\n    result == 30,\n    withdraw_io(sum_of_squares, redeemer),\n  }\n}\n\ntest success_delegated_validation(script_hash via fuzz.bytearray_fixed(28)) {\n  let redeemer = WithdrawRedeemer(42)\n  let redeemer_data: Data = redeemer\n  and {\n    delegated_validation(\n      42,\n      script_hash,\n      builtin.un_i_data,\n      [Pair(Withdraw(Script(script_hash)), redeemer_data)],\n    ),\n    withdraw(fn(x: Int) { x == 42 }, redeemer),\n  }\n}\n\ntest fail_delegated_validation(script_hash via fuzz.bytearray_fixed(28)) fail {\n  let redeemer = WithdrawRedeemer(42)\n  let redeemer_data: Data = redeemer\n  and {\n    delegated_validation(\n      42,\n      script_hash,\n      builtin.un_i_data,\n      [Pair(Withdraw(Script(blake2b_224(script_hash))), redeemer_data)],\n    ),\n    withdraw(fn(x: Int) { x == 42 }, redeemer),\n  }\n}\n\ntest success_generic_delegated_validation(\n  script_hash via fuzz.bytearray_fixed(28),\n) {\n  let redeemer_data: Data = builtin.i_data(42)\n  generic_delegated_validation(\n    script_hash,\n    fn(rdmr: Data) -> Bool {\n      let i = builtin.un_i_data(rdmr)\n      i == 42\n    },\n    [Pair(Withdraw(Script(script_hash)), redeemer_data)],\n  )\n}\n\ntest fail_generic_delegated_validation(\n  script_hash via fuzz.bytearray_fixed(28),\n) fail {\n  let redeemer_data: Data = builtin.i_data(42)\n  generic_delegated_validation(\n    script_hash,\n    fn(rdmr: Data) -> Bool {\n      let i = builtin.un_i_data(rdmr)\n      i == 42\n    },\n    [Pair(Withdraw(Script(blake2b_224(script_hash))), redeemer_data)],\n  )\n}\n",
      "dependencies": [
        "aiken/builtin",
        "aiken/collection/pairs",
        "aiken/crypto",
        "aiken/fuzz",
        "aiken_design_patterns/utils",
        "cardano/address",
        "cardano/transaction"
      ],
      "source": "anastasia",
      "isReExportFile": false
    },
    {
      "key": "anastasia:aiken-design-patterns.multi-utxo-indexer-one-to-many",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-design-patterns/lib/aiken-design-patterns/multi-utxo-indexer-one-to-many.ak",
      "name": "aiken-design-patterns.multi-utxo-indexer-one-to-many",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 1,
          "raw": "use aiken/builtin",
          "source": "anastasia"
        },
        {
          "module": "aiken/collection/list",
          "items": [],
          "line": 2,
          "raw": "use aiken/collection/list",
          "source": "anastasia"
        },
        {
          "module": "aiken/crypto",
          "items": ["ScriptHash"],
          "line": 3,
          "raw": "use aiken/crypto.{ScriptHash}",
          "source": "anastasia"
        },
        {
          "module": "aiken/fuzz",
          "items": [],
          "line": 4,
          "raw": "use aiken/fuzz",
          "source": "anastasia"
        },
        {
          "module": "aiken_design_patterns/stake_validator",
          "items": [],
          "line": 5,
          "raw": "use aiken_design_patterns/stake_validator",
          "source": "anastasia"
        },
        {
          "module": "aiken_design_patterns/utils",
          "items": [],
          "line": 6,
          "raw": "use aiken_design_patterns/utils",
          "source": "anastasia"
        },
        {
          "module": "aiken_scott_utils/list",
          "items": [],
          "alias": "list_extra",
          "line": 7,
          "raw": "use aiken_scott_utils/list as list_extra",
          "source": "anastasia"
        },
        {
          "module": "cardano/address",
          "items": ["Address", "Credential", "Script"],
          "line": 8,
          "raw": "use cardano/address.{Address, Credential, Script}",
          "source": "anastasia"
        }
      ],
      "functions": [
        {
          "name": "withdraw_no_redeemer",
          "signature": "pub fn withdraw_no_redeemer(pub fn withdraw_no_redeemer(input_output_validator: fn(Int, Input, Int, Output) -> Bool, input_collective_outputs_validator: fn(Int, Input, List<Output>) -> Bool, collective_inputs_outputs_validator: fn(List<Input>, List<Output>) -> Bool, outer_indices: Pairs<Int, List<Int>>, total_input_count: Int, stake_cred: Credential, tx: Transaction,",
          "documentation": "Use this function inside your withdrawal script to validate all the inputs\ncoming from **the script's spend endpoint**. This is an important detail, as\nthe validator needs to guarantee an exact number of inputs are spent.\n\nIf you want to work with an external staking script, consider\nusing [`withdraw_with_redeemer`](#withdraw_with_redeemer).\n\nThe arguments are:\n1. Validation function on each input, and each of its corresponding outputs\n2. Validation function on each input, against all its outputs\n3. Validation function on all the inputs and all the outputs\n4. `Pairs` of indices, mapping each input to multiple outputs\n5. **Total** number of **inputs**\n6. Staking credential of the wrapping validator (provided by `withdraw`).\n**Note** that in this variant, it can only validate spending the UTxOs\nfrom its own spending endpoint\n7. `Transaction` provided by the validator\n\nFor validation functions, corresponding indices of inputs/outputs are also\nprovided in these functions.",
          "parameters": [],
          "returnType": "Bool, input_collective_outputs_validator: fn(Int, Input, List<Output>) -> Bool, collective_inputs_outputs_validator: fn(List<Input>, List<Output>) -> Bool, outer_indices: Pairs<Int, List<Int>>, total_input_count: Int, stake_cred: Credential, tx: Transaction,",
          "line": 34,
          "raw": "pub fn withdraw_no_redeemer(pub fn withdraw_no_redeemer(input_output_validator: fn(Int, Input, Int, Output) -> Bool, input_collective_outputs_validator: fn(Int, Input, List<Output>) -> Bool, collective_inputs_outputs_validator: fn(List<Input>, List<Output>) -> Bool, outer_indices: Pairs<Int, List<Int>>, total_input_count: Int, stake_cred: Credential, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn withdraw_no_redeemer(\n  input_output_validator: fn(Int, Input, Int, Output) -> Bool,\n  input_collective_outputs_validator: fn(Int, Input, List<Output>) -> Bool,\n  collective_inputs_outputs_validator: fn(List<Input>, List<Output>) -> Bool,\n  outer_indices: Pairs<Int, List<Int>>,\n  total_input_count: Int,\n  stake_cred: Credential,\n  tx: Transaction,\n) -> Bool {\n  stake_validator.withdraw(\n    fn(indices, own_validator, tx) {\n      let Transaction { inputs, outputs, .. } = tx\n      let\n        processed_indices,\n        _,\n        _,\n        all_inputs,\n        all_outputs,\n        remaining_script_inputs_count,\n      <-\n        list_extra.foldr6(\n          inputs,\n          list.reverse(indices),\n          total_input_count,\n          511,\n          [],\n          [],\n          total_input_count - 1,\n          fn(\n            input,\n            remaining_indices,\n            in0,\n            out0,\n            all_inputs_so_far,\n            all_outputs_so_far,\n            i,\n            return,\n          ) {\n            let next_i = i - 1\n            when input.output.address.payment_credential is {\n              Script(script) ->\n                if script == own_validator {\n                  when remaining_indices is {\n                    [] -> fail @\"More UTxOs are spent than specified\"\n                    [Pair(in1, outs), ..rest_of_indices] ->\n                      if i == in1 && in1 < in0 {\n                        let\n                          new_latest_out_ix,\n                          collected_outputs,\n                          all_outputs_so_far_updated,\n                        <-\n                          list_extra.foldr3(\n                            outs,\n                            out0,\n                            [],\n                            all_outputs_so_far,\n                            fn(\n                              curr_out_ix,\n                              prev_out_ix,\n                              outputs_so_far,\n                              outer_all_outputs,\n                              inner_return,\n                            ) {\n                              if curr_out_ix < prev_out_ix {\n                                expect Some(out_utxo) =\n                                  outputs |> list.at(curr_out_ix)\n                                if input_output_validator(\n                                  in1,\n                                  input,\n                                  curr_out_ix,\n                                  out_utxo,\n                                ) {\n                                  inner_return(\n                                    curr_out_ix,\n                                    list.push(outputs_so_far, out_utxo),\n                                    list.push(outer_all_outputs, out_utxo),\n                                  )\n                                } else {\n                                  fail @\"Validation on an input with one of its corresponding outputs failed\"\n                                }\n                              } else {\n                                fail @\"All output indices must be in ascending order\"\n                              }\n                            },\n                          )\n                        if input_collective_outputs_validator(\n                          in1,\n                          input,\n                          collected_outputs,\n                        ) {\n                          return(\n                            rest_of_indices,\n                            in1,\n                            new_latest_out_ix,\n                            list.push(all_inputs_so_far, input),\n                            all_outputs_so_far_updated,\n                            next_i,\n                          )\n                        } else {\n                          fail @\"Validation on the output count failed\"\n                        }\n                      } else {\n                        fail @\"Input and output indices must be in ascending orders\"\n                      }\n                  }\n                } else {\n                  return(\n                    remaining_indices,\n                    in0,\n                    out0,\n                    all_inputs_so_far,\n                    all_outputs_so_far,\n                    next_i,\n                  )\n                }\n              _ ->\n                return(\n                  remaining_indices,\n                  in0,\n                  out0,\n                  all_inputs_so_far,\n                  all_outputs_so_far,\n                  next_i,\n                )\n            }\n          },\n        )\n      and {\n        collective_inputs_outputs_validator(all_inputs, all_outputs),\n        list.is_empty(processed_indices),\n        remaining_script_inputs_count == -1,\n      }\n    },\n    outer_indices,\n    stake_cred,\n    tx,\n  )\n}"
        },
        {
          "name": "withdraw_with_redeemer",
          "signature": "pub fn withdraw_with_redeemer(pub fn withdraw_with_redeemer(spend_redeemer_coercer_and_stake_credential_extractor: fn(Redeemer) -> (a, Credential), input_output_validator: fn(Int, Input, a, Int, Output) -> Bool, input_collective_outputs_validator: fn(Int, Input, a, List<Output>) -> Bool, collective_inputs_outputs_validator: fn(List<Input>, List<Output>) -> Bool, indices: Pairs<Int, List<Int>>, total_script_inputs: Int, stake_cred: Credential, tx: Transaction,",
          "documentation": "A variant of [`withdraw_no_redeemer`](#withdraw_no_redeemer). The difference\nhere is that it gives access to the spend redeemers to your validation\nfunctions.\n\nNote that your spend redeemers are expected to carry the `Credential` to the\nresulting staking script (which is the purpose of the first argument).\n\nThe arguments are:\n1. Validation function on each input, and each of its corresponding outputs\n2. Validation function on each input, against all its outputs\n3. Validation function on all the inputs and all the outputs\n4. `Pairs` of indices, mapping each input to multiple outputs\n5. **Total** number of **script inputs**\n6. Staking credential of the wrapping validator (provided by `withdraw`)\n7. `Transaction` provided by the validator\n\nFor validation functions, corresponding indices of inputs/outputs are also\nprovided in these functions.\n\nUnder the hood, one other difference is that here, instead of traversing all\nthe inputs, there are two traversals: one over the `redeemers`, and another\nover the indices.",
          "parameters": [],
          "returnType": "(a, Credential), input_output_validator: fn(Int, Input, a, Int, Output) -> Bool, input_collective_outputs_validator: fn(Int, Input, a, List<Output>) -> Bool, collective_inputs_outputs_validator: fn(List<Input>, List<Output>) -> Bool, indices: Pairs<Int, List<Int>>, total_script_inputs: Int, stake_cred: Credential, tx: Transaction,",
          "line": 195,
          "raw": "pub fn withdraw_with_redeemer(pub fn withdraw_with_redeemer(spend_redeemer_coercer_and_stake_credential_extractor: fn(Redeemer) -> (a, Credential), input_output_validator: fn(Int, Input, a, Int, Output) -> Bool, input_collective_outputs_validator: fn(Int, Input, a, List<Output>) -> Bool, collective_inputs_outputs_validator: fn(List<Input>, List<Output>) -> Bool, indices: Pairs<Int, List<Int>>, total_script_inputs: Int, stake_cred: Credential, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn withdraw_with_redeemer(\n  spend_redeemer_coercer_and_stake_credential_extractor: fn(Redeemer) ->\n    (a, Credential),\n  input_output_validator: fn(Int, Input, a, Int, Output) -> Bool,\n  input_collective_outputs_validator: fn(Int, Input, a, List<Output>) -> Bool,\n  collective_inputs_outputs_validator: fn(List<Input>, List<Output>) -> Bool,\n  indices: Pairs<Int, List<Int>>,\n  total_script_inputs: Int,\n  stake_cred: Credential,\n  tx: Transaction,\n) -> Bool {\n  let Transaction { inputs, outputs, redeemers, .. } = tx\n  // Folding from left so that redeemers are ordered in reverse. This allows\n  // for cheaper collection of UTxOs in the next fold.\n  let script_redeemers =\n    list.foldl(\n      redeemers,\n      [],\n      fn(redeemer, acc) {\n        let Pair(redeemer_purpose, redeemer_data) = redeemer\n        when redeemer_purpose is {\n          Spend(_) -> {\n            let (coerced_redeemer, stake_credential_from_spend_redeemer) =\n              spend_redeemer_coercer_and_stake_credential_extractor(\n                redeemer_data,\n              )\n            if stake_cred == stake_credential_from_spend_redeemer {\n              list.push(acc, coerced_redeemer)\n            } else {\n              acc\n            }\n          }\n          _ -> acc\n        }\n      },\n    )\n  let\n    processed_redeemers,\n    _,\n    _,\n    all_inputs,\n    all_outputs,\n    remaining_script_inputs_count,\n  <-\n    list_extra.foldr6(\n      indices,\n      script_redeemers,\n      511,\n      511,\n      [],\n      [],\n      total_script_inputs - 1,\n      fn(\n        curr_input_outputs_indices,\n        remaining_redeemers,\n        in0,\n        out0,\n        all_inputs_so_far,\n        all_outputs_so_far,\n        i,\n        return,\n      ) {\n        let next_i = i - 1\n        let Pair(in1, outs) = curr_input_outputs_indices\n        if in1 < in0 {\n          expect Some(in_utxo) = inputs |> list.at(in1)\n          when remaining_redeemers is {\n            [] -> fail @\"More UTxOs are spent than there are redeemers\"\n            [current_redeemer, ..rest_of_redeemers] -> {\n              let\n                new_latest_out_ix,\n                collected_outputs,\n                all_outputs_so_far_updated,\n              <-\n                list_extra.foldr3(\n                  outs,\n                  out0,\n                  [],\n                  all_outputs_so_far,\n                  fn(\n                    curr_out_ix,\n                    prev_out_ix,\n                    outputs_so_far,\n                    outer_all_outputs,\n                    inner_return,\n                  ) {\n                    if curr_out_ix < prev_out_ix {\n                      expect Some(out_utxo) = outputs |> list.at(curr_out_ix)\n                      if input_output_validator(\n                        in1,\n                        in_utxo,\n                        current_redeemer,\n                        curr_out_ix,\n                        out_utxo,\n                      ) {\n                        inner_return(\n                          curr_out_ix,\n                          list.push(outputs_so_far, out_utxo),\n                          list.push(outer_all_outputs, out_utxo),\n                        )\n                      } else {\n                        fail @\"Validation on an input with one of its corresponding outputs failed\"\n                      }\n                    } else {\n                      fail @\"All output indices must be in ascending order\"\n                    }\n                  },\n                )\n              if input_collective_outputs_validator(\n                in1,\n                in_utxo,\n                current_redeemer,\n                collected_outputs,\n              ) {\n                return(\n                  rest_of_redeemers,\n                  in1,\n                  new_latest_out_ix,\n                  list.push(all_inputs_so_far, in_utxo),\n                  all_outputs_so_far_updated,\n                  next_i,\n                )\n              } else {\n                fail @\"Validation on the output count failed\"\n              }\n            }\n          }\n        } else {\n          fail @\"All input indices must be in ascending order\"\n        }\n      },\n    )\n  and {\n    collective_inputs_outputs_validator(all_inputs, all_outputs),\n    list.is_empty(processed_redeemers),\n    remaining_script_inputs_count == -1,\n  }\n}"
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [
        {
          "name": "tests_fuzzer",
          "signature": "fn tests_fuzzer() -> Fuzzer<",
          "parameters": [],
          "returnType": "Fuzzer<",
          "line": 334,
          "raw": "fn tests_fuzzer() -> Fuzzer<",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn tests_fuzzer() -> Fuzzer<\n  (\n    ScriptHash,\n    List<Input>,\n    List<Output>,\n    Pairs<Int, List<Int>>,\n    Int,\n    Pairs<ScriptPurpose, Redeemer>,\n  ),\n> {\n  let script_hash <- fuzz.and_then(fuzz.bytearray_fixed(28))\n  let wallet_inputs <- fuzz.and_then(utils.user_inputs_fuzzer())\n  let script_inputs <-\n    fuzz.and_then(\n      fuzz.list_between(\n        utils.specific_script_input_fuzzer(script_hash, NoDatum),\n        1,\n        10,\n      ),\n    )\n  let inputs = list.concat(wallet_inputs, script_inputs) |> utils.sort_inputs\n  let (script_input_indices, script_outputs) =\n    list.indexed_foldr(\n      inputs,\n      ([], []),\n      fn(i, input, acc) {\n        let (i_indices, outputs) = acc\n        when input.output.address.payment_credential is {\n          Script(_) ->\n            (\n              i_indices |> list.push(i),\n              outputs\n                |> list.push(input.output)\n                |> list.push(input.output)\n                |> list.push(input.output)\n                |> list.push(input.output)\n                |> list.push(input.output),\n            )\n          _ -> acc\n        }\n      },\n    )\n  let redeemer =\n    script_input_indices\n      |> list.indexed_foldr(\n          [],\n          fn(i, script_input_index, acc) {\n            list.push(\n              acc,\n              Pair(script_input_index, list.range(i * 5, i * 5 + 4)),\n            )\n          },\n        )\n  fuzz.constant(\n    (\n      script_hash,\n      inputs,\n      script_outputs,\n      redeemer,\n      list.length(script_inputs),\n      list.map(\n        script_inputs,\n        fn(i) { Pair(Spend(i.output_reference), builtin.i_data(0)) },\n      ),\n    ),\n  )\n}"
        }
      ],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/builtin\nuse aiken/collection/list\nuse aiken/crypto.{ScriptHash}\nuse aiken/fuzz\nuse aiken_design_patterns/stake_validator\nuse aiken_design_patterns/utils\nuse aiken_scott_utils/list as list_extra\nuse cardano/address.{Address, Credential, Script}\nuse cardano/transaction.{\n  Input, NoDatum, Output, Redeemer, ScriptPurpose, Spend, Transaction,\n  placeholder,\n}\n\n/// Use this function inside your withdrawal script to validate all the inputs\n/// coming from **the script's spend endpoint**. This is an important detail, as\n/// the validator needs to guarantee an exact number of inputs are spent.\n///\n/// If you want to work with an external staking script, consider\n/// using [`withdraw_with_redeemer`](#withdraw_with_redeemer).\n///\n/// The arguments are:\n/// 1. Validation function on each input, and each of its corresponding outputs\n/// 2. Validation function on each input, against all its outputs\n/// 3. Validation function on all the inputs and all the outputs\n/// 4. `Pairs` of indices, mapping each input to multiple outputs\n/// 5. **Total** number of **inputs**\n/// 6. Staking credential of the wrapping validator (provided by `withdraw`).\n///    **Note** that in this variant, it can only validate spending the UTxOs\n///    from its own spending endpoint\n/// 7. `Transaction` provided by the validator\n///\n/// For validation functions, corresponding indices of inputs/outputs are also\n/// provided in these functions.\npub fn withdraw_no_redeemer(\n  input_output_validator: fn(Int, Input, Int, Output) -> Bool,\n  input_collective_outputs_validator: fn(Int, Input, List<Output>) -> Bool,\n  collective_inputs_outputs_validator: fn(List<Input>, List<Output>) -> Bool,\n  outer_indices: Pairs<Int, List<Int>>,\n  total_input_count: Int,\n  stake_cred: Credential,\n  tx: Transaction,\n) -> Bool {\n  stake_validator.withdraw(\n    fn(indices, own_validator, tx) {\n      let Transaction { inputs, outputs, .. } = tx\n      let\n        processed_indices,\n        _,\n        _,\n        all_inputs,\n        all_outputs,\n        remaining_script_inputs_count,\n      <-\n        list_extra.foldr6(\n          inputs,\n          list.reverse(indices),\n          total_input_count,\n          511,\n          [],\n          [],\n          total_input_count - 1,\n          fn(\n            input,\n            remaining_indices,\n            in0,\n            out0,\n            all_inputs_so_far,\n            all_outputs_so_far,\n            i,\n            return,\n          ) {\n            let next_i = i - 1\n            when input.output.address.payment_credential is {\n              Script(script) ->\n                if script == own_validator {\n                  when remaining_indices is {\n                    [] -> fail @\"More UTxOs are spent than specified\"\n                    [Pair(in1, outs), ..rest_of_indices] ->\n                      if i == in1 && in1 < in0 {\n                        let\n                          new_latest_out_ix,\n                          collected_outputs,\n                          all_outputs_so_far_updated,\n                        <-\n                          list_extra.foldr3(\n                            outs,\n                            out0,\n                            [],\n                            all_outputs_so_far,\n                            fn(\n                              curr_out_ix,\n                              prev_out_ix,\n                              outputs_so_far,\n                              outer_all_outputs,\n                              inner_return,\n                            ) {\n                              if curr_out_ix < prev_out_ix {\n                                expect Some(out_utxo) =\n                                  outputs |> list.at(curr_out_ix)\n                                if input_output_validator(\n                                  in1,\n                                  input,\n                                  curr_out_ix,\n                                  out_utxo,\n                                ) {\n                                  inner_return(\n                                    curr_out_ix,\n                                    list.push(outputs_so_far, out_utxo),\n                                    list.push(outer_all_outputs, out_utxo),\n                                  )\n                                } else {\n                                  fail @\"Validation on an input with one of its corresponding outputs failed\"\n                                }\n                              } else {\n                                fail @\"All output indices must be in ascending order\"\n                              }\n                            },\n                          )\n                        if input_collective_outputs_validator(\n                          in1,\n                          input,\n                          collected_outputs,\n                        ) {\n                          return(\n                            rest_of_indices,\n                            in1,\n                            new_latest_out_ix,\n                            list.push(all_inputs_so_far, input),\n                            all_outputs_so_far_updated,\n                            next_i,\n                          )\n                        } else {\n                          fail @\"Validation on the output count failed\"\n                        }\n                      } else {\n                        fail @\"Input and output indices must be in ascending orders\"\n                      }\n                  }\n                } else {\n                  return(\n                    remaining_indices,\n                    in0,\n                    out0,\n                    all_inputs_so_far,\n                    all_outputs_so_far,\n                    next_i,\n                  )\n                }\n              _ ->\n                return(\n                  remaining_indices,\n                  in0,\n                  out0,\n                  all_inputs_so_far,\n                  all_outputs_so_far,\n                  next_i,\n                )\n            }\n          },\n        )\n      and {\n        collective_inputs_outputs_validator(all_inputs, all_outputs),\n        list.is_empty(processed_indices),\n        remaining_script_inputs_count == -1,\n      }\n    },\n    outer_indices,\n    stake_cred,\n    tx,\n  )\n}\n\n/// A variant of [`withdraw_no_redeemer`](#withdraw_no_redeemer). The difference\n/// here is that it gives access to the spend redeemers to your validation\n/// functions.\n///\n/// Note that your spend redeemers are expected to carry the `Credential` to the\n/// resulting staking script (which is the purpose of the first argument).\n///\n/// The arguments are:\n/// 1. Validation function on each input, and each of its corresponding outputs\n/// 2. Validation function on each input, against all its outputs\n/// 3. Validation function on all the inputs and all the outputs\n/// 4. `Pairs` of indices, mapping each input to multiple outputs\n/// 5. **Total** number of **script inputs**\n/// 6. Staking credential of the wrapping validator (provided by `withdraw`)\n/// 7. `Transaction` provided by the validator\n///\n/// For validation functions, corresponding indices of inputs/outputs are also\n/// provided in these functions.\n///\n/// Under the hood, one other difference is that here, instead of traversing all\n/// the inputs, there are two traversals: one over the `redeemers`, and another\n/// over the indices.\npub fn withdraw_with_redeemer(\n  spend_redeemer_coercer_and_stake_credential_extractor: fn(Redeemer) ->\n    (a, Credential),\n  input_output_validator: fn(Int, Input, a, Int, Output) -> Bool,\n  input_collective_outputs_validator: fn(Int, Input, a, List<Output>) -> Bool,\n  collective_inputs_outputs_validator: fn(List<Input>, List<Output>) -> Bool,\n  indices: Pairs<Int, List<Int>>,\n  total_script_inputs: Int,\n  stake_cred: Credential,\n  tx: Transaction,\n) -> Bool {\n  let Transaction { inputs, outputs, redeemers, .. } = tx\n  // Folding from left so that redeemers are ordered in reverse. This allows\n  // for cheaper collection of UTxOs in the next fold.\n  let script_redeemers =\n    list.foldl(\n      redeemers,\n      [],\n      fn(redeemer, acc) {\n        let Pair(redeemer_purpose, redeemer_data) = redeemer\n        when redeemer_purpose is {\n          Spend(_) -> {\n            let (coerced_redeemer, stake_credential_from_spend_redeemer) =\n              spend_redeemer_coercer_and_stake_credential_extractor(\n                redeemer_data,\n              )\n            if stake_cred == stake_credential_from_spend_redeemer {\n              list.push(acc, coerced_redeemer)\n            } else {\n              acc\n            }\n          }\n          _ -> acc\n        }\n      },\n    )\n  let\n    processed_redeemers,\n    _,\n    _,\n    all_inputs,\n    all_outputs,\n    remaining_script_inputs_count,\n  <-\n    list_extra.foldr6(\n      indices,\n      script_redeemers,\n      511,\n      511,\n      [],\n      [],\n      total_script_inputs - 1,\n      fn(\n        curr_input_outputs_indices,\n        remaining_redeemers,\n        in0,\n        out0,\n        all_inputs_so_far,\n        all_outputs_so_far,\n        i,\n        return,\n      ) {\n        let next_i = i - 1\n        let Pair(in1, outs) = curr_input_outputs_indices\n        if in1 < in0 {\n          expect Some(in_utxo) = inputs |> list.at(in1)\n          when remaining_redeemers is {\n            [] -> fail @\"More UTxOs are spent than there are redeemers\"\n            [current_redeemer, ..rest_of_redeemers] -> {\n              let\n                new_latest_out_ix,\n                collected_outputs,\n                all_outputs_so_far_updated,\n              <-\n                list_extra.foldr3(\n                  outs,\n                  out0,\n                  [],\n                  all_outputs_so_far,\n                  fn(\n                    curr_out_ix,\n                    prev_out_ix,\n                    outputs_so_far,\n                    outer_all_outputs,\n                    inner_return,\n                  ) {\n                    if curr_out_ix < prev_out_ix {\n                      expect Some(out_utxo) = outputs |> list.at(curr_out_ix)\n                      if input_output_validator(\n                        in1,\n                        in_utxo,\n                        current_redeemer,\n                        curr_out_ix,\n                        out_utxo,\n                      ) {\n                        inner_return(\n                          curr_out_ix,\n                          list.push(outputs_so_far, out_utxo),\n                          list.push(outer_all_outputs, out_utxo),\n                        )\n                      } else {\n                        fail @\"Validation on an input with one of its corresponding outputs failed\"\n                      }\n                    } else {\n                      fail @\"All output indices must be in ascending order\"\n                    }\n                  },\n                )\n              if input_collective_outputs_validator(\n                in1,\n                in_utxo,\n                current_redeemer,\n                collected_outputs,\n              ) {\n                return(\n                  rest_of_redeemers,\n                  in1,\n                  new_latest_out_ix,\n                  list.push(all_inputs_so_far, in_utxo),\n                  all_outputs_so_far_updated,\n                  next_i,\n                )\n              } else {\n                fail @\"Validation on the output count failed\"\n              }\n            }\n          }\n        } else {\n          fail @\"All input indices must be in ascending order\"\n        }\n      },\n    )\n  and {\n    collective_inputs_outputs_validator(all_inputs, all_outputs),\n    list.is_empty(processed_redeemers),\n    remaining_script_inputs_count == -1,\n  }\n}\n\nfn tests_fuzzer() -> Fuzzer<\n  (\n    ScriptHash,\n    List<Input>,\n    List<Output>,\n    Pairs<Int, List<Int>>,\n    Int,\n    Pairs<ScriptPurpose, Redeemer>,\n  ),\n> {\n  let script_hash <- fuzz.and_then(fuzz.bytearray_fixed(28))\n  let wallet_inputs <- fuzz.and_then(utils.user_inputs_fuzzer())\n  let script_inputs <-\n    fuzz.and_then(\n      fuzz.list_between(\n        utils.specific_script_input_fuzzer(script_hash, NoDatum),\n        1,\n        10,\n      ),\n    )\n  let inputs = list.concat(wallet_inputs, script_inputs) |> utils.sort_inputs\n  let (script_input_indices, script_outputs) =\n    list.indexed_foldr(\n      inputs,\n      ([], []),\n      fn(i, input, acc) {\n        let (i_indices, outputs) = acc\n        when input.output.address.payment_credential is {\n          Script(_) ->\n            (\n              i_indices |> list.push(i),\n              outputs\n                |> list.push(input.output)\n                |> list.push(input.output)\n                |> list.push(input.output)\n                |> list.push(input.output)\n                |> list.push(input.output),\n            )\n          _ -> acc\n        }\n      },\n    )\n  let redeemer =\n    script_input_indices\n      |> list.indexed_foldr(\n          [],\n          fn(i, script_input_index, acc) {\n            list.push(\n              acc,\n              Pair(script_input_index, list.range(i * 5, i * 5 + 4)),\n            )\n          },\n        )\n  fuzz.constant(\n    (\n      script_hash,\n      inputs,\n      script_outputs,\n      redeemer,\n      list.length(script_inputs),\n      list.map(\n        script_inputs,\n        fn(i) { Pair(Spend(i.output_reference), builtin.i_data(0)) },\n      ),\n    ),\n  )\n}\n\ntest success_withdraw_no_redeemer(test_values via tests_fuzzer()) {\n  let (\n    script_hash,\n    inputs,\n    script_outputs,\n    indices,\n    _script_input_count,\n    _redeemers,\n  ) = test_values\n  let tx =\n    Transaction { ..placeholder, inputs: inputs, outputs: script_outputs }\n  withdraw_no_redeemer(\n    fn(_ii, _i, _oi, _o) { True },\n    fn(_ii, _i, _os) { True },\n    fn(_is, _os) { True },\n    indices,\n    list.length(inputs),\n    Script(script_hash),\n    tx,\n  )\n}\n\ntest fail_withdraw_no_redeemer(test_values via tests_fuzzer()) fail {\n  let (\n    script_hash,\n    inputs,\n    _script_outputs,\n    indices,\n    script_input_count,\n    _redeemers,\n  ) = test_values\n  let tx = Transaction { ..placeholder, inputs: inputs, outputs: [] }\n  withdraw_no_redeemer(\n    fn(_ii, _i, _oi, _o) { True },\n    fn(_ii, _i, _os) { True },\n    fn(_is, _os) { True },\n    indices,\n    script_input_count,\n    Script(script_hash),\n    tx,\n  )\n}\n\ntest success_withdraw_with_redeemer(test_values via tests_fuzzer()) {\n  let (\n    script_hash,\n    inputs,\n    script_outputs,\n    indices,\n    script_input_count,\n    redeemers,\n  ) = test_values\n  let tx =\n    Transaction {\n      ..placeholder,\n      inputs: inputs,\n      outputs: script_outputs,\n      redeemers: redeemers,\n    }\n  withdraw_with_redeemer(\n    fn(_d) { (0, Script(script_hash)) },\n    fn(_ii, _i, _r, _oi, _o) { True },\n    fn(_ii, _i, _r, _os) { True },\n    fn(_is, _os) { True },\n    indices,\n    script_input_count,\n    Script(script_hash),\n    tx,\n  )\n}\n\ntest fail_withdraw_with_redeemer(test_values via tests_fuzzer()) fail {\n  let (\n    script_hash,\n    inputs,\n    _script_outputs,\n    indices,\n    script_input_count,\n    _redeemers,\n  ) = test_values\n  let tx =\n    Transaction { ..placeholder, inputs: inputs, outputs: [], redeemers: [] }\n  withdraw_with_redeemer(\n    fn(_d) { (0, Script(script_hash)) },\n    fn(_ii, _i, _r, _oi, _o) { True },\n    fn(_ii, _i, _r, _os) { True },\n    fn(_is, _os) { True },\n    indices,\n    script_input_count,\n    Script(script_hash),\n    tx,\n  )\n}\n",
      "dependencies": [
        "aiken/builtin",
        "aiken/collection/list",
        "aiken/crypto",
        "aiken/fuzz",
        "aiken_design_patterns/stake_validator",
        "aiken_design_patterns/utils",
        "aiken_scott_utils/list",
        "cardano/address"
      ],
      "source": "anastasia",
      "isReExportFile": false
    },
    {
      "key": "anastasia:aiken-design-patterns.multi-utxo-indexer",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-design-patterns/lib/aiken-design-patterns/multi-utxo-indexer.ak",
      "name": "aiken-design-patterns.multi-utxo-indexer",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 1,
          "raw": "use aiken/builtin",
          "source": "anastasia"
        },
        {
          "module": "aiken/collection/list",
          "items": [],
          "line": 2,
          "raw": "use aiken/collection/list",
          "source": "anastasia"
        },
        {
          "module": "aiken/crypto",
          "items": ["ScriptHash"],
          "line": 3,
          "raw": "use aiken/crypto.{ScriptHash}",
          "source": "anastasia"
        },
        {
          "module": "aiken/fuzz",
          "items": [],
          "line": 4,
          "raw": "use aiken/fuzz",
          "source": "anastasia"
        },
        {
          "module": "aiken_design_patterns/stake_validator",
          "items": [],
          "line": 5,
          "raw": "use aiken_design_patterns/stake_validator",
          "source": "anastasia"
        },
        {
          "module": "aiken_design_patterns/utils",
          "items": [],
          "line": 6,
          "raw": "use aiken_design_patterns/utils",
          "source": "anastasia"
        },
        {
          "module": "aiken_scott_utils/list",
          "items": [],
          "alias": "list_extra",
          "line": 7,
          "raw": "use aiken_scott_utils/list as list_extra",
          "source": "anastasia"
        },
        {
          "module": "cardano/address",
          "items": ["Address", "Credential", "Script"],
          "line": 8,
          "raw": "use cardano/address.{Address, Credential, Script}",
          "source": "anastasia"
        }
      ],
      "functions": [
        {
          "name": "withdraw_no_redeemer",
          "signature": "pub fn withdraw_no_redeemer(pub fn withdraw_no_redeemer(validation_logic: fn(Int, Input, Int, Output) -> Bool, indices: Pairs<Int, Int>, stake_cred: Credential, tx: Transaction,",
          "documentation": "Helper function to complement your staking script. Note that this function\nexpects to see an equal number of inputs coming from addresses whose payment\nparts are **equal to its own** (`stake_cred`). This is an important detail,\nas the validator needs to guarantee an exact number of inputs are spent.\n\nThe validation function you should provide has access to:\n- Index of the `Input` being validated\n- The `Input` itself\n- Index of the `Output` being validated\n- The `Output` itself",
          "parameters": [],
          "returnType": "Bool, indices: Pairs<Int, Int>, stake_cred: Credential, tx: Transaction,",
          "line": 24,
          "raw": "pub fn withdraw_no_redeemer(pub fn withdraw_no_redeemer(validation_logic: fn(Int, Input, Int, Output) -> Bool, indices: Pairs<Int, Int>, stake_cred: Credential, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn withdraw_no_redeemer(\n  validation_logic: fn(Int, Input, Int, Output) -> Bool,\n  indices: Pairs<Int, Int>,\n  stake_cred: Credential,\n  tx: Transaction,\n) -> Bool {\n  stake_validator.withdraw(\n    fn(indices, own_validator, tx) {\n      let Transaction { inputs, outputs, .. } = tx\n      let\n        processed_indices,\n        _,\n        _,\n        _,\n      <-\n        list_extra.foldl4(\n          inputs,\n          indices,\n          -1,\n          -1,\n          0,\n          fn(input, remaining_indices, in0, out0, i, return) {\n            let next_i = i + 1\n            when input.output.address.payment_credential is {\n              Script(script) ->\n                if script == own_validator {\n                  when remaining_indices is {\n                    [] -> fail @\"More UTxOs are spent than specified\"\n                    [Pair(in1, out1), ..rest_of_indices] ->\n                      if i == in1 && in1 > in0 && out1 > out0 {\n                        expect Some(out_utxo) = outputs |> list.at(out1)\n                        if validation_logic(in1, input, out1, out_utxo) {\n                          return(rest_of_indices, in1, out1, next_i)\n                        } else {\n                          fail @\"Validation failed\"\n                        }\n                      } else {\n                        fail @\"Input and output indices must be in ascending orders\"\n                      }\n                  }\n                } else {\n                  return(remaining_indices, in0, out0, next_i)\n                }\n              _ -> return(remaining_indices, in0, out0, next_i)\n            }\n          },\n        )\n      (processed_indices == [])?\n    },\n    indices,\n    stake_cred,\n    tx,\n  )\n}"
        },
        {
          "name": "withdraw_with_redeemer",
          "signature": "pub fn withdraw_with_redeemer(pub fn withdraw_with_redeemer(spend_redeemer_coercer_and_stake_credential_extractor: fn(Data) -> (a, Credential), validation_logic: fn(Int, Input, a, Int, Output) -> Bool, indices: Pairs<Int, Int>, stake_cred: Credential, tx: Transaction,",
          "documentation": "Another variant that is independent of the spending validator, and also\nprovides the validation logic with each UTxO's redeemer. Subsequently, an\nadditional argument must be provided, capable of coercing a redeemer `Data`\nto spending script's redeemer, and also extracting the staking credential of\nthe script that performs the validation.\n\nUnder the hood, one other difference is that here, instead of traversing all\nthe inputs, there are two traversals: one over the `redeemers`, and another\nover the indices.",
          "parameters": [],
          "returnType": "(a, Credential), validation_logic: fn(Int, Input, a, Int, Output) -> Bool, indices: Pairs<Int, Int>, stake_cred: Credential, tx: Transaction,",
          "line": 88,
          "raw": "pub fn withdraw_with_redeemer(pub fn withdraw_with_redeemer(spend_redeemer_coercer_and_stake_credential_extractor: fn(Data) -> (a, Credential), validation_logic: fn(Int, Input, a, Int, Output) -> Bool, indices: Pairs<Int, Int>, stake_cred: Credential, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn withdraw_with_redeemer(\n  spend_redeemer_coercer_and_stake_credential_extractor: fn(Data) ->\n    (a, Credential),\n  validation_logic: fn(Int, Input, a, Int, Output) -> Bool,\n  indices: Pairs<Int, Int>,\n  stake_cred: Credential,\n  tx: Transaction,\n) -> Bool {\n  let Transaction { inputs, outputs, redeemers, .. } = tx\n  let script_redeemers =\n    list.foldr(\n      redeemers,\n      [],\n      fn(redeemer, acc) {\n        let Pair(redeemer_purpose, redeemer_data) = redeemer\n        when redeemer_purpose is {\n          Spend(_) -> {\n            let (coerced_redeemer, stake_credential_from_spend_redeemer) =\n              spend_redeemer_coercer_and_stake_credential_extractor(\n                redeemer_data,\n              )\n            if stake_cred == stake_credential_from_spend_redeemer {\n              list.push(acc, coerced_redeemer)\n            } else {\n              acc\n            }\n          }\n          _ -> acc\n        }\n      },\n    )\n  let\n    processed_redeemers,\n    _,\n    _,\n    _,\n  <-\n    list_extra.foldl4(\n      indices,\n      script_redeemers,\n      -1,\n      -1,\n      0,\n      fn(curr_in_out_indices, remaining_script_redeemers, in0, out0, i, return) {\n        when remaining_script_redeemers is {\n          [] -> fail @\"Too many indices specified\"\n          [script_redeemer, ..rest_of_script_redeemers] -> {\n            let Pair(in1, out1) = curr_in_out_indices\n            if in1 > in0 && out1 > out0 {\n              expect Some(in_utxo) = inputs |> list.at(in1)\n              expect Some(out_utxo) = outputs |> list.at(out1)\n              if validation_logic(in1, in_utxo, script_redeemer, out1, out_utxo) {\n                return(rest_of_script_redeemers, in1, out1, i + 1)\n              } else {\n                fail @\"Validation failed\"\n              }\n            } else {\n              // Input and output indices must be ordered to disallow duplicates.\n              fail @\"Input and output indices must be in ascending orders\"\n            }\n          }\n        }\n      },\n    )\n  (processed_redeemers == [])?\n}"
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [
        {
          "name": "tests_fuzzer",
          "signature": "fn tests_fuzzer() -> Fuzzer<",
          "parameters": [],
          "returnType": "Fuzzer<",
          "line": 155,
          "raw": "fn tests_fuzzer() -> Fuzzer<",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn tests_fuzzer() -> Fuzzer<\n  (\n    ScriptHash,\n    List<Input>,\n    List<Output>,\n    Pairs<Int, Int>,\n    Pairs<ScriptPurpose, Redeemer>,\n  ),\n> {\n  let script_hash <- fuzz.and_then(fuzz.bytearray_fixed(28))\n  let wallet_inputs <- fuzz.and_then(utils.user_inputs_fuzzer())\n  let script_inputs <-\n    fuzz.and_then(\n      fuzz.list_between(\n        utils.specific_script_input_fuzzer(script_hash, NoDatum),\n        1,\n        10,\n      ),\n    )\n  let inputs = list.concat(wallet_inputs, script_inputs) |> utils.sort_inputs\n  let (script_input_indices, script_outputs) =\n    list.indexed_foldr(\n      inputs,\n      ([], []),\n      fn(i, input, acc) {\n        let (i_indices, outputs) = acc\n        when input.output.address.payment_credential is {\n          Script(_) ->\n            (i_indices |> list.push(i), outputs |> list.push(input.output))\n          _ -> acc\n        }\n      },\n    )\n  let redeemer =\n    script_input_indices\n      |> list.indexed_foldr(\n          [],\n          fn(i, script_input_index, acc) {\n            list.push(acc, Pair(script_input_index, i))\n          },\n        )\n  fuzz.constant(\n    (\n      script_hash,\n      inputs,\n      script_outputs,\n      redeemer,\n      list.map(\n        script_inputs,\n        fn(i) { Pair(Spend(i.output_reference), builtin.i_data(0)) },\n      ),\n    ),\n  )\n}"
        }
      ],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/builtin\nuse aiken/collection/list\nuse aiken/crypto.{ScriptHash}\nuse aiken/fuzz\nuse aiken_design_patterns/stake_validator\nuse aiken_design_patterns/utils\nuse aiken_scott_utils/list as list_extra\nuse cardano/address.{Address, Credential, Script}\nuse cardano/transaction.{\n  Input, NoDatum, Output, Redeemer, ScriptPurpose, Spend, Transaction,\n  placeholder,\n}\n\n/// Helper function to complement your staking script. Note that this function\n/// expects to see an equal number of inputs coming from addresses whose payment\n/// parts are **equal to its own** (`stake_cred`). This is an important detail,\n/// as the validator needs to guarantee an exact number of inputs are spent.\n///\n/// The validation function you should provide has access to:\n/// - Index of the `Input` being validated\n/// - The `Input` itself\n/// - Index of the `Output` being validated\n/// - The `Output` itself\npub fn withdraw_no_redeemer(\n  validation_logic: fn(Int, Input, Int, Output) -> Bool,\n  indices: Pairs<Int, Int>,\n  stake_cred: Credential,\n  tx: Transaction,\n) -> Bool {\n  stake_validator.withdraw(\n    fn(indices, own_validator, tx) {\n      let Transaction { inputs, outputs, .. } = tx\n      let\n        processed_indices,\n        _,\n        _,\n        _,\n      <-\n        list_extra.foldl4(\n          inputs,\n          indices,\n          -1,\n          -1,\n          0,\n          fn(input, remaining_indices, in0, out0, i, return) {\n            let next_i = i + 1\n            when input.output.address.payment_credential is {\n              Script(script) ->\n                if script == own_validator {\n                  when remaining_indices is {\n                    [] -> fail @\"More UTxOs are spent than specified\"\n                    [Pair(in1, out1), ..rest_of_indices] ->\n                      if i == in1 && in1 > in0 && out1 > out0 {\n                        expect Some(out_utxo) = outputs |> list.at(out1)\n                        if validation_logic(in1, input, out1, out_utxo) {\n                          return(rest_of_indices, in1, out1, next_i)\n                        } else {\n                          fail @\"Validation failed\"\n                        }\n                      } else {\n                        fail @\"Input and output indices must be in ascending orders\"\n                      }\n                  }\n                } else {\n                  return(remaining_indices, in0, out0, next_i)\n                }\n              _ -> return(remaining_indices, in0, out0, next_i)\n            }\n          },\n        )\n      (processed_indices == [])?\n    },\n    indices,\n    stake_cred,\n    tx,\n  )\n}\n\n/// Another variant that is independent of the spending validator, and also\n/// provides the validation logic with each UTxO's redeemer. Subsequently, an\n/// additional argument must be provided, capable of coercing a redeemer `Data`\n/// to spending script's redeemer, and also extracting the staking credential of\n/// the script that performs the validation.\n///\n/// Under the hood, one other difference is that here, instead of traversing all\n/// the inputs, there are two traversals: one over the `redeemers`, and another\n/// over the indices.\npub fn withdraw_with_redeemer(\n  spend_redeemer_coercer_and_stake_credential_extractor: fn(Data) ->\n    (a, Credential),\n  validation_logic: fn(Int, Input, a, Int, Output) -> Bool,\n  indices: Pairs<Int, Int>,\n  stake_cred: Credential,\n  tx: Transaction,\n) -> Bool {\n  let Transaction { inputs, outputs, redeemers, .. } = tx\n  let script_redeemers =\n    list.foldr(\n      redeemers,\n      [],\n      fn(redeemer, acc) {\n        let Pair(redeemer_purpose, redeemer_data) = redeemer\n        when redeemer_purpose is {\n          Spend(_) -> {\n            let (coerced_redeemer, stake_credential_from_spend_redeemer) =\n              spend_redeemer_coercer_and_stake_credential_extractor(\n                redeemer_data,\n              )\n            if stake_cred == stake_credential_from_spend_redeemer {\n              list.push(acc, coerced_redeemer)\n            } else {\n              acc\n            }\n          }\n          _ -> acc\n        }\n      },\n    )\n  let\n    processed_redeemers,\n    _,\n    _,\n    _,\n  <-\n    list_extra.foldl4(\n      indices,\n      script_redeemers,\n      -1,\n      -1,\n      0,\n      fn(curr_in_out_indices, remaining_script_redeemers, in0, out0, i, return) {\n        when remaining_script_redeemers is {\n          [] -> fail @\"Too many indices specified\"\n          [script_redeemer, ..rest_of_script_redeemers] -> {\n            let Pair(in1, out1) = curr_in_out_indices\n            if in1 > in0 && out1 > out0 {\n              expect Some(in_utxo) = inputs |> list.at(in1)\n              expect Some(out_utxo) = outputs |> list.at(out1)\n              if validation_logic(in1, in_utxo, script_redeemer, out1, out_utxo) {\n                return(rest_of_script_redeemers, in1, out1, i + 1)\n              } else {\n                fail @\"Validation failed\"\n              }\n            } else {\n              // Input and output indices must be ordered to disallow duplicates.\n              fail @\"Input and output indices must be in ascending orders\"\n            }\n          }\n        }\n      },\n    )\n  (processed_redeemers == [])?\n}\n\nfn tests_fuzzer() -> Fuzzer<\n  (\n    ScriptHash,\n    List<Input>,\n    List<Output>,\n    Pairs<Int, Int>,\n    Pairs<ScriptPurpose, Redeemer>,\n  ),\n> {\n  let script_hash <- fuzz.and_then(fuzz.bytearray_fixed(28))\n  let wallet_inputs <- fuzz.and_then(utils.user_inputs_fuzzer())\n  let script_inputs <-\n    fuzz.and_then(\n      fuzz.list_between(\n        utils.specific_script_input_fuzzer(script_hash, NoDatum),\n        1,\n        10,\n      ),\n    )\n  let inputs = list.concat(wallet_inputs, script_inputs) |> utils.sort_inputs\n  let (script_input_indices, script_outputs) =\n    list.indexed_foldr(\n      inputs,\n      ([], []),\n      fn(i, input, acc) {\n        let (i_indices, outputs) = acc\n        when input.output.address.payment_credential is {\n          Script(_) ->\n            (i_indices |> list.push(i), outputs |> list.push(input.output))\n          _ -> acc\n        }\n      },\n    )\n  let redeemer =\n    script_input_indices\n      |> list.indexed_foldr(\n          [],\n          fn(i, script_input_index, acc) {\n            list.push(acc, Pair(script_input_index, i))\n          },\n        )\n  fuzz.constant(\n    (\n      script_hash,\n      inputs,\n      script_outputs,\n      redeemer,\n      list.map(\n        script_inputs,\n        fn(i) { Pair(Spend(i.output_reference), builtin.i_data(0)) },\n      ),\n    ),\n  )\n}\n\ntest success_withdraw_no_redeemer(test_values via tests_fuzzer()) {\n  let (script_hash, inputs, script_outputs, redeemer, _redeemers) = test_values\n  let tx =\n    Transaction { ..placeholder, inputs: inputs, outputs: script_outputs }\n  withdraw_no_redeemer(\n    fn(_ii, _i, _oi, _o) { True },\n    redeemer,\n    Script(script_hash),\n    tx,\n  )\n}\n\ntest fail_withdraw_no_redeemer(test_values via tests_fuzzer()) fail {\n  let (script_hash, inputs, _script_outputs, redeemer, _redeemers) = test_values\n  let tx = Transaction { ..placeholder, inputs: inputs, outputs: [] }\n  withdraw_no_redeemer(\n    fn(_ii, _i, _oi, _o) { True },\n    redeemer,\n    Script(script_hash),\n    tx,\n  )\n}\n\ntest success_withdraw_with_redeemer(test_values via tests_fuzzer()) {\n  let (script_hash, inputs, script_outputs, redeemer, redeemers) = test_values\n  let tx =\n    Transaction {\n      ..placeholder,\n      inputs: inputs,\n      outputs: script_outputs,\n      redeemers: redeemers,\n    }\n  withdraw_with_redeemer(\n    fn(_d) { (0, Script(script_hash)) },\n    fn(_ii, _i, _r, _oi, _o) { True },\n    redeemer,\n    Script(script_hash),\n    tx,\n  )\n}\n\ntest fail_withdraw_with_redeemer(test_values via tests_fuzzer()) fail {\n  let (script_hash, inputs, script_outputs, redeemer, _redeemers) = test_values\n  let tx =\n    Transaction {\n      ..placeholder,\n      inputs: inputs,\n      outputs: script_outputs,\n      redeemers: [],\n    }\n  withdraw_with_redeemer(\n    fn(_d) { (0, Script(script_hash)) },\n    fn(_ii, _i, _r, _oi, _o) { True },\n    redeemer,\n    Script(script_hash),\n    tx,\n  )\n}\n",
      "dependencies": [
        "aiken/builtin",
        "aiken/collection/list",
        "aiken/crypto",
        "aiken/fuzz",
        "aiken_design_patterns/stake_validator",
        "aiken_design_patterns/utils",
        "aiken_scott_utils/list",
        "cardano/address"
      ],
      "source": "anastasia",
      "isReExportFile": false
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-design-patterns/lib/aiken-design-patterns/parameter-validation.ak",
      "name": "aiken-design-patterns.parameter-validation",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 33,
          "raw": "use aiken/builtin",
          "source": "anastasia"
        },
        {
          "module": "aiken/crypto",
          "items": ["Blake2b_224", "Hash", "ScriptHash", "blake2b_224"],
          "line": 34,
          "raw": "use aiken/crypto.{Blake2b_224, Hash, ScriptHash, blake2b_224}",
          "source": "anastasia"
        },
        {
          "module": "aiken/primitive/bytearray",
          "items": [],
          "line": 35,
          "raw": "use aiken/primitive/bytearray",
          "source": "anastasia"
        },
        {
          "module": "cardano/transaction",
          "items": ["OutputReference", "Transaction"],
          "line": 36,
          "raw": "use cardano/transaction.{OutputReference, Transaction}",
          "source": "anastasia"
        }
      ],
      "functions": [
        {
          "name": "apply_param",
          "signature": "pub fn apply_param(pub fn apply_param(version: Int, prefix: ByteArray, param: ByteArray, ) -> ScriptHash {",
          "documentation": "Use this inside your dependent script for single parameter scripts. The\nparameter must be serialised before getting passed here. It'll be hashed\nwith `blake2b_224` before placement after `prefix`.\n\nNote that your prefix should be from a single CBOR encoded result. And also,\nthe version should either be 1, 2, or 3 depending on your script.",
          "parameters": [],
          "returnType": "ScriptHash",
          "line": 73,
          "raw": "pub fn apply_param(pub fn apply_param(version: Int, prefix: ByteArray, param: ByteArray, ) -> ScriptHash {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn apply_param(\n  version: Int,\n  prefix: ByteArray,\n  param: ByteArray,\n) -> ScriptHash {\n  append_first_param_to_prefix(version, prefix, param)\n    |> bytearray.concat(postfix)\n    |> blake2b_224\n}"
        },
        {
          "name": "apply_prehashed_param",
          "signature": "pub fn apply_prehashed_param(pub fn apply_prehashed_param(version: Int, prefix: ByteArray, param: ByteArray, ) -> ScriptHash {",
          "documentation": "Similar to [`apply_param`](#apply_param), but for scripts that their\nparameters don't need to be resolved (e.g. have a script hash as their\nparameter).\n\nNote that `blake2b_224` is the presumed hashing algorithm, i.e. the\nparameter is expected to be 28 bytes long.",
          "parameters": [],
          "returnType": "ScriptHash",
          "line": 89,
          "raw": "pub fn apply_prehashed_param(pub fn apply_prehashed_param(version: Int, prefix: ByteArray, param: ByteArray, ) -> ScriptHash {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn apply_prehashed_param(\n  version: Int,\n  prefix: ByteArray,\n  param: ByteArray,\n) -> ScriptHash {\n  append_first_prehashed_param_to_prefix(version, prefix, param)\n    |> bytearray.concat(postfix)\n    |> blake2b_224\n}"
        },
        {
          "name": "apply_param_2",
          "signature": "pub fn apply_param_2(pub fn apply_param_2(version: Int, prefix: ByteArray, param_0: ByteArray, param_1: ByteArray, ) -> ScriptHash {",
          "documentation": "Similar to [`apply_param`](#apply_param), but for scripts with 2 parameters.",
          "parameters": [],
          "returnType": "ScriptHash",
          "line": 100,
          "raw": "pub fn apply_param_2(pub fn apply_param_2(version: Int, prefix: ByteArray, param_0: ByteArray, param_1: ByteArray, ) -> ScriptHash {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn apply_param_2(\n  version: Int,\n  prefix: ByteArray,\n  param_0: ByteArray,\n  param_1: ByteArray,\n) -> ScriptHash {\n  append_first_param_to_prefix(version, prefix, param_0)\n    |> bytearray.concat(param_header_28_bytes)\n    |> append_param(param_1)\n    |> bytearray.concat(postfix)\n    |> blake2b_224\n}"
        },
        {
          "name": "apply_prehashed_param_2",
          "signature": "pub fn apply_prehashed_param_2(pub fn apply_prehashed_param_2(version: Int, prefix: ByteArray, param_0: ByteArray, param_1: ByteArray, ) -> ScriptHash {",
          "documentation": "Similar to [`apply_prehashed_param`](#apply_prehashed_param), but for\nscripts with 2 parameters.",
          "parameters": [],
          "returnType": "ScriptHash",
          "line": 115,
          "raw": "pub fn apply_prehashed_param_2(pub fn apply_prehashed_param_2(version: Int, prefix: ByteArray, param_0: ByteArray, param_1: ByteArray, ) -> ScriptHash {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn apply_prehashed_param_2(\n  version: Int,\n  prefix: ByteArray,\n  param_0: ByteArray,\n  param_1: ByteArray,\n) -> ScriptHash {\n  append_first_prehashed_param_to_prefix(version, prefix, param_0)\n    |> bytearray.concat(param_header_28_bytes)\n    |> bytearray.concat(param_1)\n    |> bytearray.concat(postfix)\n    |> blake2b_224\n}"
        },
        {
          "name": "apply_param_3",
          "signature": "pub fn apply_param_3(pub fn apply_param_3(version: Int, prefix: ByteArray, param_0: ByteArray, param_1: ByteArray, param_2: ByteArray, ) -> ScriptHash {",
          "documentation": "Similar to [`apply_param`](#apply_param), but for scripts with 3 parameters.",
          "parameters": [],
          "returnType": "ScriptHash",
          "line": 129,
          "raw": "pub fn apply_param_3(pub fn apply_param_3(version: Int, prefix: ByteArray, param_0: ByteArray, param_1: ByteArray, param_2: ByteArray, ) -> ScriptHash {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn apply_param_3(\n  version: Int,\n  prefix: ByteArray,\n  param_0: ByteArray,\n  param_1: ByteArray,\n  param_2: ByteArray,\n) -> ScriptHash {\n  append_first_param_to_prefix(version, prefix, param_0)\n    |> bytearray.concat(param_header_28_bytes)\n    |> append_param(param_1)\n    |> bytearray.concat(param_header_28_bytes)\n    |> append_param(param_2)\n    |> bytearray.concat(postfix)\n    |> blake2b_224\n}"
        },
        {
          "name": "apply_prehashed_param_3",
          "signature": "pub fn apply_prehashed_param_3(pub fn apply_prehashed_param_3(version: Int, prefix: ByteArray, param_0: ByteArray, param_1: ByteArray, param_2: ByteArray, ) -> ScriptHash {",
          "documentation": "Similar to [`apply_prehashed_param`](#apply_prehashed_param), but for\nscripts with 3 parameters.",
          "parameters": [],
          "returnType": "ScriptHash",
          "line": 147,
          "raw": "pub fn apply_prehashed_param_3(pub fn apply_prehashed_param_3(version: Int, prefix: ByteArray, param_0: ByteArray, param_1: ByteArray, param_2: ByteArray, ) -> ScriptHash {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn apply_prehashed_param_3(\n  version: Int,\n  prefix: ByteArray,\n  param_0: ByteArray,\n  param_1: ByteArray,\n  param_2: ByteArray,\n) -> ScriptHash {\n  append_first_prehashed_param_to_prefix(version, prefix, param_0)\n    |> bytearray.concat(param_header_28_bytes)\n    |> bytearray.concat(param_1)\n    |> bytearray.concat(param_header_28_bytes)\n    |> bytearray.concat(param_2)\n    |> bytearray.concat(postfix)\n    |> blake2b_224\n}"
        },
        {
          "name": "spend_wrapper",
          "signature": "pub fn spend_wrapper(pub fn spend_wrapper(hashed_parameter: Hash<Blake2b_224, p>, parameter_serialiser: fn(p) -> ByteArray, validator_function: fn(p, Option<d>, redeemer, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: ParameterizedRedeemer<p, redeemer>, output_reference: OutputReference, tx: Transaction,",
          "documentation": "Helper function for parameterized spending scripts, which takes care of\nvalidating resolved parameter hashes, provides you with both the parameter,\nand your custom redeemer.",
          "parameters": [],
          "returnType": "ByteArray, validator_function: fn(p, Option<d>, redeemer, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: ParameterizedRedeemer<p, redeemer>, output_reference: OutputReference, tx: Transaction,",
          "line": 172,
          "raw": "pub fn spend_wrapper(pub fn spend_wrapper(hashed_parameter: Hash<Blake2b_224, p>, parameter_serialiser: fn(p) -> ByteArray, validator_function: fn(p, Option<d>, redeemer, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: ParameterizedRedeemer<p, redeemer>, output_reference: OutputReference, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn spend_wrapper(\n  hashed_parameter: Hash<Blake2b_224, p>,\n  parameter_serialiser: fn(p) -> ByteArray,\n  validator_function: fn(p, Option<d>, redeemer, OutputReference, Transaction) ->\n    Bool,\n  datum: Option<d>,\n  outer_redeemer: ParameterizedRedeemer<p, redeemer>,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  let ParameterizedRedeemer { param, redeemer } = outer_redeemer\n  expect (blake2b_224(parameter_serialiser(param)) == hashed_parameter)?\n  validator_function(param, datum, redeemer, output_reference, tx)\n}"
        },
        {
          "name": "no_datum_wrapper",
          "signature": "pub fn no_datum_wrapper(pub fn no_datum_wrapper(hashed_parameter: Hash<Blake2b_224, p>, parameter_serialiser: fn(p) -> ByteArray, validator_function: fn(p, redeemer, endpoint_specific, Transaction) -> Bool, outer_redeemer: ParameterizedRedeemer<p, redeemer>, variable_arg: endpoint_specific, tx: Transaction,",
          "documentation": "Similar to [`spend_wrapper`](#spend_wrapper), but for other endpoints that\nare not provided with a datum (mint, withdraw, etc.).",
          "parameters": [],
          "returnType": "ByteArray, validator_function: fn(p, redeemer, endpoint_specific, Transaction) -> Bool, outer_redeemer: ParameterizedRedeemer<p, redeemer>, variable_arg: endpoint_specific, tx: Transaction,",
          "line": 189,
          "raw": "pub fn no_datum_wrapper(pub fn no_datum_wrapper(hashed_parameter: Hash<Blake2b_224, p>, parameter_serialiser: fn(p) -> ByteArray, validator_function: fn(p, redeemer, endpoint_specific, Transaction) -> Bool, outer_redeemer: ParameterizedRedeemer<p, redeemer>, variable_arg: endpoint_specific, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn no_datum_wrapper(\n  hashed_parameter: Hash<Blake2b_224, p>,\n  parameter_serialiser: fn(p) -> ByteArray,\n  validator_function: fn(p, redeemer, endpoint_specific, Transaction) -> Bool,\n  outer_redeemer: ParameterizedRedeemer<p, redeemer>,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  let ParameterizedRedeemer { param, redeemer } = outer_redeemer\n  expect (blake2b_224(parameter_serialiser(param)) == hashed_parameter)?\n  validator_function(param, redeemer, variable_arg, tx)\n}"
        },
        {
          "name": "spend_wrapper_2",
          "signature": "pub fn spend_wrapper_2(pub fn spend_wrapper_2(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, Option<d>, r, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: ParameterizedRedeemer2<p, q, r>, output_reference: OutputReference, tx: Transaction,",
          "parameters": [],
          "returnType": "ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, Option<d>, r, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: ParameterizedRedeemer2<p, q, r>, output_reference: OutputReference, tx: Transaction,",
          "line": 208,
          "raw": "pub fn spend_wrapper_2(pub fn spend_wrapper_2(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, Option<d>, r, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: ParameterizedRedeemer2<p, q, r>, output_reference: OutputReference, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn spend_wrapper_2(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  validator_function: fn(p, q, Option<d>, r, OutputReference, Transaction) ->\n    Bool,\n  datum: Option<d>,\n  outer_redeemer: ParameterizedRedeemer2<p, q, r>,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  let ParameterizedRedeemer2 { param_0, param_1, redeemer } = outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n    }?\n  validator_function(param_0, param_1, datum, redeemer, output_reference, tx)\n}"
        },
        {
          "name": "no_datum_wrapper_2",
          "signature": "pub fn no_datum_wrapper_2(pub fn no_datum_wrapper_2(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, redeemer, endpoint_specific, Transaction) -> Bool, outer_redeemer: ParameterizedRedeemer2<p, q, redeemer>, variable_arg: endpoint_specific, tx: Transaction,",
          "parameters": [],
          "returnType": "ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, redeemer, endpoint_specific, Transaction) -> Bool, outer_redeemer: ParameterizedRedeemer2<p, q, redeemer>, variable_arg: endpoint_specific, tx: Transaction,",
          "line": 228,
          "raw": "pub fn no_datum_wrapper_2(pub fn no_datum_wrapper_2(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, redeemer, endpoint_specific, Transaction) -> Bool, outer_redeemer: ParameterizedRedeemer2<p, q, redeemer>, variable_arg: endpoint_specific, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn no_datum_wrapper_2(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  validator_function: fn(p, q, redeemer, endpoint_specific, Transaction) -> Bool,\n  outer_redeemer: ParameterizedRedeemer2<p, q, redeemer>,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  let ParameterizedRedeemer2 { param_0, param_1, redeemer } = outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n    }?\n  validator_function(param_0, param_1, redeemer, variable_arg, tx)\n}"
        },
        {
          "name": "spend_wrapper_3",
          "signature": "pub fn spend_wrapper_3(pub fn spend_wrapper_3(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, hashed_parameter_2: Hash<Blake2b_224, s>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, Option<d>, r, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: ParameterizedRedeemer3<p, q, s, r>, output_reference: OutputReference, tx: Transaction,",
          "parameters": [],
          "returnType": "ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, Option<d>, r, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: ParameterizedRedeemer3<p, q, s, r>, output_reference: OutputReference, tx: Transaction,",
          "line": 253,
          "raw": "pub fn spend_wrapper_3(pub fn spend_wrapper_3(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, hashed_parameter_2: Hash<Blake2b_224, s>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, Option<d>, r, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: ParameterizedRedeemer3<p, q, s, r>, output_reference: OutputReference, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn spend_wrapper_3(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  hashed_parameter_2: Hash<Blake2b_224, s>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  parameter_serialiser_2: fn(s) -> ByteArray,\n  validator_function: fn(p, q, s, Option<d>, r, OutputReference, Transaction) ->\n    Bool,\n  datum: Option<d>,\n  outer_redeemer: ParameterizedRedeemer3<p, q, s, r>,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  let ParameterizedRedeemer3 { param_0, param_1, param_2, redeemer } =\n    outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n      blake2b_224(parameter_serialiser_2(param_2)) == hashed_parameter_2,\n    }?\n  validator_function(\n    param_0,\n    param_1,\n    param_2,\n    datum,\n    redeemer,\n    output_reference,\n    tx,\n  )\n}"
        },
        {
          "name": "no_datum_wrapper_3",
          "signature": "pub fn no_datum_wrapper_3(pub fn no_datum_wrapper_3(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, hashed_parameter_2: Hash<Blake2b_224, s>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, redeemer, endpoint_specific, Transaction) -> Bool, outer_redeemer: ParameterizedRedeemer3<p, q, s, redeemer>, variable_arg: endpoint_specific, tx: Transaction,",
          "parameters": [],
          "returnType": "ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, redeemer, endpoint_specific, Transaction) -> Bool, outer_redeemer: ParameterizedRedeemer3<p, q, s, redeemer>, variable_arg: endpoint_specific, tx: Transaction,",
          "line": 285,
          "raw": "pub fn no_datum_wrapper_3(pub fn no_datum_wrapper_3(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, hashed_parameter_2: Hash<Blake2b_224, s>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, redeemer, endpoint_specific, Transaction) -> Bool, outer_redeemer: ParameterizedRedeemer3<p, q, s, redeemer>, variable_arg: endpoint_specific, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn no_datum_wrapper_3(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  hashed_parameter_2: Hash<Blake2b_224, s>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  parameter_serialiser_2: fn(s) -> ByteArray,\n  validator_function: fn(p, q, s, redeemer, endpoint_specific, Transaction) ->\n    Bool,\n  outer_redeemer: ParameterizedRedeemer3<p, q, s, redeemer>,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  let ParameterizedRedeemer3 { param_0, param_1, param_2, redeemer } =\n    outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n      blake2b_224(parameter_serialiser_2(param_2)) == hashed_parameter_2,\n    }?\n  validator_function(param_0, param_1, param_2, redeemer, variable_arg, tx)\n}"
        },
        {
          "name": "spend_wrapper_no_redeemer",
          "signature": "pub fn spend_wrapper_no_redeemer(pub fn spend_wrapper_no_redeemer(hashed_parameter: Hash<Blake2b_224, p>, parameter_serialiser: fn(p) -> ByteArray, validator_function: fn(p, Option<d>, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: Parameter<p>, output_reference: OutputReference, tx: Transaction,",
          "documentation": "Wrapper function for spending scripts with one parameter that don't need a\nredeemer.",
          "parameters": [],
          "returnType": "ByteArray, validator_function: fn(p, Option<d>, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: Parameter<p>, output_reference: OutputReference, tx: Transaction,",
          "line": 315,
          "raw": "pub fn spend_wrapper_no_redeemer(pub fn spend_wrapper_no_redeemer(hashed_parameter: Hash<Blake2b_224, p>, parameter_serialiser: fn(p) -> ByteArray, validator_function: fn(p, Option<d>, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: Parameter<p>, output_reference: OutputReference, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn spend_wrapper_no_redeemer(\n  hashed_parameter: Hash<Blake2b_224, p>,\n  parameter_serialiser: fn(p) -> ByteArray,\n  validator_function: fn(p, Option<d>, OutputReference, Transaction) -> Bool,\n  datum: Option<d>,\n  outer_redeemer: Parameter<p>,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  let Parameter { param } = outer_redeemer\n  expect (blake2b_224(parameter_serialiser(param)) == hashed_parameter)?\n  validator_function(param, datum, output_reference, tx)\n}"
        },
        {
          "name": "no_datum_wrapper_no_redeemer",
          "signature": "pub fn no_datum_wrapper_no_redeemer(pub fn no_datum_wrapper_no_redeemer(hashed_parameter: Hash<Blake2b_224, p>, parameter_serialiser: fn(p) -> ByteArray, validator_function: fn(p, endpoint_specific, Transaction) -> Bool, outer_redeemer: Parameter<p>, variable_arg: endpoint_specific, tx: Transaction,",
          "documentation": "Wrapper function for datumless scripts with one parameters that don't need a\nredeemer.",
          "parameters": [],
          "returnType": "ByteArray, validator_function: fn(p, endpoint_specific, Transaction) -> Bool, outer_redeemer: Parameter<p>, variable_arg: endpoint_specific, tx: Transaction,",
          "line": 331,
          "raw": "pub fn no_datum_wrapper_no_redeemer(pub fn no_datum_wrapper_no_redeemer(hashed_parameter: Hash<Blake2b_224, p>, parameter_serialiser: fn(p) -> ByteArray, validator_function: fn(p, endpoint_specific, Transaction) -> Bool, outer_redeemer: Parameter<p>, variable_arg: endpoint_specific, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn no_datum_wrapper_no_redeemer(\n  hashed_parameter: Hash<Blake2b_224, p>,\n  parameter_serialiser: fn(p) -> ByteArray,\n  validator_function: fn(p, endpoint_specific, Transaction) -> Bool,\n  outer_redeemer: Parameter<p>,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  let Parameter { param } = outer_redeemer\n  expect (blake2b_224(parameter_serialiser(param)) == hashed_parameter)?\n  validator_function(param, variable_arg, tx)\n}"
        },
        {
          "name": "spend_wrapper_no_redeemer_2",
          "signature": "pub fn spend_wrapper_no_redeemer_2(pub fn spend_wrapper_no_redeemer_2(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, Option<d>, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: Parameter2<p, q>, output_reference: OutputReference, tx: Transaction,",
          "parameters": [],
          "returnType": "ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, Option<d>, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: Parameter2<p, q>, output_reference: OutputReference, tx: Transaction,",
          "line": 349,
          "raw": "pub fn spend_wrapper_no_redeemer_2(pub fn spend_wrapper_no_redeemer_2(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, Option<d>, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: Parameter2<p, q>, output_reference: OutputReference, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn spend_wrapper_no_redeemer_2(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  validator_function: fn(p, q, Option<d>, OutputReference, Transaction) -> Bool,\n  datum: Option<d>,\n  outer_redeemer: Parameter2<p, q>,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  let Parameter2 { param_0, param_1 } = outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n    }?\n  validator_function(param_0, param_1, datum, output_reference, tx)\n}"
        },
        {
          "name": "no_datum_wrapper_no_redeemer_2",
          "signature": "pub fn no_datum_wrapper_no_redeemer_2(pub fn no_datum_wrapper_no_redeemer_2(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, endpoint_specific, Transaction) -> Bool, outer_redeemer: Parameter2<p, q>, variable_arg: endpoint_specific, tx: Transaction,",
          "parameters": [],
          "returnType": "ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, endpoint_specific, Transaction) -> Bool, outer_redeemer: Parameter2<p, q>, variable_arg: endpoint_specific, tx: Transaction,",
          "line": 368,
          "raw": "pub fn no_datum_wrapper_no_redeemer_2(pub fn no_datum_wrapper_no_redeemer_2(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, endpoint_specific, Transaction) -> Bool, outer_redeemer: Parameter2<p, q>, variable_arg: endpoint_specific, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn no_datum_wrapper_no_redeemer_2(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  validator_function: fn(p, q, endpoint_specific, Transaction) -> Bool,\n  outer_redeemer: Parameter2<p, q>,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  let Parameter2 { param_0, param_1 } = outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n    }?\n  validator_function(param_0, param_1, variable_arg, tx)\n}"
        },
        {
          "name": "spend_wrapper_no_redeemer_3",
          "signature": "pub fn spend_wrapper_no_redeemer_3(pub fn spend_wrapper_no_redeemer_3(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, hashed_parameter_2: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, Option<d>, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: Parameter3<p, q, s>, output_reference: OutputReference, tx: Transaction,",
          "parameters": [],
          "returnType": "ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, Option<d>, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: Parameter3<p, q, s>, output_reference: OutputReference, tx: Transaction,",
          "line": 392,
          "raw": "pub fn spend_wrapper_no_redeemer_3(pub fn spend_wrapper_no_redeemer_3(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, hashed_parameter_2: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, Option<d>, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: Parameter3<p, q, s>, output_reference: OutputReference, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn spend_wrapper_no_redeemer_3(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  hashed_parameter_2: Hash<Blake2b_224, q>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  parameter_serialiser_2: fn(s) -> ByteArray,\n  validator_function: fn(p, q, s, Option<d>, OutputReference, Transaction) ->\n    Bool,\n  datum: Option<d>,\n  outer_redeemer: Parameter3<p, q, s>,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  let Parameter3 { param_0, param_1, param_2 } = outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n      blake2b_224(parameter_serialiser_2(param_2)) == hashed_parameter_2,\n    }?\n  validator_function(param_0, param_1, param_2, datum, output_reference, tx)\n}"
        },
        {
          "name": "no_datum_wrapper_no_redeemer_3",
          "signature": "pub fn no_datum_wrapper_no_redeemer_3(pub fn no_datum_wrapper_no_redeemer_3(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, hashed_parameter_2: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, endpoint_specific, Transaction) -> Bool, outer_redeemer: Parameter3<p, q, s>, variable_arg: endpoint_specific, tx: Transaction,",
          "parameters": [],
          "returnType": "ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, endpoint_specific, Transaction) -> Bool, outer_redeemer: Parameter3<p, q, s>, variable_arg: endpoint_specific, tx: Transaction,",
          "line": 415,
          "raw": "pub fn no_datum_wrapper_no_redeemer_3(pub fn no_datum_wrapper_no_redeemer_3(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, hashed_parameter_2: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, endpoint_specific, Transaction) -> Bool, outer_redeemer: Parameter3<p, q, s>, variable_arg: endpoint_specific, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn no_datum_wrapper_no_redeemer_3(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  hashed_parameter_2: Hash<Blake2b_224, q>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  parameter_serialiser_2: fn(s) -> ByteArray,\n  validator_function: fn(p, q, s, endpoint_specific, Transaction) -> Bool,\n  outer_redeemer: Parameter3<p, q, s>,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  let Parameter3 { param_0, param_1, param_2 } = outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n      blake2b_224(parameter_serialiser_2(param_2)) == hashed_parameter_2,\n    }?\n  validator_function(param_0, param_1, param_2, variable_arg, tx)\n}"
        },
        {
          "name": "prehashed_param_spend_wrapper",
          "signature": "pub fn prehashed_param_spend_wrapper(pub fn prehashed_param_spend_wrapper(validator_function: fn( Hash<Blake2b_224, a>, Option<d>, redeemer, OutputReference, Transaction, ) -> Bool, parameter: Hash<Blake2b_224, a>, datum: Option<d>, redeemer: redeemer, output_reference: OutputReference, tx: Transaction,",
          "documentation": "Helper function for spending scripts that are parameterized by a single hash\nvalue which is not needed to be resolved.\n\nThe purpose of theses wrappers is to make the parameters appear only once in\nthe resulting CBORs.",
          "parameters": [],
          "returnType": "Bool, parameter: Hash<Blake2b_224, a>, datum: Option<d>, redeemer: redeemer, output_reference: OutputReference, tx: Transaction,",
          "line": 441,
          "raw": "pub fn prehashed_param_spend_wrapper(pub fn prehashed_param_spend_wrapper(validator_function: fn( Hash<Blake2b_224, a>, Option<d>, redeemer, OutputReference, Transaction, ) -> Bool, parameter: Hash<Blake2b_224, a>, datum: Option<d>, redeemer: redeemer, output_reference: OutputReference, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn prehashed_param_spend_wrapper(\n  validator_function: fn(\n    Hash<Blake2b_224, a>,\n    Option<d>,\n    redeemer,\n    OutputReference,\n    Transaction,\n  ) ->\n    Bool,\n  parameter: Hash<Blake2b_224, a>,\n  datum: Option<d>,\n  redeemer: redeemer,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  validator_function(parameter, datum, redeemer, output_reference, tx)\n}"
        },
        {
          "name": "prehashed_param_no_datum_wrapper",
          "signature": "pub fn prehashed_param_no_datum_wrapper(pub fn prehashed_param_no_datum_wrapper(validator_function: fn( Hash<Blake2b_224, a>, redeemer, endpoint_specific, Transaction, ) -> Bool, param: Hash<Blake2b_224, a>, redeemer: redeemer, variable_arg: endpoint_specific, tx: Transaction,",
          "documentation": "Similar to [`prehashed_param_spend_wrapper`](#prehashed_param_spend_wrapper), but\nfor other endpoints that are not provided with a datum (mint, withdraw,\netc.).",
          "parameters": [],
          "returnType": "Bool, param: Hash<Blake2b_224, a>, redeemer: redeemer, variable_arg: endpoint_specific, tx: Transaction,",
          "line": 462,
          "raw": "pub fn prehashed_param_no_datum_wrapper(pub fn prehashed_param_no_datum_wrapper(validator_function: fn( Hash<Blake2b_224, a>, redeemer, endpoint_specific, Transaction, ) -> Bool, param: Hash<Blake2b_224, a>, redeemer: redeemer, variable_arg: endpoint_specific, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn prehashed_param_no_datum_wrapper(\n  validator_function: fn(\n    Hash<Blake2b_224, a>,\n    redeemer,\n    endpoint_specific,\n    Transaction,\n  ) ->\n    Bool,\n  param: Hash<Blake2b_224, a>,\n  redeemer: redeemer,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  validator_function(param, redeemer, variable_arg, tx)\n}"
        },
        {
          "name": "prehashed_param_spend_wrapper_2",
          "signature": "pub fn prehashed_param_spend_wrapper_2(pub fn prehashed_param_spend_wrapper_2(validator_function: fn( Hash<Blake2b_224, a>, Hash<Blake2b_224, b>, Option<d>, redeemer, OutputReference, Transaction, ) -> Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, datum: Option<d>, redeemer: redeemer, output_reference: OutputReference, tx: Transaction,",
          "parameters": [],
          "returnType": "Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, datum: Option<d>, redeemer: redeemer, output_reference: OutputReference, tx: Transaction,",
          "line": 478,
          "raw": "pub fn prehashed_param_spend_wrapper_2(pub fn prehashed_param_spend_wrapper_2(validator_function: fn( Hash<Blake2b_224, a>, Hash<Blake2b_224, b>, Option<d>, redeemer, OutputReference, Transaction, ) -> Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, datum: Option<d>, redeemer: redeemer, output_reference: OutputReference, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn prehashed_param_spend_wrapper_2(\n  validator_function: fn(\n    Hash<Blake2b_224, a>,\n    Hash<Blake2b_224, b>,\n    Option<d>,\n    redeemer,\n    OutputReference,\n    Transaction,\n  ) ->\n    Bool,\n  parameter_0: Hash<Blake2b_224, a>,\n  parameter_1: Hash<Blake2b_224, b>,\n  datum: Option<d>,\n  redeemer: redeemer,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  validator_function(\n    parameter_0,\n    parameter_1,\n    datum,\n    redeemer,\n    output_reference,\n    tx,\n  )\n}"
        },
        {
          "name": "prehashed_param_no_datum_wrapper_2",
          "signature": "pub fn prehashed_param_no_datum_wrapper_2(pub fn prehashed_param_no_datum_wrapper_2(validator_function: fn( Hash<Blake2b_224, a>, Hash<Blake2b_224, b>, redeemer, endpoint_specific, Transaction, ) -> Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, redeemer: redeemer, variable_arg: endpoint_specific, tx: Transaction,",
          "parameters": [],
          "returnType": "Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, redeemer: redeemer, variable_arg: endpoint_specific, tx: Transaction,",
          "line": 505,
          "raw": "pub fn prehashed_param_no_datum_wrapper_2(pub fn prehashed_param_no_datum_wrapper_2(validator_function: fn( Hash<Blake2b_224, a>, Hash<Blake2b_224, b>, redeemer, endpoint_specific, Transaction, ) -> Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, redeemer: redeemer, variable_arg: endpoint_specific, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn prehashed_param_no_datum_wrapper_2(\n  validator_function: fn(\n    Hash<Blake2b_224, a>,\n    Hash<Blake2b_224, b>,\n    redeemer,\n    endpoint_specific,\n    Transaction,\n  ) ->\n    Bool,\n  parameter_0: Hash<Blake2b_224, a>,\n  parameter_1: Hash<Blake2b_224, b>,\n  redeemer: redeemer,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  validator_function(parameter_0, parameter_1, redeemer, variable_arg, tx)\n}"
        },
        {
          "name": "prehashed_param_spend_wrapper_3",
          "signature": "pub fn prehashed_param_spend_wrapper_3(pub fn prehashed_param_spend_wrapper_3(validator_function: fn( Hash<Blake2b_224, a>, Hash<Blake2b_224, b>, Hash<Blake2b_224, c>, Option<d>, redeemer, OutputReference, Transaction, ) -> Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, parameter_2: Hash<Blake2b_224, c>, datum: Option<d>, redeemer: redeemer, output_reference: OutputReference, tx: Transaction,",
          "parameters": [],
          "returnType": "Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, parameter_2: Hash<Blake2b_224, c>, datum: Option<d>, redeemer: redeemer, output_reference: OutputReference, tx: Transaction,",
          "line": 523,
          "raw": "pub fn prehashed_param_spend_wrapper_3(pub fn prehashed_param_spend_wrapper_3(validator_function: fn( Hash<Blake2b_224, a>, Hash<Blake2b_224, b>, Hash<Blake2b_224, c>, Option<d>, redeemer, OutputReference, Transaction, ) -> Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, parameter_2: Hash<Blake2b_224, c>, datum: Option<d>, redeemer: redeemer, output_reference: OutputReference, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn prehashed_param_spend_wrapper_3(\n  validator_function: fn(\n    Hash<Blake2b_224, a>,\n    Hash<Blake2b_224, b>,\n    Hash<Blake2b_224, c>,\n    Option<d>,\n    redeemer,\n    OutputReference,\n    Transaction,\n  ) ->\n    Bool,\n  parameter_0: Hash<Blake2b_224, a>,\n  parameter_1: Hash<Blake2b_224, b>,\n  parameter_2: Hash<Blake2b_224, c>,\n  datum: Option<d>,\n  redeemer: redeemer,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  validator_function(\n    parameter_0,\n    parameter_1,\n    parameter_2,\n    datum,\n    redeemer,\n    output_reference,\n    tx,\n  )\n}"
        },
        {
          "name": "prehashed_param_no_datum_wrapper_3",
          "signature": "pub fn prehashed_param_no_datum_wrapper_3(pub fn prehashed_param_no_datum_wrapper_3(validator_function: fn( Hash<Blake2b_224, a>, Hash<Blake2b_224, b>, Hash<Blake2b_224, c>, redeemer, endpoint_specific, Transaction, ) -> Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, parameter_2: Hash<Blake2b_224, c>, redeemer: redeemer, variable_arg: endpoint_specific, tx: Transaction,",
          "parameters": [],
          "returnType": "Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, parameter_2: Hash<Blake2b_224, c>, redeemer: redeemer, variable_arg: endpoint_specific, tx: Transaction,",
          "line": 553,
          "raw": "pub fn prehashed_param_no_datum_wrapper_3(pub fn prehashed_param_no_datum_wrapper_3(validator_function: fn( Hash<Blake2b_224, a>, Hash<Blake2b_224, b>, Hash<Blake2b_224, c>, redeemer, endpoint_specific, Transaction, ) -> Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, parameter_2: Hash<Blake2b_224, c>, redeemer: redeemer, variable_arg: endpoint_specific, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn prehashed_param_no_datum_wrapper_3(\n  validator_function: fn(\n    Hash<Blake2b_224, a>,\n    Hash<Blake2b_224, b>,\n    Hash<Blake2b_224, c>,\n    redeemer,\n    endpoint_specific,\n    Transaction,\n  ) ->\n    Bool,\n  parameter_0: Hash<Blake2b_224, a>,\n  parameter_1: Hash<Blake2b_224, b>,\n  parameter_2: Hash<Blake2b_224, c>,\n  redeemer: redeemer,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  validator_function(\n    parameter_0,\n    parameter_1,\n    parameter_2,\n    redeemer,\n    variable_arg,\n    tx,\n  )\n}"
        }
      ],
      "types": [
        {
          "name": "ParameterizedRedeemer<p, r>",
          "definition": "{ param: p, redeemer: r, }",
          "line": 164,
          "raw": "pub type ParameterizedRedeemer<p, r> {",
          "isPublic": true,
          "source": "anastasia"
        },
        {
          "name": "ParameterizedRedeemer2<p, q, r>",
          "definition": "{ param_0: p, param_1: q, redeemer: r, }",
          "line": 202,
          "raw": "pub type ParameterizedRedeemer2<p, q, r> {",
          "isPublic": true,
          "source": "anastasia"
        },
        {
          "name": "ParameterizedRedeemer3<p, q, s, r>",
          "definition": "{ param_0: p, param_1: q, param_2: s, redeemer: r, }",
          "line": 246,
          "raw": "pub type ParameterizedRedeemer3<p, q, s, r> {",
          "isPublic": true,
          "source": "anastasia"
        },
        {
          "name": "Parameter<p>",
          "definition": "{ param: p, }",
          "line": 309,
          "raw": "pub type Parameter<p> {",
          "isPublic": true,
          "source": "anastasia"
        },
        {
          "name": "Parameter2<p, q>",
          "definition": "{ param_0: p, param_1: q, }",
          "line": 344,
          "raw": "pub type Parameter2<p, q> {",
          "isPublic": true,
          "source": "anastasia"
        },
        {
          "name": "Parameter3<p, q, s>",
          "definition": "{ param_0: p, param_1: q, param_2: s, }",
          "line": 386,
          "raw": "pub type Parameter3<p, q, s> {",
          "isPublic": true,
          "source": "anastasia"
        }
      ],
      "constants": [],
      "atoms": [
        {
          "name": "append_first_param_to_prefix",
          "signature": "fn append_first_param_to_prefix(fn append_first_param_to_prefix(version: Int, prefix: ByteArray, param: ByteArray, ) -> ByteArray {",
          "parameters": [],
          "returnType": "ByteArray",
          "line": 42,
          "raw": "fn append_first_param_to_prefix(fn append_first_param_to_prefix(version: Int, prefix: ByteArray, param: ByteArray, ) -> ByteArray {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn append_first_param_to_prefix(\n  version: Int,\n  prefix: ByteArray,\n  param: ByteArray,\n) -> ByteArray {\n  builtin.integer_to_bytearray(True, 1, version)\n    |> bytearray.concat(prefix)\n    |> bytearray.concat(blake2b_224(param))\n}"
        },
        {
          "name": "append_param",
          "signature": "fn append_param(prefix: ByteArray, param: ByteArray) -> ByteArray {",
          "parameters": [
            {
              "name": "prefix",
              "type": "ByteArray",
              "optional": false
            },
            {
              "name": "param",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "ByteArray",
          "line": 52,
          "raw": "fn append_param(prefix: ByteArray, param: ByteArray) -> ByteArray {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn append_param(prefix: ByteArray, param: ByteArray) -> ByteArray {\n  prefix\n    |> bytearray.concat(blake2b_224(param))\n}"
        },
        {
          "name": "append_first_prehashed_param_to_prefix",
          "signature": "fn append_first_prehashed_param_to_prefix(fn append_first_prehashed_param_to_prefix(version: Int, prefix: ByteArray, param: ByteArray, ) -> ByteArray {",
          "parameters": [],
          "returnType": "ByteArray",
          "line": 57,
          "raw": "fn append_first_prehashed_param_to_prefix(fn append_first_prehashed_param_to_prefix(version: Int, prefix: ByteArray, param: ByteArray, ) -> ByteArray {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn append_first_prehashed_param_to_prefix(\n  version: Int,\n  prefix: ByteArray,\n  param: ByteArray,\n) -> ByteArray {\n  builtin.integer_to_bytearray(True, 1, version)\n    |> bytearray.concat(prefix)\n    |> bytearray.concat(param)\n}"
        }
      ],
      "privateTypes": [],
      "privateConstants": [
        {
          "name": "param_header_28_bytes",
          "type": "Unknown",
          "value": "#\"004c011e581c\"",
          "line": 38,
          "raw": "const param_header_28_bytes = #\"004c011e581c\"",
          "isPublic": false,
          "source": "anastasia"
        },
        {
          "name": "postfix",
          "type": "ByteArray",
          "value": "#\"0001\"",
          "line": 40,
          "raw": "const postfix: ByteArray = #\"0001\"",
          "isPublic": false,
          "source": "anastasia"
        }
      ],
      "content": "//// In some cases, validators need to be aware of instances of a parameterized\n//// script in order to have a more robust control over the flow of assets.\n//// \n//// As a simple example, consider a minting script that needs to ensure the\n//// destination of its tokens can only be instances of a specific spending\n//// script, e.g. parameterized by users' wallets.\n//// \n//// Since each different wallet leads to a different script address, without\n//// verifying instances, instances can only be seen as arbitrary scripts from\n//// the minting script's point of view.\n//// \n//// This can be resolved by validating an instance is the result of applying\n//// specific parameters to a given parameterized script.\n//// \n//// To allow this validation on-chain, some restrictions are needed:\n//// 1. Parameters of the script must have constant lengths, which can be\n////    achieved by having them hashed\n//// 2. Consequently, for each transaction, the resolved value of those\n////    parameters must be provided through the redeemer\n//// 3. The dependent script must be provided with CBOR bytes of instances\n////    before and after the parameter(s)\n//// 4. Wrapping of instances' logics in an outer function so that there'll be\n////    single occurances of each parameter\n//// \n//// This pattern provides two sets of functions. One for applying parameter(s)\n//// in the dependent script (i.e. the minting script in the example above), and\n//// one for wrapping your parameterized scripts with.\n//// \n//// After defining your parameterized scripts, you'll need to generate\n//// instances of them with dummy data in order to obtain the required `prefix`\n//// and `postfix` values for your target script to utilize.\n\nuse aiken/builtin\nuse aiken/crypto.{Blake2b_224, Hash, ScriptHash, blake2b_224}\nuse aiken/primitive/bytearray\nuse cardano/transaction.{OutputReference, Transaction}\n\nconst param_header_28_bytes = #\"004c011e581c\"\n\nconst postfix: ByteArray = #\"0001\"\n\nfn append_first_param_to_prefix(\n  version: Int,\n  prefix: ByteArray,\n  param: ByteArray,\n) -> ByteArray {\n  builtin.integer_to_bytearray(True, 1, version)\n    |> bytearray.concat(prefix)\n    |> bytearray.concat(blake2b_224(param))\n}\n\nfn append_param(prefix: ByteArray, param: ByteArray) -> ByteArray {\n  prefix\n    |> bytearray.concat(blake2b_224(param))\n}\n\nfn append_first_prehashed_param_to_prefix(\n  version: Int,\n  prefix: ByteArray,\n  param: ByteArray,\n) -> ByteArray {\n  builtin.integer_to_bytearray(True, 1, version)\n    |> bytearray.concat(prefix)\n    |> bytearray.concat(param)\n}\n\n/// Use this inside your dependent script for single parameter scripts. The\n/// parameter must be serialised before getting passed here. It'll be hashed\n/// with `blake2b_224` before placement after `prefix`.\n///\n/// Note that your prefix should be from a single CBOR encoded result. And also,\n/// the version should either be 1, 2, or 3 depending on your script.\npub fn apply_param(\n  version: Int,\n  prefix: ByteArray,\n  param: ByteArray,\n) -> ScriptHash {\n  append_first_param_to_prefix(version, prefix, param)\n    |> bytearray.concat(postfix)\n    |> blake2b_224\n}\n\n/// Similar to [`apply_param`](#apply_param), but for scripts that their\n/// parameters don't need to be resolved (e.g. have a script hash as their\n/// parameter).\n///\n/// Note that `blake2b_224` is the presumed hashing algorithm, i.e. the\n/// parameter is expected to be 28 bytes long.\npub fn apply_prehashed_param(\n  version: Int,\n  prefix: ByteArray,\n  param: ByteArray,\n) -> ScriptHash {\n  append_first_prehashed_param_to_prefix(version, prefix, param)\n    |> bytearray.concat(postfix)\n    |> blake2b_224\n}\n\n/// Similar to [`apply_param`](#apply_param), but for scripts with 2 parameters.\npub fn apply_param_2(\n  version: Int,\n  prefix: ByteArray,\n  param_0: ByteArray,\n  param_1: ByteArray,\n) -> ScriptHash {\n  append_first_param_to_prefix(version, prefix, param_0)\n    |> bytearray.concat(param_header_28_bytes)\n    |> append_param(param_1)\n    |> bytearray.concat(postfix)\n    |> blake2b_224\n}\n\n/// Similar to [`apply_prehashed_param`](#apply_prehashed_param), but for\n/// scripts with 2 parameters.\npub fn apply_prehashed_param_2(\n  version: Int,\n  prefix: ByteArray,\n  param_0: ByteArray,\n  param_1: ByteArray,\n) -> ScriptHash {\n  append_first_prehashed_param_to_prefix(version, prefix, param_0)\n    |> bytearray.concat(param_header_28_bytes)\n    |> bytearray.concat(param_1)\n    |> bytearray.concat(postfix)\n    |> blake2b_224\n}\n\n/// Similar to [`apply_param`](#apply_param), but for scripts with 3 parameters.\npub fn apply_param_3(\n  version: Int,\n  prefix: ByteArray,\n  param_0: ByteArray,\n  param_1: ByteArray,\n  param_2: ByteArray,\n) -> ScriptHash {\n  append_first_param_to_prefix(version, prefix, param_0)\n    |> bytearray.concat(param_header_28_bytes)\n    |> append_param(param_1)\n    |> bytearray.concat(param_header_28_bytes)\n    |> append_param(param_2)\n    |> bytearray.concat(postfix)\n    |> blake2b_224\n}\n\n/// Similar to [`apply_prehashed_param`](#apply_prehashed_param), but for\n/// scripts with 3 parameters.\npub fn apply_prehashed_param_3(\n  version: Int,\n  prefix: ByteArray,\n  param_0: ByteArray,\n  param_1: ByteArray,\n  param_2: ByteArray,\n) -> ScriptHash {\n  append_first_prehashed_param_to_prefix(version, prefix, param_0)\n    |> bytearray.concat(param_header_28_bytes)\n    |> bytearray.concat(param_1)\n    |> bytearray.concat(param_header_28_bytes)\n    |> bytearray.concat(param_2)\n    |> bytearray.concat(postfix)\n    |> blake2b_224\n}\n\n/// Datatype for redeemer of your single parameterized scripts.\npub type ParameterizedRedeemer<p, r> {\n  param: p,\n  redeemer: r,\n}\n\n/// Helper function for parameterized spending scripts, which takes care of\n/// validating resolved parameter hashes, provides you with both the parameter,\n/// and your custom redeemer.\npub fn spend_wrapper(\n  hashed_parameter: Hash<Blake2b_224, p>,\n  parameter_serialiser: fn(p) -> ByteArray,\n  validator_function: fn(p, Option<d>, redeemer, OutputReference, Transaction) ->\n    Bool,\n  datum: Option<d>,\n  outer_redeemer: ParameterizedRedeemer<p, redeemer>,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  let ParameterizedRedeemer { param, redeemer } = outer_redeemer\n  expect (blake2b_224(parameter_serialiser(param)) == hashed_parameter)?\n  validator_function(param, datum, redeemer, output_reference, tx)\n}\n\n/// Similar to [`spend_wrapper`](#spend_wrapper), but for other endpoints that\n/// are not provided with a datum (mint, withdraw, etc.).\npub fn no_datum_wrapper(\n  hashed_parameter: Hash<Blake2b_224, p>,\n  parameter_serialiser: fn(p) -> ByteArray,\n  validator_function: fn(p, redeemer, endpoint_specific, Transaction) -> Bool,\n  outer_redeemer: ParameterizedRedeemer<p, redeemer>,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  let ParameterizedRedeemer { param, redeemer } = outer_redeemer\n  expect (blake2b_224(parameter_serialiser(param)) == hashed_parameter)?\n  validator_function(param, redeemer, variable_arg, tx)\n}\n\npub type ParameterizedRedeemer2<p, q, r> {\n  param_0: p,\n  param_1: q,\n  redeemer: r,\n}\n\npub fn spend_wrapper_2(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  validator_function: fn(p, q, Option<d>, r, OutputReference, Transaction) ->\n    Bool,\n  datum: Option<d>,\n  outer_redeemer: ParameterizedRedeemer2<p, q, r>,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  let ParameterizedRedeemer2 { param_0, param_1, redeemer } = outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n    }?\n  validator_function(param_0, param_1, datum, redeemer, output_reference, tx)\n}\n\npub fn no_datum_wrapper_2(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  validator_function: fn(p, q, redeemer, endpoint_specific, Transaction) -> Bool,\n  outer_redeemer: ParameterizedRedeemer2<p, q, redeemer>,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  let ParameterizedRedeemer2 { param_0, param_1, redeemer } = outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n    }?\n  validator_function(param_0, param_1, redeemer, variable_arg, tx)\n}\n\npub type ParameterizedRedeemer3<p, q, s, r> {\n  param_0: p,\n  param_1: q,\n  param_2: s,\n  redeemer: r,\n}\n\npub fn spend_wrapper_3(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  hashed_parameter_2: Hash<Blake2b_224, s>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  parameter_serialiser_2: fn(s) -> ByteArray,\n  validator_function: fn(p, q, s, Option<d>, r, OutputReference, Transaction) ->\n    Bool,\n  datum: Option<d>,\n  outer_redeemer: ParameterizedRedeemer3<p, q, s, r>,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  let ParameterizedRedeemer3 { param_0, param_1, param_2, redeemer } =\n    outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n      blake2b_224(parameter_serialiser_2(param_2)) == hashed_parameter_2,\n    }?\n  validator_function(\n    param_0,\n    param_1,\n    param_2,\n    datum,\n    redeemer,\n    output_reference,\n    tx,\n  )\n}\n\npub fn no_datum_wrapper_3(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  hashed_parameter_2: Hash<Blake2b_224, s>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  parameter_serialiser_2: fn(s) -> ByteArray,\n  validator_function: fn(p, q, s, redeemer, endpoint_specific, Transaction) ->\n    Bool,\n  outer_redeemer: ParameterizedRedeemer3<p, q, s, redeemer>,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  let ParameterizedRedeemer3 { param_0, param_1, param_2, redeemer } =\n    outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n      blake2b_224(parameter_serialiser_2(param_2)) == hashed_parameter_2,\n    }?\n  validator_function(param_0, param_1, param_2, redeemer, variable_arg, tx)\n}\n\n/// Datatype for parameterized scripts that don't need a redeemer.\npub type Parameter<p> {\n  param: p,\n}\n\n/// Wrapper function for spending scripts with one parameter that don't need a\n/// redeemer.\npub fn spend_wrapper_no_redeemer(\n  hashed_parameter: Hash<Blake2b_224, p>,\n  parameter_serialiser: fn(p) -> ByteArray,\n  validator_function: fn(p, Option<d>, OutputReference, Transaction) -> Bool,\n  datum: Option<d>,\n  outer_redeemer: Parameter<p>,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  let Parameter { param } = outer_redeemer\n  expect (blake2b_224(parameter_serialiser(param)) == hashed_parameter)?\n  validator_function(param, datum, output_reference, tx)\n}\n\n/// Wrapper function for datumless scripts with one parameters that don't need a\n/// redeemer.\npub fn no_datum_wrapper_no_redeemer(\n  hashed_parameter: Hash<Blake2b_224, p>,\n  parameter_serialiser: fn(p) -> ByteArray,\n  validator_function: fn(p, endpoint_specific, Transaction) -> Bool,\n  outer_redeemer: Parameter<p>,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  let Parameter { param } = outer_redeemer\n  expect (blake2b_224(parameter_serialiser(param)) == hashed_parameter)?\n  validator_function(param, variable_arg, tx)\n}\n\npub type Parameter2<p, q> {\n  param_0: p,\n  param_1: q,\n}\n\npub fn spend_wrapper_no_redeemer_2(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  validator_function: fn(p, q, Option<d>, OutputReference, Transaction) -> Bool,\n  datum: Option<d>,\n  outer_redeemer: Parameter2<p, q>,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  let Parameter2 { param_0, param_1 } = outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n    }?\n  validator_function(param_0, param_1, datum, output_reference, tx)\n}\n\npub fn no_datum_wrapper_no_redeemer_2(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  validator_function: fn(p, q, endpoint_specific, Transaction) -> Bool,\n  outer_redeemer: Parameter2<p, q>,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  let Parameter2 { param_0, param_1 } = outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n    }?\n  validator_function(param_0, param_1, variable_arg, tx)\n}\n\npub type Parameter3<p, q, s> {\n  param_0: p,\n  param_1: q,\n  param_2: s,\n}\n\npub fn spend_wrapper_no_redeemer_3(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  hashed_parameter_2: Hash<Blake2b_224, q>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  parameter_serialiser_2: fn(s) -> ByteArray,\n  validator_function: fn(p, q, s, Option<d>, OutputReference, Transaction) ->\n    Bool,\n  datum: Option<d>,\n  outer_redeemer: Parameter3<p, q, s>,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  let Parameter3 { param_0, param_1, param_2 } = outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n      blake2b_224(parameter_serialiser_2(param_2)) == hashed_parameter_2,\n    }?\n  validator_function(param_0, param_1, param_2, datum, output_reference, tx)\n}\n\npub fn no_datum_wrapper_no_redeemer_3(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  hashed_parameter_2: Hash<Blake2b_224, q>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  parameter_serialiser_2: fn(s) -> ByteArray,\n  validator_function: fn(p, q, s, endpoint_specific, Transaction) -> Bool,\n  outer_redeemer: Parameter3<p, q, s>,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  let Parameter3 { param_0, param_1, param_2 } = outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n      blake2b_224(parameter_serialiser_2(param_2)) == hashed_parameter_2,\n    }?\n  validator_function(param_0, param_1, param_2, variable_arg, tx)\n}\n\n/// Helper function for spending scripts that are parameterized by a single hash\n/// value which is not needed to be resolved.\n///\n/// The purpose of theses wrappers is to make the parameters appear only once in\n/// the resulting CBORs.\npub fn prehashed_param_spend_wrapper(\n  validator_function: fn(\n    Hash<Blake2b_224, a>,\n    Option<d>,\n    redeemer,\n    OutputReference,\n    Transaction,\n  ) ->\n    Bool,\n  parameter: Hash<Blake2b_224, a>,\n  datum: Option<d>,\n  redeemer: redeemer,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  validator_function(parameter, datum, redeemer, output_reference, tx)\n}\n\n/// Similar to [`prehashed_param_spend_wrapper`](#prehashed_param_spend_wrapper), but\n/// for other endpoints that are not provided with a datum (mint, withdraw,\n/// etc.).\npub fn prehashed_param_no_datum_wrapper(\n  validator_function: fn(\n    Hash<Blake2b_224, a>,\n    redeemer,\n    endpoint_specific,\n    Transaction,\n  ) ->\n    Bool,\n  param: Hash<Blake2b_224, a>,\n  redeemer: redeemer,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  validator_function(param, redeemer, variable_arg, tx)\n}\n\npub fn prehashed_param_spend_wrapper_2(\n  validator_function: fn(\n    Hash<Blake2b_224, a>,\n    Hash<Blake2b_224, b>,\n    Option<d>,\n    redeemer,\n    OutputReference,\n    Transaction,\n  ) ->\n    Bool,\n  parameter_0: Hash<Blake2b_224, a>,\n  parameter_1: Hash<Blake2b_224, b>,\n  datum: Option<d>,\n  redeemer: redeemer,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  validator_function(\n    parameter_0,\n    parameter_1,\n    datum,\n    redeemer,\n    output_reference,\n    tx,\n  )\n}\n\npub fn prehashed_param_no_datum_wrapper_2(\n  validator_function: fn(\n    Hash<Blake2b_224, a>,\n    Hash<Blake2b_224, b>,\n    redeemer,\n    endpoint_specific,\n    Transaction,\n  ) ->\n    Bool,\n  parameter_0: Hash<Blake2b_224, a>,\n  parameter_1: Hash<Blake2b_224, b>,\n  redeemer: redeemer,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  validator_function(parameter_0, parameter_1, redeemer, variable_arg, tx)\n}\n\npub fn prehashed_param_spend_wrapper_3(\n  validator_function: fn(\n    Hash<Blake2b_224, a>,\n    Hash<Blake2b_224, b>,\n    Hash<Blake2b_224, c>,\n    Option<d>,\n    redeemer,\n    OutputReference,\n    Transaction,\n  ) ->\n    Bool,\n  parameter_0: Hash<Blake2b_224, a>,\n  parameter_1: Hash<Blake2b_224, b>,\n  parameter_2: Hash<Blake2b_224, c>,\n  datum: Option<d>,\n  redeemer: redeemer,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  validator_function(\n    parameter_0,\n    parameter_1,\n    parameter_2,\n    datum,\n    redeemer,\n    output_reference,\n    tx,\n  )\n}\n\npub fn prehashed_param_no_datum_wrapper_3(\n  validator_function: fn(\n    Hash<Blake2b_224, a>,\n    Hash<Blake2b_224, b>,\n    Hash<Blake2b_224, c>,\n    redeemer,\n    endpoint_specific,\n    Transaction,\n  ) ->\n    Bool,\n  parameter_0: Hash<Blake2b_224, a>,\n  parameter_1: Hash<Blake2b_224, b>,\n  parameter_2: Hash<Blake2b_224, c>,\n  redeemer: redeemer,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  validator_function(\n    parameter_0,\n    parameter_1,\n    parameter_2,\n    redeemer,\n    variable_arg,\n    tx,\n  )\n}\n",
      "dependencies": [
        "aiken/builtin",
        "aiken/crypto",
        "aiken/primitive/bytearray",
        "cardano/transaction"
      ],
      "source": "anastasia",
      "isReExportFile": false
    },
    {
      "key": "anastasia:aiken-design-patterns.singular-utxo-indexer",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-design-patterns/lib/aiken-design-patterns/singular-utxo-indexer.ak",
      "name": "aiken-design-patterns.singular-utxo-indexer",
      "imports": [
        {
          "module": "aiken/collection/list",
          "items": [],
          "line": 1,
          "raw": "use aiken/collection/list",
          "source": "anastasia"
        },
        {
          "module": "aiken_design_patterns/utils",
          "items": [],
          "line": 2,
          "raw": "use aiken_design_patterns/utils",
          "source": "anastasia"
        },
        {
          "module": "aiken_scott_utils/list",
          "items": [],
          "alias": "list_extra",
          "line": 3,
          "raw": "use aiken_scott_utils/list as list_extra",
          "source": "anastasia"
        },
        {
          "module": "cardano/transaction",
          "items": ["Input", "NoDatum", "Output", "OutputReference"],
          "line": 4,
          "raw": "use cardano/transaction.{Input, NoDatum, Output, OutputReference}",
          "source": "anastasia"
        }
      ],
      "functions": [
        {
          "name": "one_to_one",
          "signature": "pub fn one_to_one(pub fn one_to_one(validation_logic: fn(Input, Output) -> Bool, input_index: Int, output_index: Int, own_ref: OutputReference, inputs: List<Input>, outputs: List<Output>, double_satisfaction_prevented: Bool,",
          "documentation": "Helper function to be defined in the spending endpoint of your contract, for\nappointing an input at `input_index` against an output at `output_index`. By\nincluding this in your spending endpoint, you'll get an efficient access to\nyour input, and its corresponding output.\n\nWithin the function you pass as `validation_logic`, you have access to the\npicked input and output.\n\nApart from `validation_logic`, the only other validation this function\nperforms for you is the equality of the picked input's output reference with\nthe one extracted from [`ScriptInfo`](https://aiken-lang.github.io/stdlib/cardano/script_context.html#ScriptInfo).\n\n`double_satisfaction_prevented` is a required `Bool`, which is just a\nreminder that this function does NOT cover the\n[double satisfaction](https://github.com/Plutonomicon/plutonomicon/blob/b6906173c3f98fb5d7b40fd206f9d6fe14d0b03b/vulnerabilities.md#double-satisfaction)\nvulnerability out-of-the-box.",
          "parameters": [],
          "returnType": "Bool, input_index: Int, output_index: Int, own_ref: OutputReference, inputs: List<Input>, outputs: List<Output>, double_satisfaction_prevented: Bool,",
          "line": 22,
          "raw": "pub fn one_to_one(pub fn one_to_one(validation_logic: fn(Input, Output) -> Bool, input_index: Int, output_index: Int, own_ref: OutputReference, inputs: List<Input>, outputs: List<Output>, double_satisfaction_prevented: Bool,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn one_to_one(\n  validation_logic: fn(Input, Output) -> Bool,\n  input_index: Int,\n  output_index: Int,\n  own_ref: OutputReference,\n  inputs: List<Input>,\n  outputs: List<Output>,\n  double_satisfaction_prevented: Bool,\n) -> Bool {\n  expect double_satisfaction_prevented\n  expect Some(Input { output_reference: in_ref, .. } as in_input) =\n    inputs |> list.at(input_index)\n\n  expect Some(out_utxo) = outputs |> list.at(output_index)\n\n  // Indicated input must match the spending one.\n  expect own_ref == in_ref\n\n  validation_logic(in_input, out_utxo)\n}"
        },
        {
          "name": "one_to_many",
          "signature": "pub fn one_to_many(pub fn one_to_many(input_output_validator: fn(Input, Int, Output) -> Bool, input_collective_outputs_validator: fn(Input, List<Output>) -> Bool, input_index: Int, output_indices: List<Int>, own_ref: OutputReference, inputs: List<Input>, outputs: List<Output>, double_satisfaction_prevented: Bool,",
          "documentation": "Helper function for appointing an input against a set of outputs in a\ntransaction. Similar to [`one_to_one`](#one_to-one), this function also\nvalidates the spent UTxO's output reference matches the one found using the\ninput index.\n\nRequired validation functions are provided with:\n1. `Input` itself, output index, and `Output` itself (this validation is\nexecuted for each output)\n2. `Input` itself, and the list of all `Output`s (this validation is\nexecuted only once)\n\nHere we also have the `double_satisfaction_prevented` argument as a mere\nreminder that this function does not cover double satisfaction on its own.",
          "parameters": [],
          "returnType": "Bool, input_collective_outputs_validator: fn(Input, List<Output>) -> Bool, input_index: Int, output_indices: List<Int>, own_ref: OutputReference, inputs: List<Input>, outputs: List<Output>, double_satisfaction_prevented: Bool,",
          "line": 56,
          "raw": "pub fn one_to_many(pub fn one_to_many(input_output_validator: fn(Input, Int, Output) -> Bool, input_collective_outputs_validator: fn(Input, List<Output>) -> Bool, input_index: Int, output_indices: List<Int>, own_ref: OutputReference, inputs: List<Input>, outputs: List<Output>, double_satisfaction_prevented: Bool,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn one_to_many(\n  input_output_validator: fn(Input, Int, Output) -> Bool,\n  input_collective_outputs_validator: fn(Input, List<Output>) -> Bool,\n  input_index: Int,\n  output_indices: List<Int>,\n  own_ref: OutputReference,\n  inputs: List<Input>,\n  outputs: List<Output>,\n  double_satisfaction_prevented: Bool,\n) -> Bool {\n  expect double_satisfaction_prevented\n  expect Some(input) = inputs |> list.at(input_index)\n\n  let\n    _,\n    all_outputs,\n  <-\n    list_extra.foldr2(\n      output_indices,\n      // sufficiently large index to ensure first check passes\n      511,\n      [],\n      fn(curr_ix, prev_ix, outputs_acc, return) {\n        if curr_ix < prev_ix {\n          expect Some(out_utxo) = outputs |> list.at(curr_ix)\n          expect input_output_validator(input, curr_ix, out_utxo)\n          return(curr_ix, list.push(outputs_acc, out_utxo))\n        } else {\n          fail @\"Output indices must be in ascending order\"\n        }\n      },\n    )\n\n  // Indicated input must match the spending one.\n  expect (own_ref == input.output_reference)?\n\n  input_collective_outputs_validator(input, all_outputs)\n}"
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [
        {
          "name": "always_true_in_out",
          "signature": "fn always_true_in_out(_i: Input, _o: Output) -> Bool {",
          "parameters": [
            {
              "name": "_i",
              "type": "Input",
              "optional": false
            },
            {
              "name": "_o",
              "type": "Output",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 95,
          "raw": "fn always_true_in_out(_i: Input, _o: Output) -> Bool {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn always_true_in_out(_i: Input, _o: Output) -> Bool {\n  True\n}"
        },
        {
          "name": "always_true_in_outs",
          "signature": "fn always_true_in_outs(_i: Input, _os: List<Output>) -> Bool {",
          "parameters": [
            {
              "name": "_i",
              "type": "Input",
              "optional": false
            },
            {
              "name": "_os",
              "type": "List<Output>",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 99,
          "raw": "fn always_true_in_outs(_i: Input, _os: List<Output>) -> Bool {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn always_true_in_outs(_i: Input, _os: List<Output>) -> Bool {\n  True\n}"
        }
      ],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/collection/list\nuse aiken_design_patterns/utils\nuse aiken_scott_utils/list as list_extra\nuse cardano/transaction.{Input, NoDatum, Output, OutputReference}\n\n/// Helper function to be defined in the spending endpoint of your contract, for\n/// appointing an input at `input_index` against an output at `output_index`. By\n/// including this in your spending endpoint, you'll get an efficient access to\n/// your input, and its corresponding output.\n///\n/// Within the function you pass as `validation_logic`, you have access to the\n/// picked input and output.\n///\n/// Apart from `validation_logic`, the only other validation this function\n/// performs for you is the equality of the picked input's output reference with\n/// the one extracted from [`ScriptInfo`](https://aiken-lang.github.io/stdlib/cardano/script_context.html#ScriptInfo).\n///\n/// `double_satisfaction_prevented` is a required `Bool`, which is just a\n/// reminder that this function does NOT cover the\n/// [double satisfaction](https://github.com/Plutonomicon/plutonomicon/blob/b6906173c3f98fb5d7b40fd206f9d6fe14d0b03b/vulnerabilities.md#double-satisfaction)\n/// vulnerability out-of-the-box.\npub fn one_to_one(\n  validation_logic: fn(Input, Output) -> Bool,\n  input_index: Int,\n  output_index: Int,\n  own_ref: OutputReference,\n  inputs: List<Input>,\n  outputs: List<Output>,\n  double_satisfaction_prevented: Bool,\n) -> Bool {\n  expect double_satisfaction_prevented\n  expect Some(Input { output_reference: in_ref, .. } as in_input) =\n    inputs |> list.at(input_index)\n\n  expect Some(out_utxo) = outputs |> list.at(output_index)\n\n  // Indicated input must match the spending one.\n  expect own_ref == in_ref\n\n  validation_logic(in_input, out_utxo)\n}\n\n/// Helper function for appointing an input against a set of outputs in a\n/// transaction. Similar to [`one_to_one`](#one_to-one), this function also\n/// validates the spent UTxO's output reference matches the one found using the\n/// input index.\n///\n/// Required validation functions are provided with:\n/// 1. `Input` itself, output index, and `Output` itself (this validation is\n///    executed for each output)\n/// 2. `Input` itself, and the list of all `Output`s (this validation is\n///    executed only once)\n///\n/// Here we also have the `double_satisfaction_prevented` argument as a mere\n/// reminder that this function does not cover double satisfaction on its own.\npub fn one_to_many(\n  input_output_validator: fn(Input, Int, Output) -> Bool,\n  input_collective_outputs_validator: fn(Input, List<Output>) -> Bool,\n  input_index: Int,\n  output_indices: List<Int>,\n  own_ref: OutputReference,\n  inputs: List<Input>,\n  outputs: List<Output>,\n  double_satisfaction_prevented: Bool,\n) -> Bool {\n  expect double_satisfaction_prevented\n  expect Some(input) = inputs |> list.at(input_index)\n\n  let\n    _,\n    all_outputs,\n  <-\n    list_extra.foldr2(\n      output_indices,\n      // sufficiently large index to ensure first check passes\n      511,\n      [],\n      fn(curr_ix, prev_ix, outputs_acc, return) {\n        if curr_ix < prev_ix {\n          expect Some(out_utxo) = outputs |> list.at(curr_ix)\n          expect input_output_validator(input, curr_ix, out_utxo)\n          return(curr_ix, list.push(outputs_acc, out_utxo))\n        } else {\n          fail @\"Output indices must be in ascending order\"\n        }\n      },\n    )\n\n  // Indicated input must match the spending one.\n  expect (own_ref == input.output_reference)?\n\n  input_collective_outputs_validator(input, all_outputs)\n}\n\nfn always_true_in_out(_i: Input, _o: Output) -> Bool {\n  True\n}\n\nfn always_true_in_outs(_i: Input, _os: List<Output>) -> Bool {\n  True\n}\n\ntest success__one_to_one(\n  script_hash_and_inputs via utils.inputs_with_an_authentic_script_input_fuzzer(\n    NoDatum,\n  ),\n) {\n  let (_script_hash, script_input, inputs) = script_hash_and_inputs\n  let input_index = utils.find_index_of_first_script_input(inputs)\n  one_to_one(\n    always_true_in_out,\n    input_index,\n    0,\n    script_input.output_reference,\n    inputs,\n    [script_input.output],\n    double_satisfaction_prevented: True,\n  )\n}\n\ntest fail__one_to_one__bad_outputs(\n  script_hash_and_inputs via utils.inputs_with_an_authentic_script_input_fuzzer(\n    NoDatum,\n  ),\n) fail {\n  let (_script_hash, script_input, inputs) = script_hash_and_inputs\n  let input_index = utils.find_index_of_first_script_input(inputs)\n  one_to_one(\n    always_true_in_out,\n    input_index,\n    0,\n    script_input.output_reference,\n    inputs,\n    [],\n    double_satisfaction_prevented: True,\n  )\n}\n\ntest success__one_to_many(\n  script_hash_and_inputs via utils.inputs_with_an_authentic_script_input_fuzzer(\n    NoDatum,\n  ),\n) {\n  let (_script_hash, script_input, inputs) = script_hash_and_inputs\n  let input_index = utils.find_index_of_first_script_input(inputs)\n  trace Pair(input_index, list.range(0, 9))\n  one_to_many(\n    fn(_i, _oi, _o) { True },\n    always_true_in_outs,\n    input_index,\n    list.range(0, 9),\n    script_input.output_reference,\n    inputs,\n    list.repeat(script_input.output, 10),\n    double_satisfaction_prevented: True,\n  )\n}\n\ntest fail__one_to_many__bad_outputs(\n  script_hash_and_inputs via utils.inputs_with_an_authentic_script_input_fuzzer(\n    NoDatum,\n  ),\n) fail {\n  let (_script_hash, script_input, inputs) = script_hash_and_inputs\n  let input_index = utils.find_index_of_first_script_input(inputs)\n  one_to_many(\n    fn(_i, _oi, _o) { True },\n    always_true_in_outs,\n    input_index,\n    list.range(0, 9),\n    script_input.output_reference,\n    inputs,\n    [],\n    double_satisfaction_prevented: True,\n  )\n}\n",
      "dependencies": [
        "aiken/collection/list",
        "aiken_design_patterns/utils",
        "aiken_scott_utils/list",
        "cardano/transaction"
      ],
      "source": "anastasia",
      "isReExportFile": false
    },
    {
      "key": "anastasia:aiken-design-patterns.stake-validator",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-design-patterns/lib/aiken-design-patterns/stake-validator.ak",
      "name": "aiken-design-patterns.stake-validator",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 12,
          "raw": "use aiken/builtin",
          "source": "anastasia"
        },
        {
          "module": "aiken/collection/pairs",
          "items": [],
          "line": 13,
          "raw": "use aiken/collection/pairs",
          "source": "anastasia"
        },
        {
          "module": "aiken/crypto",
          "items": ["ScriptHash", "blake2b_224"],
          "line": 14,
          "raw": "use aiken/crypto.{ScriptHash, blake2b_224}",
          "source": "anastasia"
        },
        {
          "module": "aiken/fuzz",
          "items": [],
          "line": 15,
          "raw": "use aiken/fuzz",
          "source": "anastasia"
        },
        {
          "module": "cardano/address",
          "items": ["Credential", "Script"],
          "line": 16,
          "raw": "use cardano/address.{Credential, Script}",
          "source": "anastasia"
        },
        {
          "module": "cardano/assets",
          "items": ["Lovelace"],
          "line": 17,
          "raw": "use cardano/assets.{Lovelace}",
          "source": "anastasia"
        },
        {
          "module": "cardano/transaction",
          "items": ["Redeemer", "Transaction", "Withdraw", "placeholder"],
          "line": 18,
          "raw": "use cardano/transaction.{Redeemer, Transaction, Withdraw, placeholder}",
          "source": "anastasia"
        }
      ],
      "functions": [
        {
          "name": "spend",
          "signature": "pub fn spend(pub fn spend(withdraw_script_hash: ScriptHash, withdraw_redeemer_validator: fn(Redeemer, Lovelace) -> Bool, tx: Transaction,",
          "documentation": "Helper function for implementing validation for spending UTxOs, essentially\ndelegating their requirements to the given withdrawal validator.\n\nIn simpler terms, it says: As long as there is a reward withdrawal of the\ngiven script in transaction, this UTxO can be spent.\n\nAllows you to validate based on both the withdrawal's redeemer (mostly\nuseful for ensuring specific endpoints are invoked), and the withdrawal\nLovelace count.",
          "parameters": [],
          "returnType": "Bool, tx: Transaction,",
          "line": 29,
          "raw": "pub fn spend(pub fn spend(withdraw_script_hash: ScriptHash, withdraw_redeemer_validator: fn(Redeemer, Lovelace) -> Bool, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn spend(\n  withdraw_script_hash: ScriptHash,\n  withdraw_redeemer_validator: fn(Redeemer, Lovelace) -> Bool,\n  tx: Transaction,\n) -> Bool {\n  let Transaction { redeemers, withdrawals, .. } = tx\n\n  let withdraw_script = Script(withdraw_script_hash)\n\n  let withdraw_purpose = Withdraw(withdraw_script)\n\n  let withdraw_redeemer: Redeemer =\n    redeemers |> pairs.get_first(withdraw_purpose)\n\n  expect Some(withdraw_amount) = withdrawals |> pairs.get_first(withdraw_script)\n\n  withdraw_redeemer_validator(withdraw_redeemer, withdraw_amount)\n}"
        },
        {
          "name": "spend_minimal",
          "signature": "pub fn spend_minimal(withdraw_script_hash: ScriptHash, tx: Transaction) -> Bool {",
          "documentation": "A more minimal version of [`spend`](#spend), where only the `withdrawals`\nfield is traversed, and no other validations are performed.",
          "parameters": [
            {
              "name": "withdraw_script_hash",
              "type": "ScriptHash",
              "optional": false
            },
            {
              "name": "tx",
              "type": "Transaction",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 50,
          "raw": "pub fn spend_minimal(withdraw_script_hash: ScriptHash, tx: Transaction) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn spend_minimal(withdraw_script_hash: ScriptHash, tx: Transaction) -> Bool {\n  let Transaction { withdrawals, .. } = tx\n\n  let withdraw_script = Script(withdraw_script_hash)\n\n  when withdrawals |> pairs.get_first(withdraw_script) is {\n    Some(_) -> True\n    _ -> False\n  }\n}"
        },
        {
          "name": "withdraw",
          "signature": "pub fn withdraw(pub fn withdraw(withdrawal_logic: fn(a, ScriptHash, Transaction) -> Bool, redeemer: a, stake_cred: Credential, tx: Transaction,",
          "documentation": "Function to be used under your withdrawal endpoint. The only convenience\nthis function provides is that it'll provide you with the `ScriptHash` of\nyour withdrawal script, so that you don't have to unwrap it yourself.",
          "parameters": [],
          "returnType": "Bool, redeemer: a, stake_cred: Credential, tx: Transaction,",
          "line": 64,
          "raw": "pub fn withdraw(pub fn withdraw(withdrawal_logic: fn(a, ScriptHash, Transaction) -> Bool, redeemer: a, stake_cred: Credential, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn withdraw(\n  withdrawal_logic: fn(a, ScriptHash, Transaction) -> Bool,\n  redeemer: a,\n  stake_cred: Credential,\n  tx: Transaction,\n) -> Bool {\n  expect Script(own_validator) = stake_cred\n\n  withdrawal_logic(redeemer, own_validator, tx)\n}"
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "//// This pattern allows for delegating some computations to a given staking\n//// script.\n//// \n//// The primary application for this is the so-called \"withdraw zero trick,\"\n//// which is most effective for validators that need to go over multiple\n//// inputs.\n//// \n//// With a minimal spending logic (which is executed for each UTxO), and an\n//// arbitrary withdrawal logic (which is executed only once), a much more\n//// optimized script can be implemented.\n\nuse aiken/builtin\nuse aiken/collection/pairs\nuse aiken/crypto.{ScriptHash, blake2b_224}\nuse aiken/fuzz\nuse cardano/address.{Credential, Script}\nuse cardano/assets.{Lovelace}\nuse cardano/transaction.{Redeemer, Transaction, Withdraw, placeholder}\n\n/// Helper function for implementing validation for spending UTxOs, essentially\n/// delegating their requirements to the given withdrawal validator.\n///\n/// In simpler terms, it says: As long as there is a reward withdrawal of the\n/// given script in transaction, this UTxO can be spent.\n///\n/// Allows you to validate based on both the withdrawal's redeemer (mostly\n/// useful for ensuring specific endpoints are invoked), and the withdrawal\n/// Lovelace count.\npub fn spend(\n  withdraw_script_hash: ScriptHash,\n  withdraw_redeemer_validator: fn(Redeemer, Lovelace) -> Bool,\n  tx: Transaction,\n) -> Bool {\n  let Transaction { redeemers, withdrawals, .. } = tx\n\n  let withdraw_script = Script(withdraw_script_hash)\n\n  let withdraw_purpose = Withdraw(withdraw_script)\n\n  let withdraw_redeemer: Redeemer =\n    redeemers |> pairs.get_first(withdraw_purpose)\n\n  expect Some(withdraw_amount) = withdrawals |> pairs.get_first(withdraw_script)\n\n  withdraw_redeemer_validator(withdraw_redeemer, withdraw_amount)\n}\n\n/// A more minimal version of [`spend`](#spend), where only the `withdrawals`\n/// field is traversed, and no other validations are performed.\npub fn spend_minimal(withdraw_script_hash: ScriptHash, tx: Transaction) -> Bool {\n  let Transaction { withdrawals, .. } = tx\n\n  let withdraw_script = Script(withdraw_script_hash)\n\n  when withdrawals |> pairs.get_first(withdraw_script) is {\n    Some(_) -> True\n    _ -> False\n  }\n}\n\n/// Function to be used under your withdrawal endpoint. The only convenience\n/// this function provides is that it'll provide you with the `ScriptHash` of\n/// your withdrawal script, so that you don't have to unwrap it yourself.\npub fn withdraw(\n  withdrawal_logic: fn(a, ScriptHash, Transaction) -> Bool,\n  redeemer: a,\n  stake_cred: Credential,\n  tx: Transaction,\n) -> Bool {\n  expect Script(own_validator) = stake_cred\n\n  withdrawal_logic(redeemer, own_validator, tx)\n}\n\ntest success_spend(script_hash via fuzz.bytearray_fixed(28)) {\n  let tx =\n    Transaction {\n      ..placeholder,\n      redeemers: [Pair(Withdraw(Script(script_hash)), builtin.i_data(0))],\n      withdrawals: [Pair(Script(script_hash), 0)],\n    }\n  spend(script_hash, fn(_r_data, _qty) { True }, tx)\n}\n\ntest fail_spend(script_hash via fuzz.bytearray_fixed(28)) fail {\n  let spend_script = Script(script_hash)\n  let tx =\n    Transaction {\n      ..placeholder,\n      redeemers: [Pair(Withdraw(spend_script), builtin.i_data(0))],\n      withdrawals: [Pair(spend_script, 0)],\n    }\n  // Hashing to get a different script hash\n  let expected_withdraw_script_hash = blake2b_224(script_hash)\n  spend(expected_withdraw_script_hash, fn(_r_data, _qty) { True }, tx)\n}\n\ntest success_spend_minimal(script_hash via fuzz.bytearray_fixed(28)) {\n  let tx =\n    Transaction { ..placeholder, withdrawals: [Pair(Script(script_hash), 0)] }\n  spend_minimal(script_hash, tx)\n}\n\ntest fail_spend_minimal(script_hash via fuzz.bytearray_fixed(28)) fail {\n  let spend_script = Script(script_hash)\n  let tx = Transaction { ..placeholder, withdrawals: [Pair(spend_script, 0)] }\n  // Hashing to get a different script hash\n  let expected_withdraw_script_hash = blake2b_224(script_hash)\n  spend_minimal(expected_withdraw_script_hash, tx)\n}\n",
      "dependencies": [
        "aiken/builtin",
        "aiken/collection/pairs",
        "aiken/crypto",
        "aiken/fuzz",
        "cardano/address",
        "cardano/assets",
        "cardano/transaction"
      ],
      "source": "anastasia",
      "isReExportFile": false
    },
    {
      "key": "anastasia:aiken-design-patterns.tests",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-design-patterns/lib/aiken-design-patterns/tests.ak",
      "name": "aiken-design-patterns.tests",
      "imports": [
        {
          "module": "aiken/crypto",
          "items": ["blake2b_256"],
          "line": 1,
          "raw": "use aiken/crypto.{blake2b_256}",
          "source": "anastasia"
        },
        {
          "module": "aiken/fuzz",
          "items": [],
          "line": 2,
          "raw": "use aiken/fuzz",
          "source": "anastasia"
        },
        {
          "module": "aiken/primitive/bytearray",
          "items": [],
          "line": 3,
          "raw": "use aiken/primitive/bytearray",
          "source": "anastasia"
        },
        {
          "module": "cardano/address",
          "items": ["Address", "Script"],
          "line": 7,
          "raw": "use cardano/address.{Address, Script}",
          "source": "anastasia"
        },
        {
          "module": "cardano/assets",
          "items": [],
          "line": 8,
          "raw": "use cardano/assets",
          "source": "anastasia"
        },
        {
          "module": "cardano/transaction",
          "items": ["InlineDatum", "Output"],
          "line": 9,
          "raw": "use cardano/transaction.{InlineDatum, Output}",
          "source": "anastasia"
        }
      ],
      "functions": [],
      "types": [],
      "constants": [],
      "atoms": [
        {
          "name": "test_224_01",
          "signature": "fn test_224_01() {",
          "parameters": [],
          "returnType": "Unknown",
          "line": 12,
          "raw": "fn test_224_01() {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn test_224_01() {\n  bytearray.take(blake2b_256(#\"01\"), 28)\n}"
        },
        {
          "name": "test_224_02",
          "signature": "fn test_224_02() {",
          "parameters": [],
          "returnType": "Unknown",
          "line": 17,
          "raw": "fn test_224_02() {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn test_224_02() {\n  bytearray.take(blake2b_256(#\"02\"), 28)\n}"
        },
        {
          "name": "test_utxo_01",
          "signature": "fn test_utxo_01() {",
          "parameters": [],
          "returnType": "Unknown",
          "line": 22,
          "raw": "fn test_utxo_01() {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn test_utxo_01() {\n  Output {\n    address: Address {\n      payment_credential: Script(test_224_01()),\n      stake_credential: None,\n    },\n    value: assets.add(assets.from_lovelace(2_000_000), test_224_01(), #\"01\", 1),\n    datum: InlineDatum(1),\n    reference_script: None,\n  }\n}"
        },
        {
          "name": "test_utxo_02",
          "signature": "fn test_utxo_02() {",
          "parameters": [],
          "returnType": "Unknown",
          "line": 35,
          "raw": "fn test_utxo_02() {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn test_utxo_02() {\n  Output {\n    address: Address {\n      payment_credential: Script(test_224_02()),\n      stake_credential: None,\n    },\n    value: assets.add(assets.from_lovelace(2_000_000), test_224_02(), #\"02\", 1),\n    datum: InlineDatum(1),\n    reference_script: None,\n  }\n}"
        }
      ],
      "privateTypes": [],
      "privateConstants": [],
      "content": "use aiken/crypto.{blake2b_256}\nuse aiken/fuzz\nuse aiken/primitive/bytearray\nuse aiken_design_patterns/utils.{\n  authentic_input_is_reproduced_unchanged, sum_of_squares,\n}\nuse cardano/address.{Address, Script}\nuse cardano/assets\nuse cardano/transaction.{InlineDatum, Output}\n\n// Generate a bytearray with blake2b_256\nfn test_224_01() {\n  bytearray.take(blake2b_256(#\"01\"), 28)\n}\n\n// Generate a bytearray with blake2b_256\nfn test_224_02() {\n  bytearray.take(blake2b_256(#\"02\"), 28)\n}\n\n// Create a UTxO\nfn test_utxo_01() {\n  Output {\n    address: Address {\n      payment_credential: Script(test_224_01()),\n      stake_credential: None,\n    },\n    value: assets.add(assets.from_lovelace(2_000_000), test_224_01(), #\"01\", 1),\n    datum: InlineDatum(1),\n    reference_script: None,\n  }\n}\n\n// Create a UTxO\nfn test_utxo_02() {\n  Output {\n    address: Address {\n      payment_credential: Script(test_224_02()),\n      stake_credential: None,\n    },\n    value: assets.add(assets.from_lovelace(2_000_000), test_224_02(), #\"02\", 1),\n    datum: InlineDatum(1),\n    reference_script: None,\n  }\n}\n\n// Test case to ensure authentic UTXO is reproduced unchanged\ntest authentic_utxo_reproduced() {\n  authentic_input_is_reproduced_unchanged(\n    test_224_01(),\n    None,\n    test_utxo_01(),\n    test_utxo_01(),\n  )\n}\n\n// Test case to ensure unauthentic UTXO is not reproduced unchanged\ntest unauthentic_utxo_reproduced() fail {\n  authentic_input_is_reproduced_unchanged(\n    test_224_01(),\n    None,\n    test_utxo_01(),\n    test_utxo_02(),\n  )\n}\n\n// Test case for sum_of_squares function with expected output\ntest sum_of_squares_test_ok() {\n  sum_of_squares([100, 20, 3, 4, 5]) == 10450\n}\n\n// Test case for sum_of_squares function with expected failure\ntest sum_of_squares_test_fail() fail {\n  sum_of_squares([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 1\n}\n\n// Property-based test: Testing the identity property with a single-element list\ntest prop_sum_of_squares_identity(x: Int via fuzz.int()) {\n  sum_of_squares([x]) == x * x\n}\n\n// Property-based test: Testing non-negativity of the sum of squares\ntest prop_sum_of_squares_non_negative(xs: List<Int> via fuzz.list(fuzz.int())) {\n  let result = sum_of_squares(xs)\n  result >= 0\n}\n",
      "dependencies": [
        "aiken/crypto",
        "aiken/fuzz",
        "aiken/primitive/bytearray",
        "cardano/address",
        "cardano/assets",
        "cardano/transaction"
      ],
      "source": "anastasia",
      "isReExportFile": false
    },
    {
      "key": "anastasia:aiken-design-patterns.tx-level-minter",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-design-patterns/lib/aiken-design-patterns/tx-level-minter.ak",
      "name": "aiken-design-patterns.tx-level-minter",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 13,
          "raw": "use aiken/builtin",
          "source": "anastasia"
        },
        {
          "module": "aiken/collection/dict",
          "items": ["Dict"],
          "line": 14,
          "raw": "use aiken/collection/dict.{Dict}",
          "source": "anastasia"
        },
        {
          "module": "aiken/collection/list",
          "items": [],
          "line": 15,
          "raw": "use aiken/collection/list",
          "source": "anastasia"
        },
        {
          "module": "aiken/collection/pairs",
          "items": [],
          "line": 16,
          "raw": "use aiken/collection/pairs",
          "source": "anastasia"
        },
        {
          "module": "aiken/crypto",
          "items": ["blake2b_224"],
          "line": 17,
          "raw": "use aiken/crypto.{blake2b_224}",
          "source": "anastasia"
        },
        {
          "module": "aiken/fuzz",
          "items": [],
          "line": 18,
          "raw": "use aiken/fuzz",
          "source": "anastasia"
        },
        {
          "module": "aiken_design_patterns/utils",
          "items": [],
          "alias": "utils",
          "line": 19,
          "raw": "use aiken_design_patterns/utils as utils",
          "source": "anastasia"
        },
        {
          "module": "cardano/assets",
          "items": ["AssetName", "PolicyId", "Value"],
          "line": 20,
          "raw": "use cardano/assets.{AssetName, PolicyId, Value}",
          "source": "anastasia"
        },
        {
          "module": "cardano/transaction",
          "items": ["Mint", "Redeemer", "Transaction", "placeholder"],
          "line": 21,
          "raw": "use cardano/transaction.{Mint, Redeemer, Transaction, placeholder}",
          "source": "anastasia"
        }
      ],
      "functions": [
        {
          "name": "spend",
          "signature": "pub fn spend(pub fn spend(mint_script_hash: PolicyId, mint_redeemer_validator: fn(Redeemer) -> Bool, mint_tokens_validator: fn(Dict<AssetName, Int>) -> Bool, tx: Transaction,",
          "documentation": "Function to be used under the spending endpoint of your validator. It looks\nat both the redeemers, and minted tokens to allow you validate both its\nredeemer, and its tokens getting minted/burnt.",
          "parameters": [],
          "returnType": "Bool, mint_tokens_validator: fn(Dict<AssetName, Int>) -> Bool, tx: Transaction,",
          "line": 26,
          "raw": "pub fn spend(pub fn spend(mint_script_hash: PolicyId, mint_redeemer_validator: fn(Redeemer) -> Bool, mint_tokens_validator: fn(Dict<AssetName, Int>) -> Bool, tx: Transaction,",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn spend(\n  mint_script_hash: PolicyId,\n  mint_redeemer_validator: fn(Redeemer) -> Bool,\n  mint_tokens_validator: fn(Dict<AssetName, Int>) -> Bool,\n  tx: Transaction,\n) -> Bool {\n  let Transaction { mint, redeemers, .. } = tx\n\n  let mint_purpose = Mint(mint_script_hash)\n\n  let mint_redeemer: Redeemer = redeemers |> pairs.get_first(mint_purpose)\n\n  let tokens = mint |> assets.tokens(mint_script_hash)\n\n  and {\n    mint_redeemer_validator(mint_redeemer),\n    mint_tokens_validator(tokens),\n  }\n}"
        },
        {
          "name": "spend_minimal",
          "signature": "pub fn spend_minimal(mint_script_hash: PolicyId, tx: Transaction) -> Bool {",
          "documentation": "A minimal version of [`spend`](#spend), where the only validation is\npresence of at least one minting/burning action with the given policy ID.",
          "parameters": [
            {
              "name": "mint_script_hash",
              "type": "PolicyId",
              "optional": false
            },
            {
              "name": "tx",
              "type": "Transaction",
              "optional": false
            }
          ],
          "returnType": "Bool",
          "line": 48,
          "raw": "pub fn spend_minimal(mint_script_hash: PolicyId, tx: Transaction) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn spend_minimal(mint_script_hash: PolicyId, tx: Transaction) -> Bool {\n  !(tx.mint |> assets.tokens(mint_script_hash) |> dict.is_empty)\n}"
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [
        {
          "name": "grab_a_policy_from_mint",
          "signature": "fn grab_a_policy_from_mint(m: Value) -> Fuzzer<(PolicyId, Value)> {",
          "parameters": [
            {
              "name": "m",
              "type": "Value",
              "optional": false
            }
          ],
          "returnType": "Fuzzer<(PolicyId, Value)>",
          "line": 52,
          "raw": "fn grab_a_policy_from_mint(m: Value) -> Fuzzer<(PolicyId, Value)> {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn grab_a_policy_from_mint(m: Value) -> Fuzzer<(PolicyId, Value)> {\n  let policies = m |> assets.policies\n  fuzz.map(\n    fuzz.int_between(0, list.length(policies) - 1),\n    fn(i) {\n      trace list.length(policies)\n      trace i\n      expect Some(p) = list.at(policies, i)\n      (p, m)\n    },\n  )\n}"
        }
      ],
      "privateTypes": [],
      "privateConstants": [],
      "content": "//// This design pattern couples the spend and minting endpoints of a validator,\n//// in order to have minimal spend costs, in exchange for a single execution of\n//// the minting endpoint.\n//// \n//// In other words, spend logic only ensures the minting endpoint executes. It\n//// does so by looking at the mint field and making sure **only** a non-zero\n//// amount of its asset (i.e. with a policy identical to the validator's hash,\n//// where its name comes from `expected_mint_name`) are getting minted/burnt.\n//// \n//// The arbitrary logic is passed to the minting policy so that it can be\n//// executed a single time for a given transaction.\n\nuse aiken/builtin\nuse aiken/collection/dict.{Dict}\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{blake2b_224}\nuse aiken/fuzz\nuse aiken_design_patterns/utils as utils\nuse cardano/assets.{AssetName, PolicyId, Value}\nuse cardano/transaction.{Mint, Redeemer, Transaction, placeholder}\n\n/// Function to be used under the spending endpoint of your validator. It looks\n/// at both the redeemers, and minted tokens to allow you validate both its\n/// redeemer, and its tokens getting minted/burnt.\npub fn spend(\n  mint_script_hash: PolicyId,\n  mint_redeemer_validator: fn(Redeemer) -> Bool,\n  mint_tokens_validator: fn(Dict<AssetName, Int>) -> Bool,\n  tx: Transaction,\n) -> Bool {\n  let Transaction { mint, redeemers, .. } = tx\n\n  let mint_purpose = Mint(mint_script_hash)\n\n  let mint_redeemer: Redeemer = redeemers |> pairs.get_first(mint_purpose)\n\n  let tokens = mint |> assets.tokens(mint_script_hash)\n\n  and {\n    mint_redeemer_validator(mint_redeemer),\n    mint_tokens_validator(tokens),\n  }\n}\n\n/// A minimal version of [`spend`](#spend), where the only validation is\n/// presence of at least one minting/burning action with the given policy ID.\npub fn spend_minimal(mint_script_hash: PolicyId, tx: Transaction) -> Bool {\n  !(tx.mint |> assets.tokens(mint_script_hash) |> dict.is_empty)\n}\n\nfn grab_a_policy_from_mint(m: Value) -> Fuzzer<(PolicyId, Value)> {\n  let policies = m |> assets.policies\n  fuzz.map(\n    fuzz.int_between(0, list.length(policies) - 1),\n    fn(i) {\n      trace list.length(policies)\n      trace i\n      expect Some(p) = list.at(policies, i)\n      (p, m)\n    },\n  )\n}\n\ntest success_spend(\n  random_policy_and_mint via fuzz.and_then(\n    utils.mint_fuzzer(),\n    grab_a_policy_from_mint,\n  ),\n) {\n  let (random_policy, random_mint) = random_policy_and_mint\n  let tx =\n    Transaction {\n      ..placeholder,\n      mint: random_mint,\n      redeemers: [Pair(Mint(random_policy), builtin.i_data(0))],\n    }\n  spend(random_policy, fn(_r_data) { True }, fn(_tn_qty_dict) { True }, tx)\n}\n\ntest fail_spend(\n  random_policy_and_mint via fuzz.and_then(\n    utils.mint_fuzzer(),\n    grab_a_policy_from_mint,\n  ),\n) {\n  let (random_policy, random_mint) = random_policy_and_mint\n  let tx =\n    Transaction {\n      ..placeholder,\n      mint: random_mint,\n      redeemers: [Pair(Mint(random_policy), builtin.i_data(0))],\n    }\n  // Hashing to get a different policy\n  let hashed_policy = blake2b_224(random_policy)\n  spend(hashed_policy, fn(_r_data) { True }, fn(_tn_qty_dict) { True }, tx)\n}\n\ntest success_spend_minimal(script_hash via fuzz.bytearray_fixed(28)) {\n  let tx =\n    Transaction { ..placeholder, mint: assets.from_asset(script_hash, #\"\", 1) }\n  spend_minimal(script_hash, tx)\n}\n\ntest fail_spend_minimal(script_hash via fuzz.bytearray_fixed(28)) fail {\n  let tx =\n    Transaction { ..placeholder, mint: assets.from_asset(script_hash, #\"\", 1) }\n  // Hashing to get a different script hash\n  let expected_mint_script_hash = blake2b_224(script_hash)\n  spend_minimal(expected_mint_script_hash, tx)\n}\n",
      "dependencies": [
        "aiken/builtin",
        "aiken/collection/dict",
        "aiken/collection/list",
        "aiken/collection/pairs",
        "aiken/crypto",
        "aiken/fuzz",
        "aiken_design_patterns/utils",
        "cardano/assets",
        "cardano/transaction"
      ],
      "source": "anastasia",
      "isReExportFile": false
    },
    {
      "key": "anastasia:aiken-design-patterns.utils",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-design-patterns/lib/aiken-design-patterns/utils.ak",
      "name": "aiken-design-patterns.utils",
      "imports": [
        {
          "module": "aiken/builtin",
          "items": [],
          "line": 3,
          "raw": "use aiken/builtin",
          "source": "anastasia"
        },
        {
          "module": "aiken/collection/list",
          "items": ["foldl"],
          "line": 4,
          "raw": "use aiken/collection/list.{foldl}",
          "source": "anastasia"
        },
        {
          "module": "aiken/crypto",
          "items": ["ScriptHash"],
          "line": 5,
          "raw": "use aiken/crypto.{ScriptHash}",
          "source": "anastasia"
        },
        {
          "module": "aiken/fuzz",
          "items": ["and_then"],
          "line": 6,
          "raw": "use aiken/fuzz.{and_then}",
          "source": "anastasia"
        },
        {
          "module": "cardano/address",
          "items": ["Address", "Inline", "Script", "VerificationKey"],
          "line": 7,
          "raw": "use cardano/address.{Address, Inline, Script, VerificationKey}",
          "source": "anastasia"
        },
        {
          "module": "cardano/assets",
          "items": ["AssetName", "PolicyId", "Value"],
          "line": 8,
          "raw": "use cardano/assets.{AssetName, PolicyId, Value}",
          "source": "anastasia"
        },
        {
          "module": "cardano/transaction",
          "items": ["Datum", "Input", "NoDatum", "Output", "OutputReference"],
          "line": 9,
          "raw": "use cardano/transaction.{Datum, Input, NoDatum, Output, OutputReference}",
          "source": "anastasia"
        },
        {
          "module": "cardano/transaction/output_reference",
          "items": [],
          "alias": "output_reference",
          "line": 10,
          "raw": "use cardano/transaction/output_reference as output_reference",
          "source": "anastasia"
        }
      ],
      "functions": [
        {
          "name": "sort_inputs",
          "signature": "pub fn sort_inputs(inputs: List<Input>) -> List<Input> {",
          "parameters": [
            {
              "name": "inputs",
              "type": "List<Input>",
              "optional": false
            }
          ],
          "returnType": "List<Input>",
          "line": 12,
          "raw": "pub fn sort_inputs(inputs: List<Input>) -> List<Input> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn sort_inputs(inputs: List<Input>) -> List<Input> {\n  inputs\n    |> list.sort(\n        fn(i0: Input, i1: Input) {\n          output_reference.compare(i0.output_reference, i1.output_reference)\n        },\n      )\n}"
        },
        {
          "name": "resolve_output_reference",
          "signature": "pub fn resolve_output_reference(pub fn resolve_output_reference(inputs: List<Input>, output_ref: OutputReference, ) -> Output {",
          "documentation": "Copied from [Fortuna](https://github.com/cardano-miners/fortuna/blob/5eeb1bc31b72252b991bbcaf836b128dca6a74b9/lib/fortuna/utils.ak#L6-L17).",
          "parameters": [],
          "returnType": "Output",
          "line": 22,
          "raw": "pub fn resolve_output_reference(pub fn resolve_output_reference(inputs: List<Input>, output_ref: OutputReference, ) -> Output {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn resolve_output_reference(\n  inputs: List<Input>,\n  output_ref: OutputReference,\n) -> Output {\n  expect [input, ..] = inputs\n\n  if input.output_reference == output_ref {\n    input.output\n  } else {\n    resolve_output_reference(builtin.tail_list(inputs), output_ref)\n  }\n}"
        },
        {
          "name": "authentic_input_is_reproduced_unchanged",
          "signature": "pub fn authentic_input_is_reproduced_unchanged(pub fn authentic_input_is_reproduced_unchanged(auth_symbol: PolicyId, optional_auth_name: Option<AssetName>, in_utxo: Output, out_utxo: Output, ) -> Bool {",
          "parameters": [],
          "returnType": "Bool",
          "line": 35,
          "raw": "pub fn authentic_input_is_reproduced_unchanged(pub fn authentic_input_is_reproduced_unchanged(auth_symbol: PolicyId, optional_auth_name: Option<AssetName>, in_utxo: Output, out_utxo: Output, ) -> Bool {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn authentic_input_is_reproduced_unchanged(\n  auth_symbol: PolicyId,\n  optional_auth_name: Option<AssetName>,\n  in_utxo: Output,\n  out_utxo: Output,\n) -> Bool {\n  expect Output {\n    value: in_val,\n    datum: in_dat,\n    address: in_addr,\n    reference_script: None,\n  } = in_utxo\n  expect Output {\n    value: out_val,\n    datum: out_dat,\n    address: out_addr,\n    reference_script: None,\n  } = out_utxo\n\n  expect [_, (in_sym, in_name, in_quantity)] = in_val |> assets.flatten\n\n  let name_is_authentic =\n    when optional_auth_name is {\n      Some(auth_name) -> in_name == auth_name\n      None -> True\n    }\n  and {\n    in_val == out_val,\n    in_dat == out_dat,\n    in_addr.payment_credential == out_addr.payment_credential,\n    in_sym == auth_symbol,\n    name_is_authentic,\n    in_quantity == 1,\n  }\n}"
        },
        {
          "name": "sum_of_squares",
          "signature": "pub fn sum_of_squares(xs: List<Int>) -> Int {",
          "parameters": [
            {
              "name": "xs",
              "type": "List<Int>",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 71,
          "raw": "pub fn sum_of_squares(xs: List<Int>) -> Int {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn sum_of_squares(xs: List<Int>) -> Int {\n  xs |> foldl(0, fn(x, acc) { acc + x * x })\n}"
        },
        {
          "name": "find_index_of_first_script_input",
          "signature": "pub fn find_index_of_first_script_input(inputs: List<Input>) -> Int {",
          "documentation": "Given a list of inputs, this function returns the index of the first inputs\nwhich its address has a `Script` payment part.",
          "parameters": [
            {
              "name": "inputs",
              "type": "List<Input>",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 77,
          "raw": "pub fn find_index_of_first_script_input(inputs: List<Input>) -> Int {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn find_index_of_first_script_input(inputs: List<Input>) -> Int {\n  expect Some(input_index) =\n    list.indexed_foldr(\n      inputs,\n      None,\n      fn(i, input, m_i) {\n        when m_i is {\n          Some(_) -> m_i\n          None ->\n            when input.output.address.payment_credential is {\n              Script(_) -> Some(i)\n              _ -> None\n            }\n        }\n      },\n    )\n  input_index\n}"
        },
        {
          "name": "single_specific_asset_value_fuzzer",
          "signature": "pub fn single_specific_asset_value_fuzzer(policyId: ByteArray) -> Fuzzer<Value> {",
          "documentation": "A fuzzer for `Value` with a single asset. Unsafely expects 28 bytes long\npolicy ID to be provided.",
          "parameters": [
            {
              "name": "policyId",
              "type": "ByteArray",
              "optional": false
            }
          ],
          "returnType": "Fuzzer<Value>",
          "line": 98,
          "raw": "pub fn single_specific_asset_value_fuzzer(policyId: ByteArray) -> Fuzzer<Value> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn single_specific_asset_value_fuzzer(policyId: ByteArray) -> Fuzzer<Value> {\n  let token_name <- and_then(fuzz.bytearray_between(0, 32))\n  let quantity <- and_then(fuzz.int_at_least(1))\n  fuzz.constant(assets.from_asset(policyId, token_name, quantity))\n}"
        },
        {
          "name": "single_asset_value_fuzzer",
          "signature": "pub fn single_asset_value_fuzzer() -> Fuzzer<Value> {",
          "documentation": "A `Value` fuzzer with a single asset. Randomly generates the policy ID.",
          "parameters": [],
          "returnType": "Fuzzer<Value>",
          "line": 105,
          "raw": "pub fn single_asset_value_fuzzer() -> Fuzzer<Value> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn single_asset_value_fuzzer() -> Fuzzer<Value> {\n  let policyId <- and_then(fuzz.bytearray_fixed(28))\n  single_specific_asset_value_fuzzer(policyId)\n}"
        },
        {
          "name": "mint_fuzzer",
          "signature": "pub fn mint_fuzzer() -> Fuzzer<Value> {",
          "documentation": "A `Value` fuzzer without any lovelaces.",
          "parameters": [],
          "returnType": "Fuzzer<Value>",
          "line": 111,
          "raw": "pub fn mint_fuzzer() -> Fuzzer<Value> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn mint_fuzzer() -> Fuzzer<Value> {\n  let other_assets_values <-\n    and_then(fuzz.list_between(single_asset_value_fuzzer(), 1, 10))\n  fuzz.constant(\n    list.foldl(\n      other_assets_values,\n      assets.zero,\n      fn(v, acc) { assets.merge(v, acc) },\n    ),\n  )\n}"
        },
        {
          "name": "value_fuzzer",
          "signature": "pub fn value_fuzzer(min_lovelaces: Int) -> Fuzzer<Value> {",
          "documentation": "A `Value` fuzzer, guaranteed to include some amount of ADA (minimum must be\nspecified).",
          "parameters": [
            {
              "name": "min_lovelaces",
              "type": "Int",
              "optional": false
            }
          ],
          "returnType": "Fuzzer<Value>",
          "line": 125,
          "raw": "pub fn value_fuzzer(min_lovelaces: Int) -> Fuzzer<Value> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn value_fuzzer(min_lovelaces: Int) -> Fuzzer<Value> {\n  let lovelace_count <- and_then(fuzz.int_at_least(min_lovelaces))\n  let lovelace_value = assets.from_lovelace(lovelace_count)\n  let other_assets_values <-\n    and_then(fuzz.list_at_most(single_asset_value_fuzzer(), 10))\n  fuzz.constant(\n    list.foldl(\n      other_assets_values,\n      lovelace_value,\n      fn(v, acc) { assets.merge(v, acc) },\n    ),\n  )\n}"
        },
        {
          "name": "output_reference_fuzzer",
          "signature": "pub fn output_reference_fuzzer() -> Fuzzer<OutputReference> {",
          "documentation": "Output reference fuzzer, transaction ID with 32 bytes, and output index\nbetween 0 and 512.",
          "parameters": [],
          "returnType": "Fuzzer<OutputReference>",
          "line": 141,
          "raw": "pub fn output_reference_fuzzer() -> Fuzzer<OutputReference> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn output_reference_fuzzer() -> Fuzzer<OutputReference> {\n  let ref_bytes <- and_then(fuzz.bytearray_fixed(32))\n  let output_index <- and_then(fuzz.int_between(0, 512))\n  fuzz.constant(OutputReference { transaction_id: ref_bytes, output_index })\n}"
        },
        {
          "name": "user_output_fuzzer",
          "signature": "pub fn user_output_fuzzer() -> Fuzzer<Output> {",
          "documentation": "Simple wallet UTxO fuzzer, with a random number of tokens/NFTs.",
          "parameters": [],
          "returnType": "Fuzzer<Output>",
          "line": 148,
          "raw": "pub fn user_output_fuzzer() -> Fuzzer<Output> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn user_output_fuzzer() -> Fuzzer<Output> {\n  let pkh <- and_then(fuzz.bytearray_fixed(28))\n  let skh <- and_then(fuzz.bytearray_fixed(28))\n  let v <- and_then(value_fuzzer(2_000_000))\n  fuzz.constant(\n    Output {\n      address: Address {\n        payment_credential: VerificationKey(pkh),\n        stake_credential: Some(Inline(VerificationKey(skh))),\n      },\n      value: v,\n      datum: NoDatum,\n      reference_script: None,\n    },\n  )\n}"
        },
        {
          "name": "user_input_fuzzer",
          "signature": "pub fn user_input_fuzzer() -> Fuzzer<Input> {",
          "documentation": "Simple wallet UTxO fuzzer, with a random reference output and a random\nnumber of tokens/NFTs.",
          "parameters": [],
          "returnType": "Fuzzer<Input>",
          "line": 167,
          "raw": "pub fn user_input_fuzzer() -> Fuzzer<Input> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn user_input_fuzzer() -> Fuzzer<Input> {\n  let output_reference <- and_then(output_reference_fuzzer())\n  let output <- and_then(user_output_fuzzer())\n  fuzz.constant(Input { output_reference, output })\n}"
        },
        {
          "name": "specific_script_output_fuzzer",
          "signature": "pub fn specific_script_output_fuzzer(pub fn specific_script_output_fuzzer(script_hash: ScriptHash, datum: Datum, ) -> Fuzzer<Output> {",
          "documentation": "Given a script hash and datum, this fuzzer generates a UTxO at an address\nwhich its payment part is the same as the given script hash.",
          "parameters": [],
          "returnType": "Fuzzer<Output>",
          "line": 175,
          "raw": "pub fn specific_script_output_fuzzer(pub fn specific_script_output_fuzzer(script_hash: ScriptHash, datum: Datum, ) -> Fuzzer<Output> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn specific_script_output_fuzzer(\n  script_hash: ScriptHash,\n  datum: Datum,\n) -> Fuzzer<Output> {\n  let v <- and_then(value_fuzzer(2_000_000))\n  fuzz.constant(\n    Output {\n      address: Address {\n        payment_credential: Script(script_hash),\n        stake_credential: None,\n      },\n      value: v,\n      datum,\n      reference_script: None,\n    },\n  )\n}"
        },
        {
          "name": "script_output_fuzzer",
          "signature": "pub fn script_output_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Output)> {",
          "documentation": "Returns a tuple where its first element is the random script hash (payment\npart of the UTxO's address). UTxO value is also random, with 2 ADA.",
          "parameters": [
            {
              "name": "datum",
              "type": "Datum",
              "optional": false
            }
          ],
          "returnType": "Fuzzer<(ByteArray, Output)>",
          "line": 195,
          "raw": "pub fn script_output_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Output)> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn script_output_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Output)> {\n  let script_hash <- and_then(fuzz.bytearray_fixed(28))\n  let utxo <- and_then(specific_script_output_fuzzer(script_hash, datum))\n  fuzz.constant((script_hash, utxo))\n}"
        },
        {
          "name": "authentic_script_output_fuzzer",
          "signature": "pub fn authentic_script_output_fuzzer(pub fn authentic_script_output_fuzzer(datum: Datum, ) -> Fuzzer<(ByteArray, Output)> {",
          "documentation": "UTxO fuzzer, where the value is composed of 2 ADA and a beacon NFT, such\nthat its policy ID is equal to the script credential of the payment part of\nUTxO's address. This script hash is also returned.",
          "parameters": [],
          "returnType": "Fuzzer<(ByteArray, Output)>",
          "line": 204,
          "raw": "pub fn authentic_script_output_fuzzer(pub fn authentic_script_output_fuzzer(datum: Datum, ) -> Fuzzer<(ByteArray, Output)> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn authentic_script_output_fuzzer(\n  datum: Datum,\n) -> Fuzzer<(ByteArray, Output)> {\n  let script_hash <- and_then(fuzz.bytearray_fixed(28))\n  let tn <- and_then(fuzz.bytearray_between(0, 32))\n  let lovelace_value = assets.from_lovelace(2_000_000)\n  let beacon = assets.from_asset(script_hash, tn, 1)\n  let v = assets.merge(lovelace_value, beacon)\n  fuzz.constant(\n    (\n      script_hash,\n      Output {\n        address: Address {\n          payment_credential: Script(script_hash),\n          stake_credential: None,\n        },\n        value: v,\n        datum,\n        reference_script: None,\n      },\n    ),\n  )\n}"
        },
        {
          "name": "specific_script_input_fuzzer",
          "signature": "pub fn specific_script_input_fuzzer(pub fn specific_script_input_fuzzer(script_hash: ScriptHash, datum: Datum, ) -> Fuzzer<Input> {",
          "documentation": "Similar to [`specific_script_output_fuzzer`](#specific_script_output_fuzzer),\nwith an additional randomized wrapper for output reference.",
          "parameters": [],
          "returnType": "Fuzzer<Input>",
          "line": 230,
          "raw": "pub fn specific_script_input_fuzzer(pub fn specific_script_input_fuzzer(script_hash: ScriptHash, datum: Datum, ) -> Fuzzer<Input> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn specific_script_input_fuzzer(\n  script_hash: ScriptHash,\n  datum: Datum,\n) -> Fuzzer<Input> {\n  let output_reference <- and_then(output_reference_fuzzer())\n  let output <- and_then(specific_script_output_fuzzer(script_hash, datum))\n  fuzz.constant(Input { output_reference, output })\n}"
        },
        {
          "name": "script_input_fuzzer",
          "signature": "pub fn script_input_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Input)> {",
          "documentation": "Similar to [`script_output_fuzzer`](#script_output_fuzzer), with an\nadditional randomized wrapper for output reference.",
          "parameters": [
            {
              "name": "datum",
              "type": "Datum",
              "optional": false
            }
          ],
          "returnType": "Fuzzer<(ByteArray, Input)>",
          "line": 241,
          "raw": "pub fn script_input_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Input)> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn script_input_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Input)> {\n  let output_reference <- and_then(output_reference_fuzzer())\n  let (script_hash, output) <- and_then(script_output_fuzzer(datum))\n  fuzz.constant((script_hash, Input { output_reference, output }))\n}"
        },
        {
          "name": "authentic_script_input_fuzzer",
          "signature": "pub fn authentic_script_input_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Input)> {",
          "documentation": "Similar to [`authentic_script_output_fuzzer`](#script_output_fuzzer), with\nand additional randomized wrapper for output reference.",
          "parameters": [
            {
              "name": "datum",
              "type": "Datum",
              "optional": false
            }
          ],
          "returnType": "Fuzzer<(ByteArray, Input)>",
          "line": 249,
          "raw": "pub fn authentic_script_input_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Input)> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn authentic_script_input_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Input)> {\n  let output_reference <- and_then(output_reference_fuzzer())\n  let (script_hash, output) <- and_then(authentic_script_output_fuzzer(datum))\n  fuzz.constant((script_hash, Input { output_reference, output }))\n}"
        },
        {
          "name": "user_outputs_fuzzer",
          "signature": "pub fn user_outputs_fuzzer() -> Fuzzer<List<Output>> {",
          "documentation": "Simple (non-script) outputs fuzzer.",
          "parameters": [],
          "returnType": "Fuzzer<List<Output>>",
          "line": 256,
          "raw": "pub fn user_outputs_fuzzer() -> Fuzzer<List<Output>> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn user_outputs_fuzzer() -> Fuzzer<List<Output>> {\n  fuzz.list_between(user_output_fuzzer(), 1, 10)\n}"
        },
        {
          "name": "user_inputs_fuzzer",
          "signature": "pub fn user_inputs_fuzzer() -> Fuzzer<List<Input>> {",
          "documentation": "Simple (non-script) inputs fuzzer.",
          "parameters": [],
          "returnType": "Fuzzer<List<Input>>",
          "line": 261,
          "raw": "pub fn user_inputs_fuzzer() -> Fuzzer<List<Input>> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn user_inputs_fuzzer() -> Fuzzer<List<Input>> {\n  fuzz.list_between(user_input_fuzzer(), 1, 10)\n}"
        },
        {
          "name": "inputs_with_an_authentic_script_input_fuzzer",
          "signature": "pub fn inputs_with_an_authentic_script_input_fuzzer(pub fn inputs_with_an_authentic_script_input_fuzzer(datum: Datum, ) -> Fuzzer<(ByteArray, Input, List<Input>)> {",
          "documentation": "Fuzzer for a sorted list of user/wallet inputs, with the addition of one\nauthentic script input.",
          "parameters": [],
          "returnType": "Fuzzer<(ByteArray, Input, List<Input>)>",
          "line": 267,
          "raw": "pub fn inputs_with_an_authentic_script_input_fuzzer(pub fn inputs_with_an_authentic_script_input_fuzzer(datum: Datum, ) -> Fuzzer<(ByteArray, Input, List<Input>)> {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn inputs_with_an_authentic_script_input_fuzzer(\n  datum: Datum,\n) -> Fuzzer<(ByteArray, Input, List<Input>)> {\n  let wallet_inputs <- and_then(user_inputs_fuzzer())\n  let (spend_script_hash, script_input) <-\n    and_then(authentic_script_input_fuzzer(datum))\n  fuzz.constant(\n    (\n      spend_script_hash,\n      script_input,\n      [script_input, ..wallet_inputs] |> sort_inputs,\n    ),\n  )\n}"
        }
      ],
      "types": [],
      "constants": [],
      "atoms": [],
      "privateTypes": [],
      "privateConstants": [],
      "content": "//// @hidden\n\nuse aiken/builtin\nuse aiken/collection/list.{foldl}\nuse aiken/crypto.{ScriptHash}\nuse aiken/fuzz.{and_then}\nuse cardano/address.{Address, Inline, Script, VerificationKey}\nuse cardano/assets.{AssetName, PolicyId, Value}\nuse cardano/transaction.{Datum, Input, NoDatum, Output, OutputReference}\nuse cardano/transaction/output_reference as output_reference\n\npub fn sort_inputs(inputs: List<Input>) -> List<Input> {\n  inputs\n    |> list.sort(\n        fn(i0: Input, i1: Input) {\n          output_reference.compare(i0.output_reference, i1.output_reference)\n        },\n      )\n}\n\n/// Copied from [Fortuna](https://github.com/cardano-miners/fortuna/blob/5eeb1bc31b72252b991bbcaf836b128dca6a74b9/lib/fortuna/utils.ak#L6-L17).\npub fn resolve_output_reference(\n  inputs: List<Input>,\n  output_ref: OutputReference,\n) -> Output {\n  expect [input, ..] = inputs\n\n  if input.output_reference == output_ref {\n    input.output\n  } else {\n    resolve_output_reference(builtin.tail_list(inputs), output_ref)\n  }\n}\n\npub fn authentic_input_is_reproduced_unchanged(\n  auth_symbol: PolicyId,\n  optional_auth_name: Option<AssetName>,\n  in_utxo: Output,\n  out_utxo: Output,\n) -> Bool {\n  expect Output {\n    value: in_val,\n    datum: in_dat,\n    address: in_addr,\n    reference_script: None,\n  } = in_utxo\n  expect Output {\n    value: out_val,\n    datum: out_dat,\n    address: out_addr,\n    reference_script: None,\n  } = out_utxo\n\n  expect [_, (in_sym, in_name, in_quantity)] = in_val |> assets.flatten\n\n  let name_is_authentic =\n    when optional_auth_name is {\n      Some(auth_name) -> in_name == auth_name\n      None -> True\n    }\n  and {\n    in_val == out_val,\n    in_dat == out_dat,\n    in_addr.payment_credential == out_addr.payment_credential,\n    in_sym == auth_symbol,\n    name_is_authentic,\n    in_quantity == 1,\n  }\n}\n\npub fn sum_of_squares(xs: List<Int>) -> Int {\n  xs |> foldl(0, fn(x, acc) { acc + x * x })\n}\n\n/// Given a list of inputs, this function returns the index of the first inputs\n/// which its address has a `Script` payment part.\npub fn find_index_of_first_script_input(inputs: List<Input>) -> Int {\n  expect Some(input_index) =\n    list.indexed_foldr(\n      inputs,\n      None,\n      fn(i, input, m_i) {\n        when m_i is {\n          Some(_) -> m_i\n          None ->\n            when input.output.address.payment_credential is {\n              Script(_) -> Some(i)\n              _ -> None\n            }\n        }\n      },\n    )\n  input_index\n}\n\n/// A fuzzer for `Value` with a single asset. Unsafely expects 28 bytes long\n/// policy ID to be provided.\npub fn single_specific_asset_value_fuzzer(policyId: ByteArray) -> Fuzzer<Value> {\n  let token_name <- and_then(fuzz.bytearray_between(0, 32))\n  let quantity <- and_then(fuzz.int_at_least(1))\n  fuzz.constant(assets.from_asset(policyId, token_name, quantity))\n}\n\n/// A `Value` fuzzer with a single asset. Randomly generates the policy ID.\npub fn single_asset_value_fuzzer() -> Fuzzer<Value> {\n  let policyId <- and_then(fuzz.bytearray_fixed(28))\n  single_specific_asset_value_fuzzer(policyId)\n}\n\n/// A `Value` fuzzer without any lovelaces.\npub fn mint_fuzzer() -> Fuzzer<Value> {\n  let other_assets_values <-\n    and_then(fuzz.list_between(single_asset_value_fuzzer(), 1, 10))\n  fuzz.constant(\n    list.foldl(\n      other_assets_values,\n      assets.zero,\n      fn(v, acc) { assets.merge(v, acc) },\n    ),\n  )\n}\n\n/// A `Value` fuzzer, guaranteed to include some amount of ADA (minimum must be\n/// specified).\npub fn value_fuzzer(min_lovelaces: Int) -> Fuzzer<Value> {\n  let lovelace_count <- and_then(fuzz.int_at_least(min_lovelaces))\n  let lovelace_value = assets.from_lovelace(lovelace_count)\n  let other_assets_values <-\n    and_then(fuzz.list_at_most(single_asset_value_fuzzer(), 10))\n  fuzz.constant(\n    list.foldl(\n      other_assets_values,\n      lovelace_value,\n      fn(v, acc) { assets.merge(v, acc) },\n    ),\n  )\n}\n\n/// Output reference fuzzer, transaction ID with 32 bytes, and output index\n/// between 0 and 512.\npub fn output_reference_fuzzer() -> Fuzzer<OutputReference> {\n  let ref_bytes <- and_then(fuzz.bytearray_fixed(32))\n  let output_index <- and_then(fuzz.int_between(0, 512))\n  fuzz.constant(OutputReference { transaction_id: ref_bytes, output_index })\n}\n\n/// Simple wallet UTxO fuzzer, with a random number of tokens/NFTs.\npub fn user_output_fuzzer() -> Fuzzer<Output> {\n  let pkh <- and_then(fuzz.bytearray_fixed(28))\n  let skh <- and_then(fuzz.bytearray_fixed(28))\n  let v <- and_then(value_fuzzer(2_000_000))\n  fuzz.constant(\n    Output {\n      address: Address {\n        payment_credential: VerificationKey(pkh),\n        stake_credential: Some(Inline(VerificationKey(skh))),\n      },\n      value: v,\n      datum: NoDatum,\n      reference_script: None,\n    },\n  )\n}\n\n/// Simple wallet UTxO fuzzer, with a random reference output and a random\n/// number of tokens/NFTs.\npub fn user_input_fuzzer() -> Fuzzer<Input> {\n  let output_reference <- and_then(output_reference_fuzzer())\n  let output <- and_then(user_output_fuzzer())\n  fuzz.constant(Input { output_reference, output })\n}\n\n/// Given a script hash and datum, this fuzzer generates a UTxO at an address\n/// which its payment part is the same as the given script hash.\npub fn specific_script_output_fuzzer(\n  script_hash: ScriptHash,\n  datum: Datum,\n) -> Fuzzer<Output> {\n  let v <- and_then(value_fuzzer(2_000_000))\n  fuzz.constant(\n    Output {\n      address: Address {\n        payment_credential: Script(script_hash),\n        stake_credential: None,\n      },\n      value: v,\n      datum,\n      reference_script: None,\n    },\n  )\n}\n\n/// Returns a tuple where its first element is the random script hash (payment\n/// part of the UTxO's address). UTxO value is also random, with 2 ADA.\npub fn script_output_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Output)> {\n  let script_hash <- and_then(fuzz.bytearray_fixed(28))\n  let utxo <- and_then(specific_script_output_fuzzer(script_hash, datum))\n  fuzz.constant((script_hash, utxo))\n}\n\n/// UTxO fuzzer, where the value is composed of 2 ADA and a beacon NFT, such\n/// that its policy ID is equal to the script credential of the payment part of\n/// UTxO's address. This script hash is also returned.\npub fn authentic_script_output_fuzzer(\n  datum: Datum,\n) -> Fuzzer<(ByteArray, Output)> {\n  let script_hash <- and_then(fuzz.bytearray_fixed(28))\n  let tn <- and_then(fuzz.bytearray_between(0, 32))\n  let lovelace_value = assets.from_lovelace(2_000_000)\n  let beacon = assets.from_asset(script_hash, tn, 1)\n  let v = assets.merge(lovelace_value, beacon)\n  fuzz.constant(\n    (\n      script_hash,\n      Output {\n        address: Address {\n          payment_credential: Script(script_hash),\n          stake_credential: None,\n        },\n        value: v,\n        datum,\n        reference_script: None,\n      },\n    ),\n  )\n}\n\n/// Similar to [`specific_script_output_fuzzer`](#specific_script_output_fuzzer),\n/// with an additional randomized wrapper for output reference.\npub fn specific_script_input_fuzzer(\n  script_hash: ScriptHash,\n  datum: Datum,\n) -> Fuzzer<Input> {\n  let output_reference <- and_then(output_reference_fuzzer())\n  let output <- and_then(specific_script_output_fuzzer(script_hash, datum))\n  fuzz.constant(Input { output_reference, output })\n}\n\n/// Similar to [`script_output_fuzzer`](#script_output_fuzzer), with an\n/// additional randomized wrapper for output reference.\npub fn script_input_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Input)> {\n  let output_reference <- and_then(output_reference_fuzzer())\n  let (script_hash, output) <- and_then(script_output_fuzzer(datum))\n  fuzz.constant((script_hash, Input { output_reference, output }))\n}\n\n/// Similar to [`authentic_script_output_fuzzer`](#script_output_fuzzer), with\n/// and additional randomized wrapper for output reference.\npub fn authentic_script_input_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Input)> {\n  let output_reference <- and_then(output_reference_fuzzer())\n  let (script_hash, output) <- and_then(authentic_script_output_fuzzer(datum))\n  fuzz.constant((script_hash, Input { output_reference, output }))\n}\n\n/// Simple (non-script) outputs fuzzer.\npub fn user_outputs_fuzzer() -> Fuzzer<List<Output>> {\n  fuzz.list_between(user_output_fuzzer(), 1, 10)\n}\n\n/// Simple (non-script) inputs fuzzer.\npub fn user_inputs_fuzzer() -> Fuzzer<List<Input>> {\n  fuzz.list_between(user_input_fuzzer(), 1, 10)\n}\n\n/// Fuzzer for a sorted list of user/wallet inputs, with the addition of one\n/// authentic script input.\npub fn inputs_with_an_authentic_script_input_fuzzer(\n  datum: Datum,\n) -> Fuzzer<(ByteArray, Input, List<Input>)> {\n  let wallet_inputs <- and_then(user_inputs_fuzzer())\n  let (spend_script_hash, script_input) <-\n    and_then(authentic_script_input_fuzzer(datum))\n  fuzz.constant(\n    (\n      spend_script_hash,\n      script_input,\n      [script_input, ..wallet_inputs] |> sort_inputs,\n    ),\n  )\n}\n",
      "dependencies": [
        "aiken/builtin",
        "aiken/collection/list",
        "aiken/crypto",
        "aiken/fuzz",
        "cardano/address",
        "cardano/assets",
        "cardano/transaction",
        "cardano/transaction/output_reference"
      ],
      "source": "anastasia",
      "isReExportFile": false
    },
    {
      "key": "anastasia:aiken-design-patterns.validity-range-normalization",
      "path": "/Users/g/code/don-docs/dons-docs/packages/aiken-design-patterns/lib/aiken-design-patterns/validity-range-normalization.ak",
      "name": "aiken-design-patterns.validity-range-normalization",
      "imports": [
        {
          "module": "aiken/interval",
          "items": ["Interval", "IntervalBound"],
          "line": 11,
          "raw": "use aiken/interval.{Interval, IntervalBound}",
          "source": "anastasia"
        },
        {
          "module": "cardano/transaction",
          "items": ["ValidityRange"],
          "line": 12,
          "raw": "use cardano/transaction.{ValidityRange}",
          "source": "anastasia"
        }
      ],
      "functions": [
        {
          "name": "normalize_time_range",
          "signature": "pub fn normalize_time_range(pub fn normalize_time_range(validity_range: ValidityRange, ) -> NormalizedTimeRange {",
          "documentation": "Validates the given time range, and returns a normalized version.",
          "parameters": [],
          "returnType": "NormalizedTimeRange",
          "line": 24,
          "raw": "pub fn normalize_time_range(pub fn normalize_time_range(validity_range: ValidityRange, ) -> NormalizedTimeRange {",
          "isPublic": true,
          "source": "anastasia",
          "implementation": "pub fn normalize_time_range(\n  validity_range: ValidityRange,\n) -> NormalizedTimeRange {\n  let Interval {\n    lower_bound: IntervalBound {\n      bound_type: lower_bound_type,\n      is_inclusive: lower_is_inclusive,\n    },\n    upper_bound: IntervalBound {\n      bound_type: upper_bound_type,\n      is_inclusive: upper_is_inclusive,\n    },\n  } = validity_range\n  when (lower_bound_type, upper_bound_type) is {\n    (interval.NegativeInfinity, interval.PositiveInfinity) -> Always\n    (interval.NegativeInfinity, interval.Finite(upper_int)) ->\n      FromNegInf { upper: resolve_upper(upper_int, upper_is_inclusive) }\n    (interval.Finite(init_lower_int), interval.Finite(init_upper_int)) ->\n      ClosedRange {\n        lower: resolve_lower(init_lower_int, lower_is_inclusive),\n        upper: resolve_upper(init_upper_int, upper_is_inclusive),\n      }\n    (interval.Finite(init_lower_int), interval.PositiveInfinity) ->\n      ToPosInf { lower: resolve_lower(init_lower_int, lower_is_inclusive) }\n    _ -> fail @\"Improper validity range encountered\"\n  }\n}"
        }
      ],
      "types": [
        {
          "name": "NormalizedTimeRange",
          "definition": "{ ClosedRange { lower: Int, upper: Int } FromNegInf { upper: Int } ToPosInf { lower: Int } Always }",
          "line": 16,
          "raw": "pub type NormalizedTimeRange {",
          "isPublic": true,
          "source": "anastasia"
        }
      ],
      "constants": [],
      "atoms": [
        {
          "name": "resolve_lower",
          "signature": "fn resolve_lower(init_lower: Int, is_inclusive: Bool) -> Int {",
          "parameters": [
            {
              "name": "init_lower",
              "type": "Int",
              "optional": false
            },
            {
              "name": "is_inclusive",
              "type": "Bool",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 52,
          "raw": "fn resolve_lower(init_lower: Int, is_inclusive: Bool) -> Int {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn resolve_lower(init_lower: Int, is_inclusive: Bool) -> Int {\n  if is_inclusive {\n    init_lower\n  } else {\n    init_lower + 1\n  }\n}"
        },
        {
          "name": "resolve_upper",
          "signature": "fn resolve_upper(init_upper: Int, is_inclusive: Bool) -> Int {",
          "parameters": [
            {
              "name": "init_upper",
              "type": "Int",
              "optional": false
            },
            {
              "name": "is_inclusive",
              "type": "Bool",
              "optional": false
            }
          ],
          "returnType": "Int",
          "line": 60,
          "raw": "fn resolve_upper(init_upper: Int, is_inclusive: Bool) -> Int {",
          "isPublic": false,
          "source": "anastasia",
          "implementation": "fn resolve_upper(init_upper: Int, is_inclusive: Bool) -> Int {\n  if is_inclusive {\n    init_upper\n  } else {\n    init_upper - 1\n  }\n}"
        }
      ],
      "privateTypes": [],
      "privateConstants": [],
      "content": "//// The datatype that models validity range in Cardano currently allows for\n//// values that are either meaningless, or can have more than one\n//// representations. For example, since the values are integers, the inclusive\n//// flag for each end is redundant and can be omitted in favor of a predefined\n//// convention (e.g. a value should always be considered inclusive).\n//// \n//// In this module we present a custom datatype that essentially reduces the\n//// value domain of the original validity range to a smaller one that\n//// eliminates meaningless instances and redundancies.\n\nuse aiken/interval.{Interval, IntervalBound}\nuse cardano/transaction.{ValidityRange}\n\n/// Datatype for eliminating meaningless ranges, without the redundant\n/// inclusiveness flag (instead all range values are inclusive).\npub type NormalizedTimeRange {\n  ClosedRange { lower: Int, upper: Int }\n  FromNegInf { upper: Int }\n  ToPosInf { lower: Int }\n  Always\n}\n\n/// Validates the given time range, and returns a normalized version.\npub fn normalize_time_range(\n  validity_range: ValidityRange,\n) -> NormalizedTimeRange {\n  let Interval {\n    lower_bound: IntervalBound {\n      bound_type: lower_bound_type,\n      is_inclusive: lower_is_inclusive,\n    },\n    upper_bound: IntervalBound {\n      bound_type: upper_bound_type,\n      is_inclusive: upper_is_inclusive,\n    },\n  } = validity_range\n  when (lower_bound_type, upper_bound_type) is {\n    (interval.NegativeInfinity, interval.PositiveInfinity) -> Always\n    (interval.NegativeInfinity, interval.Finite(upper_int)) ->\n      FromNegInf { upper: resolve_upper(upper_int, upper_is_inclusive) }\n    (interval.Finite(init_lower_int), interval.Finite(init_upper_int)) ->\n      ClosedRange {\n        lower: resolve_lower(init_lower_int, lower_is_inclusive),\n        upper: resolve_upper(init_upper_int, upper_is_inclusive),\n      }\n    (interval.Finite(init_lower_int), interval.PositiveInfinity) ->\n      ToPosInf { lower: resolve_lower(init_lower_int, lower_is_inclusive) }\n    _ -> fail @\"Improper validity range encountered\"\n  }\n}\n\nfn resolve_lower(init_lower: Int, is_inclusive: Bool) -> Int {\n  if is_inclusive {\n    init_lower\n  } else {\n    init_lower + 1\n  }\n}\n\nfn resolve_upper(init_upper: Int, is_inclusive: Bool) -> Int {\n  if is_inclusive {\n    init_upper\n  } else {\n    init_upper - 1\n  }\n}\n",
      "dependencies": ["aiken/interval", "cardano/transaction"],
      "source": "anastasia",
      "isReExportFile": false
    }
  ],
  "functions": [
    {
      "key": "stdlib:aiken.cbor.diagnostic",
      "fullName": "stdlib:aiken.cbor.diagnostic",
      "name": "diagnostic",
      "signature": "pub fn diagnostic(self: Data) -> String {",
      "documentation": "Obtain a String representation of _anything_. This is particularly (and only) useful for tracing\nand debugging. This function is expensive and should not be used in any production code as it\nwill very likely explodes the validator's budget.\n\nThe output is a [CBOR diagnostic](https://www.rfc-editor.org/rfc/rfc8949#name-diagnostic-notation)\nof the underlying on-chain binary representation of the data. It's not as\neasy to read as plain Aiken code, but it is handy for troubleshooting values\n_at runtime_. Incidentally, getting familiar with reading CBOR diagnostic is\na good idea in the Cardano world.\n\n```aiken\ncbor.diagnostic(42) == \"42\"\ncbor.diagnostic(#\"a1b2\") == \"h'A1B2'\"\ncbor.diagnostic([1, 2, 3]) == \"[_ 1, 2, 3]\"\ncbor.diagnostic([]) == \"[]\"\ncbor.diagnostic((1, 2)) == \"[_ 1, 2]\"\ncbor.diagnostic((1, #\"ff\", 3)) == \"[_ 1, h'FF', 3]\"\ncbor.diagnostic([(1, #\"ff\")]) == \"{_ 1: h'FF' }\"\ncbor.diagnostic(Some(42)) == \"121([_ 42])\"\ncbor.diagnostic(None) == \"122([])\"\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "String",
      "line": 26,
      "raw": "pub fn diagnostic(self: Data) -> String {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn diagnostic(self: Data) -> String {\n  aiken.diagnostic(self, #\"\")\n    |> decode_utf8\n}"
    },
    {
      "key": "stdlib:aiken.cbor.deserialise",
      "fullName": "stdlib:aiken.cbor.deserialise",
      "name": "deserialise",
      "signature": "pub fn deserialise(bytes: ByteArray) -> Option<Data> {",
      "documentation": "Deserialise a [CBOR](https://www.rfc-editor.org/rfc/rfc8949) Data. This is the reverse operation of [serialise](#serialise).\nIn particular, we have the following property:\n\n```aiken\ncbor.deserialise(cbor.serialise(any_data)) == Some(any_data)\n```\n\n> [!CAUTION]\n> Unfortunately, this function isn't derived from a builtin primitive. It\n> is therefore an order of magnitude more expensive than its counterpart\n> and shall be used with care.\n>\n> In general, one might prefer avoiding deserialisation unless truly necessary.\n> Yet, it may come in handy for testing and in rare scenarios.",
      "parameters": [
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Option<Data>",
      "line": 45,
      "raw": "pub fn deserialise(bytes: ByteArray) -> Option<Data> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn deserialise(bytes: ByteArray) -> Option<Data> {\n  let length = bytearray.length(bytes)\n\n  let peek =\n    fn(offset: Int, callback: fn(Byte) -> Decoder<Data>) -> Decoder<Data> {\n      fn(cursor) {\n        if 0 >= cursor {\n          deserialise_failure\n        } else {\n          callback(bytearray.at(bytes, length - cursor))(cursor - offset)\n        }\n      }\n    }\n\n  let take =\n    fn(n: Int, callback: fn(ByteArray) -> Decoder<Data>) -> Decoder<Data> {\n      fn(cursor) {\n        if 0 >= cursor {\n          deserialise_failure\n        } else {\n          callback(builtin.slice_bytearray(length - cursor, n, bytes))(\n            cursor - n,\n          )\n        }\n      }\n    }\n\n  if length == 0 {\n    None\n  } else {\n    let Pair(result, consumed) = decode_data(peek, take)(length)\n    if consumed != 0 {\n      None\n    } else {\n      Some(result)\n    }\n  }\n}"
    },
    {
      "key": "stdlib:aiken.cbor.serialise",
      "fullName": "stdlib:aiken.cbor.serialise",
      "name": "serialise",
      "signature": "pub fn serialise(self: Data) -> ByteArray {",
      "documentation": "Serialise any value to binary, encoding using [CBOR](https://www.rfc-editor.org/rfc/rfc8949).\n\nThis is particularly useful in combination with hashing functions, as a way\nto obtain a byte representation that matches the serialised representation\nused by the ledger in the context of on-chain code.\n\nNote that the output matches the output of [`diagnostic`](#diagnostic),\nthough with a different encoding. [`diagnostic`](#diagnostic) is merely a\ntextual representation of the CBOR encoding that is human friendly and\nuseful for debugging.\n\n```aiken\ncbor.serialise(42) == #\"182a\"\ncbor.serialise(#\"a1b2\") == #\"42a1b2\"\ncbor.serialise([]) == #\"80\"\ncbor.serialise((1, 2)) == #\"9f0102ff\"\ncbor.serialise((1, #\"ff\", 3)) == #\"9f0141ff03ff\"\ncbor.serialise([(1, #\"ff\")]) == #\"a10141ff\"\ncbor.serialise(Some(42)) == #\"d8799f182aff\"\ncbor.serialise(None) == #\"d87a80\"\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 105,
      "raw": "pub fn serialise(self: Data) -> ByteArray {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn serialise(self: Data) -> ByteArray {\n  serialise_data(self)\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.strategy.expect_no_duplicate",
      "fullName": "stdlib:aiken.collection.dict.strategy.expect_no_duplicate",
      "name": "expect_no_duplicate",
      "signature": "pub fn expect_no_duplicate() -> UnionStrategy<key, value> {",
      "documentation": "A strategy which always fail, enforcing the dict contains no duplicate.\n\n```aiken\nfn(_, _, _, _, _) {\nfail @\"unexpected duplicate key found in dict.\"\n}\n```",
      "parameters": [],
      "returnType": "UnionStrategy<key, value>",
      "line": 23,
      "raw": "pub fn expect_no_duplicate() -> UnionStrategy<key, value> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn expect_no_duplicate() -> UnionStrategy<key, value> {\n  fn(_, _, _, _, _) {\n    fail @\"unexpected duplicate key found in dict.\"\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.strategy.keep_left",
      "fullName": "stdlib:aiken.collection.dict.strategy.keep_left",
      "name": "keep_left",
      "signature": "pub fn keep_left() -> UnionStrategy<key, value> {",
      "documentation": "Combine values by keeping the values present in the left-most dict.\n\n```aiken\nfn(_key, left, _right, keep, _discard) { keep(left) }\n```",
      "parameters": [],
      "returnType": "UnionStrategy<key, value>",
      "line": 34,
      "raw": "pub fn keep_left() -> UnionStrategy<key, value> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn keep_left() -> UnionStrategy<key, value> {\n  fn(_key, left, _right, keep, _discard) { keep(left) }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.strategy.keep_right",
      "fullName": "stdlib:aiken.collection.dict.strategy.keep_right",
      "name": "keep_right",
      "signature": "pub fn keep_right() -> UnionStrategy<key, value> {",
      "documentation": "Combine values by keeping the values present in the right-most dict.\n\n```aiken\nfn(_key, _left, right, keep, _discard) { keep(right) }\n```",
      "parameters": [],
      "returnType": "UnionStrategy<key, value>",
      "line": 43,
      "raw": "pub fn keep_right() -> UnionStrategy<key, value> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn keep_right() -> UnionStrategy<key, value> {\n  fn(_key, _left, right, keep, _discard) { keep(right) }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.strategy.sum",
      "fullName": "stdlib:aiken.collection.dict.strategy.sum",
      "name": "sum",
      "signature": "pub fn sum() -> UnionStrategy<key, Int> {",
      "documentation": "Combine values by taking their sum.\n\n```aiken\nfn(_key, left, right, keep, _discard) { keep(left + right) }\n```",
      "parameters": [],
      "returnType": "UnionStrategy<key, Int>",
      "line": 52,
      "raw": "pub fn sum() -> UnionStrategy<key, Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sum() -> UnionStrategy<key, Int> {\n  fn(_key, left, right, keep, _discard) { keep(left + right) }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.strategy.sum_if_non_zero",
      "fullName": "stdlib:aiken.collection.dict.strategy.sum_if_non_zero",
      "name": "sum_if_non_zero",
      "signature": "pub fn sum_if_non_zero() -> UnionStrategy<key, Int> {",
      "documentation": "Combine values by taking their sum, only if it is non-null. If the\nresulting sum is 0, discard the key/value entirely.\n\n```aiken\nfn(_key, left, right, keep, discard) {\nlet value = left + right\nif value == 0 {\ndiscard()\n} else {\nkeep(value)\n}\n}\n```",
      "parameters": [],
      "returnType": "UnionStrategy<key, Int>",
      "line": 69,
      "raw": "pub fn sum_if_non_zero() -> UnionStrategy<key, Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sum_if_non_zero() -> UnionStrategy<key, Int> {\n  fn(_key, left, right, keep, discard) {\n    let value = left + right\n    if value == 0 {\n      discard()\n    } else {\n      keep(value)\n    }\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.from_ascending_pairs",
      "fullName": "stdlib:aiken.collection.dict.from_ascending_pairs",
      "name": "from_ascending_pairs",
      "signature": "pub fn from_ascending_pairs(xs: Pairs<ByteArray, value>) -> Dict<key, value> {",
      "documentation": "Like ['from_pairs'](#from_pairs), but from an already sorted list by ascending\nkeys. This function fails (i.e. halts the program execution) if the list isn't\nsorted.\n\n```aiken\nlet pairs = [Pair(\"a\", 100), Pair(\"b\", 200), Pair(\"c\", 300)]\n\nlet result =\ndict.from_ascending_pairs(pairs)\n|> dict.to_pairs()\n\nresult == [Pair(\"a\", 100), Pair(\"b\", 200), Pair(\"c\", 300)]\n```\n\nThis is meant to be used to turn a list constructed off-chain into a `Dict`\nwhich has taken care of maintaining interval invariants. This function still\nperforms a sanity check on all keys to avoid silly mistakes. It is, however,\nconsiderably faster than ['from_pairs'](from_pairs)",
      "parameters": [
        {
          "name": "xs",
          "type": "Pairs<ByteArray, value>",
          "optional": false
        }
      ],
      "returnType": "Dict<key, value>",
      "line": 72,
      "raw": "pub fn from_ascending_pairs(xs: Pairs<ByteArray, value>) -> Dict<key, value> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_ascending_pairs(xs: Pairs<ByteArray, value>) -> Dict<key, value> {\n  let Void = check_ascending_list(xs)\n  Dict { inner: xs }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.from_ascending_pairs_with",
      "fullName": "stdlib:aiken.collection.dict.from_ascending_pairs_with",
      "name": "from_ascending_pairs_with",
      "signature": "pub fn from_ascending_pairs_with(pub fn from_ascending_pairs_with(xs: Pairs<ByteArray, value>, predicate: fn(value) -> Bool,",
      "documentation": "Like [`from_ascending_pairs`](#from_ascending_pairs) but fails if **any**\nvalue doesn't satisfy the predicate.\n\n```aiken\nlet pairs = [Pair(\"a\", 100), Pair(\"b\", 200), Pair(\"c\", 300)]\n\ndict.from_ascending_pairs_with(pairs, fn(x) { x <= 250 }) // fail\n```",
      "parameters": [],
      "returnType": "Bool,",
      "line": 98,
      "raw": "pub fn from_ascending_pairs_with(pub fn from_ascending_pairs_with(xs: Pairs<ByteArray, value>, predicate: fn(value) -> Bool,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_ascending_pairs_with(\n  xs: Pairs<ByteArray, value>,\n  predicate: fn(value) -> Bool,\n) -> Dict<key, value> {\n  let Void = check_ascending_pairs_with(xs, predicate)\n  Dict { inner: xs }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.from_pairs",
      "fullName": "stdlib:aiken.collection.dict.from_pairs",
      "name": "from_pairs",
      "signature": "pub fn from_pairs(self: Pairs<ByteArray, value>) -> Dict<key, value> {",
      "documentation": "Construct a dictionary from a list of key-value pairs. Note that when a key is present\nmultiple times, the first occurrence prevails.\n\n```aiken\nlet pairs = [Pair(\"a\", 100), Pair(\"c\", 300), Pair(\"b\", 200)]\n\nlet result =\ndict.from_pairs(pairs)\n|> dict.to_pairs()\n\nresult == [Pair(\"a\", 100), Pair(\"b\", 200), Pair(\"c\", 300)]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Pairs<ByteArray, value>",
          "optional": false
        }
      ],
      "returnType": "Dict<key, value>",
      "line": 157,
      "raw": "pub fn from_pairs(self: Pairs<ByteArray, value>) -> Dict<key, value> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_pairs(self: Pairs<ByteArray, value>) -> Dict<key, value> {\n  Dict { inner: do_from_pairs(self) }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.find",
      "fullName": "stdlib:aiken.collection.dict.find",
      "name": "find",
      "signature": "pub fn find(self: Dict<key, value>, value v: value) -> Option<ByteArray> {",
      "documentation": "Finds a value in the dictionary, and returns the first key found to have that value.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(key: \"a\", value: 42)\n|> dict.insert(key: \"b\", value: 14)\n|> dict.insert(key: \"c\", value: 42)\n|> dict.find(42)\n\nresult == Some(\"a\")\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Dict<key, value>",
          "optional": false
        }
      ],
      "returnType": "Option<ByteArray>",
      "line": 215,
      "raw": "pub fn find(self: Dict<key, value>, value v: value) -> Option<ByteArray> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn find(self: Dict<key, value>, value v: value) -> Option<ByteArray> {\n  do_find(self.inner, v)\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.get",
      "fullName": "stdlib:aiken.collection.dict.get",
      "name": "get",
      "signature": "pub fn get(self: Dict<key, value>, key: ByteArray) -> Option<value> {",
      "documentation": "Get a value in the dict by its key.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(key: \"a\", value: \"Aiken\")\n|> dict.get(key: \"a\")\n\nresult == Some(\"Aiken\")\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Dict<key, value>",
          "optional": false
        },
        {
          "name": "key",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Option<value>",
      "line": 271,
      "raw": "pub fn get(self: Dict<key, value>, key: ByteArray) -> Option<value> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn get(self: Dict<key, value>, key: ByteArray) -> Option<value> {\n  do_get(self.inner, key)\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.has_key",
      "fullName": "stdlib:aiken.collection.dict.has_key",
      "name": "has_key",
      "signature": "pub fn has_key(self: Dict<key, value>, key k: ByteArray) -> Bool {",
      "documentation": "Check if a key exists in the dictionary.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(key: \"a\", value: \"Aiken\")\n|> dict.has_key(\"a\")\n\nresult == True\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Dict<key, value>",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 355,
      "raw": "pub fn has_key(self: Dict<key, value>, key k: ByteArray) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn has_key(self: Dict<key, value>, key k: ByteArray) -> Bool {\n  do_has_key(self.inner, k)\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.is_empty",
      "fullName": "stdlib:aiken.collection.dict.is_empty",
      "name": "is_empty",
      "signature": "pub fn is_empty(self: Dict<key, value>) -> Bool {",
      "documentation": "Efficiently checks whether a dictionary is empty.\n```aiken\ndict.is_empty(dict.empty) == True\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Dict<key, value>",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 404,
      "raw": "pub fn is_empty(self: Dict<key, value>) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn is_empty(self: Dict<key, value>) -> Bool {\n  when self.inner is {\n    [] -> True\n    _ -> False\n  }\n}",
      "tests": ["test is_empty_1() {\n  is_empty(empty)\n}"]
    },
    {
      "key": "stdlib:aiken.collection.dict.keys",
      "fullName": "stdlib:aiken.collection.dict.keys",
      "name": "keys",
      "signature": "pub fn keys(self: Dict<key, value>) -> List<ByteArray> {",
      "documentation": "Extract all the keys present in a given `Dict`.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(\"a\", 14)\n|> dict.insert(\"b\", 42)\n|> dict.insert(\"a\", 1337)\n|> dict.keys()\n\nresult == [\"a\", \"b\"]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Dict<key, value>",
          "optional": false
        }
      ],
      "returnType": "List<ByteArray>",
      "line": 427,
      "raw": "pub fn keys(self: Dict<key, value>) -> List<ByteArray> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn keys(self: Dict<key, value>) -> List<ByteArray> {\n  do_keys(self.inner)\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.size",
      "fullName": "stdlib:aiken.collection.dict.size",
      "name": "size",
      "signature": "pub fn size(self: Dict<key, value>) -> Int {",
      "documentation": "Return the number of key-value pairs in the dictionary.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(\"a\", 100)\n|> dict.insert(\"b\", 200)\n|> dict.insert(\"c\", 300)\n|> dict.size()\n\nresult == 3\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Dict<key, value>",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 462,
      "raw": "pub fn size(self: Dict<key, value>) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn size(self: Dict<key, value>) -> Int {\n  do_size(self.inner)\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.values",
      "fullName": "stdlib:aiken.collection.dict.values",
      "name": "values",
      "signature": "pub fn values(self: Dict<key, value>) -> List<value> {",
      "documentation": "Extract all the values present in a given `Dict`.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(\"a\", 14)\n|> dict.insert(\"b\", 42)\n|> dict.insert(\"c\", 1337)\n|> dict.values()\n\nresult == [14, 42, 1337]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Dict<key, value>",
          "optional": false
        }
      ],
      "returnType": "List<value>",
      "line": 504,
      "raw": "pub fn values(self: Dict<key, value>) -> List<value> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn values(self: Dict<key, value>) -> List<value> {\n  do_values(self.inner)\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.delete",
      "fullName": "stdlib:aiken.collection.dict.delete",
      "name": "delete",
      "signature": "pub fn delete(self: Dict<key, value>, key: ByteArray) -> Dict<key, value> {",
      "documentation": "Remove a key-value pair from the dictionary. If the key is not found, no changes are made.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(key: \"a\", value: 100)\n|> dict.insert(key: \"b\", value: 200)\n|> dict.delete(key: \"a\")\n|> dict.to_pairs()\n\nresult == [Pair(\"b\", 200)]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Dict<key, value>",
          "optional": false
        },
        {
          "name": "key",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Dict<key, value>",
      "line": 541,
      "raw": "pub fn delete(self: Dict<key, value>, key: ByteArray) -> Dict<key, value> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn delete(self: Dict<key, value>, key: ByteArray) -> Dict<key, value> {\n  Dict { inner: do_delete(self.inner, key) }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.filter",
      "fullName": "stdlib:aiken.collection.dict.filter",
      "name": "filter",
      "signature": "pub fn filter(pub fn filter(self: Dict<key, value>, with: fn(ByteArray, value) -> Bool,",
      "documentation": "Keep only the key-value pairs that pass the given predicate.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(key: \"a\", value: 100)\n|> dict.insert(key: \"b\", value: 200)\n|> dict.insert(key: \"c\", value: 300)\n|> dict.filter(fn(k, _v) { k != \"a\" })\n|> dict.to_pairs()\n\nresult == [Pair(\"b\", 200), Pair(\"c\", 300)]\n```",
      "parameters": [],
      "returnType": "Bool,",
      "line": 628,
      "raw": "pub fn filter(pub fn filter(self: Dict<key, value>, with: fn(ByteArray, value) -> Bool,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn filter(\n  self: Dict<key, value>,\n  with: fn(ByteArray, value) -> Bool,\n) -> Dict<key, value> {\n  Dict { inner: do_filter(self.inner, with) }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.insert",
      "fullName": "stdlib:aiken.collection.dict.insert",
      "name": "insert",
      "signature": "pub fn insert(pub fn insert(self: Dict<key, value>, key k: ByteArray, value v: value, ) -> Dict<key, value> {",
      "documentation": "Insert a value in the dictionary at a given key. If the key already exists, its value is **overridden**. If you need ways to combine keys together, use (`insert_with`)[#insert_with].\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(key: \"a\", value: 1)\n|> dict.insert(key: \"b\", value: 2)\n|> dict.insert(key: \"a\", value: 3)\n|> dict.to_pairs()\n\nresult == [Pair(\"a\", 3), Pair(\"b\", 2)]\n```",
      "parameters": [],
      "returnType": "Dict<key, value>",
      "line": 680,
      "raw": "pub fn insert(pub fn insert(self: Dict<key, value>, key k: ByteArray, value v: value, ) -> Dict<key, value> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn insert(\n  self: Dict<key, value>,\n  key k: ByteArray,\n  value v: value,\n) -> Dict<key, value> {\n  Dict { inner: do_insert(self.inner, k, v) }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.insert_with",
      "fullName": "stdlib:aiken.collection.dict.insert_with",
      "name": "insert_with",
      "signature": "pub fn insert_with(pub fn insert_with(self: Dict<key, value>, key k: ByteArray, value v: value, with: UnionStrategy<ByteArray, value>, ) -> Dict<key, value> {",
      "documentation": "Insert a value in the dictionary at a given key. When the key already exist, the provided\nmerge function is called. The value existing in the dictionary is passed as the second argument\nto the merge function, and the new value is passed as the third argument.\n\n```aiken\nuse aiken/collection/dict/union\n\nlet result =\ndict.empty\n|> dict.insert_with(key: \"a\", value: 1, with: strategy.sum())\n|> dict.insert_with(key: \"b\", value: 2, with: strategy.sum())\n|> dict.insert_with(key: \"a\", value: 3, with: strategy.sum())\n|> dict.to_pairs()\n\nresult == [Pair(\"a\", 4), Pair(\"b\", 2)]\n```",
      "parameters": [],
      "returnType": "Dict<key, value>",
      "line": 744,
      "raw": "pub fn insert_with(pub fn insert_with(self: Dict<key, value>, key k: ByteArray, value v: value, with: UnionStrategy<ByteArray, value>, ) -> Dict<key, value> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn insert_with(\n  self: Dict<key, value>,\n  key k: ByteArray,\n  value v: value,\n  with: UnionStrategy<ByteArray, value>,\n) -> Dict<key, value> {\n  Dict {\n    inner: do_insert_with(\n      self.inner,\n      k,\n      v,\n      fn(k, v1, v2, some, none) { with(k, v2, v1, some, none) },\n    ),\n  }\n}",
      "tests": [
        "test insert_with_1() {\n  let result =\n    empty\n      |> insert_with(key: \"foo\", value: 1, with: strategy.sum())\n      |> insert_with(key: \"bar\", value: 2, with: strategy.sum())\n      |> to_pairs()\n\n  result == [Pair(\"bar\", 2), Pair(\"foo\", 1)]\n}",
        "test insert_with_2() {\n  let result =\n    empty\n      |> insert_with(key: \"foo\", value: 1, with: strategy.sum())\n      |> insert_with(key: \"bar\", value: 2, with: strategy.sum())\n      |> insert_with(key: \"foo\", value: 3, with: strategy.sum())\n      |> to_pairs()\n\n  result == [Pair(\"bar\", 2), Pair(\"foo\", 4)]\n}",
        "test insert_with_3() {\n  let with =\n    fn(k, a, _b, keep, discard) {\n      if k == \"foo\" {\n        keep(a)\n      } else {\n        discard()\n      }\n    }\n\n  let result =\n    empty\n      |> insert_with(key: \"foo\", value: 1, with: with)\n      |> insert_with(key: \"bar\", value: 2, with: with)\n      |> insert_with(key: \"foo\", value: 3, with: with)\n      |> insert_with(key: \"bar\", value: 4, with: with)\n      |> to_pairs()\n\n  result == [Pair(\"foo\", 1)]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.dict.map",
      "fullName": "stdlib:aiken.collection.dict.map",
      "name": "map",
      "signature": "pub fn map(self: Dict<key, a>, with: fn(ByteArray, a) -> b) -> Dict<key, b> {",
      "documentation": "Apply a function to all key-value pairs in a Dict.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(\"a\", 100)\n|> dict.insert(\"b\", 200)\n|> dict.insert(\"c\", 300)\n|> dict.map(fn(_k, v) { v * 2 })\n|> dict.to_pairs()\n\nresult == [Pair(\"a\", 200), Pair(\"b\", 400), Pair(\"c\", 600)]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Dict<key, a>",
          "optional": false
        },
        {
          "name": "with",
          "type": "fn(ByteArray, a",
          "optional": false
        }
      ],
      "returnType": "b) -> Dict<key, b>",
      "line": 815,
      "raw": "pub fn map(self: Dict<key, a>, with: fn(ByteArray, a) -> b) -> Dict<key, b> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn map(self: Dict<key, a>, with: fn(ByteArray, a) -> b) -> Dict<key, b> {\n  Dict { inner: do_map(self.inner, with) }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.pop",
      "fullName": "stdlib:aiken.collection.dict.pop",
      "name": "pop",
      "signature": "pub fn pop(pub fn pop(self: Dict<key, value>, key: ByteArray, ) -> (Option<value>, Dict<key, value>) {",
      "documentation": "Remove a key-value pair from the dictionary and return its value. If the key is not found, no changes are made.\n\n```aiken\nlet (value, _) =\ndict.empty\n|> dict.insert(key: \"a\", value: 100)\n|> dict.insert(key: \"b\", value: 200)\n|> dict.pop(key: \"a\")\n\nresult == 100\n```",
      "parameters": [],
      "returnType": "(Option<value>, Dict<key, value>)",
      "line": 854,
      "raw": "pub fn pop(pub fn pop(self: Dict<key, value>, key: ByteArray, ) -> (Option<value>, Dict<key, value>) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn pop(\n  self: Dict<key, value>,\n  key: ByteArray,\n) -> (Option<value>, Dict<key, value>) {\n  do_pop(self.inner, key, fn(value, inner) { (value, Dict { inner }) })\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.union",
      "fullName": "stdlib:aiken.collection.dict.union",
      "name": "union",
      "signature": "pub fn union(pub fn union(left: Dict<key, value>, right: Dict<key, value>, ) -> Dict<key, value> {",
      "documentation": "Combine two dictionaries. If the same key exist in both the left and\nright dictionary, values from the left are preferred (i.e. left-biaised).\n\n```aiken\nlet left_dict = dict.from_pairs([Pair(\"a\", 100), Pair(\"b\", 200)])\nlet right_dict = dict.from_pairs([Pair(\"a\", 150), Pair(\"c\", 300)])\n\nlet result =\ndict.union(left_dict, right_dict) |> dict.to_pairs()\n\nresult == [Pair(\"a\", 100), Pair(\"b\", 200), Pair(\"c\", 300)]\n```",
      "parameters": [],
      "returnType": "Dict<key, value>",
      "line": 942,
      "raw": "pub fn union(pub fn union(left: Dict<key, value>, right: Dict<key, value>, ) -> Dict<key, value> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn union(\n  left: Dict<key, value>,\n  right: Dict<key, value>,\n) -> Dict<key, value> {\n  Dict { inner: do_union(left.inner, right.inner) }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.union_with",
      "fullName": "stdlib:aiken.collection.dict.union_with",
      "name": "union_with",
      "signature": "pub fn union_with(pub fn union_with(left: Dict<key, value>, right: Dict<key, value>, with: UnionStrategy<ByteArray, value>, ) -> Dict<key, value> {",
      "documentation": "Like [`union`](#union) but allows specifying the behavior to adopt when a key is present\nin both dictionaries. The first value received correspond to the value in the left\ndictionnary, whereas the second argument corresponds to the value in the right dictionnary.\n\nWhen passing `None`, the value is removed and not present in the union.\n\n```aiken\nlet left_dict = dict.from_pairs([Pair(\"a\", 100), Pair(\"b\", 200)])\nlet right_dict = dict.from_pairs([Pair(\"a\", 150), Pair(\"c\", 300)])\n\nlet result =\ndict.union_with(\nleft_dict,\nright_dict,\nfn(_k, v1, v2) { Some(v1 + v2) },\n)\n|> dict.to_pairs()\n\nresult == [Pair(\"a\", 250), Pair(\"b\", 200), Pair(\"c\", 300)]\n```",
      "parameters": [],
      "returnType": "Dict<key, value>",
      "line": 1011,
      "raw": "pub fn union_with(pub fn union_with(left: Dict<key, value>, right: Dict<key, value>, with: UnionStrategy<ByteArray, value>, ) -> Dict<key, value> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn union_with(\n  left: Dict<key, value>,\n  right: Dict<key, value>,\n  with: UnionStrategy<ByteArray, value>,\n) -> Dict<key, value> {\n  Dict { inner: do_union_with(left.inner, right.inner, with) }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.foldl",
      "fullName": "stdlib:aiken.collection.dict.foldl",
      "name": "foldl",
      "signature": "pub fn foldl(pub fn foldl(self: Dict<key, value>, zero: result, with: fn(ByteArray, value, result) -> result,",
      "documentation": "Fold over the key-value pairs in a dictionary. The fold direction follows keys\nin ascending order and is done from left-to-right.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(key: \"a\", value: 100)\n|> dict.insert(key: \"b\", value: 200)\n|> dict.insert(key: \"c\", value: 300)\n|> dict.foldl(0, fn(_k, v, r) { v + r })\n\nresult == 600\n```",
      "parameters": [],
      "returnType": "result,",
      "line": 1088,
      "raw": "pub fn foldl(pub fn foldl(self: Dict<key, value>, zero: result, with: fn(ByteArray, value, result) -> result,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn foldl(\n  self: Dict<key, value>,\n  zero: result,\n  with: fn(ByteArray, value, result) -> result,\n) -> result {\n  do_foldl(self.inner, zero, with)\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.foldr",
      "fullName": "stdlib:aiken.collection.dict.foldr",
      "name": "foldr",
      "signature": "pub fn foldr(pub fn foldr(self: Dict<key, value>, zero: result, with: fn(ByteArray, value, result) -> result,",
      "documentation": "Fold over the key-value pairs in a dictionary. The fold direction follows keys\nin ascending order and is done from right-to-left.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(key: \"a\", value: 100)\n|> dict.insert(key: \"b\", value: 200)\n|> dict.insert(key: \"c\", value: 300)\n|> dict.foldr(0, fn(_k, v, r) { v + r })\n\nresult == 600\n```",
      "parameters": [],
      "returnType": "result,",
      "line": 1128,
      "raw": "pub fn foldr(pub fn foldr(self: Dict<key, value>, zero: result, with: fn(ByteArray, value, result) -> result,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn foldr(\n  self: Dict<key, value>,\n  zero: result,\n  with: fn(ByteArray, value, result) -> result,\n) -> result {\n  do_foldr(self.inner, zero, with)\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.to_pairs",
      "fullName": "stdlib:aiken.collection.dict.to_pairs",
      "name": "to_pairs",
      "signature": "pub fn to_pairs(self: Dict<key, value>) -> Pairs<ByteArray, value> {",
      "documentation": "Get the inner list holding the dictionary data.\n\n```aiken\nlet result =\ndict.empty\n|> dict.insert(\"a\", 100)\n|> dict.insert(\"b\", 200)\n|> dict.insert(\"c\", 300)\n|> dict.to_pairs()\n\nresult == [Pair(\"a\", 100), Pair(\"b\", 200), Pair(\"c\", 300)]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Dict<key, value>",
          "optional": false
        }
      ],
      "returnType": "Pairs<ByteArray, value>",
      "line": 1167,
      "raw": "pub fn to_pairs(self: Dict<key, value>) -> Pairs<ByteArray, value> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn to_pairs(self: Dict<key, value>) -> Pairs<ByteArray, value> {\n  self.inner\n}"
    },
    {
      "key": "stdlib:aiken.collection.list.push",
      "fullName": "stdlib:aiken.collection.list.push",
      "name": "push",
      "signature": "pub fn push(self: List<a>, elem: a) -> List<a> {",
      "documentation": "Add an element in front of the list. Sometimes useful when combined with\nother functions.\n\n```aiken\nlist.push([2, 3], 1) == [1, ..[2, 3]] == [1, 2, 3]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "elem",
          "type": "a",
          "optional": false
        }
      ],
      "returnType": "List<a>",
      "line": 13,
      "raw": "pub fn push(self: List<a>, elem: a) -> List<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn push(self: List<a>, elem: a) -> List<a> {\n  [elem, ..self]\n}",
      "tests": [
        "test push_1() {\n  push([], 0) == [0]\n}",
        "test push_2() {\n  push([2, 3], 1) == [1, 2, 3]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.range",
      "fullName": "stdlib:aiken.collection.list.range",
      "name": "range",
      "signature": "pub fn range(from: Int, to: Int) -> List<Int> {",
      "documentation": "Construct a list of a integer from a given range.\n\n```aiken\nlist.range(0, 3) == [0, 1, 2, 3]\nlist.range(-1, 1) == [-1, 0, 1]\n```",
      "parameters": [
        {
          "name": "from",
          "type": "Int",
          "optional": false
        },
        {
          "name": "to",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "List<Int>",
      "line": 31,
      "raw": "pub fn range(from: Int, to: Int) -> List<Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn range(from: Int, to: Int) -> List<Int> {\n  if from > to {\n    []\n  } else {\n    [from, ..range(from + 1, to)]\n  }\n}",
      "tests": [
        "test range_1() {\n  range(0, 3) == [0, 1, 2, 3]\n}",
        "test range_2() {\n  range(-1, 1) == [-1, 0, 1]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.repeat",
      "fullName": "stdlib:aiken.collection.list.repeat",
      "name": "repeat",
      "signature": "pub fn repeat(elem: a, n_times: Int) -> List<a> {",
      "documentation": "Construct a list filled with n copies of a value.\n\n```aiken\nlist.repeat(\"na\", 3) == [\"na\", \"na\", \"na\"]\n```",
      "parameters": [
        {
          "name": "elem",
          "type": "a",
          "optional": false
        },
        {
          "name": "n_times",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "List<a>",
      "line": 52,
      "raw": "pub fn repeat(elem: a, n_times: Int) -> List<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn repeat(elem: a, n_times: Int) -> List<a> {\n  if n_times <= 0 {\n    []\n  } else {\n    [elem, ..repeat(elem, n_times - 1)]\n  }\n}",
      "tests": [
        "test repeat_1() {\n  repeat(42, 0) == []\n}",
        "test repeat_2() {\n  repeat(14, 3) == [14, 14, 14]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.all",
      "fullName": "stdlib:aiken.collection.list.all",
      "name": "all",
      "signature": "pub fn all(self: List<a>, predicate: fn(a) -> Bool) -> Bool {",
      "documentation": "Determine if all elements of the list satisfy the given predicate.\n\nNote: an empty list always satisfies the predicate.\n\n```aiken\nlist.all([], fn(n) { n > 0 }) == True\nlist.all([1, 2, 3], fn(n) { n > 0 }) == True\nlist.all([1, 2, 3], fn(n) { n == 2 }) == False\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "fn(a",
          "optional": false
        }
      ],
      "returnType": "Bool) -> Bool",
      "line": 79,
      "raw": "pub fn all(self: List<a>, predicate: fn(a) -> Bool) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn all(self: List<a>, predicate: fn(a) -> Bool) -> Bool {\n  when self is {\n    [] -> True\n    [x, ..xs] -> predicate(x) && all(xs, predicate)\n  }\n}",
      "tests": [
        "test all_1() {\n  all([1, 2, 3], fn(n) { n > 0 }) == True\n}",
        "test all_2() {\n  all([1, 2, 3], fn(n) { n > 42 }) == False\n}",
        "test all_3() {\n  all([], fn(n) { n == 42 }) == True\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.any",
      "fullName": "stdlib:aiken.collection.list.any",
      "name": "any",
      "signature": "pub fn any(self: List<a>, predicate: fn(a) -> Bool) -> Bool {",
      "documentation": "Determine if at least one element of the list satisfies the given predicate.\n\nNote: an empty list never satisfies the predicate.\n\n```aiken\nlist.any([], fn(n) { n > 2 }) == False\nlist.any([1, 2, 3], fn(n) { n > 0 }) == True\nlist.any([1, 2, 3], fn(n) { n == 2 }) == True\nlist.any([1, 2, 3], fn(n) { n < 0 }) == False\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "fn(a",
          "optional": false
        }
      ],
      "returnType": "Bool) -> Bool",
      "line": 108,
      "raw": "pub fn any(self: List<a>, predicate: fn(a) -> Bool) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn any(self: List<a>, predicate: fn(a) -> Bool) -> Bool {\n  when self is {\n    [] -> False\n    [x, ..xs] -> predicate(x) || any(xs, predicate)\n  }\n}",
      "tests": [
        "test any_1() {\n  any([1, 2, 3], fn(n) { n > 0 }) == True\n}",
        "test any_2() {\n  any([1, 2, 3], fn(n) { n > 42 }) == False\n}",
        "test any_3() {\n  any([], fn(n) { n == 42 }) == False\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.at",
      "fullName": "stdlib:aiken.collection.list.at",
      "name": "at",
      "signature": "pub fn at(self: List<a>, index: Int) -> Option<a> {",
      "documentation": "Return Some(item) at the index or None if the index is out of range. The index is 0-based.\n\n```aiken\nlist.at([1, 2, 3], 1) == Some(2)\nlist.at([1, 2, 3], 42) == None\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "index",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Option<a>",
      "line": 133,
      "raw": "pub fn at(self: List<a>, index: Int) -> Option<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn at(self: List<a>, index: Int) -> Option<a> {\n  when self is {\n    [] -> None\n    [x, ..xs] ->\n      if index == 0 {\n        Some(x)\n      } else {\n        at(xs, index - 1)\n      }\n  }\n}",
      "tests": [
        "test at_1() {\n  at([1, 2, 3], -1) == None\n}",
        "test at_2() {\n  at([], 0) == None\n}",
        "test at_3() {\n  at([1, 2, 3], 3) == None\n}",
        "test at_4() {\n  at([1], 0) == Some(1)\n}",
        "test at_5() {\n  at([1, 2, 3], 2) == Some(3)\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.count",
      "fullName": "stdlib:aiken.collection.list.count",
      "name": "count",
      "signature": "pub fn count(self: List<a>, predicate: fn(a) -> Bool) -> Int {",
      "documentation": "Count how many items in the list satisfy the given predicate.\n\n```aiken\nlist.count([], fn(a) { a > 2}) == 0\nlist.count([1, 2, 3], fn(a) { n > 0 }) == 3\nlist.count([1, 2, 3], fn(a) { n >= 2 }) == 2\nlist.count([1, 2, 3], fn(a) { n > 5 }) == 0\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "fn(a",
          "optional": false
        }
      ],
      "returnType": "Bool) -> Int",
      "line": 173,
      "raw": "pub fn count(self: List<a>, predicate: fn(a) -> Bool) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn count(self: List<a>, predicate: fn(a) -> Bool) -> Int {\n  foldr(\n    self,\n    0,\n    fn(item, total) {\n      if predicate(item) {\n        total + 1\n      } else {\n        total\n      }\n    },\n  )\n}",
      "tests": [
        "test count_empty() {\n  count([], fn(a) { a > 2 }) == 0\n}",
        "test count_all() {\n  count([1, 2, 3], fn(a) { a > 0 }) == 3\n}",
        "test count_some() {\n  count([1, 2, 3], fn(a) { a >= 2 }) == 2\n}",
        "test count_none() {\n  count([1, 2, 3], fn(a) { a > 5 }) == 0\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.find",
      "fullName": "stdlib:aiken.collection.list.find",
      "name": "find",
      "signature": "pub fn find(self: List<a>, predicate: fn(a) -> Bool) -> Option<a> {",
      "documentation": "Find the first element satisfying the given predicate, if any.\n\n```aiken\nlist.find([1, 2, 3], fn(x) { x == 2 }) == Some(2)\nlist.find([4, 5, 6], fn(x) { x == 2 }) == None\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "fn(a",
          "optional": false
        }
      ],
      "returnType": "Bool) -> Option<a>",
      "line": 209,
      "raw": "pub fn find(self: List<a>, predicate: fn(a) -> Bool) -> Option<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn find(self: List<a>, predicate: fn(a) -> Bool) -> Option<a> {\n  when self is {\n    [] -> None\n    [x, ..xs] ->\n      if predicate(x) {\n        Some(x)\n      } else {\n        find(xs, predicate)\n      }\n  }\n}",
      "tests": [
        "test find_1() {\n  find([1, 2, 3], fn(x) { x == 1 }) == Some(1)\n}",
        "test find_2() {\n  find([1, 2, 3], fn(x) { x > 42 }) == None\n}",
        "test find_3() {\n  find([], fn(_) { True }) == None\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.has",
      "fullName": "stdlib:aiken.collection.list.has",
      "name": "has",
      "signature": "pub fn has(self: List<a>, elem: a) -> Bool {",
      "documentation": "Figures out whether a list contain the given element.\n\n```aiken\nlist.has([1, 2, 3], 2) == True\nlist.has([1, 2, 3], 14) == False\nlist.has([], 14) == False\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "elem",
          "type": "a",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 240,
      "raw": "pub fn has(self: List<a>, elem: a) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn has(self: List<a>, elem: a) -> Bool {\n  when self is {\n    [] -> False\n    [x, ..xs] ->\n      if x == elem {\n        True\n      } else {\n        has(xs, elem)\n      }\n  }\n}",
      "tests": [
        "test has_1() {\n  has([1, 2, 3], 1) == True\n}",
        "test has_2() {\n  has([1, 2, 3], 14) == False\n}",
        "test has_3() {\n  has([], 14) == False\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.head",
      "fullName": "stdlib:aiken.collection.list.head",
      "name": "head",
      "signature": "pub fn head(self: List<a>) -> Option<a> {",
      "documentation": "Get the first element of a list\n\n```aiken\nlist.head([1, 2, 3]) == Some(1)\nlist.head([]) == None\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        }
      ],
      "returnType": "Option<a>",
      "line": 270,
      "raw": "pub fn head(self: List<a>) -> Option<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn head(self: List<a>) -> Option<a> {\n  when self is {\n    [] -> None\n    _ -> Some(builtin.head_list(self))\n  }\n}",
      "tests": [
        "test head_1() {\n  head([1, 2, 3]) == Some(1)\n}",
        "test head_2() {\n  head([]) == None\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.is_empty",
      "fullName": "stdlib:aiken.collection.list.is_empty",
      "name": "is_empty",
      "signature": "pub fn is_empty(self: List<a>) -> Bool {",
      "documentation": "Checks whether a list is empty.\n\n```aiken\nlist.is_empty([]) == True\nlist.is_empty([1, 2, 3]) == False\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 291,
      "raw": "pub fn is_empty(self: List<a>) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn is_empty(self: List<a>) -> Bool {\n  when self is {\n    [] -> True\n    _ -> False\n  }\n}",
      "tests": [
        "test is_empty_1() {\n  is_empty([]) == True\n}",
        "test is_empty_2() {\n  is_empty([1, 2, 3]) == False\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.index_of",
      "fullName": "stdlib:aiken.collection.list.index_of",
      "name": "index_of",
      "signature": "pub fn index_of(self: List<a>, elem: a) -> Option<Int> {",
      "documentation": "Gets the index of an element of a list, if any. Otherwise, returns None.\n\n```aiken\nlist.index_of([1, 5, 2], 2) == Some(2)\nlist.index_of([1, 7, 3], 4) == None\nlist.index_of([1, 0, 9, 6], 6) == 3\nlist.index_of([], 6) == None\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "elem",
          "type": "a",
          "optional": false
        }
      ],
      "returnType": "Option<Int>",
      "line": 314,
      "raw": "pub fn index_of(self: List<a>, elem: a) -> Option<Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn index_of(self: List<a>, elem: a) -> Option<Int> {\n  do_index_of(self, elem, 0)\n}"
    },
    {
      "key": "stdlib:aiken.collection.list.last",
      "fullName": "stdlib:aiken.collection.list.last",
      "name": "last",
      "signature": "pub fn last(self: List<a>) -> Option<a> {",
      "documentation": "Get the last in the given list, if any.\n\n```aiken\nlist.last([]) == None\nlist.last([1, 2, 3]) == Some(3)\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        }
      ],
      "returnType": "Option<a>",
      "line": 352,
      "raw": "pub fn last(self: List<a>) -> Option<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn last(self: List<a>) -> Option<a> {\n  when self is {\n    [] -> None\n    [x] -> Some(x)\n    [_, ..xs] -> last(xs)\n  }\n}",
      "tests": [
        "test last_1() {\n  last([]) == None\n}",
        "test last_2() {\n  last([1]) == Some(1)\n}",
        "test last_3() {\n  last([1, 2, 3, 4]) == Some(4)\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.length",
      "fullName": "stdlib:aiken.collection.list.length",
      "name": "length",
      "signature": "pub fn length(self: List<a>) -> Int {",
      "documentation": "Get the number of elements in the given list.\n\n```aiken\nlist.length([]) == 0\nlist.length([1, 2, 3]) == 3\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 378,
      "raw": "pub fn length(self: List<a>) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn length(self: List<a>) -> Int {\n  when self is {\n    [] -> 0\n    [_, ..xs] -> 1 + length(xs)\n  }\n}",
      "tests": [
        "test length_1() {\n  length([]) == 0\n}",
        "test length_2() {\n  length([1, 2, 3]) == 3\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.delete",
      "fullName": "stdlib:aiken.collection.list.delete",
      "name": "delete",
      "signature": "pub fn delete(self: List<a>, elem: a) -> List<a> {",
      "documentation": "Remove the first occurrence of the given element from the list.\n\n```aiken\nlist.delete([1, 2, 3, 1], 1) == [2, 3, 1]\nlist.delete([1, 2, 3], 14) == [1, 2, 3]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "elem",
          "type": "a",
          "optional": false
        }
      ],
      "returnType": "List<a>",
      "line": 403,
      "raw": "pub fn delete(self: List<a>, elem: a) -> List<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn delete(self: List<a>, elem: a) -> List<a> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      if x == elem {\n        xs\n      } else {\n        [x, ..delete(xs, elem)]\n      }\n  }\n}",
      "tests": [
        "test delete_1() {\n  delete([], 42) == []\n}",
        "test delete_2() {\n  delete([1, 2, 3, 1], 1) == [2, 3, 1]\n}",
        "test delete_3() {\n  delete([1, 2, 3], 14) == [1, 2, 3]\n}",
        "test delete_4() {\n  delete([2], 2) == []\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.drop",
      "fullName": "stdlib:aiken.collection.list.drop",
      "name": "drop",
      "signature": "pub fn drop(self: List<a>, n: Int) -> List<a> {",
      "documentation": "Drop the first `n` elements of a list.\n\n```aiken\nlist.drop([1, 2, 3], 2) == [3]\nlist.drop([], 42) == []\nlist.drop([1, 2, 3], 42) == []\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "n",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "List<a>",
      "line": 438,
      "raw": "pub fn drop(self: List<a>, n: Int) -> List<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn drop(self: List<a>, n: Int) -> List<a> {\n  if n <= 0 {\n    self\n  } else {\n    when self is {\n      [] -> []\n      [_x, ..xs] -> drop(xs, n - 1)\n    }\n  }\n}",
      "tests": [
        "test drop_1() {\n  drop([], 42) == []\n}",
        "test drop_2() {\n  drop([1, 2, 3], 2) == [3]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.drop_while",
      "fullName": "stdlib:aiken.collection.list.drop_while",
      "name": "drop_while",
      "signature": "pub fn drop_while(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {",
      "documentation": "Returns the suffix of the given list after removing all elements that satisfy the predicate.\n\n```aiken\nlist.drop_while([1, 2, 3], fn(x) { x < 2 }) == [2, 3]\nlist.drop_while([], fn(x) { x > 2 }) == []\nlist.drop_while([1, 2, 3], fn(x) { x == 3 }) == [1, 2, 3]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "fn(a",
          "optional": false
        }
      ],
      "returnType": "Bool) -> List<a>",
      "line": 464,
      "raw": "pub fn drop_while(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn drop_while(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      if predicate(x) {\n        drop_while(xs, predicate)\n      } else {\n        self\n      }\n  }\n}",
      "tests": [
        "test drop_while_1() {\n  drop_while([], fn(x) { x > 2 }) == []\n}",
        "test drop_while_2() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  drop_while(xs, fn(x) { x > 5 }) == [5, 4, 3, 2, 1]\n}",
        "test drop_while_3() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  drop_while(xs, fn(x) { x == 42 }) == xs\n}",
        "test drop_while_4() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  drop_while(xs, fn(x) { x < 42 }) == []\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.filter",
      "fullName": "stdlib:aiken.collection.list.filter",
      "name": "filter",
      "signature": "pub fn filter(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {",
      "documentation": "Produce a list of elements that satisfy a predicate.\n\n```aiken\nlist.filter([1, 2, 3], fn(x) { x >= 2 }) == [2, 3]\nlist.filter([], fn(x) { x > 2 }) == []\nlist.filter([1, 2, 3], fn(x) { x == 3 }) == [3]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "fn(a",
          "optional": false
        }
      ],
      "returnType": "Bool) -> List<a>",
      "line": 502,
      "raw": "pub fn filter(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn filter(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      if predicate(x) {\n        [x, ..filter(xs, predicate)]\n      } else {\n        filter(xs, predicate)\n      }\n  }\n}",
      "tests": [
        "test filter_1() {\n  filter([], fn(x) { x > 0 }) == []\n}",
        "test filter_2() {\n  let xs = [1, 2, 3, 4, 5, 6]\n  filter(xs, fn(x) { builtin.mod_integer(x, 2) == 0 }) == [2, 4, 6]\n}",
        "test filter_3() {\n  let filter_foldr =\n    fn(xs, f) {\n      foldr(\n        xs,\n        [],\n        fn(x, ys) {\n          if f(x) {\n            [x, ..ys]\n          } else {\n            ys\n          }\n        },\n      )\n    }\n\n  let is_odd =\n    fn(n) { builtin.mod_integer(n, 2) != 0 }\n\n  filter_foldr([1, 2, 3], is_odd) == filter([1, 2, 3], is_odd)\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.filter_map",
      "fullName": "stdlib:aiken.collection.list.filter_map",
      "name": "filter_map",
      "signature": "pub fn filter_map(self: List<a>, predicate: fn(a) -> Option<b>) -> List<b> {",
      "documentation": "Produce a list of transformed elements that satisfy a predicate.\n\n```aiken\nlet transform = fn(x) { if x % 2 == 0 { None } else { Some(3*x) } }\nlist.filter_map([1, 2, 3], transform) == [3, 9]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "fn(a",
          "optional": false
        }
      ],
      "returnType": "Option<b>) -> List<b>",
      "line": 551,
      "raw": "pub fn filter_map(self: List<a>, predicate: fn(a) -> Option<b>) -> List<b> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn filter_map(self: List<a>, predicate: fn(a) -> Option<b>) -> List<b> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      when predicate(x) is {\n        None -> filter_map(xs, predicate)\n        Some(y) -> [y, ..filter_map(xs, predicate)]\n      }\n  }\n}",
      "tests": [
        "test filter_map_1() {\n  filter_map([], fn(_) { Some(42) }) == []\n}",
        "test filter_map_2() {\n  filter_map(\n    [1, 2, 3, 4, 5, 6],\n    fn(x) {\n      if builtin.mod_integer(x, 2) != 0 {\n        Some(3 * x)\n      } else {\n        None\n      }\n    },\n  ) == [3, 9, 15]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.init",
      "fullName": "stdlib:aiken.collection.list.init",
      "name": "init",
      "signature": "pub fn init(self: List<a>) -> Option<List<a>> {",
      "documentation": "Return all elements except the last one.\n\n```aiken\nlist.init([]) == None\nlist.init([1, 2, 3]) == Some([1, 2])\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        }
      ],
      "returnType": "Option<List<a>>",
      "line": 585,
      "raw": "pub fn init(self: List<a>) -> Option<List<a>> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn init(self: List<a>) -> Option<List<a>> {\n  when self is {\n    [] -> None\n    _ -> Some(do_init(self))\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.list.partition",
      "fullName": "stdlib:aiken.collection.list.partition",
      "name": "partition",
      "signature": "pub fn partition(self: List<a>, predicate: fn(a) -> Bool) -> (List<a>, List<a>) {",
      "documentation": "Returns a tuple with all elements that satisfy the predicate at first\nelement, and the rest as second element.\n\n```aiken\nlist.partition([1, 2, 3, 4], fn(x) { x % 2 == 0 }) == ([2, 4], [1, 3])\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "fn(a",
          "optional": false
        }
      ],
      "returnType": "Bool) -> (List<a>, List<a>)",
      "line": 618,
      "raw": "pub fn partition(self: List<a>, predicate: fn(a) -> Bool) -> (List<a>, List<a>) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn partition(self: List<a>, predicate: fn(a) -> Bool) -> (List<a>, List<a>) {\n  when self is {\n    [] -> ([], [])\n    [x, ..xs] -> {\n      let (left, right) = partition(xs, predicate)\n      if predicate(x) {\n        ([x, ..left], right)\n      } else {\n        (left, [x, ..right])\n      }\n    }\n  }\n}",
      "tests": [
        "test partition_1() {\n  partition([], fn(x) { x > 2 }) == ([], [])\n}",
        "test partition_2() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  partition(xs, fn(x) { x > 5 }) == ([10, 9, 8, 7, 6], [5, 4, 3, 2, 1])\n}",
        "test partition_3() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  partition(xs, fn(x) { x == 42 }) == ([], xs)\n}",
        "test partition_4() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  partition(xs, fn(x) { x < 42 }) == (xs, [])\n}",
        "test partition_5() {\n  partition([1, 2, 3, 4], fn(x) { x % 2 == 0 }) == ([2, 4], [1, 3])\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.slice",
      "fullName": "stdlib:aiken.collection.list.slice",
      "name": "slice",
      "signature": "pub fn slice(self: List<a>, from: Int, to: Int) -> List<a> {",
      "documentation": "Extract a sublist from the given list using 0-based indexes. Negative\nindexes wrap over, so `-1` refers to the last element of the list.\n\n```aiken\nlist.slice([1, 2, 3, 4, 5, 6], from: 2, to: 4) == [3, 4, 5]\nlist.slice([1, 2, 3, 4, 5, 6], from: -2, to: -1) == [5, 6]\nlist.slice([1, 2, 3, 4, 5, 6], from: 1, to: -1) == [2, 3, 4, 5, 6]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "from",
          "type": "Int",
          "optional": false
        },
        {
          "name": "to",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "List<a>",
      "line": 663,
      "raw": "pub fn slice(self: List<a>, from: Int, to: Int) -> List<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn slice(self: List<a>, from: Int, to: Int) -> List<a> {\n  let (i, l) =\n    if from >= 0 {\n      (from, None)\n    } else {\n      let l = length(self)\n      (l + from, Some(l))\n    }\n\n  let j =\n    if to >= 0 {\n      to - i + 1\n    } else {\n      when l is {\n        Some(l) -> l + to - i + 1\n        None -> length(self) + to - i + 1\n      }\n    }\n\n  self\n    |> drop(i)\n    |> take(j)\n}",
      "tests": [
        "test slice_1() {\n  slice([1, 2, 3], 0, 2) == [1, 2, 3]\n}",
        "test slice_2() {\n  slice([1, 2, 3, 4, 5, 6], from: 2, to: 4) == [3, 4, 5]\n}",
        "test slice_3() {\n  slice([1, 2, 3, 4, 5, 6], from: -2, to: -1) == [5, 6]\n}",
        "test slice_4() {\n  slice([1, 2, 3, 4, 5, 6], from: 1, to: -1) == [2, 3, 4, 5, 6]\n}",
        "test slice_5() {\n  slice([1, 2, 3, 4, 5, 6], from: -4, to: -3) == [3, 4]\n}",
        "test slice_6() {\n  slice([1, 2, 3, 4, 5, 6], from: -2, to: 1) == []\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.span",
      "fullName": "stdlib:aiken.collection.list.span",
      "name": "span",
      "signature": "pub fn span(self: List<a>, n: Int) -> (List<a>, List<a>) {",
      "documentation": "Cut a list in two, such that the first list contains the given number of /\nelements and the second list contains the rest.\n\nFundamentally equivalent to (but more efficient):\n\n```aiken\n// span(xs, n) == (take(xs, n), drop(xs, n))\nspan([1, 2, 3, 4, 5], 3) == ([1, 2, 3], [4, 5])\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "n",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "(List<a>, List<a>)",
      "line": 720,
      "raw": "pub fn span(self: List<a>, n: Int) -> (List<a>, List<a>) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn span(self: List<a>, n: Int) -> (List<a>, List<a>) {\n  when self is {\n    [] -> ([], [])\n    [x, ..xs] ->\n      if n <= 0 {\n        ([], self)\n      } else {\n        let (left, right) = span(xs, n - 1)\n        ([x, ..left], right)\n      }\n  }\n}",
      "tests": [
        "test span_1() {\n  span([], 2) == ([], [])\n}",
        "test span_2() {\n  span([1, 2, 3], 2) == ([1, 2], [3])\n}",
        "test span_3() {\n  span([1, 2, 3], -1) == ([], [1, 2, 3])\n}",
        "test span_4() {\n  span([1, 2, 3], 42) == ([1, 2, 3], [])\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.tail",
      "fullName": "stdlib:aiken.collection.list.tail",
      "name": "tail",
      "signature": "pub fn tail(self: List<a>) -> Option<List<a>> {",
      "documentation": "Get elements of a list after the first one, if any.\n\n```aiken\nlist.tail([]) == None\nlist.tail([1, 2, 3]) == Some([2, 3])\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        }
      ],
      "returnType": "Option<List<a>>",
      "line": 755,
      "raw": "pub fn tail(self: List<a>) -> Option<List<a>> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn tail(self: List<a>) -> Option<List<a>> {\n  when self is {\n    [] -> None\n    [_, ..xs] -> Some(xs)\n  }\n}",
      "tests": [
        "test tail_1() {\n  tail([1, 2, 3]) == Some([2, 3])\n}",
        "test tail_2() {\n  tail([]) == None\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.take",
      "fullName": "stdlib:aiken.collection.list.take",
      "name": "take",
      "signature": "pub fn take(self: List<a>, n: Int) -> List<a> {",
      "documentation": "Get the first `n` elements of a list.\n\n```aiken\nlist.take([1, 2, 3], 2) == [1, 2]\nlist.take([1, 2, 3], 14) == [1, 2, 3]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "n",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "List<a>",
      "line": 776,
      "raw": "pub fn take(self: List<a>, n: Int) -> List<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn take(self: List<a>, n: Int) -> List<a> {\n  if n <= 0 {\n    []\n  } else {\n    when self is {\n      [] -> []\n      [x, ..xs] -> [x, ..take(xs, n - 1)]\n    }\n  }\n}",
      "tests": [
        "test take_1() {\n  take([], 42) == []\n}",
        "test take_2() {\n  take([1, 2, 3], 2) == [1, 2]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.take_while",
      "fullName": "stdlib:aiken.collection.list.take_while",
      "name": "take_while",
      "signature": "pub fn take_while(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {",
      "documentation": "Returns the longest prefix of the given list where all elements satisfy the predicate.\n\n```aiken\nlist.take_while([1, 2, 3], fn(x) { x > 2 }) == []\nlist.take_while([1, 2, 3], fn(x) { x < 2 }) == [1]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "predicate",
          "type": "fn(a",
          "optional": false
        }
      ],
      "returnType": "Bool) -> List<a>",
      "line": 801,
      "raw": "pub fn take_while(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn take_while(self: List<a>, predicate: fn(a) -> Bool) -> List<a> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      if predicate(x) {\n        [x, ..take_while(xs, predicate)]\n      } else {\n        []\n      }\n  }\n}",
      "tests": [
        "test take_while_1() {\n  take_while([], fn(x) { x > 2 }) == []\n}",
        "test take_while_2() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  take_while(xs, fn(x) { x > 5 }) == [10, 9, 8, 7, 6]\n}",
        "test take_while_3() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  take_while(xs, fn(x) { x == 42 }) == []\n}",
        "test take_while_4() {\n  let xs = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n  take_while(xs, fn(x) { x < 42 }) == xs\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.unique",
      "fullName": "stdlib:aiken.collection.list.unique",
      "name": "unique",
      "signature": "pub fn unique(self: List<a>) -> List<a> {",
      "documentation": "Removes duplicate elements from a list.\n\n```aiken\nlist.unique([1, 2, 3, 1]) == [1, 2, 3]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        }
      ],
      "returnType": "List<a>",
      "line": 837,
      "raw": "pub fn unique(self: List<a>) -> List<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn unique(self: List<a>) -> List<a> {\n  when self is {\n    [] -> []\n    [x, ..xs] -> [x, ..unique(filter(xs, fn(y) { y != x }))]\n  }\n}",
      "tests": [
        "test unique_1() {\n  unique([]) == []\n}",
        "test unique_2() {\n  let xs = [1, 2, 3, 1, 1, 3, 4, 1, 2, 3, 2, 4, 5, 6, 7, 8, 9, 10, 9]\n  unique(xs) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.flat_map",
      "fullName": "stdlib:aiken.collection.list.flat_map",
      "name": "flat_map",
      "signature": "pub fn flat_map(self: List<a>, with: fn(a) -> List<b>) -> List<b> {",
      "documentation": "Map elements of a list into a new list and flatten the result.\n\n```aiken\nlist.flat_map([1, 2, 3], fn(a) { [a, 2*a] }) == [1, 2, 2, 4, 3, 6]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "with",
          "type": "fn(a",
          "optional": false
        }
      ],
      "returnType": "List<b>) -> List<b>",
      "line": 860,
      "raw": "pub fn flat_map(self: List<a>, with: fn(a) -> List<b>) -> List<b> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn flat_map(self: List<a>, with: fn(a) -> List<b>) -> List<b> {\n  foldr(self, [], fn(x, xs) { concat(with(x), xs) })\n}",
      "tests": [
        "test flat_map_1() {\n  flat_map([], fn(a) { [a] }) == []\n}",
        "test flat_map_2() {\n  flat_map([1, 2, 3], fn(a) { [a, a] }) == [1, 1, 2, 2, 3, 3]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.for_each",
      "fullName": "stdlib:aiken.collection.list.for_each",
      "name": "for_each",
      "signature": "pub fn for_each(self: List<a>, do: fn(a) -> Void) -> Void {",
      "documentation": "Perform an action for each element of a list.\n\n```aiken\nlist.for_each(labels, do: fn(lbl) { trace lbl Void })\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "do",
          "type": "fn(a",
          "optional": false
        }
      ],
      "returnType": "Void) -> Void",
      "line": 877,
      "raw": "pub fn for_each(self: List<a>, do: fn(a) -> Void) -> Void {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn for_each(self: List<a>, do: fn(a) -> Void) -> Void {\n  foldr(self, Void, fn(x, _) { do(x) })\n}",
      "tests": [
        "test for_each_1() {\n  for_each(\n    [@\"hello\", @\"world\"],\n    do: fn(lbl) {\n      trace lbl\n      Void\n    },\n  )\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.indexed_map",
      "fullName": "stdlib:aiken.collection.list.indexed_map",
      "name": "indexed_map",
      "signature": "pub fn indexed_map(self: List<a>, with: fn(Int, a) -> result) -> List<result> {",
      "documentation": "List [`map`](#map) but provides the position (0-based) of the elements while iterating.\n\n```aiken\nlist.indexed_map([1, 2, 3], fn(i, x) { i + x }) == [1, 3, 5]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "with",
          "type": "fn(Int, a",
          "optional": false
        }
      ],
      "returnType": "result) -> List<result>",
      "line": 896,
      "raw": "pub fn indexed_map(self: List<a>, with: fn(Int, a) -> result) -> List<result> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn indexed_map(self: List<a>, with: fn(Int, a) -> result) -> List<result> {\n  do_indexed_map(0, self, with)\n}"
    },
    {
      "key": "stdlib:aiken.collection.list.map",
      "fullName": "stdlib:aiken.collection.list.map",
      "name": "map",
      "signature": "pub fn map(self: List<a>, with: fn(a) -> result) -> List<result> {",
      "documentation": "Apply a function to each element of a list.\n\n```aiken\nlist.map([1, 2, 3, 4], fn(n) { n + 1 }) == [2, 3, 4, 5]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "with",
          "type": "fn(a",
          "optional": false
        }
      ],
      "returnType": "result) -> List<result>",
      "line": 933,
      "raw": "pub fn map(self: List<a>, with: fn(a) -> result) -> List<result> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn map(self: List<a>, with: fn(a) -> result) -> List<result> {\n  when self is {\n    [] -> []\n    [x, ..xs] -> [with(x), ..map(xs, with)]\n  }\n}",
      "tests": [
        "test map_1() {\n  map([], fn(n) { n + 1 }) == []\n}",
        "test map_2() {\n  map([1, 2, 3, 4], fn(n) { n + 1 }) == [2, 3, 4, 5]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.map2",
      "fullName": "stdlib:aiken.collection.list.map2",
      "name": "map2",
      "signature": "pub fn map2(pub fn map2(self: List<a>, bs: List<b>, with: fn(a, b) -> result,",
      "documentation": "Apply a function of two arguments, combining elements from two lists.\n\nNote: if one list is longer, the extra elements are dropped.\n\n```aiken\nlist.map2([1, 2, 3], [1, 2], fn(a, b) { a + b }) == [2, 4]\n```",
      "parameters": [],
      "returnType": "result,",
      "line": 955,
      "raw": "pub fn map2(pub fn map2(self: List<a>, bs: List<b>, with: fn(a, b) -> result,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn map2(\n  self: List<a>,\n  bs: List<b>,\n  with: fn(a, b) -> result,\n) -> List<result> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      when bs is {\n        [] -> []\n        [y, ..ys] -> [with(x, y), ..map2(xs, ys, with)]\n      }\n  }\n}",
      "tests": [
        "test map2_1() {\n  map2([], [1, 2, 3], fn(a, b) { a + b }) == []\n}",
        "test map2_2() {\n  map2([1, 2, 3], [1, 2], fn(a, b) { a + b }) == [2, 4]\n}",
        "test map2_3() {\n  map2([42], [1, 2, 3], fn(_a, b) { Some(b) }) == [Some(1)]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.map3",
      "fullName": "stdlib:aiken.collection.list.map3",
      "name": "map3",
      "signature": "pub fn map3(pub fn map3(self: List<a>, bs: List<b>, cs: List<c>, with: fn(a, b, c) -> result,",
      "documentation": "Apply a function of three arguments, combining elements from three lists.\n\nNote: if one list is longer, the extra elements are dropped.\n\n```aiken\nlist.map3([1, 2, 3], [1, 2], [1, 2, 3], fn(a, b, c) { a + b + c }) == [3, 6]\n```",
      "parameters": [],
      "returnType": "result,",
      "line": 989,
      "raw": "pub fn map3(pub fn map3(self: List<a>, bs: List<b>, cs: List<c>, with: fn(a, b, c) -> result,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn map3(\n  self: List<a>,\n  bs: List<b>,\n  cs: List<c>,\n  with: fn(a, b, c) -> result,\n) -> List<result> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      when bs is {\n        [] -> []\n        [y, ..ys] ->\n          when cs is {\n            [] -> []\n            [z, ..zs] -> [with(x, y, z), ..map3(xs, ys, zs, with)]\n          }\n      }\n  }\n}",
      "tests": [
        "test map3_1() {\n  map3([], [], [1, 2, 3], fn(a, b, c) { a + b + c }) == []\n}",
        "test map3_2() {\n  map3([1, 2, 3], [1, 2], [1, 2, 3], fn(a, b, c) { a + b + c }) == [3, 6]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.reverse",
      "fullName": "stdlib:aiken.collection.list.reverse",
      "name": "reverse",
      "signature": "pub fn reverse(self: List<a>) -> List<a> {",
      "documentation": "Return the list with its elements in the reserve order.\n\n```aiken\nlist.reverse([1, 2, 3]) == [3, 2, 1]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        }
      ],
      "returnType": "List<a>",
      "line": 1022,
      "raw": "pub fn reverse(self: List<a>) -> List<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn reverse(self: List<a>) -> List<a> {\n  foldl(self, [], fn(x, xs) { [x, ..xs] })\n}",
      "tests": [
        "test reverse_1() {\n  reverse([]) == []\n}",
        "test reverse_2() {\n  reverse([1, 2, 3]) == [3, 2, 1]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.sort",
      "fullName": "stdlib:aiken.collection.list.sort",
      "name": "sort",
      "signature": "pub fn sort(self: List<a>, compare: fn(a, a) -> Ordering) -> List<a> {",
      "documentation": "Sort a list in ascending order using the given comparison function.\n\n```aiken\nuse aiken/int\n\nsort([3, 1, 4, 0, 2], int.compare) == [0, 1, 2, 3, 4]\nsort([1, 2, 3], int.compare) == [1, 2, 3]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "compare",
          "type": "fn(a, a",
          "optional": false
        }
      ],
      "returnType": "Ordering) -> List<a>",
      "line": 1042,
      "raw": "pub fn sort(self: List<a>, compare: fn(a, a) -> Ordering) -> List<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sort(self: List<a>, compare: fn(a, a) -> Ordering) -> List<a> {\n  when self is {\n    [] -> []\n    [x, ..xs] -> insert(sort(xs, compare), x, compare)\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.list.unzip",
      "fullName": "stdlib:aiken.collection.list.unzip",
      "name": "unzip",
      "signature": "pub fn unzip(self: List<(a, b)>) -> (List<a>, List<b>) {",
      "documentation": "Decompose a list of tuples into a tuple of lists.\n\n```\nlist.unzip([(1, \"a\"), (2, \"b\")]) == ([1, 2], [\"a\", \"b\"])\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<(a, b",
          "optional": false
        }
      ],
      "returnType": "(List<a>, List<b>)",
      "line": 1085,
      "raw": "pub fn unzip(self: List<(a, b)>) -> (List<a>, List<b>) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn unzip(self: List<(a, b)>) -> (List<a>, List<b>) {\n  when self is {\n    [] -> ([], [])\n    [(a, b), ..xs] -> {\n      let (a_tail, b_tail) = unzip(xs)\n      ([a, ..a_tail], [b, ..b_tail])\n    }\n  }\n}",
      "tests": [
        "test unzip_1() {\n  unzip([]) == ([], [])\n}",
        "test unzip_2() {\n  unzip([(1, \"a\"), (2, \"b\")]) == ([1, 2], [\"a\", \"b\"])\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.concat",
      "fullName": "stdlib:aiken.collection.list.concat",
      "name": "concat",
      "signature": "pub fn concat(left: List<a>, right: List<a>) -> List<a> {",
      "documentation": "Merge two lists together.\n\n```aiken\nlist.concat([], []) == []\nlist.concat([], [1, 2, 3]) == [1, 2, 3]\nlist.concat([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n```",
      "parameters": [
        {
          "name": "left",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "right",
          "type": "List<a>",
          "optional": false
        }
      ],
      "returnType": "List<a>",
      "line": 1112,
      "raw": "pub fn concat(left: List<a>, right: List<a>) -> List<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn concat(left: List<a>, right: List<a>) -> List<a> {\n  when left is {\n    [] -> right\n    [x, ..xs] -> [x, ..concat(xs, right)]\n  }\n}",
      "tests": [
        "test concat_1() {\n  concat([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n}",
        "test concat_2() {\n  concat([1, 2, 3], []) == [1, 2, 3]\n}",
        "test concat_3() {\n  concat([], [1, 2, 3]) == [1, 2, 3]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.difference",
      "fullName": "stdlib:aiken.collection.list.difference",
      "name": "difference",
      "signature": "pub fn difference(self: List<a>, with: List<a>) -> List<a> {",
      "documentation": "Remove the first occurrence of each element of the second list from the first one.\n\n```\nlist.difference([\"h\", \"e\", \"l\", \"l\", \"o\"], [\"l\", \"e\", \"l\"]) == [\"h\", \"o\"]\nlist.difference([1, 2, 3, 4, 5], [1, 1, 2]) == [3, 4, 5]\nlist.difference([1, 2, 3], []) == [1, 2, 3]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "with",
          "type": "List<a>",
          "optional": false
        }
      ],
      "returnType": "List<a>",
      "line": 1138,
      "raw": "pub fn difference(self: List<a>, with: List<a>) -> List<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn difference(self: List<a>, with: List<a>) -> List<a> {\n  when with is {\n    [] -> self\n    [x, ..xs] -> difference(delete(self, x), xs)\n  }\n}",
      "tests": [
        "test difference_1() {\n  difference([\"h\", \"e\", \"l\", \"l\", \"o\"], [\"l\", \"e\", \"l\"]) == [\"h\", \"o\"]\n}",
        "test difference_2() {\n  difference([1, 2, 3, 4, 5], [1, 1, 2]) == [3, 4, 5]\n}",
        "test difference_3() {\n  difference([1, 2, 3], []) == [1, 2, 3]\n}",
        "test difference_4() {\n  difference([], [1, 2, 3]) == []\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.zip",
      "fullName": "stdlib:aiken.collection.list.zip",
      "name": "zip",
      "signature": "pub fn zip(self: List<a>, bs: List<b>) -> List<(a, b)> {",
      "documentation": "Combine two lists together.\n\nNote: if one list is longer, the extra elements are dropped.\n\n```aiken\nlist.zip([1, 2], [\"a\", \"b\", \"c\"]) == [(1, \"a\"), (2, \"b\")]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "bs",
          "type": "List<b>",
          "optional": false
        }
      ],
      "returnType": "List<(a, b)>",
      "line": 1168,
      "raw": "pub fn zip(self: List<a>, bs: List<b>) -> List<(a, b)> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn zip(self: List<a>, bs: List<b>) -> List<(a, b)> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      when bs is {\n        [] -> []\n        [y, ..ys] -> [(x, y), ..zip(xs, ys)]\n      }\n  }\n}",
      "tests": [
        "test zip_1() {\n  zip([], [1, 2, 3]) == []\n}",
        "test zip_2() {\n  zip([1, 2, 3], []) == []\n}",
        "test zip_3() {\n  zip([1, 2], [\"a\", \"b\", \"c\"]) == [(1, \"a\"), (2, \"b\")]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.foldl",
      "fullName": "stdlib:aiken.collection.list.foldl",
      "name": "foldl",
      "signature": "pub fn foldl(self: List<a>, zero: b, with: fn(a, b) -> b) -> b {",
      "documentation": "Reduce a list from left to right.\n\n```aiken\nlist.foldl([1, 2, 3], 0, fn(n, total) { n + total }) == 6\nlist.foldl([1, 2, 3], [], fn(x, xs) { [x, ..xs] }) == [3, 2, 1]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "zero",
          "type": "b",
          "optional": false
        },
        {
          "name": "with",
          "type": "fn(a, b",
          "optional": false
        }
      ],
      "returnType": "b) -> b",
      "line": 1199,
      "raw": "pub fn foldl(self: List<a>, zero: b, with: fn(a, b) -> b) -> b {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn foldl(self: List<a>, zero: b, with: fn(a, b) -> b) -> b {\n  when self is {\n    [] -> zero\n    [x, ..xs] -> foldl(xs, with(x, zero), with)\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.list.foldl2",
      "fullName": "stdlib:aiken.collection.list.foldl2",
      "name": "foldl2",
      "signature": "pub fn foldl2(pub fn foldl2(self: List<elem>, zero_a: a, zero_b: b, with: fn(elem, a, b, Fold2<a, b, result>) -> result, return: Fold2<a, b, result>,",
      "documentation": "Reduce a list from left to right, while accumulating two results. This is\nfaster (albeit equivalent) than accumulating both results in a `Pair` or tuple.\n\n> [!TIP]\n> Using [`backpassing`](https://aiken-lang.org/language-tour/functions#backpassing-) to ease readability is a good idea.\n\n```aiken\nlet len, sum <-\nfoldl2(\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n0,\n0,\nfn(n, len, sum, return) { return(len + 1, sum + n) },\n)\n\nand {\nlen == 10,\nsum == 55,\n}\n```",
      "parameters": [],
      "returnType": "result, return: Fold2<a, b, result>,",
      "line": 1230,
      "raw": "pub fn foldl2(pub fn foldl2(self: List<elem>, zero_a: a, zero_b: b, with: fn(elem, a, b, Fold2<a, b, result>) -> result, return: Fold2<a, b, result>,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn foldl2(\n  self: List<elem>,\n  zero_a: a,\n  zero_b: b,\n  with: fn(elem, a, b, Fold2<a, b, result>) -> result,\n  return: Fold2<a, b, result>,\n) -> result {\n  when self is {\n    [] -> return(zero_a, zero_b)\n    [x, ..xs] -> {\n      let a, b <- with(x, zero_a, zero_b)\n      foldl2(xs, a, b, with, return)\n    }\n  }\n}",
      "tests": [
        "test foldl2_optimized() {\n  let\n    len,\n    sum,\n  <-\n    foldl2(\n      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n      0,\n      0,\n      fn(n, len, sum, return) { return(len + 1, sum + n) },\n    )\n\n  and {\n    len == 10,\n    sum == 55,\n  }\n}",
        "test foldl2_classic() {\n  let (len, sum) =\n    foldl(\n      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n      (0, 0),\n      fn(n, (len, sum)) { (len + 1, sum + n) },\n    )\n\n  and {\n    len == 10,\n    sum == 55,\n  }\n}",
        "test foldl2_pair() {\n  let Pair(len, sum) =\n    foldl(\n      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n      Pair(0, 0),\n      fn(n, Pair(len, sum)) { Pair(len + 1, sum + n) },\n    )\n\n  and {\n    len == 10,\n    sum == 55,\n  }\n}",
        "test foldl2_foo() {\n  let Foo(len, sum) =\n    foldl(\n      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n      Foo(0, 0),\n      fn(n, Foo(len, sum)) { Foo(len + 1, sum + n) },\n    )\n\n  and {\n    len == 10,\n    sum == 55,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.foldr",
      "fullName": "stdlib:aiken.collection.list.foldr",
      "name": "foldr",
      "signature": "pub fn foldr(self: List<a>, zero: b, with: fn(a, b) -> b) -> b {",
      "documentation": "Reduce a list from right to left.\n\n```aiken\nlist.foldr([1, 2, 3], 0, fn(n, total) { n + total }) == 6\nlist.foldr([1, 2, 3], [], fn(x, xs) { [x, ..xs] }) == [1, 2, 3]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "zero",
          "type": "b",
          "optional": false
        },
        {
          "name": "with",
          "type": "fn(a, b",
          "optional": false
        }
      ],
      "returnType": "b) -> b",
      "line": 1328,
      "raw": "pub fn foldr(self: List<a>, zero: b, with: fn(a, b) -> b) -> b {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn foldr(self: List<a>, zero: b, with: fn(a, b) -> b) -> b {\n  when self is {\n    [] -> zero\n    [x, ..xs] -> with(x, foldr(xs, zero, with))\n  }\n}",
      "tests": [
        "test foldr_1() {\n  foldr([1, 2, 3, 4, 5], 0, fn(n, total) { n + total }) == 15\n}",
        "test foldr_2() {\n  foldr(\n    [1, 2, 3],\n    \"\",\n    fn(n, _str) {\n      if builtin.mod_integer(n, 2) == 0 {\n        \"foo\"\n      } else {\n        \"bar\"\n      }\n    },\n  ) == \"bar\"\n}",
        "test foldr_3() {\n  foldr([1, 2, 3, 4], [], fn(x, xs) { [x, ..xs] }) == [1, 2, 3, 4]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.list.foldr2",
      "fullName": "stdlib:aiken.collection.list.foldr2",
      "name": "foldr2",
      "signature": "pub fn foldr2(pub fn foldr2(self: List<elem>, zero_a: a, zero_b: b, with: fn(elem, a, b, Fold2<a, b, result>) -> result, return: Fold2<a, b, result>,",
      "documentation": "Reduce a list from right to left, while accumulating two results. This is\nfaster (albeit equivalent) than accumulating both results in a `Pair` or tuple.\n\n> [!TIP]\n> Using [`backpassing`](https://aiken-lang.org/language-tour/functions#backpassing-) to ease readability is a good idea.\n\n```aiken\nlet len, sum <-\nfoldr2(\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10],\n0,\n0,\nfn(n, len, sum, return) { return(len + 1, sum + n) },\n)\n\nand {\nlen == 10,\nsum == 55,\n}\n```",
      "parameters": [],
      "returnType": "result, return: Fold2<a, b, result>,",
      "line": 1377,
      "raw": "pub fn foldr2(pub fn foldr2(self: List<elem>, zero_a: a, zero_b: b, with: fn(elem, a, b, Fold2<a, b, result>) -> result, return: Fold2<a, b, result>,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn foldr2(\n  self: List<elem>,\n  zero_a: a,\n  zero_b: b,\n  with: fn(elem, a, b, Fold2<a, b, result>) -> result,\n  return: Fold2<a, b, result>,\n) -> result {\n  do_foldr2(self, with, return)(zero_a, zero_b)\n}"
    },
    {
      "key": "stdlib:aiken.collection.list.indexed_foldr",
      "fullName": "stdlib:aiken.collection.list.indexed_foldr",
      "name": "indexed_foldr",
      "signature": "pub fn indexed_foldr(pub fn indexed_foldr(self: List<a>, zero: result, with: fn(Int, a, result) -> result,",
      "documentation": "Like [`foldr`](#foldr), but also provides the position (0-based) of the elements when iterating.\n\n```aiken\nlet group = fn(i, x, xs) { [(i, x), ..xs] }\nlist.indexed_foldr([\"a\", \"b\", \"c\"], [], group) == [\n(0, \"a\"),\n(1, \"b\"),\n(2, \"c\")\n]\n```",
      "parameters": [],
      "returnType": "result,",
      "line": 1426,
      "raw": "pub fn indexed_foldr(pub fn indexed_foldr(self: List<a>, zero: result, with: fn(Int, a, result) -> result,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn indexed_foldr(\n  self: List<a>,\n  zero: result,\n  with: fn(Int, a, result) -> result,\n) -> result {\n  do_indexed_foldr(0, self, zero, with)\n}"
    },
    {
      "key": "stdlib:aiken.collection.list.reduce",
      "fullName": "stdlib:aiken.collection.list.reduce",
      "name": "reduce",
      "signature": "pub fn reduce(self: List<a>, zero: b, with: fn(b, a) -> b) -> b {",
      "documentation": "Reduce a list from left to right using the accumulator as left operand.\nSaid differently, this is [`foldl`](#foldl) with callback arguments swapped.\n\n```aiken\nlist.reduce([#[1], #[2], #[3]], #[0], bytearray.concat) == #[0, 1, 2, 3]\nlist.reduce([True, False, True], False, fn(b, a) { or { b, a } }) == True\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "zero",
          "type": "b",
          "optional": false
        },
        {
          "name": "with",
          "type": "fn(b, a",
          "optional": false
        }
      ],
      "returnType": "b) -> b",
      "line": 1464,
      "raw": "pub fn reduce(self: List<a>, zero: b, with: fn(b, a) -> b) -> b {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn reduce(self: List<a>, zero: b, with: fn(b, a) -> b) -> b {\n  foldl(self, zero, flip(with))\n}",
      "tests": [
        "test reduce_1() {\n  reduce([], 0, fn(n, total) { n + total }) == 0\n}",
        "test reduce_2() {\n  reduce([1, 2, 3], 0, fn(n, total) { n + total }) == 6\n}",
        "test reduce_3() {\n  reduce([True, False, True], False, fn(left, right) { left || right }) == True\n}",
        "test reduce_4() {\n  reduce(\n    [#[1], #[2], #[3]],\n    #[9],\n    fn(left, right) { bytearray.concat(left, right) },\n  ) == #[9, 1, 2, 3]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.pairs.get_all",
      "fullName": "stdlib:aiken.collection.pairs.get_all",
      "name": "get_all",
      "signature": "pub fn get_all(self: Pairs<key, value>, key k: key) -> List<value> {",
      "documentation": "Get all values in the alist associated with a given key.\n\n```aiken\npairs.get_all([], \"a\") == []\npairs.get_all([Pair(\"a\", 1)], \"a\") == [1]\npairs.get_all([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == [1]\npairs.get_all([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == [1, 3]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Pairs<key, value>",
          "optional": false
        }
      ],
      "returnType": "List<value>",
      "line": 28,
      "raw": "pub fn get_all(self: Pairs<key, value>, key k: key) -> List<value> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn get_all(self: Pairs<key, value>, key k: key) -> List<value> {\n  when self is {\n    [] -> []\n    [Pair(k2, v), ..rest] ->\n      if k == k2 {\n        [v, ..get_all(rest, k)]\n      } else {\n        get_all(rest, k)\n      }\n  }\n}",
      "tests": [
        "test get_all_1() {\n  get_all([], \"a\") == []\n}",
        "test get_all_2() {\n  get_all([Pair(\"a\", 1)], \"a\") == [1]\n}",
        "test get_all_3() {\n  get_all([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == [1]\n}",
        "test get_all_4() {\n  get_all([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == [1, 3]\n}",
        "test get_all_5() {\n  get_all([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"c\", 3)], \"d\") == []\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.pairs.get_first",
      "fullName": "stdlib:aiken.collection.pairs.get_first",
      "name": "get_first",
      "signature": "pub fn get_first(self: Pairs<key, value>, key k: key) -> Option<value> {",
      "documentation": "Get the value in the alist by its key.\nIf multiple values with the same key exist, only the first one is returned.\n\n```aiken\npairs.get_first([], \"a\") == None\npairs.get_first([Pair(\"a\", 1)], \"a\") == Some(1)\npairs.get_first([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == Some(1)\npairs.get_first([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == Some(1)\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Pairs<key, value>",
          "optional": false
        }
      ],
      "returnType": "Option<value>",
      "line": 69,
      "raw": "pub fn get_first(self: Pairs<key, value>, key k: key) -> Option<value> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn get_first(self: Pairs<key, value>, key k: key) -> Option<value> {\n  when self is {\n    [] -> None\n    [Pair(k2, v), ..rest] ->\n      if k == k2 {\n        Some(v)\n      } else {\n        get_first(rest, k)\n      }\n  }\n}",
      "tests": [
        "test get_first_1() {\n  get_first([], \"a\") == None\n}",
        "test get_first_2() {\n  get_first([Pair(\"a\", 1)], \"a\") == Some(1)\n}",
        "test get_first_3() {\n  get_first([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == Some(1)\n}",
        "test get_first_4() {\n  get_first([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == Some(1)\n}",
        "test get_first_5() {\n  get_first([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"c\", 3)], \"d\") == None\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.pairs.get_last",
      "fullName": "stdlib:aiken.collection.pairs.get_last",
      "name": "get_last",
      "signature": "pub fn get_last(self: Pairs<key, value>, key k: key) -> Option<value> {",
      "documentation": "Get the value in the alist by its key.\nIf multiple values with the same key exist, only the last one is returned.\n\n```aiken\npairs.get_last([], \"a\") == None\npairs.get_last([Pair(\"a\", 1)], \"a\") == Some(1)\npairs.get_last([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == Some(1)\npairs.get_last([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == Some(3)\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Pairs<key, value>",
          "optional": false
        }
      ],
      "returnType": "Option<value>",
      "line": 110,
      "raw": "pub fn get_last(self: Pairs<key, value>, key k: key) -> Option<value> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn get_last(self: Pairs<key, value>, key k: key) -> Option<value> {\n  when self is {\n    [] -> None\n    [Pair(k2, v), ..rest] ->\n      if k == k2 {\n        when get_last(rest, k) is {\n          None -> Some(v)\n          some -> some\n        }\n      } else {\n        get_last(rest, k)\n      }\n  }\n}",
      "tests": [
        "test get_last_1() {\n  get_last([], \"a\") == None\n}",
        "test get_last_2() {\n  get_last([Pair(\"a\", 1)], \"a\") == Some(1)\n}",
        "test get_last_3() {\n  get_last([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == Some(1)\n}",
        "test get_last_4() {\n  get_last([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == Some(3)\n}",
        "test get_last_5() {\n  get_last([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"c\", 3)], \"d\") == None\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.pairs.find_all",
      "fullName": "stdlib:aiken.collection.pairs.find_all",
      "name": "find_all",
      "signature": "pub fn find_all(self: Pairs<key, value>, v: value) -> List<key> {",
      "documentation": "Finds all keys in the alist associated with a given value.\n\n```aiken\npairs.find_all([], 1) == []\npairs.find_all([Pair(\"a\", 1)], 1) == [\"a\"]\npairs.find_all([Pair(\"a\", 1), Pair(\"b\", 2)], 1) == [\"a\"]\npairs.find_all([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"c\", 1)], 1) == [\"a\", \"c\"]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Pairs<key, value>",
          "optional": false
        },
        {
          "name": "v",
          "type": "value",
          "optional": false
        }
      ],
      "returnType": "List<key>",
      "line": 153,
      "raw": "pub fn find_all(self: Pairs<key, value>, v: value) -> List<key> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn find_all(self: Pairs<key, value>, v: value) -> List<key> {\n  when self is {\n    [] -> []\n    [Pair(k2, v2), ..rest] ->\n      if v == v2 {\n        [k2, ..find_all(rest, v)]\n      } else {\n        find_all(rest, v)\n      }\n  }\n}",
      "tests": [
        "test find_all_1() {\n  find_all([], \"a\") == []\n}",
        "test find_all_2() {\n  find_all([Pair(\"a\", 14)], 14) == [\"a\"]\n}",
        "test find_all_3() {\n  find_all([Pair(\"a\", 14)], 42) == []\n}",
        "test find_all_4() {\n  find_all([Pair(\"a\", 14), Pair(\"b\", 42), Pair(\"c\", 14)], 14) == [\"a\", \"c\"]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.pairs.find_first",
      "fullName": "stdlib:aiken.collection.pairs.find_first",
      "name": "find_first",
      "signature": "pub fn find_first(self: Pairs<key, value>, v: value) -> Option<key> {",
      "documentation": "Finds the first key in the alist associated with a given value, if any.\n\n```aiken\npairs.find_first([], 1) == None\npairs.find_first([Pair(\"a\", 1)], 1) == Some(\"a\")\npairs.find_first([Pair(\"a\", 1), Pair(\"b\", 2)], 1) == Some(\"a\")\npairs.find_first([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"c\", 1)], 1) == Some(\"a\")\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Pairs<key, value>",
          "optional": false
        },
        {
          "name": "v",
          "type": "value",
          "optional": false
        }
      ],
      "returnType": "Option<key>",
      "line": 189,
      "raw": "pub fn find_first(self: Pairs<key, value>, v: value) -> Option<key> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn find_first(self: Pairs<key, value>, v: value) -> Option<key> {\n  when self is {\n    [] -> None\n    [Pair(k2, v2), ..rest] ->\n      if v == v2 {\n        Some(k2)\n      } else {\n        find_first(rest, v)\n      }\n  }\n}",
      "tests": [
        "test find_first_1() {\n  find_first([], \"a\") == None\n}",
        "test find_first_2() {\n  find_first([Pair(\"a\", 14)], 14) == Some(\"a\")\n}",
        "test find_first_3() {\n  find_first([Pair(\"a\", 14)], 42) == None\n}",
        "test find_first_4() {\n  find_first([Pair(\"a\", 14), Pair(\"b\", 42), Pair(\"c\", 14)], 14) == Some(\"a\")\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.pairs.find_last",
      "fullName": "stdlib:aiken.collection.pairs.find_last",
      "name": "find_last",
      "signature": "pub fn find_last(self: Pairs<key, value>, v: value) -> Option<key> {",
      "documentation": "Finds the last key in the alist associated with a given value, if any.\n\n```aiken\npairs.find_last([], 1) == None\npairs.find_last([Pair(\"a\", 1)], 1) == Some(\"a\")\npairs.find_last([Pair(\"a\", 1), Pair(\"b\", 2)], 1) == Some(\"a\")\npairs.find_last([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"c\", 1)], 1) == Some(\"c\")\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Pairs<key, value>",
          "optional": false
        },
        {
          "name": "v",
          "type": "value",
          "optional": false
        }
      ],
      "returnType": "Option<key>",
      "line": 225,
      "raw": "pub fn find_last(self: Pairs<key, value>, v: value) -> Option<key> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn find_last(self: Pairs<key, value>, v: value) -> Option<key> {\n  when self is {\n    [] -> None\n    [Pair(k2, v2), ..rest] ->\n      if v == v2 {\n        when find_last(rest, v) is {\n          None -> Some(k2)\n          some -> some\n        }\n      } else {\n        find_last(rest, v)\n      }\n  }\n}",
      "tests": [
        "test find_last_1() {\n  find_last([], \"a\") == None\n}",
        "test find_last_2() {\n  find_last([Pair(\"a\", 14)], 14) == Some(\"a\")\n}",
        "test find_last_3() {\n  find_last([Pair(\"a\", 14)], 42) == None\n}",
        "test find_last_4() {\n  find_last([Pair(\"a\", 14), Pair(\"b\", 42), Pair(\"c\", 14)], 14) == Some(\"c\")\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.pairs.has_key",
      "fullName": "stdlib:aiken.collection.pairs.has_key",
      "name": "has_key",
      "signature": "pub fn has_key(self: Pairs<key, value>, k: key) -> Bool {",
      "documentation": "Check if a key exists in the pairs.\n\n```aiken\npairs.has_key([], \"a\") == False\npairs.has_key([Pair(\"a\", 1)], \"a\") == True\npairs.has_key([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == True\npairs.has_key([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == True\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Pairs<key, value>",
          "optional": false
        },
        {
          "name": "k",
          "type": "key",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 264,
      "raw": "pub fn has_key(self: Pairs<key, value>, k: key) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn has_key(self: Pairs<key, value>, k: key) -> Bool {\n  when self is {\n    [] -> False\n    // || is lazy so this is fine\n    [Pair(k2, _), ..rest] -> k == k2 || has_key(rest, k)\n  }\n}",
      "tests": [
        "test has_key_1() {\n  !has_key([], \"a\")\n}",
        "test has_key_2() {\n  has_key([Pair(\"a\", 14)], \"a\")\n}",
        "test has_key_3() {\n  !has_key([Pair(\"a\", 14)], \"b\")\n}",
        "test has_key_4() {\n  has_key([Pair(\"a\", 14), Pair(\"b\", 42)], \"b\")\n}",
        "test has_key_5() {\n  has_key([Pair(\"a\", 14), Pair(\"b\", 42), Pair(\"a\", 42)], \"a\")\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.pairs.keys",
      "fullName": "stdlib:aiken.collection.pairs.keys",
      "name": "keys",
      "signature": "pub fn keys(self: Pairs<key, value>) -> List<key> {",
      "documentation": "Extract all the keys present in a given `Pairs`.\n\n```aiken\npairs.keys([]) == []\npairs.keys([Pair(\"a\", 1)]) == [\"a\"]\npairs.keys([Pair(\"a\", 1), Pair(\"b\", 2)]) == [\"a\", \"b\"]\npairs.keys([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)]) == [\"a\", \"b\", \"a\"]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Pairs<key, value>",
          "optional": false
        }
      ],
      "returnType": "List<key>",
      "line": 300,
      "raw": "pub fn keys(self: Pairs<key, value>) -> List<key> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn keys(self: Pairs<key, value>) -> List<key> {\n  when self is {\n    [] -> []\n    [Pair(k, _), ..rest] -> [k, ..keys(rest)]\n  }\n}",
      "tests": [
        "test keys_1() {\n  keys([]) == []\n}",
        "test keys_2() {\n  keys([Pair(\"a\", 0)]) == [\"a\"]\n}",
        "test keys_3() {\n  keys([Pair(\"a\", 0), Pair(\"b\", 0)]) == [\"a\", \"b\"]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.pairs.values",
      "fullName": "stdlib:aiken.collection.pairs.values",
      "name": "values",
      "signature": "pub fn values(self: Pairs<key, value>) -> List<value> {",
      "documentation": "Extract all the values present in a given `Pairs`.\n\n```aiken\npairs.values([]) == []\npairs.values([Pair(\"a\", 1)]) == [1]\npairs.values([Pair(\"a\", 1), Pair(\"b\", 2)]) == [1, 2]\npairs.values([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)]) == [1, 2, 3]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Pairs<key, value>",
          "optional": false
        }
      ],
      "returnType": "List<value>",
      "line": 327,
      "raw": "pub fn values(self: Pairs<key, value>) -> List<value> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn values(self: Pairs<key, value>) -> List<value> {\n  when self is {\n    [] -> []\n    [Pair(_, v), ..rest] -> [v, ..values(rest)]\n  }\n}",
      "tests": [
        "test values_1() {\n  values([]) == []\n}",
        "test values_2() {\n  values([Pair(\"a\", 1)]) == [1]\n}",
        "test values_3() {\n  values([Pair(\"a\", 1), Pair(\"b\", 2)]) == [1, 2]\n}",
        "test values_4() {\n  values([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)]) == [1, 2, 3]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.pairs.delete_all",
      "fullName": "stdlib:aiken.collection.pairs.delete_all",
      "name": "delete_all",
      "signature": "pub fn delete_all(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {",
      "documentation": "Remove all key-value pairs matching the key from the Pairs. If the key is not found, no changes are made.\n\n```aiken\npairs.delete_all([], \"a\") == []\npairs.delete_all([Pair(\"a\", 1)], \"a\") == []\npairs.delete_all([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == [Pair(\"b\", 2)]\npairs.delete_all([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == [Pair(\"b\", 2)]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Pairs<key, value>",
          "optional": false
        }
      ],
      "returnType": "Pairs<key, value>",
      "line": 360,
      "raw": "pub fn delete_all(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn delete_all(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {\n  when self is {\n    [] -> []\n    [Pair(k2, v2), ..rest] ->\n      if k == k2 {\n        delete_all(rest, k)\n      } else {\n        [Pair(k2, v2), ..delete_all(rest, k)]\n      }\n  }\n}",
      "tests": [
        "test delete_all_1() {\n  delete_all([], \"a\") == []\n}",
        "test delete_all_2() {\n  delete_all([Pair(\"a\", 14)], \"a\") == []\n}",
        "test delete_all_3() {\n  let fixture = [Pair(\"a\", 14)]\n  delete_all(fixture, \"b\") == fixture\n}",
        "test delete_all_4() {\n  let fixture = [Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)]\n  delete_all(fixture, \"a\") == [Pair(\"b\", 2)]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.pairs.delete_first",
      "fullName": "stdlib:aiken.collection.pairs.delete_first",
      "name": "delete_first",
      "signature": "pub fn delete_first(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {",
      "documentation": "Remove a single key-value pair from the `Pairs`. If the key is not found, no changes are made.\nDuplicate keys are not deleted. Only the **first** key found is deleted.\n\n```aiken\npairs.delete_first([], \"a\") == []\npairs.delete_first([Pair(\"a\", 1)], \"a\") == []\npairs.delete_first([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == [Pair(\"b\", 2)]\npairs.delete_first([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == [Pair(\"b\", 2), Pair(\"a\", 3)]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Pairs<key, value>",
          "optional": false
        }
      ],
      "returnType": "Pairs<key, value>",
      "line": 399,
      "raw": "pub fn delete_first(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn delete_first(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {\n  when self is {\n    [] -> []\n    [Pair(k2, v2), ..rest] ->\n      if k == k2 {\n        rest\n      } else {\n        [Pair(k2, v2), ..delete_first(rest, k)]\n      }\n  }\n}",
      "tests": [
        "test delete_first_1() {\n  delete_first([], \"a\") == []\n}",
        "test delete_first_2() {\n  delete_first([Pair(\"a\", 14)], \"a\") == []\n}",
        "test delete_first_3() {\n  let fixture = [Pair(\"a\", 14)]\n  delete_first(fixture, \"b\") == fixture\n}",
        "test delete_first_4() {\n  let fixture = [Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)]\n  delete_first(fixture, \"a\") == [Pair(\"b\", 2), Pair(\"a\", 3)]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.pairs.delete_last",
      "fullName": "stdlib:aiken.collection.pairs.delete_last",
      "name": "delete_last",
      "signature": "pub fn delete_last(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {",
      "documentation": "Remove a single key-value pair from the Pairs. If the key is not found, no changes are made.\nDuplicate keys are not deleted. Only the **last** key found is deleted.\n\n```aiken\npairs.delete_last([], \"a\") == []\npairs.delete_last([Pair(\"a\", 1)], \"a\") == []\npairs.delete_last([Pair(\"a\", 1), Pair(\"b\", 2)], \"a\") == [Pair(\"b\", 2)]\npairs.delete_last([Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)], \"a\") == [Pair(\"a\", 1), Pair(\"b\", 2)]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Pairs<key, value>",
          "optional": false
        }
      ],
      "returnType": "Pairs<key, value>",
      "line": 438,
      "raw": "pub fn delete_last(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn delete_last(self: Pairs<key, value>, key k: key) -> Pairs<key, value> {\n  when self is {\n    [] -> []\n    [Pair(k2, v2), ..rest] ->\n      if k == k2 {\n        let tail = delete_last(rest, k)\n        if tail == rest {\n          rest\n        } else {\n          [Pair(k2, v2), ..tail]\n        }\n      } else {\n        [Pair(k2, v2), ..delete_last(rest, k)]\n      }\n  }\n}",
      "tests": [
        "test delete_last_1() {\n  delete_last([], \"a\") == []\n}",
        "test delete_last_2() {\n  delete_last([Pair(\"a\", 14)], \"a\") == []\n}",
        "test delete_last_3() {\n  let fixture = [Pair(\"a\", 14)]\n  delete_last(fixture, \"b\") == fixture\n}",
        "test delete_last_4() {\n  let fixture = [Pair(\"a\", 1), Pair(\"b\", 2), Pair(\"a\", 3)]\n  delete_last(fixture, \"a\") == [Pair(\"a\", 1), Pair(\"b\", 2)]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.pairs.insert_by_ascending_key",
      "fullName": "stdlib:aiken.collection.pairs.insert_by_ascending_key",
      "name": "insert_by_ascending_key",
      "signature": "pub fn insert_by_ascending_key(pub fn insert_by_ascending_key(self: Pairs<key, value>, key k: key, value v: value, compare: fn(key, key) -> Ordering,",
      "documentation": "Insert a value in the `Pairs` at a given key. If the key already exists,\nthe value is added in front.\n\n> [!CAUTION]\n> The list is only traversed up to the given key and the traversal\n> stops as soon as a higher key is encountered. Said differently, the list\n> is assumed to **be ordered by ascending keys**! If it is not, expect the\n> unexpected.\n\n```aiken\nuse aiken/primitive/bytearray\n\nlet result =\n[]\n|> pairs.insert_by_ascending_key(key: \"foo\", value: 1, compare: bytearray.compare)\n|> pairs.insert_by_ascending_key(key: \"bar\", value: 2, compare: bytearray.compare)\n|> pairs.insert_by_ascending_key(key: \"foo\", value: 3, compare: bytearray.compare)\n\nresult == [Pair(\"bar\", 2), Pair(\"foo\", 3), Pair(\"foo\", 1)]\n```",
      "parameters": [],
      "returnType": "Ordering,",
      "line": 493,
      "raw": "pub fn insert_by_ascending_key(pub fn insert_by_ascending_key(self: Pairs<key, value>, key k: key, value v: value, compare: fn(key, key) -> Ordering,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn insert_by_ascending_key(\n  self: Pairs<key, value>,\n  key k: key,\n  value v: value,\n  compare: fn(key, key) -> Ordering,\n) -> Pairs<key, value> {\n  when self is {\n    [] -> [Pair(k, v)]\n    [Pair(k2, v2), ..rest] ->\n      if compare(k, k2) == Less {\n        [Pair(k, v), ..self]\n      } else {\n        if k == k2 {\n          [Pair(k, v), ..self]\n        } else {\n          [Pair(k2, v2), ..insert_by_ascending_key(rest, k, v, compare)]\n        }\n      }\n  }\n}",
      "tests": [
        "test insert_by_ascending_key_1() {\n  let m =\n    []\n      |> insert_by_ascending_key(\"foo\", 42, bytearray.compare)\n      |> insert_by_ascending_key(\"foo\", 14, bytearray.compare)\n\n  m == [Pair(\"foo\", 14), Pair(\"foo\", 42)]\n}",
        "test insert_by_ascending_key_2() {\n  let m =\n    []\n      |> insert_by_ascending_key(\"foo\", 42, bytearray.compare)\n      |> insert_by_ascending_key(\"bar\", 14, bytearray.compare)\n      |> insert_by_ascending_key(\"baz\", 1337, bytearray.compare)\n\n  m == [Pair(\"bar\", 14), Pair(\"baz\", 1337), Pair(\"foo\", 42)]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.pairs.insert_with_by_ascending_key",
      "fullName": "stdlib:aiken.collection.pairs.insert_with_by_ascending_key",
      "name": "insert_with_by_ascending_key",
      "signature": "pub fn insert_with_by_ascending_key(pub fn insert_with_by_ascending_key(self: Pairs<key, value>, key k: key, value v: value, compare: fn(key, key) -> Ordering, with: fn(value, value) -> value,",
      "documentation": "Like [`insert_by_ascending_key`](#insert_by_ascending_key) but specifies\nhow to combine two values on a key conflict.\n\n> [!CAUTION]\n> The list is only traversed up to the given key and the traversal\n> stops as soon as a higher key is encountered. Said differently, the list\n> is assumed to **be ordered by ascending keys**! If it is not, expect the\n> unexpected.\n\n```aiken\nuse aiken/primitive/bytearray\n\nlet add_integer = fn(x, y) { x + y }\n\nlet result =\n[]\n|> pairs.insert_with_by_ascending_key(key: \"foo\", value: 1, compare: bytearray.compare, with: add_integer)\n|> pairs.insert_with_by_ascending_key(key: \"bar\", value: 2, compare: bytearray.compare, with: add_integer)\n|> pairs.insert_with_by_ascending_key(key: \"foo\", value: 3, compare: bytearray.compare, with: add_integer)\n\nresult == [Pair(\"bar\", 2), Pair(\"foo\", 4)]\n```",
      "parameters": [],
      "returnType": "Ordering, with: fn(value, value) -> value,",
      "line": 555,
      "raw": "pub fn insert_with_by_ascending_key(pub fn insert_with_by_ascending_key(self: Pairs<key, value>, key k: key, value v: value, compare: fn(key, key) -> Ordering, with: fn(value, value) -> value,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn insert_with_by_ascending_key(\n  self: Pairs<key, value>,\n  key k: key,\n  value v: value,\n  compare: fn(key, key) -> Ordering,\n  with: fn(value, value) -> value,\n) -> Pairs<key, value> {\n  when self is {\n    [] -> [Pair(k, v)]\n    [Pair(k2, v2), ..rest] ->\n      if compare(k, k2) == Less {\n        [Pair(k, v), ..self]\n      } else {\n        if k == k2 {\n          [Pair(k, with(v, v2)), ..rest]\n        } else {\n          [\n            Pair(k2, v2),\n            ..insert_with_by_ascending_key(rest, k, v, compare, with)\n          ]\n        }\n      }\n  }\n}",
      "tests": [
        "test insert_with_by_ascending_key_1() {\n  let compare_un_b_data =\n    fn(l, r) {\n      bytearray.compare(l |> builtin.un_b_data, r |> builtin.un_b_data)\n    }\n\n  let m =\n    []\n      |> insert_with_by_ascending_key(\n          \"foo\" |> builtin.b_data,\n          42,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n      |> insert_with_by_ascending_key(\n          \"foo\" |> builtin.b_data,\n          14,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n\n  m == [Pair(\"foo\" |> builtin.b_data, 56)]\n}",
        "test insert_with_by_ascending_key_2() {\n  let compare_un_b_data =\n    fn(l, r) {\n      bytearray.compare(l |> builtin.un_b_data, r |> builtin.un_b_data)\n    }\n\n  let m =\n    []\n      |> insert_with_by_ascending_key(\n          \"foo\" |> builtin.b_data,\n          42,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n      |> insert_with_by_ascending_key(\n          \"bar\" |> builtin.b_data,\n          14,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n      |> insert_with_by_ascending_key(\n          \"baz\" |> builtin.b_data,\n          1337,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n\n  m == [\n    Pair(\"bar\" |> builtin.b_data, 14),\n    Pair(\"baz\" |> builtin.b_data, 1337),\n    Pair(\"foo\" |> builtin.b_data, 42),\n  ]\n}",
        "test insert_with_by_ascending_key_3() {\n  let compare_un_b_data =\n    fn(l, r) {\n      bytearray.compare(l |> builtin.un_b_data, r |> builtin.un_b_data)\n    }\n\n  let result =\n    []\n      |> insert_with_by_ascending_key(\n          \"foo\" |> builtin.b_data,\n          1,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n      |> insert_with_by_ascending_key(\n          \"bar\" |> builtin.b_data,\n          2,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n      |> insert_with_by_ascending_key(\n          \"foo\" |> builtin.b_data,\n          3,\n          compare_un_b_data,\n          builtin.add_integer,\n        )\n\n  result == [Pair(\"bar\" |> builtin.b_data, 2), Pair(\"foo\" |> builtin.b_data, 4)]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.pairs.map",
      "fullName": "stdlib:aiken.collection.pairs.map",
      "name": "map",
      "signature": "pub fn map(pub fn map(self: Pairs<key, value>, with: fn(key, value) -> result,",
      "documentation": "Apply a function to all key-value pairs in a alist, replacing the values.\n\n```aiken\nlet fixture = [Pair(\"a\", 100), Pair(\"b\", 200)]\n\npairs.map(fixture, fn(_k, v) { v * 2 }) == [Pair(\"a\", 200), Pair(\"b\", 400)]\n```",
      "parameters": [],
      "returnType": "result,",
      "line": 675,
      "raw": "pub fn map(pub fn map(self: Pairs<key, value>, with: fn(key, value) -> result,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn map(\n  self: Pairs<key, value>,\n  with: fn(key, value) -> result,\n) -> Pairs<key, result> {\n  when self is {\n    [] -> []\n    [Pair(k, v), ..rest] -> [Pair(k, with(k, v)), ..map(rest, with)]\n  }\n}",
      "tests": [
        "test map_1() {\n  let fixture = [Pair(\"a\", 1), Pair(\"b\", 2)]\n\n  map(fixture, with: fn(k, _) { k }) == [Pair(\"a\", \"a\"), Pair(\"b\", \"b\")]\n}",
        "test map_2() {\n  let fixture = [Pair(\"a\", 1), Pair(\"b\", 2)]\n\n  map(fixture, with: fn(_, v) { v + 1 }) == [Pair(\"a\", 2), Pair(\"b\", 3)]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.pairs.repsert_by_ascending_key",
      "fullName": "stdlib:aiken.collection.pairs.repsert_by_ascending_key",
      "name": "repsert_by_ascending_key",
      "signature": "pub fn repsert_by_ascending_key(pub fn repsert_by_ascending_key(self: Pairs<key, value>, key k: key, value v: value, compare: fn(key, key) -> Ordering,",
      "documentation": "Insert a value in the `Pairs` at a given key. If the key already exists,\nits value is replaced.\n\n> [!CAUTION]\n> The list is only traversed up to the given key and the traversal\n> stops as soon as a higher key is encountered. Said differently, the list\n> is assumed to **be ordered by ascending keys**! If it is not, expect the\n> unexpected.\n\n```aiken\nuse aiken/primitive/bytearray\n\nlet result =\n[]\n|> pairs.repsert_by_ascending_key(key: \"foo\", value: 1, compare: bytearray.compare)\n|> pairs.repsert_by_ascending_key(key: \"bar\", value: 2, compare: bytearray.compare)\n|> pairs.repsert_by_ascending_key(key: \"foo\", value: 3, compare: bytearray.compare)\n\nresult == [Pair(\"bar\", 2), Pair(\"foo\", 3)]\n```",
      "parameters": [],
      "returnType": "Ordering,",
      "line": 717,
      "raw": "pub fn repsert_by_ascending_key(pub fn repsert_by_ascending_key(self: Pairs<key, value>, key k: key, value v: value, compare: fn(key, key) -> Ordering,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn repsert_by_ascending_key(\n  self: Pairs<key, value>,\n  key k: key,\n  value v: value,\n  compare: fn(key, key) -> Ordering,\n) -> Pairs<key, value> {\n  when self is {\n    [] -> [Pair(k, v)]\n    [Pair(k2, v2), ..rest] ->\n      if compare(k, k2) == Less {\n        [Pair(k, v), ..self]\n      } else {\n        if k == k2 {\n          [Pair(k, v), ..rest]\n        } else {\n          [Pair(k2, v2), ..repsert_by_ascending_key(rest, k, v, compare)]\n        }\n      }\n  }\n}",
      "tests": [
        "test repsert_by_ascending_key_1() {\n  let m =\n    []\n      |> repsert_by_ascending_key(\"foo\", 42, bytearray.compare)\n      |> repsert_by_ascending_key(\"foo\", 14, bytearray.compare)\n\n  m == [Pair(\"foo\", 14)]\n}",
        "test repsert_by_ascending_key_2() {\n  let m =\n    []\n      |> repsert_by_ascending_key(\"foo\", 42, bytearray.compare)\n      |> repsert_by_ascending_key(\"bar\", 14, bytearray.compare)\n      |> repsert_by_ascending_key(\"baz\", 1337, bytearray.compare)\n\n  m == [Pair(\"bar\", 14), Pair(\"baz\", 1337), Pair(\"foo\", 42)]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.pairs.foldl",
      "fullName": "stdlib:aiken.collection.pairs.foldl",
      "name": "foldl",
      "signature": "pub fn foldl(pub fn foldl(self: Pairs<key, value>, zero: result, with: fn(key, value, result) -> result,",
      "documentation": "Fold over the key-value pairs in a pairs. The fold direction follows keys\nin ascending order and is done from left-to-right.\n\n```aiken\nlet fixture = [\nPair(1, 100),\nPair(2, 200),\nPair(3, 300),\n]\n\npairs.foldl(fixture, 0, fn(k, v, result) { k * v + result }) == 1400\n```",
      "parameters": [],
      "returnType": "result,",
      "line": 771,
      "raw": "pub fn foldl(pub fn foldl(self: Pairs<key, value>, zero: result, with: fn(key, value, result) -> result,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn foldl(\n  self: Pairs<key, value>,\n  zero: result,\n  with: fn(key, value, result) -> result,\n) -> result {\n  when self is {\n    [] -> zero\n    [Pair(k, v), ..rest] -> foldl(rest, with(k, v, zero), with)\n  }\n}",
      "tests": [
        "test foldl_1() {\n  foldl([], 14, fn(_, _, _) { 42 }) == 14\n}",
        "test foldl_2() {\n  foldl(\n    [Pair(\"a\", 42), Pair(\"b\", 14)],\n    zero: 0,\n    with: fn(_, v, total) { v + total },\n  ) == 56\n}"
      ]
    },
    {
      "key": "stdlib:aiken.collection.pairs.foldr",
      "fullName": "stdlib:aiken.collection.pairs.foldr",
      "name": "foldr",
      "signature": "pub fn foldr(pub fn foldr(self: Pairs<key, value>, zero: result, with: fn(key, value, result) -> result,",
      "documentation": "Fold over the key-value pairs in a Pairs. The fold direction follows the\norder of elements in the Pairs and is done from right-to-left.\n\n```aiken\nlet fixture = [\nPair(1, 100),\nPair(2, 200),\nPair(3, 300),\n]\n\npairs.foldr(fixture, 0, fn(k, v, result) { k * v + result }) == 1400\n```",
      "parameters": [],
      "returnType": "result,",
      "line": 806,
      "raw": "pub fn foldr(pub fn foldr(self: Pairs<key, value>, zero: result, with: fn(key, value, result) -> result,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn foldr(\n  self: Pairs<key, value>,\n  zero: result,\n  with: fn(key, value, result) -> result,\n) -> result {\n  when self is {\n    [] -> zero\n    [Pair(k, v), ..rest] -> with(k, v, foldr(rest, zero, with))\n  }\n}",
      "tests": [
        "test foldr_1() {\n  foldr([], 14, fn(_, _, _) { 42 }) == 14\n}",
        "test foldr_2() {\n  foldr(\n    [Pair(\"a\", 42), Pair(\"b\", 14)],\n    zero: 0,\n    with: fn(_, v, total) { v + total },\n  ) == 56\n}",
        "test foldr_3() {\n  let fixture = [Pair(1, 100), Pair(2, 200), Pair(3, 300)]\n\n  foldr(fixture, 0, fn(k, v, result) { k * v + result }) == 1400\n}"
      ]
    },
    {
      "key": "stdlib:aiken.crypto.bitwise.add_bits",
      "fullName": "stdlib:aiken.crypto.bitwise.add_bits",
      "name": "add_bits",
      "signature": "pub fn add_bits(field: Int, big_endian: Bool) {",
      "parameters": [
        {
          "name": "field",
          "type": "Int",
          "optional": false
        },
        {
          "name": "big_endian",
          "type": "Bool",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 13,
      "raw": "pub fn add_bits(field: Int, big_endian: Bool) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn add_bits(field: Int, big_endian: Bool) {\n  fn(state: State<t>, bytes: ByteArray) -> State<t> {\n    builtin.bytearray_to_integer(big_endian, bytes)\n      |> builtin.add_integer(state.inner, _)\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bitwise.add_int",
      "fullName": "stdlib:aiken.crypto.bitwise.add_int",
      "name": "add_int",
      "signature": "pub fn add_int(field: Int) {",
      "parameters": [
        {
          "name": "field",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 22,
      "raw": "pub fn add_int(field: Int) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn add_int(field: Int) {\n  fn(state: State<t>, int: Int) -> State<t> {\n    state.inner + int\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bitwise.add_state",
      "fullName": "stdlib:aiken.crypto.bitwise.add_state",
      "name": "add_state",
      "signature": "pub fn add_state(field: Int) {",
      "parameters": [
        {
          "name": "field",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 30,
      "raw": "pub fn add_state(field: Int) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn add_state(field: Int) {\n  fn(state: State<t>, other: State<t>) -> State<t> {\n    state.inner + other.inner\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bitwise.sub_bits",
      "fullName": "stdlib:aiken.crypto.bitwise.sub_bits",
      "name": "sub_bits",
      "signature": "pub fn sub_bits(field: Int, big_endian: Bool) {",
      "parameters": [
        {
          "name": "field",
          "type": "Int",
          "optional": false
        },
        {
          "name": "big_endian",
          "type": "Bool",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 38,
      "raw": "pub fn sub_bits(field: Int, big_endian: Bool) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sub_bits(field: Int, big_endian: Bool) {\n  fn(state: State<t>, bytes: ByteArray) -> State<t> {\n    builtin.bytearray_to_integer(big_endian, bytes)\n      |> builtin.subtract_integer(state.inner, _)\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bitwise.sub_int",
      "fullName": "stdlib:aiken.crypto.bitwise.sub_int",
      "name": "sub_int",
      "signature": "pub fn sub_int(field: Int) {",
      "parameters": [
        {
          "name": "field",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 47,
      "raw": "pub fn sub_int(field: Int) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sub_int(field: Int) {\n  fn(state: State<t>, int: Int) -> State<t> {\n    state.inner - int\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bitwise.sub_state",
      "fullName": "stdlib:aiken.crypto.bitwise.sub_state",
      "name": "sub_state",
      "signature": "pub fn sub_state(field: Int) {",
      "parameters": [
        {
          "name": "field",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 55,
      "raw": "pub fn sub_state(field: Int) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sub_state(field: Int) {\n  fn(state: State<t>, other: State<t>) -> State<t> {\n    state.inner - other.inner\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bitwise.mul_bits",
      "fullName": "stdlib:aiken.crypto.bitwise.mul_bits",
      "name": "mul_bits",
      "signature": "pub fn mul_bits(field: Int, big_endian: Bool) {",
      "parameters": [
        {
          "name": "field",
          "type": "Int",
          "optional": false
        },
        {
          "name": "big_endian",
          "type": "Bool",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 63,
      "raw": "pub fn mul_bits(field: Int, big_endian: Bool) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn mul_bits(field: Int, big_endian: Bool) {\n  fn(state: State<t>, bytes: ByteArray) -> State<t> {\n    builtin.bytearray_to_integer(big_endian, bytes)\n      |> builtin.multiply_integer(state.inner, _)\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bitwise.mul_int",
      "fullName": "stdlib:aiken.crypto.bitwise.mul_int",
      "name": "mul_int",
      "signature": "pub fn mul_int(field: Int) {",
      "parameters": [
        {
          "name": "field",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 72,
      "raw": "pub fn mul_int(field: Int) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn mul_int(field: Int) {\n  fn(state: State<t>, int: Int) -> State<t> {\n    state.inner * int\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bitwise.mul_state",
      "fullName": "stdlib:aiken.crypto.bitwise.mul_state",
      "name": "mul_state",
      "signature": "pub fn mul_state(field: Int) {",
      "parameters": [
        {
          "name": "field",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 80,
      "raw": "pub fn mul_state(field: Int) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn mul_state(field: Int) {\n  fn(state: State<t>, other: State<t>) -> State<t> {\n    state.inner * other.inner\n      |> builtin.mod_integer(field)\n      |> State\n  }\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bitwise.scale",
      "fullName": "stdlib:aiken.crypto.bitwise.scale",
      "name": "scale",
      "signature": "pub fn scale(pub fn scale(self: State<t>, e: Int, mul: fn(State<t>, State<t>) -> State<t>,",
      "parameters": [],
      "returnType": "State<t>,",
      "line": 88,
      "raw": "pub fn scale(pub fn scale(self: State<t>, e: Int, mul: fn(State<t>, State<t>) -> State<t>,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn scale(\n  self: State<t>,\n  e: Int,\n  mul: fn(State<t>, State<t>) -> State<t>,\n) -> State<t> {\n  if e < 0 {\n    zero\n  } else if e == 0 {\n    one\n  } else if e % 2 == 0 {\n    scale(mul(self, self), e / 2, mul)\n  } else {\n    mul(self, scale(mul(self, self), ( e - 1 ) / 2, mul))\n  }\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bitwise.scale2",
      "fullName": "stdlib:aiken.crypto.bitwise.scale2",
      "name": "scale2",
      "signature": "pub fn scale2(self: State<t>, k: Int, mul: fn(State<t>, State<t>) -> State<t>) {",
      "documentation": "A faster version of `scale` for the case where the exponent is a power of two.\nThat is, the exponent $e = 2^k$ for some non-negative integer $k$. Which is used a lot in zk-SNARKs.",
      "parameters": [
        {
          "name": "self",
          "type": "State<t>",
          "optional": false
        },
        {
          "name": "k",
          "type": "Int",
          "optional": false
        },
        {
          "name": "mul",
          "type": "fn(State<t>, State<t>",
          "optional": false
        }
      ],
      "returnType": "State<t>)",
      "line": 106,
      "raw": "pub fn scale2(self: State<t>, k: Int, mul: fn(State<t>, State<t>) -> State<t>) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn scale2(self: State<t>, k: Int, mul: fn(State<t>, State<t>) -> State<t>) {\n  if k < 0 {\n    zero\n  } else {\n    do_scale2(self, k, mul)\n  }\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bitwise.neg",
      "fullName": "stdlib:aiken.crypto.bitwise.neg",
      "name": "neg",
      "signature": "pub fn neg(field: Int) {",
      "parameters": [
        {
          "name": "field",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 122,
      "raw": "pub fn neg(field: Int) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn neg(field: Int) {\n  fn(state: State<t>) -> State<t> {\n    ( field - state.inner ) % field\n      |> State\n  }\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bitwise.to_int",
      "fullName": "stdlib:aiken.crypto.bitwise.to_int",
      "name": "to_int",
      "signature": "pub fn to_int(state: State<t>) -> Int {",
      "parameters": [
        {
          "name": "state",
          "type": "State<t>",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 129,
      "raw": "pub fn to_int(state: State<t>) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn to_int(state: State<t>) -> Int {\n  state.inner\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bitwise.from_int",
      "fullName": "stdlib:aiken.crypto.bitwise.from_int",
      "name": "from_int",
      "signature": "pub fn from_int(int: Int, field: Int) -> State<t> {",
      "parameters": [
        {
          "name": "int",
          "type": "Int",
          "optional": false
        },
        {
          "name": "field",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "State<t>",
      "line": 133,
      "raw": "pub fn from_int(int: Int, field: Int) -> State<t> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_int(int: Int, field: Int) -> State<t> {\n  int % field\n    |> State\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.g1.compress",
      "fullName": "stdlib:aiken.crypto.bls12_381.g1.compress",
      "name": "compress",
      "signature": "pub fn compress(point) {",
      "documentation": "Compresses a point in the G1 group into a more compact representation.\nThe compressed representation is a 48-byte string, corresponding to a modified `x` coordinate.\nThe leading most significant 3 bits of this string indicate how to reconstruct the `y` coordinate.\n\n> [!NOTE]\n> More explicitly via [Zcash's spec](https://github.com/supranational/blst#serialization-format):\n>\n> <i>The most-significant three bits of a G1 or G2 encoding should be masked away before the coordinate(s) are interpreted. These bits are used to unambiguously represent the underlying element:\n>\n> - The most significant bit, when set, indicates that the point is in compressed form. Otherwise, the point is in uncompressed form.\n> - The second-most significant bit indicates that the point is at infinity. If this bit is set, the remaining bits of the group element's encoding should be set to zero.\n> - The third-most significant bit is set if (and only if) this point is in compressed form and it is not the point at infinity and its y-coordinate is the lexicographically largest of the two associated with the encoded x-coordinate.</i>",
      "parameters": [
        {
          "name": "point",
          "type": "Unknown",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 60,
      "raw": "pub fn compress(point) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn compress(point) {\n  builtin.bls12_381_g1_compress(point)\n}",
      "tests": [
        "test compress_1() {\n  compress(\n    #<Bls12_381, G1>\"97f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb\",\n  ) == #\"97f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb\"\n}"
      ]
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.g1.decompress",
      "fullName": "stdlib:aiken.crypto.bls12_381.g1.decompress",
      "name": "decompress",
      "signature": "pub fn decompress(bytes) {",
      "documentation": "Decompresses a point in the G1 group from its compressed form.",
      "parameters": [
        {
          "name": "bytes",
          "type": "Unknown",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 71,
      "raw": "pub fn decompress(bytes) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn decompress(bytes) {\n  builtin.bls12_381_g1_uncompress(bytes)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.g1.equal",
      "fullName": "stdlib:aiken.crypto.bls12_381.g1.equal",
      "name": "equal",
      "signature": "pub fn equal(left, right) {",
      "parameters": [
        {
          "name": "left",
          "type": "Unknown",
          "optional": false
        },
        {
          "name": "right",
          "type": "Unknown",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 75,
      "raw": "pub fn equal(left, right) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn equal(left, right) {\n  builtin.bls12_381_g1_equal(left, right)\n}",
      "tests": ["test equal_1() {\n  equal(generator, generator)\n}"]
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.g1.add",
      "fullName": "stdlib:aiken.crypto.bls12_381.g1.add",
      "name": "add",
      "signature": "pub fn add(left, right) {",
      "documentation": "Adds two points in the G1 group.",
      "parameters": [
        {
          "name": "left",
          "type": "Unknown",
          "optional": false
        },
        {
          "name": "right",
          "type": "Unknown",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 84,
      "raw": "pub fn add(left, right) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn add(left, right) {\n  builtin.bls12_381_g1_add(left, right)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.g1.sub",
      "fullName": "stdlib:aiken.crypto.bls12_381.g1.sub",
      "name": "sub",
      "signature": "pub fn sub(left, right) {",
      "documentation": "Subtracts one point in the G1 group from another.",
      "parameters": [
        {
          "name": "left",
          "type": "Unknown",
          "optional": false
        },
        {
          "name": "right",
          "type": "Unknown",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 89,
      "raw": "pub fn sub(left, right) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sub(left, right) {\n  builtin.bls12_381_g1_add(left, builtin.bls12_381_g1_neg(right))\n}",
      "tests": [
        "test sub_1() {\n  generator == sub(add(generator, generator), generator)\n}"
      ]
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.g1.scale",
      "fullName": "stdlib:aiken.crypto.bls12_381.g1.scale",
      "name": "scale",
      "signature": "pub fn scale(point, e: State<Scalar>) {",
      "documentation": "Exponentiates a point in the G1 group with a `scalar`.\nThis operation is equivalent to the repeated addition of the point with itself `e` times.",
      "parameters": [
        {
          "name": "point",
          "type": "Unknown",
          "optional": false
        },
        {
          "name": "e",
          "type": "State<Scalar>",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 99,
      "raw": "pub fn scale(point, e: State<Scalar>) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn scale(point, e: State<Scalar>) {\n  builtin.bls12_381_g1_scalar_mul(scalar.to_int(e), point)\n}",
      "tests": [
        "test scale_1() {\n  let x = scalar.from_int(2)\n  builtin.bls12_381_g1_add(generator, generator) == scale(generator, x)\n}"
      ]
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.g1.hash_to_group",
      "fullName": "stdlib:aiken.crypto.bls12_381.g1.hash_to_group",
      "name": "hash_to_group",
      "signature": "pub fn hash_to_group(bytes: ByteArray, domain_separation_tag: ByteArray) {",
      "documentation": "Hashes arbitrary data to a point in the G1 group.\nYou can use the `domain_separation_tag` parameter to cryptographically separate different uses of the hash function between applications.",
      "parameters": [
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "domain_separation_tag",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 110,
      "raw": "pub fn hash_to_group(bytes: ByteArray, domain_separation_tag: ByteArray) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn hash_to_group(bytes: ByteArray, domain_separation_tag: ByteArray) {\n  builtin.bls12_381_g1_hash_to_group(bytes, domain_separation_tag)\n}",
      "tests": [
        "test hash_to_group_1() {\n  hash_to_group(\"hello\", \"world\") == #<Bls12_381, G1>\"89223b03c629cc6bcbbdccbba46b6679bc6a79db82f2d3bd115899a45a5a38c391587b59d3d1e297f977d1c4ee9e3388\"\n}"
      ]
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.g2.compress",
      "fullName": "stdlib:aiken.crypto.bls12_381.g2.compress",
      "name": "compress",
      "signature": "pub fn compress(point) {",
      "documentation": "Compresses a point in the G2 group into a more compact representation.\nThe compressed representation is the concatenation of two 48-byte strings, corresponding to a modified and complexified `x` coordinate.\nThe leading most significant 3 bits of this string indicate how to reconstruct the `y` coordinate.\n\n> [!NOTE]\n> More explicitly via [Zcash's spec](https://github.com/supranational/blst#serialization-format):\n>\n> <i>The most-significant three bits of a G1 or G2 encoding should be masked away before the coordinate(s) are interpreted. These bits are used to unambiguously represent the underlying element:\n>\n> - The most significant bit, when set, indicates that the point is in compressed form. Otherwise, the point is in uncompressed form.\n> - The second-most significant bit indicates that the point is at infinity. If this bit is set, the remaining bits of the group element's encoding should be set to zero.\n> - The third-most significant bit is set if (and only if) this point is in compressed form and it is not the point at infinity and its y-coordinate is the lexicographically largest of the two associated with the encoded x-coordinate.</i>",
      "parameters": [
        {
          "name": "point",
          "type": "Unknown",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 60,
      "raw": "pub fn compress(point) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn compress(point) {\n  builtin.bls12_381_g2_compress(point)\n}",
      "tests": [
        "test compress_1() {\n  let g2 =\n    #<Bls12_381, G2>\"93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8\"\n  compress(g2) == #\"93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8\"\n}"
      ]
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.g2.decompress",
      "fullName": "stdlib:aiken.crypto.bls12_381.g2.decompress",
      "name": "decompress",
      "signature": "pub fn decompress(bytes) {",
      "documentation": "Decompresses a point in the G2 group from its compressed form.",
      "parameters": [
        {
          "name": "bytes",
          "type": "Unknown",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 71,
      "raw": "pub fn decompress(bytes) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn decompress(bytes) {\n  builtin.bls12_381_g2_uncompress(bytes)\n}",
      "tests": [
        "test decompress_1() {\n  let g2 =\n    #<Bls12_381, G2>\"93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8\"\n  generator == g2\n}"
      ]
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.g2.equal",
      "fullName": "stdlib:aiken.crypto.bls12_381.g2.equal",
      "name": "equal",
      "signature": "pub fn equal(left, right) {",
      "parameters": [
        {
          "name": "left",
          "type": "Unknown",
          "optional": false
        },
        {
          "name": "right",
          "type": "Unknown",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 81,
      "raw": "pub fn equal(left, right) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn equal(left, right) {\n  builtin.bls12_381_g2_equal(left, right)\n}",
      "tests": [
        "test equal_1() {\n  equal(\n    generator,\n    #<Bls12_381, G2>\"93e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8\",\n  )\n}"
      ]
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.g2.add",
      "fullName": "stdlib:aiken.crypto.bls12_381.g2.add",
      "name": "add",
      "signature": "pub fn add(left, right) {",
      "documentation": "Adds two points in the G2 group.",
      "parameters": [
        {
          "name": "left",
          "type": "Unknown",
          "optional": false
        },
        {
          "name": "right",
          "type": "Unknown",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 93,
      "raw": "pub fn add(left, right) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn add(left, right) {\n  builtin.bls12_381_g2_add(left, right)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.g2.sub",
      "fullName": "stdlib:aiken.crypto.bls12_381.g2.sub",
      "name": "sub",
      "signature": "pub fn sub(left, right) {",
      "documentation": "Subtracts one point in the G2 group from another.",
      "parameters": [
        {
          "name": "left",
          "type": "Unknown",
          "optional": false
        },
        {
          "name": "right",
          "type": "Unknown",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 98,
      "raw": "pub fn sub(left, right) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sub(left, right) {\n  builtin.bls12_381_g2_add(left, builtin.bls12_381_g2_neg(right))\n}",
      "tests": [
        "test sub_1() {\n  generator == sub(add(generator, generator), generator)\n}"
      ]
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.g2.scale",
      "fullName": "stdlib:aiken.crypto.bls12_381.g2.scale",
      "name": "scale",
      "signature": "pub fn scale(point, e: State<Scalar>) {",
      "documentation": "Exponentiates a point in the G2 group with a `scalar`.\nThis operation is equivalent to the repeated addition of the point with itself `e` times.",
      "parameters": [
        {
          "name": "point",
          "type": "Unknown",
          "optional": false
        },
        {
          "name": "e",
          "type": "State<Scalar>",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 108,
      "raw": "pub fn scale(point, e: State<Scalar>) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn scale(point, e: State<Scalar>) {\n  builtin.bls12_381_g2_scalar_mul(scalar.to_int(e), point)\n}",
      "tests": [
        "test scale_1() {\n  let x = scalar.from_int(2)\n  builtin.bls12_381_g2_add(generator, generator) == scale(generator, x)\n}"
      ]
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.g2.hash_to_group",
      "fullName": "stdlib:aiken.crypto.bls12_381.g2.hash_to_group",
      "name": "hash_to_group",
      "signature": "pub fn hash_to_group(bytes, domain_separation_tag) {",
      "documentation": "Hashes arbitrary data to a point in the G2 group.\nYou can use the `domain_separation_tag` parameter to cryptographically separate different uses of the hash function between applications.",
      "parameters": [
        {
          "name": "bytes",
          "type": "Unknown",
          "optional": false
        },
        {
          "name": "domain_separation_tag",
          "type": "Unknown",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 119,
      "raw": "pub fn hash_to_group(bytes, domain_separation_tag) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn hash_to_group(bytes, domain_separation_tag) {\n  builtin.bls12_381_g2_hash_to_group(bytes, domain_separation_tag)\n}",
      "tests": [
        "test hash_to_group_1() {\n  hash_to_group(\"hello\", \"world\") == #<Bls12_381, G2>\"a18486bba1dc8321f4998ed4268c6df8dfa5618dd5c91595844059d517f8104bf8031d3e766f9c99db1d6f58b201ee9614de92fc08f9e5cc3a6cd814e871857cb6e3924e8a4fa48775116c5f158d58ceda63614d62f6b7bc47db798d656969a5\"\n}"
      ]
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.from_bytes",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.from_bytes",
      "name": "from_bytes",
      "signature": "pub fn from_bytes(b: ByteArray) -> State<Scalar> {",
      "documentation": "Constructs a new `Scalar` element from a Big-Endian (most-significant bits first) `ByteArray`.",
      "parameters": [
        {
          "name": "b",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "State<Scalar>",
      "line": 37,
      "raw": "pub fn from_bytes(b: ByteArray) -> State<Scalar> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_bytes(b: ByteArray) -> State<Scalar> {\n  b\n    |> builtin.bytearray_to_integer(True, _)\n    |> bitwise.from_int(field_prime)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.from_bytes_little_endian",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.from_bytes_little_endian",
      "name": "from_bytes_little_endian",
      "signature": "pub fn from_bytes_little_endian(bytes: ByteArray) -> State<Scalar> {",
      "documentation": "Constructs a new `Scalar` element from a Little-Endian (least-significant bits first) `ByteArray`.",
      "parameters": [
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "State<Scalar>",
      "line": 44,
      "raw": "pub fn from_bytes_little_endian(bytes: ByteArray) -> State<Scalar> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_bytes_little_endian(bytes: ByteArray) -> State<Scalar> {\n  bytes\n    |> builtin.bytearray_to_integer(False, _)\n    |> bitwise.from_int(field_prime)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.from_int",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.from_int",
      "name": "from_int",
      "signature": "pub fn from_int(n: Int) -> State<Scalar> {",
      "documentation": "Constructs a new `Scalar` element from an integer, ensuring it's within the valid range of the field.",
      "parameters": [
        {
          "name": "n",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "State<Scalar>",
      "line": 51,
      "raw": "pub fn from_int(n: Int) -> State<Scalar> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_int(n: Int) -> State<Scalar> {\n  bitwise.from_int(n, field_prime)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.scale",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.scale",
      "name": "scale",
      "signature": "pub fn scale(self: State<Scalar>, e: Int) -> State<Scalar> {",
      "documentation": "Exponentiates an `Scalar` element by a non-negative integer exponent, using repeated squaring.\nNote that this function returns `scalar.zero` for negative exponents.\nA dedicated builtin function for this is in the making, see CIP 109.",
      "parameters": [
        {
          "name": "self",
          "type": "State<Scalar>",
          "optional": false
        },
        {
          "name": "e",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "State<Scalar>",
      "line": 86,
      "raw": "pub fn scale(self: State<Scalar>, e: Int) -> State<Scalar> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn scale(self: State<Scalar>, e: Int) -> State<Scalar> {\n  bitwise.scale(self, e, mul)\n}",
      "tests": [
        "test scale_1() {\n  let x = from_int(834884848)\n\n  and {\n    ( x |> scale(-1) ) == zero,\n    ( x |> scale(0) ) == one,\n    ( x |> scale(1) ) == x,\n    ( x |> scale(2) |> to_int ) == 697032709419983104,\n    ( x |> scale(3) |> to_int ) == 581942047655130761945608192,\n    (\n      from_int(field_prime - 4)\n        |> scale(200)\n        |> to_int\n    ) == 12843927705572658539565969578937286576443167978938369866871449552629978143484,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.scale2",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.scale2",
      "name": "scale2",
      "signature": "pub fn scale2(self: State<Scalar>, k: Int) -> State<Scalar> {",
      "documentation": "A faster version of `scale` for the case where the exponent is a power of two.\nThat is, the exponent `e = 2^k` for some non-negative integer `k`. Which is used alot in zk-SNARKs.",
      "parameters": [
        {
          "name": "self",
          "type": "State<Scalar>",
          "optional": false
        },
        {
          "name": "k",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "State<Scalar>",
      "line": 109,
      "raw": "pub fn scale2(self: State<Scalar>, k: Int) -> State<Scalar> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn scale2(self: State<Scalar>, k: Int) -> State<Scalar> {\n  bitwise.scale2(self, k, mul)\n}",
      "tests": [
        "test scale2_1() {\n  let x = from_int(834884848)\n\n  and {\n    scale2(x, -1) == zero,\n    scale2(x, 0) == scale(x, 1),\n    scale2(x, 1) == scale(x, 2),\n    scale2(x, 2) == scale(x, 4),\n    scale2(x, 3) == scale(x, 8),\n    scale2(x, 4) == scale(x, 16),\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.add",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.add",
      "name": "add",
      "signature": "pub fn add(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {",
      "documentation": "Adds two `Scalar` elements, ensuring the result stays within the finite field range.",
      "parameters": [
        {
          "name": "left",
          "type": "State<Scalar>",
          "optional": false
        },
        {
          "name": "right",
          "type": "State<Scalar>",
          "optional": false
        }
      ],
      "returnType": "State<Scalar>",
      "line": 131,
      "raw": "pub fn add(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn add(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {\n  add_s_scalar(left, right)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.add_bytes",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.add_bytes",
      "name": "add_bytes",
      "signature": "pub fn add_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {",
      "parameters": [
        {
          "name": "intermediate",
          "type": "State<Scalar>",
          "optional": false
        },
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "State<Scalar>",
      "line": 137,
      "raw": "pub fn add_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn add_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {\n  add_bit_scalar(intermediate, bytes)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.add_int",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.add_int",
      "name": "add_int",
      "signature": "pub fn add_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {",
      "parameters": [
        {
          "name": "intermediate",
          "type": "State<Scalar>",
          "optional": false
        },
        {
          "name": "int",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "State<Scalar>",
      "line": 143,
      "raw": "pub fn add_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn add_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {\n  add_i_scalar(intermediate, int)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.div",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.div",
      "name": "div",
      "signature": "pub fn div(left: State<Scalar>, right: State<Scalar>) -> Option<State<Scalar>> {",
      "documentation": "Divides one `Scalar` element by another, returning `None` if the divisor is zero.",
      "parameters": [
        {
          "name": "left",
          "type": "State<Scalar>",
          "optional": false
        },
        {
          "name": "right",
          "type": "State<Scalar>",
          "optional": false
        }
      ],
      "returnType": "Option<State<Scalar>>",
      "line": 160,
      "raw": "pub fn div(left: State<Scalar>, right: State<Scalar>) -> Option<State<Scalar>> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn div(left: State<Scalar>, right: State<Scalar>) -> Option<State<Scalar>> {\n  if right == zero {\n    None\n  } else {\n    Some(mul(left, scale(right, field_prime - 2)))\n  }\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.div_int",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.div_int",
      "name": "div_int",
      "signature": "pub fn div_int(left: State<Scalar>, right: Int) -> Option<State<Scalar>> {",
      "parameters": [
        {
          "name": "left",
          "type": "State<Scalar>",
          "optional": false
        },
        {
          "name": "right",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Option<State<Scalar>>",
      "line": 168,
      "raw": "pub fn div_int(left: State<Scalar>, right: Int) -> Option<State<Scalar>> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn div_int(left: State<Scalar>, right: Int) -> Option<State<Scalar>> {\n  let right = from_int(right)\n  if right == zero {\n    None\n  } else {\n    Some(mul(left, scale(right, field_prime - 2)))\n  }\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.div_bytes",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.div_bytes",
      "name": "div_bytes",
      "signature": "pub fn div_bytes(left: State<Scalar>, right: ByteArray) -> Option<State<Scalar>> {",
      "parameters": [
        {
          "name": "left",
          "type": "State<Scalar>",
          "optional": false
        },
        {
          "name": "right",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Option<State<Scalar>>",
      "line": 177,
      "raw": "pub fn div_bytes(left: State<Scalar>, right: ByteArray) -> Option<State<Scalar>> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn div_bytes(left: State<Scalar>, right: ByteArray) -> Option<State<Scalar>> {\n  let right = from_bytes(right)\n\n  if right == zero {\n    None\n  } else {\n    Some(mul(left, scale(right, field_prime - 2)))\n  }\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.mul",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.mul",
      "name": "mul",
      "signature": "pub fn mul(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {",
      "documentation": "Multiplies two `Scalar` elements, with the result constrained within the finite field.",
      "parameters": [
        {
          "name": "left",
          "type": "State<Scalar>",
          "optional": false
        },
        {
          "name": "right",
          "type": "State<Scalar>",
          "optional": false
        }
      ],
      "returnType": "State<Scalar>",
      "line": 204,
      "raw": "pub fn mul(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn mul(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {\n  mul_s_scalar(left, right)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.mul_bytes",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.mul_bytes",
      "name": "mul_bytes",
      "signature": "pub fn mul_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {",
      "parameters": [
        {
          "name": "intermediate",
          "type": "State<Scalar>",
          "optional": false
        },
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "State<Scalar>",
      "line": 210,
      "raw": "pub fn mul_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn mul_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {\n  mul_bit_scalar(intermediate, bytes)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.mul_int",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.mul_int",
      "name": "mul_int",
      "signature": "pub fn mul_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {",
      "parameters": [
        {
          "name": "intermediate",
          "type": "State<Scalar>",
          "optional": false
        },
        {
          "name": "int",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "State<Scalar>",
      "line": 216,
      "raw": "pub fn mul_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn mul_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {\n  mul_i_scalar(intermediate, int)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.neg",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.neg",
      "name": "neg",
      "signature": "pub fn neg(intermediate: State<Scalar>) -> State<Scalar> {",
      "documentation": "Calculates the additive inverse of a `Scalar` element.",
      "parameters": [
        {
          "name": "intermediate",
          "type": "State<Scalar>",
          "optional": false
        }
      ],
      "returnType": "State<Scalar>",
      "line": 234,
      "raw": "pub fn neg(intermediate: State<Scalar>) -> State<Scalar> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn neg(intermediate: State<Scalar>) -> State<Scalar> {\n  neg_scalar(intermediate)\n}",
      "tests": [
        "test neg_1() {\n  trace neg(zero)\n\n  and {\n    neg(from_int(834884848)) == from_int(\n      52435875175126190479447740508185965837690552500527637822603658699937746299665,\n    ),\n    neg(zero) == zero,\n    neg(one) == from_int(field_prime - 1),\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.recip",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.recip",
      "name": "recip",
      "signature": "pub fn recip(self: State<Scalar>) -> Option<State<Scalar>> {",
      "documentation": "Calculates the multiplicative inverse of an `Scalar` element, returning `None` if the element is zero.",
      "parameters": [
        {
          "name": "self",
          "type": "State<Scalar>",
          "optional": false
        }
      ],
      "returnType": "Option<State<Scalar>>",
      "line": 251,
      "raw": "pub fn recip(self: State<Scalar>) -> Option<State<Scalar>> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn recip(self: State<Scalar>) -> Option<State<Scalar>> {\n  div(one, self)\n}",
      "tests": [
        "test recip_1() {\n  and {\n    recip(from_int(834884848)) == Some(\n      from_int(\n        35891248691642227249400403463796410930702563777316955162085759263735363466421,\n      ),\n    ),\n    recip(zero) == None,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.sub",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.sub",
      "name": "sub",
      "signature": "pub fn sub(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {",
      "documentation": "Subtracts one `Scalar` element from another, with the result wrapped within the finite field range.",
      "parameters": [
        {
          "name": "left",
          "type": "State<Scalar>",
          "optional": false
        },
        {
          "name": "right",
          "type": "State<Scalar>",
          "optional": false
        }
      ],
      "returnType": "State<Scalar>",
      "line": 269,
      "raw": "pub fn sub(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sub(left: State<Scalar>, right: State<Scalar>) -> State<Scalar> {\n  sub_s_scalar(left, right)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.sub_bytes",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.sub_bytes",
      "name": "sub_bytes",
      "signature": "pub fn sub_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {",
      "parameters": [
        {
          "name": "intermediate",
          "type": "State<Scalar>",
          "optional": false
        },
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "State<Scalar>",
      "line": 275,
      "raw": "pub fn sub_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sub_bytes(intermediate: State<Scalar>, bytes: ByteArray) -> State<Scalar> {\n  sub_bit_scalar(intermediate, bytes)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.sub_int",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.sub_int",
      "name": "sub_int",
      "signature": "pub fn sub_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {",
      "parameters": [
        {
          "name": "intermediate",
          "type": "State<Scalar>",
          "optional": false
        },
        {
          "name": "int",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "State<Scalar>",
      "line": 281,
      "raw": "pub fn sub_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sub_int(intermediate: State<Scalar>, int: Int) -> State<Scalar> {\n  sub_i_scalar(intermediate, int)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.to_int",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.to_int",
      "name": "to_int",
      "signature": "pub fn to_int(s: State<Scalar>) -> Int {",
      "documentation": "Converts a `Scalar` element back to its integer representation.",
      "parameters": [
        {
          "name": "s",
          "type": "State<Scalar>",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 297,
      "raw": "pub fn to_int(s: State<Scalar>) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn to_int(s: State<Scalar>) -> Int {\n  bitwise.to_int(s)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.to_bytes",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.to_bytes",
      "name": "to_bytes",
      "signature": "pub fn to_bytes(s: State<Scalar>) -> ByteArray {",
      "documentation": "Converts a `Scalar` element to a Big-Endian (most-significant bits first) `ByteArray`.",
      "parameters": [
        {
          "name": "s",
          "type": "State<Scalar>",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 302,
      "raw": "pub fn to_bytes(s: State<Scalar>) -> ByteArray {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn to_bytes(s: State<Scalar>) -> ByteArray {\n  s |> bitwise.to_int |> builtin.integer_to_bytearray(True, field_size, _)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.to_bytes_little_endian",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.to_bytes_little_endian",
      "name": "to_bytes_little_endian",
      "signature": "pub fn to_bytes_little_endian(s: State<Scalar>) -> ByteArray {",
      "documentation": "Converts a `Scalar` element to a Little-Endian (least-significant bits first) `ByteArray`.",
      "parameters": [
        {
          "name": "s",
          "type": "State<Scalar>",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 307,
      "raw": "pub fn to_bytes_little_endian(s: State<Scalar>) -> ByteArray {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn to_bytes_little_endian(s: State<Scalar>) -> ByteArray {\n  s |> bitwise.to_int |> builtin.integer_to_bytearray(False, field_size, _)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int224.from_bytearray_big_endian",
      "fullName": "stdlib:aiken.crypto.int224.from_bytearray_big_endian",
      "name": "from_bytearray_big_endian",
      "signature": "pub fn from_bytearray_big_endian(bytes: ByteArray) -> State {",
      "documentation": "Constructs a new `Bits224` element from a Big-Endian (most-significant bits first) `ByteArray`.",
      "parameters": [
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 34,
      "raw": "pub fn from_bytearray_big_endian(bytes: ByteArray) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_bytearray_big_endian(bytes: ByteArray) -> State {\n  bytes\n    |> builtin.bytearray_to_integer(True, _)\n    |> bitwise.from_int(field)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int224.from_bytearray_little_endian",
      "fullName": "stdlib:aiken.crypto.int224.from_bytearray_little_endian",
      "name": "from_bytearray_little_endian",
      "signature": "pub fn from_bytearray_little_endian(bytes: ByteArray) -> State {",
      "documentation": "Constructs a new `Bits224` element from a Little-Endian (least-significant bits first) `ByteArray`.",
      "parameters": [
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 41,
      "raw": "pub fn from_bytearray_little_endian(bytes: ByteArray) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_bytearray_little_endian(bytes: ByteArray) -> State {\n  bytes\n    |> builtin.bytearray_to_integer(False, _)\n    |> bitwise.from_int(field)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int224.from_int",
      "fullName": "stdlib:aiken.crypto.int224.from_int",
      "name": "from_int",
      "signature": "pub fn from_int(int: Int) -> State {",
      "documentation": "Constructs a new `Bits224` element from an integer, ensuring it's within the valid range of the field.",
      "parameters": [
        {
          "name": "int",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 48,
      "raw": "pub fn from_int(int: Int) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_int(int: Int) -> State {\n  bitwise.from_int(int, field)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int224.scale",
      "fullName": "stdlib:aiken.crypto.int224.scale",
      "name": "scale",
      "signature": "pub fn scale(self: State, e: Int) -> State {",
      "documentation": "Exponentiates a `Bits224` element by a non-negative integer exponent, using repeated squaring.\nNote that this function returns `zero` for negative exponents.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        },
        {
          "name": "e",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 56,
      "raw": "pub fn scale(self: State, e: Int) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn scale(self: State, e: Int) -> State {\n  bitwise.scale(self, e, mul)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int224.scale2",
      "fullName": "stdlib:aiken.crypto.int224.scale2",
      "name": "scale2",
      "signature": "pub fn scale2(self: State, k: Int) -> State {",
      "documentation": "A faster version of `scale` for the case where the exponent is a power of two.\nThat is, the exponent $e = 2^k$ for some non-negative integer $k$.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        },
        {
          "name": "k",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 62,
      "raw": "pub fn scale2(self: State, k: Int) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn scale2(self: State, k: Int) -> State {\n  bitwise.scale2(self, k, mul)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int224.add",
      "fullName": "stdlib:aiken.crypto.int224.add",
      "name": "add",
      "signature": "pub fn add(left: State, right: State) -> State {",
      "documentation": "Adds two `Bits224` elements, ensuring the result stays within the finite field range.",
      "parameters": [
        {
          "name": "left",
          "type": "State",
          "optional": false
        },
        {
          "name": "right",
          "type": "State",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 71,
      "raw": "pub fn add(left: State, right: State) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn add(left: State, right: State) -> State {\n  add_s_bits224(left, right)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int224.add_bytes",
      "fullName": "stdlib:aiken.crypto.int224.add_bytes",
      "name": "add_bytes",
      "signature": "pub fn add_bytes(self: State, bytes: ByteArray) -> State {",
      "documentation": "Adds a ByteArray to a `Bits224` element, interpreting bytes as a big-endian number.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        },
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 78,
      "raw": "pub fn add_bytes(self: State, bytes: ByteArray) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn add_bytes(self: State, bytes: ByteArray) -> State {\n  add_bit224(self, bytes)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int224.add_int",
      "fullName": "stdlib:aiken.crypto.int224.add_int",
      "name": "add_int",
      "signature": "pub fn add_int(self: State, int: Int) -> State {",
      "documentation": "Adds an integer to a `Bits224` element.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        },
        {
          "name": "int",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 85,
      "raw": "pub fn add_int(self: State, int: Int) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn add_int(self: State, int: Int) -> State {\n  add_i224(self, int)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int224.mul",
      "fullName": "stdlib:aiken.crypto.int224.mul",
      "name": "mul",
      "signature": "pub fn mul(left: State, right: State) -> State {",
      "documentation": "Multiplies two `Bits224` elements, with the result constrained within the finite field.",
      "parameters": [
        {
          "name": "left",
          "type": "State",
          "optional": false
        },
        {
          "name": "right",
          "type": "State",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 92,
      "raw": "pub fn mul(left: State, right: State) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn mul(left: State, right: State) -> State {\n  mul_s_bits224(left, right)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int224.mul_bytes",
      "fullName": "stdlib:aiken.crypto.int224.mul_bytes",
      "name": "mul_bytes",
      "signature": "pub fn mul_bytes(self: State, bytes: ByteArray) -> State {",
      "documentation": "Multiplies a `Bits224` element by a ByteArray, interpreting bytes as a big-endian number.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        },
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 99,
      "raw": "pub fn mul_bytes(self: State, bytes: ByteArray) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn mul_bytes(self: State, bytes: ByteArray) -> State {\n  mul_bit224(self, bytes)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int224.mul_int",
      "fullName": "stdlib:aiken.crypto.int224.mul_int",
      "name": "mul_int",
      "signature": "pub fn mul_int(self: State, int: Int) -> State {",
      "documentation": "Multiplies a `Bits224` element by an integer.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        },
        {
          "name": "int",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 106,
      "raw": "pub fn mul_int(self: State, int: Int) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn mul_int(self: State, int: Int) -> State {\n  mul_i224(self, int)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int224.neg",
      "fullName": "stdlib:aiken.crypto.int224.neg",
      "name": "neg",
      "signature": "pub fn neg(self: State) -> State {",
      "documentation": "Calculates the additive inverse of a `Bits224` element.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 113,
      "raw": "pub fn neg(self: State) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn neg(self: State) -> State {\n  neg224(self)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int224.sub",
      "fullName": "stdlib:aiken.crypto.int224.sub",
      "name": "sub",
      "signature": "pub fn sub(left: State, right: State) -> State {",
      "documentation": "Subtracts one `Bits224` element from another, with the result wrapped within the finite field range.",
      "parameters": [
        {
          "name": "left",
          "type": "State",
          "optional": false
        },
        {
          "name": "right",
          "type": "State",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 120,
      "raw": "pub fn sub(left: State, right: State) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sub(left: State, right: State) -> State {\n  sub_s_bits224(left, right)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int224.sub_bytes",
      "fullName": "stdlib:aiken.crypto.int224.sub_bytes",
      "name": "sub_bytes",
      "signature": "pub fn sub_bytes(self: State, bytes: ByteArray) -> State {",
      "documentation": "Subtracts a `ByteArray` from a `Bits224` element, interpreting bytes as a big-endian number.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        },
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 127,
      "raw": "pub fn sub_bytes(self: State, bytes: ByteArray) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sub_bytes(self: State, bytes: ByteArray) -> State {\n  sub_bit224(self, bytes)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int224.sub_int",
      "fullName": "stdlib:aiken.crypto.int224.sub_int",
      "name": "sub_int",
      "signature": "pub fn sub_int(self: State, int: Int) -> State {",
      "documentation": "Subtracts an integer from a `Bits224` element.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        },
        {
          "name": "int",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 134,
      "raw": "pub fn sub_int(self: State, int: Int) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sub_int(self: State, int: Int) -> State {\n  sub_i224(self, int)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int224.to_bytearray_big_endian",
      "fullName": "stdlib:aiken.crypto.int224.to_bytearray_big_endian",
      "name": "to_bytearray_big_endian",
      "signature": "pub fn to_bytearray_big_endian(self: State) -> ByteArray {",
      "documentation": "Converts a `Bits224` element to a Big-Endian (most-significant bits first) `ByteArray`.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 141,
      "raw": "pub fn to_bytearray_big_endian(self: State) -> ByteArray {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn to_bytearray_big_endian(self: State) -> ByteArray {\n  bitwise.to_int(self)\n    |> builtin.integer_to_bytearray(True, field_size, _)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int224.to_bytearray_little_endian",
      "fullName": "stdlib:aiken.crypto.int224.to_bytearray_little_endian",
      "name": "to_bytearray_little_endian",
      "signature": "pub fn to_bytearray_little_endian(self: State) -> ByteArray {",
      "documentation": "Converts a `Bits224` element to a Little-Endian (least-significant bits first) `ByteArray`.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 147,
      "raw": "pub fn to_bytearray_little_endian(self: State) -> ByteArray {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn to_bytearray_little_endian(self: State) -> ByteArray {\n  bitwise.to_int(self)\n    |> builtin.integer_to_bytearray(False, field_size, _)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int224.to_int",
      "fullName": "stdlib:aiken.crypto.int224.to_int",
      "name": "to_int",
      "signature": "pub fn to_int(self: State) -> Int {",
      "documentation": "Converts a `Bits224` element back to its integer representation.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 153,
      "raw": "pub fn to_int(self: State) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn to_int(self: State) -> Int {\n  bitwise.to_int(self)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int256.from_bytearray_big_endian",
      "fullName": "stdlib:aiken.crypto.int256.from_bytearray_big_endian",
      "name": "from_bytearray_big_endian",
      "signature": "pub fn from_bytearray_big_endian(bytes: ByteArray) -> State {",
      "documentation": "Constructs a new `Bits256` element from a Big-Endian (most-significant bits first) `ByteArray`.",
      "parameters": [
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 33,
      "raw": "pub fn from_bytearray_big_endian(bytes: ByteArray) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_bytearray_big_endian(bytes: ByteArray) -> State {\n  bytes\n    |> builtin.bytearray_to_integer(True, _)\n    |> bitwise.from_int(field)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int256.from_bytearray_little_endian",
      "fullName": "stdlib:aiken.crypto.int256.from_bytearray_little_endian",
      "name": "from_bytearray_little_endian",
      "signature": "pub fn from_bytearray_little_endian(bytes: ByteArray) -> State {",
      "documentation": "Constructs a new `Bits256` element from a Little-Endian (least-significant bits first) `ByteArray`.",
      "parameters": [
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 40,
      "raw": "pub fn from_bytearray_little_endian(bytes: ByteArray) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_bytearray_little_endian(bytes: ByteArray) -> State {\n  bytes\n    |> builtin.bytearray_to_integer(False, _)\n    |> bitwise.from_int(field)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int256.from_int",
      "fullName": "stdlib:aiken.crypto.int256.from_int",
      "name": "from_int",
      "signature": "pub fn from_int(int: Int) -> State {",
      "documentation": "Constructs a new `Bits256` element from an integer, ensuring it's within the valid range of the field.",
      "parameters": [
        {
          "name": "int",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 47,
      "raw": "pub fn from_int(int: Int) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_int(int: Int) -> State {\n  bitwise.from_int(int, field)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int256.scale",
      "fullName": "stdlib:aiken.crypto.int256.scale",
      "name": "scale",
      "signature": "pub fn scale(self: State, e: Int) -> State {",
      "documentation": "Exponentiates a `Bits256` element by a non-negative integer exponent, using repeated squaring.\nNote that this function returns `zero` for negative exponents.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        },
        {
          "name": "e",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 55,
      "raw": "pub fn scale(self: State, e: Int) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn scale(self: State, e: Int) -> State {\n  bitwise.scale(self, e, mul)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int256.scale2",
      "fullName": "stdlib:aiken.crypto.int256.scale2",
      "name": "scale2",
      "signature": "pub fn scale2(self: State, k: Int) -> State {",
      "documentation": "A faster version of `scale` for the case where the exponent is a power of two.\nThat is, the exponent $e = 2^k$ for some non-negative integer $k$.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        },
        {
          "name": "k",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 61,
      "raw": "pub fn scale2(self: State, k: Int) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn scale2(self: State, k: Int) -> State {\n  bitwise.scale2(self, k, mul)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int256.add",
      "fullName": "stdlib:aiken.crypto.int256.add",
      "name": "add",
      "signature": "pub fn add(left: State, right: State) -> State {",
      "documentation": "Adds two `Bits256` elements, ensuring the result stays within the finite field range.",
      "parameters": [
        {
          "name": "left",
          "type": "State",
          "optional": false
        },
        {
          "name": "right",
          "type": "State",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 70,
      "raw": "pub fn add(left: State, right: State) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn add(left: State, right: State) -> State {\n  add_s_hash256(left, right)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int256.add_bytes",
      "fullName": "stdlib:aiken.crypto.int256.add_bytes",
      "name": "add_bytes",
      "signature": "pub fn add_bytes(self: State, bytes: ByteArray) -> State {",
      "documentation": "Adds a ByteArray to a `Bits256` element, interpreting bytes as a big-endian number.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        },
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 77,
      "raw": "pub fn add_bytes(self: State, bytes: ByteArray) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn add_bytes(self: State, bytes: ByteArray) -> State {\n  add_bit256(self, bytes)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int256.add_int",
      "fullName": "stdlib:aiken.crypto.int256.add_int",
      "name": "add_int",
      "signature": "pub fn add_int(self: State, int: Int) -> State {",
      "documentation": "Adds an integer to a `Bits256` element.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        },
        {
          "name": "int",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 84,
      "raw": "pub fn add_int(self: State, int: Int) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn add_int(self: State, int: Int) -> State {\n  add_i256(self, int)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int256.mul",
      "fullName": "stdlib:aiken.crypto.int256.mul",
      "name": "mul",
      "signature": "pub fn mul(left: State, right: State) -> State {",
      "documentation": "Multiplies two `Bits256` elements, with the result constrained within the finite field.",
      "parameters": [
        {
          "name": "left",
          "type": "State",
          "optional": false
        },
        {
          "name": "right",
          "type": "State",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 91,
      "raw": "pub fn mul(left: State, right: State) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn mul(left: State, right: State) -> State {\n  mul_s_hash256(left, right)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int256.mul_bytes",
      "fullName": "stdlib:aiken.crypto.int256.mul_bytes",
      "name": "mul_bytes",
      "signature": "pub fn mul_bytes(self: State, bytes: ByteArray) -> State {",
      "documentation": "Multiplies a `Bits256` element by a ByteArray, interpreting bytes as a big-endian number.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        },
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 98,
      "raw": "pub fn mul_bytes(self: State, bytes: ByteArray) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn mul_bytes(self: State, bytes: ByteArray) -> State {\n  mul_bit256(self, bytes)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int256.mul_int",
      "fullName": "stdlib:aiken.crypto.int256.mul_int",
      "name": "mul_int",
      "signature": "pub fn mul_int(self: State, int: Int) -> State {",
      "documentation": "Multiplies a `Bits256` element by an integer.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        },
        {
          "name": "int",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 105,
      "raw": "pub fn mul_int(self: State, int: Int) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn mul_int(self: State, int: Int) -> State {\n  mul_i256(self, int)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int256.neg",
      "fullName": "stdlib:aiken.crypto.int256.neg",
      "name": "neg",
      "signature": "pub fn neg(self: State) -> State {",
      "documentation": "Calculates the additive inverse of a `Bits256` element.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 112,
      "raw": "pub fn neg(self: State) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn neg(self: State) -> State {\n  neg256(self)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int256.sub",
      "fullName": "stdlib:aiken.crypto.int256.sub",
      "name": "sub",
      "signature": "pub fn sub(left: State, right: State) -> State {",
      "documentation": "Subtracts one `Bits256` element from another, with the result wrapped within the finite field range.",
      "parameters": [
        {
          "name": "left",
          "type": "State",
          "optional": false
        },
        {
          "name": "right",
          "type": "State",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 119,
      "raw": "pub fn sub(left: State, right: State) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sub(left: State, right: State) -> State {\n  sub_s_hash256(left, right)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int256.sub_bytes",
      "fullName": "stdlib:aiken.crypto.int256.sub_bytes",
      "name": "sub_bytes",
      "signature": "pub fn sub_bytes(self: State, bytes: ByteArray) -> State {",
      "documentation": "Subtracts a `ByteArray` from a `Bits256` element, interpreting bytes as a big-endian number.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        },
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 126,
      "raw": "pub fn sub_bytes(self: State, bytes: ByteArray) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sub_bytes(self: State, bytes: ByteArray) -> State {\n  sub_bit256(self, bytes)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int256.sub_int",
      "fullName": "stdlib:aiken.crypto.int256.sub_int",
      "name": "sub_int",
      "signature": "pub fn sub_int(self: State, int: Int) -> State {",
      "documentation": "Subtracts an integer from a `Bits256` element.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        },
        {
          "name": "int",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "State",
      "line": 133,
      "raw": "pub fn sub_int(self: State, int: Int) -> State {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sub_int(self: State, int: Int) -> State {\n  sub_i256(self, int)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int256.to_bytearray_big_endian",
      "fullName": "stdlib:aiken.crypto.int256.to_bytearray_big_endian",
      "name": "to_bytearray_big_endian",
      "signature": "pub fn to_bytearray_big_endian(self: State) -> ByteArray {",
      "documentation": "Converts a `Bits256` element to a Big-Endian (most-significant bits first) `ByteArray`.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 140,
      "raw": "pub fn to_bytearray_big_endian(self: State) -> ByteArray {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn to_bytearray_big_endian(self: State) -> ByteArray {\n  bitwise.to_int(self)\n    |> builtin.integer_to_bytearray(True, field_size, _)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int256.to_bytearray_little_endian",
      "fullName": "stdlib:aiken.crypto.int256.to_bytearray_little_endian",
      "name": "to_bytearray_little_endian",
      "signature": "pub fn to_bytearray_little_endian(self: State) -> ByteArray {",
      "documentation": "Converts a `Bits256` element to a Little-Endian (least-significant bits first) `ByteArray`.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 146,
      "raw": "pub fn to_bytearray_little_endian(self: State) -> ByteArray {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn to_bytearray_little_endian(self: State) -> ByteArray {\n  bitwise.to_int(self)\n    |> builtin.integer_to_bytearray(False, field_size, _)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.int256.to_int",
      "fullName": "stdlib:aiken.crypto.int256.to_int",
      "name": "to_int",
      "signature": "pub fn to_int(self: State) -> Int {",
      "documentation": "Converts a `Bits256` element back to its integer representation.",
      "parameters": [
        {
          "name": "self",
          "type": "State",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 152,
      "raw": "pub fn to_int(self: State) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn to_int(self: State) -> Int {\n  bitwise.to_int(self)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.blake2b_224",
      "fullName": "stdlib:aiken.crypto.blake2b_224",
      "name": "blake2b_224",
      "signature": "pub fn blake2b_224(bytes: ByteArray) -> Hash<Blake2b_224, a> {",
      "documentation": "Compute the blake2b-224 hash digest (28 bytes) of some data.\nMinimum Plutus Version: 3",
      "parameters": [
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Hash<Blake2b_224, a>",
      "line": 68,
      "raw": "pub fn blake2b_224(bytes: ByteArray) -> Hash<Blake2b_224, a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn blake2b_224(bytes: ByteArray) -> Hash<Blake2b_224, a> {\n  builtin.blake2b_224(bytes)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.blake2b_256",
      "fullName": "stdlib:aiken.crypto.blake2b_256",
      "name": "blake2b_256",
      "signature": "pub fn blake2b_256(bytes: ByteArray) -> Hash<Blake2b_256, a> {",
      "documentation": "Compute the blake2b-256 hash digest (32 bytes) of some data.",
      "parameters": [
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Hash<Blake2b_256, a>",
      "line": 82,
      "raw": "pub fn blake2b_256(bytes: ByteArray) -> Hash<Blake2b_256, a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn blake2b_256(bytes: ByteArray) -> Hash<Blake2b_256, a> {\n  builtin.blake2b_256(bytes)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.keccak_256",
      "fullName": "stdlib:aiken.crypto.keccak_256",
      "name": "keccak_256",
      "signature": "pub fn keccak_256(bytes: ByteArray) -> Hash<Keccak_256, a> {",
      "documentation": "Compute the keccak-256 hash digest (32 bytes) of some data.",
      "parameters": [
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Hash<Keccak_256, a>",
      "line": 92,
      "raw": "pub fn keccak_256(bytes: ByteArray) -> Hash<Keccak_256, a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn keccak_256(bytes: ByteArray) -> Hash<Keccak_256, a> {\n  builtin.keccak_256(bytes)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.sha2_256",
      "fullName": "stdlib:aiken.crypto.sha2_256",
      "name": "sha2_256",
      "signature": "pub fn sha2_256(bytes: ByteArray) -> Hash<Sha2_256, a> {",
      "documentation": "Compute the sha2-256 hash digest (32 bytes) of some data.",
      "parameters": [
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Hash<Sha2_256, a>",
      "line": 102,
      "raw": "pub fn sha2_256(bytes: ByteArray) -> Hash<Sha2_256, a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sha2_256(bytes: ByteArray) -> Hash<Sha2_256, a> {\n  builtin.sha2_256(bytes)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.sha3_256",
      "fullName": "stdlib:aiken.crypto.sha3_256",
      "name": "sha3_256",
      "signature": "pub fn sha3_256(bytes: ByteArray) -> Hash<Sha3_256, a> {",
      "documentation": "Compute the sha3-256 hash digest (32 bytes) of some data.",
      "parameters": [
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Hash<Sha3_256, a>",
      "line": 112,
      "raw": "pub fn sha3_256(bytes: ByteArray) -> Hash<Sha3_256, a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sha3_256(bytes: ByteArray) -> Hash<Sha3_256, a> {\n  builtin.sha3_256(bytes)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.verify_ecdsa_signature",
      "fullName": "stdlib:aiken.crypto.verify_ecdsa_signature",
      "name": "verify_ecdsa_signature",
      "signature": "pub fn verify_ecdsa_signature(pub fn verify_ecdsa_signature(key: VerificationKey, msg: ByteArray, sig: Signature, ) -> Bool {",
      "documentation": "Verify an ECDCA signature (over secp256k1) using the given verification key.\nReturns `True` when the signature is valid.",
      "parameters": [],
      "returnType": "Bool",
      "line": 120,
      "raw": "pub fn verify_ecdsa_signature(pub fn verify_ecdsa_signature(key: VerificationKey, msg: ByteArray, sig: Signature, ) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn verify_ecdsa_signature(\n  key: VerificationKey,\n  msg: ByteArray,\n  sig: Signature,\n) -> Bool {\n  builtin.verify_ecdsa_secp256k1_signature(key, msg, sig)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.verify_ed25519_signature",
      "fullName": "stdlib:aiken.crypto.verify_ed25519_signature",
      "name": "verify_ed25519_signature",
      "signature": "pub fn verify_ed25519_signature(pub fn verify_ed25519_signature(key: VerificationKey, msg: ByteArray, sig: Signature, ) -> Bool {",
      "documentation": "Verify an Ed25519 signature using the given verification key.\nReturns `True` when the signature is valid.",
      "parameters": [],
      "returnType": "Bool",
      "line": 130,
      "raw": "pub fn verify_ed25519_signature(pub fn verify_ed25519_signature(key: VerificationKey, msg: ByteArray, sig: Signature, ) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn verify_ed25519_signature(\n  key: VerificationKey,\n  msg: ByteArray,\n  sig: Signature,\n) -> Bool {\n  builtin.verify_ed25519_signature(key, msg, sig)\n}"
    },
    {
      "key": "stdlib:aiken.crypto.verify_schnorr_signature",
      "fullName": "stdlib:aiken.crypto.verify_schnorr_signature",
      "name": "verify_schnorr_signature",
      "signature": "pub fn verify_schnorr_signature(pub fn verify_schnorr_signature(key: VerificationKey, msg: ByteArray, sig: Signature, ) -> Bool {",
      "documentation": "Verify a Schnorr signature (over secp256k1) using the given verification key.\nReturns `True` when the signature is valid.",
      "parameters": [],
      "returnType": "Bool",
      "line": 140,
      "raw": "pub fn verify_schnorr_signature(pub fn verify_schnorr_signature(key: VerificationKey, msg: ByteArray, sig: Signature, ) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn verify_schnorr_signature(\n  key: VerificationKey,\n  msg: ByteArray,\n  sig: Signature,\n) -> Bool {\n  builtin.verify_schnorr_secp256k1_signature(key, msg, sig)\n}"
    },
    {
      "key": "stdlib:aiken.interval.after",
      "fullName": "stdlib:aiken.interval.after",
      "name": "after",
      "signature": "pub fn after(lower_bound: Int) -> Interval {",
      "documentation": "Create an interval that includes all values greater than the given bound. i.e $[lower_bound, +∞]$\n\n```aiken\ninterval.after(10) == Interval {\nlower_bound: IntervalBound { bound_type: Finite(10), is_inclusive: True },\nupper_bound: IntervalBound { bound_type: PositiveInfinity, is_inclusive: True },\n}\n```",
      "parameters": [
        {
          "name": "lower_bound",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Interval",
      "line": 123,
      "raw": "pub fn after(lower_bound: Int) -> Interval {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn after(lower_bound: Int) -> Interval {\n  Interval {\n    lower_bound: IntervalBound {\n      bound_type: Finite(lower_bound),\n      is_inclusive: True,\n    },\n    upper_bound: IntervalBound {\n      bound_type: PositiveInfinity,\n      is_inclusive: True,\n    },\n  }\n}"
    },
    {
      "key": "stdlib:aiken.interval.entirely_after",
      "fullName": "stdlib:aiken.interval.entirely_after",
      "name": "entirely_after",
      "signature": "pub fn entirely_after(lower_bound: Int) -> Interval {",
      "documentation": "Create an interval that includes all values after (and not including) the given bound. i.e $(lower_bound, +∞]$\n\n```aiken\ninterval.entirely_after(10) == Interval {\nlower_bound: IntervalBound { bound_type: Finite(10), is_inclusive: False },\nupper_bound: IntervalBound { bound_type: PositiveInfinity, is_inclusive: True },\n}\n```",
      "parameters": [
        {
          "name": "lower_bound",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Interval",
      "line": 144,
      "raw": "pub fn entirely_after(lower_bound: Int) -> Interval {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn entirely_after(lower_bound: Int) -> Interval {\n  Interval {\n    lower_bound: IntervalBound {\n      bound_type: Finite(lower_bound),\n      is_inclusive: False,\n    },\n    upper_bound: IntervalBound {\n      bound_type: PositiveInfinity,\n      is_inclusive: True,\n    },\n  }\n}"
    },
    {
      "key": "stdlib:aiken.interval.before",
      "fullName": "stdlib:aiken.interval.before",
      "name": "before",
      "signature": "pub fn before(upper_bound: Int) -> Interval {",
      "documentation": "Create an interval that includes all values before (and including) the given bound. i.e $(-∞, upper_bound]$\n\n```aiken\ninterval.before(100) == Interval {\nlower_bound: IntervalBound { bound_type: NegativeInfinity, is_inclusive: True },\nupper_bound: IntervalBound { bound_type: Finite(100), is_inclusive: True },\n}\n```",
      "parameters": [
        {
          "name": "upper_bound",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Interval",
      "line": 165,
      "raw": "pub fn before(upper_bound: Int) -> Interval {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn before(upper_bound: Int) -> Interval {\n  Interval {\n    lower_bound: IntervalBound {\n      bound_type: NegativeInfinity,\n      is_inclusive: True,\n    },\n    upper_bound: IntervalBound {\n      bound_type: Finite(upper_bound),\n      is_inclusive: True,\n    },\n  }\n}"
    },
    {
      "key": "stdlib:aiken.interval.entirely_before",
      "fullName": "stdlib:aiken.interval.entirely_before",
      "name": "entirely_before",
      "signature": "pub fn entirely_before(upper_bound: Int) -> Interval {",
      "documentation": "Create an interval that includes all values before (and not including) the given bound. i.e $(-∞, upper_bound)$\n\n```aiken\ninterval.entirely_before(10) == Interval {\nlower_bound: IntervalBound { bound_type: NegativeInfinity, is_inclusive: True },\nupper_bound: IntervalBound { bound_type: Finite(10), is_inclusive: False },\n}\n```",
      "parameters": [
        {
          "name": "upper_bound",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Interval",
      "line": 186,
      "raw": "pub fn entirely_before(upper_bound: Int) -> Interval {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn entirely_before(upper_bound: Int) -> Interval {\n  Interval {\n    lower_bound: IntervalBound {\n      bound_type: NegativeInfinity,\n      is_inclusive: True,\n    },\n    upper_bound: IntervalBound {\n      bound_type: Finite(upper_bound),\n      is_inclusive: False,\n    },\n  }\n}"
    },
    {
      "key": "stdlib:aiken.interval.between",
      "fullName": "stdlib:aiken.interval.between",
      "name": "between",
      "signature": "pub fn between(lower_bound: Int, upper_bound: Int) -> Interval {",
      "documentation": "Create an interval that includes all values between two bounds, including the bounds. i.e. $[lower_bound, upper_bound]$\n\n```aiken\ninterval.between(10, 100) == Interval {\nlower_bound: IntervalBound { bound_type: Finite(10), is_inclusive: True },\nupper_bound: IntervalBound { bound_type: Finite(100), is_inclusive: True },\n}\n```",
      "parameters": [
        {
          "name": "lower_bound",
          "type": "Int",
          "optional": false
        },
        {
          "name": "upper_bound",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Interval",
      "line": 207,
      "raw": "pub fn between(lower_bound: Int, upper_bound: Int) -> Interval {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn between(lower_bound: Int, upper_bound: Int) -> Interval {\n  Interval {\n    lower_bound: IntervalBound {\n      bound_type: Finite(lower_bound),\n      is_inclusive: True,\n    },\n    upper_bound: IntervalBound {\n      bound_type: Finite(upper_bound),\n      is_inclusive: True,\n    },\n  }\n}"
    },
    {
      "key": "stdlib:aiken.interval.entirely_between",
      "fullName": "stdlib:aiken.interval.entirely_between",
      "name": "entirely_between",
      "signature": "pub fn entirely_between(lower_bound: Int, upper_bound: Int) -> Interval {",
      "documentation": "Create an interval that includes all values between two bounds, excluding the bounds. i.e. $(lower_bound, upper_bound)$\n\n```aiken\ninterval.entirely_between(10, 100) == Interval {\nlower_bound: IntervalBound { bound_type: Finite(10), is_inclusive: False },\nupper_bound: IntervalBound { bound_type: Finite(100), is_inclusive: False },\n}\n```",
      "parameters": [
        {
          "name": "lower_bound",
          "type": "Int",
          "optional": false
        },
        {
          "name": "upper_bound",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Interval",
      "line": 228,
      "raw": "pub fn entirely_between(lower_bound: Int, upper_bound: Int) -> Interval {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn entirely_between(lower_bound: Int, upper_bound: Int) -> Interval {\n  Interval {\n    lower_bound: IntervalBound {\n      bound_type: Finite(lower_bound),\n      is_inclusive: False,\n    },\n    upper_bound: IntervalBound {\n      bound_type: Finite(upper_bound),\n      is_inclusive: False,\n    },\n  }\n}"
    },
    {
      "key": "stdlib:aiken.interval.contains",
      "fullName": "stdlib:aiken.interval.contains",
      "name": "contains",
      "signature": "pub fn contains(self: Interval, elem: Int) -> Bool {",
      "documentation": "Checks whether an element is contained within the interval.\n\n```aiken\nlet iv =\nInterval {\nlower_bound: IntervalBound {\nbound_type: Finite(14),\nis_inclusive: True\n},\nupper_bound: IntervalBound {\nbound_type: Finite(42),\nis_inclusive: False\n},\n}\n\ninterval.contains(iv, 25) == True\ninterval.contains(iv, 0) == False\ninterval.contains(iv, 14) == True\ninterval.contains(iv, 42) == False\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Interval",
          "optional": false
        },
        {
          "name": "elem",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 299,
      "raw": "pub fn contains(self: Interval, elem: Int) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn contains(self: Interval, elem: Int) -> Bool {\n  let is_greater_than_lower_bound =\n    when self.lower_bound.bound_type is {\n      NegativeInfinity -> True\n      Finite(lower_bound) ->\n        if self.lower_bound.is_inclusive {\n          elem >= lower_bound\n        } else {\n          elem > lower_bound\n        }\n      PositiveInfinity -> False\n    }\n\n  let is_smaller_than_upper_bound =\n    when self.upper_bound.bound_type is {\n      NegativeInfinity -> False\n      Finite(upper_bound) ->\n        if self.upper_bound.is_inclusive {\n          elem <= upper_bound\n        } else {\n          elem < upper_bound\n        }\n      PositiveInfinity -> True\n    }\n\n  is_greater_than_lower_bound && is_smaller_than_upper_bound\n}",
      "tests": [
        "test contains_1() {\n  let iv = everything\n  contains(iv, 14)\n}",
        "test contains_2() {\n  let iv = entirely_before(15)\n  contains(iv, 14)\n}",
        "test contains_3() {\n  let iv = before(14)\n  contains(iv, 14)\n}",
        "test contains_4() {\n  let iv = entirely_before(14)\n  !contains(iv, 14)\n}",
        "test contains_5() {\n  let iv = entirely_after(13)\n  contains(iv, 14)\n}",
        "test contains_6() {\n  let iv = after(14)\n  contains(iv, 14)\n}",
        "test contains_7() {\n  let iv = entirely_after(14)\n  !contains(iv, 14)\n}",
        "test contains_8() {\n  let iv = between(42, 1337)\n  !contains(iv, 14)\n}",
        "test contains_9() {\n  let iv = between(0, 42)\n  contains(iv, 14)\n}",
        "test contains_10() {\n  let iv = between(0, 42)\n  contains(iv, 42)\n}",
        "test contains_11() {\n  let iv = entirely_between(0, 42)\n  !contains(iv, 0)\n}",
        "test contains_12() {\n  let iv = empty\n  !contains(iv, 14)\n}"
      ]
    },
    {
      "key": "stdlib:aiken.interval.is_empty",
      "fullName": "stdlib:aiken.interval.is_empty",
      "name": "is_empty",
      "signature": "pub fn is_empty(self: Interval) -> Bool {",
      "documentation": "Tells whether an interval is empty; i.e. that is contains no value.\n\n```aiken\nlet iv1 = interval.empty\n\nlet iv2 = Interval {\nlower_bound: IntervalBound { bound_type: Finite(0), is_inclusive: False },\nupper_bound: IntervalBound { bound_type: Finite(0), is_inclusive: False },\n}\n\nlet iv3 = Interval {\nlower_bound: IntervalBound { bound_type: Finite(0), is_inclusive: False },\nupper_bound: IntervalBound { bound_type: Finite(100), is_inclusive: False },\n}\n\ninterval.is_empty(iv1) == True\ninterval.is_empty(iv2) == True\ninterval.is_empty(iv3) == False\n\n// Note: Two empty intervals are not necessarily equal.\niv1 != iv2\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Interval",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 409,
      "raw": "pub fn is_empty(self: Interval) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn is_empty(self: Interval) -> Bool {\n  compare_bound_type(\n    self.lower_bound.bound_type,\n    self.upper_bound.bound_type,\n    fn() {\n      let is_open_interval =\n        !self.lower_bound.is_inclusive && !self.upper_bound.is_inclusive\n      if is_open_interval {\n        when (self.lower_bound.bound_type, self.upper_bound.bound_type) is {\n          (Finite(lower_bound), Finite(upper_bound)) ->\n            lower_bound + 1 == upper_bound\n          _ -> False\n        }\n      } else {\n        False\n      }\n    },\n    fn(_) { !(self.lower_bound.is_inclusive && self.upper_bound.is_inclusive) },\n    fn() { True },\n  )\n}"
    },
    {
      "key": "stdlib:aiken.interval.is_entirely_after",
      "fullName": "stdlib:aiken.interval.is_entirely_after",
      "name": "is_entirely_after",
      "signature": "pub fn is_entirely_after(self: Interval, point: Int) -> Bool {",
      "documentation": "Check whether the interval is entirely after a given point.\n\n```aiken\ninterval.is_entirely_after(interval.after(10), 5) == True\ninterval.is_entirely_after(interval.after(10), 10) == False\ninterval.is_entirely_after(interval.after(10), 15) == False\ninterval.is_entirely_after(interval.between(10, 20), 30) == False\ninterval.is_entirely_after(interval.between(10, 20), 5) == True\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Interval",
          "optional": false
        },
        {
          "name": "point",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 440,
      "raw": "pub fn is_entirely_after(self: Interval, point: Int) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn is_entirely_after(self: Interval, point: Int) -> Bool {\n  when self.lower_bound.bound_type is {\n    Finite(low) ->\n      if self.lower_bound.is_inclusive {\n        point < low\n      } else {\n        point <= low\n      }\n    NegativeInfinity -> False\n    PositiveInfinity -> True\n  }\n}",
      "tests": [
        "test is_entirely_after_1() {\n  is_entirely_after(after(10), 5)\n}",
        "test is_entirely_after_2() {\n  !is_entirely_after(after(10), 10)\n}",
        "test is_entirely_after_3() {\n  !is_entirely_after(after(10), 15)\n}",
        "test is_entirely_after_4() {\n  !is_entirely_after(between(10, 20), 30)\n}",
        "test is_entirely_after_5() {\n  is_entirely_after(between(10, 20), 5)\n}",
        "test is_entirely_after_6() {\n  is_entirely_after(entirely_after(10), 10)\n}",
        "test is_entirely_after_7() {\n  !is_entirely_after(before(10), 5)\n}",
        "test is_entirely_after_8() {\n  !is_entirely_after(before(10), 15)\n}",
        "test is_entirely_after_9() {\n  !is_entirely_after(entirely_before(10), 5)\n}",
        "test is_entirely_after_10() {\n  is_entirely_after(\n    Interval {\n      lower_bound: IntervalBound {\n        bound_type: PositiveInfinity,\n        is_inclusive: True,\n      },\n      upper_bound: IntervalBound {\n        bound_type: PositiveInfinity,\n        is_inclusive: False,\n      },\n    },\n    1,\n  )\n}"
      ]
    },
    {
      "key": "stdlib:aiken.interval.is_entirely_before",
      "fullName": "stdlib:aiken.interval.is_entirely_before",
      "name": "is_entirely_before",
      "signature": "pub fn is_entirely_before(self: Interval, point: Int) -> Bool {",
      "documentation": "Check whether the interval is entirely before a given point.\n\n```aiken\ninterval.is_entirely_before(interval.before(10), 15) == True\ninterval.is_entirely_before(interval.before(10), 10) == False\ninterval.is_entirely_before(interval.before(10), 5) == False\ninterval.is_entirely_before(interval.between(10, 20), 30) == True\ninterval.is_entirely_before(interval.between(10, 20), 5) == False\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Interval",
          "optional": false
        },
        {
          "name": "point",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 514,
      "raw": "pub fn is_entirely_before(self: Interval, point: Int) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn is_entirely_before(self: Interval, point: Int) -> Bool {\n  when self.upper_bound.bound_type is {\n    Finite(hi) ->\n      if self.upper_bound.is_inclusive {\n        hi < point\n      } else {\n        hi <= point\n      }\n    PositiveInfinity -> False\n    NegativeInfinity -> True\n  }\n}",
      "tests": [
        "test is_entirely_before_1() {\n  is_entirely_before(before(10), 15)\n}",
        "test is_entirely_before_2() {\n  !is_entirely_before(before(10), 10)\n}",
        "test is_entirely_before_3() {\n  !is_entirely_before(before(10), 5)\n}",
        "test is_entirely_before_4() {\n  is_entirely_before(between(10, 20), 30)\n}",
        "test is_entirely_before_5() {\n  !is_entirely_before(between(10, 20), 5)\n}",
        "test is_entirely_before_6() {\n  is_entirely_before(entirely_before(10), 10)\n}",
        "test is_entirely_before_7() {\n  !is_entirely_before(after(10), 15)\n}",
        "test is_entirely_before_8() {\n  !is_entirely_before(after(10), 5)\n}",
        "test is_entirely_before_9() {\n  !is_entirely_before(entirely_after(10), 5)\n}",
        "test is_entirely_before_10() {\n  is_entirely_before(\n    Interval {\n      lower_bound: IntervalBound {\n        bound_type: NegativeInfinity,\n        is_inclusive: True,\n      },\n      upper_bound: IntervalBound {\n        bound_type: NegativeInfinity,\n        is_inclusive: False,\n      },\n    },\n    1,\n  )\n}"
      ]
    },
    {
      "key": "stdlib:aiken.interval.to_string",
      "fullName": "stdlib:aiken.interval.to_string",
      "name": "to_string",
      "signature": "pub fn to_string(self: Interval) -> String {",
      "documentation": "Obtain a human-readable string representation of the interval. Useful for debugging.",
      "parameters": [
        {
          "name": "self",
          "type": "Interval",
          "optional": false
        }
      ],
      "returnType": "String",
      "line": 580,
      "raw": "pub fn to_string(self: Interval) -> String {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn to_string(self: Interval) -> String {\n  let lower_bracket =\n    if self.lower_bound.is_inclusive {\n      @\"[\"\n    } else {\n      @\"(\"\n    }\n\n  let lower_bound = bound_type_to_string(self.lower_bound.bound_type)\n\n  let upper_bound = bound_type_to_string(self.upper_bound.bound_type)\n\n  let upper_bracket =\n    if self.upper_bound.is_inclusive {\n      @\"]\"\n    } else {\n      @\")\"\n    }\n\n  lower_bracket\n    |> string.concat(lower_bound)\n    |> string.concat(@\", \")\n    |> string.concat(upper_bound)\n    |> string.concat(upper_bracket)\n}"
    },
    {
      "key": "stdlib:aiken.interval.hull",
      "fullName": "stdlib:aiken.interval.hull",
      "name": "hull",
      "signature": "pub fn hull(iv1: Interval, iv2: Interval) -> Interval {",
      "documentation": "Computes the smallest interval containing the two given intervals, if any\n\n```aiken\nlet iv1 = between(0, 10) // [0, 10]\nlet iv2 = between(2, 14) // [2, 14]\nhull(iv1, iv2) == between(0, 14)\n\nlet iv1 = between(5, 10) // [5, 10]\nlet iv2 = before(0) // [ْ-∞, 0]\nhull(iv1, iv2) == before(10)\n\nlet iv1 = entirely_after(0) // (0, +∞]\nlet iv2 = between(10, 42)  // [10, 42]\nhull(iv1, iv2) = entirely_after(0)\n```",
      "parameters": [
        {
          "name": "iv1",
          "type": "Interval",
          "optional": false
        },
        {
          "name": "iv2",
          "type": "Interval",
          "optional": false
        }
      ],
      "returnType": "Interval",
      "line": 631,
      "raw": "pub fn hull(iv1: Interval, iv2: Interval) -> Interval {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn hull(iv1: Interval, iv2: Interval) -> Interval {\n  Interval {\n    lower_bound: min(iv1.lower_bound, iv2.lower_bound),\n    upper_bound: max(iv1.upper_bound, iv2.upper_bound),\n  }\n}",
      "tests": [
        "test hull_1() {\n  let iv1 = between(0, 10)\n  let iv2 = between(2, 14)\n  hull(iv1, iv2) == between(0, 14)\n}",
        "test hull_2() {\n  let iv1 = between(5, 10)\n  let iv2 = before(0)\n  hull(iv1, iv2) == before(10)\n}",
        "test hull_3() {\n  let iv1 = entirely_after(0)\n  let iv2 = between(10, 42)\n  hull(iv1, iv2) == entirely_after(0)\n}"
      ]
    },
    {
      "key": "stdlib:aiken.interval.includes",
      "fullName": "stdlib:aiken.interval.includes",
      "name": "includes",
      "signature": "pub fn includes(self: Interval, other: Interval) -> Bool {",
      "documentation": "Checks whether the second interval is fully included in the first.\n\n```aiken\nbetween(-5, 5)  // [-5, 5]\n|> includes(between(0, 2)) // [0, 2]\n\nbetween(-5, 5)  // [-5, 5]\n|> includes(entirely_between(-5, 5)) // (-5, 5)\n\nafter(0) // [0, +∞]\n|> includes(after(1)) // [1, +∞]\n\nbefore(-1) // (-∞, -1]\n|> includes(entirely_before(-1)) // [-∞, -1)\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Interval",
          "optional": false
        },
        {
          "name": "other",
          "type": "Interval",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 671,
      "raw": "pub fn includes(self: Interval, other: Interval) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn includes(self: Interval, other: Interval) -> Bool {\n  and {\n    !is_empty(self),\n    or {\n      is_empty(other),\n      and {\n        compare_bound_type(\n          other.lower_bound.bound_type,\n          self.lower_bound.bound_type,\n          fn() { False },\n          fn(_) {\n            self.lower_bound.is_inclusive || !other.lower_bound.is_inclusive\n          },\n          fn() { True },\n        ),\n        compare_bound_type(\n          other.upper_bound.bound_type,\n          self.upper_bound.bound_type,\n          fn() { True },\n          fn(_) {\n            self.upper_bound.is_inclusive || !other.upper_bound.is_inclusive\n          },\n          fn() { False },\n        ),\n      },\n    },\n  }\n}",
      "tests": [
        "test includes_1() {\n  between(-5, 5) |> includes(between(-5, 5))\n}",
        "test includes_2() {\n  between(-5, 5) |> includes(between(0, 2))\n}",
        "test includes_3() {\n  between(-5, 5) |> includes(entirely_between(-5, 5))\n}",
        "test includes_4() {\n  !(entirely_between(-5, 5) |> includes(between(-5, 5)))\n}",
        "test includes_5() {\n  and {\n    after(0) |> includes(after(1)),\n    entirely_after(0) |> includes(entirely_after(1)),\n  }\n}",
        "test includes_6() {\n  and {\n    after(0) |> includes(after(1)),\n    entirely_after(0) |> includes(after(1)),\n  }\n}",
        "test includes_7() {\n  and {\n    before(0) |> includes(before(-1)),\n    entirely_before(0) |> includes(before(-1)),\n  }\n}",
        "test includes_8() {\n  and {\n    !(before(-1) |> includes(before(0))),\n    !(entirely_before(-1) |> includes(before(0))),\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.interval.intersection",
      "fullName": "stdlib:aiken.interval.intersection",
      "name": "intersection",
      "signature": "pub fn intersection(iv1: Interval, iv2: Interval) -> Interval {",
      "documentation": "Computes the largest interval contained in the two given intervals, if any.\n\n```aiken\nlet iv1 = interval.between(0, 10) // [0, 10]\nlet iv2 = interval.between(2, 14) // [2, 14]\ninterval.intersection(iv1, iv2) == interval.between(2, 10)\n\nlet iv1 = interval.entirely_before(10) // [-∞, 10)\nlet iv2 = interval.entirely_after(0) // (0, +∞]\ninterval.intersection(iv1, iv2) == interval.entirely_between(0, 10)\n\nlet iv1 = interval.between(0, 1) // [0, 1]\nlet iv2 = interval.between(2, 3) // [2, 3]\ninterval.intersection(iv1, iv2) |> interval.is_empty\n```",
      "parameters": [
        {
          "name": "iv1",
          "type": "Interval",
          "optional": false
        },
        {
          "name": "iv2",
          "type": "Interval",
          "optional": false
        }
      ],
      "returnType": "Interval",
      "line": 759,
      "raw": "pub fn intersection(iv1: Interval, iv2: Interval) -> Interval {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn intersection(iv1: Interval, iv2: Interval) -> Interval {\n  Interval {\n    lower_bound: max(iv1.lower_bound, iv2.lower_bound),\n    upper_bound: min(iv1.upper_bound, iv2.upper_bound),\n  }\n}",
      "tests": [
        "test intersection_1() {\n  let iv1 = between(0, 10)\n  let iv2 = between(2, 14)\n  intersection(iv1, iv2) == between(2, 10)\n}",
        "test intersection_2() {\n  let iv1 = between(0, 1)\n  let iv2 = between(1, 2)\n  intersection(iv1, iv2) == between(1, 1)\n}",
        "test intersection_3() {\n  let iv1 = between(0, 1)\n  let iv2 = entirely_between(1, 2)\n  intersection(iv1, iv2)\n    |> is_empty\n}",
        "test intersection_4() {\n  let iv1 = entirely_between(0, 1)\n  let iv2 = entirely_between(1, 2)\n  intersection(iv1, iv2)\n    |> is_empty\n}",
        "test intersection_5() {\n  let iv1 = between(0, 10)\n  let iv2 = before(4)\n  intersection(iv1, iv2) == between(0, 4)\n}",
        "test intersection_6() {\n  let iv1 = entirely_before(10)\n  let iv2 = entirely_after(0)\n  intersection(iv1, iv2) == entirely_between(0, 10)\n}"
      ]
    },
    {
      "key": "stdlib:aiken.interval.max",
      "fullName": "stdlib:aiken.interval.max",
      "name": "max",
      "signature": "pub fn max(left: IntervalBound, right: IntervalBound) -> IntervalBound {",
      "documentation": "Return the highest bound of the two. For equal `IntervalBoundType`,\nan inclusive `IntervalBound` is considered higher.\n\n```aiken\nlet ib1 = IntervalBound { bound_type: Finite(0), is_inclusive: False }\nlet ib2 = IntervalBound { bound_type: Finite(1), is_inclusive: False }\n\ninterval.max(ib1, ib2) == ib2\n```",
      "parameters": [
        {
          "name": "left",
          "type": "IntervalBound",
          "optional": false
        },
        {
          "name": "right",
          "type": "IntervalBound",
          "optional": false
        }
      ],
      "returnType": "IntervalBound",
      "line": 813,
      "raw": "pub fn max(left: IntervalBound, right: IntervalBound) -> IntervalBound {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn max(left: IntervalBound, right: IntervalBound) -> IntervalBound {\n  compare_bound_type(\n    left.bound_type,\n    right.bound_type,\n    fn() { right },\n    fn(is_negative) {\n      if left.is_inclusive == right.is_inclusive {\n        left\n      } else if is_negative {\n        if left.is_inclusive {\n          right\n        } else {\n          left\n        }\n      } else {\n        if left.is_inclusive {\n          left\n        } else {\n          right\n        }\n      }\n    },\n    fn() { left },\n  )\n}"
    },
    {
      "key": "stdlib:aiken.interval.min",
      "fullName": "stdlib:aiken.interval.min",
      "name": "min",
      "signature": "pub fn min(left: IntervalBound, right: IntervalBound) -> IntervalBound {",
      "documentation": "Return the smallest bound of the two. For equal `IntervalBoundType`,\nan inclusive `IntervalBound` is considered smaller.\n\n```aiken\nlet ib1 = IntervalBound { bound_type: Finite(0), is_inclusive: False }\nlet ib2 = IntervalBound { bound_type: Finite(1), is_inclusive: False }\n\ninterval.min(ib1, ib2) == ib1\n```",
      "parameters": [
        {
          "name": "left",
          "type": "IntervalBound",
          "optional": false
        },
        {
          "name": "right",
          "type": "IntervalBound",
          "optional": false
        }
      ],
      "returnType": "IntervalBound",
      "line": 848,
      "raw": "pub fn min(left: IntervalBound, right: IntervalBound) -> IntervalBound {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn min(left: IntervalBound, right: IntervalBound) -> IntervalBound {\n  compare_bound_type(\n    left.bound_type,\n    right.bound_type,\n    fn() { left },\n    fn(is_negative) {\n      if left.is_inclusive == right.is_inclusive {\n        left\n      } else if is_negative {\n        if left.is_inclusive {\n          left\n        } else {\n          right\n        }\n      } else {\n        if left.is_inclusive {\n          right\n        } else {\n          left\n        }\n      }\n    },\n    fn() { right },\n  )\n}"
    },
    {
      "key": "stdlib:aiken.math.rational.from_int",
      "fullName": "stdlib:aiken.math.rational.from_int",
      "name": "from_int",
      "signature": "pub fn from_int(numerator: Int) -> Rational {",
      "documentation": "Create a new `Rational` from an `Int`.\n\n```aiken\nSome(rational.from_int(14)) == rational.new(14, 1)\nSome(rational.from_int(-5)) == rational.new(-5, 1)\nSome(rational.from_int(0)) == rational.new(0, 1)\n```",
      "parameters": [
        {
          "name": "numerator",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Rational",
      "line": 34,
      "raw": "pub fn from_int(numerator: Int) -> Rational {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_int(numerator: Int) -> Rational {\n  Rational { numerator, denominator: 1 }\n}",
      "tests": [
        "test from_int_1() {\n  and {\n    (from_int(14) == ratio(14, 1))?,\n    (from_int(-5) == ratio(-5, 1))?,\n    (from_int(0) == ratio(0, 1))?,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.new",
      "fullName": "stdlib:aiken.math.rational.new",
      "name": "new",
      "signature": "pub fn new(numerator: Int, denominator: Int) -> Option<Rational> {",
      "documentation": "Make a `Rational` number from the ratio of two integers.\n\nReturns `None` when the denominator is null.\n\n```aiken\nrational.new(14, 42) == Some(r)\nrational.new(14, 0) == None\n```",
      "parameters": [
        {
          "name": "numerator",
          "type": "Int",
          "optional": false
        },
        {
          "name": "denominator",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Option<Rational>",
      "line": 65,
      "raw": "pub fn new(numerator: Int, denominator: Int) -> Option<Rational> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn new(numerator: Int, denominator: Int) -> Option<Rational> {\n  if denominator == 0 {\n    None\n  } else if denominator < 0 {\n    Some(Rational { numerator: -numerator, denominator: -denominator })\n  } else {\n    Some(Rational { numerator, denominator })\n  }\n}",
      "tests": [
        "test new_1() {\n  and {\n    (new(2, 0) == None)?,\n    (new(2, 3) == Some(ratio(2, 3)))?,\n    (new(-2, 3) == Some(ratio(-2, 3)))?,\n    (new(2, -3) == Some(ratio(-2, 3)))?,\n    (new(2, 4) == Some(ratio(2, 4)))?,\n    (new(-2, -3) == Some(ratio(2, 3)))?,\n    (new(-2, -4) == Some(ratio(2, 4)))?,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.denominator",
      "fullName": "stdlib:aiken.math.rational.denominator",
      "name": "denominator",
      "signature": "pub fn denominator(self: Rational) -> Int {",
      "documentation": "Get the denominator of a rational value.\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nrational.denominator(x) == 3\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Rational",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 102,
      "raw": "pub fn denominator(self: Rational) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn denominator(self: Rational) -> Int {\n  self.denominator\n}",
      "tests": [
        "test denominator_1() {\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(-2, 3)\n  expect Some(z) = new(2, -3)\n  expect Some(w) = new(-2, -3)\n  and {\n    (denominator(x) == 3)?,\n    (denominator(y) == 3)?,\n    (denominator(z) == 3)?,\n    (denominator(w) == 3)?,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.numerator",
      "fullName": "stdlib:aiken.math.rational.numerator",
      "name": "numerator",
      "signature": "pub fn numerator(self: Rational) -> Int {",
      "documentation": "Get the numerator of a rational value.\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nrational.numerator(x) == 2\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Rational",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 125,
      "raw": "pub fn numerator(self: Rational) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn numerator(self: Rational) -> Int {\n  self.numerator\n}",
      "tests": [
        "test numerator_1() {\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(-2, 3)\n  expect Some(z) = new(2, -3)\n  expect Some(w) = new(-2, -3)\n\n  and {\n    (numerator(x) == 2)?,\n    (numerator(y) == -2)?,\n    (numerator(z) == -2)?,\n    (numerator(w) == 2)?,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.abs",
      "fullName": "stdlib:aiken.math.rational.abs",
      "name": "abs",
      "signature": "pub fn abs(self: Rational) -> Rational {",
      "documentation": "Absolute value of a `Rational`.\n\n```aiken\nexpect Some(x) = rational.new(3, 2)\nexpect Some(y) = rational.new(-3, 2)\n\nrational.abs(x) == x\nrational.abs(y) == x\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Rational",
          "optional": false
        }
      ],
      "returnType": "Rational",
      "line": 154,
      "raw": "pub fn abs(self: Rational) -> Rational {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn abs(self: Rational) -> Rational {\n  let Rational { numerator: a_n, denominator: a_d } = self\n  Rational { numerator: math.abs(a_n), denominator: a_d }\n}",
      "tests": [
        "test abs_examples() {\n  and {\n    (abs(ratio(5, 2)) == ratio(5, 2))?,\n    (abs(ratio(-5, 2)) == ratio(5, 2))?,\n    (abs(ratio(5, 2)) == abs(ratio(-5, 2)))?,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.negate",
      "fullName": "stdlib:aiken.math.rational.negate",
      "name": "negate",
      "signature": "pub fn negate(a: Rational) -> Rational {",
      "documentation": "Change the sign of a `Rational`.\n\n```aiken\nexpect Some(x) = rational.new(3, 2)\nexpect Some(y) = rational.new(-3, 2)\n\nrational.negate(x) == y\nrational.negate(y) == x\n```",
      "parameters": [
        {
          "name": "a",
          "type": "Rational",
          "optional": false
        }
      ],
      "returnType": "Rational",
      "line": 176,
      "raw": "pub fn negate(a: Rational) -> Rational {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn negate(a: Rational) -> Rational {\n  let Rational { numerator: a_n, denominator: a_d } = a\n  Rational { numerator: -a_n, denominator: a_d }\n}",
      "tests": [
        "test negate_1() {\n  and {\n    (negate(ratio(5, 2)) == ratio(-5, 2))?,\n    (negate(ratio(-5, 2)) == ratio(5, 2))?,\n    (negate(negate(ratio(5, 2))) == ratio(5, 2))?,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.reciprocal",
      "fullName": "stdlib:aiken.math.rational.reciprocal",
      "name": "reciprocal",
      "signature": "pub fn reciprocal(self: Rational) -> Option<Rational> {",
      "documentation": "Reciprocal of a `Rational` number. That is, a new `Rational` where the\nnumerator and denominator have been swapped.\n\n```aiken\nexpect Some(x) = rational.new(2, 5)\nrational.reciprocal(x) == rational.new(5, 2)\n\nlet y = rational.zero\nrational.reciprocal(y) == None\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Rational",
          "optional": false
        }
      ],
      "returnType": "Option<Rational>",
      "line": 199,
      "raw": "pub fn reciprocal(self: Rational) -> Option<Rational> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn reciprocal(self: Rational) -> Option<Rational> {\n  let Rational { numerator: a_n, denominator: a_d } = self\n  if a_n < 0 {\n    Some(Rational { numerator: -a_d, denominator: -a_n })\n  } else if a_n > 0 {\n    Some(Rational { numerator: a_d, denominator: a_n })\n  } else {\n    None\n  }\n}",
      "tests": [
        "test reciprocal_1() {\n  and {\n    (reciprocal(ratio(5, 2)) == new(2, 5))?,\n    (reciprocal(ratio(-5, 2)) == new(-2, 5))?,\n    (reciprocal(ratio(0, 2)) == None)?,\n    (reciprocal(ratio(2, 3)) == new(3, 2))?,\n    (reciprocal(ratio(-2, 3)) == new(-3, 2))?,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.reduce",
      "fullName": "stdlib:aiken.math.rational.reduce",
      "name": "reduce",
      "signature": "pub fn reduce(self: Rational) -> Rational {",
      "documentation": "Reduce a rational to its irreducible form. This operation makes the\nnumerator and denominator coprime.\n\n```aiken\nexpect Some(x) = rational.new(80, 200)\nSome(rational.reduce(x)) == rational.new(2, 5)\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Rational",
          "optional": false
        }
      ],
      "returnType": "Rational",
      "line": 227,
      "raw": "pub fn reduce(self: Rational) -> Rational {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn reduce(self: Rational) -> Rational {\n  let Rational { numerator: a_n, denominator: a_d } = self\n  let d = math.gcd(a_n, a_d)\n  Rational { numerator: a_n / d, denominator: a_d / d }\n}",
      "tests": [
        "test reduce_1() {\n  and {\n    (reduce(ratio(80, 200)) == ratio(2, 5))?,\n    (reduce(ratio(-5, 1)) == ratio(-5, 1))?,\n    (reduce(ratio(0, 3)) == ratio(0, 1))?,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.add",
      "fullName": "stdlib:aiken.math.rational.add",
      "name": "add",
      "signature": "pub fn add(left: Rational, right: Rational) -> Rational {",
      "documentation": "Addition: sum of two rational values\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nexpect Some(y) = rational.new(3, 4)\n\nSome(rational.add(x, y)) == rational.new(17, 12)\n```",
      "parameters": [
        {
          "name": "left",
          "type": "Rational",
          "optional": false
        },
        {
          "name": "right",
          "type": "Rational",
          "optional": false
        }
      ],
      "returnType": "Rational",
      "line": 253,
      "raw": "pub fn add(left: Rational, right: Rational) -> Rational {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn add(left: Rational, right: Rational) -> Rational {\n  let Rational { numerator: a_n, denominator: a_d } = left\n  let Rational { numerator: b_n, denominator: b_d } = right\n  Rational { numerator: a_n * b_d + b_n * a_d, denominator: a_d * b_d }\n}",
      "tests": [
        "test add_1() {\n  add(ratio(2, 3), ratio(3, 4)) == ratio(17, 12)\n}",
        "test add_2() {\n  add(ratio(-2, 3), ratio(3, 4)) == ratio(1, 12)\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.div",
      "fullName": "stdlib:aiken.math.rational.div",
      "name": "div",
      "signature": "pub fn div(left: Rational, right: Rational) -> Option<Rational> {",
      "documentation": "Division: quotient of two rational values. Returns `None` when the second\nvalue is null.\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nexpect Some(y) = rational.new(3, 4)\n\nrational.div(x, y) == rational.new(8, 9)\n```",
      "parameters": [
        {
          "name": "left",
          "type": "Rational",
          "optional": false
        },
        {
          "name": "right",
          "type": "Rational",
          "optional": false
        }
      ],
      "returnType": "Option<Rational>",
      "line": 276,
      "raw": "pub fn div(left: Rational, right: Rational) -> Option<Rational> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn div(left: Rational, right: Rational) -> Option<Rational> {\n  reciprocal(right) |> option.map(mul(left, _))\n}",
      "tests": [
        "test div_1() {\n  div(ratio(2, 3), ratio(3, 4)) == new(8, 9)\n}",
        "test div_2() {\n  div(ratio(2, 3), ratio(-3, 4)) == new(-8, 9)\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.mul",
      "fullName": "stdlib:aiken.math.rational.mul",
      "name": "mul",
      "signature": "pub fn mul(left: Rational, right: Rational) -> Rational {",
      "documentation": "Multiplication: the product of two rational values.\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nexpect Some(y) = rational.new(3, 4)\n\nSome(rational.mul(x, y)) == rational.new(6, 12)\n```",
      "parameters": [
        {
          "name": "left",
          "type": "Rational",
          "optional": false
        },
        {
          "name": "right",
          "type": "Rational",
          "optional": false
        }
      ],
      "returnType": "Rational",
      "line": 296,
      "raw": "pub fn mul(left: Rational, right: Rational) -> Rational {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn mul(left: Rational, right: Rational) -> Rational {\n  let Rational { numerator: a_n, denominator: a_d } = left\n  let Rational { numerator: b_n, denominator: b_d } = right\n  Rational { numerator: a_n * b_n, denominator: a_d * b_d }\n}",
      "tests": [
        "test mul_1() {\n  mul(ratio(2, 3), ratio(3, 4)) == ratio(6, 12)\n}",
        "test mul_2() {\n  mul(ratio(-2, 3), ratio(-3, 4)) == ratio(6, 12)\n}",
        "test mul_3() {\n  let result =\n    ratio(2, 5)\n      |> mul(ratio(1, 8))\n      |> mul(ratio(3, 10))\n      |> mul(ratio(21, 100))\n      |> mul(ratio(3, 5))\n      |> mul(ratio(2, 8))\n      |> mul(ratio(4, 10))\n      |> mul(ratio(22, 100))\n      |> reduce\n\n  result == ratio(2079, 50000000)\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.sub",
      "fullName": "stdlib:aiken.math.rational.sub",
      "name": "sub",
      "signature": "pub fn sub(left: Rational, right: Rational) -> Rational {",
      "documentation": "Subtraction: difference of two rational values\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nexpect Some(y) = rational.new(3, 4)\n\nSome(rational.sub(x, y)) == rational.new(-1, 12)\n```",
      "parameters": [
        {
          "name": "left",
          "type": "Rational",
          "optional": false
        },
        {
          "name": "right",
          "type": "Rational",
          "optional": false
        }
      ],
      "returnType": "Rational",
      "line": 333,
      "raw": "pub fn sub(left: Rational, right: Rational) -> Rational {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sub(left: Rational, right: Rational) -> Rational {\n  let Rational { numerator: a_n, denominator: a_d } = left\n  let Rational { numerator: b_n, denominator: b_d } = right\n  Rational { numerator: a_n * b_d - b_n * a_d, denominator: a_d * b_d }\n}",
      "tests": [
        "test sub_1() {\n  sub(ratio(2, 3), ratio(3, 4)) == ratio(-1, 12)\n}",
        "test sub_2() {\n  sub(ratio(2, 3), ratio(-3, 4)) == ratio(17, 12)\n}",
        "test sub_3() {\n  sub(ratio(-2, 3), ratio(3, 4)) == ratio(-17, 12)\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.compare",
      "fullName": "stdlib:aiken.math.rational.compare",
      "name": "compare",
      "signature": "pub fn compare(left: Rational, right: Rational) -> Ordering {",
      "documentation": "Compare two rationals for an ordering. This is safe to use even for\nnon-reduced rationals.\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nexpect Some(y) = rational.new(3, 4)\nexpect Some(z) = rational.new(4, 6)\n\ncompare(x, y) == Less\ncompare(y, x) == Greater\ncompare(x, x) == Equal\ncompare(x, z) == Equal\n```",
      "parameters": [
        {
          "name": "left",
          "type": "Rational",
          "optional": false
        },
        {
          "name": "right",
          "type": "Rational",
          "optional": false
        }
      ],
      "returnType": "Ordering",
      "line": 366,
      "raw": "pub fn compare(left: Rational, right: Rational) -> Ordering {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn compare(left: Rational, right: Rational) -> Ordering {\n  let Rational { numerator: a_n, denominator: a_d } = left\n  let Rational { numerator: b_n, denominator: b_d } = right\n\n  let l = a_n * b_d\n  let r = b_n * a_d\n\n  if l < r {\n    Less\n  } else if l > r {\n    Greater\n  } else {\n    Equal\n  }\n}",
      "tests": [
        "test compare_1() {\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n  expect Some(z) = new(4, 6)\n  and {\n    compare(x, y) == Less,\n    compare(y, x) == Greater,\n    compare(x, x) == Equal,\n    compare(x, z) == Equal,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.compare_with",
      "fullName": "stdlib:aiken.math.rational.compare_with",
      "name": "compare_with",
      "signature": "pub fn compare_with(pub fn compare_with(left: Rational, with: fn(Int, Int) -> Bool, right: Rational,",
      "documentation": "Comparison of two rational values using a chosen heuristic. For example:\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nexpect Some(y) = rational.new(3, 4)\n\nrational.compare_with(x, >, y) == False\nrational.compare_with(y, >, x) == True\nrational.compare_with(x, >, x) == False\nrational.compare_with(x, >=, x) == True\nrational.compare_with(x, ==, x) == True\nrational.compare_with(x, ==, y) == False\n```",
      "parameters": [],
      "returnType": "Bool, right: Rational,",
      "line": 407,
      "raw": "pub fn compare_with(pub fn compare_with(left: Rational, with: fn(Int, Int) -> Bool, right: Rational,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn compare_with(\n  left: Rational,\n  with: fn(Int, Int) -> Bool,\n  right: Rational,\n) -> Bool {\n  let Rational { numerator: a_n, denominator: a_d } = left\n  let Rational { numerator: b_n, denominator: b_d } = right\n  with(a_n * b_d, b_n * a_d)\n}",
      "tests": [
        "test compare_with_eq() {\n  let eq =\n    compare_with(_, fn(l, r) { l == r }, _)\n\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n\n  !eq(x, y)? && !eq(y, x)? && eq(x, x)?\n}",
        "test compare_with_neq() {\n  let neq =\n    compare_with(_, fn(l, r) { l != r }, _)\n\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n\n  neq(x, y)? && neq(y, x)? && !neq(x, x)?\n}",
        "test compare_with_gte() {\n  let gte =\n    compare_with(_, fn(l, r) { l >= r }, _)\n\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n\n  !gte(x, y)? && gte(y, x)? && gte(x, x)?\n}",
        "test compare_with_gt() {\n  let gt =\n    compare_with(_, fn(l, r) { l > r }, _)\n\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n\n  !gt(x, y)? && gt(y, x)? && !gt(x, x)?\n}",
        "test compare_with_lte() {\n  let lte =\n    compare_with(_, fn(l, r) { l <= r }, _)\n\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n\n  lte(x, y)? && !lte(y, x)? && lte(x, x)?\n}",
        "test compare_with_lt() {\n  let lt =\n    compare_with(_, fn(l, r) { l < r }, _)\n\n  expect Some(x) = new(2, 3)\n  expect Some(y) = new(3, 4)\n\n  lt(x, y)? && !lt(y, x)? && !lt(x, x)?\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.arithmetic_mean",
      "fullName": "stdlib:aiken.math.rational.arithmetic_mean",
      "name": "arithmetic_mean",
      "signature": "pub fn arithmetic_mean(self: List<Rational>) -> Option<Rational> {",
      "documentation": "Calculate the arithmetic mean between two `Rational` values.\n\n```aiken\nlet x = rational.from_int(0)\nlet y = rational.from_int(1)\nlet z = rational.from_int(2)\n\nexpect Some(result) = rational.arithmetic_mean([x, y, z])\n\nrational.compare(result, y) == Equal\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<Rational>",
          "optional": false
        }
      ],
      "returnType": "Option<Rational>",
      "line": 492,
      "raw": "pub fn arithmetic_mean(self: List<Rational>) -> Option<Rational> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn arithmetic_mean(self: List<Rational>) -> Option<Rational> {\n  div(list.foldr(self, zero, add), from_int(list.length(self)))\n}",
      "tests": [
        "test arithmetic_mean_1() {\n  let x = ratio(1, 2)\n  let y = ratio(1, 2)\n  expect Some(z) = arithmetic_mean([x, y])\n  reduce(z) == ratio(1, 2)\n}",
        "test arithmetic_mean_2() {\n  let x = ratio(1, 1)\n  let y = ratio(2, 1)\n  expect Some(z) = arithmetic_mean([x, y])\n  reduce(z) == ratio(3, 2)\n}",
        "test arithmetic_mean_3() {\n  let xs =\n    [\n      ratio(1, 1),\n      ratio(2, 1),\n      ratio(3, 1),\n      ratio(4, 1),\n      ratio(5, 1),\n      ratio(6, 1),\n    ]\n  expect Some(z) = arithmetic_mean(xs)\n  reduce(z) == ratio(7, 2)\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.geometric_mean",
      "fullName": "stdlib:aiken.math.rational.geometric_mean",
      "name": "geometric_mean",
      "signature": "pub fn geometric_mean(left: Rational, right: Rational) -> Option<Rational> {",
      "documentation": "Calculate the geometric mean between two `Rational` values. This returns\neither the exact result or the smallest integer nearest to the square root\nfor the numerator and denominator.\n\n```aiken\nexpect Some(x) = rational.new(1, 3)\nexpect Some(y) = rational.new(1, 6)\n\nrational.geometric_mean(x, y) == rational.new(1, 4)\n```",
      "parameters": [
        {
          "name": "left",
          "type": "Rational",
          "optional": false
        },
        {
          "name": "right",
          "type": "Rational",
          "optional": false
        }
      ],
      "returnType": "Option<Rational>",
      "line": 534,
      "raw": "pub fn geometric_mean(left: Rational, right: Rational) -> Option<Rational> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn geometric_mean(left: Rational, right: Rational) -> Option<Rational> {\n  let Rational { numerator: a_n, denominator: a_d } = left\n  let Rational { numerator: b_n, denominator: b_d } = right\n  when math.sqrt(a_n * b_n) is {\n    Some(numerator) ->\n      when math.sqrt(a_d * b_d) is {\n        Some(denominator) -> Some(Rational { numerator, denominator })\n        None -> None\n      }\n    None -> None\n  }\n}",
      "tests": [
        "test geometric_mean1() {\n  expect Some(x) = new(1, 2)\n  expect Some(y) = new(1, 2)\n  geometric_mean(x, y) == new(1, 2)\n}",
        "test geometric_mean2() {\n  expect Some(x) = new(-1, 2)\n  expect Some(y) = new(1, 2)\n  geometric_mean(x, y) == None\n}",
        "test geometric_mean3() {\n  expect Some(x) = new(1, 2)\n  expect Some(y) = new(-1, 2)\n  geometric_mean(x, y) == None\n}",
        "test geometric_mean4() {\n  expect Some(x) = new(1, 3)\n  expect Some(y) = new(1, 6)\n  geometric_mean(x, y) == new(1, 4)\n}",
        "test geometric_mean5() {\n  expect Some(x) = new(67, 2500)\n  expect Some(y) = new(35331, 1000)\n  expect Some(yi) = reciprocal(y)\n  geometric_mean(x, yi) == new(258, 9398)\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.ceil",
      "fullName": "stdlib:aiken.math.rational.ceil",
      "name": "ceil",
      "signature": "pub fn ceil(self: Rational) -> Int {",
      "documentation": "Returns the smallest `Int` not less than a given `Rational`\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nrational.ceil(x) == 1\n\nexpect Some(y) = rational.new(44, 14)\nrational.ceil(y) == 4\n\nexpect Some(z) = rational.new(-14, 3)\nrational.ceil(z) == -4\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Rational",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 592,
      "raw": "pub fn ceil(self: Rational) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn ceil(self: Rational) -> Int {\n  let Rational { numerator, denominator } = self\n  if builtin.remainder_integer(numerator, denominator) > 0 {\n    builtin.quotient_integer(numerator, denominator) + 1\n  } else {\n    builtin.quotient_integer(numerator, denominator)\n  }\n}",
      "tests": [
        "test ceil_1() {\n  and {\n    (ceil(ratio(13, 5)) == 3)?,\n    (ceil(ratio(15, 5)) == 3)?,\n    (ceil(ratio(16, 5)) == 4)?,\n    (ceil(ratio(-3, 5)) == 0)?,\n    (ceil(ratio(-5, 5)) == -1)?,\n    (ceil(ratio(-14, 3)) == -4)?,\n    (ceil(ratio(-14, 6)) == -2)?,\n    (ceil(ratio(44, 14)) == 4)?,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.floor",
      "fullName": "stdlib:aiken.math.rational.floor",
      "name": "floor",
      "signature": "pub fn floor(self: Rational) -> Int {",
      "documentation": "Returns the greatest `Int` no greater than a given `Rational`\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nrational.floor(x) == 0\n\nexpect Some(y) = rational.new(44, 14)\nrational.floor(y) == 3\n\nexpect Some(z) = rational.new(-14, 3)\nrational.floor(z) == -5\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Rational",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 626,
      "raw": "pub fn floor(self: Rational) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn floor(self: Rational) -> Int {\n  let Rational { numerator: a_n, denominator: a_d } = self\n  a_n / a_d\n}",
      "tests": [
        "test floor_1() {\n  and {\n    (floor(ratio(5, 2)) == 2)?,\n    (floor(ratio(5, 3)) == 1)?,\n    (floor(ratio(5, 4)) == 1)?,\n    (floor(ratio(5, 5)) == 1)?,\n    (floor(ratio(5, 6)) == 0)?,\n    (floor(ratio(8, 3)) == 2)?,\n    (floor(ratio(-14, 3)) == -5)?,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.pow",
      "fullName": "stdlib:aiken.math.rational.pow",
      "name": "pow",
      "signature": "pub fn pow(x: Rational, y: Int) -> Option<Rational> {",
      "documentation": "Computes the rational number x raised to the power y. Returns `None` for\ninvalid exponentiation.\n\n```aiken\nexpect Some(x) = rational.new(50, 2500)\nrational.reduce(rational.pow(x, 3)) == rational.new(1, 125000)\n\nexpect Some(x) = rational.new(50, 2500)\nrational.reduce(rational.pow(x, -3)) == rational.new(125000, 1)\n```",
      "parameters": [
        {
          "name": "x",
          "type": "Rational",
          "optional": false
        },
        {
          "name": "y",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Option<Rational>",
      "line": 653,
      "raw": "pub fn pow(x: Rational, y: Int) -> Option<Rational> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn pow(x: Rational, y: Int) -> Option<Rational> {\n  let Rational { numerator: a, denominator: b } = x\n\n  if a == 0 && y <= 0 {\n    None\n  } else if y > 0 {\n    Some(Rational { numerator: math.pow(a, y), denominator: math.pow(b, y) })\n  } else if y < 0 {\n    Some(Rational { numerator: math.pow(b, -y), denominator: math.pow(a, -y) })\n  } else {\n    Some(Rational { numerator: 1, denominator: 1 })\n  }\n}",
      "tests": [
        "test pow_negative_exponent_non_zero_fraction() {\n  expect Some(base) = new(50, 2500)\n  expect Some(calculated_result) = pow(base, -3)\n  expect Some(expected_result) = new(125000, 1)\n  reduce(calculated_result) == expected_result\n}",
        "test pow_positive_exponent() {\n  expect Some(base) = new(50, 2500)\n  expect Some(calculated_result) = pow(base, 3)\n  expect Some(expected_result) = new(1, 125000)\n  reduce(calculated_result) == expected_result\n}",
        "test pow_exponent_zero() {\n  expect Some(base) = new(50, 2500)\n  pow(base, 0) == new(1, 1)\n}",
        "test pow_rational_zero_exponent_zero() {\n  expect Some(base) = new(0, 1)\n  pow(base, 0) == None\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.proper_fraction",
      "fullName": "stdlib:aiken.math.rational.proper_fraction",
      "name": "proper_fraction",
      "signature": "pub fn proper_fraction(self: Rational) -> (Int, Rational) {",
      "documentation": "Returns the proper fraction of a given `Rational` `r`. That is, a 2-tuple of\nan `Int` and `Rational` (n, f) such that:\n\n- `r = n + f`;\n- `n` and `f` have the same sign as `r`;\n- `f` has an absolute value less than 1.",
      "parameters": [
        {
          "name": "self",
          "type": "Rational",
          "optional": false
        }
      ],
      "returnType": "(Int, Rational)",
      "line": 697,
      "raw": "pub fn proper_fraction(self: Rational) -> (Int, Rational) {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn proper_fraction(self: Rational) -> (Int, Rational) {\n  let Rational { numerator, denominator } = self\n  (\n    builtin.quotient_integer(numerator, denominator),\n    Rational {\n      numerator: builtin.remainder_integer(numerator, denominator),\n      denominator,\n    },\n  )\n}",
      "tests": [
        "test proper_fraction_1() {\n  let r = ratio(10, 7)\n  let (n, f) = proper_fraction(r)\n  and {\n    (n == 1)?,\n    (f == ratio(3, 7))?,\n    (r == add(from_int(n), f))?,\n  }\n}",
        "test proper_fraction_2() {\n  let r = ratio(-10, 7)\n  let (n, f) = proper_fraction(r)\n  and {\n    (n == -1)?,\n    (f == ratio(-3, 7))?,\n    (r == add(from_int(n), f))?,\n  }\n}",
        "test proper_fraction_3() {\n  let r = ratio(4, 2)\n  let (n, f) = proper_fraction(r)\n  and {\n    (n == 2)?,\n    (f == ratio(0, 2))?,\n    (r == add(from_int(n), f))?,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.round",
      "fullName": "stdlib:aiken.math.rational.round",
      "name": "round",
      "signature": "pub fn round(self: Rational) -> Int {",
      "documentation": "Round the argument to the nearest whole number. If the argument is\nequidistant between two values, the greater value is returned (it\nrounds half towards positive infinity).\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nrational.round(x) == 1\n\nexpect Some(y) = rational.new(3, 2)\nrational.round(y) == 2\n\nexpect Some(z) = rational.new(-3, 2)\nrational.round(z) == -1\n```\n\n> [!CAUTION]\n> This behaves differently than _Haskell_. If you're coming from `PlutusTx`, beware that in Haskell, rounding on equidistant values depends on the whole number being odd or even.\n> If you need this behaviour, use [`round_even`](#round_even).",
      "parameters": [
        {
          "name": "self",
          "type": "Rational",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 756,
      "raw": "pub fn round(self: Rational) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn round(self: Rational) -> Int {\n  let (n, f) = proper_fraction(self)\n\n  let is_negative = f.numerator < 0\n\n  when compare(abs(f), ratio(1, 2)) is {\n    Less -> n\n    Equal ->\n      if is_negative {\n        n\n      } else {\n        n + 1\n      }\n    Greater ->\n      if is_negative {\n        n - 1\n      } else {\n        n + 1\n      }\n  }\n}",
      "tests": [
        "test round_1() {\n  and {\n    (round(ratio(10, 7)) == 1)?,\n    (round(ratio(11, 7)) == 2)?,\n    (round(ratio(3, 2)) == 2)?,\n    (round(ratio(5, 2)) == 3)?,\n    (round(ratio(-3, 2)) == -1)?,\n    (round(ratio(-2, 3)) == -1)?,\n    (round(ratio(-10, 7)) == -1)?,\n    (round(ratio(4, 2)) == 2)?,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.round_even",
      "fullName": "stdlib:aiken.math.rational.round_even",
      "name": "round_even",
      "signature": "pub fn round_even(self: Rational) -> Int {",
      "documentation": "Round the argument to the nearest whole number. If the argument is\nequidistant between two values, it returns the value that is even (it\nrounds half to even, also known as 'banker's rounding').\n\n```aiken\nexpect Some(w) = rational.new(2, 3)\nrational.round_even(w) == 1\n\nexpect Some(x) = rational.new(3, 2)\nrational.round_even(x) == 2\n\nexpect Some(y) = rational.new(5, 2)\nrational.round_even(y) == 2\n\nexpect Some(y) = rational.new(-3, 2)\nrational.round_even(y) == -2\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Rational",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 808,
      "raw": "pub fn round_even(self: Rational) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn round_even(self: Rational) -> Int {\n  let (n, f) = proper_fraction(self)\n\n  let m =\n    when compare(f, ratio(0, 1)) is {\n      Less -> -1\n      _ -> 1\n    }\n\n  let is_even = n % 2 == 0\n\n  when compare(abs(f), ratio(1, 2)) is {\n    Less -> n\n    Equal ->\n      if is_even {\n        n\n      } else {\n        n + m\n      }\n    Greater -> n + m\n  }\n}",
      "tests": [
        "test round_even_1() {\n  and {\n    (round_even(ratio(10, 7)) == 1)?,\n    (round_even(ratio(11, 7)) == 2)?,\n    (round_even(ratio(3, 2)) == 2)?,\n    (round_even(ratio(5, 2)) == 2)?,\n    (round_even(ratio(-3, 2)) == -2)?,\n    (round_even(ratio(-2, 3)) == -1)?,\n    (round_even(ratio(-10, 7)) == -1)?,\n    (round_even(ratio(4, 2)) == 2)?,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.rational.truncate",
      "fullName": "stdlib:aiken.math.rational.truncate",
      "name": "truncate",
      "signature": "pub fn truncate(self: Rational) -> Int {",
      "documentation": "Returns the nearest `Int` between zero and a given `Rational`.\n\n```aiken\nexpect Some(x) = rational.new(2, 3)\nrational.truncate(x) == 0\n\nexpect Some(y) = rational.new(44, 14)\nrational.truncate(y) == 3\n\nexpect Some(z) = rational.new(-14, 3)\nrational.truncate(z) == -4\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Rational",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 856,
      "raw": "pub fn truncate(self: Rational) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn truncate(self: Rational) -> Int {\n  let Rational { numerator: a_n, denominator: a_d } = self\n  builtin.quotient_integer(a_n, a_d)\n}",
      "tests": [
        "test truncate_1() {\n  and {\n    (truncate(ratio(5, 2)) == 2)?,\n    (truncate(ratio(5, 3)) == 1)?,\n    (truncate(ratio(5, 4)) == 1)?,\n    (truncate(ratio(5, 5)) == 1)?,\n    (truncate(ratio(5, 6)) == 0)?,\n    (truncate(ratio(8, 3)) == 2)?,\n    (truncate(ratio(-14, 3)) == -4)?,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.abs",
      "fullName": "stdlib:aiken.math.abs",
      "name": "abs",
      "signature": "pub fn abs(self: Int) -> Int {",
      "documentation": "Calculate the absolute value of an integer.\n\n```aiken\nmath.abs(-42) == 42\nmath.abs(14) == 14\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 29,
      "raw": "pub fn abs(self: Int) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn abs(self: Int) -> Int {\n  if self < 0 {\n    0 - self\n  } else {\n    self\n  }\n}",
      "tests": [
        "test abs_1() {\n  abs(14) == 14\n}",
        "test abs_2() {\n  abs(-42) == 42\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.clamp",
      "fullName": "stdlib:aiken.math.clamp",
      "name": "clamp",
      "signature": "pub fn clamp(self: Int, min: Int, max: Int) -> Int {",
      "documentation": "Restrict the value of an integer between two min and max bounds\n\n```aiken\nmath.clamp(14, min: 0, max: 10) == 10\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Int",
          "optional": false
        },
        {
          "name": "min",
          "type": "Int",
          "optional": false
        },
        {
          "name": "max",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 50,
      "raw": "pub fn clamp(self: Int, min: Int, max: Int) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn clamp(self: Int, min: Int, max: Int) -> Int {\n  if self < min {\n    min\n  } else {\n    if self > max {\n      max\n    } else {\n      self\n    }\n  }\n}",
      "tests": [
        "test clamp_1() {\n  clamp(14, min: 0, max: 10) == 10\n}",
        "test clamp_2() {\n  clamp(7, min: 0, max: 10) == 7\n}",
        "test clamp_3() {\n  clamp(7, min: 10, max: 100) == 10\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.gcd",
      "fullName": "stdlib:aiken.math.gcd",
      "name": "gcd",
      "signature": "pub fn gcd(x: Int, y: Int) -> Int {",
      "documentation": "The greatest common divisor of two integers.\n\n```aiken\nmath.gcd(42, 14) == 14\nmath.gcd(14, 42) == 14\nmath.gcd(0, 0) == 0\n```",
      "parameters": [
        {
          "name": "x",
          "type": "Int",
          "optional": false
        },
        {
          "name": "y",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 81,
      "raw": "pub fn gcd(x: Int, y: Int) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn gcd(x: Int, y: Int) -> Int {\n  abs(do_gcd(x, y))\n}"
    },
    {
      "key": "stdlib:aiken.math.is_sqrt",
      "fullName": "stdlib:aiken.math.is_sqrt",
      "name": "is_sqrt",
      "signature": "pub fn is_sqrt(self: Int, x: Int) -> Bool {",
      "documentation": "Checks if an integer has a given integer square root x.\nThe check has constant time complexity $O(1)$.\n\n```aiken\nmath.is_sqrt(0, 0)\nmath.is_sqrt(25, 5)\n!math.is_sqrt(25, -5)\nmath.is_sqrt(44203, 210)\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Int",
          "optional": false
        },
        {
          "name": "x",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 113,
      "raw": "pub fn is_sqrt(self: Int, x: Int) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn is_sqrt(self: Int, x: Int) -> Bool {\n  x * x <= self && ( x + 1 ) * ( x + 1 ) > self\n}",
      "tests": [
        "test is_sqrt1() {\n  is_sqrt(44203, 210)\n}",
        "test is_sqrt2() {\n  is_sqrt(975461057789971041, 987654321)\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.log",
      "fullName": "stdlib:aiken.math.log",
      "name": "log",
      "signature": "pub fn log(self: Int, base: Int) -> Int {",
      "documentation": "The logarithm in base `b` of an element using integer divisions.\n\n```aiken\nmath.log(10, base: 2) == 3\nmath.log(42, base: 2) == 5\nmath.log(42, base: 3) == 3\nmath.log(5, base: 0) == 0\nmath.log(4, base: 4) == 1\nmath.log(4, base: 42) == 0\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Int",
          "optional": false
        },
        {
          "name": "base",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 135,
      "raw": "pub fn log(self: Int, base: Int) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn log(self: Int, base: Int) -> Int {\n  if base <= 0 {\n    0\n  } else if self == base {\n    1\n  } else if self < base {\n    0\n  } else {\n    1 + log(self / base, base)\n  }\n}",
      "tests": [
        "test log_10_2() {\n  log(10, base: 2) == 3\n}",
        "test log_42_2() {\n  log(42, base: 2) == 5\n}",
        "test log_42_3() {\n  log(42, base: 3) == 3\n}",
        "test log_5_0() {\n  log(5, base: 0) == 0\n}",
        "test log_4_4() {\n  log(4, base: 4) == 1\n}",
        "test log_4_43() {\n  log(4, base: 43) == 0\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.log2",
      "fullName": "stdlib:aiken.math.log2",
      "name": "log2",
      "signature": "pub fn log2(x: Int) -> Int {",
      "documentation": "The integer logarithm in base 2. Faster than [`log`](#log) in this particular case.\n\n```aiken\nmath.log2(1) == 0\nmath.log2(2) == 1\nmath.log2(3) == 1\nmath.log2(4) == 2\nmath.log2(256) == 8\nmath.log2(257) == 8\nmath.log2(511) == 8\nmath.log2(1025) == 10\n```",
      "parameters": [
        {
          "name": "x",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 183,
      "raw": "pub fn log2(x: Int) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn log2(x: Int) -> Int {\n  expect x > 0\n  let s = builtin.integer_to_bytearray(True, 0, x)\n  let len = builtin.length_of_bytearray(s)\n  let b = builtin.index_bytearray(s, 0)\n  len * 8 - if b < 2 {\n    8\n  } else if b < 4 {\n    7\n  } else if b < 8 {\n    6\n  } else if b < 16 {\n    5\n  } else if b < 32 {\n    4\n  } else if b < 64 {\n    3\n  } else if b < 128 {\n    2\n  } else {\n    1\n  }\n}",
      "tests": [
        "test log2_matrix() {\n  and {\n    log2(1) == 0,\n    log2(2) == 1,\n    log2(3) == 1,\n    log2(4) == 2,\n    log2(256) == 8,\n    log2(257) == 8,\n    log2(511) == 8,\n    log2(1025) == 10,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.max",
      "fullName": "stdlib:aiken.math.max",
      "name": "max",
      "signature": "pub fn max(a: Int, b: Int) -> Int {",
      "documentation": "Return the maximum of two integers.",
      "parameters": [
        {
          "name": "a",
          "type": "Int",
          "optional": false
        },
        {
          "name": "b",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 221,
      "raw": "pub fn max(a: Int, b: Int) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn max(a: Int, b: Int) -> Int {\n  if a > b {\n    a\n  } else {\n    b\n  }\n}",
      "tests": [
        "test max_1() {\n  max(0, 0) == 0\n}",
        "test max_2() {\n  max(14, 42) == 42\n}",
        "test max_3() {\n  max(42, 14) == 42\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.min",
      "fullName": "stdlib:aiken.math.min",
      "name": "min",
      "signature": "pub fn min(a: Int, b: Int) -> Int {",
      "documentation": "Return the minimum of two integers.",
      "parameters": [
        {
          "name": "a",
          "type": "Int",
          "optional": false
        },
        {
          "name": "b",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 242,
      "raw": "pub fn min(a: Int, b: Int) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn min(a: Int, b: Int) -> Int {\n  if a > b {\n    b\n  } else {\n    a\n  }\n}",
      "tests": [
        "test min_1() {\n  min(0, 0) == 0\n}",
        "test min_2() {\n  min(14, 42) == 14\n}",
        "test min_3() {\n  min(42, 14) == 14\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.pow",
      "fullName": "stdlib:aiken.math.pow",
      "name": "pow",
      "signature": "pub fn pow(self: Int, e: Int) -> Int {",
      "documentation": "Calculates a number to the power of `e` using the exponentiation by\nsquaring method.\n\n```aiken\nmath.pow(3, 5) == 243\nmath.pow(7, 2) == 49\nmath.pow(3, -4) == 0\nmath.pow(0, 0) == 1\nmath.pow(513, 3) == 135005697\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Int",
          "optional": false
        },
        {
          "name": "e",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 272,
      "raw": "pub fn pow(self: Int, e: Int) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn pow(self: Int, e: Int) -> Int {\n  if e < 0 {\n    0\n  } else if e == 0 {\n    1\n  } else if e % 2 == 0 {\n    pow(self * self, e / 2)\n  } else {\n    self * pow(self * self, ( e - 1 ) / 2)\n  }\n}",
      "tests": [
        "test pow_3_5() {\n  pow(3, 5) == 243\n}",
        "test pow_7_2() {\n  pow(7, 2) == 49\n}",
        "test pow_3__4() {\n  // negative powers round to zero\n  pow(3, -4) == 0\n}",
        "test pow_0_0() {\n  // sorry math\n  pow(0, 0) == 1\n}",
        "test pow_513_3() {\n  pow(513, 3) == 135005697\n}",
        "test pow_2_4() {\n  pow(2, 4) == 16\n}",
        "test pow_2_42() {\n  pow(2, 42) == 4398046511104\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.pow2",
      "fullName": "stdlib:aiken.math.pow2",
      "name": "pow2",
      "signature": "pub fn pow2(e: Int) -> Int {",
      "documentation": "Calculates the power of 2 for a given exponent `e`. Much cheaper than\nusing `pow(2, _)` for small exponents $0 < e < 256$.\n\n```aiken\nmath.pow2(-2) == 0\nmath.pow2(0) == 1\nmath.pow2(1) == 2\nmath.pow2(4) == 16\nmath.pow2(42) == 4398046511104\n```",
      "parameters": [
        {
          "name": "e",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 324,
      "raw": "pub fn pow2(e: Int) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn pow2(e: Int) -> Int {\n  // do_pow2(e, 1)\n  if e < 8 {\n    if e < 0 {\n      0\n    } else {\n      builtin.index_bytearray(#[1, 2, 4, 8, 16, 32, 64, 128], e)\n    }\n  } else if e < 32 {\n    256 * pow2(e - 8)\n  } else {\n    4294967296 * pow2(e - 32)\n  }\n}",
      "tests": [
        "test pow2_neg() {\n  pow2(-2) == 0\n}",
        "test pow2_0() {\n  pow2(0) == 1\n}",
        "test pow2_1() {\n  pow2(1) == 2\n}",
        "test pow2_4() {\n  pow2(4) == 16\n}",
        "test pow2_42() {\n  pow2(42) == 4398046511104\n}",
        "test pow2_256() {\n  pow2(256) == 115792089237316195423570985008687907853269984665640564039457584007913129639936\n}"
      ]
    },
    {
      "key": "stdlib:aiken.math.sqrt",
      "fullName": "stdlib:aiken.math.sqrt",
      "name": "sqrt",
      "signature": "pub fn sqrt(self: Int) -> Option<Int> {",
      "documentation": "Calculates the square root of an integer using the [Babylonian\nmethod](https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method). This returns either the exact result or the smallest integer\nnearest to the square root.\n\nReturns `None` for negative values.\n\n```aiken\nmath.sqrt(0) == Some(0)\nmath.sqrt(25) == Some(5)\nmath.sqrt(44203) == Some(210)\nmath.sqrt(-42) == None\n```\n\n> [!TIP]\n> This function can be quite expensive to perform on-chain. Prefer using [`is_sqrt`](#is_sqrt) whenever possible.",
      "parameters": [
        {
          "name": "self",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Option<Int>",
      "line": 378,
      "raw": "pub fn sqrt(self: Int) -> Option<Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn sqrt(self: Int) -> Option<Int> {\n  if self < 0 {\n    None\n  } else if self <= 1 {\n    Some(self)\n  } else {\n    Some(sqrt_babylonian(self, self, ( self + 1 ) / 2))\n  }\n}"
    },
    {
      "key": "stdlib:aiken.option.is_none",
      "fullName": "stdlib:aiken.option.is_none",
      "name": "is_none",
      "signature": "pub fn is_none(self: Option<a>) -> Bool {",
      "documentation": "Asserts whether an option is `None`.",
      "parameters": [
        {
          "name": "self",
          "type": "Option<a>",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 8,
      "raw": "pub fn is_none(self: Option<a>) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn is_none(self: Option<a>) -> Bool {\n  when self is {\n    Some(_) -> False\n    _ -> True\n  }\n}",
      "tests": [
        "test is_none_1() {\n  is_none(Some(0)) == False\n}",
        "test is_none_2() {\n  is_none(None) == True\n}"
      ]
    },
    {
      "key": "stdlib:aiken.option.is_some",
      "fullName": "stdlib:aiken.option.is_some",
      "name": "is_some",
      "signature": "pub fn is_some(self: Option<a>) -> Bool {",
      "documentation": "Asserts whether an option is `Some`, irrespective of the value it contains.",
      "parameters": [
        {
          "name": "self",
          "type": "Option<a>",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 24,
      "raw": "pub fn is_some(self: Option<a>) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn is_some(self: Option<a>) -> Bool {\n  when self is {\n    Some(_) -> True\n    _ -> False\n  }\n}",
      "tests": [
        "test is_some_1() {\n  is_some(Some(0)) == True\n}",
        "test is_some_2() {\n  is_some(None) == False\n}"
      ]
    },
    {
      "key": "stdlib:aiken.option.and_then",
      "fullName": "stdlib:aiken.option.and_then",
      "name": "and_then",
      "signature": "pub fn and_then(pub fn and_then(self: Option<a>, then: fn(a) -> Option<result>,",
      "documentation": "Chain together many computations that may fail.\n\n```aiken\nself\n|> dict.get(policy_id)\n|> option.and_then(dict.get(_, asset_name))\n|> option.or_else(0)\n```",
      "parameters": [],
      "returnType": "Option<result>,",
      "line": 49,
      "raw": "pub fn and_then(pub fn and_then(self: Option<a>, then: fn(a) -> Option<result>,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn and_then(\n  self: Option<a>,\n  then: fn(a) -> Option<result>,\n) -> Option<result> {\n  when self is {\n    None -> None\n    Some(a) -> then(a)\n  }\n}"
    },
    {
      "key": "stdlib:aiken.option.choice",
      "fullName": "stdlib:aiken.option.choice",
      "name": "choice",
      "signature": "pub fn choice(self: List<Option<a>>) -> Option<a> {",
      "documentation": "Picks the first element which is not None. If there's no such element, return None.\n\n```aiken\noption.choice([]) == None\noption.choice([Some(14), Some(42)]) == Some(14)\noption.choice([None, Some(42)]) == Some(42)\noption.choice([None, None]) == None\n```",
      "parameters": [
        {
          "name": "self",
          "type": "List<Option<a>>",
          "optional": false
        }
      ],
      "returnType": "Option<a>",
      "line": 96,
      "raw": "pub fn choice(self: List<Option<a>>) -> Option<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn choice(self: List<Option<a>>) -> Option<a> {\n  when self is {\n    [] -> None\n    [head, ..others] ->\n      when head is {\n        None -> choice(others)\n        _ -> head\n      }\n  }\n}",
      "tests": [
        "test choice_1() {\n  Some(1) == choice([Some(1), Some(2)])\n}",
        "test choice_2() {\n  None == choice([])\n}",
        "test choice_3() {\n  Some(1) == choice([None, Some(1)])\n}"
      ]
    },
    {
      "key": "stdlib:aiken.option.flatten",
      "fullName": "stdlib:aiken.option.flatten",
      "name": "flatten",
      "signature": "pub fn flatten(opt: Option<Option<a>>) -> Option<a> {",
      "documentation": "Converts from `Option<Option<a>>` to `Option<a>`.\n\n```aiken\noption.flatten(Some(Some(42))) == Some(42)\noption.flatten(Some(None)) == None\noption.flatten(None) == None\n```\n\nFlattening only removes one level of nesting at a time:\n\n```aiken\nflatten(Some(Some(Some(42)))) == Some(Some(42))\nSome(Some(Some(42))) |> flatten |> flatten == Some(42)\n```",
      "parameters": [
        {
          "name": "opt",
          "type": "Option<Option<a>>",
          "optional": false
        }
      ],
      "returnType": "Option<a>",
      "line": 133,
      "raw": "pub fn flatten(opt: Option<Option<a>>) -> Option<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn flatten(opt: Option<Option<a>>) -> Option<a> {\n  when opt is {\n    Some(inner) -> inner\n    None -> None\n  }\n}",
      "tests": [
        "test flatten_1() {\n  let x: Option<Option<Int>> = Some(Some(6))\n  Some(6) == flatten(x)\n}",
        "test flatten_2() {\n  let x: Option<Option<Int>> = Some(None)\n  None == flatten(x)\n}",
        "test flatten_3() {\n  let x: Option<Option<Int>> = None\n  None == flatten(x)\n}",
        "test flatten_4() {\n  let x: Option<Option<Option<Int>>> = Some(Some(Some(6)))\n\n  let result =\n    x\n      |> flatten\n      |> flatten\n\n  Some(6) == result\n}"
      ]
    },
    {
      "key": "stdlib:aiken.option.map",
      "fullName": "stdlib:aiken.option.map",
      "name": "map",
      "signature": "pub fn map(self: Option<a>, with: fn(a) -> result) -> Option<result> {",
      "documentation": "Apply a function to the inner value of an [`Option`](#option)\n\n```aiken\noption.map(None, fn(n) { n * 2 }) == None\noption.map(Some(14), fn(n) { n * 2 }) == Some(28)\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Option<a>",
          "optional": false
        },
        {
          "name": "with",
          "type": "fn(a",
          "optional": false
        }
      ],
      "returnType": "result) -> Option<result>",
      "line": 172,
      "raw": "pub fn map(self: Option<a>, with: fn(a) -> result) -> Option<result> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn map(self: Option<a>, with: fn(a) -> result) -> Option<result> {\n  when self is {\n    None -> None\n    Some(a) -> Some(with(a))\n  }\n}",
      "tests": [
        "test map_1() {\n  map(None, fn(_) { Void }) == None\n}",
        "test map_2() {\n  map(Some(14), fn(n) { n + 1 }) == Some(15)\n}"
      ]
    },
    {
      "key": "stdlib:aiken.option.map2",
      "fullName": "stdlib:aiken.option.map2",
      "name": "map2",
      "signature": "pub fn map2(pub fn map2(opt_a: Option<a>, opt_b: Option<b>, with: fn(a, b) -> result,",
      "documentation": "Combine two [`Option`](#option) together.\n\n```aiken\ntype Foo {\nFoo(Int, Int)\n}\n\noption.map2(Some(14), Some(42), Foo) == Some(Foo(14, 42))\noption.map2(None, Some(42), Foo) == None\noption.map2(Some(14), None, Foo) == None\n```",
      "parameters": [],
      "returnType": "result,",
      "line": 198,
      "raw": "pub fn map2(pub fn map2(opt_a: Option<a>, opt_b: Option<b>, with: fn(a, b) -> result,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn map2(\n  opt_a: Option<a>,\n  opt_b: Option<b>,\n  with: fn(a, b) -> result,\n) -> Option<result> {\n  when opt_a is {\n    None -> None\n    Some(a) ->\n      when opt_b is {\n        None -> None\n        Some(b) -> Some(with(a, b))\n      }\n  }\n}",
      "tests": [
        "test map2_1() {\n  map2(None, Some(42), fn(_, _) { 14 }) == None\n}",
        "test map2_2() {\n  map2(Some(42), None, fn(_, _) { 14 }) == None\n}",
        "test map2_3() {\n  map2(Some(14), Some(42), fn(a, b) { (a, b) }) == Some((14, 42))\n}"
      ]
    },
    {
      "key": "stdlib:aiken.option.map3",
      "fullName": "stdlib:aiken.option.map3",
      "name": "map3",
      "signature": "pub fn map3(pub fn map3(opt_a: Option<a>, opt_b: Option<b>, opt_c: Option<c>, with: fn(a, b, c) -> result,",
      "documentation": "Combine three [`Option`](#option) together.\n\n```aiken\ntype Foo {\nFoo(Int, Int, Int)\n}\n\noption.map3(Some(14), Some(42), Some(1337), Foo) == Some(Foo(14, 42, 1337))\noption.map3(None, Some(42), Some(1337), Foo) == None\noption.map3(Some(14), None, None, Foo) == None\n```",
      "parameters": [],
      "returnType": "result,",
      "line": 236,
      "raw": "pub fn map3(pub fn map3(opt_a: Option<a>, opt_b: Option<b>, opt_c: Option<c>, with: fn(a, b, c) -> result,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn map3(\n  opt_a: Option<a>,\n  opt_b: Option<b>,\n  opt_c: Option<c>,\n  with: fn(a, b, c) -> result,\n) -> Option<result> {\n  when opt_a is {\n    None -> None\n    Some(a) ->\n      when opt_b is {\n        None -> None\n        Some(b) ->\n          when opt_c is {\n            None -> None\n            Some(c) -> Some(with(a, b, c))\n          }\n      }\n  }\n}",
      "tests": [
        "test map3_1() {\n  map3(None, Some(42), None, fn(_, _, _) { 14 }) == None\n}",
        "test map3_2() {\n  map3(Some(42), None, None, fn(_, _, _) { 14 }) == None\n}",
        "test map3_3() {\n  map3(Some(14), Some(42), Some(1337), fn(a, b, c) { c - a + b }) == Some(1365)\n}"
      ]
    },
    {
      "key": "stdlib:aiken.option.or_try",
      "fullName": "stdlib:aiken.option.or_try",
      "name": "or_try",
      "signature": "pub fn or_try(self: Option<a>, compute_default: fn() -> Option<a>) -> Option<a> {",
      "documentation": "Like [`or_else`](#or_else) but allows returning an `Option`.\nThis is effectively mapping the error branch.\n\n```aiken\noption.or_try(None, fn(_) { Some(\"aiken\") }) == Some(\"aiken\")\noption.or_try(Some(42), fn(_) { Some(14) }) == Some(42)\noption.or_try(None, fn (_) { fail }) => 💥\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Option<a>",
          "optional": false
        },
        {
          "name": "compute_default",
          "type": "fn(",
          "optional": false
        }
      ],
      "returnType": "Option<a>) -> Option<a>",
      "line": 276,
      "raw": "pub fn or_try(self: Option<a>, compute_default: fn() -> Option<a>) -> Option<a> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn or_try(self: Option<a>, compute_default: fn() -> Option<a>) -> Option<a> {\n  when self is {\n    None -> compute_default()\n    _ -> self\n  }\n}",
      "tests": [
        "test or_try_1() {\n  or_try(None, fn() { Some(\"aiken\") }) == Some(\"aiken\")\n}",
        "test or_try_2() {\n  or_try(Some(42), fn() { fail }) == Some(42)\n}"
      ]
    },
    {
      "key": "stdlib:aiken.option.or_else",
      "fullName": "stdlib:aiken.option.or_else",
      "name": "or_else",
      "signature": "pub fn or_else(self: Option<a>, default: a) -> a {",
      "documentation": "Provide a default value, turning an optional value into a normal value.\n\n```aiken\noption.or_else(None, \"aiken\") == \"aiken\"\noption.or_else(Some(42), 14) == 42\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Option<a>",
          "optional": false
        },
        {
          "name": "default",
          "type": "a",
          "optional": false
        }
      ],
      "returnType": "a",
      "line": 299,
      "raw": "pub fn or_else(self: Option<a>, default: a) -> a {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn or_else(self: Option<a>, default: a) -> a {\n  when self is {\n    None -> default\n    Some(a) -> a\n  }\n}",
      "tests": [
        "test or_else_1() {\n  or_else(None, \"aiken\") == \"aiken\"\n}",
        "test or_else_2() {\n  or_else(Some(42), 14) == 42\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.from_int_big_endian",
      "fullName": "stdlib:aiken.primitive.bytearray.from_int_big_endian",
      "name": "from_int_big_endian",
      "signature": "pub fn from_int_big_endian(self: Int, size: Int) -> ByteArray {",
      "documentation": "Encode an integer value as a Big-Endian (most-significant bytes first) `ByteArray`.\nThe size is the expected size in number of bytes.\n\n> [!IMPORTANT]\n> This function fails (i.e. halts the program) if the value cannot fit in the given size. When the\n> size is _too large_, the array is left-padded with zeroes.\n\n```aiken\nbytearray.from_int_big_endian(1_000_000, 3) == #\"0f4240\"\nbytearray.from_int_big_endian(1_000_000, 5) == #\"00000f4240\"\nbytearray.from_int_big_endian(0, 8) == #\"0000000000000000\"\nbytearray.from_int_big_endian(1_000_000, 1) => 💥\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Int",
          "optional": false
        },
        {
          "name": "size",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 23,
      "raw": "pub fn from_int_big_endian(self: Int, size: Int) -> ByteArray {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_int_big_endian(self: Int, size: Int) -> ByteArray {\n  builtin.integer_to_bytearray(True, size, self)\n}",
      "tests": [
        "test from_int_big_endian_1() {\n  from_int_big_endian(1_000_000, 3) == #\"0f4240\"\n}",
        "test from_int_big_endian_2() {\n  from_int_big_endian(1_000_000, 5) == #\"00000f4240\"\n}",
        "test from_int_big_endian_3() {\n  from_int_big_endian(0, 8) == #\"0000000000000000\"\n}",
        "test from_int_big_endian_4() fail {\n  from_int_big_endian(1_000_000, 1) == #\"40\"\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.from_int_little_endian",
      "fullName": "stdlib:aiken.primitive.bytearray.from_int_little_endian",
      "name": "from_int_little_endian",
      "signature": "pub fn from_int_little_endian(self: Int, size: Int) -> ByteArray {",
      "documentation": "Encode an integer value as a Little-Endian (least-significant bytes first) `ByteArray`.\nThe size is the expected size in number of bytes.\n\n> [!IMPORTANT]\n> This function fails (i.e. halts the program) if the value cannot fit in the given size. When the\n> size is _too large_, the array is right-padded with zeroes.\n\n```aiken\nbytearray.from_int_little_endian(1_000_000, 3) == #\"40420f\"\nbytearray.from_int_little_endian(1_000_000, 5) == #\"40420f0000\"\nbytearray.from_int_little_endian(0, 8) == #\"0000000000000000\"\nbytearray.from_int_little_endian(1_000_000, 1) => 💥\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Int",
          "optional": false
        },
        {
          "name": "size",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 56,
      "raw": "pub fn from_int_little_endian(self: Int, size: Int) -> ByteArray {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_int_little_endian(self: Int, size: Int) -> ByteArray {\n  builtin.integer_to_bytearray(False, size, self)\n}",
      "tests": [
        "test from_int_little_endian_1() {\n  from_int_little_endian(1_000_000, 3) == #\"40420f\"\n}",
        "test from_int_little_endian_2() {\n  from_int_little_endian(1_000_000, 5) == #\"40420f0000\"\n}",
        "test from_int_little_endian_3() {\n  from_int_little_endian(0, 8) == #\"0000000000000000\"\n}",
        "test from_int_little_endian_4() fail {\n  from_int_little_endian(1_000_000, 1) == #\"40\"\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.from_string",
      "fullName": "stdlib:aiken.primitive.bytearray.from_string",
      "name": "from_string",
      "signature": "pub fn from_string(str: String) -> ByteArray {",
      "documentation": "Convert a `String` into a `ByteArray`.\n\n```aiken\nbytearray.from_string(@\"ABC\") == #\"414243\"\n```",
      "parameters": [
        {
          "name": "str",
          "type": "String",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 81,
      "raw": "pub fn from_string(str: String) -> ByteArray {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_string(str: String) -> ByteArray {\n  builtin.encode_utf8(str)\n}",
      "tests": [
        "test from_string_1() {\n  from_string(@\"\") == \"\"\n}",
        "test from_string_2() {\n  from_string(@\"ABC\") == #\"414243\"\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.push",
      "fullName": "stdlib:aiken.primitive.bytearray.push",
      "name": "push",
      "signature": "pub fn push(self: ByteArray, byte: Byte) -> ByteArray {",
      "documentation": "Add a byte element in front of a `ByteArray`. When the given byte is\ngreater than 255, it wraps-around. **PlutusV2 behavior** So 256 is mapped to 0, 257 to 1, and so\nforth.\nIn PlutusV3 this will error instead of wrapping around.\n\n```aiken\nbytearray.push(#\"\", 0) == #\"00\"\nbytearray.push(#\"0203\", 1) == #\"010203\"\nbytearray.push(#\"0203\", 257) == #\"010203\"\n```",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "byte",
          "type": "Byte",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 103,
      "raw": "pub fn push(self: ByteArray, byte: Byte) -> ByteArray {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn push(self: ByteArray, byte: Byte) -> ByteArray {\n  builtin.cons_bytearray(byte, self)\n}",
      "tests": [
        "test push_1() {\n  push(#[], 0) == #[0]\n}",
        "test push_2() {\n  push(#[2, 3], 1) == #[1, 2, 3]\n}",
        "test push_3() fail {\n  let x = 257\n  push(#[2, 3], x) == #[1, 2, 3]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.at",
      "fullName": "stdlib:aiken.primitive.bytearray.at",
      "name": "at",
      "signature": "pub fn at(self: ByteArray, index: Int) -> Byte {",
      "documentation": "Get the `Byte` at the given index, or crash.\n\n> [!WARNING]\n> This functions fails (i.e. halts the program) if there's no byte at the given index.",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "index",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Byte",
      "line": 126,
      "raw": "pub fn at(self: ByteArray, index: Int) -> Byte {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn at(self: ByteArray, index: Int) -> Byte {\n  builtin.index_bytearray(self, index)\n}"
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.index_of",
      "fullName": "stdlib:aiken.primitive.bytearray.index_of",
      "name": "index_of",
      "signature": "pub fn index_of(self: ByteArray, bytes: ByteArray) -> Option<(Int, Int)> {",
      "documentation": "Search the start and end positions of a sub-array in a `ByteArray`.\n\n```aiken\nbytearray.index_of(\"Hello, World!\", \"World\") == Some((7, 11))\nbytearray.index_of(\"Hello, World!\", \"foo\") == None\nbytearray.index_of(\"Hello, World!\", \"!\") == Some((12, 12))\nbytearray.index_of(\"Hello, World!\", \"o\") == Some((4, 4))\nbytearray.index_of(\"Hello, World!\", \"Hello, World!\") == Some((0, 12))\n```",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Option<(Int, Int)>",
      "line": 139,
      "raw": "pub fn index_of(self: ByteArray, bytes: ByteArray) -> Option<(Int, Int)> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn index_of(self: ByteArray, bytes: ByteArray) -> Option<(Int, Int)> {\n  let offset = length(bytes)\n\n  do_index_of(self, bytes, 0, offset, length(self))\n    |> option.map(fn(ix) { (ix, ix + offset - 1) })\n}"
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.is_empty",
      "fullName": "stdlib:aiken.primitive.bytearray.is_empty",
      "name": "is_empty",
      "signature": "pub fn is_empty(self: ByteArray) -> Bool {",
      "documentation": "Returns `True` when the given `ByteArray` is empty.\n\n```aiken\nbytearray.is_empty(#\"\") == True\nbytearray.is_empty(#\"00ff\") == False\n```",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 190,
      "raw": "pub fn is_empty(self: ByteArray) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn is_empty(self: ByteArray) -> Bool {\n  builtin.length_of_bytearray(self) == 0\n}",
      "tests": [
        "test is_empty_1() {\n  is_empty(#\"\") == True\n}",
        "test is_empty_2() {\n  is_empty(#\"01\") == False\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.length",
      "fullName": "stdlib:aiken.primitive.bytearray.length",
      "name": "length",
      "signature": "pub fn length(self: ByteArray) -> Int {",
      "documentation": "Returns the number of bytes in a `ByteArray`.\n\n```aiken\nbytearray.length(#[1, 2, 3]) == 3\n```",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 207,
      "raw": "pub fn length(self: ByteArray) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn length(self: ByteArray) -> Int {\n  builtin.length_of_bytearray(self)\n}",
      "tests": [
        "test length_1() {\n  length(#\"\") == 0\n}",
        "test length_2() {\n  length(#\"010203\") == 3\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.test_bit",
      "fullName": "stdlib:aiken.primitive.bytearray.test_bit",
      "name": "test_bit",
      "signature": "pub fn test_bit(self: ByteArray, ix: Int) -> Bool {",
      "documentation": "Checks whether a bit (Most-Significant-Bit first) is set in the given 'ByteArray'.\n\nFor example, consider the following bytearray: `#\"8b765f\"`. It can also be written as the\nfollowing bits sequence:\n\n`8`    | `b`    | `7`    | `6`    | `5`    | `f`\n---    | ---    | ---    | ---    | ---    | ---\n`1000` | `1011` | `0111` | `0110` | `0101` | `1111`\n\nAnd thus, we have:\n\n```aiken\ntest_bit(#\"8b765f\", 0) == True\ntest_bit(#\"8b765f\", 1) == False\ntest_bit(#\"8b765f\", 2) == False\ntest_bit(#\"8b765f\", 3) == False\ntest_bit(#\"8b765f\", 7) == True\ntest_bit(#\"8b765f\", 8) == False\ntest_bit(#\"8b765f\", 20) == True\ntest_bit(#\"8b765f\", 21) == True\ntest_bit(#\"8b765f\", 22) == True\ntest_bit(#\"8b765f\", 23) == True\n```",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "ix",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 242,
      "raw": "pub fn test_bit(self: ByteArray, ix: Int) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn test_bit(self: ByteArray, ix: Int) -> Bool {\n  builtin.less_than_equals_bytearray(\n    #[128],\n    builtin.cons_bytearray(\n      builtin.index_bytearray(self, ix / 8) * math.pow2(ix % 8) % 256,\n      \"\",\n    ),\n  )\n}",
      "tests": [
        "test test_bit_0() {\n  test_bit(#\"8b765f\", 0)\n}",
        "test test_bit_1() {\n  !test_bit(#\"8b765f\", 1)\n}",
        "test test_bit_2() {\n  !test_bit(#\"8b765f\", 2)\n}",
        "test test_bit_3() {\n  !test_bit(#\"8b765f\", 3)\n}",
        "test test_bit_7() {\n  test_bit(#\"8b765f\", 7)\n}",
        "test test_bit_8() {\n  !test_bit(#\"8b765f\", 8)\n}",
        "test test_bit_20_21_22_23() {\n  and {\n    test_bit(#\"8b765f\", 20),\n    test_bit(#\"8b765f\", 21),\n    test_bit(#\"8b765f\", 22),\n    test_bit(#\"8b765f\", 23),\n  }\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.drop",
      "fullName": "stdlib:aiken.primitive.bytearray.drop",
      "name": "drop",
      "signature": "pub fn drop(self: ByteArray, n: Int) -> ByteArray {",
      "documentation": "Returns the suffix of a `ByteArray` after `n` elements.\n\n```aiken\nbytearray.drop(#[1, 2, 3], n: 2) == #[3]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "n",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 292,
      "raw": "pub fn drop(self: ByteArray, n: Int) -> ByteArray {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn drop(self: ByteArray, n: Int) -> ByteArray {\n  builtin.slice_bytearray(n, builtin.length_of_bytearray(self) - n, self)\n}",
      "tests": [
        "test drop_1() {\n  let x = #\"01020304050607\"\n  drop(x, 2) == #\"0304050607\"\n}",
        "test drop_2() {\n  let x = #\"01020304050607\"\n  drop(x, 0) == x\n}",
        "test drop_3() {\n  let x = #\"01\"\n  drop(x, 1) == #\"\"\n}",
        "test drop_4() {\n  let x = #\"\"\n  drop(x, 2) == #\"\"\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.slice",
      "fullName": "stdlib:aiken.primitive.bytearray.slice",
      "name": "slice",
      "signature": "pub fn slice(self: ByteArray, start: Int, end: Int) -> ByteArray {",
      "documentation": "Extract a `ByteArray` as a slice of another `ByteArray`.\n\nIndexes are 0-based and inclusive.\n\n```aiken\nbytearray.slice(#[0, 1, 2, 3, 4, 5, 6], start: 1, end: 3) == #[1, 2, 3]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "start",
          "type": "Int",
          "optional": false
        },
        {
          "name": "end",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 323,
      "raw": "pub fn slice(self: ByteArray, start: Int, end: Int) -> ByteArray {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn slice(self: ByteArray, start: Int, end: Int) -> ByteArray {\n  builtin.slice_bytearray(start, end - start + 1, self)\n}",
      "tests": [
        "test slice_1() {\n  slice(#\"\", 1, 2) == #\"\"\n}",
        "test slice_2() {\n  slice(#\"010203\", 1, 2) == #\"0203\"\n}",
        "test slice_3() {\n  slice(#\"010203\", 0, 42) == #\"010203\"\n}",
        "test slice_4() {\n  slice(#[0, 1, 2, 3, 4], 0, 3) == #[0, 1, 2, 3]\n}",
        "test slice_5() {\n  slice(#[0, 1, 2, 3, 4], 1, 2) == #[1, 2]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.take",
      "fullName": "stdlib:aiken.primitive.bytearray.take",
      "name": "take",
      "signature": "pub fn take(self: ByteArray, n: Int) -> ByteArray {",
      "documentation": "Returns the n-length prefix of a `ByteArray`.\n\n```aiken\nbytearray.take(#[1, 2, 3], n: 2) == #[1, 2]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "n",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 352,
      "raw": "pub fn take(self: ByteArray, n: Int) -> ByteArray {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn take(self: ByteArray, n: Int) -> ByteArray {\n  builtin.slice_bytearray(0, n, self)\n}",
      "tests": [
        "test take_1() {\n  let x = #\"01020304050607\"\n  take(x, 2) == #\"0102\"\n}",
        "test take_2() {\n  let x = #\"01020304050607\"\n  take(x, 0) == #\"\"\n}",
        "test take_3() {\n  let x = #\"01\"\n  take(x, 1) == x\n}",
        "test take_4() {\n  let x = #\"010203\"\n  take(x, 0) == #\"\"\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.concat",
      "fullName": "stdlib:aiken.primitive.bytearray.concat",
      "name": "concat",
      "signature": "pub fn concat(left: ByteArray, right: ByteArray) -> ByteArray {",
      "documentation": "Combine two `ByteArray` together.\n\n```aiken\nbytearray.concat(left: #[1, 2, 3], right: #[4, 5, 6]) == #[1, 2, 3, 4, 5, 6]\n```",
      "parameters": [
        {
          "name": "left",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "right",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 383,
      "raw": "pub fn concat(left: ByteArray, right: ByteArray) -> ByteArray {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn concat(left: ByteArray, right: ByteArray) -> ByteArray {\n  builtin.append_bytearray(left, right)\n}",
      "tests": [
        "test concat_1() {\n  concat(#\"\", #\"\") == #\"\"\n}",
        "test concat_2() {\n  concat(#\"\", #\"01\") == #\"01\"\n}",
        "test concat_3() {\n  concat(#\"0102\", #\"\") == #\"0102\"\n}",
        "test concat_4() {\n  concat(#\"0102\", #\"0304\") == #\"01020304\"\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.compare",
      "fullName": "stdlib:aiken.primitive.bytearray.compare",
      "name": "compare",
      "signature": "pub fn compare(left: ByteArray, right: ByteArray) -> Ordering {",
      "documentation": "Compare two bytearrays lexicographically.\n\n```aiken\nbytearray.compare(#\"00\", #\"FF\") == Less\nbytearray.compare(#\"42\", #\"42\") == Equal\nbytearray.compare(#\"FF\", #\"00\") == Greater\n```",
      "parameters": [
        {
          "name": "left",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "right",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Ordering",
      "line": 410,
      "raw": "pub fn compare(left: ByteArray, right: ByteArray) -> Ordering {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn compare(left: ByteArray, right: ByteArray) -> Ordering {\n  if builtin.less_than_bytearray(left, right) {\n    Less\n  } else if builtin.equals_bytearray(left, right) {\n    Equal\n  } else {\n    Greater\n  }\n}"
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.foldl",
      "fullName": "stdlib:aiken.primitive.bytearray.foldl",
      "name": "foldl",
      "signature": "pub fn foldl(pub fn foldl(self: ByteArray, zero: result, with: fn(Int, result) -> result,",
      "documentation": "Left-fold over bytes of a [`ByteArray`](https://aiken-lang.github.io/prelude/aiken.html#ByteArray). Note that every byte given to the callback function is comprised between 0 and 255.\n\n```aiken\nbytearray.foldl(#\"acab\", 0, fn(byte, acc) { acc * 256 + byte }) == 44203\nbytearray.foldl(#[1, 2, 3], #\"\", flip(bytearray.push)) == #[3, 2, 1]\n```",
      "parameters": [],
      "returnType": "result,",
      "line": 428,
      "raw": "pub fn foldl(pub fn foldl(self: ByteArray, zero: result, with: fn(Int, result) -> result,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn foldl(\n  self: ByteArray,\n  zero: result,\n  with: fn(Int, result) -> result,\n) -> result {\n  do_foldl(self, zero, builtin.length_of_bytearray(self), 0, with)\n}"
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.foldr",
      "fullName": "stdlib:aiken.primitive.bytearray.foldr",
      "name": "foldr",
      "signature": "pub fn foldr(pub fn foldr(self: ByteArray, zero: result, with: fn(Int, result) -> result,",
      "documentation": "Right-fold over bytes of a [`ByteArray`](https://aiken-lang.github.io/prelude/aiken.html#ByteArray). Note that every byte given to the callback function is comprised between 0 and 255.\n\n```aiken\nbytearray.foldr(#\"acab\", 0, fn(byte, acc) { acc * 256 + byte }) == 43948\nbytearray.foldl(#[1, 2, 3], #\"\", flip(bytearray.push)) == #[1, 2, 3]\n```",
      "parameters": [],
      "returnType": "result,",
      "line": 482,
      "raw": "pub fn foldr(pub fn foldr(self: ByteArray, zero: result, with: fn(Int, result) -> result,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn foldr(\n  self: ByteArray,\n  zero: result,\n  with: fn(Int, result) -> result,\n) -> result {\n  do_foldr(self, zero, builtin.length_of_bytearray(self) - 1, with)\n}"
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.reduce",
      "fullName": "stdlib:aiken.primitive.bytearray.reduce",
      "name": "reduce",
      "signature": "pub fn reduce(pub fn reduce(self: ByteArray, zero: result, with: fn(result, Int) -> result,",
      "documentation": "Reduce bytes in a ByteArray from left to right using the accumulator as left operand.\nSaid differently, this is [`foldl`](#foldl) with callback arguments swapped.\n\n```aiken\nbytearray.reduce(#[1,2,3], #[], bytearray.push) == #[3, 2, 1]\n```",
      "parameters": [],
      "returnType": "result,",
      "line": 526,
      "raw": "pub fn reduce(pub fn reduce(self: ByteArray, zero: result, with: fn(result, Int) -> result,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn reduce(\n  self: ByteArray,\n  zero: result,\n  with: fn(result, Int) -> result,\n) -> result {\n  foldl(self, zero, flip(with))\n}",
      "tests": [
        "test reduce_1() {\n  reduce(#[], #[], push) == #[]\n}",
        "test reduce_2() {\n  reduce(#[1, 2, 3], #[], push) == #[3, 2, 1]\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.to_int_big_endian",
      "fullName": "stdlib:aiken.primitive.bytearray.to_int_big_endian",
      "name": "to_int_big_endian",
      "signature": "pub fn to_int_big_endian(self: ByteArray) -> Int {",
      "documentation": "Interpret a Big-Endian (most-significant bytes first) `ByteArray` as an `Int`.\n\n```aiken\nbytearray.to_int_big_endian(#\"0f4240\") == 1_000_000\nbytearray.to_int_big_endian(#\"00000f4240\") == 1_000_000\nbytearray.to_int_big_endian(#\"0000000000000000\") == 0\n```",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 549,
      "raw": "pub fn to_int_big_endian(self: ByteArray) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn to_int_big_endian(self: ByteArray) -> Int {\n  builtin.bytearray_to_integer(True, self)\n}",
      "tests": [
        "test to_int_big_endian_1() {\n  to_int_big_endian(#\"0f4240\") == 1_000_000\n}",
        "test to_int_big_endian_2() {\n  to_int_big_endian(#\"00000f4240\") == 1_000_000\n}",
        "test to_int_big_endian_3() {\n  to_int_big_endian(#\"0000000000000000\") == 0\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.to_int_little_endian",
      "fullName": "stdlib:aiken.primitive.bytearray.to_int_little_endian",
      "name": "to_int_little_endian",
      "signature": "pub fn to_int_little_endian(self: ByteArray) -> Int {",
      "documentation": "Interpret a Little-Endian (least-significant bytes first) `ByteArray` as an `Int`.\n\n```aiken\nbytearray.to_int_big_endian(#\"40420f\") == 1_000_000\nbytearray.to_int_big_endian(#\"40420f0000\") == 1_000_000\nbytearray.to_int_big_endian(#\"0000000000000000\") == 0\n```",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 572,
      "raw": "pub fn to_int_little_endian(self: ByteArray) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn to_int_little_endian(self: ByteArray) -> Int {\n  builtin.bytearray_to_integer(False, self)\n}",
      "tests": [
        "test to_int_little_endian_1() {\n  to_int_little_endian(#\"40420f\") == 1_000_000\n}",
        "test to_int_little_endian_2() {\n  to_int_little_endian(#\"40420f0000\") == 1_000_000\n}",
        "test to_int_little_endian_3() {\n  to_int_little_endian(#\"0000000000000000\") == 0\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.to_string",
      "fullName": "stdlib:aiken.primitive.bytearray.to_string",
      "name": "to_string",
      "signature": "pub fn to_string(self: ByteArray) -> String {",
      "documentation": "Convert a `ByteArray` into a `String`.\n\n> [!WARNING]\n> This functions fails (i.e. halts the program) if the underlying `ByteArray` isn't UTF-8-encoded. In particular, you cannot convert arbitrary hash digests using this function.\n>\n> For converting arbitrary `ByteArray`s, use [bytearray.to_hex](#to_hex).\n\n```aiken\nbytearray.to_string(#\"414243\") == \"ABC\"\nbytearray.to_string(some_hash) => 💥\n```",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "String",
      "line": 599,
      "raw": "pub fn to_string(self: ByteArray) -> String {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn to_string(self: ByteArray) -> String {\n  builtin.decode_utf8(self)\n}",
      "tests": [
        "test to_string_1() {\n  to_string(\"\") == @\"\"\n}",
        "test to_string_2() {\n  to_string(\"ABC\") == @\"ABC\"\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.to_hex",
      "fullName": "stdlib:aiken.primitive.bytearray.to_hex",
      "name": "to_hex",
      "signature": "pub fn to_hex(self: ByteArray) -> String {",
      "documentation": "Encode a `ByteArray` as a hexidecimal `String`.\n\n```aiken\nbytearray.to_hex(\"Hello world!\") == @\"48656c6c6f20776f726c6421\"\n```",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "String",
      "line": 616,
      "raw": "pub fn to_hex(self: ByteArray) -> String {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn to_hex(self: ByteArray) -> String {\n  self\n    |> encode_base16(builtin.length_of_bytearray(self) - 1, \"\")\n    |> builtin.decode_utf8\n}",
      "tests": [
        "test to_hex_1() {\n  to_hex(\"Hello world!\") == @\"48656C6C6F20776F726C6421\"\n}",
        "test to_hex_2() {\n  to_hex(\"The quick brown fox jumps over the lazy dog\") == @\"54686520717569636B2062726F776E20666F78206A756D7073206F76657220746865206C617A7920646F67\"\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.starts_with",
      "fullName": "stdlib:aiken.primitive.bytearray.starts_with",
      "name": "starts_with",
      "signature": "pub fn starts_with(self: ByteArray, prefix: ByteArray) -> Bool {",
      "documentation": "Checks whether a `ByteArray` starts with a given prefix.\n\n```aiken\nbytearray.starts_with(\"Hello, World!\", prefix: \"Hello\") == True\nbytearray.starts_with(\"\", prefix: \"\") == True\nbytearray.starts_with(\"Hello\", prefix: \"Hello, World!\") == False\n```",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "prefix",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 637,
      "raw": "pub fn starts_with(self: ByteArray, prefix: ByteArray) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn starts_with(self: ByteArray, prefix: ByteArray) -> Bool {\n  let prefix_length = length(prefix)\n  if length(self) < prefix_length {\n    False\n  } else {\n    take(self, prefix_length) == prefix\n  }\n}",
      "tests": [
        "test starts_with_1() {\n  starts_with(\"\", \"\")\n}",
        "test starts_with_2() {\n  starts_with(\"Hello, World!\", \"Hello, World!\")\n}",
        "test starts_with_3() {\n  !starts_with(\"Hello, World!\", \"hello\")\n}",
        "test starts_with_4() {\n  !starts_with(\"\", \"World\")\n}",
        "test starts_with_5() {\n  starts_with(\"Hello, World\", \"Hello\")\n}",
        "test starts_with_6() {\n  !starts_with(\"foo\", \"foo_\")\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.and_bytes",
      "fullName": "stdlib:aiken.primitive.bytearray.and_bytes",
      "name": "and_bytes",
      "signature": "pub fn and_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {",
      "parameters": [
        {
          "name": "left",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "right",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "pad_end",
          "type": "Bool",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 670,
      "raw": "pub fn and_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn and_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {\n  builtin.and_bytearray(pad_end, left, right)\n}"
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.or_bytes",
      "fullName": "stdlib:aiken.primitive.bytearray.or_bytes",
      "name": "or_bytes",
      "signature": "pub fn or_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {",
      "parameters": [
        {
          "name": "left",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "right",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "pad_end",
          "type": "Bool",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 674,
      "raw": "pub fn or_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn or_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {\n  builtin.or_bytearray(pad_end, left, right)\n}"
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.xor_bytes",
      "fullName": "stdlib:aiken.primitive.bytearray.xor_bytes",
      "name": "xor_bytes",
      "signature": "pub fn xor_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {",
      "parameters": [
        {
          "name": "left",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "right",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "pad_end",
          "type": "Bool",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 678,
      "raw": "pub fn xor_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn xor_bytes(left: ByteArray, right: ByteArray, pad_end: Bool) -> ByteArray {\n  builtin.xor_bytearray(pad_end, left, right)\n}"
    },
    {
      "key": "stdlib:aiken.primitive.int.compare",
      "fullName": "stdlib:aiken.primitive.int.compare",
      "name": "compare",
      "signature": "pub fn compare(left: Int, right: Int) -> Ordering {",
      "documentation": "Compare two integers.\n\n```aiken\nint.compare(14, 42) == Less\nint.compare(14, 14) == Equal\nint.compare(42, 14) == Greater\n```",
      "parameters": [
        {
          "name": "left",
          "type": "Int",
          "optional": false
        },
        {
          "name": "right",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Ordering",
      "line": 15,
      "raw": "pub fn compare(left: Int, right: Int) -> Ordering {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn compare(left: Int, right: Int) -> Ordering {\n  if left < right {\n    Less\n  } else if left > right {\n    Greater\n  } else {\n    Equal\n  }\n}"
    },
    {
      "key": "stdlib:aiken.primitive.int.from_bytearray_big_endian",
      "fullName": "stdlib:aiken.primitive.int.from_bytearray_big_endian",
      "name": "from_bytearray_big_endian",
      "signature": "pub fn from_bytearray_big_endian(self: ByteArray) -> Int {",
      "documentation": "Interpret a Big-Endian (most-significant bytes first) `ByteArray` as an `Int`.\n\n```aiken\nint.from_bytearray_big_endian(#\"0f4240\") == 1_000_000\nint.from_bytearray_big_endian(#\"00000f4240\") == 1_000_000\nint.from_bytearray_big_endian(#\"0000000000000000\") == 0\n```",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 34,
      "raw": "pub fn from_bytearray_big_endian(self: ByteArray) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_bytearray_big_endian(self: ByteArray) -> Int {\n  bytearray_to_integer(True, self)\n}",
      "tests": [
        "test from_bytearray_big_endian_1() {\n  from_bytearray_big_endian(#\"0f4240\") == 1_000_000\n}",
        "test from_bytearray_big_endian_2() {\n  from_bytearray_big_endian(#\"00000f4240\") == 1_000_000\n}",
        "test from_bytearray_big_endian_3() {\n  from_bytearray_big_endian(#\"0000000000000000\") == 0\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.int.from_bytearray_little_endian",
      "fullName": "stdlib:aiken.primitive.int.from_bytearray_little_endian",
      "name": "from_bytearray_little_endian",
      "signature": "pub fn from_bytearray_little_endian(self: ByteArray) -> Int {",
      "documentation": "Interpret a Little-Endian (least-significant bytes first) `ByteArray` as an `Int`.\n\n```aiken\nint.from_bytearray_big_endian(#\"40420f\") == 1_000_000\nint.from_bytearray_big_endian(#\"40420f0000\") == 1_000_000\nint.from_bytearray_big_endian(#\"0000000000000000\") == 0\n```",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 57,
      "raw": "pub fn from_bytearray_little_endian(self: ByteArray) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_bytearray_little_endian(self: ByteArray) -> Int {\n  bytearray_to_integer(False, self)\n}",
      "tests": [
        "test from_bytearray_little_endian_1() {\n  from_bytearray_little_endian(#\"40420f\") == 1_000_000\n}",
        "test from_bytearray_little_endian_2() {\n  from_bytearray_little_endian(#\"40420f0000\") == 1_000_000\n}",
        "test from_bytearray_little_endian_3() {\n  from_bytearray_little_endian(#\"0000000000000000\") == 0\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.int.from_utf8",
      "fullName": "stdlib:aiken.primitive.int.from_utf8",
      "name": "from_utf8",
      "signature": "pub fn from_utf8(bytes: ByteArray) -> Option<Int> {",
      "documentation": "Parse an integer from a utf-8 encoded `ByteArray`, when possible.\n\n```aiken\nint.from_utf8(\"14\") == Some(14)\nint.from_utf8(\"-42\") == Some(-42)\nint.from_utf8(\"007\") == Some(7)\nint.from_utf8(\"foo\") == None\nint.from_utf8(\"1.0\") == None\nint.from_utf8(\"1-2\") == None\n```",
      "parameters": [
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Option<Int>",
      "line": 83,
      "raw": "pub fn from_utf8(bytes: ByteArray) -> Option<Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_utf8(bytes: ByteArray) -> Option<Int> {\n  bytes\n    |> bytearray.foldr(\n        Some((0, 0)),\n        fn(byte, st) {\n          when st is {\n            None -> None\n            Some((n, e)) ->\n              if byte < 48 || byte > 57 {\n                if byte == 45 {\n                  Some((-n, 0))\n                } else {\n                  None\n                }\n              } else if n < 0 {\n                None\n              } else {\n                let digit = byte - 48\n                Some((n + digit * math.pow(10, e), e + 1))\n              }\n          }\n        },\n      )\n    |> option.map(fn(tuple) { tuple.1st })\n}",
      "tests": [
        "test from_utf8_1() {\n  from_utf8(\"0017\") == Some(17)\n}",
        "test from_utf8_2() {\n  from_utf8(\"42\") == Some(42)\n}",
        "test from_utf8_3() {\n  from_utf8(\"1337\") == Some(1337)\n}",
        "test from_utf8_4() {\n  from_utf8(\"-14\") == Some(-14)\n}",
        "test from_utf8_5() {\n  from_utf8(\"foo\") == None\n}",
        "test from_utf8_6() {\n  from_utf8(\"1-2\") == None\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.int.to_string",
      "fullName": "stdlib:aiken.primitive.int.to_string",
      "name": "to_string",
      "signature": "pub fn to_string(n: Int) -> String {",
      "documentation": "Convert an `Int` to its `String` representation.\n\n```aiken\nint.to_string(42) == @\"42\"\n```",
      "parameters": [
        {
          "name": "n",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "String",
      "line": 138,
      "raw": "pub fn to_string(n: Int) -> String {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn to_string(n: Int) -> String {\n  diagnostic(n, \"\") |> decode_utf8\n}",
      "tests": [
        "test to_string_1() {\n  to_string(0) == @\"0\"\n}",
        "test to_string_2() {\n  to_string(5) == @\"5\"\n}",
        "test to_string_3() {\n  to_string(42) == @\"42\"\n}",
        "test to_string_4() {\n  to_string(200) == @\"200\"\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.string.from_bytearray",
      "fullName": "stdlib:aiken.primitive.string.from_bytearray",
      "name": "from_bytearray",
      "signature": "pub fn from_bytearray(bytes: ByteArray) -> String {",
      "documentation": "Convert a `ByteArray` into a `String`\n\n> [!WARNING]\n> This functions fails if the underlying `ByteArray` isn't UTF-8-encoded. In particular, you cannot convert arbitrary hash digests using this function.\n>\n> For converting arbitrary `ByteArray`s, use [bytearray.to_hex](./bytearray.html#to_hex).\n\n```aiken\nstring.from_bytearray(\"foo\") == @\"foo\"\nstring.from_bytearray(#\"666f6f\") == @\"foo\"\nstring.from_bytearray(some_hash) -> fail\n```",
      "parameters": [
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "String",
      "line": 19,
      "raw": "pub fn from_bytearray(bytes: ByteArray) -> String {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_bytearray(bytes: ByteArray) -> String {\n  decode_utf8(bytes)\n}",
      "tests": [
        "test from_bytearray_1() {\n  from_bytearray(#[]) == @\"\"\n}",
        "test from_bytearray_2() {\n  from_bytearray(#[65, 66, 67]) == @\"ABC\"\n}",
        "test from_bytearray_3() {\n  from_bytearray(\"ABC\") == @\"ABC\"\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.string.from_int",
      "fullName": "stdlib:aiken.primitive.string.from_int",
      "name": "from_int",
      "signature": "pub fn from_int(n: Int) -> String {",
      "documentation": "Convert an `Int` to its `String` representation.\n\n```aiken\nstring.from_int(42) == @\"42\"\n```",
      "parameters": [
        {
          "name": "n",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "String",
      "line": 40,
      "raw": "pub fn from_int(n: Int) -> String {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_int(n: Int) -> String {\n  diagnostic(n, \"\") |> decode_utf8\n}",
      "tests": [
        "test from_int_1() {\n  from_int(0) == @\"0\"\n}",
        "test from_int_2() {\n  from_int(5) == @\"5\"\n}",
        "test from_int_3() {\n  from_int(42) == @\"42\"\n}",
        "test from_int_4() {\n  from_int(200) == @\"200\"\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.string.concat",
      "fullName": "stdlib:aiken.primitive.string.concat",
      "name": "concat",
      "signature": "pub fn concat(left: String, right: String) -> String {",
      "documentation": "Combine two `String` together.\n\n```aiken\nstring.concat(left: @\"Hello\", right: @\", World!\") == @\"Hello, World!\"\n```",
      "parameters": [
        {
          "name": "left",
          "type": "String",
          "optional": false
        },
        {
          "name": "right",
          "type": "String",
          "optional": false
        }
      ],
      "returnType": "String",
      "line": 67,
      "raw": "pub fn concat(left: String, right: String) -> String {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn concat(left: String, right: String) -> String {\n  append_string(left, right)\n}",
      "tests": [
        "test concat_1() {\n  concat(@\"\", @\"\") == @\"\"\n}",
        "test concat_2() {\n  concat(@\"\", @\"foo\") == concat(@\"foo\", @\"\")\n}",
        "test concat_3() {\n  concat(left: @\"Hello\", right: @\", World!\") == @\"Hello, World!\"\n}"
      ]
    },
    {
      "key": "stdlib:aiken.primitive.string.join",
      "fullName": "stdlib:aiken.primitive.string.join",
      "name": "join",
      "signature": "pub fn join(list: List<String>, delimiter: String) -> String {",
      "documentation": "Join a list of strings, separated by a given _delimiter_.\n\n```aiken\nstring.join([], @\"+\") == @\"\"\nstring.join([@\"a\", @\"b\", @\"c\"], @\",\") == @\"a,b,c\"\n```",
      "parameters": [
        {
          "name": "list",
          "type": "List<String>",
          "optional": false
        },
        {
          "name": "delimiter",
          "type": "String",
          "optional": false
        }
      ],
      "returnType": "String",
      "line": 89,
      "raw": "pub fn join(list: List<String>, delimiter: String) -> String {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn join(list: List<String>, delimiter: String) -> String {\n  do_join(list, encode_utf8(delimiter), #\"\")\n    |> decode_utf8\n}"
    },
    {
      "key": "stdlib:aiken.primitive.string.to_bytearray",
      "fullName": "stdlib:aiken.primitive.string.to_bytearray",
      "name": "to_bytearray",
      "signature": "pub fn to_bytearray(self: String) -> ByteArray {",
      "documentation": "Convert a `String` into a `ByteArray`\n\n```aiken\nstring.to_bytearray(@\"foo\") == \"foo\"\n```",
      "parameters": [
        {
          "name": "self",
          "type": "String",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 125,
      "raw": "pub fn to_bytearray(self: String) -> ByteArray {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn to_bytearray(self: String) -> ByteArray {\n  encode_utf8(self)\n}",
      "tests": [
        "test to_bytearray_1() {\n  to_bytearray(@\"\") == \"\"\n}",
        "test to_bytearray_2() {\n  to_bytearray(@\"ABC\") == #[65, 66, 67]\n}",
        "test to_bytearray_3() {\n  to_bytearray(@\"ABC\") == \"ABC\"\n}"
      ]
    },
    {
      "key": "stdlib:cardano.address.credential.compare",
      "fullName": "stdlib:cardano.address.credential.compare",
      "name": "compare",
      "signature": "pub fn compare(left: Credential, right: Credential) -> Ordering {",
      "parameters": [
        {
          "name": "left",
          "type": "Credential",
          "optional": false
        },
        {
          "name": "right",
          "type": "Credential",
          "optional": false
        }
      ],
      "returnType": "Ordering",
      "line": 4,
      "raw": "pub fn compare(left: Credential, right: Credential) -> Ordering {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn compare(left: Credential, right: Credential) -> Ordering {\n  when left is {\n    Script(left) ->\n      when right is {\n        Script(right) -> bytearray.compare(left, right)\n        _ -> Less\n      }\n    VerificationKey(left) ->\n      when right is {\n        Script(_) -> Greater\n        VerificationKey(right) -> bytearray.compare(left, right)\n      }\n  }\n}",
      "tests": [
        "test compare_matrix() {\n  and {\n    (compare(Script(\"\"), Script(\"\")) == Equal)?,\n    (compare(VerificationKey(\"\"), VerificationKey(\"\")) == Equal)?,\n    (compare(Script(\"\"), VerificationKey(\"\")) == Less)?,\n    (compare(VerificationKey(\"\"), Script(\"\")) == Greater)?,\n    (compare(Script(\"01\"), Script(\"02\")) == Less)?,\n    (compare(Script(\"02\"), Script(\"01\")) == Greater)?,\n    (compare(VerificationKey(\"01\"), VerificationKey(\"02\")) == Less)?,\n    (compare(VerificationKey(\"02\"), VerificationKey(\"01\")) == Greater)?,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:cardano.address.from_script",
      "fullName": "stdlib:cardano.address.from_script",
      "name": "from_script",
      "signature": "pub fn from_script(script: Hash<Blake2b_224, Script>) -> Address {",
      "documentation": "Smart-constructor for an [Address](#Address) from a [script](#Script) hash. The address has no delegation rights whatsoever.",
      "parameters": [
        {
          "name": "script",
          "type": "Hash<Blake2b_224, Script>",
          "optional": false
        }
      ],
      "returnType": "Address",
      "line": 28,
      "raw": "pub fn from_script(script: Hash<Blake2b_224, Script>) -> Address {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_script(script: Hash<Blake2b_224, Script>) -> Address {\n  Address { payment_credential: Script(script), stake_credential: None }\n}"
    },
    {
      "key": "stdlib:cardano.address.from_verification_key",
      "fullName": "stdlib:cardano.address.from_verification_key",
      "name": "from_verification_key",
      "signature": "pub fn from_verification_key(vk: Hash<Blake2b_224, VerificationKey>) -> Address {",
      "documentation": "Smart-constructor for an [Address](#Address) from a [verification key](#VerificationKey) hash. The resulting address has no delegation rights whatsoever.",
      "parameters": [
        {
          "name": "vk",
          "type": "Hash<Blake2b_224, VerificationKey>",
          "optional": false
        }
      ],
      "returnType": "Address",
      "line": 33,
      "raw": "pub fn from_verification_key(vk: Hash<Blake2b_224, VerificationKey>) -> Address {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_verification_key(vk: Hash<Blake2b_224, VerificationKey>) -> Address {\n  Address { payment_credential: VerificationKey(vk), stake_credential: None }\n}"
    },
    {
      "key": "stdlib:cardano.address.with_delegation_key",
      "fullName": "stdlib:cardano.address.with_delegation_key",
      "name": "with_delegation_key",
      "signature": "pub fn with_delegation_key(pub fn with_delegation_key(self: Address, vk: Hash<Blake2b_224, VerificationKey>, ) -> Address {",
      "documentation": "Set (or reset) the delegation part of an [Address](#Address) using a [verification key](#VerificationKey) hash. This is useful when combined with [`from_verification_key`](#from_verification_key) and/or [`from_script`](#from_script).",
      "parameters": [],
      "returnType": "Address",
      "line": 38,
      "raw": "pub fn with_delegation_key(pub fn with_delegation_key(self: Address, vk: Hash<Blake2b_224, VerificationKey>, ) -> Address {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn with_delegation_key(\n  self: Address,\n  vk: Hash<Blake2b_224, VerificationKey>,\n) -> Address {\n  Address {\n    payment_credential: self.payment_credential,\n    stake_credential: Some(Inline(VerificationKey(vk))),\n  }\n}"
    },
    {
      "key": "stdlib:cardano.address.with_delegation_script",
      "fullName": "stdlib:cardano.address.with_delegation_script",
      "name": "with_delegation_script",
      "signature": "pub fn with_delegation_script(pub fn with_delegation_script(self: Address, script: Hash<Blake2b_224, Script>, ) -> Address {",
      "documentation": "Set (or reset) the delegation part of an [Address](#Address) using a [script](#Script) hash. This is useful when combined with [`from_verification_key`](#from_verification_key) and/or [`from_script`](#from_script).",
      "parameters": [],
      "returnType": "Address",
      "line": 49,
      "raw": "pub fn with_delegation_script(pub fn with_delegation_script(self: Address, script: Hash<Blake2b_224, Script>, ) -> Address {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn with_delegation_script(\n  self: Address,\n  script: Hash<Blake2b_224, Script>,\n) -> Address {\n  Address {\n    payment_credential: self.payment_credential,\n    stake_credential: Some(Inline(Script(script))),\n  }\n}"
    },
    {
      "key": "stdlib:cardano.assets.strategy.triple",
      "fullName": "stdlib:cardano.assets.strategy.triple",
      "name": "triple",
      "signature": "pub fn triple() -> FlattenStrategy<(Hash<Blake2b_224, Script>, ByteArray, Int)> {",
      "documentation": "Keep all assets, combining them as a 3-tuple.\n\n```aiken\nfn(policy_id, asset_name, quantity, keep, _discard) {\nkeep((policy_id, asset_name, quantity))\n}\n```",
      "parameters": [],
      "returnType": "FlattenStrategy<(Hash<Blake2b_224, Script>, ByteArray, Int)>",
      "line": 31,
      "raw": "pub fn triple() -> FlattenStrategy<(Hash<Blake2b_224, Script>, ByteArray, Int)> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn triple() -> FlattenStrategy<(Hash<Blake2b_224, Script>, ByteArray, Int)> {\n  fn(policy_id, asset_name, quantity, keep, _discard) {\n    keep((policy_id, asset_name, quantity))\n  }\n}"
    },
    {
      "key": "stdlib:cardano.assets.from_asset",
      "fullName": "stdlib:cardano.assets.from_asset",
      "name": "from_asset",
      "signature": "pub fn from_asset(pub fn from_asset(policy_id: PolicyId, asset_name: AssetName, quantity: Int, ) -> Value {",
      "documentation": "Construct a `Value` from an asset identifier (i.e. `PolicyId` + `AssetName`)\nand a given quantity.",
      "parameters": [],
      "returnType": "Value",
      "line": 47,
      "raw": "pub fn from_asset(pub fn from_asset(policy_id: PolicyId, asset_name: AssetName, quantity: Int, ) -> Value {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_asset(\n  policy_id: PolicyId,\n  asset_name: AssetName,\n  quantity: Int,\n) -> Value {\n  if quantity == 0 {\n    zero\n  } else {\n    let asset =\n      dict.empty\n        |> dict.insert(asset_name, quantity)\n    dict.empty\n      |> dict.insert(policy_id, asset)\n      |> Value\n  }\n}"
    },
    {
      "key": "stdlib:cardano.assets.from_asset_list",
      "fullName": "stdlib:cardano.assets.from_asset_list",
      "name": "from_asset_list",
      "signature": "pub fn from_asset_list(xs: Pairs<PolicyId, Pairs<AssetName, Int>>) -> Value {",
      "documentation": "Promote an arbitrary list of assets into a `Value`. This function fails\n(i.e. halts the program execution) if:\n\n- there's any duplicate amongst `PolicyId`;\n- there's any duplicate amongst `AssetName`;\n- the `AssetName` aren't sorted in ascending lexicographic order; or\n- any asset quantity is null.\n\nThis function is meant to turn arbitrary user-defined `Data` into safe `Value`,\nwhile checking for internal invariants.",
      "parameters": [
        {
          "name": "xs",
          "type": "Pairs<PolicyId, Pairs<AssetName, Int>>",
          "optional": false
        }
      ],
      "returnType": "Value",
      "line": 74,
      "raw": "pub fn from_asset_list(xs: Pairs<PolicyId, Pairs<AssetName, Int>>) -> Value {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_asset_list(xs: Pairs<PolicyId, Pairs<AssetName, Int>>) -> Value {\n  xs\n    |> list.foldr(\n        dict.empty,\n        fn(inner, acc) {\n          expect Pair(p, [_, ..] as x) = inner\n          x\n            |> from_ascending_pairs_with(fn(v) { v != 0 })\n            |> dict.insert_with(acc, p, _, dict_strategy.expect_no_duplicate())\n        },\n      )\n    |> Value\n}",
      "tests": [
        "test from_asset_list_1() {\n  let v = from_asset_list([])\n  v == zero\n}",
        "test from_asset_list_2() fail {\n  let v = from_asset_list([Pair(#\"33\", [])])\n  v == zero\n}",
        "test from_asset_list_3() fail {\n  let v = from_asset_list([Pair(#\"33\", [Pair(#\"\", 0)])])\n  v != zero\n}",
        "test from_asset_list_4() {\n  let v = from_asset_list([Pair(#\"33\", [Pair(#\"\", 1)])])\n  flatten(v) == [(#\"33\", #\"\", 1)]\n}",
        "test from_asset_list_5() {\n  let v = from_asset_list([Pair(#\"33\", [Pair(#\"\", 1), Pair(#\"33\", 1)])])\n  flatten(v) == [(#\"33\", #\"\", 1), (#\"33\", #\"33\", 1)]\n}",
        "test from_asset_list_6() fail {\n  let v =\n    from_asset_list(\n      [\n        Pair(#\"33\", [Pair(#\"\", 1), Pair(#\"33\", 1)]),\n        Pair(#\"33\", [Pair(#\"\", 1), Pair(#\"33\", 1)]),\n      ],\n    )\n  v != zero\n}",
        "test from_asset_list_7() fail {\n  let v =\n    from_asset_list(\n      [\n        Pair(#\"33\", [Pair(#\"\", 1), Pair(#\"33\", 1)]),\n        Pair(#\"34\", [Pair(#\"\", 1), Pair(#\"\", 1)]),\n      ],\n    )\n  v != zero\n}",
        "test from_asset_list_8() {\n  let v =\n    from_asset_list(\n      [\n        Pair(#\"33\", [Pair(#\"\", 1), Pair(#\"33\", 1)]),\n        Pair(#\"34\", [Pair(#\"31\", 1)]), Pair(#\"35\", [Pair(#\"\", 1)]),\n      ],\n    )\n  flatten(v) == [\n    (#\"33\", #\"\", 1), (#\"33\", #\"33\", 1), (#\"34\", #\"31\", 1), (#\"35\", #\"\", 1),\n  ]\n}",
        "test from_asset_list_9() {\n  let v =\n    from_asset_list(\n      [\n        Pair(#\"35\", [Pair(#\"\", 1)]), Pair(#\"33\", [Pair(#\"\", 1), Pair(#\"33\", 1)]),\n        Pair(#\"34\", [Pair(#\"31\", 1)]),\n      ],\n    )\n  flatten(v) == [\n    (#\"33\", #\"\", 1), (#\"33\", #\"33\", 1), (#\"34\", #\"31\", 1), (#\"35\", #\"\", 1),\n  ]\n}"
      ]
    },
    {
      "key": "stdlib:cardano.assets.from_lovelace",
      "fullName": "stdlib:cardano.assets.from_lovelace",
      "name": "from_lovelace",
      "signature": "pub fn from_lovelace(quantity: Int) -> Value {",
      "documentation": "Construct a `Value` from a lovelace quantity.\n\nFriendly reminder: 1 Ada = 1.000.000 Lovelace",
      "parameters": [
        {
          "name": "quantity",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Value",
      "line": 164,
      "raw": "pub fn from_lovelace(quantity: Int) -> Value {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn from_lovelace(quantity: Int) -> Value {\n  from_asset(ada_policy_id, ada_asset_name, quantity)\n}"
    },
    {
      "key": "stdlib:cardano.assets.is_zero",
      "fullName": "stdlib:cardano.assets.is_zero",
      "name": "is_zero",
      "signature": "pub fn is_zero(self: Value) -> Bool {",
      "documentation": "Check is a `Value` is zero. That is, it has no assets and holds no Ada/Lovelace.",
      "parameters": [
        {
          "name": "self",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 174,
      "raw": "pub fn is_zero(self: Value) -> Bool {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn is_zero(self: Value) -> Bool {\n  self == zero\n}"
    },
    {
      "key": "stdlib:cardano.assets.match",
      "fullName": "stdlib:cardano.assets.match",
      "name": "match",
      "signature": "pub fn match(pub fn match(left: Value, right: Data, assert_lovelace: fn(Lovelace, Lovelace) -> Bool,",
      "documentation": "Efficiently compare two values together, allowing a custom behaviour for Ada/Lovelace.\nThe second parameter is provided as `Data`, allowing to conveniently compare serialized\ndatums or similar structurually equivalent types (such as `Pairs<PolicyId, Pairs<AssetName, Lovelace>>`).\n\nThe third argument is a callback function to assert the left and right lovelace\nquantities. Its first argument refers to the quantity of the first argument of\n`match`, and the second argument of the callback to the quantity of the second\nargument of `match`. In the absence of lovelace in any value, it defaults to `0`.\n\n```aiken\nconst value: Value =\nassets.from_lovelace(30)\n|> assets.add(\"foo\", \"bar\", 1)\n|> assets.add(\"foo\", \"baz\", 42)\n\nconst datum: Data =\nassets.from_lovelace(20)\n|> assets.add(\"foo\", \"bar\", 1)\n|> assets.add(\"foo\", \"baz\", 42)\n\nTrue == assets.match(value, datum, >=)\n\nFalse == assets.match(value, datum, ==)\n\nTrue == assets.match(value, datum, fn(value_lovelace, datum_lovelace) {\n2 * datum_lovelace >= value_lovelace\n})\n```",
      "parameters": [],
      "returnType": "Bool,",
      "line": 206,
      "raw": "pub fn match(pub fn match(left: Value, right: Data, assert_lovelace: fn(Lovelace, Lovelace) -> Bool,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn match(\n  left: Value,\n  right: Data,\n  assert_lovelace: fn(Lovelace, Lovelace) -> Bool,\n) -> Bool {\n  builtin.choose_data(\n    right,\n    False,\n    {\n      let (left_lovelace, left_assets) = dict.pop(left.inner, ada_policy_id)\n      let left_assets: Data = left_assets\n      let left_lovelace =\n        when left_lovelace is {\n          Some(tokens) -> builtin.head_list(dict.to_pairs(tokens)).2nd\n          None -> 0\n        }\n      when builtin.un_map_data(right) is {\n        [] -> left_assets == right && assert_lovelace(left_lovelace, 0)\n        [first_asset, ..right_assets] ->\n          if first_asset.1st == builtin.b_data(ada_policy_id) {\n            and {\n              assert_lovelace(\n                left_lovelace,\n                builtin.un_i_data(\n                  builtin.head_list(builtin.un_map_data(first_asset.2nd)).2nd,\n                ),\n              ),\n              left_assets == builtin.map_data(right_assets),\n            }\n          } else {\n            and {\n              assert_lovelace(left_lovelace, 0),\n              left_assets == right,\n            }\n          }\n      }\n    },\n    False,\n    False,\n    False,\n  )\n}",
      "tests": [
        "test match_1() {\n  match(fixture_match_value, fixture_match_data, fn(_, _) { True })\n}",
        "test match_2() {\n  !match(\n    fixture_match_value,\n    fixture_match_data,\n    fn(source, target) { source == target },\n  )\n}",
        "test match_3() {\n  !match(\n    fixture_match_value,\n    fixture_match_data_missing_foo_02,\n    fn(_, _) { True },\n  )\n}",
        "test match_4() {\n  !match(fixture_match_value, fixture_match_data_missing_bar, fn(_, _) { True })\n}",
        "test match_5() {\n  !match(\n    fixture_match_value,\n    fixture_match_data_altered_foo_01,\n    fn(_, _) { True },\n  )\n}",
        "test match_6() {\n  !match(\n    fixture_match_value,\n    fixture_match_data_extra_policy,\n    fn(_, _) { True },\n  )\n}",
        "test match_7() {\n  !match(fixture_match_value, fixture_match_data_extra_asset, fn(_, _) { True })\n}",
        "test match_8() {\n  !match(fixture_match_value, fixture_match_data_no_assets, fn(_, _) { True })\n}",
        "test match_9() {\n  match(zero, zero, ==)\n}",
        "test match_10() {\n  match(\n    without_lovelace(fixture_match_value),\n    without_lovelace(fixture_match_value),\n    fn(left, right) { left == 0 && right == 0 },\n  )\n}",
        "test match_11() {\n  match(\n    without_lovelace(fixture_match_value),\n    fixture_match_value,\n    fn(left, right) { left == 0 && right > 0 },\n  )\n}",
        "test match_12() {\n  match(\n    fixture_match_value,\n    without_lovelace(fixture_match_value),\n    fn(left, right) { left > 0 && right == 0 },\n  )\n}",
        "test match_13() {\n  match(\n    zero |> add(ada_policy_id, ada_asset_name, 42),\n    zero,\n    fn(left, right) { left == 42 && right == 0 },\n  )\n}",
        "test match_14() {\n  match(\n    zero,\n    zero |> add(ada_policy_id, ada_asset_name, 42),\n    fn(left, right) { left == 0 && right == 42 },\n  )\n}",
        "test match_benchmark() {\n  match(fixture_match_benchmark_left, fixture_match_benchmark_right, ==)\n}",
        "test match_benchmark_vs() {\n  let data: Data = fixture_match_benchmark_right\n  expect pairs: Pairs<PolicyId, Pairs<AssetName, Int>> = data\n  fixture_match_benchmark_left == from_asset_list(pairs)\n}"
      ]
    },
    {
      "key": "stdlib:cardano.assets.lovelace_of",
      "fullName": "stdlib:cardano.assets.lovelace_of",
      "name": "lovelace_of",
      "signature": "pub fn lovelace_of(self: Value) -> Int {",
      "documentation": "A specialized version of `quantity_of` for the Ada currency.",
      "parameters": [
        {
          "name": "self",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 511,
      "raw": "pub fn lovelace_of(self: Value) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn lovelace_of(self: Value) -> Int {\n  quantity_of(self, ada_policy_id, ada_asset_name)\n}"
    },
    {
      "key": "stdlib:cardano.assets.policies",
      "fullName": "stdlib:cardano.assets.policies",
      "name": "policies",
      "signature": "pub fn policies(self: Value) -> List<PolicyId> {",
      "documentation": "A list of all token policies in that Value with non-zero tokens.",
      "parameters": [
        {
          "name": "self",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "List<PolicyId>",
      "line": 516,
      "raw": "pub fn policies(self: Value) -> List<PolicyId> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn policies(self: Value) -> List<PolicyId> {\n  dict.keys(self.inner)\n}"
    },
    {
      "key": "stdlib:cardano.assets.quantity_of",
      "fullName": "stdlib:cardano.assets.quantity_of",
      "name": "quantity_of",
      "signature": "pub fn quantity_of(pub fn quantity_of(self: Value, policy_id: PolicyId, asset_name: AssetName, ) -> Int {",
      "documentation": "Extract the quantity of a given asset.",
      "parameters": [],
      "returnType": "Int",
      "line": 521,
      "raw": "pub fn quantity_of(pub fn quantity_of(self: Value, policy_id: PolicyId, asset_name: AssetName, ) -> Int {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn quantity_of(\n  self: Value,\n  policy_id: PolicyId,\n  asset_name: AssetName,\n) -> Int {\n  self.inner\n    |> dict.get(policy_id)\n    |> option.and_then(dict.get(_, asset_name))\n    |> option.or_else(0)\n}"
    },
    {
      "key": "stdlib:cardano.assets.tokens",
      "fullName": "stdlib:cardano.assets.tokens",
      "name": "tokens",
      "signature": "pub fn tokens(self: Value, policy_id: PolicyId) -> Dict<AssetName, Int> {",
      "documentation": "Get all tokens associated with a given policy.",
      "parameters": [
        {
          "name": "self",
          "type": "Value",
          "optional": false
        },
        {
          "name": "policy_id",
          "type": "PolicyId",
          "optional": false
        }
      ],
      "returnType": "Dict<AssetName, Int>",
      "line": 533,
      "raw": "pub fn tokens(self: Value, policy_id: PolicyId) -> Dict<AssetName, Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn tokens(self: Value, policy_id: PolicyId) -> Dict<AssetName, Int> {\n  self.inner\n    |> dict.get(policy_id)\n    |> option.or_else(dict.empty)\n}"
    },
    {
      "key": "stdlib:cardano.assets.add",
      "fullName": "stdlib:cardano.assets.add",
      "name": "add",
      "signature": "pub fn add(pub fn add(self: Value, policy_id: PolicyId, asset_name: AssetName, quantity: Int, ) -> Value {",
      "documentation": "Add a (positive or negative) quantity of a single token to a assets.\nThis is more efficient than [`merge`](#merge) for a single asset.",
      "parameters": [],
      "returnType": "Value",
      "line": 543,
      "raw": "pub fn add(pub fn add(self: Value, policy_id: PolicyId, asset_name: AssetName, quantity: Int, ) -> Value {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn add(\n  self: Value,\n  policy_id: PolicyId,\n  asset_name: AssetName,\n  quantity: Int,\n) -> Value {\n  if quantity == 0 {\n    self\n  } else {\n    let helper =\n      fn(_, left, _right, keep, discard) {\n        let inner_result =\n          dict.insert_with(\n            left,\n            asset_name,\n            quantity,\n            dict_strategy.sum_if_non_zero(),\n          )\n\n        if dict.is_empty(inner_result) {\n          discard()\n        } else {\n          keep(inner_result)\n        }\n      }\n\n    Value(\n      dict.insert_with(\n        self.inner,\n        policy_id,\n        dict.from_ascending_pairs([Pair(asset_name, quantity)]),\n        helper,\n      ),\n    )\n  }\n}",
      "tests": [
        "test add_1() {\n  let v =\n    zero\n      |> add(#\"acab\", #\"beef\", 321)\n      |> add(#\"acab\", #\"beef\", -321)\n  v == zero\n}",
        "test add_2() {\n  let v =\n    from_lovelace(123)\n      |> add(#\"acab\", #\"beef\", 321)\n      |> add(#\"acab\", #\"beef\", -1 * 321)\n  v == from_lovelace(123)\n}",
        "test add_3() {\n  let v =\n    from_lovelace(1)\n      |> add(ada_policy_id, ada_asset_name, 2)\n      |> add(ada_policy_id, ada_asset_name, 3)\n  v == from_lovelace(6)\n}",
        "test add_4() {\n  let v =\n    zero\n      |> add(#\"acab\", #\"beef\", 0)\n  v == zero\n}",
        "test add_5() {\n  let v =\n    zero\n      |> add(#\"acab\", #\"beef\", 0)\n      |> add(#\"acab\", #\"beef\", 0)\n  v == zero\n}"
      ]
    },
    {
      "key": "stdlib:cardano.assets.merge",
      "fullName": "stdlib:cardano.assets.merge",
      "name": "merge",
      "signature": "pub fn merge(left v0: Value, right v1: Value) -> Value {",
      "documentation": "Combine two `Value` together.",
      "parameters": [],
      "returnType": "Value",
      "line": 620,
      "raw": "pub fn merge(left v0: Value, right v1: Value) -> Value {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn merge(left v0: Value, right v1: Value) -> Value {\n  Value(\n    dict.union_with(\n      v0.inner,\n      v1.inner,\n      fn(_, a0, a1, keep, discard) {\n        let result = dict.union_with(a0, a1, dict_strategy.sum_if_non_zero())\n        if dict.is_empty(result) {\n          discard()\n        } else {\n          keep(result)\n        }\n      },\n    ),\n  )\n}",
      "tests": [
        "test merge_1() {\n  let v1 = from_lovelace(1)\n  let v2 = from_lovelace(-1)\n  merge(v1, v2) == zero\n}",
        "test merge_2() {\n  let v1 = from_asset(#\"00\", #\"\", 1)\n  let v2 = from_asset(#\"01\", #\"\", 2)\n  let v3 = from_asset(#\"02\", #\"\", 3)\n  let v =\n    from_lovelace(42)\n      |> merge(v3)\n      |> merge(v1)\n      |> merge(v2)\n\n  flatten(v) == [\n    (#\"\", #\"\", 42), (#\"00\", #\"\", 1), (#\"01\", #\"\", 2), (#\"02\", #\"\", 3),\n  ]\n}",
        "test merge_3() {\n  let v1 = from_asset(#\"00\", #\"\", 1)\n  let v2 = from_asset(#\"00\", #\"\", -1)\n  let v3 = from_asset(#\"01\", #\"\", 1)\n\n  let v =\n    zero\n      |> merge(v1)\n      |> merge(v2)\n      |> merge(v3)\n\n  flatten(v) == [(#\"01\", #\"\", 1)]\n}",
        "test merge_4() {\n  let v1 = from_asset(#\"00\", #\"\", 1)\n  let v2 = from_asset(#\"00\", #\"\", -1)\n\n  merge(v1, v2) == zero\n}",
        "test merge_5() {\n  let v =\n    zero\n      |> add(#\"acab\", #\"beef\", 0)\n\n  merge(zero, v) == zero\n}"
      ]
    },
    {
      "key": "stdlib:cardano.assets.negate",
      "fullName": "stdlib:cardano.assets.negate",
      "name": "negate",
      "signature": "pub fn negate(self: Value) -> Value {",
      "documentation": "Negates quantities of all tokens (including Ada) in that `Value`.\n\n```\nv1\n|> assets.negate\n|> assets.merge(v1)\n|> assets.is_zero\n// True\n```",
      "parameters": [
        {
          "name": "self",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "Value",
      "line": 696,
      "raw": "pub fn negate(self: Value) -> Value {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn negate(self: Value) -> Value {\n  dict.map(self.inner, fn(_, a) { dict.map(a, fn(_, q) { 0 - q }) })\n    |> Value\n}"
    },
    {
      "key": "stdlib:cardano.assets.restricted_to",
      "fullName": "stdlib:cardano.assets.restricted_to",
      "name": "restricted_to",
      "signature": "pub fn restricted_to(self: Value, mask: List<PolicyId>) -> Value {",
      "documentation": "Get a subset of the assets restricted to the given policies.",
      "parameters": [
        {
          "name": "self",
          "type": "Value",
          "optional": false
        },
        {
          "name": "mask",
          "type": "List<PolicyId>",
          "optional": false
        }
      ],
      "returnType": "Value",
      "line": 702,
      "raw": "pub fn restricted_to(self: Value, mask: List<PolicyId>) -> Value {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn restricted_to(self: Value, mask: List<PolicyId>) -> Value {\n  list.foldr(\n    policies(self),\n    zero,\n    fn(policy_id, value) {\n      if list.has(mask, policy_id) {\n        dict.foldr(\n          tokens(self, policy_id),\n          value,\n          fn(asset_name, quantity, value) {\n            add(value, policy_id, asset_name, quantity)\n          },\n        )\n      } else {\n        value\n      }\n    },\n  )\n}",
      "tests": [
        "test restricted_to_1() {\n  let self = from_lovelace(42) |> add(\"foo\", \"\", 1)\n  restricted_to(self, []) == zero\n}",
        "test restricted_to_2() {\n  let self = from_lovelace(42) |> add(\"foo\", \"\", 1)\n  restricted_to(self, [ada_policy_id]) == from_lovelace(42)\n}",
        "test restricted_to_3() {\n  let self = from_lovelace(42) |> add(\"foo\", \"\", 1) |> add(\"bar\", \"\", 1)\n  restricted_to(self, [\"foo\", \"bar\"]) == without_lovelace(self)\n}",
        "test restricted_to_4() {\n  let self = from_lovelace(42) |> add(\"foo\", \"bar\", 1) |> add(\"foo\", \"baz\", 1)\n  restricted_to(self, [\"foo\"]) == without_lovelace(self)\n}",
        "test restricted_to_5() {\n  let self = from_lovelace(42) |> add(\"foo\", \"bar\", 1) |> add(\"foo\", \"baz\", 1)\n  restricted_to(self, [ada_policy_id, \"foo\"]) == self\n}"
      ]
    },
    {
      "key": "stdlib:cardano.assets.without_lovelace",
      "fullName": "stdlib:cardano.assets.without_lovelace",
      "name": "without_lovelace",
      "signature": "pub fn without_lovelace(self: Value) -> Value {",
      "documentation": "Get a `Value` excluding Ada.",
      "parameters": [
        {
          "name": "self",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "Value",
      "line": 748,
      "raw": "pub fn without_lovelace(self: Value) -> Value {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn without_lovelace(self: Value) -> Value {\n  dict.delete(self.inner, ada_policy_id)\n    |> Value\n}",
      "tests": [
        "test without_lovelace_1() {\n  let v = from_lovelace(1000000)\n  without_lovelace(v) == zero\n}",
        "test without_lovelace_2() {\n  let v = from_lovelace(1000000)\n  let v2 = from_lovelace(50000000)\n  without_lovelace(v) == without_lovelace(v2)\n}",
        "test without_lovelace_3() {\n  let v =\n    from_asset(#\"010203\", #\"040506\", 100)\n      |> add(ada_policy_id, ada_asset_name, 100000000)\n  let v2 = from_asset(#\"010203\", #\"040506\", 100)\n  without_lovelace(v) == without_lovelace(v2) && without_lovelace(v) == v2\n}"
      ]
    },
    {
      "key": "stdlib:cardano.assets.flatten",
      "fullName": "stdlib:cardano.assets.flatten",
      "name": "flatten",
      "signature": "pub fn flatten(self: Value) -> List<(PolicyId, AssetName, Int)> {",
      "documentation": "Flatten a `Value` as list of 3-tuple `(PolicyId, AssetName, Quantity)`.\n\nHandy to manipulate values as uniform lists.",
      "parameters": [
        {
          "name": "self",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "List<(PolicyId, AssetName, Int)>",
      "line": 777,
      "raw": "pub fn flatten(self: Value) -> List<(PolicyId, AssetName, Int)> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn flatten(self: Value) -> List<(PolicyId, AssetName, Int)> {\n  dict.foldr(\n    self.inner,\n    [],\n    fn(policy_id, asset_list, value) {\n      dict.foldr(\n        asset_list,\n        value,\n        fn(asset_name, quantity, xs) {\n          [(policy_id, asset_name, quantity), ..xs]\n        },\n      )\n    },\n  )\n}"
    },
    {
      "key": "stdlib:cardano.assets.flatten_with",
      "fullName": "stdlib:cardano.assets.flatten_with",
      "name": "flatten_with",
      "signature": "pub fn flatten_with(self: Value, with: FlattenStrategy<result>) -> List<result> {",
      "documentation": "Flatten a `Value` as a list of results, possibly discarding some along the way.\n\nWhen the transform function returns `None`, the result is discarded altogether.",
      "parameters": [
        {
          "name": "self",
          "type": "Value",
          "optional": false
        },
        {
          "name": "with",
          "type": "FlattenStrategy<result>",
          "optional": false
        }
      ],
      "returnType": "List<result>",
      "line": 796,
      "raw": "pub fn flatten_with(self: Value, with: FlattenStrategy<result>) -> List<result> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn flatten_with(self: Value, with: FlattenStrategy<result>) -> List<result> {\n  dict.foldr(\n    self.inner,\n    [],\n    fn(policy_id, asset_list, value) {\n      dict.foldr(\n        asset_list,\n        value,\n        fn(asset_name, quantity, xs) {\n          with(\n            policy_id,\n            asset_name,\n            quantity,\n            fn(x) { [x, ..xs] },\n            fn() { xs },\n          )\n        },\n      )\n    },\n  )\n}",
      "tests": [
        "test flatten_with_1() {\n  flatten_with(zero, strategy.triple()) == []\n}",
        "test flatten_with_2() {\n  let v =\n    zero\n      |> add(\"a\", \"1\", 14)\n      |> add(\"b\", \"\", 42)\n      |> add(\"a\", \"2\", 42)\n\n  flatten_with(\n    v,\n    fn(p, a, q, keep, discard) {\n      if q == 42 {\n        keep((p, a))\n      } else {\n        discard()\n      }\n    },\n  ) == [(\"a\", \"2\"), (\"b\", \"\")]\n}"
      ]
    },
    {
      "key": "stdlib:cardano.assets.reduce",
      "fullName": "stdlib:cardano.assets.reduce",
      "name": "reduce",
      "signature": "pub fn reduce(pub fn reduce(self: Value, start: result, with: fn(PolicyId, AssetName, Int, result) -> result,",
      "documentation": "Reduce a value into a single result\n\n```\nassets.zero\n|> assets.add(\"a\", \"1\", 10)\n|> assets.add(\"b\", \"2\", 20)\n|> assets.reduce(v, 0, fn(_, _, quantity, acc) { acc + quantity })\n// 30\n```",
      "parameters": [],
      "returnType": "result,",
      "line": 850,
      "raw": "pub fn reduce(pub fn reduce(self: Value, start: result, with: fn(PolicyId, AssetName, Int, result) -> result,",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn reduce(\n  self: Value,\n  start: result,\n  with: fn(PolicyId, AssetName, Int, result) -> result,\n) -> result {\n  dict.foldr(\n    self.inner,\n    start,\n    fn(policy_id, asset_list, result) {\n      dict.foldr(asset_list, result, with(policy_id, _, _, _))\n    },\n  )\n}",
      "tests": [
        "test reduce_1() {\n  let v =\n    zero\n      |> add(\"a\", \"1\", 10)\n      |> add(\"b\", \"2\", 20)\n  let result = reduce(v, 0, fn(_, _, quantity, acc) { acc + quantity })\n  result == 30\n}",
        "test reduce_2() {\n  let v =\n    zero\n      |> add(\"a\", \"1\", 5)\n      |> add(\"a\", \"2\", 15)\n      |> add(\"b\", \"\", 10)\n  let result =\n    reduce(\n      v,\n      [],\n      fn(policy_id, asset_name, _, acc) { [(policy_id, asset_name), ..acc] },\n    )\n  result == [(\"a\", \"1\"), (\"a\", \"2\"), (\"b\", \"\")]\n}",
        "test reduce_3() {\n  let v = zero\n  let result = reduce(v, 1, fn(_, _, quantity, acc) { acc + quantity })\n  result == 1\n}"
      ]
    },
    {
      "key": "stdlib:cardano.assets.to_dict",
      "fullName": "stdlib:cardano.assets.to_dict",
      "name": "to_dict",
      "signature": "pub fn to_dict(self: Value) -> Dict<PolicyId, Dict<AssetName, Int>> {",
      "documentation": "Convert the value into a dictionary of dictionaries.",
      "parameters": [
        {
          "name": "self",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "Dict<PolicyId, Dict<AssetName, Int>>",
      "line": 895,
      "raw": "pub fn to_dict(self: Value) -> Dict<PolicyId, Dict<AssetName, Int>> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn to_dict(self: Value) -> Dict<PolicyId, Dict<AssetName, Int>> {\n  self.inner\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.min_fee_coefficient",
      "fullName": "stdlib:cardano.governance.protocol_parameters.min_fee_coefficient",
      "name": "min_fee_coefficient",
      "signature": "pub fn min_fee_coefficient(self: ProtocolParametersUpdate) -> Option<Int> {",
      "documentation": "The linear coefficient that intervenes in the transaction fee calculation.\nIt is multiplied by the size of the transaction in bytes to obtain a Lovelace value.",
      "parameters": [
        {
          "name": "self",
          "type": "ProtocolParametersUpdate",
          "optional": false
        }
      ],
      "returnType": "Option<Int>",
      "line": 67,
      "raw": "pub fn min_fee_coefficient(self: ProtocolParametersUpdate) -> Option<Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn min_fee_coefficient(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 0, into_int)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.min_fee_constant",
      "fullName": "stdlib:cardano.governance.protocol_parameters.min_fee_constant",
      "name": "min_fee_constant",
      "signature": "pub fn min_fee_constant(self: ProtocolParametersUpdate) -> Option<Int> {",
      "documentation": "The constant factor that intervenes in the transaction fee calculation. It is\na flat cost of lovelace that is added to every fee calculation.",
      "parameters": [
        {
          "name": "self",
          "type": "ProtocolParametersUpdate",
          "optional": false
        }
      ],
      "returnType": "Option<Int>",
      "line": 73,
      "raw": "pub fn min_fee_constant(self: ProtocolParametersUpdate) -> Option<Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn min_fee_constant(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 1, into_int)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.max_block_body_size",
      "fullName": "stdlib:cardano.governance.protocol_parameters.max_block_body_size",
      "name": "max_block_body_size",
      "signature": "pub fn max_block_body_size(self: ProtocolParametersUpdate) -> Option<Int> {",
      "documentation": "The maximum size of a serialized block body, expressed in bytes.",
      "parameters": [
        {
          "name": "self",
          "type": "ProtocolParametersUpdate",
          "optional": false
        }
      ],
      "returnType": "Option<Int>",
      "line": 78,
      "raw": "pub fn max_block_body_size(self: ProtocolParametersUpdate) -> Option<Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn max_block_body_size(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 2, into_int)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.max_transaction_size",
      "fullName": "stdlib:cardano.governance.protocol_parameters.max_transaction_size",
      "name": "max_transaction_size",
      "signature": "pub fn max_transaction_size(self: ProtocolParametersUpdate) -> Option<Int> {",
      "documentation": "The maximum size of a serialized transaction (body + witnesses), expressed in bytes.",
      "parameters": [
        {
          "name": "self",
          "type": "ProtocolParametersUpdate",
          "optional": false
        }
      ],
      "returnType": "Option<Int>",
      "line": 83,
      "raw": "pub fn max_transaction_size(self: ProtocolParametersUpdate) -> Option<Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn max_transaction_size(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 3, into_int)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.max_block_header_size",
      "fullName": "stdlib:cardano.governance.protocol_parameters.max_block_header_size",
      "name": "max_block_header_size",
      "signature": "pub fn max_block_header_size(self: ProtocolParametersUpdate) -> Option<Int> {",
      "documentation": "The maximum size of a serialized block header, expressed in bytes.",
      "parameters": [
        {
          "name": "self",
          "type": "ProtocolParametersUpdate",
          "optional": false
        }
      ],
      "returnType": "Option<Int>",
      "line": 88,
      "raw": "pub fn max_block_header_size(self: ProtocolParametersUpdate) -> Option<Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn max_block_header_size(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 4, into_int)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.stake_credential_deposit",
      "fullName": "stdlib:cardano.governance.protocol_parameters.stake_credential_deposit",
      "name": "stake_credential_deposit",
      "signature": "pub fn stake_credential_deposit(pub fn stake_credential_deposit(self: ProtocolParametersUpdate, ) -> Option<Lovelace> {",
      "documentation": "The required deposit amount when registering stake credentials, expressed in Lovelace.",
      "parameters": [],
      "returnType": "Option<Lovelace>",
      "line": 93,
      "raw": "pub fn stake_credential_deposit(pub fn stake_credential_deposit(self: ProtocolParametersUpdate, ) -> Option<Lovelace> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn stake_credential_deposit(\n  self: ProtocolParametersUpdate,\n) -> Option<Lovelace> {\n  get_protocol_param(self.inner, 5, into_int)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.stake_pool_deposit",
      "fullName": "stdlib:cardano.governance.protocol_parameters.stake_pool_deposit",
      "name": "stake_pool_deposit",
      "signature": "pub fn stake_pool_deposit(self: ProtocolParametersUpdate) -> Option<Lovelace> {",
      "documentation": "The required deposit amount when registering a stake pool, expressed in Lovelace.",
      "parameters": [
        {
          "name": "self",
          "type": "ProtocolParametersUpdate",
          "optional": false
        }
      ],
      "returnType": "Option<Lovelace>",
      "line": 100,
      "raw": "pub fn stake_pool_deposit(self: ProtocolParametersUpdate) -> Option<Lovelace> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn stake_pool_deposit(self: ProtocolParametersUpdate) -> Option<Lovelace> {\n  get_protocol_param(self.inner, 6, into_int)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.stake_pool_retirement_horizon",
      "fullName": "stdlib:cardano.governance.protocol_parameters.stake_pool_retirement_horizon",
      "name": "stake_pool_retirement_horizon",
      "signature": "pub fn stake_pool_retirement_horizon(pub fn stake_pool_retirement_horizon(self: ProtocolParametersUpdate, ) -> Option<Int> {",
      "documentation": "The maximum number of epoch in the future allowed for a stake pool retirement to be scheduled.",
      "parameters": [],
      "returnType": "Option<Int>",
      "line": 105,
      "raw": "pub fn stake_pool_retirement_horizon(pub fn stake_pool_retirement_horizon(self: ProtocolParametersUpdate, ) -> Option<Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn stake_pool_retirement_horizon(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 7, into_int)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.desired_number_of_stake_pools",
      "fullName": "stdlib:cardano.governance.protocol_parameters.desired_number_of_stake_pools",
      "name": "desired_number_of_stake_pools",
      "signature": "pub fn desired_number_of_stake_pools(pub fn desired_number_of_stake_pools(self: ProtocolParametersUpdate, ) -> Option<Int> {",
      "documentation": "The desired/optimal number of fully saturated stake pools in the system. Also known as the _'k-parameter'_.",
      "parameters": [],
      "returnType": "Option<Int>",
      "line": 112,
      "raw": "pub fn desired_number_of_stake_pools(pub fn desired_number_of_stake_pools(self: ProtocolParametersUpdate, ) -> Option<Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn desired_number_of_stake_pools(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 8, into_int)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.stake_pool_pledge_influence",
      "fullName": "stdlib:cardano.governance.protocol_parameters.stake_pool_pledge_influence",
      "name": "stake_pool_pledge_influence",
      "signature": "pub fn stake_pool_pledge_influence(pub fn stake_pool_pledge_influence(self: ProtocolParametersUpdate, ) -> Option<Rational> {",
      "documentation": "A parameter controlling the influence of an pool owner's pledge on the rewards. Also known as _'a0'_.",
      "parameters": [],
      "returnType": "Option<Rational>",
      "line": 119,
      "raw": "pub fn stake_pool_pledge_influence(pub fn stake_pool_pledge_influence(self: ProtocolParametersUpdate, ) -> Option<Rational> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn stake_pool_pledge_influence(\n  self: ProtocolParametersUpdate,\n) -> Option<Rational> {\n  get_protocol_param(self.inner, 9, into_rational)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.monetary_expansion",
      "fullName": "stdlib:cardano.governance.protocol_parameters.monetary_expansion",
      "name": "monetary_expansion",
      "signature": "pub fn monetary_expansion(self: ProtocolParametersUpdate) -> Option<Rational> {",
      "documentation": "The monetary expansion parameter, controlling the fraction of Ada put in circulation on every epoch through the incentivies model. Also known as _'ρ'_.",
      "parameters": [
        {
          "name": "self",
          "type": "ProtocolParametersUpdate",
          "optional": false
        }
      ],
      "returnType": "Option<Rational>",
      "line": 126,
      "raw": "pub fn monetary_expansion(self: ProtocolParametersUpdate) -> Option<Rational> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn monetary_expansion(self: ProtocolParametersUpdate) -> Option<Rational> {\n  get_protocol_param(self.inner, 10, into_rational)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.treasury_expansion",
      "fullName": "stdlib:cardano.governance.protocol_parameters.treasury_expansion",
      "name": "treasury_expansion",
      "signature": "pub fn treasury_expansion(self: ProtocolParametersUpdate) -> Option<Rational> {",
      "documentation": "The parameter controlling what fraction (%) of available rewards is sent to the treasury on every epoch. Also known as _'τ'_.",
      "parameters": [
        {
          "name": "self",
          "type": "ProtocolParametersUpdate",
          "optional": false
        }
      ],
      "returnType": "Option<Rational>",
      "line": 131,
      "raw": "pub fn treasury_expansion(self: ProtocolParametersUpdate) -> Option<Rational> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn treasury_expansion(self: ProtocolParametersUpdate) -> Option<Rational> {\n  get_protocol_param(self.inner, 11, into_rational)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.min_stake_pool_cost",
      "fullName": "stdlib:cardano.governance.protocol_parameters.min_stake_pool_cost",
      "name": "min_stake_pool_cost",
      "signature": "pub fn min_stake_pool_cost(self: ProtocolParametersUpdate) -> Option<Lovelace> {",
      "documentation": "Minimum authorized constant cost that stake pools can declare when registering, expressed in Lovelace.",
      "parameters": [
        {
          "name": "self",
          "type": "ProtocolParametersUpdate",
          "optional": false
        }
      ],
      "returnType": "Option<Lovelace>",
      "line": 136,
      "raw": "pub fn min_stake_pool_cost(self: ProtocolParametersUpdate) -> Option<Lovelace> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn min_stake_pool_cost(self: ProtocolParametersUpdate) -> Option<Lovelace> {\n  get_protocol_param(self.inner, 16, into_int)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.min_utxo_deposit_coefficient",
      "fullName": "stdlib:cardano.governance.protocol_parameters.min_utxo_deposit_coefficient",
      "name": "min_utxo_deposit_coefficient",
      "signature": "pub fn min_utxo_deposit_coefficient(pub fn min_utxo_deposit_coefficient(self: ProtocolParametersUpdate, ) -> Option<Int> {",
      "documentation": "The linear coefficient that intervenes in the calculation of the minimum Ada value that any UTxO must hold. It is expressed in Lovelace per Byte, and is also known as the 'coins per utxo byte' parameter.",
      "parameters": [],
      "returnType": "Option<Int>",
      "line": 141,
      "raw": "pub fn min_utxo_deposit_coefficient(pub fn min_utxo_deposit_coefficient(self: ProtocolParametersUpdate, ) -> Option<Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn min_utxo_deposit_coefficient(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 17, into_int)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.cost_models",
      "fullName": "stdlib:cardano.governance.protocol_parameters.cost_models",
      "name": "cost_models",
      "signature": "pub fn cost_models(self: ProtocolParametersUpdate) -> Option<Data> {",
      "documentation": "The costs associated with the various operations of the Plutus Virtual Machine, which can be different for each Plutus version.",
      "parameters": [
        {
          "name": "self",
          "type": "ProtocolParametersUpdate",
          "optional": false
        }
      ],
      "returnType": "Option<Data>",
      "line": 148,
      "raw": "pub fn cost_models(self: ProtocolParametersUpdate) -> Option<Data> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn cost_models(self: ProtocolParametersUpdate) -> Option<Data> {\n  get_protocol_param(self.inner, 18, identity)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.script_execution_prices",
      "fullName": "stdlib:cardano.governance.protocol_parameters.script_execution_prices",
      "name": "script_execution_prices",
      "signature": "pub fn script_execution_prices(pub fn script_execution_prices(self: ProtocolParametersUpdate, ) -> Option<ScriptExecutionPrices> {",
      "documentation": "The price, in Lovelace per unit, of the execution units corresponding to cpu and memory usage of on-chain scripts.",
      "parameters": [],
      "returnType": "Option<ScriptExecutionPrices>",
      "line": 153,
      "raw": "pub fn script_execution_prices(pub fn script_execution_prices(self: ProtocolParametersUpdate, ) -> Option<ScriptExecutionPrices> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn script_execution_prices(\n  self: ProtocolParametersUpdate,\n) -> Option<ScriptExecutionPrices> {\n  get_protocol_param(self.inner, 19, into_script_execution_prices)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.max_transaction_execution_units",
      "fullName": "stdlib:cardano.governance.protocol_parameters.max_transaction_execution_units",
      "name": "max_transaction_execution_units",
      "signature": "pub fn max_transaction_execution_units(pub fn max_transaction_execution_units(self: ProtocolParametersUpdate, ) -> Option<ExecutionUnits> {",
      "documentation": "The maximum execution units allowed for a single transaction.",
      "parameters": [],
      "returnType": "Option<ExecutionUnits>",
      "line": 160,
      "raw": "pub fn max_transaction_execution_units(pub fn max_transaction_execution_units(self: ProtocolParametersUpdate, ) -> Option<ExecutionUnits> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn max_transaction_execution_units(\n  self: ProtocolParametersUpdate,\n) -> Option<ExecutionUnits> {\n  get_protocol_param(self.inner, 20, into_execution_units)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.max_block_execution_units",
      "fullName": "stdlib:cardano.governance.protocol_parameters.max_block_execution_units",
      "name": "max_block_execution_units",
      "signature": "pub fn max_block_execution_units(pub fn max_block_execution_units(self: ProtocolParametersUpdate, ) -> Option<ExecutionUnits> {",
      "documentation": "The maximum execution units allowed for a single block.",
      "parameters": [],
      "returnType": "Option<ExecutionUnits>",
      "line": 167,
      "raw": "pub fn max_block_execution_units(pub fn max_block_execution_units(self: ProtocolParametersUpdate, ) -> Option<ExecutionUnits> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn max_block_execution_units(\n  self: ProtocolParametersUpdate,\n) -> Option<ExecutionUnits> {\n  get_protocol_param(self.inner, 21, into_execution_units)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.max_value_size",
      "fullName": "stdlib:cardano.governance.protocol_parameters.max_value_size",
      "name": "max_value_size",
      "signature": "pub fn max_value_size(self: ProtocolParametersUpdate) -> Option<Int> {",
      "documentation": "The maximum size of a serialized value in a transaction output. This effectively limits\nthe maximum kinds of assets that can be sent in a single output. It is expressed in bytes.",
      "parameters": [
        {
          "name": "self",
          "type": "ProtocolParametersUpdate",
          "optional": false
        }
      ],
      "returnType": "Option<Int>",
      "line": 175,
      "raw": "pub fn max_value_size(self: ProtocolParametersUpdate) -> Option<Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn max_value_size(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 22, into_int)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.collateral_percentage",
      "fullName": "stdlib:cardano.governance.protocol_parameters.collateral_percentage",
      "name": "collateral_percentage",
      "signature": "pub fn collateral_percentage(self: ProtocolParametersUpdate) -> Option<Int> {",
      "documentation": "The scaling factor applied to the transaction cost for defining the minimum collateral\namount. It is expressed in percent points (so 100 = 100%).",
      "parameters": [
        {
          "name": "self",
          "type": "ProtocolParametersUpdate",
          "optional": false
        }
      ],
      "returnType": "Option<Int>",
      "line": 181,
      "raw": "pub fn collateral_percentage(self: ProtocolParametersUpdate) -> Option<Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn collateral_percentage(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 23, into_int)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.max_collateral_inputs",
      "fullName": "stdlib:cardano.governance.protocol_parameters.max_collateral_inputs",
      "name": "max_collateral_inputs",
      "signature": "pub fn max_collateral_inputs(self: ProtocolParametersUpdate) -> Option<Int> {",
      "documentation": "The maximum number of collateral inputs allowed in the transaction.",
      "parameters": [
        {
          "name": "self",
          "type": "ProtocolParametersUpdate",
          "optional": false
        }
      ],
      "returnType": "Option<Int>",
      "line": 186,
      "raw": "pub fn max_collateral_inputs(self: ProtocolParametersUpdate) -> Option<Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn max_collateral_inputs(self: ProtocolParametersUpdate) -> Option<Int> {\n  get_protocol_param(self.inner, 24, into_int)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.stake_pool_operator_voting_thresholds",
      "fullName": "stdlib:cardano.governance.protocol_parameters.stake_pool_operator_voting_thresholds",
      "name": "stake_pool_operator_voting_thresholds",
      "signature": "pub fn stake_pool_operator_voting_thresholds(pub fn stake_pool_operator_voting_thresholds(self: ProtocolParametersUpdate, ) -> Option<StakePoolOperatorVotingThresholds> {",
      "documentation": "The various governance voting thresholds pertaining to stake pool operators.",
      "parameters": [],
      "returnType": "Option<StakePoolOperatorVotingThresholds>",
      "line": 191,
      "raw": "pub fn stake_pool_operator_voting_thresholds(pub fn stake_pool_operator_voting_thresholds(self: ProtocolParametersUpdate, ) -> Option<StakePoolOperatorVotingThresholds> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn stake_pool_operator_voting_thresholds(\n  self: ProtocolParametersUpdate,\n) -> Option<StakePoolOperatorVotingThresholds> {\n  get_protocol_param(self.inner, 25, into_spo_voting_thresholds)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.delegate_representative_voting_thresholds",
      "fullName": "stdlib:cardano.governance.protocol_parameters.delegate_representative_voting_thresholds",
      "name": "delegate_representative_voting_thresholds",
      "signature": "pub fn delegate_representative_voting_thresholds(pub fn delegate_representative_voting_thresholds(self: ProtocolParametersUpdate, ) -> Option<DelegateRepresentativeVotingThresholds> {",
      "documentation": "The various governance voting thresholds pertaining to delegate representatives\n(a.k.a DReps).",
      "parameters": [],
      "returnType": "Option<DelegateRepresentativeVotingThresholds>",
      "line": 199,
      "raw": "pub fn delegate_representative_voting_thresholds(pub fn delegate_representative_voting_thresholds(self: ProtocolParametersUpdate, ) -> Option<DelegateRepresentativeVotingThresholds> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn delegate_representative_voting_thresholds(\n  self: ProtocolParametersUpdate,\n) -> Option<DelegateRepresentativeVotingThresholds> {\n  get_protocol_param(self.inner, 26, into_drep_voting_thresholds)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.min_constitutional_committee_size",
      "fullName": "stdlib:cardano.governance.protocol_parameters.min_constitutional_committee_size",
      "name": "min_constitutional_committee_size",
      "signature": "pub fn min_constitutional_committee_size(pub fn min_constitutional_committee_size(self: ProtocolParametersUpdate, ) -> Option<Int> {",
      "documentation": "The minimum number of members in the constitutional committee. Any updates of the committee\nmust leave at least this number of members.",
      "parameters": [],
      "returnType": "Option<Int>",
      "line": 207,
      "raw": "pub fn min_constitutional_committee_size(pub fn min_constitutional_committee_size(self: ProtocolParametersUpdate, ) -> Option<Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn min_constitutional_committee_size(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 27, into_int)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.max_constitutional_committee_mandate",
      "fullName": "stdlib:cardano.governance.protocol_parameters.max_constitutional_committee_mandate",
      "name": "max_constitutional_committee_mandate",
      "signature": "pub fn max_constitutional_committee_mandate(pub fn max_constitutional_committee_mandate(self: ProtocolParametersUpdate, ) -> Option<Int> {",
      "documentation": "The maximum length of a constitutional committee member, expressed in number of epochs.",
      "parameters": [],
      "returnType": "Option<Int>",
      "line": 214,
      "raw": "pub fn max_constitutional_committee_mandate(pub fn max_constitutional_committee_mandate(self: ProtocolParametersUpdate, ) -> Option<Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn max_constitutional_committee_mandate(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 28, into_int)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.governance_proposal_lifetime",
      "fullName": "stdlib:cardano.governance.protocol_parameters.governance_proposal_lifetime",
      "name": "governance_proposal_lifetime",
      "signature": "pub fn governance_proposal_lifetime(pub fn governance_proposal_lifetime(self: ProtocolParametersUpdate, ) -> Option<Int> {",
      "documentation": "The lifetime of any governance proposal. An action that hasn't been approved beyond that\nperiod is considered inactive and discarded. It is expressed in number of epochs.",
      "parameters": [],
      "returnType": "Option<Int>",
      "line": 222,
      "raw": "pub fn governance_proposal_lifetime(pub fn governance_proposal_lifetime(self: ProtocolParametersUpdate, ) -> Option<Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn governance_proposal_lifetime(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 29, into_int)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.governance_proposal_deposit",
      "fullName": "stdlib:cardano.governance.protocol_parameters.governance_proposal_deposit",
      "name": "governance_proposal_deposit",
      "signature": "pub fn governance_proposal_deposit(pub fn governance_proposal_deposit(self: ProtocolParametersUpdate, ) -> Option<Lovelace> {",
      "documentation": "The required deposit amount for governance proposal procedures, expressed in Lovelace.",
      "parameters": [],
      "returnType": "Option<Lovelace>",
      "line": 229,
      "raw": "pub fn governance_proposal_deposit(pub fn governance_proposal_deposit(self: ProtocolParametersUpdate, ) -> Option<Lovelace> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn governance_proposal_deposit(\n  self: ProtocolParametersUpdate,\n) -> Option<Lovelace> {\n  get_protocol_param(self.inner, 30, into_int)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.delegate_representative_deposit",
      "fullName": "stdlib:cardano.governance.protocol_parameters.delegate_representative_deposit",
      "name": "delegate_representative_deposit",
      "signature": "pub fn delegate_representative_deposit(pub fn delegate_representative_deposit(self: ProtocolParametersUpdate, ) -> Option<Lovelace> {",
      "documentation": "The required deposit amount when registering as a delegate representative, expressed in\nLovelace.",
      "parameters": [],
      "returnType": "Option<Lovelace>",
      "line": 237,
      "raw": "pub fn delegate_representative_deposit(pub fn delegate_representative_deposit(self: ProtocolParametersUpdate, ) -> Option<Lovelace> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn delegate_representative_deposit(\n  self: ProtocolParametersUpdate,\n) -> Option<Lovelace> {\n  get_protocol_param(self.inner, 31, into_int)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.delegate_representative_max_idle_time",
      "fullName": "stdlib:cardano.governance.protocol_parameters.delegate_representative_max_idle_time",
      "name": "delegate_representative_max_idle_time",
      "signature": "pub fn delegate_representative_max_idle_time(pub fn delegate_representative_max_idle_time(self: ProtocolParametersUpdate, ) -> Option<Int> {",
      "documentation": "The maximum number of epochs that a delegate representative can stay inactive (i.e. no\nvoting) without becoming _inactive_ and removed from thresholds calculations.",
      "parameters": [],
      "returnType": "Option<Int>",
      "line": 245,
      "raw": "pub fn delegate_representative_max_idle_time(pub fn delegate_representative_max_idle_time(self: ProtocolParametersUpdate, ) -> Option<Int> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn delegate_representative_max_idle_time(\n  self: ProtocolParametersUpdate,\n) -> Option<Int> {\n  get_protocol_param(self.inner, 32, into_int)\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.reference_scripts_tier_fee_initial_factor",
      "fullName": "stdlib:cardano.governance.protocol_parameters.reference_scripts_tier_fee_initial_factor",
      "name": "reference_scripts_tier_fee_initial_factor",
      "signature": "pub fn reference_scripts_tier_fee_initial_factor(pub fn reference_scripts_tier_fee_initial_factor(self: ProtocolParametersUpdate, ) -> Option<Rational> {",
      "documentation": "The base tier fee coefficient for reference scripts. Reference scripts gets increasingly\nmore expensives every ~24KB, the base coefficient is a multiplicating factor which grows\nexponentially with each tier.",
      "parameters": [],
      "returnType": "Option<Rational>",
      "line": 254,
      "raw": "pub fn reference_scripts_tier_fee_initial_factor(pub fn reference_scripts_tier_fee_initial_factor(self: ProtocolParametersUpdate, ) -> Option<Rational> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn reference_scripts_tier_fee_initial_factor(\n  self: ProtocolParametersUpdate,\n) -> Option<Rational> {\n  get_protocol_param(self.inner, 33, into_rational)\n}"
    },
    {
      "key": "stdlib:cardano.governance.voter.compare",
      "fullName": "stdlib:cardano.governance.voter.compare",
      "name": "compare",
      "signature": "pub fn compare(left: Voter, right: Voter) -> Ordering {",
      "parameters": [
        {
          "name": "left",
          "type": "Voter",
          "optional": false
        },
        {
          "name": "right",
          "type": "Voter",
          "optional": false
        }
      ],
      "returnType": "Ordering",
      "line": 8,
      "raw": "pub fn compare(left: Voter, right: Voter) -> Ordering {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn compare(left: Voter, right: Voter) -> Ordering {\n  when left is {\n    ConstitutionalCommitteeMember(left) ->\n      when right is {\n        ConstitutionalCommitteeMember(right) -> credential.compare(left, right)\n        _ -> Less\n      }\n    DelegateRepresentative(left) ->\n      when right is {\n        DelegateRepresentative(right) -> credential.compare(left, right)\n        ConstitutionalCommitteeMember(_) -> Greater\n        _ -> Less\n      }\n    StakePool(left) ->\n      when right is {\n        StakePool(right) -> bytearray.compare(left, right)\n        _ -> Greater\n      }\n  }\n}",
      "tests": [
        "test compare_matrix() {\n  let cc0 = ConstitutionalCommitteeMember(Script(\"0\"))\n  let cc1 = ConstitutionalCommitteeMember(Script(\"1\"))\n\n  let drep0 = DelegateRepresentative(Script(\"0\"))\n  let drep1 = DelegateRepresentative(Script(\"1\"))\n\n  let spo0 = StakePool(\"0\")\n  let spo1 = StakePool(\"1\")\n\n  and {\n    (compare(cc0, cc0) == Equal)?,\n    (compare(cc0, cc1) == Less)?,\n    (compare(cc1, cc0) == Greater)?,\n    (compare(drep0, drep0) == Equal)?,\n    (compare(drep0, drep1) == Less)?,\n    (compare(drep1, drep0) == Greater)?,\n    (compare(spo0, spo0) == Equal)?,\n    (compare(spo0, spo1) == Less)?,\n    (compare(spo1, spo0) == Greater)?,\n    (compare(cc0, drep0) == Less)?,\n    (compare(cc0, drep1) == Less)?,\n    (compare(cc0, spo0) == Less)?,\n    (compare(cc0, spo1) == Less)?,\n    (compare(drep0, cc0) == Greater)?,\n    (compare(drep0, cc1) == Greater)?,\n    (compare(drep0, spo0) == Less)?,\n    (compare(drep0, spo1) == Less)?,\n    (compare(spo0, cc0) == Greater)?,\n    (compare(spo0, cc1) == Greater)?,\n    (compare(spo0, drep0) == Greater)?,\n    (compare(spo0, drep1) == Greater)?,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:cardano.transaction.output_reference.compare",
      "fullName": "stdlib:cardano.transaction.output_reference.compare",
      "name": "compare",
      "signature": "pub fn compare(left: OutputReference, right: OutputReference) -> Ordering {",
      "parameters": [
        {
          "name": "left",
          "type": "OutputReference",
          "optional": false
        },
        {
          "name": "right",
          "type": "OutputReference",
          "optional": false
        }
      ],
      "returnType": "Ordering",
      "line": 5,
      "raw": "pub fn compare(left: OutputReference, right: OutputReference) -> Ordering {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn compare(left: OutputReference, right: OutputReference) -> Ordering {\n  when bytearray.compare(left.transaction_id, right.transaction_id) is {\n    Equal -> int.compare(left.output_index, right.output_index)\n    ordering -> ordering\n  }\n}",
      "tests": [
        "test compare_matrix() {\n  and {\n    (compare(OutputReference(\"\", 0), OutputReference(\"\", 0)) == Equal)?,\n    (compare(OutputReference(\"00\", 42), OutputReference(\"00\", 42)) == Equal)?,\n    (compare(OutputReference(\"00\", 0), OutputReference(\"01\", 0)) == Less)?,\n    (compare(OutputReference(\"01\", 0), OutputReference(\"00\", 0)) == Greater)?,\n    (compare(OutputReference(\"00\", 42), OutputReference(\"01\", 14)) == Less)?,\n    (compare(OutputReference(\"01\", 14), OutputReference(\"00\", 42)) == Greater)?,\n    (compare(OutputReference(\"\", 42), OutputReference(\"\", 14)) == Greater)?,\n    (compare(OutputReference(\"\", 14), OutputReference(\"\", 42)) == Less)?,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:cardano.transaction.script_purpose.compare",
      "fullName": "stdlib:cardano.transaction.script_purpose.compare",
      "name": "compare",
      "signature": "pub fn compare(left: ScriptPurpose, right: ScriptPurpose) -> Ordering {",
      "parameters": [
        {
          "name": "left",
          "type": "ScriptPurpose",
          "optional": false
        },
        {
          "name": "right",
          "type": "ScriptPurpose",
          "optional": false
        }
      ],
      "returnType": "Ordering",
      "line": 13,
      "raw": "pub fn compare(left: ScriptPurpose, right: ScriptPurpose) -> Ordering {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn compare(left: ScriptPurpose, right: ScriptPurpose) -> Ordering {\n  when left is {\n    Mint(left) ->\n      when right is {\n        Mint(right) -> bytearray.compare(left, right)\n        _ -> Less\n      }\n\n    Spend(left) ->\n      when right is {\n        Spend(right) -> output_reference.compare(left, right)\n        Mint(_) -> Greater\n        _ -> Less\n      }\n\n    Withdraw(left) ->\n      when right is {\n        Withdraw(right) -> credential.compare(left, right)\n        Spend(_) | Mint(_) -> Greater\n        _ -> Less\n      }\n\n    Publish { at: left, .. } ->\n      when right is {\n        Publish { at: right, .. } -> int.compare(left, right)\n        Spend(_) | Mint(_) | Withdraw(_) -> Greater\n        _ -> Less\n      }\n\n    Vote(left) ->\n      when right is {\n        Vote(right) -> voter.compare(left, right)\n        Propose { .. } -> Less\n        _ -> Greater\n      }\n\n    Propose { at: left, .. } ->\n      when right is {\n        Propose { at: right, .. } -> int.compare(left, right)\n        _ -> Greater\n      }\n  }\n}",
      "tests": [
        "test compare_matrix() {\n  let mint0 = Mint(\"0\")\n  let mint1 = Mint(\"1\")\n\n  let spend0 = Spend(OutputReference(\"\", 0))\n  let spend1 = Spend(OutputReference(\"\", 1))\n\n  let withdraw0 = Withdraw(VerificationKey(\"0\"))\n  let withdraw1 = Withdraw(VerificationKey(\"1\"))\n\n  let publish0 = Publish(0, RegisterCredential(Script(\"\"), Never))\n  let publish1 = Publish(1, RegisterCredential(Script(\"\"), Never))\n\n  let vote0 = Vote(StakePool(\"0\"))\n  let vote1 = Vote(StakePool(\"1\"))\n\n  let propose0 = Propose(0, ProposalProcedure(0, Script(\"\"), NicePoll))\n  let propose1 = Propose(1, ProposalProcedure(0, Script(\"\"), NicePoll))\n\n  and {\n    (compare(mint0, mint0) == Equal)?,\n    (compare(mint0, mint1) == Less)?,\n    (compare(mint1, mint0) == Greater)?,\n    (compare(mint0, spend0) == Less)?,\n    (compare(mint0, withdraw0) == Less)?,\n    (compare(mint0, publish0) == Less)?,\n    (compare(mint0, vote0) == Less)?,\n    (compare(mint0, propose0) == Less)?,\n    (compare(spend0, spend0) == Equal)?,\n    (compare(spend0, spend1) == Less)?,\n    (compare(spend1, spend0) == Greater)?,\n    (compare(spend0, mint0) == Greater)?,\n    (compare(spend0, withdraw0) == Less)?,\n    (compare(spend0, publish0) == Less)?,\n    (compare(spend0, vote0) == Less)?,\n    (compare(spend0, propose0) == Less)?,\n    (compare(withdraw0, withdraw0) == Equal)?,\n    (compare(withdraw0, withdraw1) == Less)?,\n    (compare(withdraw1, withdraw0) == Greater)?,\n    (compare(withdraw0, mint0) == Greater)?,\n    (compare(withdraw0, spend0) == Greater)?,\n    (compare(withdraw0, publish0) == Less)?,\n    (compare(withdraw0, vote0) == Less)?,\n    (compare(withdraw0, propose0) == Less)?,\n    (compare(publish0, publish0) == Equal)?,\n    (compare(publish0, publish1) == Less)?,\n    (compare(publish1, publish0) == Greater)?,\n    (compare(publish0, mint0) == Greater)?,\n    (compare(publish0, spend0) == Greater)?,\n    (compare(publish0, withdraw0) == Greater)?,\n    (compare(publish0, vote0) == Less)?,\n    (compare(publish0, propose0) == Less)?,\n    (compare(vote0, vote0) == Equal)?,\n    (compare(vote0, vote1) == Less)?,\n    (compare(vote1, vote0) == Greater)?,\n    (compare(vote0, mint0) == Greater)?,\n    (compare(vote0, spend0) == Greater)?,\n    (compare(vote0, withdraw0) == Greater)?,\n    (compare(vote0, publish0) == Greater)?,\n    (compare(vote0, propose0) == Less)?,\n    (compare(propose0, propose0) == Equal)?,\n    (compare(propose0, propose1) == Less)?,\n    (compare(propose1, propose0) == Greater)?,\n    (compare(propose0, mint0) == Greater)?,\n    (compare(propose0, spend0) == Greater)?,\n    (compare(propose0, withdraw0) == Greater)?,\n    (compare(propose0, publish0) == Greater)?,\n    (compare(propose0, vote0) == Greater)?,\n  }\n}"
      ]
    },
    {
      "key": "stdlib:cardano.transaction.find_input",
      "fullName": "stdlib:cardano.transaction.find_input",
      "name": "find_input",
      "signature": "pub fn find_input(pub fn find_input(inputs: List<Input>, output_reference: OutputReference, ) -> Option<Input> {",
      "documentation": "Find an input by its [`OutputReference`](#OutputReference). This is typically used in\ncombination with the `Spend` [`ScriptPurpose`](#ScriptPurpose) to find a script's own\ninput.\n\n```aiken\nvalidator {\nspend(datum, redeemer, my_output_reference, self) {\nexpect Some(input) =\nself.inputs\n|> transaction.find_input(my_output_reference)\n}\n}\n```",
      "parameters": [],
      "returnType": "Option<Input>",
      "line": 136,
      "raw": "pub fn find_input(pub fn find_input(inputs: List<Input>, output_reference: OutputReference, ) -> Option<Input> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn find_input(\n  inputs: List<Input>,\n  output_reference: OutputReference,\n) -> Option<Input> {\n  inputs\n    |> list.find(fn(input) { input.output_reference == output_reference })\n}"
    },
    {
      "key": "stdlib:cardano.transaction.find_datum",
      "fullName": "stdlib:cardano.transaction.find_datum",
      "name": "find_datum",
      "signature": "pub fn find_datum(pub fn find_datum(outputs: List<Output>, datums: Dict<DataHash, Data>, datum_hash: DataHash, ) -> Option<Data> {",
      "documentation": "Find a [`Datum`](#Datum) by its hash, if present. The function looks first for\ndatums in the witness set, and then for inline datums if it doesn't find any in\nwitnesses.",
      "parameters": [],
      "returnType": "Option<Data>",
      "line": 147,
      "raw": "pub fn find_datum(pub fn find_datum(outputs: List<Output>, datums: Dict<DataHash, Data>, datum_hash: DataHash, ) -> Option<Data> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn find_datum(\n  outputs: List<Output>,\n  datums: Dict<DataHash, Data>,\n  datum_hash: DataHash,\n) -> Option<Data> {\n  datums\n    |> dict.get(datum_hash)\n    |> option.or_try(\n        fn() {\n          outputs\n            |> list.filter_map(\n                fn(output) {\n                  when output.datum is {\n                    InlineDatum(data) ->\n                      if blake2b_256(builtin.serialise_data(data)) == datum_hash {\n                        Some(data)\n                      } else {\n                        None\n                      }\n                    _ -> None\n                  }\n                },\n              )\n            |> list.head\n        },\n      )\n}"
    },
    {
      "key": "stdlib:cardano.transaction.find_script_outputs",
      "fullName": "stdlib:cardano.transaction.find_script_outputs",
      "name": "find_script_outputs",
      "signature": "pub fn find_script_outputs(pub fn find_script_outputs(outputs: List<Output>, script_hash: ScriptHash, ) -> List<Output> {",
      "documentation": "Find all outputs that are paying into the given script hash, if any. This is useful for\ncontracts running over multiple transactions.",
      "parameters": [],
      "returnType": "List<Output>",
      "line": 177,
      "raw": "pub fn find_script_outputs(pub fn find_script_outputs(outputs: List<Output>, script_hash: ScriptHash, ) -> List<Output> {",
      "isPublic": true,
      "source": "stdlib",
      "implementation": "pub fn find_script_outputs(\n  outputs: List<Output>,\n  script_hash: ScriptHash,\n) -> List<Output> {\n  outputs\n    |> list.filter(\n        fn(output) {\n          when output.address.payment_credential is {\n            Script(addr_script_hash) -> script_hash == addr_script_hash\n            VerificationKey(_) -> False\n          }\n        },\n      )\n}"
    },
    {
      "key": "prelude:aiken.builtin.add_integer",
      "fullName": "prelude:aiken.builtin.add_integer",
      "name": "add_integer",
      "signature": "pub fn add_integer(left: Int, right: Int) -> Int {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nAdds two integers (+).",
      "parameters": [
        {
          "name": "left",
          "type": "Int",
          "optional": false
        },
        {
          "name": "right",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 13,
      "raw": "pub fn add_integer(left: Int, right: Int) -> Int {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn add_integer(left: Int, right: Int) -> Int {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.subtract_integer",
      "fullName": "prelude:aiken.builtin.subtract_integer",
      "name": "subtract_integer",
      "signature": "pub fn subtract_integer(left: Int, right: Int) -> Int {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nSubtract two integers (-).",
      "parameters": [
        {
          "name": "left",
          "type": "Int",
          "optional": false
        },
        {
          "name": "right",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 21,
      "raw": "pub fn subtract_integer(left: Int, right: Int) -> Int {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn subtract_integer(left: Int, right: Int) -> Int {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.multiply_integer",
      "fullName": "prelude:aiken.builtin.multiply_integer",
      "name": "multiply_integer",
      "signature": "pub fn multiply_integer(left: Int, right: Int) -> Int {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nMultiple two integers (*).",
      "parameters": [
        {
          "name": "left",
          "type": "Int",
          "optional": false
        },
        {
          "name": "right",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 29,
      "raw": "pub fn multiply_integer(left: Int, right: Int) -> Int {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn multiply_integer(left: Int, right: Int) -> Int {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.divide_integer",
      "fullName": "prelude:aiken.builtin.divide_integer",
      "name": "divide_integer",
      "signature": "pub fn divide_integer(numerator: Int, denominator: Int) -> Int {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInteger division truncated towards negative infinity (/).",
      "parameters": [
        {
          "name": "numerator",
          "type": "Int",
          "optional": false
        },
        {
          "name": "denominator",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 37,
      "raw": "pub fn divide_integer(numerator: Int, denominator: Int) -> Int {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn divide_integer(numerator: Int, denominator: Int) -> Int {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.quotient_integer",
      "fullName": "prelude:aiken.builtin.quotient_integer",
      "name": "quotient_integer",
      "signature": "pub fn quotient_integer(numerator: Int, denominator: Int) -> Int {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInteger division truncated towards zero.",
      "parameters": [
        {
          "name": "numerator",
          "type": "Int",
          "optional": false
        },
        {
          "name": "denominator",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 45,
      "raw": "pub fn quotient_integer(numerator: Int, denominator: Int) -> Int {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn quotient_integer(numerator: Int, denominator: Int) -> Int {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.remainder_integer",
      "fullName": "prelude:aiken.builtin.remainder_integer",
      "name": "remainder_integer",
      "signature": "pub fn remainder_integer(numerator: Int, denominator: Int) -> Int {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInteger remainder, satisfying\n\n```aiken\nquotient_integer(x, y) * y + remainder_integer(x, y) == x\n```",
      "parameters": [
        {
          "name": "numerator",
          "type": "Int",
          "optional": false
        },
        {
          "name": "denominator",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 57,
      "raw": "pub fn remainder_integer(numerator: Int, denominator: Int) -> Int {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn remainder_integer(numerator: Int, denominator: Int) -> Int {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.mod_integer",
      "fullName": "prelude:aiken.builtin.mod_integer",
      "name": "mod_integer",
      "signature": "pub fn mod_integer(numerator: Int, denominator: Int) -> Int {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInteger modulus (%), satisfying\n\n```aiken\ndivide_integer(x, y) * y + mod_integer(x, y) == x\n```",
      "parameters": [
        {
          "name": "numerator",
          "type": "Int",
          "optional": false
        },
        {
          "name": "denominator",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 69,
      "raw": "pub fn mod_integer(numerator: Int, denominator: Int) -> Int {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn mod_integer(numerator: Int, denominator: Int) -> Int {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.equals_integer",
      "fullName": "prelude:aiken.builtin.equals_integer",
      "name": "equals_integer",
      "signature": "pub fn equals_integer(left: Int, right: Int) -> Bool {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInteger equality.",
      "parameters": [
        {
          "name": "left",
          "type": "Int",
          "optional": false
        },
        {
          "name": "right",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 77,
      "raw": "pub fn equals_integer(left: Int, right: Int) -> Bool {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn equals_integer(left: Int, right: Int) -> Bool {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.less_than_integer",
      "fullName": "prelude:aiken.builtin.less_than_integer",
      "name": "less_than_integer",
      "signature": "pub fn less_than_integer(left: Int, right: Int) -> Bool {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInteger strict inequality.",
      "parameters": [
        {
          "name": "left",
          "type": "Int",
          "optional": false
        },
        {
          "name": "right",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 85,
      "raw": "pub fn less_than_integer(left: Int, right: Int) -> Bool {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn less_than_integer(left: Int, right: Int) -> Bool {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.less_than_equals_integer",
      "fullName": "prelude:aiken.builtin.less_than_equals_integer",
      "name": "less_than_equals_integer",
      "signature": "pub fn less_than_equals_integer(left: Int, right: Int) -> Bool {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInteger inequality.",
      "parameters": [
        {
          "name": "left",
          "type": "Int",
          "optional": false
        },
        {
          "name": "right",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 93,
      "raw": "pub fn less_than_equals_integer(left: Int, right: Int) -> Bool {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn less_than_equals_integer(left: Int, right: Int) -> Bool {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.integer_to_bytearray",
      "fullName": "prelude:aiken.builtin.integer_to_bytearray",
      "name": "integer_to_bytearray",
      "signature": "pub fn integer_to_bytearray(pub fn integer_to_bytearray(endianness: Bool, size: Int, value: Int, ) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nConvert an integer value into a [ByteArray](../aiken.html#ByteArray).\n\n- The first arguments / specifies the endianness:\n\nboolean value | endianness\n----          | ----\nTrue          | Big endian\nFalse         | Little endian\n\n- The second argument indicates the target `size` (in bytes) of the final [ByteArray](../aiken.html#ByteArray). This allows to allocate a specific number of bytes in advance. The function fails if the given value cannot fit in the requested size or if the `value` is negative. However, a size of 0 will yield a [ByteArray](../aiken.html#ByteArray) that is precisely as large as necessary to fit the `value`.",
      "parameters": [],
      "returnType": "ByteArray",
      "line": 110,
      "raw": "pub fn integer_to_bytearray(pub fn integer_to_bytearray(endianness: Bool, size: Int, value: Int, ) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn integer_to_bytearray(\n  endianness: Bool,\n  size: Int,\n  value: Int,\n) -> ByteArray {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.append_bytearray",
      "fullName": "prelude:aiken.builtin.append_bytearray",
      "name": "append_bytearray",
      "signature": "pub fn append_bytearray(left: ByteArray, right: ByteArray) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConcatenate two bytearrays together.",
      "parameters": [
        {
          "name": "left",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "right",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 126,
      "raw": "pub fn append_bytearray(left: ByteArray, right: ByteArray) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn append_bytearray(left: ByteArray, right: ByteArray) -> ByteArray {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.cons_bytearray",
      "fullName": "prelude:aiken.builtin.cons_bytearray",
      "name": "cons_bytearray",
      "signature": "pub fn cons_bytearray(byte: Int, bytes: ByteArray) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nPush a byte in front of a bytearray.",
      "parameters": [
        {
          "name": "byte",
          "type": "Int",
          "optional": false
        },
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 134,
      "raw": "pub fn cons_bytearray(byte: Int, bytes: ByteArray) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn cons_bytearray(byte: Int, bytes: ByteArray) -> ByteArray {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.replicate_byte",
      "fullName": "prelude:aiken.builtin.replicate_byte",
      "name": "replicate_byte",
      "signature": "pub fn replicate_byte(length: Int, byte: Int) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nConstruct a `ByteArray` from the repetition of the same byte a specific number of times. Fails if the byte is out-of-bound or if the length is negative.",
      "parameters": [
        {
          "name": "length",
          "type": "Int",
          "optional": false
        },
        {
          "name": "byte",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 142,
      "raw": "pub fn replicate_byte(length: Int, byte: Int) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn replicate_byte(length: Int, byte: Int) -> ByteArray {\n  todo\n}"
    },
    {
      "key": "prelude:aiken.builtin.count_set_bits",
      "fullName": "prelude:aiken.builtin.count_set_bits",
      "name": "count_set_bits",
      "signature": "pub fn count_set_bits(self: ByteArray) -> Int {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nCount the number of bits set in the given `ByteArray`.",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 152,
      "raw": "pub fn count_set_bits(self: ByteArray) -> Int {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn count_set_bits(self: ByteArray) -> Int {\n  todo\n}"
    },
    {
      "key": "prelude:aiken.builtin.find_first_set_bit",
      "fullName": "prelude:aiken.builtin.find_first_set_bit",
      "name": "find_first_set_bit",
      "signature": "pub fn find_first_set_bit(self: ByteArray) -> Int {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nFind the index of the first bit set. Note that bits are indexed _from the end_ (see also [`read_bit`](#read_bit) for more details).",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 160,
      "raw": "pub fn find_first_set_bit(self: ByteArray) -> Int {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn find_first_set_bit(self: ByteArray) -> Int {\n  todo\n}"
    },
    {
      "key": "prelude:aiken.builtin.index_bytearray",
      "fullName": "prelude:aiken.builtin.index_bytearray",
      "name": "index_bytearray",
      "signature": "pub fn index_bytearray(bytes: ByteArray, index: Int) -> Int {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nAccess the byte at the given index in the bytearray.",
      "parameters": [
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "index",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 168,
      "raw": "pub fn index_bytearray(bytes: ByteArray, index: Int) -> Int {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn index_bytearray(bytes: ByteArray, index: Int) -> Int {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.length_of_bytearray",
      "fullName": "prelude:aiken.builtin.length_of_bytearray",
      "name": "length_of_bytearray",
      "signature": "pub fn length_of_bytearray(bytes: ByteArray) -> Int {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nNumber of bytes in a bytearray.",
      "parameters": [
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 176,
      "raw": "pub fn length_of_bytearray(bytes: ByteArray) -> Int {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn length_of_bytearray(bytes: ByteArray) -> Int {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.read_bit",
      "fullName": "prelude:aiken.builtin.read_bit",
      "name": "read_bit",
      "signature": "pub fn read_bit(self: ByteArray, index: Int) -> Bool {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nRead a particular bit (`True` if set) at the given index. Fails if the\nindex is out-of-bounds. Note that the index reads _from the end_. For\nexample, consider the byte `0xF4` and an index `i`:\n\ni=7 | i=6 | i=5 | i=4 | i=3 | i=2 | i=1 | i=0\n--- | --- | --- | --- | --- | --- | --- | ---\n1  |  1  |  1  |  1  |  0  |  1  |  0  |  0\n\nSo, we have:\n\n```aiken\nread_bit(#[0xF4], 0) == False\nread_bit(#[0xF4], 1) == False\nread_bit(#[0xF4], 2) == True\nread_bit(#[0xF4], 3) == False\nread_bit(#[0xF4], 4) == True\nread_bit(#[0xF4], 5) == True\nread_bit(#[0xF4], 6) == True\nread_bit(#[0xF4], 7) == True\nread_bit(#[0xF4, 0xF4], 8) == False\n```",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "index",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 204,
      "raw": "pub fn read_bit(self: ByteArray, index: Int) -> Bool {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn read_bit(self: ByteArray, index: Int) -> Bool {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.slice_bytearray",
      "fullName": "prelude:aiken.builtin.slice_bytearray",
      "name": "slice_bytearray",
      "signature": "pub fn slice_bytearray(start: Int, len: Int, bytes: ByteArray) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nExtract a sub-array from a bytearray given starting and length of the sub-array.",
      "parameters": [
        {
          "name": "start",
          "type": "Int",
          "optional": false
        },
        {
          "name": "len",
          "type": "Int",
          "optional": false
        },
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 212,
      "raw": "pub fn slice_bytearray(start: Int, len: Int, bytes: ByteArray) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn slice_bytearray(start: Int, len: Int, bytes: ByteArray) -> ByteArray {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.write_bits",
      "fullName": "prelude:aiken.builtin.write_bits",
      "name": "write_bits",
      "signature": "pub fn write_bits(self: ByteArray, indices: List<Int>, value: Bool) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nWrite a bit each index in the list of indices. Writes 1 if value is True and 0 if value is False.\nFails if the index is out-of-bounds. Note that the index reads _from the end_.\nFor example, consider the byte `0xF4` and an index `i`:\n\ni=7 | i=6 | i=5 | i=4 | i=3 | i=2 | i=1 | i=0\n--- | --- | --- | --- | --- | --- | --- | ---\n1  |  1  |  1  |  1  |  0  |  1  |  0  |  0\n\nSo, we have:\n\n```aiken\nwrite_bits(#[0xF4], [0, 1], True) == #[0xF7]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "indices",
          "type": "List<Int>",
          "optional": false
        },
        {
          "name": "value",
          "type": "Bool",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 232,
      "raw": "pub fn write_bits(self: ByteArray, indices: List<Int>, value: Bool) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn write_bits(self: ByteArray, indices: List<Int>, value: Bool) -> ByteArray {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.equals_bytearray",
      "fullName": "prelude:aiken.builtin.equals_bytearray",
      "name": "equals_bytearray",
      "signature": "pub fn equals_bytearray(left: ByteArray, right: ByteArray) -> Bool {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nBytearray equality.",
      "parameters": [
        {
          "name": "left",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "right",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 242,
      "raw": "pub fn equals_bytearray(left: ByteArray, right: ByteArray) -> Bool {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn equals_bytearray(left: ByteArray, right: ByteArray) -> Bool {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.less_than_bytearray",
      "fullName": "prelude:aiken.builtin.less_than_bytearray",
      "name": "less_than_bytearray",
      "signature": "pub fn less_than_bytearray(left: ByteArray, right: ByteArray) -> Bool {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nBytearray strict inequality.",
      "parameters": [
        {
          "name": "left",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "right",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 250,
      "raw": "pub fn less_than_bytearray(left: ByteArray, right: ByteArray) -> Bool {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn less_than_bytearray(left: ByteArray, right: ByteArray) -> Bool {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.less_than_equals_bytearray",
      "fullName": "prelude:aiken.builtin.less_than_equals_bytearray",
      "name": "less_than_equals_bytearray",
      "signature": "pub fn less_than_equals_bytearray(left: ByteArray, right: ByteArray) -> Bool {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nBytearray inequality.",
      "parameters": [
        {
          "name": "left",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "right",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 258,
      "raw": "pub fn less_than_equals_bytearray(left: ByteArray, right: ByteArray) -> Bool {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn less_than_equals_bytearray(left: ByteArray, right: ByteArray) -> Bool {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.and_bytearray",
      "fullName": "prelude:aiken.builtin.and_bytearray",
      "name": "and_bytearray",
      "signature": "pub fn and_bytearray(pub fn and_bytearray(padding: Bool, left: ByteArray, right: ByteArray, ) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nLogical AND applied to two bytearrays. The first argument indicates whether padding semantics should be used. If this argument is `False`, truncation semantics are used instead.\n\n> [!NOTE]\n> All bitwise operations are processed in little-endian bit order. For\n> example, ANDing `#\"F0\"` with `#\"0FFF\"` will yield a `#\"00\"` (or `#\"00FF\"`\n> if `padding` is `True`).",
      "parameters": [],
      "returnType": "ByteArray",
      "line": 273,
      "raw": "pub fn and_bytearray(pub fn and_bytearray(padding: Bool, left: ByteArray, right: ByteArray, ) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn and_bytearray(\n  padding: Bool,\n  left: ByteArray,\n  right: ByteArray,\n) -> ByteArray {\n  todo\n}"
    },
    {
      "key": "prelude:aiken.builtin.or_bytearray",
      "fullName": "prelude:aiken.builtin.or_bytearray",
      "name": "or_bytearray",
      "signature": "pub fn or_bytearray(pub fn or_bytearray(padding: Bool, left: ByteArray, right: ByteArray, ) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nLogical OR applied to two bytearrays. The first argument indicates whether padding semantics should be used. If this argument is `False`, truncation semantics are used instead.\n\n> [!NOTE]\n> All bitwise operations are processed in little-endian bit order. For\n> example, ORing `#\"FF\"` with `#\"00FF\"` will yield a `#\"FF\"` (or `#\"FFFF\"`\n> if `padding` is `True`).",
      "parameters": [],
      "returnType": "ByteArray",
      "line": 290,
      "raw": "pub fn or_bytearray(pub fn or_bytearray(padding: Bool, left: ByteArray, right: ByteArray, ) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn or_bytearray(\n  padding: Bool,\n  left: ByteArray,\n  right: ByteArray,\n) -> ByteArray {\n  todo\n}"
    },
    {
      "key": "prelude:aiken.builtin.xor_bytearray",
      "fullName": "prelude:aiken.builtin.xor_bytearray",
      "name": "xor_bytearray",
      "signature": "pub fn xor_bytearray(pub fn xor_bytearray(padding: Bool, left: ByteArray, right: ByteArray, ) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nLogical XOR applied to two bytearrays. The first argument indicates whether padding semantics should be used. If this argument is `False`, truncation semantics are used instead.\n\n> [!NOTE]\n> All bitwise operations are processed in little-endian bit order. For\n> example, XORing `#\"0F\"` with `#\"0000\"` will yield a `#\"0F\"` (or `#\"0F00\"`\n> if `padding` is `True`).",
      "parameters": [],
      "returnType": "ByteArray",
      "line": 307,
      "raw": "pub fn xor_bytearray(pub fn xor_bytearray(padding: Bool, left: ByteArray, right: ByteArray, ) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn xor_bytearray(\n  padding: Bool,\n  left: ByteArray,\n  right: ByteArray,\n) -> ByteArray {\n  todo\n}"
    },
    {
      "key": "prelude:aiken.builtin.complement_bytearray",
      "fullName": "prelude:aiken.builtin.complement_bytearray",
      "name": "complement_bytearray",
      "signature": "pub fn complement_bytearray(self: ByteArray) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nLogical bitwise complement of the bytearray (set becomes unset, and unset becomes set).",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 319,
      "raw": "pub fn complement_bytearray(self: ByteArray) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn complement_bytearray(self: ByteArray) -> ByteArray {\n  todo\n}"
    },
    {
      "key": "prelude:aiken.builtin.rotate_bytearray",
      "fullName": "prelude:aiken.builtin.rotate_bytearray",
      "name": "rotate_bytearray",
      "signature": "pub fn rotate_bytearray(self: ByteArray, offset: Int) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nLike [`shift_bytearray`](#shift_bytearray) but instead of introducing zeroes in holes, use the bits that are dropped from either ends.\n\n```aiken\nrotate_bytearray(#[0xEB, 0xFC], 5) == #[0x7F, 0x9D]\nrotate_bytearray(#[0xEB, 0xFC], -8) == #[0xFC, 0xEB]\nrotate_bytearray(#[0xEB, 0xFC], 8) == #[0xFC, 0xEB]\n```",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "offset",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 335,
      "raw": "pub fn rotate_bytearray(self: ByteArray, offset: Int) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn rotate_bytearray(self: ByteArray, offset: Int) -> ByteArray {\n  todo\n}"
    },
    {
      "key": "prelude:aiken.builtin.shift_bytearray",
      "fullName": "prelude:aiken.builtin.shift_bytearray",
      "name": "shift_bytearray",
      "signature": "pub fn shift_bytearray(self: ByteArray, offset: Int) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nShift bits in a `ByteArray` by the given offset, replacing holes with zeroes. The offset can be positive (left-shift) or negative (right-shift).\n\n```aiken\nshift_bytearray(#[0xEB, 0xFC], 5) == #[0x7F, 0x80]\nshift_bytearray(#[0xEB, 0xFC], -8) == #[0x00, 0xEB]\nshift_bytearray(#[0xEB, 0xFC], 8) == #[0xFC, 0x00]\n```\n> [!NOTE]\n> Size of the given `ByteArray` remains unchanged, e.g. performing a\n> left-shift of `1` on `#\"80\"` results in `#\"00\"`.",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "offset",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 352,
      "raw": "pub fn shift_bytearray(self: ByteArray, offset: Int) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn shift_bytearray(self: ByteArray, offset: Int) -> ByteArray {\n  todo\n}"
    },
    {
      "key": "prelude:aiken.builtin.bytearray_to_integer",
      "fullName": "prelude:aiken.builtin.bytearray_to_integer",
      "name": "bytearray_to_integer",
      "signature": "pub fn bytearray_to_integer(endianness: Bool, bytes: ByteArray) -> Int {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nConvert a [ByteArray](../aiken.html#ByteArray) to an integer value. The first argument\nspecifies the endianness:\n\nboolean value | endianness\n----          | ----\nTrue          | Big endian\nFalse         | Little endian",
      "parameters": [
        {
          "name": "endianness",
          "type": "Bool",
          "optional": false
        },
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 368,
      "raw": "pub fn bytearray_to_integer(endianness: Bool, bytes: ByteArray) -> Int {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn bytearray_to_integer(endianness: Bool, bytes: ByteArray) -> Int {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.append_string",
      "fullName": "prelude:aiken.builtin.append_string",
      "name": "append_string",
      "signature": "pub fn append_string(left: String, right: String) -> String {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConcatenate two strings.",
      "parameters": [
        {
          "name": "left",
          "type": "String",
          "optional": false
        },
        {
          "name": "right",
          "type": "String",
          "optional": false
        }
      ],
      "returnType": "String",
      "line": 378,
      "raw": "pub fn append_string(left: String, right: String) -> String {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn append_string(left: String, right: String) -> String {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.equals_string",
      "fullName": "prelude:aiken.builtin.equals_string",
      "name": "equals_string",
      "signature": "pub fn equals_string(left: String, right: String) -> Bool {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nString equality.",
      "parameters": [
        {
          "name": "left",
          "type": "String",
          "optional": false
        },
        {
          "name": "right",
          "type": "String",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 386,
      "raw": "pub fn equals_string(left: String, right: String) -> Bool {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn equals_string(left: String, right: String) -> Bool {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.encode_utf8",
      "fullName": "prelude:aiken.builtin.encode_utf8",
      "name": "encode_utf8",
      "signature": "pub fn encode_utf8(str: String) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConvert a string into a UTF-8 encoded array of bytes.",
      "parameters": [
        {
          "name": "str",
          "type": "String",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 394,
      "raw": "pub fn encode_utf8(str: String) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn encode_utf8(str: String) -> ByteArray {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.decode_utf8",
      "fullName": "prelude:aiken.builtin.decode_utf8",
      "name": "decode_utf8",
      "signature": "pub fn decode_utf8(bytes: ByteArray) -> String {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInterpret a UTF-8 encoded array of bytes as a String. Fails if the bytes aren't UTF-8 encoded.",
      "parameters": [
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "String",
      "line": 402,
      "raw": "pub fn decode_utf8(bytes: ByteArray) -> String {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn decode_utf8(bytes: ByteArray) -> String {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.new_list",
      "fullName": "prelude:aiken.builtin.new_list",
      "name": "new_list",
      "signature": "pub fn new_list() -> List<Data> {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConstruct an empty list of Data.",
      "parameters": [],
      "returnType": "List<Data>",
      "line": 412,
      "raw": "pub fn new_list() -> List<Data> {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn new_list() -> List<Data> {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.cons_list",
      "fullName": "prelude:aiken.builtin.cons_list",
      "name": "cons_list",
      "signature": "pub fn cons_list(elem: a, list: List<a>) -> List<a> {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nPush an element in front of a list.",
      "parameters": [
        {
          "name": "elem",
          "type": "a",
          "optional": false
        },
        {
          "name": "list",
          "type": "List<a>",
          "optional": false
        }
      ],
      "returnType": "List<a>",
      "line": 420,
      "raw": "pub fn cons_list(elem: a, list: List<a>) -> List<a> {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn cons_list(elem: a, list: List<a>) -> List<a> {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.head_list",
      "fullName": "prelude:aiken.builtin.head_list",
      "name": "head_list",
      "signature": "pub fn head_list(list: List<a>) -> a {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nThe head of a list. Fails if empty.",
      "parameters": [
        {
          "name": "list",
          "type": "List<a>",
          "optional": false
        }
      ],
      "returnType": "a",
      "line": 428,
      "raw": "pub fn head_list(list: List<a>) -> a {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn head_list(list: List<a>) -> a {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.tail_list",
      "fullName": "prelude:aiken.builtin.tail_list",
      "name": "tail_list",
      "signature": "pub fn tail_list(list: List<a>) -> List<a> {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nThe tail of a list. Fails if empty.",
      "parameters": [
        {
          "name": "list",
          "type": "List<a>",
          "optional": false
        }
      ],
      "returnType": "List<a>",
      "line": 436,
      "raw": "pub fn tail_list(list: List<a>) -> List<a> {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn tail_list(list: List<a>) -> List<a> {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.null_list",
      "fullName": "prelude:aiken.builtin.null_list",
      "name": "null_list",
      "signature": "pub fn null_list(list: List<a>) -> Bool {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nTrue when a list is empty.",
      "parameters": [
        {
          "name": "list",
          "type": "List<a>",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 444,
      "raw": "pub fn null_list(list: List<a>) -> Bool {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn null_list(list: List<a>) -> Bool {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.choose_list",
      "fullName": "prelude:aiken.builtin.choose_list",
      "name": "choose_list",
      "signature": "pub fn choose_list(list: List<a>, when_empty: b, when_non_empty: b) -> b {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nSelect a branch to continue with depending on whether the list is empty or not.",
      "parameters": [
        {
          "name": "list",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "when_empty",
          "type": "b",
          "optional": false
        },
        {
          "name": "when_non_empty",
          "type": "b",
          "optional": false
        }
      ],
      "returnType": "b",
      "line": 452,
      "raw": "pub fn choose_list(list: List<a>, when_empty: b, when_non_empty: b) -> b {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn choose_list(list: List<a>, when_empty: b, when_non_empty: b) -> b {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.constr_data",
      "fullName": "prelude:aiken.builtin.constr_data",
      "name": "constr_data",
      "signature": "pub fn constr_data(index: Int, fields: List<Data>) -> Data {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConstruct a `Data` from a constructor index and a list of fields.",
      "parameters": [
        {
          "name": "index",
          "type": "Int",
          "optional": false
        },
        {
          "name": "fields",
          "type": "List<Data>",
          "optional": false
        }
      ],
      "returnType": "Data",
      "line": 462,
      "raw": "pub fn constr_data(index: Int, fields: List<Data>) -> Data {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn constr_data(index: Int, fields: List<Data>) -> Data {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.un_constr_data",
      "fullName": "prelude:aiken.builtin.un_constr_data",
      "name": "un_constr_data",
      "signature": "pub fn un_constr_data(data: Data) -> Pair<Int, List<Data>> {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInterpret a `Data` as a constructor. Fails if it's not a constructor.",
      "parameters": [
        {
          "name": "data",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "Pair<Int, List<Data>>",
      "line": 470,
      "raw": "pub fn un_constr_data(data: Data) -> Pair<Int, List<Data>> {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn un_constr_data(data: Data) -> Pair<Int, List<Data>> {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.unconstr_fields",
      "fullName": "prelude:aiken.builtin.unconstr_fields",
      "name": "unconstr_fields",
      "signature": "pub fn unconstr_fields(data: Data) -> List<Data> {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInterpret a `Data` as a constructor and extract its fields. Slightly more efficient than using [`un_constr_data`](#un_constr_data).",
      "parameters": [
        {
          "name": "data",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "List<Data>",
      "line": 478,
      "raw": "pub fn unconstr_fields(data: Data) -> List<Data> {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn unconstr_fields(data: Data) -> List<Data> {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.unconstr_index",
      "fullName": "prelude:aiken.builtin.unconstr_index",
      "name": "unconstr_index",
      "signature": "pub fn unconstr_index(data: Data) -> Int {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInterpret a `Data` as a constructor and extract its index. Slightly more efficient than using [`un_constr_data`](#un_constr_data).",
      "parameters": [
        {
          "name": "data",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 486,
      "raw": "pub fn unconstr_index(data: Data) -> Int {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn unconstr_index(data: Data) -> Int {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.map_data",
      "fullName": "prelude:aiken.builtin.map_data",
      "name": "map_data",
      "signature": "pub fn map_data(items: List<Pair<Data, Data>>) -> Data {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConstruct a `Data` from a list of pairs.",
      "parameters": [
        {
          "name": "items",
          "type": "List<Pair<Data, Data>>",
          "optional": false
        }
      ],
      "returnType": "Data",
      "line": 494,
      "raw": "pub fn map_data(items: List<Pair<Data, Data>>) -> Data {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn map_data(items: List<Pair<Data, Data>>) -> Data {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.un_map_data",
      "fullName": "prelude:aiken.builtin.un_map_data",
      "name": "un_map_data",
      "signature": "pub fn un_map_data(data: Data) -> List<Pair<Data, Data>> {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInterpret a `Data` as a map. Fails if it's not a map.",
      "parameters": [
        {
          "name": "data",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "List<Pair<Data, Data>>",
      "line": 502,
      "raw": "pub fn un_map_data(data: Data) -> List<Pair<Data, Data>> {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn un_map_data(data: Data) -> List<Pair<Data, Data>> {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.list_data",
      "fullName": "prelude:aiken.builtin.list_data",
      "name": "list_data",
      "signature": "pub fn list_data(items: List<Data>) -> Data {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConstruct a `Data` from a list of elements.",
      "parameters": [
        {
          "name": "items",
          "type": "List<Data>",
          "optional": false
        }
      ],
      "returnType": "Data",
      "line": 510,
      "raw": "pub fn list_data(items: List<Data>) -> Data {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn list_data(items: List<Data>) -> Data {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.un_list_data",
      "fullName": "prelude:aiken.builtin.un_list_data",
      "name": "un_list_data",
      "signature": "pub fn un_list_data(data: Data) -> List<Data> {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInterpret a `Data` as a list. Fails if it's not a list.",
      "parameters": [
        {
          "name": "data",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "List<Data>",
      "line": 518,
      "raw": "pub fn un_list_data(data: Data) -> List<Data> {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn un_list_data(data: Data) -> List<Data> {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.i_data",
      "fullName": "prelude:aiken.builtin.i_data",
      "name": "i_data",
      "signature": "pub fn i_data(i: Int) -> Data {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConstruct a `Data` from an integer.",
      "parameters": [
        {
          "name": "i",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Data",
      "line": 526,
      "raw": "pub fn i_data(i: Int) -> Data {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn i_data(i: Int) -> Data {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.un_i_data",
      "fullName": "prelude:aiken.builtin.un_i_data",
      "name": "un_i_data",
      "signature": "pub fn un_i_data(data: Data) -> Int {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInterpret a `Data` as a integer. Fails if it's not an integer.",
      "parameters": [
        {
          "name": "data",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 534,
      "raw": "pub fn un_i_data(data: Data) -> Int {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn un_i_data(data: Data) -> Int {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.b_data",
      "fullName": "prelude:aiken.builtin.b_data",
      "name": "b_data",
      "signature": "pub fn b_data(bytes: ByteArray) -> Data {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConstruct a `Data` from a ByteArray",
      "parameters": [
        {
          "name": "bytes",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Data",
      "line": 542,
      "raw": "pub fn b_data(bytes: ByteArray) -> Data {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn b_data(bytes: ByteArray) -> Data {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.un_b_data",
      "fullName": "prelude:aiken.builtin.un_b_data",
      "name": "un_b_data",
      "signature": "pub fn un_b_data(data: Data) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nInterpret a `Data` as a bytearray. Fails if it's not a bytearray.",
      "parameters": [
        {
          "name": "data",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 550,
      "raw": "pub fn un_b_data(data: Data) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn un_b_data(data: Data) -> ByteArray {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.equals_data",
      "fullName": "prelude:aiken.builtin.equals_data",
      "name": "equals_data",
      "signature": "pub fn equals_data(left: Data, right: Data) -> Bool {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nEquality on Data.",
      "parameters": [
        {
          "name": "left",
          "type": "Data",
          "optional": false
        },
        {
          "name": "right",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 558,
      "raw": "pub fn equals_data(left: Data, right: Data) -> Bool {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn equals_data(left: Data, right: Data) -> Bool {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.serialise_data",
      "fullName": "prelude:aiken.builtin.serialise_data",
      "name": "serialise_data",
      "signature": "pub fn serialise_data(data: Data) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>2</small>\n---                                   | ---\n\nSerialise a Data to bytes, using CBOR.",
      "parameters": [
        {
          "name": "data",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 566,
      "raw": "pub fn serialise_data(data: Data) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn serialise_data(data: Data) -> ByteArray {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.choose_data",
      "fullName": "prelude:aiken.builtin.choose_data",
      "name": "choose_data",
      "signature": "pub fn choose_data(pub fn choose_data(data: Data, when_constr: a, when_map: a, when_list: a, when_int: a, when_bytearray: a, ) -> a {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nSelect a branch to continue with based on what the Data actually is.",
      "parameters": [],
      "returnType": "a",
      "line": 574,
      "raw": "pub fn choose_data(pub fn choose_data(data: Data, when_constr: a, when_map: a, when_list: a, when_int: a, when_bytearray: a, ) -> a {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn choose_data(\n  data: Data,\n  when_constr: a,\n  when_map: a,\n  when_list: a,\n  when_int: a,\n  when_bytearray: a,\n) -> a {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.new_pair",
      "fullName": "prelude:aiken.builtin.new_pair",
      "name": "new_pair",
      "signature": "pub fn new_pair(left: Data, right: Data) -> Pair<Data, Data> {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConstruct a Data from a pair of elements.",
      "parameters": [
        {
          "name": "left",
          "type": "Data",
          "optional": false
        },
        {
          "name": "right",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "Pair<Data, Data>",
      "line": 591,
      "raw": "pub fn new_pair(left: Data, right: Data) -> Pair<Data, Data> {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn new_pair(left: Data, right: Data) -> Pair<Data, Data> {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.new_pairs",
      "fullName": "prelude:aiken.builtin.new_pairs",
      "name": "new_pairs",
      "signature": "pub fn new_pairs() -> Pairs<Data, Data> {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nConstruct an empty list of pairs of data.",
      "parameters": [],
      "returnType": "Pairs<Data, Data>",
      "line": 599,
      "raw": "pub fn new_pairs() -> Pairs<Data, Data> {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn new_pairs() -> Pairs<Data, Data> {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.fst_pair",
      "fullName": "prelude:aiken.builtin.fst_pair",
      "name": "fst_pair",
      "signature": "pub fn fst_pair(pair: Pair<a, b>) -> a {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nGet the first element of a pair.",
      "parameters": [
        {
          "name": "pair",
          "type": "Pair<a, b>",
          "optional": false
        }
      ],
      "returnType": "a",
      "line": 607,
      "raw": "pub fn fst_pair(pair: Pair<a, b>) -> a {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn fst_pair(pair: Pair<a, b>) -> a {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.snd_pair",
      "fullName": "prelude:aiken.builtin.snd_pair",
      "name": "snd_pair",
      "signature": "pub fn snd_pair(pair: Pair<a, b>) -> b {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nGet the second element of a pair.",
      "parameters": [
        {
          "name": "pair",
          "type": "Pair<a, b>",
          "optional": false
        }
      ],
      "returnType": "b",
      "line": 615,
      "raw": "pub fn snd_pair(pair: Pair<a, b>) -> b {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn snd_pair(pair: Pair<a, b>) -> b {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.blake2b_256",
      "fullName": "prelude:aiken.builtin.blake2b_256",
      "name": "blake2b_256",
      "signature": "pub fn blake2b_256(preimage: ByteArray) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nCalculate the blake2b-256 hash digest value of a given bytearray. Output is always 32-byte long.",
      "parameters": [
        {
          "name": "preimage",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 627,
      "raw": "pub fn blake2b_256(preimage: ByteArray) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn blake2b_256(preimage: ByteArray) -> ByteArray {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.blake2b_224",
      "fullName": "prelude:aiken.builtin.blake2b_224",
      "name": "blake2b_224",
      "signature": "pub fn blake2b_224(preimage: ByteArray) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nCalculate the blake2b-224 hash digest value of a given bytearray. Output is always 28-byte long.",
      "parameters": [
        {
          "name": "preimage",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 635,
      "raw": "pub fn blake2b_224(preimage: ByteArray) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn blake2b_224(preimage: ByteArray) -> ByteArray {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.keccak_256",
      "fullName": "prelude:aiken.builtin.keccak_256",
      "name": "keccak_256",
      "signature": "pub fn keccak_256(preimage: ByteArray) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nCalculate the keccak-256 hash digest value of a given bytearray. Output is always 32-byte long.",
      "parameters": [
        {
          "name": "preimage",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 643,
      "raw": "pub fn keccak_256(preimage: ByteArray) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn keccak_256(preimage: ByteArray) -> ByteArray {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.ripemd_160",
      "fullName": "prelude:aiken.builtin.ripemd_160",
      "name": "ripemd_160",
      "signature": "pub fn ripemd_160(preimage: ByteArray) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---\n\nCalculate the ripemd-160 hash digest value of a given bytearray. Output is always 20-byte long.",
      "parameters": [
        {
          "name": "preimage",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 651,
      "raw": "pub fn ripemd_160(preimage: ByteArray) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn ripemd_160(preimage: ByteArray) -> ByteArray {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.sha2_256",
      "fullName": "prelude:aiken.builtin.sha2_256",
      "name": "sha2_256",
      "signature": "pub fn sha2_256(preimage: ByteArray) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nCalculate the SHA2-256 hash digest value of a given bytearray. Output is always 32-byte long.",
      "parameters": [
        {
          "name": "preimage",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 659,
      "raw": "pub fn sha2_256(preimage: ByteArray) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn sha2_256(preimage: ByteArray) -> ByteArray {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.sha3_256",
      "fullName": "prelude:aiken.builtin.sha3_256",
      "name": "sha3_256",
      "signature": "pub fn sha3_256(preimage: ByteArray) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nCalculate the SHA3-256 hash digest value of a given bytearray. Output is always 32-byte long.",
      "parameters": [
        {
          "name": "preimage",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 667,
      "raw": "pub fn sha3_256(preimage: ByteArray) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn sha3_256(preimage: ByteArray) -> ByteArray {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.verify_ed25519_signature",
      "fullName": "prelude:aiken.builtin.verify_ed25519_signature",
      "name": "verify_ed25519_signature",
      "signature": "pub fn verify_ed25519_signature(pub fn verify_ed25519_signature(verification_key: ByteArray, message: ByteArray, signature: ByteArray, ) -> Bool {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nVerify an Ed25519 signature from a associated verification key.",
      "parameters": [],
      "returnType": "Bool",
      "line": 677,
      "raw": "pub fn verify_ed25519_signature(pub fn verify_ed25519_signature(verification_key: ByteArray, message: ByteArray, signature: ByteArray, ) -> Bool {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn verify_ed25519_signature(\n  verification_key: ByteArray,\n  message: ByteArray,\n  signature: ByteArray,\n) -> Bool {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.verify_ecdsa_secp256k1_signature",
      "fullName": "prelude:aiken.builtin.verify_ecdsa_secp256k1_signature",
      "name": "verify_ecdsa_secp256k1_signature",
      "signature": "pub fn verify_ecdsa_secp256k1_signature(pub fn verify_ecdsa_secp256k1_signature(verification_key: ByteArray, message: ByteArray, signature: ByteArray, ) -> Bool {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>2</small>\n---                                   | ---\n\nVerify an ECDSA-SECP256k1 signature from a associated verification key.",
      "parameters": [],
      "returnType": "Bool",
      "line": 689,
      "raw": "pub fn verify_ecdsa_secp256k1_signature(pub fn verify_ecdsa_secp256k1_signature(verification_key: ByteArray, message: ByteArray, signature: ByteArray, ) -> Bool {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn verify_ecdsa_secp256k1_signature(\n  verification_key: ByteArray,\n  message: ByteArray,\n  signature: ByteArray,\n) -> Bool {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.verify_schnorr_secp256k1_signature",
      "fullName": "prelude:aiken.builtin.verify_schnorr_secp256k1_signature",
      "name": "verify_schnorr_secp256k1_signature",
      "signature": "pub fn verify_schnorr_secp256k1_signature(pub fn verify_schnorr_secp256k1_signature(verification_key: ByteArray, message: ByteArray, signature: ByteArray, ) -> Bool {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>2</small>\n---                                   | ---\n\nVerify a SCHNORR-SECP256k1 signature from a associated verification key.",
      "parameters": [],
      "returnType": "Bool",
      "line": 701,
      "raw": "pub fn verify_schnorr_secp256k1_signature(pub fn verify_schnorr_secp256k1_signature(verification_key: ByteArray, message: ByteArray, signature: ByteArray, ) -> Bool {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn verify_schnorr_secp256k1_signature(\n  verification_key: ByteArray,\n  message: ByteArray,\n  signature: ByteArray,\n) -> Bool {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.bls12_381_g1_add",
      "fullName": "prelude:aiken.builtin.bls12_381_g1_add",
      "name": "bls12_381_g1_add",
      "signature": "pub fn bls12_381_g1_add(a: G1Element, b: G1Element) -> G1Element {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
      "parameters": [
        {
          "name": "a",
          "type": "G1Element",
          "optional": false
        },
        {
          "name": "b",
          "type": "G1Element",
          "optional": false
        }
      ],
      "returnType": "G1Element",
      "line": 713,
      "raw": "pub fn bls12_381_g1_add(a: G1Element, b: G1Element) -> G1Element {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn bls12_381_g1_add(a: G1Element, b: G1Element) -> G1Element {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.bls12_381_g1_neg",
      "fullName": "prelude:aiken.builtin.bls12_381_g1_neg",
      "name": "bls12_381_g1_neg",
      "signature": "pub fn bls12_381_g1_neg(self: G1Element) -> G1Element {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
      "parameters": [
        {
          "name": "self",
          "type": "G1Element",
          "optional": false
        }
      ],
      "returnType": "G1Element",
      "line": 719,
      "raw": "pub fn bls12_381_g1_neg(self: G1Element) -> G1Element {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn bls12_381_g1_neg(self: G1Element) -> G1Element {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.bls12_381_g1_scalar_mul",
      "fullName": "prelude:aiken.builtin.bls12_381_g1_scalar_mul",
      "name": "bls12_381_g1_scalar_mul",
      "signature": "pub fn bls12_381_g1_scalar_mul(scalar: Int, self: G1Element) -> G1Element {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
      "parameters": [
        {
          "name": "scalar",
          "type": "Int",
          "optional": false
        },
        {
          "name": "self",
          "type": "G1Element",
          "optional": false
        }
      ],
      "returnType": "G1Element",
      "line": 725,
      "raw": "pub fn bls12_381_g1_scalar_mul(scalar: Int, self: G1Element) -> G1Element {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn bls12_381_g1_scalar_mul(scalar: Int, self: G1Element) -> G1Element {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.bls12_381_g1_equal",
      "fullName": "prelude:aiken.builtin.bls12_381_g1_equal",
      "name": "bls12_381_g1_equal",
      "signature": "pub fn bls12_381_g1_equal(self: G1Element, other: G1Element) -> Bool {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
      "parameters": [
        {
          "name": "self",
          "type": "G1Element",
          "optional": false
        },
        {
          "name": "other",
          "type": "G1Element",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 731,
      "raw": "pub fn bls12_381_g1_equal(self: G1Element, other: G1Element) -> Bool {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn bls12_381_g1_equal(self: G1Element, other: G1Element) -> Bool {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.bls12_381_g1_compress",
      "fullName": "prelude:aiken.builtin.bls12_381_g1_compress",
      "name": "bls12_381_g1_compress",
      "signature": "pub fn bls12_381_g1_compress(self: G1Element) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
      "parameters": [
        {
          "name": "self",
          "type": "G1Element",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 737,
      "raw": "pub fn bls12_381_g1_compress(self: G1Element) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn bls12_381_g1_compress(self: G1Element) -> ByteArray {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.bls12_381_g1_uncompress",
      "fullName": "prelude:aiken.builtin.bls12_381_g1_uncompress",
      "name": "bls12_381_g1_uncompress",
      "signature": "pub fn bls12_381_g1_uncompress(self: ByteArray) -> G1Element {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "G1Element",
      "line": 743,
      "raw": "pub fn bls12_381_g1_uncompress(self: ByteArray) -> G1Element {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn bls12_381_g1_uncompress(self: ByteArray) -> G1Element {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.bls12_381_g1_hash_to_group",
      "fullName": "prelude:aiken.builtin.bls12_381_g1_hash_to_group",
      "name": "bls12_381_g1_hash_to_group",
      "signature": "pub fn bls12_381_g1_hash_to_group(pub fn bls12_381_g1_hash_to_group(group: ByteArray, domain_separation_tag: ByteArray, ) -> G1Element {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
      "parameters": [],
      "returnType": "G1Element",
      "line": 749,
      "raw": "pub fn bls12_381_g1_hash_to_group(pub fn bls12_381_g1_hash_to_group(group: ByteArray, domain_separation_tag: ByteArray, ) -> G1Element {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn bls12_381_g1_hash_to_group(\n  group: ByteArray,\n  domain_separation_tag: ByteArray,\n) -> G1Element {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.bls12_381_g2_add",
      "fullName": "prelude:aiken.builtin.bls12_381_g2_add",
      "name": "bls12_381_g2_add",
      "signature": "pub fn bls12_381_g2_add(a: G2Element, b: G2Element) -> G2Element {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
      "parameters": [
        {
          "name": "a",
          "type": "G2Element",
          "optional": false
        },
        {
          "name": "b",
          "type": "G2Element",
          "optional": false
        }
      ],
      "returnType": "G2Element",
      "line": 758,
      "raw": "pub fn bls12_381_g2_add(a: G2Element, b: G2Element) -> G2Element {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn bls12_381_g2_add(a: G2Element, b: G2Element) -> G2Element {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.bls12_381_g2_neg",
      "fullName": "prelude:aiken.builtin.bls12_381_g2_neg",
      "name": "bls12_381_g2_neg",
      "signature": "pub fn bls12_381_g2_neg(self: G2Element) -> G2Element {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
      "parameters": [
        {
          "name": "self",
          "type": "G2Element",
          "optional": false
        }
      ],
      "returnType": "G2Element",
      "line": 764,
      "raw": "pub fn bls12_381_g2_neg(self: G2Element) -> G2Element {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn bls12_381_g2_neg(self: G2Element) -> G2Element {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.bls12_381_g2_scalar_mul",
      "fullName": "prelude:aiken.builtin.bls12_381_g2_scalar_mul",
      "name": "bls12_381_g2_scalar_mul",
      "signature": "pub fn bls12_381_g2_scalar_mul(scalar: Int, self: G2Element) -> G2Element {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
      "parameters": [
        {
          "name": "scalar",
          "type": "Int",
          "optional": false
        },
        {
          "name": "self",
          "type": "G2Element",
          "optional": false
        }
      ],
      "returnType": "G2Element",
      "line": 770,
      "raw": "pub fn bls12_381_g2_scalar_mul(scalar: Int, self: G2Element) -> G2Element {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn bls12_381_g2_scalar_mul(scalar: Int, self: G2Element) -> G2Element {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.bls12_381_g2_equal",
      "fullName": "prelude:aiken.builtin.bls12_381_g2_equal",
      "name": "bls12_381_g2_equal",
      "signature": "pub fn bls12_381_g2_equal(self: G2Element, other: G2Element) -> Bool {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
      "parameters": [
        {
          "name": "self",
          "type": "G2Element",
          "optional": false
        },
        {
          "name": "other",
          "type": "G2Element",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 776,
      "raw": "pub fn bls12_381_g2_equal(self: G2Element, other: G2Element) -> Bool {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn bls12_381_g2_equal(self: G2Element, other: G2Element) -> Bool {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.bls12_381_g2_compress",
      "fullName": "prelude:aiken.builtin.bls12_381_g2_compress",
      "name": "bls12_381_g2_compress",
      "signature": "pub fn bls12_381_g2_compress(self: G2Element) -> ByteArray {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
      "parameters": [
        {
          "name": "self",
          "type": "G2Element",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 782,
      "raw": "pub fn bls12_381_g2_compress(self: G2Element) -> ByteArray {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn bls12_381_g2_compress(self: G2Element) -> ByteArray {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.bls12_381_g2_uncompress",
      "fullName": "prelude:aiken.builtin.bls12_381_g2_uncompress",
      "name": "bls12_381_g2_uncompress",
      "signature": "pub fn bls12_381_g2_uncompress(self: ByteArray) -> G2Element {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
      "parameters": [
        {
          "name": "self",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "G2Element",
      "line": 788,
      "raw": "pub fn bls12_381_g2_uncompress(self: ByteArray) -> G2Element {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn bls12_381_g2_uncompress(self: ByteArray) -> G2Element {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.bls12_381_g2_hash_to_group",
      "fullName": "prelude:aiken.builtin.bls12_381_g2_hash_to_group",
      "name": "bls12_381_g2_hash_to_group",
      "signature": "pub fn bls12_381_g2_hash_to_group(pub fn bls12_381_g2_hash_to_group(group: ByteArray, domain_separation_tag: ByteArray, ) -> G2Element {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
      "parameters": [],
      "returnType": "G2Element",
      "line": 794,
      "raw": "pub fn bls12_381_g2_hash_to_group(pub fn bls12_381_g2_hash_to_group(group: ByteArray, domain_separation_tag: ByteArray, ) -> G2Element {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn bls12_381_g2_hash_to_group(\n  group: ByteArray,\n  domain_separation_tag: ByteArray,\n) -> G2Element {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.bls12_381_miller_loop",
      "fullName": "prelude:aiken.builtin.bls12_381_miller_loop",
      "name": "bls12_381_miller_loop",
      "signature": "pub fn bls12_381_miller_loop(g1: G1Element, g2: G2Element) -> MillerLoopResult {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
      "parameters": [
        {
          "name": "g1",
          "type": "G1Element",
          "optional": false
        },
        {
          "name": "g2",
          "type": "G2Element",
          "optional": false
        }
      ],
      "returnType": "MillerLoopResult",
      "line": 803,
      "raw": "pub fn bls12_381_miller_loop(g1: G1Element, g2: G2Element) -> MillerLoopResult {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn bls12_381_miller_loop(g1: G1Element, g2: G2Element) -> MillerLoopResult {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.bls12_381_mul_miller_loop_result",
      "fullName": "prelude:aiken.builtin.bls12_381_mul_miller_loop_result",
      "name": "bls12_381_mul_miller_loop_result",
      "signature": "pub fn bls12_381_mul_miller_loop_result(pub fn bls12_381_mul_miller_loop_result(a: MillerLoopResult, b: MillerLoopResult, ) -> MillerLoopResult {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
      "parameters": [],
      "returnType": "MillerLoopResult",
      "line": 809,
      "raw": "pub fn bls12_381_mul_miller_loop_result(pub fn bls12_381_mul_miller_loop_result(a: MillerLoopResult, b: MillerLoopResult, ) -> MillerLoopResult {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn bls12_381_mul_miller_loop_result(\n  a: MillerLoopResult,\n  b: MillerLoopResult,\n) -> MillerLoopResult {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.bls12_381_final_verify",
      "fullName": "prelude:aiken.builtin.bls12_381_final_verify",
      "name": "bls12_381_final_verify",
      "signature": "pub fn bls12_381_final_verify(a: MillerLoopResult, b: MillerLoopResult) -> Bool {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>3</small>\n---                                   | ---",
      "parameters": [
        {
          "name": "a",
          "type": "MillerLoopResult",
          "optional": false
        },
        {
          "name": "b",
          "type": "MillerLoopResult",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 818,
      "raw": "pub fn bls12_381_final_verify(a: MillerLoopResult, b: MillerLoopResult) -> Bool {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn bls12_381_final_verify(a: MillerLoopResult, b: MillerLoopResult) -> Bool {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.choose_void",
      "fullName": "prelude:aiken.builtin.choose_void",
      "name": "choose_void",
      "signature": "pub fn choose_void(void: Void, when_void: a) -> a {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nContinue with the continuation when the given term is Void.",
      "parameters": [
        {
          "name": "void",
          "type": "Void",
          "optional": false
        },
        {
          "name": "when_void",
          "type": "a",
          "optional": false
        }
      ],
      "returnType": "a",
      "line": 828,
      "raw": "pub fn choose_void(void: Void, when_void: a) -> a {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn choose_void(void: Void, when_void: a) -> a {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.debug",
      "fullName": "prelude:aiken.builtin.debug",
      "name": "debug",
      "signature": "pub fn debug(message: String, continuation: a) -> a {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nTrace the provided message, and continue with the continuation.",
      "parameters": [
        {
          "name": "message",
          "type": "String",
          "optional": false
        },
        {
          "name": "continuation",
          "type": "a",
          "optional": false
        }
      ],
      "returnType": "a",
      "line": 836,
      "raw": "pub fn debug(message: String, continuation: a) -> a {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn debug(message: String, continuation: a) -> a {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.builtin.if_then_else",
      "fullName": "prelude:aiken.builtin.if_then_else",
      "name": "if_then_else",
      "signature": "pub fn if_then_else(condition: Bool, when_true: a, when_false: a) -> a {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nReturn first computation when the condition is true, and the second otherwise.",
      "parameters": [
        {
          "name": "condition",
          "type": "Bool",
          "optional": false
        },
        {
          "name": "when_true",
          "type": "a",
          "optional": false
        },
        {
          "name": "when_false",
          "type": "a",
          "optional": false
        }
      ],
      "returnType": "a",
      "line": 844,
      "raw": "pub fn if_then_else(condition: Bool, when_true: a, when_false: a) -> a {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn if_then_else(condition: Bool, when_true: a, when_false: a) -> a {\n  fail\n}"
    },
    {
      "key": "prelude:aiken.not",
      "fullName": "prelude:aiken.not",
      "name": "not",
      "signature": "pub fn not(self: Bool) -> Bool {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nLike `!`, but as a function. Handy for chaining using the pipe operator `|>` or to pass as a function.",
      "parameters": [
        {
          "name": "self",
          "type": "Bool",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 173,
      "raw": "pub fn not(self: Bool) -> Bool {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn not(self: Bool) -> Bool {\n  when self is {\n    True -> False\n    False -> True\n  }\n}"
    },
    {
      "key": "prelude:aiken.always",
      "fullName": "prelude:aiken.always",
      "name": "always",
      "signature": "pub fn always(a: a, b _b: b) -> a {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nA function that always return its first argument. Handy in folds and maps.\n\n```aiken\nlet always_14 = always(14, _)\nalways_14(42) == 14\nalways_14(1337) == 14\nalways_14(0) == 14\n```",
      "parameters": [
        {
          "name": "a",
          "type": "a",
          "optional": false
        }
      ],
      "returnType": "a",
      "line": 191,
      "raw": "pub fn always(a: a, b _b: b) -> a {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn always(a: a, b _b: b) -> a {\n  a\n}"
    },
    {
      "key": "prelude:aiken.as_data",
      "fullName": "prelude:aiken.as_data",
      "name": "as_data",
      "signature": "pub fn as_data(data: Data) -> Data {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nAn identity function to upcast any serialisable type into `Data`, in places where the compiler cannot implicitly infer it.\n\n```aiken\nlet my_uniform_list: List<Data> = [as_data(Foo(14)), as_data(Bar(True))]\n```",
      "parameters": [
        {
          "name": "data",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "Data",
      "line": 203,
      "raw": "pub fn as_data(data: Data) -> Data {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn as_data(data: Data) -> Data {\n  data\n}"
    },
    {
      "key": "prelude:aiken.identity",
      "fullName": "prelude:aiken.identity",
      "name": "identity",
      "signature": "pub fn identity(a: a) -> a {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nA function that returns its argument. Handy as a default behavior sometimes.",
      "parameters": [
        {
          "name": "a",
          "type": "a",
          "optional": false
        }
      ],
      "returnType": "a",
      "line": 211,
      "raw": "pub fn identity(a: a) -> a {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn identity(a: a) -> a {\n  a\n}"
    },
    {
      "key": "prelude:aiken.flip",
      "fullName": "prelude:aiken.flip",
      "name": "flip",
      "signature": "pub fn flip(f: fn(a, b) -> c) -> fn(b, a) -> c {",
      "documentation": "<small>Minimum Plutus Version</small> | <small>1</small>\n---                                   | ---\n\nA function that flips the arguments of a function.\n\n```aiken\npub fn titleize(left: String, right: String) {}\n\ntitleize(\"Hello\", \"World\") // \"Hello, World!\"\n\nflip(titleize)(\"Hello\", \"World\") // \"World, Hello!\"\n```",
      "parameters": [
        {
          "name": "f",
          "type": "fn(a, b",
          "optional": false
        }
      ],
      "returnType": "c) -> fn(b, a) -> c",
      "line": 227,
      "raw": "pub fn flip(f: fn(a, b) -> c) -> fn(b, a) -> c {",
      "isPublic": true,
      "source": "prelude",
      "implementation": "pub fn flip(f: fn(a, b) -> c) -> fn(b, a) -> c {\n  fn(b, a) { f(a, b) }\n}"
    },
    {
      "key": "vodka:cip.drop_cip68_prefix",
      "fullName": "vodka:cip.drop_cip68_prefix",
      "name": "drop_cip68_prefix",
      "signature": "pub fn drop_cip68_prefix(cip_68_asset_name: AssetName) -> AssetName {",
      "parameters": [
        {
          "name": "cip_68_asset_name",
          "type": "AssetName",
          "optional": false
        }
      ],
      "returnType": "AssetName",
      "line": 28,
      "raw": "pub fn drop_cip68_prefix(cip_68_asset_name: AssetName) -> AssetName {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn drop_cip68_prefix(cip_68_asset_name: AssetName) -> AssetName {\n  cip_68_asset_name |> bytearray.drop(4)\n}",
      "tests": [
        "test test_drop_cip68_prefix() {\n  let cip68_100_asset_name = #\"000643b012345678\"\n  drop_cip68_prefix(cip68_100_asset_name) == #\"12345678\"\n}"
      ]
    },
    {
      "key": "vodka:cip.cip68_100",
      "fullName": "vodka:cip.cip68_100",
      "name": "cip68_100",
      "signature": "pub fn cip68_100(asset_name: AssetName) -> AssetName {",
      "documentation": "Obtain the asset name for CIP-68 asset - Reference Token\n```aiken\nlet cip68_100_asset_name = cip68_100(asset_name)\n```",
      "parameters": [
        {
          "name": "asset_name",
          "type": "AssetName",
          "optional": false
        }
      ],
      "returnType": "AssetName",
      "line": 41,
      "raw": "pub fn cip68_100(asset_name: AssetName) -> AssetName {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn cip68_100(asset_name: AssetName) -> AssetName {\n  concat(cip68_100_prefix, asset_name)\n}"
    },
    {
      "key": "vodka:cip.cip68_222",
      "fullName": "vodka:cip.cip68_222",
      "name": "cip68_222",
      "signature": "pub fn cip68_222(asset_name: AssetName) -> AssetName {",
      "documentation": "Obtain the asset name for CIP-68 asset - Non-Fungible Token\n```aiken\nlet cip68_222_asset_name = cip68_222(asset_name)\n```",
      "parameters": [
        {
          "name": "asset_name",
          "type": "AssetName",
          "optional": false
        }
      ],
      "returnType": "AssetName",
      "line": 49,
      "raw": "pub fn cip68_222(asset_name: AssetName) -> AssetName {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn cip68_222(asset_name: AssetName) -> AssetName {\n  concat(cip68_222_prefix, asset_name)\n}"
    },
    {
      "key": "vodka:cip.cip68_333",
      "fullName": "vodka:cip.cip68_333",
      "name": "cip68_333",
      "signature": "pub fn cip68_333(asset_name: AssetName) -> AssetName {",
      "documentation": "Obtain the asset name for CIP-68 asset - Fungible Token\n```aiken\nlet cip68_333_asset_name = cip68_333(asset_name)\n```",
      "parameters": [
        {
          "name": "asset_name",
          "type": "AssetName",
          "optional": false
        }
      ],
      "returnType": "AssetName",
      "line": 57,
      "raw": "pub fn cip68_333(asset_name: AssetName) -> AssetName {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn cip68_333(asset_name: AssetName) -> AssetName {\n  concat(cip68_333_prefix, asset_name)\n}"
    },
    {
      "key": "vodka:cip.cip68_444",
      "fullName": "vodka:cip.cip68_444",
      "name": "cip68_444",
      "signature": "pub fn cip68_444(asset_name: AssetName) -> AssetName {",
      "documentation": "Obtain the asset name for CIP-68 asset - Rich-Fungible Token\n```aiken\nlet cip68_444_asset_name = cip68_444(asset_name)\n```",
      "parameters": [
        {
          "name": "asset_name",
          "type": "AssetName",
          "optional": false
        }
      ],
      "returnType": "AssetName",
      "line": 65,
      "raw": "pub fn cip68_444(asset_name: AssetName) -> AssetName {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn cip68_444(asset_name: AssetName) -> AssetName {\n  concat(cip68_444_prefix, asset_name)\n}"
    },
    {
      "key": "vodka:cocktail.vodka_address.compare_script_address",
      "fullName": "vodka:cocktail.vodka_address.compare_script_address",
      "name": "compare_script_address",
      "signature": "pub fn compare_script_address(x: Address, y: Address) -> Ordering {",
      "documentation": "Compare two script addresses",
      "parameters": [
        {
          "name": "x",
          "type": "Address",
          "optional": false
        },
        {
          "name": "y",
          "type": "Address",
          "optional": false
        }
      ],
      "returnType": "Ordering",
      "line": 6,
      "raw": "pub fn compare_script_address(x: Address, y: Address) -> Ordering {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn compare_script_address(x: Address, y: Address) -> Ordering {\n  expect Script(x_hash) = x.payment_credential\n  expect Script(y_hash) = y.payment_credential\n  bytearray.compare(x_hash, y_hash)\n}",
      "reExportedAs": ["cocktail.compare_script_address"]
    },
    {
      "key": "vodka:cocktail.vodka_address.compare_address",
      "fullName": "vodka:cocktail.vodka_address.compare_address",
      "name": "compare_address",
      "signature": "pub fn compare_address(x: Address, y: Address) -> Ordering {",
      "documentation": "Compare two addresses",
      "parameters": [
        {
          "name": "x",
          "type": "Address",
          "optional": false
        },
        {
          "name": "y",
          "type": "Address",
          "optional": false
        }
      ],
      "returnType": "Ordering",
      "line": 13,
      "raw": "pub fn compare_address(x: Address, y: Address) -> Ordering {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn compare_address(x: Address, y: Address) -> Ordering {\n  let x_hash = x.payment_credential\n  let y_hash = y.payment_credential\n  when (x_hash, y_hash) is {\n    (Script(x_script_hash), Script(y_script_hash)) ->\n      bytearray.compare(x_script_hash, y_script_hash)\n    (VerificationKey(x_key_hash), VerificationKey(y_key_hash)) ->\n      bytearray.compare(x_key_hash, y_key_hash)\n    _ -> Equal\n  }\n}",
      "reExportedAs": ["cocktail.compare_address"]
    },
    {
      "key": "vodka:cocktail.vodka_address.address_payment_key",
      "fullName": "vodka:cocktail.vodka_address.address_payment_key",
      "name": "address_payment_key",
      "signature": "pub fn address_payment_key(address: Address) -> Hash<Blake2b_224, ByteArray> {",
      "documentation": "Obtain the payment key of an address, it can be either a script hash or a verification key\n```aiken\nlet payment_key_hash = address_payment_key(address)\n```",
      "parameters": [
        {
          "name": "address",
          "type": "Address",
          "optional": false
        }
      ],
      "returnType": "Hash<Blake2b_224, ByteArray>",
      "line": 29,
      "raw": "pub fn address_payment_key(address: Address) -> Hash<Blake2b_224, ByteArray> {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn address_payment_key(address: Address) -> Hash<Blake2b_224, ByteArray> {\n  when address.payment_credential is {\n    Script(hash) -> hash\n    VerificationKey(key_hash) -> key_hash\n  }\n}",
      "reExportedAs": ["cocktail.address_payment_key"]
    },
    {
      "key": "vodka:cocktail.vodka_address.address_pub_key",
      "fullName": "vodka:cocktail.vodka_address.address_pub_key",
      "name": "address_pub_key",
      "signature": "pub fn address_pub_key(address: Address) -> Option<VerificationKeyHash> {",
      "documentation": "Obtain the verification key of an address, None if it is a script address\n```aiken\nexpect Some(pub_key_hash) = address_pub_key(address)\n```",
      "parameters": [
        {
          "name": "address",
          "type": "Address",
          "optional": false
        }
      ],
      "returnType": "Option<VerificationKeyHash>",
      "line": 40,
      "raw": "pub fn address_pub_key(address: Address) -> Option<VerificationKeyHash> {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn address_pub_key(address: Address) -> Option<VerificationKeyHash> {\n  when address.payment_credential is {\n    VerificationKey(key_hash) -> Some(key_hash)\n    _ -> None\n  }\n}",
      "reExportedAs": ["cocktail.address_pub_key"]
    },
    {
      "key": "vodka:cocktail.vodka_address.address_script_hash",
      "fullName": "vodka:cocktail.vodka_address.address_script_hash",
      "name": "address_script_hash",
      "signature": "pub fn address_script_hash(address: Address) -> Option<ScriptHash> {",
      "documentation": "Obtain the script hash of an address, None if it is a verification key address\n```aiken\nexpect Some(script_hash) = address_pub_key(address)\n```",
      "parameters": [
        {
          "name": "address",
          "type": "Address",
          "optional": false
        }
      ],
      "returnType": "Option<ScriptHash>",
      "line": 51,
      "raw": "pub fn address_script_hash(address: Address) -> Option<ScriptHash> {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn address_script_hash(address: Address) -> Option<ScriptHash> {\n  when address.payment_credential is {\n    Script(script_hash) -> Some(script_hash)\n    _ -> None\n  }\n}",
      "reExportedAs": ["cocktail.address_script_hash"]
    },
    {
      "key": "vodka:cocktail.vodka_certificate.register_stake_certificate",
      "fullName": "vodka:cocktail.vodka_certificate.register_stake_certificate",
      "name": "register_stake_certificate",
      "signature": "pub fn register_stake_certificate(pub fn register_stake_certificate(certificates: List<Certificate>, credential: Credential, ) {",
      "documentation": "Check if a certain stake registration certificate exists in certificates.\n```aiken\nlet is_stake_registerd = register_stake_certificate(certificates, stake_credential)\n```",
      "parameters": [],
      "returnType": "Unknown",
      "line": 15,
      "raw": "pub fn register_stake_certificate(pub fn register_stake_certificate(certificates: List<Certificate>, credential: Credential, ) {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn register_stake_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n) {\n  list.has(certificates, RegisterCredential { credential, deposit: Never })\n}",
      "tests": [
        "test register_stake_certificate_found() {\n  let certificates =\n    [\n      RegisterCredential { credential: Script(\"\"), deposit: Never },\n      UnregisterCredential { credential: Script(\"\"), refund: Never },\n    ]\n\n  register_stake_certificate(certificates, Script(\"\")) == True\n}",
        "test register_stake_certificate_not_found() {\n  let certificates =\n    [\n      RegisterCredential { credential: Script(\"Not Found\"), deposit: Never },\n      UnregisterCredential { credential: Script(\"Not Found\"), refund: Never },\n    ]\n\n  register_stake_certificate(certificates, Script(\"\")) == False\n}"
      ]
    },
    {
      "key": "vodka:cocktail.vodka_certificate.unregister_stake_certificate",
      "fullName": "vodka:cocktail.vodka_certificate.unregister_stake_certificate",
      "name": "unregister_stake_certificate",
      "signature": "pub fn unregister_stake_certificate(pub fn unregister_stake_certificate(certificates: List<Certificate>, credential: Credential, ) {",
      "documentation": "Check if a certain stake unregistration certificate exists in certificates.\n```aiken\nlet is_stake_unregisterd = unregister_stake_certificate(certificates, stake_credential)\n```",
      "parameters": [],
      "returnType": "Unknown",
      "line": 46,
      "raw": "pub fn unregister_stake_certificate(pub fn unregister_stake_certificate(certificates: List<Certificate>, credential: Credential, ) {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn unregister_stake_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n) {\n  list.has(certificates, UnregisterCredential { credential, refund: Never })\n}",
      "tests": [
        "test unregister_stake_certificate_found() {\n  let certificates =\n    [\n      RegisterCredential { credential: Script(\"\"), deposit: Never },\n      UnregisterCredential { credential: Script(\"\"), refund: Never },\n    ]\n\n  unregister_stake_certificate(certificates, Script(\"\")) == True\n}",
        "test unregister_stake_certificate_not_found() {\n  let certificates =\n    [\n      RegisterCredential { credential: Script(\"Not Found\"), deposit: Never },\n      UnregisterCredential { credential: Script(\"Not Found\"), refund: Never },\n    ]\n\n  unregister_stake_certificate(certificates, Script(\"\")) == False\n}"
      ]
    },
    {
      "key": "vodka:cocktail.vodka_certificate.register_drep_certificate",
      "fullName": "vodka:cocktail.vodka_certificate.register_drep_certificate",
      "name": "register_drep_certificate",
      "signature": "pub fn register_drep_certificate(pub fn register_drep_certificate(certificates: List<Certificate>, credential: Credential, deposit: Lovelace, ) {",
      "documentation": "Check if a certain drep registration with specified deposit certificate exists in certificates.\n```aiken\nlet is_drep_registerd = register_drep_certificate(certificates, stake_credential, deposit)\n```",
      "parameters": [],
      "returnType": "Unknown",
      "line": 77,
      "raw": "pub fn register_drep_certificate(pub fn register_drep_certificate(certificates: List<Certificate>, credential: Credential, deposit: Lovelace, ) {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn register_drep_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n  deposit: Lovelace,\n) {\n  list.has(\n    certificates,\n    RegisterDelegateRepresentative {\n      delegate_representative: credential,\n      deposit,\n    },\n  )\n}",
      "tests": [
        "test register_drep_certificate_found() {\n  let certificates =\n    [\n      RegisterDelegateRepresentative {\n        delegate_representative: Script(\"\"),\n        deposit: 10,\n      },\n      UnregisterDelegateRepresentative {\n        delegate_representative: Script(\"\"),\n        refund: 10,\n      },\n    ]\n\n  register_drep_certificate(certificates, Script(\"\"), 10) == True\n}",
        "test register_drep_certificate_not_found_with_diff_cred() {\n  let certificates =\n    [\n      RegisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        deposit: 10,\n      },\n      UnregisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        refund: 10,\n      },\n    ]\n\n  register_drep_certificate(certificates, Script(\"\"), 10) == False\n}",
        "test register_drep_certificate_not_found_with_diff_deposit() {\n  let certificates =\n    [\n      RegisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        deposit: 0,\n      },\n      UnregisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        refund: 0,\n      },\n    ]\n\n  register_drep_certificate(certificates, Script(\"\"), 10) == False\n}"
      ]
    },
    {
      "key": "vodka:cocktail.vodka_certificate.unregister_drep_certificate",
      "fullName": "vodka:cocktail.vodka_certificate.unregister_drep_certificate",
      "name": "unregister_drep_certificate",
      "signature": "pub fn unregister_drep_certificate(pub fn unregister_drep_certificate(certificates: List<Certificate>, credential: Credential, refund: Lovelace, ) {",
      "documentation": "Check if a certain drep unregistration with specified refund certificate exists in certificates.\n```aiken\nlet is_drep_unregisterd = unregister_drep_certificate(certificates, stake_credential, refund)\n```",
      "parameters": [],
      "returnType": "Unknown",
      "line": 143,
      "raw": "pub fn unregister_drep_certificate(pub fn unregister_drep_certificate(certificates: List<Certificate>, credential: Credential, refund: Lovelace, ) {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn unregister_drep_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n  refund: Lovelace,\n) {\n  list.has(\n    certificates,\n    UnregisterDelegateRepresentative {\n      delegate_representative: credential,\n      refund,\n    },\n  )\n}",
      "tests": [
        "test unregister_drep_certificate_found() {\n  let certificates =\n    [\n      RegisterDelegateRepresentative {\n        delegate_representative: Script(\"\"),\n        deposit: 10,\n      },\n      UnregisterDelegateRepresentative {\n        delegate_representative: Script(\"\"),\n        refund: 10,\n      },\n    ]\n\n  unregister_drep_certificate(certificates, Script(\"\"), 10) == True\n}",
        "test unregister_drep_certificate_not_found_with_diff_cred() {\n  let certificates =\n    [\n      RegisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        deposit: 10,\n      },\n      UnregisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        refund: 10,\n      },\n    ]\n\n  unregister_drep_certificate(certificates, Script(\"\"), 10) == False\n}",
        "test unregister_drep_certificate_not_found_with_diff_refund() {\n  let certificates =\n    [\n      RegisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        deposit: 0,\n      },\n      UnregisterDelegateRepresentative {\n        delegate_representative: Script(\"Not Found\"),\n        refund: 0,\n      },\n    ]\n\n  unregister_drep_certificate(certificates, Script(\"\"), 10) == False\n}"
      ]
    },
    {
      "key": "vodka:cocktail.vodka_certificate.delegate_stake_certificate",
      "fullName": "vodka:cocktail.vodka_certificate.delegate_stake_certificate",
      "name": "delegate_stake_certificate",
      "signature": "pub fn delegate_stake_certificate(pub fn delegate_stake_certificate(certificates: List<Certificate>, credential: Credential, stake_pool: StakePoolId, ) {",
      "documentation": "Check if a certain stake delegation to a specificed pool certificate exists in certificates.\n```aiken\nlet is_stake_delegated = delegate_stake_certificate(certificates, stake_credential, stake_pool)\n```",
      "parameters": [],
      "returnType": "Unknown",
      "line": 209,
      "raw": "pub fn delegate_stake_certificate(pub fn delegate_stake_certificate(certificates: List<Certificate>, credential: Credential, stake_pool: StakePoolId, ) {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn delegate_stake_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n  stake_pool: StakePoolId,\n) {\n  list.has(\n    certificates,\n    DelegateCredential {\n      credential,\n      delegate: DelegateBlockProduction { stake_pool },\n    },\n  )\n}",
      "tests": [
        "test delegate_stake_certificate_found() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_stake_certificate(certificates, Script(\"\"), \"\") == True\n}",
        "test delegate_stake_certificate_not_found_with_diff_cred() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_stake_certificate(certificates, Script(\"\"), \"\") == False\n}",
        "test delegate_stake_certificate_not_found_with_diff_pool() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"Not Found\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_stake_certificate(certificates, Script(\"\"), \"\") == False\n}"
      ]
    },
    {
      "key": "vodka:cocktail.vodka_certificate.delegate_vote_certificate",
      "fullName": "vodka:cocktail.vodka_certificate.delegate_vote_certificate",
      "name": "delegate_vote_certificate",
      "signature": "pub fn delegate_vote_certificate(pub fn delegate_vote_certificate(certificates: List<Certificate>, credential: Credential, delegate_representative: DelegateRepresentative, ) {",
      "documentation": "Check if a certain voting power delegation to a specificed drep certificate exists in certificates.\n```aiken\nlet is_vote_delegated = delegate_vote_certificate(certificates, stake_credential, delegate_representative)\n```",
      "parameters": [],
      "returnType": "Unknown",
      "line": 281,
      "raw": "pub fn delegate_vote_certificate(pub fn delegate_vote_certificate(certificates: List<Certificate>, credential: Credential, delegate_representative: DelegateRepresentative, ) {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn delegate_vote_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n  delegate_representative: DelegateRepresentative,\n) {\n  list.has(\n    certificates,\n    DelegateCredential {\n      credential,\n      delegate: DelegateVote { delegate_representative },\n    },\n  )\n}",
      "tests": [
        "test delegate_vote_certificate_found() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_vote_certificate(certificates, Script(\"\"), Registered(Script(\"\"))) == True\n}",
        "test delegate_vote_certificate_not_found_with_diff_cred() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_vote_certificate(certificates, Script(\"\"), Registered(Script(\"\"))) == False\n}",
        "test delegate_vote_certificate_not_found_with_diff_drep() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"Not Found\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"Not Found\")),\n        },\n      },\n    ]\n\n  delegate_vote_certificate(certificates, Script(\"\"), Registered(Script(\"\"))) == False\n}"
      ]
    },
    {
      "key": "vodka:cocktail.vodka_certificate.delegate_stake_and_vote_certificate",
      "fullName": "vodka:cocktail.vodka_certificate.delegate_stake_and_vote_certificate",
      "name": "delegate_stake_and_vote_certificate",
      "signature": "pub fn delegate_stake_and_vote_certificate(pub fn delegate_stake_and_vote_certificate(certificates: List<Certificate>, credential: Credential, stake_pool: StakePoolId, delegate_representative: DelegateRepresentative, ) {",
      "documentation": "Check if a certain delegation to a specificed pool and drep certificate exists in certificates.\n```aiken\nlet is_stake_and_vote_delegated = delegate_stake_and_vote_certificate(certificates, stake_credential, stake_pool, delegate_representative)\n```",
      "parameters": [],
      "returnType": "Unknown",
      "line": 353,
      "raw": "pub fn delegate_stake_and_vote_certificate(pub fn delegate_stake_and_vote_certificate(certificates: List<Certificate>, credential: Credential, stake_pool: StakePoolId, delegate_representative: DelegateRepresentative, ) {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn delegate_stake_and_vote_certificate(\n  certificates: List<Certificate>,\n  credential: Credential,\n  stake_pool: StakePoolId,\n  delegate_representative: DelegateRepresentative,\n) {\n  list.has(\n    certificates,\n    DelegateCredential {\n      credential,\n      delegate: DelegateBoth { stake_pool, delegate_representative },\n    },\n  )\n}",
      "tests": [
        "test delegate_stake_and_vote_certificate_found() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBoth {\n          stake_pool: \"\",\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_stake_and_vote_certificate(\n    certificates,\n    Script(\"\"),\n    \"\",\n    Registered(Script(\"\")),\n  ) == True\n}",
        "test delegate_stake_and_vote_certificate_not_found_with_diff_cred() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n      DelegateCredential {\n        credential: Script(\"Not Found\"),\n        delegate: DelegateBoth {\n          stake_pool: \"\",\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_stake_and_vote_certificate(\n    certificates,\n    Script(\"\"),\n    \"\",\n    Registered(Script(\"\")),\n  ) == False\n}",
        "test delegate_stake_and_vote_certificate_not_found_with_diff_drep() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBoth {\n          stake_pool: \"\",\n          delegate_representative: Registered(Script(\"Not Found\")),\n        },\n      },\n    ]\n\n  delegate_stake_and_vote_certificate(\n    certificates,\n    Script(\"\"),\n    \"\",\n    Registered(Script(\"\")),\n  ) == False\n}",
        "test delegate_stake_and_vote_certificate_not_found_with_diff_pool() {\n  let certificates =\n    [\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBlockProduction { stake_pool: \"\" },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateVote {\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n      DelegateCredential {\n        credential: Script(\"\"),\n        delegate: DelegateBoth {\n          stake_pool: \"Not Found\",\n          delegate_representative: Registered(Script(\"\")),\n        },\n      },\n    ]\n\n  delegate_stake_and_vote_certificate(\n    certificates,\n    Script(\"\"),\n    \"\",\n    Registered(Script(\"\")),\n  ) == False\n}"
      ]
    },
    {
      "key": "vodka:cocktail.vodka_converter.convert_int_to_bytes",
      "fullName": "vodka:cocktail.vodka_converter.convert_int_to_bytes",
      "name": "convert_int_to_bytes",
      "signature": "pub fn convert_int_to_bytes(i: Int) -> ByteArray {",
      "documentation": "Convert an integer to a \"stringify\" ByteArray value\n```aiken\nlet int_bytes = convert_int_to_bytes(123)\nlet this_is_true = int_bytes == \"123\"\n```",
      "parameters": [
        {
          "name": "i",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 8,
      "raw": "pub fn convert_int_to_bytes(i: Int) -> ByteArray {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn convert_int_to_bytes(i: Int) -> ByteArray {\n  convert_int_to_bytes_go(i, get_number_digit(i))\n}",
      "reExportedAs": ["cocktail.convert_int_to_bytes"]
    },
    {
      "key": "vodka:cocktail.vodka_converter.get_number_digit",
      "fullName": "vodka:cocktail.vodka_converter.get_number_digit",
      "name": "get_number_digit",
      "signature": "pub fn get_number_digit(i: Int) -> Int {",
      "documentation": "Get the number of digits in an integer",
      "parameters": [
        {
          "name": "i",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 24,
      "raw": "pub fn get_number_digit(i: Int) -> Int {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn get_number_digit(i: Int) -> Int {\n  go_get_number_digit(i, 1)\n}",
      "reExportedAs": ["cocktail.get_number_digit"]
    },
    {
      "key": "vodka:cocktail.vodka_extra_signatories.key_signed",
      "fullName": "vodka:cocktail.vodka_extra_signatories.key_signed",
      "name": "key_signed",
      "signature": "pub fn key_signed(extra_signatories: List<ByteArray>, key: ByteArray) {",
      "documentation": "Check if a key is signed by any of the extra_signatories\n```aiken\nlet extra_signatories = [\"key1\", \"key2\", \"key3\"]\n\nlet key_to_test_1 = \"key2\"\nlet this_is_true = key_signed(extra_signatories, key_to_test_1)\n\nlet key_to_test_2 = \"key4\"\nlet this_is_false = key_signed(extra_signatories, key_to_test_2)\n```",
      "parameters": [
        {
          "name": "extra_signatories",
          "type": "List<ByteArray>",
          "optional": false
        },
        {
          "name": "key",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 13,
      "raw": "pub fn key_signed(extra_signatories: List<ByteArray>, key: ByteArray) {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn key_signed(extra_signatories: List<ByteArray>, key: ByteArray) {\n  list.has(extra_signatories, key)\n}",
      "reExportedAs": ["cocktail.key_signed"]
    },
    {
      "key": "vodka:cocktail.vodka_extra_signatories.one_of_keys_signed",
      "fullName": "vodka:cocktail.vodka_extra_signatories.one_of_keys_signed",
      "name": "one_of_keys_signed",
      "signature": "pub fn one_of_keys_signed(pub fn one_of_keys_signed(extra_signatories: List<ByteArray>, keys: List<ByteArray>, ) {",
      "documentation": "Check if any of the keys are signed by the extra_signatories\n```aiken\nlet extra_signatories = [\"key1\", \"key2\", \"key3\"]\n\nlet keys_to_test_1 = [\"key4\", \"key2\", \"key5\"]\nlet this_is_true = one_of_keys_signed(extra_signatories, keys_to_test_1)\n\nlet keys_to_test_2 = [\"key4\", \"key5\"]\nlet this_is_false = one_of_keys_signed(extra_signatories, keys_to_test_2)\n```",
      "parameters": [],
      "returnType": "Unknown",
      "line": 27,
      "raw": "pub fn one_of_keys_signed(pub fn one_of_keys_signed(extra_signatories: List<ByteArray>, keys: List<ByteArray>, ) {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn one_of_keys_signed(\n  extra_signatories: List<ByteArray>,\n  keys: List<ByteArray>,\n) {\n  list.any(keys, fn(key) { key_signed(extra_signatories, key) })\n}",
      "reExportedAs": ["cocktail.one_of_keys_signed"]
    },
    {
      "key": "vodka:cocktail.vodka_extra_signatories.all_key_signed",
      "fullName": "vodka:cocktail.vodka_extra_signatories.all_key_signed",
      "name": "all_key_signed",
      "signature": "pub fn all_key_signed(extra_signatories: List<ByteArray>, keys: List<ByteArray>) {",
      "documentation": "Check if all of the keys are signed by the extra_signatories\n```aiken\nlet extra_signatories = [\"key1\", \"key2\", \"key3\"]\n\nlet keys_to_test_1 = [\"key2\", \"key3\"]\nlet this_is_true = all_keys_signed(extra_signatories, keys_to_test_1)\n\nlet keys_to_test_2 = [\"key2\", \"key4\"]\nlet this_is_false = all_keys_signed(extra_signatories, keys_to_test_2)\n```",
      "parameters": [
        {
          "name": "extra_signatories",
          "type": "List<ByteArray>",
          "optional": false
        },
        {
          "name": "keys",
          "type": "List<ByteArray>",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 44,
      "raw": "pub fn all_key_signed(extra_signatories: List<ByteArray>, keys: List<ByteArray>) {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn all_key_signed(extra_signatories: List<ByteArray>, keys: List<ByteArray>) {\n  list.all(keys, fn(key) { key_signed(extra_signatories, key) })\n}",
      "reExportedAs": ["cocktail.all_key_signed"]
    },
    {
      "key": "vodka:cocktail.vodka_inputs.input_inline_datum",
      "fullName": "vodka:cocktail.vodka_inputs.input_inline_datum",
      "name": "input_inline_datum",
      "signature": "pub fn input_inline_datum(input: Input) {",
      "documentation": "Extracts the inline datum from an input.\n```aiken\nexpect inline_datum: MyDatumType = input_inline_datum(input)\n```",
      "parameters": [
        {
          "name": "input",
          "type": "Input",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 10,
      "raw": "pub fn input_inline_datum(input: Input) {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn input_inline_datum(input: Input) {\n  expect InlineDatum(raw_datum) = input.output.datum\n  raw_datum\n}",
      "reExportedAs": ["cocktail.input_inline_datum"]
    },
    {
      "key": "vodka:cocktail.vodka_inputs.only_input_datum_with",
      "fullName": "vodka:cocktail.vodka_inputs.only_input_datum_with",
      "name": "only_input_datum_with",
      "signature": "pub fn only_input_datum_with(pub fn only_input_datum_with(inputs: List<Input>, policy: PolicyId, name: AssetName, ) {",
      "documentation": "Extract the inline datum by locating the first input in a list of inputs by Address and PolicyId.\n```aiken\nexpect inline_datum: MyDatumType = only_input_datum_with(inputs, policy, name)\n```",
      "parameters": [],
      "returnType": "Unknown",
      "line": 19,
      "raw": "pub fn only_input_datum_with(pub fn only_input_datum_with(inputs: List<Input>, policy: PolicyId, name: AssetName, ) {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn only_input_datum_with(\n  inputs: List<Input>,\n  policy: PolicyId,\n  name: AssetName,\n) {\n  expect Some(input) =\n    list.find(\n      inputs,\n      fn(input) { quantity_of(input.output.value, policy, name) == 1 },\n    )\n  input_inline_datum(input)\n}",
      "reExportedAs": ["cocktail.only_input_datum_with"]
    },
    {
      "key": "vodka:cocktail.vodka_inputs.inputs_at",
      "fullName": "vodka:cocktail.vodka_inputs.inputs_at",
      "name": "inputs_at",
      "signature": "pub fn inputs_at(inputs: List<Input>, address: Address) -> List<Input> {",
      "documentation": "Filters inputs by Address.\n```aiken\nlet filtered_inputs = inputs_at(inputs, address)\n```",
      "parameters": [
        {
          "name": "inputs",
          "type": "List<Input>",
          "optional": false
        },
        {
          "name": "address",
          "type": "Address",
          "optional": false
        }
      ],
      "returnType": "List<Input>",
      "line": 36,
      "raw": "pub fn inputs_at(inputs: List<Input>, address: Address) -> List<Input> {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn inputs_at(inputs: List<Input>, address: Address) -> List<Input> {\n  list.filter(inputs, fn(input) { input.output.address == address })\n}",
      "reExportedAs": ["cocktail.inputs_at"]
    },
    {
      "key": "vodka:cocktail.vodka_inputs.inputs_with",
      "fullName": "vodka:cocktail.vodka_inputs.inputs_with",
      "name": "inputs_with",
      "signature": "pub fn inputs_with(pub fn inputs_with(inputs: List<Input>, policy: PolicyId, name: AssetName, ) -> List<Input> {",
      "documentation": "Filters inputs by PolicyId and AssetName.\n```aiken\nlet filtered_inputs = inputs_with(inputs, policy, name)\n```",
      "parameters": [],
      "returnType": "List<Input>",
      "line": 44,
      "raw": "pub fn inputs_with(pub fn inputs_with(inputs: List<Input>, policy: PolicyId, name: AssetName, ) -> List<Input> {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn inputs_with(\n  inputs: List<Input>,\n  policy: PolicyId,\n  name: AssetName,\n) -> List<Input> {\n  list.filter(\n    inputs,\n    fn(input) { quantity_of(input.output.value, policy, name) == 1 },\n  )\n}",
      "reExportedAs": ["cocktail.inputs_with"]
    },
    {
      "key": "vodka:cocktail.vodka_inputs.inputs_with_policy",
      "fullName": "vodka:cocktail.vodka_inputs.inputs_with_policy",
      "name": "inputs_with_policy",
      "signature": "pub fn inputs_with_policy(inputs: List<Input>, policy: PolicyId) -> List<Input> {",
      "documentation": "Filters inputs by token policy.\n```aiken\nlet filtered_inputs = inputs_with_policy(inputs, policy)\n```",
      "parameters": [
        {
          "name": "inputs",
          "type": "List<Input>",
          "optional": false
        },
        {
          "name": "policy",
          "type": "PolicyId",
          "optional": false
        }
      ],
      "returnType": "List<Input>",
      "line": 59,
      "raw": "pub fn inputs_with_policy(inputs: List<Input>, policy: PolicyId) -> List<Input> {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn inputs_with_policy(inputs: List<Input>, policy: PolicyId) -> List<Input> {\n  list.filter(\n    inputs,\n    fn(input) {\n      list.any(flatten(input.output.value), fn(token) { token.1st == policy })\n    },\n  )\n}",
      "reExportedAs": ["cocktail.inputs_with_policy"]
    },
    {
      "key": "vodka:cocktail.vodka_inputs.inputs_at_with",
      "fullName": "vodka:cocktail.vodka_inputs.inputs_at_with",
      "name": "inputs_at_with",
      "signature": "pub fn inputs_at_with(pub fn inputs_at_with(inputs: List<Input>, address: Address, policy: PolicyId, name: AssetName, ) -> List<Input> {",
      "documentation": "Filters inputs by Address, PolicyId, and AssetName.\n```aiken\nlet filtered_inputs = inputs_at_with(inputs, address, policy, name)\n```",
      "parameters": [],
      "returnType": "List<Input>",
      "line": 72,
      "raw": "pub fn inputs_at_with(pub fn inputs_at_with(inputs: List<Input>, address: Address, policy: PolicyId, name: AssetName, ) -> List<Input> {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn inputs_at_with(\n  inputs: List<Input>,\n  address: Address,\n  policy: PolicyId,\n  name: AssetName,\n) -> List<Input> {\n  list.filter(\n    inputs,\n    fn(input) {\n      input.output.address == address && quantity_of(\n        input.output.value,\n        policy,\n        name,\n      ) == 1\n    },\n  )\n}",
      "reExportedAs": ["cocktail.inputs_at_with"]
    },
    {
      "key": "vodka:cocktail.vodka_inputs.inputs_at_with_policy",
      "fullName": "vodka:cocktail.vodka_inputs.inputs_at_with_policy",
      "name": "inputs_at_with_policy",
      "signature": "pub fn inputs_at_with_policy(pub fn inputs_at_with_policy(inputs: List<Input>, address: Address, policy: PolicyId, ) -> List<Input> {",
      "documentation": "Filters inputs by Address and PolicyId.\n```aiken\nlet filtered_inputs = inputs_at_with_policy(inputs, address, policy)\n```",
      "parameters": [],
      "returnType": "List<Input>",
      "line": 94,
      "raw": "pub fn inputs_at_with_policy(pub fn inputs_at_with_policy(inputs: List<Input>, address: Address, policy: PolicyId, ) -> List<Input> {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn inputs_at_with_policy(\n  inputs: List<Input>,\n  address: Address,\n  policy: PolicyId,\n) -> List<Input> {\n  list.filter(\n    inputs,\n    fn(input) {\n      input.output.address == address && list.any(\n        flatten(input.output.value),\n        fn(token) { token.1st == policy },\n      )\n    },\n  )\n}",
      "reExportedAs": ["cocktail.inputs_at_with_policy"]
    },
    {
      "key": "vodka:cocktail.vodka_inputs.inputs_token_quantity",
      "fullName": "vodka:cocktail.vodka_inputs.inputs_token_quantity",
      "name": "inputs_token_quantity",
      "signature": "pub fn inputs_token_quantity(pub fn inputs_token_quantity(inputs: List<Input>, token: (PolicyId, AssetName),",
      "documentation": "Calculate the total quantity of a token in a list of inputs.\n```aiken\nlet total_quantity = inputs_token_quantity(inputs, token)\n```",
      "parameters": [],
      "returnType": "Unknown",
      "line": 114,
      "raw": "pub fn inputs_token_quantity(pub fn inputs_token_quantity(inputs: List<Input>, token: (PolicyId, AssetName),",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn inputs_token_quantity(\n  inputs: List<Input>,\n  token: (PolicyId, AssetName),\n) -> Int {\n  list.map(\n    inputs,\n    fn(input) { quantity_of(input.output.value, token.1st, token.2nd) },\n  )\n    |> list.foldr(0, fn(n, total) { n + total })\n}",
      "reExportedAs": ["cocktail.inputs_token_quantity"]
    },
    {
      "key": "vodka:cocktail.vodka_mints.check_policy_only_burn",
      "fullName": "vodka:cocktail.vodka_mints.check_policy_only_burn",
      "name": "check_policy_only_burn",
      "signature": "pub fn check_policy_only_burn(mint: Value, policy: PolicyId) -> Bool {",
      "documentation": "Check if a certain PolicyId is burning only if exists in the minted value.\n```aiken\nlet is_policy_only_burn = check_policy_only_burn(minted_value, policy)\n```",
      "parameters": [
        {
          "name": "mint",
          "type": "Value",
          "optional": false
        },
        {
          "name": "policy",
          "type": "PolicyId",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 8,
      "raw": "pub fn check_policy_only_burn(mint: Value, policy: PolicyId) -> Bool {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn check_policy_only_burn(mint: Value, policy: PolicyId) -> Bool {\n  let mint_value = flatten(mint)\n  list.all(\n    mint_value,\n    fn(x) {\n      if x.1st == policy {\n        x.3rd < 0\n      } else {\n        True\n      }\n    },\n  )\n}",
      "reExportedAs": ["cocktail.check_policy_only_burn"]
    },
    {
      "key": "vodka:cocktail.vodka_mints.policy_only_minted_token",
      "fullName": "vodka:cocktail.vodka_mints.policy_only_minted_token",
      "name": "policy_only_minted_token",
      "signature": "pub fn policy_only_minted_token(pub fn policy_only_minted_token(mint: Value, policy: PolicyId, name: AssetName, quantity: Int, ) {",
      "documentation": "Check if a certain policy has only minted this token.\n```aiken\nlet is_policy_only_minted = check_policy_only_minted(minted_value, policy, name, quantity)\n```",
      "parameters": [],
      "returnType": "Unknown",
      "line": 26,
      "raw": "pub fn policy_only_minted_token(pub fn policy_only_minted_token(mint: Value, policy: PolicyId, name: AssetName, quantity: Int, ) {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn policy_only_minted_token(\n  mint: Value,\n  policy: PolicyId,\n  name: AssetName,\n  quantity: Int,\n) {\n  when flatten(mint) |> list.filter(fn(asset) { asset.1st == policy }) is {\n    [(_, minted_asset_name, minted_quantity)] ->\n      minted_asset_name == name && minted_quantity == quantity\n    _ -> False\n  }\n}",
      "reExportedAs": ["cocktail.policy_only_minted_token"]
    },
    {
      "key": "vodka:cocktail.vodka_mints.only_minted_token",
      "fullName": "vodka:cocktail.vodka_mints.only_minted_token",
      "name": "only_minted_token",
      "signature": "pub fn only_minted_token(pub fn only_minted_token(mint: Value, policy: PolicyId, name: AssetName, quantity: Int, ) {",
      "documentation": "Check if the minted value contains only one distinct asset with particular PolicyId.\n```aiken\nlet is_only_minted_token = only_minted_token(minted_value, policy, name, quantity)\n```",
      "parameters": [],
      "returnType": "Unknown",
      "line": 43,
      "raw": "pub fn only_minted_token(pub fn only_minted_token(mint: Value, policy: PolicyId, name: AssetName, quantity: Int, ) {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn only_minted_token(\n  mint: Value,\n  policy: PolicyId,\n  name: AssetName,\n  quantity: Int,\n) {\n  when flatten(mint) is {\n    [(minted_policy, minted_asset_name, minted_quantity)] ->\n      minted_policy == policy && minted_asset_name == name && minted_quantity == quantity\n    _ -> False\n  }\n}",
      "reExportedAs": ["cocktail.only_minted_token"]
    },
    {
      "key": "vodka:cocktail.vodka_mints.token_minted",
      "fullName": "vodka:cocktail.vodka_mints.token_minted",
      "name": "token_minted",
      "signature": "pub fn token_minted(pub fn token_minted(mint: Value, policy: PolicyId, name: AssetName, quantity: Int, ) {",
      "documentation": "Check if the minted value contains a token with particular PolicyId, AssetName, and quantity.\n```aiken\nlet is_token_minted = token_minted(minted_value, policy, name, quantity)\n```",
      "parameters": [],
      "returnType": "Unknown",
      "line": 60,
      "raw": "pub fn token_minted(pub fn token_minted(mint: Value, policy: PolicyId, name: AssetName, quantity: Int, ) {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn token_minted(\n  mint: Value,\n  policy: PolicyId,\n  name: AssetName,\n  quantity: Int,\n) {\n  flatten(mint)\n    |> list.any(fn(x) { x.1st == policy && x.2nd == name && x.3rd == quantity })\n}",
      "reExportedAs": ["cocktail.token_minted"]
    },
    {
      "key": "vodka:cocktail.vodka_outputs.output_inline_datum",
      "fullName": "vodka:cocktail.vodka_outputs.output_inline_datum",
      "name": "output_inline_datum",
      "signature": "pub fn output_inline_datum(output: Output) {",
      "documentation": "Extracts the inline datum from an output.\n```aiken\nexpect inline_datum: MyDatumType = output_inline_datum(output)\n```",
      "parameters": [
        {
          "name": "output",
          "type": "Output",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 10,
      "raw": "pub fn output_inline_datum(output: Output) {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn output_inline_datum(output: Output) {\n  expect InlineDatum(raw_datum) = output.datum\n  raw_datum\n}",
      "reExportedAs": ["cocktail.output_inline_datum"]
    },
    {
      "key": "vodka:cocktail.vodka_outputs.outputs_at",
      "fullName": "vodka:cocktail.vodka_outputs.outputs_at",
      "name": "outputs_at",
      "signature": "pub fn outputs_at(outputs: List<Output>, address: Address) -> List<Output> {",
      "documentation": "Filters outputs by Address.\n```aiken\nlet filtered_outputs = outputs_at(outputs, address)\n```",
      "parameters": [
        {
          "name": "outputs",
          "type": "List<Output>",
          "optional": false
        },
        {
          "name": "address",
          "type": "Address",
          "optional": false
        }
      ],
      "returnType": "List<Output>",
      "line": 19,
      "raw": "pub fn outputs_at(outputs: List<Output>, address: Address) -> List<Output> {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn outputs_at(outputs: List<Output>, address: Address) -> List<Output> {\n  list.filter(outputs, fn(output) { output.address == address })\n}",
      "reExportedAs": ["cocktail.outputs_at"]
    },
    {
      "key": "vodka:cocktail.vodka_outputs.outputs_with",
      "fullName": "vodka:cocktail.vodka_outputs.outputs_with",
      "name": "outputs_with",
      "signature": "pub fn outputs_with(pub fn outputs_with(outputs: List<Output>, policy: PolicyId, name: AssetName, ) -> List<Output> {",
      "documentation": "Filters outputs by PolicyId and AssetName.\n```aiken\nlet filtered_outputs = outputs_with(outputs, policy, name)\n```",
      "parameters": [],
      "returnType": "List<Output>",
      "line": 27,
      "raw": "pub fn outputs_with(pub fn outputs_with(outputs: List<Output>, policy: PolicyId, name: AssetName, ) -> List<Output> {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn outputs_with(\n  outputs: List<Output>,\n  policy: PolicyId,\n  name: AssetName,\n) -> List<Output> {\n  list.filter(\n    outputs,\n    fn(output) { quantity_of(output.value, policy, name) == 1 },\n  )\n}",
      "reExportedAs": ["cocktail.outputs_with"]
    },
    {
      "key": "vodka:cocktail.vodka_outputs.outputs_with_policy",
      "fullName": "vodka:cocktail.vodka_outputs.outputs_with_policy",
      "name": "outputs_with_policy",
      "signature": "pub fn outputs_with_policy(pub fn outputs_with_policy(outputs: List<Output>, policy: PolicyId, ) -> List<Output> {",
      "documentation": "Filters outputs by token policy.\n```aiken\nlet filtered_outputs = outputs_with_policy(outputs, policy)\n```",
      "parameters": [],
      "returnType": "List<Output>",
      "line": 42,
      "raw": "pub fn outputs_with_policy(pub fn outputs_with_policy(outputs: List<Output>, policy: PolicyId, ) -> List<Output> {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn outputs_with_policy(\n  outputs: List<Output>,\n  policy: PolicyId,\n) -> List<Output> {\n  list.filter(\n    outputs,\n    fn(output) {\n      list.any(flatten(output.value), fn(token) { token.1st == policy })\n    },\n  )\n}",
      "reExportedAs": ["cocktail.outputs_with_policy"]
    },
    {
      "key": "vodka:cocktail.vodka_outputs.outputs_at_with",
      "fullName": "vodka:cocktail.vodka_outputs.outputs_at_with",
      "name": "outputs_at_with",
      "signature": "pub fn outputs_at_with(pub fn outputs_at_with(outputs: List<Output>, address: Address, policy: PolicyId, name: AssetName, ) -> List<Output> {",
      "documentation": "Filters outputs by Address, PolicyId, and AssetName.\n```aiken\nlet filtered_outputs = outputs_at_with(outputs, address, policy, name)\n```",
      "parameters": [],
      "returnType": "List<Output>",
      "line": 58,
      "raw": "pub fn outputs_at_with(pub fn outputs_at_with(outputs: List<Output>, address: Address, policy: PolicyId, name: AssetName, ) -> List<Output> {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn outputs_at_with(\n  outputs: List<Output>,\n  address: Address,\n  policy: PolicyId,\n  name: AssetName,\n) -> List<Output> {\n  list.filter(\n    outputs,\n    fn(output) {\n      output.address == address && quantity_of(output.value, policy, name) == 1\n    },\n  )\n}",
      "reExportedAs": ["cocktail.outputs_at_with"]
    },
    {
      "key": "vodka:cocktail.vodka_outputs.outputs_at_with_policy",
      "fullName": "vodka:cocktail.vodka_outputs.outputs_at_with_policy",
      "name": "outputs_at_with_policy",
      "signature": "pub fn outputs_at_with_policy(pub fn outputs_at_with_policy(outputs: List<Output>, address: Address, policy: PolicyId, ) -> List<Output> {",
      "documentation": "Filters outputs by Address and PolicyId.\n```aiken\nlet filtered_outputs = outputs_at_with_policy(outputs, address, policy)\n```",
      "parameters": [],
      "returnType": "List<Output>",
      "line": 76,
      "raw": "pub fn outputs_at_with_policy(pub fn outputs_at_with_policy(outputs: List<Output>, address: Address, policy: PolicyId, ) -> List<Output> {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn outputs_at_with_policy(\n  outputs: List<Output>,\n  address: Address,\n  policy: PolicyId,\n) -> List<Output> {\n  list.filter(\n    outputs,\n    fn(output) {\n      output.address == address && list.any(\n        flatten(output.value),\n        fn(token) { token.1st == policy },\n      )\n    },\n  )\n}",
      "reExportedAs": ["cocktail.outputs_at_with_policy"]
    },
    {
      "key": "vodka:cocktail.vodka_redeemers.redeemer_from",
      "fullName": "vodka:cocktail.vodka_redeemers.redeemer_from",
      "name": "redeemer_from",
      "signature": "pub fn redeemer_from(pub fn redeemer_from(redeemers: Pairs<ScriptPurpose, Redeemer>, inputs: List<Input>, output_reference: OutputReference, input_address: Address, ) -> Option<Data> {",
      "documentation": "Obtain the redeemer for a given output reference and address\n```aiken\nexpect Some(redeemer) = redeemer_from(redeemers, inputs, output_reference, input_address)\n```",
      "parameters": [],
      "returnType": "Option<Data>",
      "line": 12,
      "raw": "pub fn redeemer_from(pub fn redeemer_from(redeemers: Pairs<ScriptPurpose, Redeemer>, inputs: List<Input>, output_reference: OutputReference, input_address: Address, ) -> Option<Data> {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn redeemer_from(\n  redeemers: Pairs<ScriptPurpose, Redeemer>,\n  inputs: List<Input>,\n  output_reference: OutputReference,\n  input_address: Address,\n) -> Option<Data> {\n  expect Some(redeemer) = redeemers |> pairs.get_first(Spend(output_reference))\n  expect Some(input) = find_input(inputs, output_reference)\n  if input.output.address == input_address {\n    Some(redeemer)\n  } else {\n    None\n  }\n}",
      "reExportedAs": ["cocktail.redeemer_from"]
    },
    {
      "key": "vodka:cocktail.vodka_redeemers.withdrawal_redeemer",
      "fullName": "vodka:cocktail.vodka_redeemers.withdrawal_redeemer",
      "name": "withdrawal_redeemer",
      "signature": "pub fn withdrawal_redeemer(pub fn withdrawal_redeemer(redeemers: Pairs<ScriptPurpose, Redeemer>, withdrawal_script_hash: ByteArray, ) -> Option<Data> {",
      "documentation": "Obtain the first redeemer for a given withdrawal script hash\n```aiken\nexpect Some(raw_redeemer) = withdrawal_redeemer(redeemers, withdrawal_script_hash)\nexpect my_redeemer: MyRedeemerType = raw_redeemer;\n```",
      "parameters": [],
      "returnType": "Option<Data>",
      "line": 32,
      "raw": "pub fn withdrawal_redeemer(pub fn withdrawal_redeemer(redeemers: Pairs<ScriptPurpose, Redeemer>, withdrawal_script_hash: ByteArray, ) -> Option<Data> {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn withdrawal_redeemer(\n  redeemers: Pairs<ScriptPurpose, Redeemer>,\n  withdrawal_script_hash: ByteArray,\n) -> Option<Data> {\n  redeemers\n    |> pairs.get_first(Withdraw(Script(withdrawal_script_hash)))\n}",
      "reExportedAs": ["cocktail.withdrawal_redeemer"]
    },
    {
      "key": "vodka:cocktail.vodka_redeemers.compare_output_reference",
      "fullName": "vodka:cocktail.vodka_redeemers.compare_output_reference",
      "name": "compare_output_reference",
      "signature": "pub fn compare_output_reference(x, y) {",
      "documentation": "Compare the output reference of two spend transactions",
      "parameters": [
        {
          "name": "x",
          "type": "Unknown",
          "optional": false
        },
        {
          "name": "y",
          "type": "Unknown",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 41,
      "raw": "pub fn compare_output_reference(x, y) {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn compare_output_reference(x, y) {\n  expect Spend(out_ref_x) = x\n  expect Spend(out_ref_y) = y\n  bytearray.compare(out_ref_x.transaction_id, out_ref_y.transaction_id)\n}",
      "reExportedAs": ["cocktail.compare_output_reference"]
    },
    {
      "key": "vodka:cocktail.vodka_validity_range.valid_after",
      "fullName": "vodka:cocktail.vodka_validity_range.valid_after",
      "name": "valid_after",
      "signature": "pub fn valid_after(pub fn valid_after(validity_range: ValidityRange, required_timestamp: Int, ) -> Bool {",
      "documentation": "Check if the validity range is after the required timestamp.\n```aiken\nlet is_valid_after = valid_after(transaction.validity_range, required_timestamp)\n```",
      "parameters": [],
      "returnType": "Bool",
      "line": 8,
      "raw": "pub fn valid_after(pub fn valid_after(validity_range: ValidityRange, required_timestamp: Int, ) -> Bool {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn valid_after(\n  validity_range: ValidityRange,\n  required_timestamp: Int,\n) -> Bool {\n  let IntervalBound { bound_type, is_inclusive } = validity_range.lower_bound\n  when (bound_type, is_inclusive) is {\n    (Finite(lower_bound), True) -> lower_bound > required_timestamp\n    (Finite(lower_bound), False) -> lower_bound >= required_timestamp\n    _ -> False\n  }\n}",
      "reExportedAs": ["cocktail.valid_after"]
    },
    {
      "key": "vodka:cocktail.vodka_validity_range.valid_before",
      "fullName": "vodka:cocktail.vodka_validity_range.valid_before",
      "name": "valid_before",
      "signature": "pub fn valid_before(pub fn valid_before(validity_range: ValidityRange, required_timestamp: Int, ) -> Bool {",
      "documentation": "Check if the validity range is before the required timestamp.\n```aiken\nlet is_valid_before = valid_before(transaction.validity_range, required_timestamp)\n```",
      "parameters": [],
      "returnType": "Bool",
      "line": 24,
      "raw": "pub fn valid_before(pub fn valid_before(validity_range: ValidityRange, required_timestamp: Int, ) -> Bool {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn valid_before(\n  validity_range: ValidityRange,\n  required_timestamp: Int,\n) -> Bool {\n  let IntervalBound { bound_type, is_inclusive } = validity_range.upper_bound\n  when (bound_type, is_inclusive) is {\n    (Finite(upper_bound), True) -> upper_bound < required_timestamp\n    (Finite(upper_bound), False) -> upper_bound <= required_timestamp\n    _ -> False\n  }\n}",
      "reExportedAs": ["cocktail.valid_before"]
    },
    {
      "key": "vodka:cocktail.vodka_value.value_length",
      "fullName": "vodka:cocktail.vodka_value.value_length",
      "name": "value_length",
      "signature": "pub fn value_length(value: Value) -> Int {",
      "documentation": "Calulate the length of a value\n```aiken\nlet value_length = value_length(value)\n```",
      "parameters": [
        {
          "name": "value",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 12,
      "raw": "pub fn value_length(value: Value) -> Int {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn value_length(value: Value) -> Int {\n  list.length(flatten(value))\n}",
      "reExportedAs": ["cocktail.value_length"]
    },
    {
      "key": "vodka:cocktail.vodka_value.get_all_value_to",
      "fullName": "vodka:cocktail.vodka_value.get_all_value_to",
      "name": "get_all_value_to",
      "signature": "pub fn get_all_value_to(outputs: List<Output>, address: Address) -> Value {",
      "documentation": "Get the value send to a particular address in a list of outputs\n```aiken\nlet value_to = get_all_value_to(outputs, address)\n```",
      "parameters": [
        {
          "name": "outputs",
          "type": "List<Output>",
          "optional": false
        },
        {
          "name": "address",
          "type": "Address",
          "optional": false
        }
      ],
      "returnType": "Value",
      "line": 20,
      "raw": "pub fn get_all_value_to(outputs: List<Output>, address: Address) -> Value {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn get_all_value_to(outputs: List<Output>, address: Address) -> Value {\n  list.foldr(\n    outputs,\n    zero,\n    fn(output, acc_value) {\n      if output.address == address {\n        merge(acc_value, output.value)\n      } else {\n        acc_value\n      }\n    },\n  )\n}",
      "reExportedAs": ["cocktail.get_all_value_to"]
    },
    {
      "key": "vodka:cocktail.vodka_value.get_all_value_from",
      "fullName": "vodka:cocktail.vodka_value.get_all_value_from",
      "name": "get_all_value_from",
      "signature": "pub fn get_all_value_from(inputs: List<Input>, address: Address) -> Value {",
      "documentation": "Get the value coming from a particular address in a list of inputs\n```aiken\nlet value_from = get_all_value_from(inputs, address)\n```",
      "parameters": [
        {
          "name": "inputs",
          "type": "List<Input>",
          "optional": false
        },
        {
          "name": "address",
          "type": "Address",
          "optional": false
        }
      ],
      "returnType": "Value",
      "line": 38,
      "raw": "pub fn get_all_value_from(inputs: List<Input>, address: Address) -> Value {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn get_all_value_from(inputs: List<Input>, address: Address) -> Value {\n  list.foldr(\n    inputs,\n    zero,\n    fn(input, acc_value) {\n      if input.output.address == address {\n        merge(acc_value, input.output.value)\n      } else {\n        acc_value\n      }\n    },\n  )\n}",
      "reExportedAs": ["cocktail.get_all_value_from"]
    },
    {
      "key": "vodka:cocktail.vodka_value.value_geq",
      "fullName": "vodka:cocktail.vodka_value.value_geq",
      "name": "value_geq",
      "signature": "pub fn value_geq(greater: Value, smaller: Value) -> Bool {",
      "documentation": "Check if the first value provided is greater than or equal to the second value\n```aiken\nlet is_geq = value_geq(supposed_greater, supposed_smaller)\n```",
      "parameters": [
        {
          "name": "greater",
          "type": "Value",
          "optional": false
        },
        {
          "name": "smaller",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 56,
      "raw": "pub fn value_geq(greater: Value, smaller: Value) -> Bool {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn value_geq(greater: Value, smaller: Value) -> Bool {\n  list.all(\n    flatten(smaller),\n    fn(token) { quantity_of(greater, token.1st, token.2nd) >= token.3rd },\n  )\n}",
      "reExportedAs": ["cocktail.value_geq"]
    },
    {
      "key": "vodka:cocktail.vodka_value.value_policy_info",
      "fullName": "vodka:cocktail.vodka_value.value_policy_info",
      "name": "value_policy_info",
      "signature": "pub fn value_policy_info(pub fn value_policy_info(value: Value, policy: ByteArray, ) -> Option<(ByteArray, ByteArray, Int)> {",
      "documentation": "Obtain the information (i.e. flattened value) of a policy in a value\n```aiken\nexpect Some((policyId, assetName, quantity)) = value_policy_info(value, policy)\n```",
      "parameters": [],
      "returnType": "Option<(ByteArray, ByteArray, Int)>",
      "line": 67,
      "raw": "pub fn value_policy_info(pub fn value_policy_info(value: Value, policy: ByteArray, ) -> Option<(ByteArray, ByteArray, Int)> {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn value_policy_info(\n  value: Value,\n  policy: ByteArray,\n) -> Option<(ByteArray, ByteArray, Int)> {\n  list.find(flatten(value), fn(t) { t.1st == policy })\n}",
      "reExportedAs": ["cocktail.value_policy_info"]
    },
    {
      "key": "vodka:cocktail.vodka_value.value_tokens",
      "fullName": "vodka:cocktail.vodka_value.value_tokens",
      "name": "value_tokens",
      "signature": "pub fn value_tokens(value: Value) -> List<(PolicyId, AssetName, Int)> {",
      "documentation": "Obtain the non-lovelace information (i.e. flattened value) of a policy in a value\n```aiken\nlet tokens = value_tokens(value)\n```",
      "parameters": [
        {
          "name": "value",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "List<(PolicyId, AssetName, Int)>",
      "line": 78,
      "raw": "pub fn value_tokens(value: Value) -> List<(PolicyId, AssetName, Int)> {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn value_tokens(value: Value) -> List<(PolicyId, AssetName, Int)> {\n  list.filter(flatten(value), fn(t) { t.1st != \"\" })\n}",
      "reExportedAs": ["cocktail.value_tokens"]
    },
    {
      "key": "vodka:mocktail.virgin_address.mock_verfication_key_credential",
      "fullName": "vodka:mocktail.virgin_address.mock_verfication_key_credential",
      "name": "mock_verfication_key_credential",
      "signature": "pub fn mock_verfication_key_credential(variation: Int) -> Credential {",
      "documentation": "Mock a pub key credential\n`variation` same the same index as `mock_pub_key_hash`",
      "parameters": [
        {
          "name": "variation",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Credential",
      "line": 11,
      "raw": "pub fn mock_verfication_key_credential(variation: Int) -> Credential {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn mock_verfication_key_credential(variation: Int) -> Credential {\n  VerificationKey(mock_pub_key_hash(variation))\n}"
    },
    {
      "key": "vodka:mocktail.virgin_address.mock_pub_key_address",
      "fullName": "vodka:mocktail.virgin_address.mock_pub_key_address",
      "name": "mock_pub_key_address",
      "signature": "pub fn mock_pub_key_address(pub fn mock_pub_key_address(variation: Int, stake_credential: Option<StakeCredential>, ) -> Address {",
      "documentation": "Mock a pub key address\n`variation` same the same index as `mock_pub_key_hash`\n`stake_credential` is optional",
      "parameters": [],
      "returnType": "Address",
      "line": 18,
      "raw": "pub fn mock_pub_key_address(pub fn mock_pub_key_address(variation: Int, stake_credential: Option<StakeCredential>, ) -> Address {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn mock_pub_key_address(\n  variation: Int,\n  stake_credential: Option<StakeCredential>,\n) -> Address {\n  Address {\n    payment_credential: mock_verfication_key_credential(variation),\n    stake_credential,\n  }\n}",
      "reExportedAs": ["mocktail.mock_pub_key_address"]
    },
    {
      "key": "vodka:mocktail.virgin_address.mock_script_credential",
      "fullName": "vodka:mocktail.virgin_address.mock_script_credential",
      "name": "mock_script_credential",
      "signature": "pub fn mock_script_credential(variation: Int) -> Credential {",
      "documentation": "Mock a script credential\n`variation` same the same index as `mock_script_hash`",
      "parameters": [
        {
          "name": "variation",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Credential",
      "line": 30,
      "raw": "pub fn mock_script_credential(variation: Int) -> Credential {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn mock_script_credential(variation: Int) -> Credential {\n  Script(mock_script_hash(variation))\n}",
      "reExportedAs": ["mocktail.mock_script_credential"]
    },
    {
      "key": "vodka:mocktail.virgin_address.mock_script_address",
      "fullName": "vodka:mocktail.virgin_address.mock_script_address",
      "name": "mock_script_address",
      "signature": "pub fn mock_script_address(pub fn mock_script_address(variation: Int, stake_credential: Option<StakeCredential>, ) -> Address {",
      "documentation": "Mock a script address\n`variation` same the same index as `mock_script_hash`\n`stake_credential` is optional",
      "parameters": [],
      "returnType": "Address",
      "line": 37,
      "raw": "pub fn mock_script_address(pub fn mock_script_address(variation: Int, stake_credential: Option<StakeCredential>, ) -> Address {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn mock_script_address(\n  variation: Int,\n  stake_credential: Option<StakeCredential>,\n) -> Address {\n  Address {\n    payment_credential: mock_script_credential(variation),\n    stake_credential,\n  }\n}",
      "reExportedAs": ["mocktail.mock_script_address"]
    },
    {
      "key": "vodka:mocktail.virgin_address.mock_pub_key_stake_cred",
      "fullName": "vodka:mocktail.virgin_address.mock_pub_key_stake_cred",
      "name": "mock_pub_key_stake_cred",
      "signature": "pub fn mock_pub_key_stake_cred(variation: Int) -> StakeCredential {",
      "documentation": "Mock a pub key stake credential\n`variation` same the same index as `mock_stake_key_hash`",
      "parameters": [
        {
          "name": "variation",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "StakeCredential",
      "line": 49,
      "raw": "pub fn mock_pub_key_stake_cred(variation: Int) -> StakeCredential {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn mock_pub_key_stake_cred(variation: Int) -> StakeCredential {\n  Inline(VerificationKey(mock_stake_key_hash(variation)))\n}"
    },
    {
      "key": "vodka:mocktail.virgin_address.mock_script_stake_cred",
      "fullName": "vodka:mocktail.virgin_address.mock_script_stake_cred",
      "name": "mock_script_stake_cred",
      "signature": "pub fn mock_script_stake_cred(variation: Int) -> StakeCredential {",
      "documentation": "Mock a script stake credential\n`variation` same the same index as `mock_script_stake_key_hash`",
      "parameters": [
        {
          "name": "variation",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "StakeCredential",
      "line": 55,
      "raw": "pub fn mock_script_stake_cred(variation: Int) -> StakeCredential {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn mock_script_stake_cred(variation: Int) -> StakeCredential {\n  Inline(Script(mock_script_stake_key_hash(variation)))\n}"
    },
    {
      "key": "vodka:mocktail.virgin_key_hash.mock_key_hash",
      "fullName": "vodka:mocktail.virgin_key_hash.mock_key_hash",
      "name": "mock_key_hash",
      "signature": "pub fn mock_key_hash(variation: Int) -> ByteArray {",
      "documentation": "Mock a key in hexadecimal format",
      "parameters": [
        {
          "name": "variation",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 10,
      "raw": "pub fn mock_key_hash(variation: Int) -> ByteArray {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn mock_key_hash(variation: Int) -> ByteArray {\n  serialise(variation) |> concat(root_hash) |> blake2b_224()\n}",
      "reExportedAs": ["mocktail.mock_key_hash"]
    },
    {
      "key": "vodka:mocktail.virgin_key_hash.mock_policy_id",
      "fullName": "vodka:mocktail.virgin_key_hash.mock_policy_id",
      "name": "mock_policy_id",
      "signature": "pub fn mock_policy_id(variation: Int) -> PolicyId {",
      "documentation": "Mock a PolicyID\nThe variation is used to distinguish between different PolicyIDs\nUse this but not other `mock_key_hash` functions to avoid hash collision",
      "parameters": [
        {
          "name": "variation",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "PolicyId",
      "line": 17,
      "raw": "pub fn mock_policy_id(variation: Int) -> PolicyId {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn mock_policy_id(variation: Int) -> PolicyId {\n  mock_key_hash(variation)\n}",
      "reExportedAs": ["mocktail.mock_policy_id"]
    },
    {
      "key": "vodka:mocktail.virgin_key_hash.mock_pub_key_hash",
      "fullName": "vodka:mocktail.virgin_key_hash.mock_pub_key_hash",
      "name": "mock_pub_key_hash",
      "signature": "pub fn mock_pub_key_hash(variation: Int) -> VerificationKeyHash {",
      "documentation": "Mock a public key hash\nThe variation is used to distinguish between different public keys\nUse this but not other `mock_key_hash` functions to avoid hash collision",
      "parameters": [
        {
          "name": "variation",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "VerificationKeyHash",
      "line": 24,
      "raw": "pub fn mock_pub_key_hash(variation: Int) -> VerificationKeyHash {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn mock_pub_key_hash(variation: Int) -> VerificationKeyHash {\n  mock_key_hash(variation + 1000)\n}",
      "reExportedAs": ["mocktail.mock_pub_key_hash"]
    },
    {
      "key": "vodka:mocktail.virgin_key_hash.mock_script_hash",
      "fullName": "vodka:mocktail.virgin_key_hash.mock_script_hash",
      "name": "mock_script_hash",
      "signature": "pub fn mock_script_hash(variation: Int) -> ScriptHash {",
      "documentation": "Mock a script hash\nThe variation is used to distinguish between different scripts\nUse this but not other `mock_key_hash` functions to avoid hash collision",
      "parameters": [
        {
          "name": "variation",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "ScriptHash",
      "line": 31,
      "raw": "pub fn mock_script_hash(variation: Int) -> ScriptHash {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn mock_script_hash(variation: Int) -> ScriptHash {\n  mock_key_hash(variation + 2000)\n}",
      "reExportedAs": ["mocktail.mock_script_hash"]
    },
    {
      "key": "vodka:mocktail.virgin_key_hash.mock_stake_key_hash",
      "fullName": "vodka:mocktail.virgin_key_hash.mock_stake_key_hash",
      "name": "mock_stake_key_hash",
      "signature": "pub fn mock_stake_key_hash(variation: Int) -> VerificationKeyHash {",
      "documentation": "Mock a stake key hash\nThe variation is used to distinguish between different stake keys\nUse this but not other `mock_key_hash` functions to avoid hash collision",
      "parameters": [
        {
          "name": "variation",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "VerificationKeyHash",
      "line": 38,
      "raw": "pub fn mock_stake_key_hash(variation: Int) -> VerificationKeyHash {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn mock_stake_key_hash(variation: Int) -> VerificationKeyHash {\n  mock_key_hash(variation + 3000)\n}",
      "reExportedAs": ["mocktail.mock_stake_key_hash"]
    },
    {
      "key": "vodka:mocktail.virgin_key_hash.mock_script_stake_key_hash",
      "fullName": "vodka:mocktail.virgin_key_hash.mock_script_stake_key_hash",
      "name": "mock_script_stake_key_hash",
      "signature": "pub fn mock_script_stake_key_hash(variation: Int) -> ScriptHash {",
      "documentation": "Mock a script stake key hash\nThe variation is used to distinguish between different scripts\nUse this but not other `mock_key_hash` functions to avoid hash collision",
      "parameters": [
        {
          "name": "variation",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "ScriptHash",
      "line": 45,
      "raw": "pub fn mock_script_stake_key_hash(variation: Int) -> ScriptHash {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn mock_script_stake_key_hash(variation: Int) -> ScriptHash {\n  mock_key_hash(variation + 4000)\n}"
    },
    {
      "key": "vodka:mocktail.virgin_output_reference.mock_tx_hash",
      "fullName": "vodka:mocktail.virgin_output_reference.mock_tx_hash",
      "name": "mock_tx_hash",
      "signature": "pub fn mock_tx_hash(variation: Int) -> Hash<Blake2b_256, Transaction> {",
      "parameters": [
        {
          "name": "variation",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Hash<Blake2b_256, Transaction>",
      "line": 9,
      "raw": "pub fn mock_tx_hash(variation: Int) -> Hash<Blake2b_256, Transaction> {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn mock_tx_hash(variation: Int) -> Hash<Blake2b_256, Transaction> {\n  serialise(variation) |> concat(root_hash) |> blake2b_256()\n}",
      "reExportedAs": ["mocktail.mock_tx_hash"]
    },
    {
      "key": "vodka:mocktail.virgin_output_reference.mock_utxo_ref",
      "fullName": "vodka:mocktail.virgin_output_reference.mock_utxo_ref",
      "name": "mock_utxo_ref",
      "signature": "pub fn mock_utxo_ref(variation: Int, output_index: Int) -> OutputReference {",
      "documentation": "Mock an output reference",
      "parameters": [
        {
          "name": "variation",
          "type": "Int",
          "optional": false
        },
        {
          "name": "output_index",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "OutputReference",
      "line": 14,
      "raw": "pub fn mock_utxo_ref(variation: Int, output_index: Int) -> OutputReference {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn mock_utxo_ref(variation: Int, output_index: Int) -> OutputReference {\n  OutputReference { transaction_id: mock_tx_hash(variation), output_index }\n}",
      "reExportedAs": ["mocktail.mock_utxo_ref"]
    },
    {
      "key": "vodka:mocktail.virgin_outputs.mock_output",
      "fullName": "vodka:mocktail.virgin_outputs.mock_output",
      "name": "mock_output",
      "signature": "pub fn mock_output(pub fn mock_output(address: Address, value: Value, datum: Datum, reference_script: Option<ScriptHash>, ) -> Output {",
      "documentation": "Mock an output",
      "parameters": [],
      "returnType": "Output",
      "line": 7,
      "raw": "pub fn mock_output(pub fn mock_output(address: Address, value: Value, datum: Datum, reference_script: Option<ScriptHash>, ) -> Output {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn mock_output(\n  address: Address,\n  value: Value,\n  datum: Datum,\n  reference_script: Option<ScriptHash>,\n) -> Output {\n  Output { address, value, datum, reference_script }\n}",
      "reExportedAs": ["mocktail.mock_output"]
    },
    {
      "key": "vodka:mocktail.virgin_outputs.mock_pub_key_output",
      "fullName": "vodka:mocktail.virgin_outputs.mock_pub_key_output",
      "name": "mock_pub_key_output",
      "signature": "pub fn mock_pub_key_output(address: Address, value: Value) -> Output {",
      "documentation": "Mock an output with a public key address\n`datum` and `reference_script` is omitted as it is seldom used in practice",
      "parameters": [
        {
          "name": "address",
          "type": "Address",
          "optional": false
        },
        {
          "name": "value",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "Output",
      "line": 18,
      "raw": "pub fn mock_pub_key_output(address: Address, value: Value) -> Output {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn mock_pub_key_output(address: Address, value: Value) -> Output {\n  mock_output(address, value, NoDatum, reference_script: None)\n}",
      "reExportedAs": ["mocktail.mock_pub_key_output"]
    },
    {
      "key": "vodka:mocktail.virgin_outputs.mock_script_output",
      "fullName": "vodka:mocktail.virgin_outputs.mock_script_output",
      "name": "mock_script_output",
      "signature": "pub fn mock_script_output(pub fn mock_script_output(address: Address, value: Value, datum: Datum, ) -> Output {",
      "documentation": "Mock an output with a script address\n`reference_script` is omitted as it is seldom used in practice",
      "parameters": [],
      "returnType": "Output",
      "line": 24,
      "raw": "pub fn mock_script_output(pub fn mock_script_output(address: Address, value: Value, datum: Datum, ) -> Output {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn mock_script_output(\n  address: Address,\n  value: Value,\n  datum: Datum,\n) -> Output {\n  mock_output(address, value, datum, reference_script: None)\n}",
      "reExportedAs": ["mocktail.mock_script_output"]
    },
    {
      "key": "vodka:mocktail.virgin_validity_range.mock_interval",
      "fullName": "vodka:mocktail.virgin_validity_range.mock_interval",
      "name": "mock_interval",
      "signature": "pub fn mock_interval(lower: Option<Int>, upper: Option<Int>) -> ValidityRange {",
      "documentation": "Mock a validity range with the given lower and upper bounds.",
      "parameters": [
        {
          "name": "lower",
          "type": "Option<Int>",
          "optional": false
        },
        {
          "name": "upper",
          "type": "Option<Int>",
          "optional": false
        }
      ],
      "returnType": "ValidityRange",
      "line": 7,
      "raw": "pub fn mock_interval(lower: Option<Int>, upper: Option<Int>) -> ValidityRange {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn mock_interval(lower: Option<Int>, upper: Option<Int>) -> ValidityRange {\n  let lower_bound =\n    when lower is {\n      Some(lower_bound_number) ->\n        IntervalBound {\n          bound_type: Finite(lower_bound_number),\n          is_inclusive: True,\n        }\n      None -> IntervalBound { bound_type: NegativeInfinity, is_inclusive: True }\n    }\n  let upper_bound =\n    when upper is {\n      Some(upper_bound_number) ->\n        IntervalBound {\n          bound_type: Finite(upper_bound_number),\n          is_inclusive: True,\n        }\n      None -> IntervalBound { bound_type: PositiveInfinity, is_inclusive: True }\n    }\n\n  Interval { lower_bound, upper_bound }\n}",
      "reExportedAs": ["mocktail.mock_interval"]
    },
    {
      "key": "vodka:mocktail.mocktail_tx",
      "fullName": "vodka:mocktail.mocktail_tx",
      "name": "mocktail_tx",
      "signature": "pub fn mocktail_tx() -> MocktailTx {",
      "documentation": "Initialize a new mock transaction builder, and output a built transaction wiht [`.complete().`](./mocktail.html#complete)\n```aiken\nlet tx = mocktail_tx()\n|> ...other tx building methods\n|> complete()\n```",
      "parameters": [],
      "returnType": "MocktailTx",
      "line": 59,
      "raw": "pub fn mocktail_tx() -> MocktailTx {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn mocktail_tx() -> MocktailTx {\n  MocktailTx {\n    tx: placeholder,\n    queue_input: None,\n    queue_output: None,\n    queue_ref_input: None,\n  }\n}"
    },
    {
      "key": "vodka:mocktail.tx_in",
      "fullName": "vodka:mocktail.tx_in",
      "name": "tx_in",
      "signature": "pub fn tx_in(pub fn tx_in(mocktail_tx: MocktailTx, condition: Bool, tx_hash: ByteArray, tx_index: Int, amount: Value, address: Address, ) -> MocktailTx {",
      "documentation": "Tx building method - Add an input to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> tx_in(condition, tx_hash, tx_index, amount, address)\n|> ...other tx building methods\n|> complete()\n```",
      "parameters": [],
      "returnType": "MocktailTx",
      "line": 76,
      "raw": "pub fn tx_in(pub fn tx_in(mocktail_tx: MocktailTx, condition: Bool, tx_hash: ByteArray, tx_index: Int, amount: Value, address: Address, ) -> MocktailTx {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn tx_in(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  tx_hash: ByteArray,\n  tx_index: Int,\n  amount: Value,\n  address: Address,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let queue_input =\n      Some(\n        Input {\n          output_reference: OutputReference {\n            transaction_id: tx_hash,\n            output_index: tx_index,\n          },\n          output: mock_pub_key_output(address, amount),\n        },\n      )\n    when mocktail_tx.queue_input is {\n      Some(input) ->\n        MocktailTx {\n          ..mocktail_tx,\n          queue_input: queue_input,\n          tx: mocktail_tx.tx |> add_input(True, input),\n        }\n      None -> MocktailTx { ..mocktail_tx, queue_input: queue_input }\n    }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.tx_in_inline_datum",
      "fullName": "vodka:mocktail.tx_in_inline_datum",
      "name": "tx_in_inline_datum",
      "signature": "pub fn tx_in_inline_datum(pub fn tx_in_inline_datum(mocktail_tx: MocktailTx, condition: Bool, datum: Data, ) -> MocktailTx {",
      "documentation": "Tx building method - Add an input with inline datum to the transaction.\nThis can only be used right after [`tx_in`](./mocktail.html#tx_in).\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> tx_in(condition, tx_hash, tx_index, amount, address)\n|> tx_in_inline_datum(condition, datum)\n|> ...other tx building methods\n|> complete()\n```",
      "parameters": [],
      "returnType": "MocktailTx",
      "line": 119,
      "raw": "pub fn tx_in_inline_datum(pub fn tx_in_inline_datum(mocktail_tx: MocktailTx, condition: Bool, datum: Data, ) -> MocktailTx {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn tx_in_inline_datum(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  datum: Data,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let queue_input =\n      when mocktail_tx.queue_input is {\n        Some(input) -> {\n          let Input { output_reference, output } = input\n          Some(\n            Input {\n              output_reference,\n              output: Output { ..output, datum: InlineDatum(datum) },\n            },\n          )\n        }\n        None ->\n          Some(\n            Input {\n              output_reference: mock_utxo_ref(0, 0),\n              output: mock_script_output(\n                mock_script_address(0, None),\n                zero,\n                InlineDatum(datum),\n              ),\n            },\n          )\n      }\n    MocktailTx { ..mocktail_tx, queue_input: queue_input }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.tx_out",
      "fullName": "vodka:mocktail.tx_out",
      "name": "tx_out",
      "signature": "pub fn tx_out(pub fn tx_out(mocktail_tx: MocktailTx, condition: Bool, address: Address, amount: Value, ) -> MocktailTx {",
      "documentation": "Tx building method - Add an output to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> tx_out(condition, address, amount)\n|> ...other tx building methods\n|> complete()\n```",
      "parameters": [],
      "returnType": "MocktailTx",
      "line": 162,
      "raw": "pub fn tx_out(pub fn tx_out(mocktail_tx: MocktailTx, condition: Bool, address: Address, amount: Value, ) -> MocktailTx {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn tx_out(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  address: Address,\n  amount: Value,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let queue_output = Some(mock_pub_key_output(address, amount))\n    when mocktail_tx.queue_output is {\n      Some(output) ->\n        MocktailTx {\n          ..mocktail_tx,\n          queue_output: queue_output,\n          tx: mocktail_tx.tx |> add_output(True, output),\n        }\n      None -> MocktailTx { ..mocktail_tx, queue_output: queue_output }\n    }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.tx_out_inline_datum",
      "fullName": "vodka:mocktail.tx_out_inline_datum",
      "name": "tx_out_inline_datum",
      "signature": "pub fn tx_out_inline_datum(pub fn tx_out_inline_datum(mocktail_tx: MocktailTx, condition: Bool, datum: Data, ) -> MocktailTx {",
      "documentation": "Tx building method - Add an output with inline datum to the transaction.\nThis can only be used right after [`tx_out`](./mocktail.html#tx_out).\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> tx_out(condition, address, amount)\n|> tx_out_inline_datum(condition, datum)\n|> ...other tx building methods\n|> complete()\n```",
      "parameters": [],
      "returnType": "MocktailTx",
      "line": 194,
      "raw": "pub fn tx_out_inline_datum(pub fn tx_out_inline_datum(mocktail_tx: MocktailTx, condition: Bool, datum: Data, ) -> MocktailTx {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn tx_out_inline_datum(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  datum: Data,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let queue_output =\n      when mocktail_tx.queue_output is {\n        Some(output) -> Some(Output { ..output, datum: InlineDatum(datum) })\n        None ->\n          Some(\n            mock_script_output(\n              mock_script_address(0, None),\n              zero,\n              InlineDatum(datum),\n            ),\n          )\n      }\n    MocktailTx { ..mocktail_tx, queue_output: queue_output }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.mint",
      "fullName": "vodka:mocktail.mint",
      "name": "mint",
      "signature": "pub fn mint(pub fn mint(mocktail_tx: MocktailTx, condition: Bool, quantity: Int, policy_id: ByteArray, token_name: ByteArray, ) -> MocktailTx {",
      "documentation": "Tx building method - Add a mint to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> mint(condition, quantity, policy_id, token_name)\n|> ...other tx building methods\n|> complete()\n```",
      "parameters": [],
      "returnType": "MocktailTx",
      "line": 226,
      "raw": "pub fn mint(pub fn mint(mocktail_tx: MocktailTx, condition: Bool, quantity: Int, policy_id: ByteArray, token_name: ByteArray, ) -> MocktailTx {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn mint(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  quantity: Int,\n  policy_id: ByteArray,\n  token_name: ByteArray,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    MocktailTx {\n      ..mocktail_tx,\n      tx: mocktail_tx.tx\n        |> add_mint(True, from_asset(policy_id, token_name, quantity)),\n    }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.ref_tx_in",
      "fullName": "vodka:mocktail.ref_tx_in",
      "name": "ref_tx_in",
      "signature": "pub fn ref_tx_in(pub fn ref_tx_in(mocktail_tx: MocktailTx, condition: Bool, tx_hash: ByteArray, tx_index: Int, amount: Value, address: Address, ) -> MocktailTx {",
      "documentation": "Tx building method - Add a reference input to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ref_tx_in(condition, tx_hash, tx_index, amount, address)\n|> ...other tx building methods\n|> complete()\n```",
      "parameters": [],
      "returnType": "MocktailTx",
      "line": 252,
      "raw": "pub fn ref_tx_in(pub fn ref_tx_in(mocktail_tx: MocktailTx, condition: Bool, tx_hash: ByteArray, tx_index: Int, amount: Value, address: Address, ) -> MocktailTx {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn ref_tx_in(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  tx_hash: ByteArray,\n  tx_index: Int,\n  amount: Value,\n  address: Address,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let queue_ref_input =\n      Some(\n        Input {\n          output_reference: OutputReference {\n            transaction_id: tx_hash,\n            output_index: tx_index,\n          },\n          output: mock_pub_key_output(address, amount),\n        },\n      )\n    when mocktail_tx.queue_ref_input is {\n      Some(input) ->\n        MocktailTx {\n          ..mocktail_tx,\n          queue_ref_input: queue_ref_input,\n          tx: mocktail_tx.tx |> add_reference_input(True, input),\n        }\n      None -> MocktailTx { ..mocktail_tx, queue_ref_input: queue_ref_input }\n    }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.ref_tx_in_inline_datum",
      "fullName": "vodka:mocktail.ref_tx_in_inline_datum",
      "name": "ref_tx_in_inline_datum",
      "signature": "pub fn ref_tx_in_inline_datum(pub fn ref_tx_in_inline_datum(mocktail_tx: MocktailTx, condition: Bool, datum: Data, ) -> MocktailTx {",
      "documentation": "Tx building method - Add an inline datum to last reference input in the transaction.\nThis can only be used right after [`ref_tx_in`](./mocktail.html#ref_tx_in).\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ref_tx_in(condition, tx_hash, tx_index, amount, address)\n|> ref_tx_in_inline_datum(condition, datum)\n|> ...other tx building methods\n|> complete()\n```",
      "parameters": [],
      "returnType": "MocktailTx",
      "line": 295,
      "raw": "pub fn ref_tx_in_inline_datum(pub fn ref_tx_in_inline_datum(mocktail_tx: MocktailTx, condition: Bool, datum: Data, ) -> MocktailTx {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn ref_tx_in_inline_datum(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  datum: Data,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let queue_ref_input =\n      when mocktail_tx.queue_ref_input is {\n        Some(input) -> {\n          let Input { output_reference, output } = input\n          Some(\n            Input {\n              output_reference,\n              output: Output { ..output, datum: InlineDatum(datum) },\n            },\n          )\n        }\n        None ->\n          Some(\n            Input {\n              output_reference: mock_utxo_ref(0, 0),\n              output: mock_script_output(\n                mock_script_address(0, None),\n                zero,\n                InlineDatum(datum),\n              ),\n            },\n          )\n      }\n    MocktailTx { ..mocktail_tx, queue_ref_input: queue_ref_input }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.invalid_before",
      "fullName": "vodka:mocktail.invalid_before",
      "name": "invalid_before",
      "signature": "pub fn invalid_before(pub fn invalid_before(mocktail_tx: MocktailTx, condition: Bool, time: Int, ) -> MocktailTx {",
      "documentation": "Tx building method - Add a a lower bound validity range to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> invalid_before(condition, time)\n|> ...other tx building methods\n|> complete()\n```",
      "parameters": [],
      "returnType": "MocktailTx",
      "line": 338,
      "raw": "pub fn invalid_before(pub fn invalid_before(mocktail_tx: MocktailTx, condition: Bool, time: Int, ) -> MocktailTx {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn invalid_before(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  time: Int,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let tx = mocktail_tx.tx\n    let upper_bound =\n      when tx.validity_range.upper_bound.bound_type is {\n        Finite(x) -> Some(x)\n        _ -> None\n      }\n    MocktailTx {\n      ..mocktail_tx,\n      tx: Transaction {\n        ..tx,\n        validity_range: mock_interval(Some(time), upper_bound),\n      },\n    }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.invalid_hereafter",
      "fullName": "vodka:mocktail.invalid_hereafter",
      "name": "invalid_hereafter",
      "signature": "pub fn invalid_hereafter(pub fn invalid_hereafter(mocktail_tx: MocktailTx, condition: Bool, time: Int, ) -> MocktailTx {",
      "documentation": "Tx building method - Add a a upper bound validity range to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> invalid_hereafter(condition, time)\n|> ...other tx building methods\n|> complete()\n```",
      "parameters": [],
      "returnType": "MocktailTx",
      "line": 370,
      "raw": "pub fn invalid_hereafter(pub fn invalid_hereafter(mocktail_tx: MocktailTx, condition: Bool, time: Int, ) -> MocktailTx {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn invalid_hereafter(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  time: Int,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    let tx = mocktail_tx.tx\n    let lower_bound =\n      when tx.validity_range.lower_bound.bound_type is {\n        Finite(x) -> Some(x)\n        _ -> None\n      }\n    MocktailTx {\n      ..mocktail_tx,\n      tx: Transaction {\n        ..tx,\n        validity_range: mock_interval(lower_bound, Some(time)),\n      },\n    }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.required_signer_hash",
      "fullName": "vodka:mocktail.required_signer_hash",
      "name": "required_signer_hash",
      "signature": "pub fn required_signer_hash(pub fn required_signer_hash(mocktail_tx: MocktailTx, condition: Bool, key: ByteArray, ) -> MocktailTx {",
      "documentation": "Tx building method - Add a required signer hash to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> required_signer_hash(condition, key)\n|> ...other tx building methods\n|> complete()\n```",
      "parameters": [],
      "returnType": "MocktailTx",
      "line": 402,
      "raw": "pub fn required_signer_hash(pub fn required_signer_hash(mocktail_tx: MocktailTx, condition: Bool, key: ByteArray, ) -> MocktailTx {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn required_signer_hash(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  key: ByteArray,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    MocktailTx {\n      ..mocktail_tx,\n      tx: mocktail_tx.tx |> add_extra_signatory(True, key),\n    }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.script_withdrawal",
      "fullName": "vodka:mocktail.script_withdrawal",
      "name": "script_withdrawal",
      "signature": "pub fn script_withdrawal(pub fn script_withdrawal(mocktail_tx: MocktailTx, condition: Bool, script_hash: ByteArray, withdrawal_amount: Int, ) -> MocktailTx {",
      "documentation": "Tx building method - Add a script withdrawal to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> script_withdrawal(condition, script_hash, withdrawal_amount)\n|> ...other tx building methods\n|> complete()\n```",
      "parameters": [],
      "returnType": "MocktailTx",
      "line": 425,
      "raw": "pub fn script_withdrawal(pub fn script_withdrawal(mocktail_tx: MocktailTx, condition: Bool, script_hash: ByteArray, withdrawal_amount: Int, ) -> MocktailTx {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn script_withdrawal(\n  mocktail_tx: MocktailTx,\n  condition: Bool,\n  script_hash: ByteArray,\n  withdrawal_amount: Int,\n) -> MocktailTx {\n  if !condition {\n    mocktail_tx\n  } else {\n    MocktailTx {\n      ..mocktail_tx,\n      tx: mocktail_tx.tx\n        |> add_withdrawal(True, Pair(Script(script_hash), withdrawal_amount)),\n    }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.complete",
      "fullName": "vodka:mocktail.complete",
      "name": "complete",
      "signature": "pub fn complete(mocktail_tx: MocktailTx) -> Transaction {",
      "documentation": "Tx building method - Conclude the transaction building process, and return the built transaction.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()",
      "parameters": [
        {
          "name": "mocktail_tx",
          "type": "MocktailTx",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "line": 447,
      "raw": "pub fn complete(mocktail_tx: MocktailTx) -> Transaction {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn complete(mocktail_tx: MocktailTx) -> Transaction {\n  let tx = mocktail_tx.tx\n  let tx =\n    when mocktail_tx.queue_input is {\n      Some(input) -> tx |> add_input(True, input)\n      None -> tx\n    }\n  let tx =\n    when mocktail_tx.queue_output is {\n      Some(output) -> tx |> add_output(True, output)\n      None -> tx\n    }\n  let tx =\n    when mocktail_tx.queue_ref_input is {\n      Some(input) -> tx |> add_reference_input(True, input)\n      None -> tx\n    }\n  tx\n}"
    },
    {
      "key": "vodka:mocktail.add_input",
      "fullName": "vodka:mocktail.add_input",
      "name": "add_input",
      "signature": "pub fn add_input(tx: Transaction, condition: Bool, input: Input) -> Transaction {",
      "documentation": "Tx maniputlator - Add an input to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> add_input(condition, input)\n|> ...other tx maniputlator methods\n```",
      "parameters": [
        {
          "name": "tx",
          "type": "Transaction",
          "optional": false
        },
        {
          "name": "condition",
          "type": "Bool",
          "optional": false
        },
        {
          "name": "input",
          "type": "Input",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "line": 476,
      "raw": "pub fn add_input(tx: Transaction, condition: Bool, input: Input) -> Transaction {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn add_input(tx: Transaction, condition: Bool, input: Input) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction { ..tx, inputs: tx.inputs |> list.concat([input]) }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.add_reference_input",
      "fullName": "vodka:mocktail.add_reference_input",
      "name": "add_reference_input",
      "signature": "pub fn add_reference_input(pub fn add_reference_input(tx: Transaction, condition: Bool, input: Input, ) -> Transaction {",
      "documentation": "Tx maniputlator - Add a reference input to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> add_reference_input(condition, input)\n|> ...other tx maniputlator methods\n```",
      "parameters": [],
      "returnType": "Transaction",
      "line": 493,
      "raw": "pub fn add_reference_input(pub fn add_reference_input(tx: Transaction, condition: Bool, input: Input, ) -> Transaction {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn add_reference_input(\n  tx: Transaction,\n  condition: Bool,\n  input: Input,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction {\n      ..tx,\n      reference_inputs: tx.reference_inputs |> list.concat([input]),\n    }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.add_output",
      "fullName": "vodka:mocktail.add_output",
      "name": "add_output",
      "signature": "pub fn add_output(pub fn add_output(tx: Transaction, condition: Bool, output: Output, ) -> Transaction {",
      "documentation": "Tx maniputlator - Add an output to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet t = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> add_output(condition, output)\n|> ...other tx maniputlator methods\n```",
      "parameters": [],
      "returnType": "Transaction",
      "line": 517,
      "raw": "pub fn add_output(pub fn add_output(tx: Transaction, condition: Bool, output: Output, ) -> Transaction {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn add_output(\n  tx: Transaction,\n  condition: Bool,\n  output: Output,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction { ..tx, outputs: tx.outputs |> list.concat([output]) }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.set_fee",
      "fullName": "vodka:mocktail.set_fee",
      "name": "set_fee",
      "signature": "pub fn set_fee(pub fn set_fee(tx: Transaction, condition: Bool, lovelace_fee: Int, ) -> Transaction {",
      "documentation": "Tx maniputlator - Set a fee to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> set_fee(condition, lovelace_fee)\n|> ...other tx maniputlator methods\n```",
      "parameters": [],
      "returnType": "Transaction",
      "line": 538,
      "raw": "pub fn set_fee(pub fn set_fee(tx: Transaction, condition: Bool, lovelace_fee: Int, ) -> Transaction {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn set_fee(\n  tx: Transaction,\n  condition: Bool,\n  lovelace_fee: Int,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction { ..tx, fee: lovelace_fee }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.add_mint",
      "fullName": "vodka:mocktail.add_mint",
      "name": "add_mint",
      "signature": "pub fn add_mint(tx: Transaction, condition: Bool, mint: Value) -> Transaction {",
      "documentation": "Tx maniputlator - Add a mint to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> add_mint(condition, mint)\n|> ...other tx maniputlator methods\n```",
      "parameters": [
        {
          "name": "tx",
          "type": "Transaction",
          "optional": false
        },
        {
          "name": "condition",
          "type": "Bool",
          "optional": false
        },
        {
          "name": "mint",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "line": 559,
      "raw": "pub fn add_mint(tx: Transaction, condition: Bool, mint: Value) -> Transaction {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn add_mint(tx: Transaction, condition: Bool, mint: Value) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction {\n      ..tx,\n      mint: tx.mint\n        |> merge(mint),\n    }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.add_certificate",
      "fullName": "vodka:mocktail.add_certificate",
      "name": "add_certificate",
      "signature": "pub fn add_certificate(pub fn add_certificate(tx: Transaction, condition: Bool, certificate: Certificate, ) -> Transaction {",
      "documentation": "Tx maniputlator - Add a certificate to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> add_certificate(condition, certificate)\n|> ...other tx maniputlator methods\n```",
      "parameters": [],
      "returnType": "Transaction",
      "line": 580,
      "raw": "pub fn add_certificate(pub fn add_certificate(tx: Transaction, condition: Bool, certificate: Certificate, ) -> Transaction {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn add_certificate(\n  tx: Transaction,\n  condition: Bool,\n  certificate: Certificate,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction {\n      ..tx,\n      certificates: tx.certificates |> list.concat([certificate]),\n    }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.add_withdrawal",
      "fullName": "vodka:mocktail.add_withdrawal",
      "name": "add_withdrawal",
      "signature": "pub fn add_withdrawal(pub fn add_withdrawal(tx: Transaction, condition: Bool, withdrawal: Pair<Credential, Int>, ) -> Transaction {",
      "documentation": "Tx maniputlator - Add a withdrawal to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> add_withdrawal(condition, stake_credential, amount)\n|> ...other tx maniputlator methods\n```",
      "parameters": [],
      "returnType": "Transaction",
      "line": 604,
      "raw": "pub fn add_withdrawal(pub fn add_withdrawal(tx: Transaction, condition: Bool, withdrawal: Pair<Credential, Int>, ) -> Transaction {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn add_withdrawal(\n  tx: Transaction,\n  condition: Bool,\n  withdrawal: Pair<Credential, Int>,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction {\n      ..tx,\n      withdrawals: tx.withdrawals |> list.concat([withdrawal]),\n    }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.add_extra_signatory",
      "fullName": "vodka:mocktail.add_extra_signatory",
      "name": "add_extra_signatory",
      "signature": "pub fn add_extra_signatory(pub fn add_extra_signatory(tx: Transaction, condition: Bool, signatory: VerificationKeyHash, ) -> Transaction {",
      "documentation": "Tx maniputlator - Add an extra signatory to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> add_extra_signatory(condition, signatory)\n|> ...other tx maniputlator methods\n```",
      "parameters": [],
      "returnType": "Transaction",
      "line": 628,
      "raw": "pub fn add_extra_signatory(pub fn add_extra_signatory(tx: Transaction, condition: Bool, signatory: VerificationKeyHash, ) -> Transaction {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn add_extra_signatory(\n  tx: Transaction,\n  condition: Bool,\n  signatory: VerificationKeyHash,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction {\n      ..tx,\n      extra_signatories: tx.extra_signatories |> list.concat([signatory]),\n    }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.add_redeemer",
      "fullName": "vodka:mocktail.add_redeemer",
      "name": "add_redeemer",
      "signature": "pub fn add_redeemer(pub fn add_redeemer(tx: Transaction, condition: Bool, redeemer: Pair<ScriptPurpose, Redeemer>, ) -> Transaction {",
      "documentation": "Tx maniputlator - Add a redeemer to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> add_redeemer(condition, redeemer)\n|> ...other tx maniputlator methods\n```",
      "parameters": [],
      "returnType": "Transaction",
      "line": 652,
      "raw": "pub fn add_redeemer(pub fn add_redeemer(tx: Transaction, condition: Bool, redeemer: Pair<ScriptPurpose, Redeemer>, ) -> Transaction {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn add_redeemer(\n  tx: Transaction,\n  condition: Bool,\n  redeemer: Pair<ScriptPurpose, Redeemer>,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction { ..tx, redeemers: tx.redeemers |> list.concat([redeemer]) }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.add_datum",
      "fullName": "vodka:mocktail.add_datum",
      "name": "add_datum",
      "signature": "pub fn add_datum(tx: Transaction, condition: Bool, datum: Data) -> Transaction {",
      "documentation": "Tx maniputlator - Add a datum to the transaction.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> add_datum(condition, datum)\n|> ...other tx maniputlator methods\n```",
      "parameters": [
        {
          "name": "tx",
          "type": "Transaction",
          "optional": false
        },
        {
          "name": "condition",
          "type": "Bool",
          "optional": false
        },
        {
          "name": "datum",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "Transaction",
      "line": 673,
      "raw": "pub fn add_datum(tx: Transaction, condition: Bool, datum: Data) -> Transaction {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn add_datum(tx: Transaction, condition: Bool, datum: Data) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    let datum_hash = blake2b_256(cbor.serialise(datum))\n    Transaction { ..tx, datums: tx.datums |> dict.insert(datum_hash, datum) }\n  }\n}"
    },
    {
      "key": "vodka:mocktail.set_transaction_id",
      "fullName": "vodka:mocktail.set_transaction_id",
      "name": "set_transaction_id",
      "signature": "pub fn set_transaction_id(pub fn set_transaction_id(tx: Transaction, condition: Bool, transaction_id: TransactionId, ) -> Transaction {",
      "documentation": "Tx maniputlator - Set the transaction id.\nThis function will only run when the condition is `True`.\n```aiken\nlet tx = mocktail_tx()\n|> ...tx building methods\n|> complete()\n|> set_transaction_id(condition, transaction_id)\n|> ...other tx maniputlator methods\n```",
      "parameters": [],
      "returnType": "Transaction",
      "line": 691,
      "raw": "pub fn set_transaction_id(pub fn set_transaction_id(tx: Transaction, condition: Bool, transaction_id: TransactionId, ) -> Transaction {",
      "isPublic": true,
      "source": "vodka",
      "implementation": "pub fn set_transaction_id(\n  tx: Transaction,\n  condition: Bool,\n  transaction_id: TransactionId,\n) -> Transaction {\n  if !condition {\n    tx\n  } else {\n    Transaction { ..tx, id: transaction_id }\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.get_raw_key_and_link",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.get_raw_key_and_link",
      "name": "get_raw_key_and_link",
      "signature": "pub fn get_raw_key_and_link(node_output: Output) -> (Data, Data) {",
      "parameters": [
        {
          "name": "node_output",
          "type": "Output",
          "optional": false
        }
      ],
      "returnType": "(Data, Data)",
      "line": 30,
      "raw": "pub fn get_raw_key_and_link(node_output: Output) -> (Data, Data) {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn get_raw_key_and_link(node_output: Output) -> (Data, Data) {\n  expect InlineDatum(node_output_datum) = node_output.datum\n  let constr = builtin.un_constr_data(node_output_datum).2nd\n  let key = builtin.head_list(constr)\n  let link = builtin.head_list(builtin.tail_list(constr))\n  (key, link)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.get_key",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.get_key",
      "name": "get_key",
      "signature": "pub fn get_key(raw_key_and_link: (Data, Data)) -> NodeKey {",
      "parameters": [
        {
          "name": "raw_key_and_link",
          "type": "(Data, Data",
          "optional": false
        }
      ],
      "returnType": "NodeKey",
      "line": 38,
      "raw": "pub fn get_key(raw_key_and_link: (Data, Data)) -> NodeKey {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn get_key(raw_key_and_link: (Data, Data)) -> NodeKey {\n  expect key: NodeKey = raw_key_and_link.1st\n  key\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.get_link",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.get_link",
      "name": "get_link",
      "signature": "pub fn get_link(raw_key_and_link: (Data, Data)) -> NodeKey {",
      "parameters": [
        {
          "name": "raw_key_and_link",
          "type": "(Data, Data",
          "optional": false
        }
      ],
      "returnType": "NodeKey",
      "line": 43,
      "raw": "pub fn get_link(raw_key_and_link: (Data, Data)) -> NodeKey {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn get_link(raw_key_and_link: (Data, Data)) -> NodeKey {\n  expect link: NodeKey = raw_key_and_link.2nd\n  link\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.get_key_and_link",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.get_key_and_link",
      "name": "get_key_and_link",
      "signature": "pub fn get_key_and_link(node_output: Output) -> (NodeKey, NodeKey) {",
      "parameters": [
        {
          "name": "node_output",
          "type": "Output",
          "optional": false
        }
      ],
      "returnType": "(NodeKey, NodeKey)",
      "line": 48,
      "raw": "pub fn get_key_and_link(node_output: Output) -> (NodeKey, NodeKey) {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn get_key_and_link(node_output: Output) -> (NodeKey, NodeKey) {\n  let raw = get_raw_key_and_link(node_output)\n  (get_key(raw), get_link(raw))\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.serialize_key",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.serialize_key",
      "name": "serialize_key",
      "signature": "pub fn serialize_key(key: NodeKey) -> ByteArray {",
      "parameters": [
        {
          "name": "key",
          "type": "NodeKey",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 53,
      "raw": "pub fn serialize_key(key: NodeKey) -> ByteArray {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn serialize_key(key: NodeKey) -> ByteArray {\n  when key is {\n    Empty -> node_prefix\n    Key(actual_key) -> bytearray.concat(node_prefix, actual_key)\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.get_node_outputs",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.get_node_outputs",
      "name": "get_node_outputs",
      "signature": "pub fn get_node_outputs(pub fn get_node_outputs(outputs: List<Output>, policy_id: PolicyId, ) -> List<Output> {",
      "parameters": [],
      "returnType": "List<Output>",
      "line": 60,
      "raw": "pub fn get_node_outputs(pub fn get_node_outputs(outputs: List<Output>, policy_id: PolicyId, ) -> List<Output> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn get_node_outputs(\n  outputs: List<Output>,\n  policy_id: PolicyId,\n) -> List<Output> {\n  outputs\n    |> list.filter(\n        fn(output) {\n          let Output { value, .. } = output\n          has_data_cs(policy_id, value)\n        },\n      )\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.get_node_inputs",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.get_node_inputs",
      "name": "get_node_inputs",
      "signature": "pub fn get_node_inputs(inputs: List<Input>, policy_id: PolicyId) -> List<Output> {",
      "parameters": [
        {
          "name": "inputs",
          "type": "List<Input>",
          "optional": false
        },
        {
          "name": "policy_id",
          "type": "PolicyId",
          "optional": false
        }
      ],
      "returnType": "List<Output>",
      "line": 73,
      "raw": "pub fn get_node_inputs(inputs: List<Input>, policy_id: PolicyId) -> List<Output> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn get_node_inputs(inputs: List<Input>, policy_id: PolicyId) -> List<Output> {\n  filter_map_pre(\n    inputs,\n    fn(output) {\n      let Output { value, .. } = output\n      has_data_cs(policy_id, value)\n    },\n    fn(input) {\n      let Input { output, .. } = input\n      output\n    },\n  )\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.prove_is_root_node",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.prove_is_root_node",
      "name": "prove_is_root_node",
      "signature": "pub fn prove_is_root_node(policy_id: PolicyId, node: Output) -> Bool {",
      "documentation": "Prove that a node belongs to the given list and is its root.",
      "parameters": [
        {
          "name": "policy_id",
          "type": "PolicyId",
          "optional": false
        },
        {
          "name": "node",
          "type": "Output",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 90,
      "raw": "pub fn prove_is_root_node(policy_id: PolicyId, node: Output) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn prove_is_root_node(policy_id: PolicyId, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_root_node(node_datum.key)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, node_prefix) == 1\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.prove_is_last_node",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.prove_is_last_node",
      "name": "prove_is_last_node",
      "signature": "pub fn prove_is_last_node(policy_id: PolicyId, node: Output) -> Bool {",
      "documentation": "Prove that a node belongs to the given list and is its last node.",
      "parameters": [
        {
          "name": "policy_id",
          "type": "PolicyId",
          "optional": false
        },
        {
          "name": "node",
          "type": "Output",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 102,
      "raw": "pub fn prove_is_last_node(policy_id: PolicyId, node: Output) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn prove_is_last_node(policy_id: PolicyId, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_last_node(node_datum.link)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, serialize_key(node_datum.key)) == 1\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.prove_is_empty_list",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.prove_is_empty_list",
      "name": "prove_is_empty_list",
      "signature": "pub fn prove_is_empty_list(policy_id: PolicyId, node: Output) -> Bool {",
      "documentation": "Prove that the given list is empty, as witnessed by a node that\nis both the root and last node of the list.",
      "parameters": [
        {
          "name": "policy_id",
          "type": "PolicyId",
          "optional": false
        },
        {
          "name": "node",
          "type": "Output",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 115,
      "raw": "pub fn prove_is_empty_list(policy_id: PolicyId, node: Output) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn prove_is_empty_list(policy_id: PolicyId, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_empty_list(node_datum.key, node_datum.link)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, node_prefix) == 1\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.prove_is_member",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.prove_is_member",
      "name": "prove_is_member",
      "signature": "pub fn prove_is_member(policy_id: PolicyId, key: NodeKey, node: Output) -> Bool {",
      "documentation": "Prove that a key is a member of the given list, as witnessed by a node\nthat satisfies the membership predicate with the key.",
      "parameters": [
        {
          "name": "policy_id",
          "type": "PolicyId",
          "optional": false
        },
        {
          "name": "key",
          "type": "NodeKey",
          "optional": false
        },
        {
          "name": "node",
          "type": "Output",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 128,
      "raw": "pub fn prove_is_member(policy_id: PolicyId, key: NodeKey, node: Output) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn prove_is_member(policy_id: PolicyId, key: NodeKey, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_member(key, node_datum.key)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, serialize_key(key)) == 1\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.prove_is_not_member",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.prove_is_not_member",
      "name": "prove_is_not_member",
      "signature": "pub fn prove_is_not_member(pub fn prove_is_not_member(policy_id: PolicyId, key: NodeKey, node: Output, ) -> Bool {",
      "documentation": "Prove that a key is a member of the given list, as witnessed by a node\nthat satisfies the non-membership predicate with the key.",
      "parameters": [],
      "returnType": "Bool",
      "line": 141,
      "raw": "pub fn prove_is_not_member(pub fn prove_is_not_member(policy_id: PolicyId, key: NodeKey, node: Output, ) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn prove_is_not_member(\n  policy_id: PolicyId,\n  key: NodeKey,\n  node: Output,\n) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_not_member(key, node_datum.key, node_datum.link)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, serialize_key(node_datum.key)) == 1\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.list_state_transition",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.list_state_transition",
      "name": "list_state_transition",
      "signature": "pub fn list_state_transition(node_mint: Dict<AssetName, Int>) -> Bool {",
      "documentation": "Detect whether the list's minting policy is invoked in the transaction,\nso that the spending validator can forward to it.",
      "parameters": [
        {
          "name": "node_mint",
          "type": "Dict<AssetName, Int>",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 160,
      "raw": "pub fn list_state_transition(node_mint: Dict<AssetName, Int>) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn list_state_transition(node_mint: Dict<AssetName, Int>) -> Bool {\n  // 1. Tokens of the list's minting policy must be minted or burned.\n  dict.is_empty(node_mint) == False\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.modify_data",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.modify_data",
      "name": "modify_data",
      "signature": "pub fn modify_data(pub fn modify_data(node_mint: Dict<AssetName, Int>, own_input: Output, own_output: Output, node_nft_policy_id: ByteArray, node_nft_asset_name: ByteArray, ) -> Bool {",
      "documentation": "Modify the `data` field of a list node without changing the `key` and\n`link` fields.",
      "parameters": [],
      "returnType": "Bool",
      "line": 167,
      "raw": "pub fn modify_data(pub fn modify_data(node_mint: Dict<AssetName, Int>, own_input: Output, own_output: Output, node_nft_policy_id: ByteArray, node_nft_asset_name: ByteArray, ) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn modify_data(\n  node_mint: Dict<AssetName, Int>,\n  own_input: Output,\n  own_output: Output,\n  node_nft_policy_id: ByteArray,\n  node_nft_asset_name: ByteArray,\n) -> Bool {\n  // 1. Tokens of the list's minting policy must *not* be minted or burned.\n  expect dict.is_empty(node_mint)\n\n  // 2. Let own_input be the node utxo input for which this rule is evaluated.\n  // 3. Let own_output be an output of the transaction indicated by the redeemer\n  //    of the spending validator.\n  // 4. The node NFT of the list must be present in own_input.\n  expect\n    quantity_of(own_input.value, node_nft_policy_id, node_nft_asset_name) == 1\n\n  // 5. The value must match in own_input and own_output.\n  expect own_input.value == own_output.value\n\n  // 6. The key and link fields must match in own_input and own_output.\n  let input_key_and_link = get_raw_key_and_link(own_input)\n  let output_key_and_link = get_raw_key_and_link(own_output)\n  expect input_key_and_link == output_key_and_link\n\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.init",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.init",
      "name": "init",
      "signature": "pub fn init(pub fn init(node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, node_cs: ByteArray, ) -> Bool {",
      "documentation": "Initialize an empty unordered list.\n\nApplication code must ensure that this action can happen only once.",
      "parameters": [],
      "returnType": "Bool",
      "line": 201,
      "raw": "pub fn init(pub fn init(node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, node_cs: ByteArray, ) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn init(\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n  node_cs: ByteArray,\n) -> Bool {\n  // 1. The transaction's sole effect on the list is to add the root key.\n  expect key_added(Empty, node_mint)\n\n  // 2. The list must be empty after the transaction, as proved by an output\n  // root_node that holds the minted root node NFT.\n  expect Some(root_node) = list.head(node_outputs)\n  let raw_key_and_link = get_raw_key_and_link(root_node)\n  expect is_empty_list(get_key(raw_key_and_link), get_link(raw_key_and_link))\n  expect quantity_of(root_node.value, node_cs, node_prefix) == 1\n\n  // 3. The root_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(root_node.value)) == 2\n\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.deinit",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.deinit",
      "name": "deinit",
      "signature": "pub fn deinit(pub fn deinit(node_inputs: List<Output>, node_mint: Dict<AssetName, Int>, node_cs: ByteArray, ) -> Bool {",
      "documentation": "Deinitialize an empty unordered list.",
      "parameters": [],
      "returnType": "Bool",
      "line": 224,
      "raw": "pub fn deinit(pub fn deinit(node_inputs: List<Output>, node_mint: Dict<AssetName, Int>, node_cs: ByteArray, ) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn deinit(\n  node_inputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n  node_cs: ByteArray,\n) -> Bool {\n  // 1. The transaction's sole effect on the list is to remove the root key.\n  expect key_removed(Empty, node_mint)\n\n  // 2. The list must be empty before the transaction, as proved by an input\n  //    root_node that holds the minted root node NFT.\n  expect Some(root_node) = list.head(node_inputs)\n  let raw_key_and_link = get_raw_key_and_link(root_node)\n  expect is_empty_list(get_key(raw_key_and_link), get_link(raw_key_and_link))\n  expect quantity_of(root_node.value, node_cs, node_prefix) == 1\n\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.prepend",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.prepend",
      "name": "prepend",
      "signature": "pub fn prepend(pub fn prepend(key_to_prepend: NodeKey, prepended_node_index: Int, anchor_node_output_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
      "documentation": "Prepend a new node to the beginning of the list.\n\nThe index arguments in this function are relative to the node_inputs\nand node_outputs. They are NOT absolute.",
      "parameters": [],
      "returnType": "Bool",
      "line": 247,
      "raw": "pub fn prepend(pub fn prepend(key_to_prepend: NodeKey, prepended_node_index: Int, anchor_node_output_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn prepend(\n  key_to_prepend: NodeKey,\n  prepended_node_index: Int,\n  anchor_node_output_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify the mint:\n  // 1. Let key_to_prepend be the key being prepended.\n  // 2. The transaction's sole effect on the list is to add key_to_prepend.\n  expect key_added(key_to_prepend, node_mint)\n\n  // Verify the inputs:\n  // 3. node_inputs must be a singleton. Let anchor_node_input be its sole node.\n  expect list.length(node_inputs) == 1\n  expect Some(anchor_node_input) = list.head(node_inputs)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n\n  // 4. anchor_node_input must be the root node of the list.\n  expect is_root_node(parsed_anchor_node_input_datum.key)\n\n  // Verify the outputs:\n  // 5. node_outputs must have exactly two nodes: prepended_node and anchor_node_output.\n  expect list.length(node_outputs) == 2\n  expect Some(prepended_node) = list.at(node_outputs, prepended_node_index)\n  let prepended_node_raw_key_and_link = get_raw_key_and_link(prepended_node)\n  expect Some(anchor_node_output) =\n    list.at(node_outputs, anchor_node_output_index)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 6. key_to_prepend must be a member of the list after the transaction,\n  //    as witnessed by prepended_node.\n  expect is_member(key_to_prepend, get_key(prepended_node_raw_key_and_link))\n\n  // 7. anchor_node input and prepended node must match on the link_field.\n  //    In other words, they must both link to the same key.\n  expect\n    parsed_anchor_node_input_datum.link == get_link(\n      prepended_node_raw_key_and_link,\n    )\n\n  // 8. anchor_node_output must link to key_to_prepend.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: key_to_prepend,\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // 9. prepended_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(prepended_node.value)) == 2\n\n  // Verify immutable data:\n  // 10. anchor node input must match anchor node output on address, value,\n  //     and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // 11. prepended_node must match anchor_node_output on address.\n  expect prepended_node.address == anchor_node_output.address\n\n  // 12. key_to_prepend must not be a member of the list before the transaction,\n  //     as witnessed by anchor_node_input.\n  expect\n    is_not_member(\n      key_to_prepend,\n      node_key: parsed_anchor_node_input_datum.key,\n      node_link: parsed_anchor_node_input_datum.link,\n    )\n\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.append",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.append",
      "name": "append",
      "signature": "pub fn append(pub fn append(key_to_append: NodeKey, appended_node_index: Int, anchor_node_output_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
      "documentation": "Append a new node to the end of the list.\n\nThe index arguments in this function are relative to the node_inputs\nand node_outputs. They are NOT absolute.",
      "parameters": [],
      "returnType": "Bool",
      "line": 329,
      "raw": "pub fn append(pub fn append(key_to_append: NodeKey, appended_node_index: Int, anchor_node_output_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn append(\n  key_to_append: NodeKey,\n  appended_node_index: Int,\n  anchor_node_output_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify the mint:\n  // 1. Let key_to_append be the key being appended.\n  // 2. The transaction's sole effect on the list is to add key_to_append.\n  expect key_added(key_to_append, node_mint)\n\n  // 3. node_inputs must be a singleton. Let anchor_node_input be its sole node.\n  expect list.length(node_inputs) == 1\n  expect Some(anchor_node_input) = list.head(node_inputs)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n  let anchor_node_raw_key_and_link = get_raw_key_and_link(anchor_node_input)\n\n  // 4. anchor_node_input must be the last node of the list before the transaction.\n  expect is_last_node(get_link(anchor_node_raw_key_and_link))\n\n  // Verify the outputs:\n  // 5. node_outputs must have exactly two nodes: appended_node and anchor_node_output.\n  expect list.length(node_outputs) == 2\n  expect Some(appended_node) = list.at(node_outputs, appended_node_index)\n  let appended_node_raw_key_and_link = get_raw_key_and_link(appended_node)\n  expect Some(anchor_node_output) =\n    list.at(node_outputs, anchor_node_output_index)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 6. key_to_append must be a member of the list after the transaction,\n  //    as witnessed by appended_node.\n  expect is_member(key_to_append, get_key(appended_node_raw_key_and_link))\n\n  // 7. appended_node must be the last node of the list after the transaction.\n  expect is_last_node(get_link(appended_node_raw_key_and_link))\n\n  // 8. anchor node output must link to key to append.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: key_to_append,\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // 9. appended_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(appended_node.value)) == 2\n\n  // Verify immutable data:\n  // 10. anchor_node input must match anchor_node output on address, value,\n  //     and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // 11. appended_node must match anchor_node_output on address.\n  expect appended_node.address == anchor_node_output.address\n\n  // 12. key_to_append must not be a member of the list before the transaction,\n  //     as witnessed by anchor_node_input.\n  expect\n    is_not_member(\n      key_to_append,\n      node_key: parsed_anchor_node_input_datum.key,\n      node_link: parsed_anchor_node_input_datum.link,\n    )\n\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.insert",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.insert",
      "name": "insert",
      "signature": "pub fn insert(pub fn insert(key_to_insert: NodeKey, inserted_node_output_index: Int, anchor_node_output_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
      "documentation": "Insert a node into the list.\n\nThe index arguments in this function are relative to the node_inputs\nand node_outputs. They are NOT absolute.",
      "parameters": [],
      "returnType": "Bool",
      "line": 407,
      "raw": "pub fn insert(pub fn insert(key_to_insert: NodeKey, inserted_node_output_index: Int, anchor_node_output_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn insert(\n  key_to_insert: NodeKey,\n  inserted_node_output_index: Int,\n  anchor_node_output_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify mint:\n  // 1. Let key_to_insert be the key being inserted.\n  // 2. The transaction’s sole effect on the list is to add key_to_insert.\n  expect key_added(key_to_insert, node_mint)\n\n  // Verify inputs:\n  // 3. node_inputs must be a singleton. Let anchor_node_input be its sole node.\n  expect list.length(node_inputs) == 1\n  expect Some(anchor_node_input) = list.head(node_inputs)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n\n  // 4. key_to_insert must not be a member of the list before the transaction,\n  //    as witnessed by anchor_node_input.\n  expect\n    is_not_member(\n      key_to_insert,\n      parsed_anchor_node_input_datum.key,\n      parsed_anchor_node_input_datum.link,\n    )\n\n  // Verify outputs:\n  // 5. node_outputs must have exactly two nodes: inserted_node and anchor_node_output.\n  expect list.length(node_outputs) == 2\n  expect Some(inserted_node_output) =\n    list.at(node_outputs, inserted_node_output_index)\n  let inserted_node_output_raw_key_and_link =\n    get_raw_key_and_link(inserted_node_output)\n  expect Some(anchor_node_output) =\n    list.at(node_outputs, anchor_node_output_index)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 6. key_to_insert must be a member of the list after the transaction,\n  //    as witnessed by inserted_node.\n  expect\n    is_member(key_to_insert, get_key(inserted_node_output_raw_key_and_link))\n\n  // 7. anchor_node output must link to key_to_insert.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: key_to_insert,\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // 8. anchor_node_input and inserted_node must match on the link field.\n  //    In other words, they must both link to the same key.\n  expect\n    parsed_anchor_node_input_datum.link == get_link(\n      inserted_node_output_raw_key_and_link,\n    )\n\n  // 9. inserted_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(inserted_node_output.value)) == 2\n\n  // Verify immutable data:\n  // 10. anchor_node_input must match anchor node output on address, value,\n  //     and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // 11. inserted_node must match anchor_node_output on address.\n  expect inserted_node_output.address == anchor_node_output.address\n\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.remove",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.remove",
      "name": "remove",
      "signature": "pub fn remove(pub fn remove(key_to_remove: NodeKey, removed_node_input_index: Int, anchor_node_input_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
      "documentation": "Remove a non-root node from the list.\n\nThe index arguments in this function are relative to the node_inputs\nand node_outputs. They are NOT absolute.",
      "parameters": [],
      "returnType": "Bool",
      "line": 489,
      "raw": "pub fn remove(pub fn remove(key_to_remove: NodeKey, removed_node_input_index: Int, anchor_node_input_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn remove(\n  key_to_remove: NodeKey,\n  removed_node_input_index: Int,\n  anchor_node_input_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify the mint:\n  // 1. Let key_to_remove be the key being removed.\n  // 2. The transaction's sole effect on the list is to remove key_to_remove.\n  expect key_removed(key_to_remove, node_mint)\n\n  // Verify the inputs:\n  // 3. node_inputs must have exactly two nodes: removed_node and anchor_node_input.\n  expect list.length(node_inputs) == 2\n  expect Some(removed_node_input) =\n    list.at(node_inputs, removed_node_input_index)\n  let removed_node_raw_key_and_link = get_raw_key_and_link(removed_node_input)\n  expect Some(anchor_node_input) = list.at(node_inputs, anchor_node_input_index)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n\n  // 4. key_to_remove must be a member of the list before the transaction,\n  //    as witnessed by removed_node.\n  expect is_member(key_to_remove, get_key(removed_node_raw_key_and_link))\n\n  // 5. anchor_node_input must link to key_to_remove.\n  expect parsed_anchor_node_input_datum.link == key_to_remove\n\n  // Verify the outputs:\n  // 6. node_outputs must be a singleton. Let anchor_node_output be its sole node.\n  expect list.length(node_outputs) == 1\n  expect Some(anchor_node_output) = list.head(node_outputs)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 7. anchor_node_output and removed_node must match on the link field.\n  //    In other words, they must both link to the same key.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: get_link(removed_node_raw_key_and_link),\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // Verify immutable data:\n  // 8. anchor_node_input must match anchor_node_output on address, value,\n  //    and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.get_raw_key_and_link",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.get_raw_key_and_link",
      "name": "get_raw_key_and_link",
      "signature": "pub fn get_raw_key_and_link(node_output: Output) -> (Data, Data) {",
      "parameters": [
        {
          "name": "node_output",
          "type": "Output",
          "optional": false
        }
      ],
      "returnType": "(Data, Data)",
      "line": 30,
      "raw": "pub fn get_raw_key_and_link(node_output: Output) -> (Data, Data) {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn get_raw_key_and_link(node_output: Output) -> (Data, Data) {\n  expect InlineDatum(node_output_datum) = node_output.datum\n  let constr = builtin.un_constr_data(node_output_datum).2nd\n  let key = builtin.head_list(constr)\n  let link = builtin.head_list(builtin.tail_list(constr))\n  (key, link)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.get_key",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.get_key",
      "name": "get_key",
      "signature": "pub fn get_key(raw_key_and_link: (Data, Data)) -> NodeKey {",
      "parameters": [
        {
          "name": "raw_key_and_link",
          "type": "(Data, Data",
          "optional": false
        }
      ],
      "returnType": "NodeKey",
      "line": 38,
      "raw": "pub fn get_key(raw_key_and_link: (Data, Data)) -> NodeKey {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn get_key(raw_key_and_link: (Data, Data)) -> NodeKey {\n  expect key: NodeKey = raw_key_and_link.1st\n  key\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.get_link",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.get_link",
      "name": "get_link",
      "signature": "pub fn get_link(raw_key_and_link: (Data, Data)) -> NodeKey {",
      "parameters": [
        {
          "name": "raw_key_and_link",
          "type": "(Data, Data",
          "optional": false
        }
      ],
      "returnType": "NodeKey",
      "line": 43,
      "raw": "pub fn get_link(raw_key_and_link: (Data, Data)) -> NodeKey {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn get_link(raw_key_and_link: (Data, Data)) -> NodeKey {\n  expect link: NodeKey = raw_key_and_link.2nd\n  link\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.get_key_and_link",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.get_key_and_link",
      "name": "get_key_and_link",
      "signature": "pub fn get_key_and_link(node_output: Output) -> (NodeKey, NodeKey) {",
      "parameters": [
        {
          "name": "node_output",
          "type": "Output",
          "optional": false
        }
      ],
      "returnType": "(NodeKey, NodeKey)",
      "line": 48,
      "raw": "pub fn get_key_and_link(node_output: Output) -> (NodeKey, NodeKey) {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn get_key_and_link(node_output: Output) -> (NodeKey, NodeKey) {\n  let raw = get_raw_key_and_link(node_output)\n  (get_key(raw), get_link(raw))\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.serialize_key",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.serialize_key",
      "name": "serialize_key",
      "signature": "pub fn serialize_key(key: NodeKey) -> ByteArray {",
      "parameters": [
        {
          "name": "key",
          "type": "NodeKey",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 53,
      "raw": "pub fn serialize_key(key: NodeKey) -> ByteArray {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn serialize_key(key: NodeKey) -> ByteArray {\n  when key is {\n    Empty -> node_prefix\n    Key(actual_key) -> bytearray.concat(node_prefix, actual_key)\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.get_node_outputs",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.get_node_outputs",
      "name": "get_node_outputs",
      "signature": "pub fn get_node_outputs(pub fn get_node_outputs(outputs: List<Output>, policy_id: PolicyId, ) -> List<Output> {",
      "parameters": [],
      "returnType": "List<Output>",
      "line": 60,
      "raw": "pub fn get_node_outputs(pub fn get_node_outputs(outputs: List<Output>, policy_id: PolicyId, ) -> List<Output> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn get_node_outputs(\n  outputs: List<Output>,\n  policy_id: PolicyId,\n) -> List<Output> {\n  outputs\n    |> list.filter(\n        fn(output) {\n          let Output { value, .. } = output\n          has_data_cs(policy_id, value)\n        },\n      )\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.get_node_inputs",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.get_node_inputs",
      "name": "get_node_inputs",
      "signature": "pub fn get_node_inputs(inputs: List<Input>, policy_id: PolicyId) -> List<Output> {",
      "parameters": [
        {
          "name": "inputs",
          "type": "List<Input>",
          "optional": false
        },
        {
          "name": "policy_id",
          "type": "PolicyId",
          "optional": false
        }
      ],
      "returnType": "List<Output>",
      "line": 73,
      "raw": "pub fn get_node_inputs(inputs: List<Input>, policy_id: PolicyId) -> List<Output> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn get_node_inputs(inputs: List<Input>, policy_id: PolicyId) -> List<Output> {\n  filter_map_pre(\n    inputs,\n    fn(output) {\n      let Output { value, .. } = output\n      has_data_cs(policy_id, value)\n    },\n    fn(input) {\n      let Input { output, .. } = input\n      output\n    },\n  )\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.prove_is_root_node",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.prove_is_root_node",
      "name": "prove_is_root_node",
      "signature": "pub fn prove_is_root_node(policy_id: PolicyId, node: Output) -> Bool {",
      "documentation": "Prove that a node belongs to the given list and is its root.",
      "parameters": [
        {
          "name": "policy_id",
          "type": "PolicyId",
          "optional": false
        },
        {
          "name": "node",
          "type": "Output",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 90,
      "raw": "pub fn prove_is_root_node(policy_id: PolicyId, node: Output) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn prove_is_root_node(policy_id: PolicyId, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_root_node(node_datum.key)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, node_prefix) == 1\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.prove_is_last_node",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.prove_is_last_node",
      "name": "prove_is_last_node",
      "signature": "pub fn prove_is_last_node(policy_id: PolicyId, node: Output) -> Bool {",
      "documentation": "Prove that a node belongs to the given list and is its last node.",
      "parameters": [
        {
          "name": "policy_id",
          "type": "PolicyId",
          "optional": false
        },
        {
          "name": "node",
          "type": "Output",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 102,
      "raw": "pub fn prove_is_last_node(policy_id: PolicyId, node: Output) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn prove_is_last_node(policy_id: PolicyId, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_last_node(node_datum.link)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, serialize_key(node_datum.key)) == 1\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.prove_is_empty_list",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.prove_is_empty_list",
      "name": "prove_is_empty_list",
      "signature": "pub fn prove_is_empty_list(policy_id: PolicyId, node: Output) -> Bool {",
      "documentation": "Prove that the given list is empty, as witnessed by a node that\nis both the root and last node of the list.",
      "parameters": [
        {
          "name": "policy_id",
          "type": "PolicyId",
          "optional": false
        },
        {
          "name": "node",
          "type": "Output",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 115,
      "raw": "pub fn prove_is_empty_list(policy_id: PolicyId, node: Output) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn prove_is_empty_list(policy_id: PolicyId, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_empty_list(node_datum.key, node_datum.link)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, node_prefix) == 1\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.prove_is_member",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.prove_is_member",
      "name": "prove_is_member",
      "signature": "pub fn prove_is_member(policy_id: PolicyId, key: NodeKey, node: Output) -> Bool {",
      "documentation": "Prove that a key is a member of the given list, as witnessed by a node\nthat satisfies the membership predicate with the key.",
      "parameters": [
        {
          "name": "policy_id",
          "type": "PolicyId",
          "optional": false
        },
        {
          "name": "key",
          "type": "NodeKey",
          "optional": false
        },
        {
          "name": "node",
          "type": "Output",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 128,
      "raw": "pub fn prove_is_member(policy_id: PolicyId, key: NodeKey, node: Output) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn prove_is_member(policy_id: PolicyId, key: NodeKey, node: Output) -> Bool {\n  // Check the datum:\n  expect InlineDatum(node_datum_raw) = node.datum\n  expect node_datum: NodeDatum = node_datum_raw\n  expect is_member(key, node_datum.key)\n  // Check the token:\n  expect quantity_of(node.value, policy_id, serialize_key(key)) == 1\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.list_state_transition",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.list_state_transition",
      "name": "list_state_transition",
      "signature": "pub fn list_state_transition(node_mint: Dict<AssetName, Int>) -> Bool {",
      "documentation": "Detect whether the list's minting policy is invoked in the transaction,\nso that the spending validator can forward to it.",
      "parameters": [
        {
          "name": "node_mint",
          "type": "Dict<AssetName, Int>",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 143,
      "raw": "pub fn list_state_transition(node_mint: Dict<AssetName, Int>) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn list_state_transition(node_mint: Dict<AssetName, Int>) -> Bool {\n  // 1. Tokens of the list's minting policy must be minted or burned.\n  dict.is_empty(node_mint) == False\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.modify_data",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.modify_data",
      "name": "modify_data",
      "signature": "pub fn modify_data(pub fn modify_data(node_mint: Dict<AssetName, Int>, own_input: Output, own_output: Output, node_nft_policy_id: ByteArray, node_nft_asset_name: ByteArray, ) -> Bool {",
      "documentation": "Modify the `data` field of a list node without changing the `key` and\n`link` fields.",
      "parameters": [],
      "returnType": "Bool",
      "line": 150,
      "raw": "pub fn modify_data(pub fn modify_data(node_mint: Dict<AssetName, Int>, own_input: Output, own_output: Output, node_nft_policy_id: ByteArray, node_nft_asset_name: ByteArray, ) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn modify_data(\n  node_mint: Dict<AssetName, Int>,\n  own_input: Output,\n  own_output: Output,\n  node_nft_policy_id: ByteArray,\n  node_nft_asset_name: ByteArray,\n) -> Bool {\n  // 1. Tokens of the list's minting policy must *not* be minted or burned.\n  expect dict.is_empty(node_mint)\n\n  // 2. Let own_input be the node utxo input for which this rule is evaluated.\n  // 3. Let own_output be an output of the transaction indicated by the redeemer\n  //    of the spending validator.\n  // 4. The node NFT of the list must be present in own_input.\n  expect\n    quantity_of(own_input.value, node_nft_policy_id, node_nft_asset_name) == 1\n\n  // 5. The value must match in own_input and own_output.\n  expect own_input.value == own_output.value\n\n  // 6. The key and link fields must match in own_input and own_output.\n  let input_key_and_link = get_raw_key_and_link(own_input)\n  let output_key_and_link = get_raw_key_and_link(own_output)\n  expect input_key_and_link == output_key_and_link\n\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.init",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.init",
      "name": "init",
      "signature": "pub fn init(pub fn init(node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, node_cs: ByteArray, ) -> Bool {",
      "documentation": "Initialize an empty unordered list.\n\nApplication code must ensure that this action can happen only once.",
      "parameters": [],
      "returnType": "Bool",
      "line": 184,
      "raw": "pub fn init(pub fn init(node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, node_cs: ByteArray, ) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn init(\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n  node_cs: ByteArray,\n) -> Bool {\n  // 1. The transaction's sole effect on the list is to add the root key.\n  expect key_added(Empty, node_mint)\n\n  // 2. The list must be empty after the transaction, as proved by an output\n  // root_node that holds the minted root node NFT.\n  expect Some(root_node) = list.head(node_outputs)\n  let raw_key_and_link = get_raw_key_and_link(root_node)\n  expect is_empty_list(get_key(raw_key_and_link), get_link(raw_key_and_link))\n  expect quantity_of(root_node.value, node_cs, node_prefix) == 1\n\n  // 3. The root_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(root_node.value)) == 2\n\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.deinit",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.deinit",
      "name": "deinit",
      "signature": "pub fn deinit(pub fn deinit(node_inputs: List<Output>, node_mint: Dict<AssetName, Int>, node_cs: ByteArray, ) -> Bool {",
      "documentation": "Deinitialize an empty unordered list.",
      "parameters": [],
      "returnType": "Bool",
      "line": 207,
      "raw": "pub fn deinit(pub fn deinit(node_inputs: List<Output>, node_mint: Dict<AssetName, Int>, node_cs: ByteArray, ) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn deinit(\n  node_inputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n  node_cs: ByteArray,\n) -> Bool {\n  // 1. The transaction's sole effect on the list is to remove the root key.\n  expect key_removed(Empty, node_mint)\n\n  // 2. The list must be empty before the transaction, as proved by an input\n  //    root_node that holds the minted root node NFT.\n  expect Some(root_node) = list.head(node_inputs)\n  let raw_key_and_link = get_raw_key_and_link(root_node)\n  expect is_empty_list(get_key(raw_key_and_link), get_link(raw_key_and_link))\n  expect quantity_of(root_node.value, node_cs, node_prefix) == 1\n\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.prepend_unsafe",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.prepend_unsafe",
      "name": "prepend_unsafe",
      "signature": "pub fn prepend_unsafe(pub fn prepend_unsafe(key_to_prepend: NodeKey, prepended_node_index: Int, anchor_node_output_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
      "documentation": "Prepend a new node to the beginning of the list.\n\nWARNING: An application using a key-unordered list MUST only add nodes with\nunique keys to the list. Duplicate keys break the linked list data structure.\n\nThe index arguments in this function are relative to the node_inputs\nand node_outputs. They are NOT absolute.",
      "parameters": [],
      "returnType": "Bool",
      "line": 233,
      "raw": "pub fn prepend_unsafe(pub fn prepend_unsafe(key_to_prepend: NodeKey, prepended_node_index: Int, anchor_node_output_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn prepend_unsafe(\n  key_to_prepend: NodeKey,\n  prepended_node_index: Int,\n  anchor_node_output_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify the mint:\n  // 1. Let key_to_prepend be the key being prepended.\n  // 2. The transaction's sole effect on the list is to add key_to_prepend.\n  expect key_added(key_to_prepend, node_mint)\n\n  // Verify the inputs:\n  // 3. node_inputs must be a singleton. Let anchor_node_input be its sole node.\n  expect list.length(node_inputs) == 1\n  expect Some(anchor_node_input) = list.head(node_inputs)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n\n  // 4. anchor_node_input must be the root node of the list.\n  expect is_root_node(parsed_anchor_node_input_datum.key)\n\n  // Verify the outputs:\n  // 5. node_outputs must have exactly two nodes: prepended_node and anchor_node_output.\n  expect list.length(node_outputs) == 2\n  expect Some(prepended_node) = list.at(node_outputs, prepended_node_index)\n  let prepended_node_raw_key_and_link = get_raw_key_and_link(prepended_node)\n  expect Some(anchor_node_output) =\n    list.at(node_outputs, anchor_node_output_index)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 6. key_to_prepend must be a member of the list after the transaction,\n  //    as witnessed by prepended_node.\n  expect is_member(key_to_prepend, get_key(prepended_node_raw_key_and_link))\n\n  // 7. anchor_node input and prepended node must match on the link_field.\n  //    In other words, they must both link to the same key.\n  expect\n    parsed_anchor_node_input_datum.link == get_link(\n      prepended_node_raw_key_and_link,\n    )\n\n  // 8. anchor_node_output must link to key_to_prepend.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: key_to_prepend,\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // 9. prepended_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(prepended_node.value)) == 2\n\n  // Verify immutable data:\n  // 10. anchor node input must match anchor node output on address, value,\n  //     and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // 11. prepended_node must match anchor_node_output on address.\n  expect prepended_node.address == anchor_node_output.address\n\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.append_unsafe",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.append_unsafe",
      "name": "append_unsafe",
      "signature": "pub fn append_unsafe(pub fn append_unsafe(key_to_append: NodeKey, appended_node_index: Int, anchor_node_output_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
      "documentation": "Append a new node to the end of the list.\n\nWARNING: An application using a key-unordered list MUST only add nodes with\nunique keys to the list. Duplicate keys break the linked list data structure.\n\nThe index arguments in this function are relative to the node_inputs\nand node_outputs. They are NOT absolute.",
      "parameters": [],
      "returnType": "Bool",
      "line": 309,
      "raw": "pub fn append_unsafe(pub fn append_unsafe(key_to_append: NodeKey, appended_node_index: Int, anchor_node_output_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn append_unsafe(\n  key_to_append: NodeKey,\n  appended_node_index: Int,\n  anchor_node_output_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify the mint:\n  // 1. Let key_to_append be the key being appended.\n  // 2. The transaction's sole effect on the list is to add key_to_append.\n  expect key_added(key_to_append, node_mint)\n\n  // 3. node_inputs must be a singleton. Let anchor_node_input be its sole node.\n  expect list.length(node_inputs) == 1\n  expect Some(anchor_node_input) = list.head(node_inputs)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n  let anchor_node_raw_key_and_link = get_raw_key_and_link(anchor_node_input)\n\n  // 4. anchor_node_input must be the last node of the list before the transaction.\n  expect is_last_node(get_link(anchor_node_raw_key_and_link))\n\n  // Verify the outputs:\n  // 5. node_outputs must have exactly two nodes: appended_node and anchor_node_output.\n  expect list.length(node_outputs) == 2\n  expect Some(appended_node) = list.at(node_outputs, appended_node_index)\n  let appended_node_raw_key_and_link = get_raw_key_and_link(appended_node)\n  expect Some(anchor_node_output) =\n    list.at(node_outputs, anchor_node_output_index)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 6. key_to_append must be a member of the list after the transaction,\n  //    as witnessed by appended_node.\n  expect is_member(key_to_append, get_key(appended_node_raw_key_and_link))\n\n  // 7. appended_node must be the last node of the list after the transaction.\n  expect is_last_node(get_link(appended_node_raw_key_and_link))\n\n  // 8. anchor node output must link to key to append.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: key_to_append,\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // 9. appended_node must not contain any other non-ADA tokens.\n  expect list.length(flatten(appended_node.value)) == 2\n\n  // Verify immutable data:\n  // 10. anchor_node input must match anchor_node output on address, value,\n  //     and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // 11. appended_node must match anchor_node_output on address.\n  expect appended_node.address == anchor_node_output.address\n\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.remove",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.remove",
      "name": "remove",
      "signature": "pub fn remove(pub fn remove(key_to_remove: NodeKey, removed_node_input_index: Int, anchor_node_input_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
      "documentation": "Remove a non-root node from the list.\n\nThe index arguments in this function are relative to the node_inputs\nand node_outputs. They are NOT absolute.",
      "parameters": [],
      "returnType": "Bool",
      "line": 378,
      "raw": "pub fn remove(pub fn remove(key_to_remove: NodeKey, removed_node_input_index: Int, anchor_node_input_index: Int, node_inputs: List<Output>, node_outputs: List<Output>, node_mint: Dict<AssetName, Int>, ) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn remove(\n  key_to_remove: NodeKey,\n  removed_node_input_index: Int,\n  anchor_node_input_index: Int,\n  node_inputs: List<Output>,\n  node_outputs: List<Output>,\n  node_mint: Dict<AssetName, Int>,\n) -> Bool {\n  // Verify the mint:\n  // 1. Let key_to_remove be the key being removed.\n  // 2. The transaction's sole effect on the list is to remove key_to_remove.\n  expect key_removed(key_to_remove, node_mint)\n\n  // Verify the inputs:\n  // 3. node_inputs must have exactly two nodes: removed_node and anchor_node_input.\n  expect list.length(node_inputs) == 2\n  expect Some(removed_node_input) =\n    list.at(node_inputs, removed_node_input_index)\n  let removed_node_raw_key_and_link = get_raw_key_and_link(removed_node_input)\n  expect Some(anchor_node_input) = list.at(node_inputs, anchor_node_input_index)\n  expect InlineDatum(anchor_node_input_datum) = anchor_node_input.datum\n  expect parsed_anchor_node_input_datum: NodeDatum = anchor_node_input_datum\n\n  // 4. key_to_remove must be a member of the list before the transaction,\n  //    as witnessed by removed_node.\n  expect is_member(key_to_remove, get_key(removed_node_raw_key_and_link))\n\n  // 5. anchor_node_input must link to key_to_remove.\n  expect parsed_anchor_node_input_datum.link == key_to_remove\n\n  // Verify the outputs:\n  // 6. node_outputs must be a singleton. Let anchor_node_output be its sole node.\n  expect list.length(node_outputs) == 1\n  expect Some(anchor_node_output) = list.head(node_outputs)\n  expect InlineDatum(anchor_node_output_datum) = anchor_node_output.datum\n  expect parsed_anchor_node_output_datum: NodeDatum = anchor_node_output_datum\n\n  // 7. anchor_node_output and removed_node must match on the link field.\n  //    In other words, they must both link to the same key.\n  let anchor_node_new_datum =\n    NodeDatum {\n      key: parsed_anchor_node_input_datum.key,\n      link: get_link(removed_node_raw_key_and_link),\n      data: parsed_anchor_node_input_datum.data,\n    }\n\n  // Verify immutable data:\n  // 8. anchor_node_input must match anchor_node_output on address, value,\n  //    and datum except for the link field.\n  expect anchor_node_input.address == anchor_node_output.address\n  expect anchor_node_input.value == anchor_node_output.value\n  expect anchor_node_new_datum == parsed_anchor_node_output_datum\n\n  // Done.\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.merkelized-validator.delegated_compute",
      "fullName": "anastasia:aiken-design-patterns.merkelized-validator.delegated_compute",
      "name": "delegated_compute",
      "signature": "pub fn delegated_compute(pub fn delegated_compute(function_input: a, staking_validator: ScriptHash, input_data_coercer: fn(Data) -> a, output_data_coercer: fn(Data) -> b, redeemers: Pairs<ScriptPurpose, Redeemer>,",
      "documentation": "Given an arbitrary `Data` as input, this function expects to find\na `Withdraw` script purpose in `redeemers` for `staking_validator`, with a\nredeemer of type [`WithdrawRedeemer<Data, Data>`](#withdrawredeemera-b),\nwhich will be coerced into your custom datatypes using your provided `Data`\nvalidators (`input_data_coercer` and `output_data_coercer`).",
      "parameters": [],
      "returnType": "a, output_data_coercer: fn(Data) -> b, redeemers: Pairs<ScriptPurpose, Redeemer>,",
      "line": 56,
      "raw": "pub fn delegated_compute(pub fn delegated_compute(function_input: a, staking_validator: ScriptHash, input_data_coercer: fn(Data) -> a, output_data_coercer: fn(Data) -> b, redeemers: Pairs<ScriptPurpose, Redeemer>,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn delegated_compute(\n  function_input: a,\n  staking_validator: ScriptHash,\n  input_data_coercer: fn(Data) -> a,\n  output_data_coercer: fn(Data) -> b,\n  redeemers: Pairs<ScriptPurpose, Redeemer>,\n) -> b {\n  expect Some(rdmr) =\n    redeemers\n      |> pairs.get_first(Withdraw(Script(staking_validator)))\n  expect WithdrawRedeemerIO { input_arg, result }: WithdrawRedeemerIO<\n    Data,\n    Data,\n  > = rdmr\n\n  let coerced_input = input_data_coercer(input_arg)\n\n  // Given input argument must be identical to the one provided to the\n  // withdrawal validator.\n  expect (coerced_input == function_input)?\n\n  // Return coerced result\n  output_data_coercer(result)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.merkelized-validator.delegated_validation",
      "fullName": "anastasia:aiken-design-patterns.merkelized-validator.delegated_validation",
      "name": "delegated_validation",
      "signature": "pub fn delegated_validation(pub fn delegated_validation(function_input: a, staking_validator: ScriptHash, input_data_coercer: fn(Data) -> a, redeemers: Pairs<ScriptPurpose, Redeemer>,",
      "documentation": "Similar to [`delegated_compute`](#delegated_compute), with the difference\nthat now values are expected to be returned by the staking script.",
      "parameters": [],
      "returnType": "a, redeemers: Pairs<ScriptPurpose, Redeemer>,",
      "line": 83,
      "raw": "pub fn delegated_validation(pub fn delegated_validation(function_input: a, staking_validator: ScriptHash, input_data_coercer: fn(Data) -> a, redeemers: Pairs<ScriptPurpose, Redeemer>,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn delegated_validation(\n  function_input: a,\n  staking_validator: ScriptHash,\n  input_data_coercer: fn(Data) -> a,\n  redeemers: Pairs<ScriptPurpose, Redeemer>,\n) -> Bool {\n  expect Some(rdmr) =\n    redeemers\n      |> pairs.get_first(Withdraw(Script(staking_validator)))\n  expect WithdrawRedeemer { input_arg }: WithdrawRedeemer<Data> = rdmr\n\n  let coerced_input = input_data_coercer(input_arg)\n\n  // Given input argument must be identical to the one provided to the\n  // withdrawal validator.\n  coerced_input == function_input\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.merkelized-validator.generic_delegated_validation",
      "fullName": "anastasia:aiken-design-patterns.merkelized-validator.generic_delegated_validation",
      "name": "generic_delegated_validation",
      "signature": "pub fn generic_delegated_validation(pub fn generic_delegated_validation(staking_validator: ScriptHash, withdraw_redeemer_validator: fn(Data) -> Bool, redeemers: Pairs<ScriptPurpose, Redeemer>,",
      "parameters": [],
      "returnType": "Bool, redeemers: Pairs<ScriptPurpose, Redeemer>,",
      "line": 101,
      "raw": "pub fn generic_delegated_validation(pub fn generic_delegated_validation(staking_validator: ScriptHash, withdraw_redeemer_validator: fn(Data) -> Bool, redeemers: Pairs<ScriptPurpose, Redeemer>,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn generic_delegated_validation(\n  staking_validator: ScriptHash,\n  withdraw_redeemer_validator: fn(Data) -> Bool,\n  redeemers: Pairs<ScriptPurpose, Redeemer>,\n) -> Bool {\n  expect Some(rdmr) =\n    redeemers\n      |> pairs.get_first(Withdraw(Script(staking_validator)))\n  withdraw_redeemer_validator(rdmr)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.merkelized-validator.withdraw_io",
      "fullName": "anastasia:aiken-design-patterns.merkelized-validator.withdraw_io",
      "name": "withdraw_io",
      "signature": "pub fn withdraw_io(pub fn withdraw_io(function: fn(a) -> b, redeemer: WithdrawRedeemerIO<a, b>,",
      "documentation": "Helper function for defining your \"computation stake validator.\" The\nresulting stake validator will carry out the provided `function`'s logic,\nand `redeemer` must contain the input(s) and expected output(s).",
      "parameters": [],
      "returnType": "b, redeemer: WithdrawRedeemerIO<a, b>,",
      "line": 115,
      "raw": "pub fn withdraw_io(pub fn withdraw_io(function: fn(a) -> b, redeemer: WithdrawRedeemerIO<a, b>,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn withdraw_io(\n  function: fn(a) -> b,\n  redeemer: WithdrawRedeemerIO<a, b>,\n) -> Bool {\n  let WithdrawRedeemerIO { input_arg, result } = redeemer\n  let computed_result = function(input_arg)\n  result == computed_result\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.merkelized-validator.withdraw",
      "fullName": "anastasia:aiken-design-patterns.merkelized-validator.withdraw",
      "name": "withdraw",
      "signature": "pub fn withdraw(pub fn withdraw(validation: fn(a) -> Bool, redeemer: WithdrawRedeemer<a>,",
      "documentation": "Helper function for defining your delegated validation. The resulting stake\nvalidator will carry out the provided `validation`'s logic with given\ninput(s) through its redeemer.",
      "parameters": [],
      "returnType": "Bool, redeemer: WithdrawRedeemer<a>,",
      "line": 127,
      "raw": "pub fn withdraw(pub fn withdraw(validation: fn(a) -> Bool, redeemer: WithdrawRedeemer<a>,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn withdraw(\n  validation: fn(a) -> Bool,\n  redeemer: WithdrawRedeemer<a>,\n) -> Bool {\n  let WithdrawRedeemer { input_arg } = redeemer\n  validation(input_arg)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.multi-utxo-indexer-one-to-many.withdraw_no_redeemer",
      "fullName": "anastasia:aiken-design-patterns.multi-utxo-indexer-one-to-many.withdraw_no_redeemer",
      "name": "withdraw_no_redeemer",
      "signature": "pub fn withdraw_no_redeemer(pub fn withdraw_no_redeemer(input_output_validator: fn(Int, Input, Int, Output) -> Bool, input_collective_outputs_validator: fn(Int, Input, List<Output>) -> Bool, collective_inputs_outputs_validator: fn(List<Input>, List<Output>) -> Bool, outer_indices: Pairs<Int, List<Int>>, total_input_count: Int, stake_cred: Credential, tx: Transaction,",
      "documentation": "Use this function inside your withdrawal script to validate all the inputs\ncoming from **the script's spend endpoint**. This is an important detail, as\nthe validator needs to guarantee an exact number of inputs are spent.\n\nIf you want to work with an external staking script, consider\nusing [`withdraw_with_redeemer`](#withdraw_with_redeemer).\n\nThe arguments are:\n1. Validation function on each input, and each of its corresponding outputs\n2. Validation function on each input, against all its outputs\n3. Validation function on all the inputs and all the outputs\n4. `Pairs` of indices, mapping each input to multiple outputs\n5. **Total** number of **inputs**\n6. Staking credential of the wrapping validator (provided by `withdraw`).\n**Note** that in this variant, it can only validate spending the UTxOs\nfrom its own spending endpoint\n7. `Transaction` provided by the validator\n\nFor validation functions, corresponding indices of inputs/outputs are also\nprovided in these functions.",
      "parameters": [],
      "returnType": "Bool, input_collective_outputs_validator: fn(Int, Input, List<Output>) -> Bool, collective_inputs_outputs_validator: fn(List<Input>, List<Output>) -> Bool, outer_indices: Pairs<Int, List<Int>>, total_input_count: Int, stake_cred: Credential, tx: Transaction,",
      "line": 34,
      "raw": "pub fn withdraw_no_redeemer(pub fn withdraw_no_redeemer(input_output_validator: fn(Int, Input, Int, Output) -> Bool, input_collective_outputs_validator: fn(Int, Input, List<Output>) -> Bool, collective_inputs_outputs_validator: fn(List<Input>, List<Output>) -> Bool, outer_indices: Pairs<Int, List<Int>>, total_input_count: Int, stake_cred: Credential, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn withdraw_no_redeemer(\n  input_output_validator: fn(Int, Input, Int, Output) -> Bool,\n  input_collective_outputs_validator: fn(Int, Input, List<Output>) -> Bool,\n  collective_inputs_outputs_validator: fn(List<Input>, List<Output>) -> Bool,\n  outer_indices: Pairs<Int, List<Int>>,\n  total_input_count: Int,\n  stake_cred: Credential,\n  tx: Transaction,\n) -> Bool {\n  stake_validator.withdraw(\n    fn(indices, own_validator, tx) {\n      let Transaction { inputs, outputs, .. } = tx\n      let\n        processed_indices,\n        _,\n        _,\n        all_inputs,\n        all_outputs,\n        remaining_script_inputs_count,\n      <-\n        list_extra.foldr6(\n          inputs,\n          list.reverse(indices),\n          total_input_count,\n          511,\n          [],\n          [],\n          total_input_count - 1,\n          fn(\n            input,\n            remaining_indices,\n            in0,\n            out0,\n            all_inputs_so_far,\n            all_outputs_so_far,\n            i,\n            return,\n          ) {\n            let next_i = i - 1\n            when input.output.address.payment_credential is {\n              Script(script) ->\n                if script == own_validator {\n                  when remaining_indices is {\n                    [] -> fail @\"More UTxOs are spent than specified\"\n                    [Pair(in1, outs), ..rest_of_indices] ->\n                      if i == in1 && in1 < in0 {\n                        let\n                          new_latest_out_ix,\n                          collected_outputs,\n                          all_outputs_so_far_updated,\n                        <-\n                          list_extra.foldr3(\n                            outs,\n                            out0,\n                            [],\n                            all_outputs_so_far,\n                            fn(\n                              curr_out_ix,\n                              prev_out_ix,\n                              outputs_so_far,\n                              outer_all_outputs,\n                              inner_return,\n                            ) {\n                              if curr_out_ix < prev_out_ix {\n                                expect Some(out_utxo) =\n                                  outputs |> list.at(curr_out_ix)\n                                if input_output_validator(\n                                  in1,\n                                  input,\n                                  curr_out_ix,\n                                  out_utxo,\n                                ) {\n                                  inner_return(\n                                    curr_out_ix,\n                                    list.push(outputs_so_far, out_utxo),\n                                    list.push(outer_all_outputs, out_utxo),\n                                  )\n                                } else {\n                                  fail @\"Validation on an input with one of its corresponding outputs failed\"\n                                }\n                              } else {\n                                fail @\"All output indices must be in ascending order\"\n                              }\n                            },\n                          )\n                        if input_collective_outputs_validator(\n                          in1,\n                          input,\n                          collected_outputs,\n                        ) {\n                          return(\n                            rest_of_indices,\n                            in1,\n                            new_latest_out_ix,\n                            list.push(all_inputs_so_far, input),\n                            all_outputs_so_far_updated,\n                            next_i,\n                          )\n                        } else {\n                          fail @\"Validation on the output count failed\"\n                        }\n                      } else {\n                        fail @\"Input and output indices must be in ascending orders\"\n                      }\n                  }\n                } else {\n                  return(\n                    remaining_indices,\n                    in0,\n                    out0,\n                    all_inputs_so_far,\n                    all_outputs_so_far,\n                    next_i,\n                  )\n                }\n              _ ->\n                return(\n                  remaining_indices,\n                  in0,\n                  out0,\n                  all_inputs_so_far,\n                  all_outputs_so_far,\n                  next_i,\n                )\n            }\n          },\n        )\n      and {\n        collective_inputs_outputs_validator(all_inputs, all_outputs),\n        list.is_empty(processed_indices),\n        remaining_script_inputs_count == -1,\n      }\n    },\n    outer_indices,\n    stake_cred,\n    tx,\n  )\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.multi-utxo-indexer-one-to-many.withdraw_with_redeemer",
      "fullName": "anastasia:aiken-design-patterns.multi-utxo-indexer-one-to-many.withdraw_with_redeemer",
      "name": "withdraw_with_redeemer",
      "signature": "pub fn withdraw_with_redeemer(pub fn withdraw_with_redeemer(spend_redeemer_coercer_and_stake_credential_extractor: fn(Redeemer) -> (a, Credential), input_output_validator: fn(Int, Input, a, Int, Output) -> Bool, input_collective_outputs_validator: fn(Int, Input, a, List<Output>) -> Bool, collective_inputs_outputs_validator: fn(List<Input>, List<Output>) -> Bool, indices: Pairs<Int, List<Int>>, total_script_inputs: Int, stake_cred: Credential, tx: Transaction,",
      "documentation": "A variant of [`withdraw_no_redeemer`](#withdraw_no_redeemer). The difference\nhere is that it gives access to the spend redeemers to your validation\nfunctions.\n\nNote that your spend redeemers are expected to carry the `Credential` to the\nresulting staking script (which is the purpose of the first argument).\n\nThe arguments are:\n1. Validation function on each input, and each of its corresponding outputs\n2. Validation function on each input, against all its outputs\n3. Validation function on all the inputs and all the outputs\n4. `Pairs` of indices, mapping each input to multiple outputs\n5. **Total** number of **script inputs**\n6. Staking credential of the wrapping validator (provided by `withdraw`)\n7. `Transaction` provided by the validator\n\nFor validation functions, corresponding indices of inputs/outputs are also\nprovided in these functions.\n\nUnder the hood, one other difference is that here, instead of traversing all\nthe inputs, there are two traversals: one over the `redeemers`, and another\nover the indices.",
      "parameters": [],
      "returnType": "(a, Credential), input_output_validator: fn(Int, Input, a, Int, Output) -> Bool, input_collective_outputs_validator: fn(Int, Input, a, List<Output>) -> Bool, collective_inputs_outputs_validator: fn(List<Input>, List<Output>) -> Bool, indices: Pairs<Int, List<Int>>, total_script_inputs: Int, stake_cred: Credential, tx: Transaction,",
      "line": 195,
      "raw": "pub fn withdraw_with_redeemer(pub fn withdraw_with_redeemer(spend_redeemer_coercer_and_stake_credential_extractor: fn(Redeemer) -> (a, Credential), input_output_validator: fn(Int, Input, a, Int, Output) -> Bool, input_collective_outputs_validator: fn(Int, Input, a, List<Output>) -> Bool, collective_inputs_outputs_validator: fn(List<Input>, List<Output>) -> Bool, indices: Pairs<Int, List<Int>>, total_script_inputs: Int, stake_cred: Credential, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn withdraw_with_redeemer(\n  spend_redeemer_coercer_and_stake_credential_extractor: fn(Redeemer) ->\n    (a, Credential),\n  input_output_validator: fn(Int, Input, a, Int, Output) -> Bool,\n  input_collective_outputs_validator: fn(Int, Input, a, List<Output>) -> Bool,\n  collective_inputs_outputs_validator: fn(List<Input>, List<Output>) -> Bool,\n  indices: Pairs<Int, List<Int>>,\n  total_script_inputs: Int,\n  stake_cred: Credential,\n  tx: Transaction,\n) -> Bool {\n  let Transaction { inputs, outputs, redeemers, .. } = tx\n  // Folding from left so that redeemers are ordered in reverse. This allows\n  // for cheaper collection of UTxOs in the next fold.\n  let script_redeemers =\n    list.foldl(\n      redeemers,\n      [],\n      fn(redeemer, acc) {\n        let Pair(redeemer_purpose, redeemer_data) = redeemer\n        when redeemer_purpose is {\n          Spend(_) -> {\n            let (coerced_redeemer, stake_credential_from_spend_redeemer) =\n              spend_redeemer_coercer_and_stake_credential_extractor(\n                redeemer_data,\n              )\n            if stake_cred == stake_credential_from_spend_redeemer {\n              list.push(acc, coerced_redeemer)\n            } else {\n              acc\n            }\n          }\n          _ -> acc\n        }\n      },\n    )\n  let\n    processed_redeemers,\n    _,\n    _,\n    all_inputs,\n    all_outputs,\n    remaining_script_inputs_count,\n  <-\n    list_extra.foldr6(\n      indices,\n      script_redeemers,\n      511,\n      511,\n      [],\n      [],\n      total_script_inputs - 1,\n      fn(\n        curr_input_outputs_indices,\n        remaining_redeemers,\n        in0,\n        out0,\n        all_inputs_so_far,\n        all_outputs_so_far,\n        i,\n        return,\n      ) {\n        let next_i = i - 1\n        let Pair(in1, outs) = curr_input_outputs_indices\n        if in1 < in0 {\n          expect Some(in_utxo) = inputs |> list.at(in1)\n          when remaining_redeemers is {\n            [] -> fail @\"More UTxOs are spent than there are redeemers\"\n            [current_redeemer, ..rest_of_redeemers] -> {\n              let\n                new_latest_out_ix,\n                collected_outputs,\n                all_outputs_so_far_updated,\n              <-\n                list_extra.foldr3(\n                  outs,\n                  out0,\n                  [],\n                  all_outputs_so_far,\n                  fn(\n                    curr_out_ix,\n                    prev_out_ix,\n                    outputs_so_far,\n                    outer_all_outputs,\n                    inner_return,\n                  ) {\n                    if curr_out_ix < prev_out_ix {\n                      expect Some(out_utxo) = outputs |> list.at(curr_out_ix)\n                      if input_output_validator(\n                        in1,\n                        in_utxo,\n                        current_redeemer,\n                        curr_out_ix,\n                        out_utxo,\n                      ) {\n                        inner_return(\n                          curr_out_ix,\n                          list.push(outputs_so_far, out_utxo),\n                          list.push(outer_all_outputs, out_utxo),\n                        )\n                      } else {\n                        fail @\"Validation on an input with one of its corresponding outputs failed\"\n                      }\n                    } else {\n                      fail @\"All output indices must be in ascending order\"\n                    }\n                  },\n                )\n              if input_collective_outputs_validator(\n                in1,\n                in_utxo,\n                current_redeemer,\n                collected_outputs,\n              ) {\n                return(\n                  rest_of_redeemers,\n                  in1,\n                  new_latest_out_ix,\n                  list.push(all_inputs_so_far, in_utxo),\n                  all_outputs_so_far_updated,\n                  next_i,\n                )\n              } else {\n                fail @\"Validation on the output count failed\"\n              }\n            }\n          }\n        } else {\n          fail @\"All input indices must be in ascending order\"\n        }\n      },\n    )\n  and {\n    collective_inputs_outputs_validator(all_inputs, all_outputs),\n    list.is_empty(processed_redeemers),\n    remaining_script_inputs_count == -1,\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.multi-utxo-indexer.withdraw_no_redeemer",
      "fullName": "anastasia:aiken-design-patterns.multi-utxo-indexer.withdraw_no_redeemer",
      "name": "withdraw_no_redeemer",
      "signature": "pub fn withdraw_no_redeemer(pub fn withdraw_no_redeemer(validation_logic: fn(Int, Input, Int, Output) -> Bool, indices: Pairs<Int, Int>, stake_cred: Credential, tx: Transaction,",
      "documentation": "Helper function to complement your staking script. Note that this function\nexpects to see an equal number of inputs coming from addresses whose payment\nparts are **equal to its own** (`stake_cred`). This is an important detail,\nas the validator needs to guarantee an exact number of inputs are spent.\n\nThe validation function you should provide has access to:\n- Index of the `Input` being validated\n- The `Input` itself\n- Index of the `Output` being validated\n- The `Output` itself",
      "parameters": [],
      "returnType": "Bool, indices: Pairs<Int, Int>, stake_cred: Credential, tx: Transaction,",
      "line": 24,
      "raw": "pub fn withdraw_no_redeemer(pub fn withdraw_no_redeemer(validation_logic: fn(Int, Input, Int, Output) -> Bool, indices: Pairs<Int, Int>, stake_cred: Credential, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn withdraw_no_redeemer(\n  validation_logic: fn(Int, Input, Int, Output) -> Bool,\n  indices: Pairs<Int, Int>,\n  stake_cred: Credential,\n  tx: Transaction,\n) -> Bool {\n  stake_validator.withdraw(\n    fn(indices, own_validator, tx) {\n      let Transaction { inputs, outputs, .. } = tx\n      let\n        processed_indices,\n        _,\n        _,\n        _,\n      <-\n        list_extra.foldl4(\n          inputs,\n          indices,\n          -1,\n          -1,\n          0,\n          fn(input, remaining_indices, in0, out0, i, return) {\n            let next_i = i + 1\n            when input.output.address.payment_credential is {\n              Script(script) ->\n                if script == own_validator {\n                  when remaining_indices is {\n                    [] -> fail @\"More UTxOs are spent than specified\"\n                    [Pair(in1, out1), ..rest_of_indices] ->\n                      if i == in1 && in1 > in0 && out1 > out0 {\n                        expect Some(out_utxo) = outputs |> list.at(out1)\n                        if validation_logic(in1, input, out1, out_utxo) {\n                          return(rest_of_indices, in1, out1, next_i)\n                        } else {\n                          fail @\"Validation failed\"\n                        }\n                      } else {\n                        fail @\"Input and output indices must be in ascending orders\"\n                      }\n                  }\n                } else {\n                  return(remaining_indices, in0, out0, next_i)\n                }\n              _ -> return(remaining_indices, in0, out0, next_i)\n            }\n          },\n        )\n      (processed_indices == [])?\n    },\n    indices,\n    stake_cred,\n    tx,\n  )\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.multi-utxo-indexer.withdraw_with_redeemer",
      "fullName": "anastasia:aiken-design-patterns.multi-utxo-indexer.withdraw_with_redeemer",
      "name": "withdraw_with_redeemer",
      "signature": "pub fn withdraw_with_redeemer(pub fn withdraw_with_redeemer(spend_redeemer_coercer_and_stake_credential_extractor: fn(Data) -> (a, Credential), validation_logic: fn(Int, Input, a, Int, Output) -> Bool, indices: Pairs<Int, Int>, stake_cred: Credential, tx: Transaction,",
      "documentation": "Another variant that is independent of the spending validator, and also\nprovides the validation logic with each UTxO's redeemer. Subsequently, an\nadditional argument must be provided, capable of coercing a redeemer `Data`\nto spending script's redeemer, and also extracting the staking credential of\nthe script that performs the validation.\n\nUnder the hood, one other difference is that here, instead of traversing all\nthe inputs, there are two traversals: one over the `redeemers`, and another\nover the indices.",
      "parameters": [],
      "returnType": "(a, Credential), validation_logic: fn(Int, Input, a, Int, Output) -> Bool, indices: Pairs<Int, Int>, stake_cred: Credential, tx: Transaction,",
      "line": 88,
      "raw": "pub fn withdraw_with_redeemer(pub fn withdraw_with_redeemer(spend_redeemer_coercer_and_stake_credential_extractor: fn(Data) -> (a, Credential), validation_logic: fn(Int, Input, a, Int, Output) -> Bool, indices: Pairs<Int, Int>, stake_cred: Credential, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn withdraw_with_redeemer(\n  spend_redeemer_coercer_and_stake_credential_extractor: fn(Data) ->\n    (a, Credential),\n  validation_logic: fn(Int, Input, a, Int, Output) -> Bool,\n  indices: Pairs<Int, Int>,\n  stake_cred: Credential,\n  tx: Transaction,\n) -> Bool {\n  let Transaction { inputs, outputs, redeemers, .. } = tx\n  let script_redeemers =\n    list.foldr(\n      redeemers,\n      [],\n      fn(redeemer, acc) {\n        let Pair(redeemer_purpose, redeemer_data) = redeemer\n        when redeemer_purpose is {\n          Spend(_) -> {\n            let (coerced_redeemer, stake_credential_from_spend_redeemer) =\n              spend_redeemer_coercer_and_stake_credential_extractor(\n                redeemer_data,\n              )\n            if stake_cred == stake_credential_from_spend_redeemer {\n              list.push(acc, coerced_redeemer)\n            } else {\n              acc\n            }\n          }\n          _ -> acc\n        }\n      },\n    )\n  let\n    processed_redeemers,\n    _,\n    _,\n    _,\n  <-\n    list_extra.foldl4(\n      indices,\n      script_redeemers,\n      -1,\n      -1,\n      0,\n      fn(curr_in_out_indices, remaining_script_redeemers, in0, out0, i, return) {\n        when remaining_script_redeemers is {\n          [] -> fail @\"Too many indices specified\"\n          [script_redeemer, ..rest_of_script_redeemers] -> {\n            let Pair(in1, out1) = curr_in_out_indices\n            if in1 > in0 && out1 > out0 {\n              expect Some(in_utxo) = inputs |> list.at(in1)\n              expect Some(out_utxo) = outputs |> list.at(out1)\n              if validation_logic(in1, in_utxo, script_redeemer, out1, out_utxo) {\n                return(rest_of_script_redeemers, in1, out1, i + 1)\n              } else {\n                fail @\"Validation failed\"\n              }\n            } else {\n              // Input and output indices must be ordered to disallow duplicates.\n              fail @\"Input and output indices must be in ascending orders\"\n            }\n          }\n        }\n      },\n    )\n  (processed_redeemers == [])?\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.apply_param",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.apply_param",
      "name": "apply_param",
      "signature": "pub fn apply_param(pub fn apply_param(version: Int, prefix: ByteArray, param: ByteArray, ) -> ScriptHash {",
      "documentation": "Use this inside your dependent script for single parameter scripts. The\nparameter must be serialised before getting passed here. It'll be hashed\nwith `blake2b_224` before placement after `prefix`.\n\nNote that your prefix should be from a single CBOR encoded result. And also,\nthe version should either be 1, 2, or 3 depending on your script.",
      "parameters": [],
      "returnType": "ScriptHash",
      "line": 73,
      "raw": "pub fn apply_param(pub fn apply_param(version: Int, prefix: ByteArray, param: ByteArray, ) -> ScriptHash {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn apply_param(\n  version: Int,\n  prefix: ByteArray,\n  param: ByteArray,\n) -> ScriptHash {\n  append_first_param_to_prefix(version, prefix, param)\n    |> bytearray.concat(postfix)\n    |> blake2b_224\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.apply_prehashed_param",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.apply_prehashed_param",
      "name": "apply_prehashed_param",
      "signature": "pub fn apply_prehashed_param(pub fn apply_prehashed_param(version: Int, prefix: ByteArray, param: ByteArray, ) -> ScriptHash {",
      "documentation": "Similar to [`apply_param`](#apply_param), but for scripts that their\nparameters don't need to be resolved (e.g. have a script hash as their\nparameter).\n\nNote that `blake2b_224` is the presumed hashing algorithm, i.e. the\nparameter is expected to be 28 bytes long.",
      "parameters": [],
      "returnType": "ScriptHash",
      "line": 89,
      "raw": "pub fn apply_prehashed_param(pub fn apply_prehashed_param(version: Int, prefix: ByteArray, param: ByteArray, ) -> ScriptHash {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn apply_prehashed_param(\n  version: Int,\n  prefix: ByteArray,\n  param: ByteArray,\n) -> ScriptHash {\n  append_first_prehashed_param_to_prefix(version, prefix, param)\n    |> bytearray.concat(postfix)\n    |> blake2b_224\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.apply_param_2",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.apply_param_2",
      "name": "apply_param_2",
      "signature": "pub fn apply_param_2(pub fn apply_param_2(version: Int, prefix: ByteArray, param_0: ByteArray, param_1: ByteArray, ) -> ScriptHash {",
      "documentation": "Similar to [`apply_param`](#apply_param), but for scripts with 2 parameters.",
      "parameters": [],
      "returnType": "ScriptHash",
      "line": 100,
      "raw": "pub fn apply_param_2(pub fn apply_param_2(version: Int, prefix: ByteArray, param_0: ByteArray, param_1: ByteArray, ) -> ScriptHash {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn apply_param_2(\n  version: Int,\n  prefix: ByteArray,\n  param_0: ByteArray,\n  param_1: ByteArray,\n) -> ScriptHash {\n  append_first_param_to_prefix(version, prefix, param_0)\n    |> bytearray.concat(param_header_28_bytes)\n    |> append_param(param_1)\n    |> bytearray.concat(postfix)\n    |> blake2b_224\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.apply_prehashed_param_2",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.apply_prehashed_param_2",
      "name": "apply_prehashed_param_2",
      "signature": "pub fn apply_prehashed_param_2(pub fn apply_prehashed_param_2(version: Int, prefix: ByteArray, param_0: ByteArray, param_1: ByteArray, ) -> ScriptHash {",
      "documentation": "Similar to [`apply_prehashed_param`](#apply_prehashed_param), but for\nscripts with 2 parameters.",
      "parameters": [],
      "returnType": "ScriptHash",
      "line": 115,
      "raw": "pub fn apply_prehashed_param_2(pub fn apply_prehashed_param_2(version: Int, prefix: ByteArray, param_0: ByteArray, param_1: ByteArray, ) -> ScriptHash {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn apply_prehashed_param_2(\n  version: Int,\n  prefix: ByteArray,\n  param_0: ByteArray,\n  param_1: ByteArray,\n) -> ScriptHash {\n  append_first_prehashed_param_to_prefix(version, prefix, param_0)\n    |> bytearray.concat(param_header_28_bytes)\n    |> bytearray.concat(param_1)\n    |> bytearray.concat(postfix)\n    |> blake2b_224\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.apply_param_3",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.apply_param_3",
      "name": "apply_param_3",
      "signature": "pub fn apply_param_3(pub fn apply_param_3(version: Int, prefix: ByteArray, param_0: ByteArray, param_1: ByteArray, param_2: ByteArray, ) -> ScriptHash {",
      "documentation": "Similar to [`apply_param`](#apply_param), but for scripts with 3 parameters.",
      "parameters": [],
      "returnType": "ScriptHash",
      "line": 129,
      "raw": "pub fn apply_param_3(pub fn apply_param_3(version: Int, prefix: ByteArray, param_0: ByteArray, param_1: ByteArray, param_2: ByteArray, ) -> ScriptHash {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn apply_param_3(\n  version: Int,\n  prefix: ByteArray,\n  param_0: ByteArray,\n  param_1: ByteArray,\n  param_2: ByteArray,\n) -> ScriptHash {\n  append_first_param_to_prefix(version, prefix, param_0)\n    |> bytearray.concat(param_header_28_bytes)\n    |> append_param(param_1)\n    |> bytearray.concat(param_header_28_bytes)\n    |> append_param(param_2)\n    |> bytearray.concat(postfix)\n    |> blake2b_224\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.apply_prehashed_param_3",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.apply_prehashed_param_3",
      "name": "apply_prehashed_param_3",
      "signature": "pub fn apply_prehashed_param_3(pub fn apply_prehashed_param_3(version: Int, prefix: ByteArray, param_0: ByteArray, param_1: ByteArray, param_2: ByteArray, ) -> ScriptHash {",
      "documentation": "Similar to [`apply_prehashed_param`](#apply_prehashed_param), but for\nscripts with 3 parameters.",
      "parameters": [],
      "returnType": "ScriptHash",
      "line": 147,
      "raw": "pub fn apply_prehashed_param_3(pub fn apply_prehashed_param_3(version: Int, prefix: ByteArray, param_0: ByteArray, param_1: ByteArray, param_2: ByteArray, ) -> ScriptHash {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn apply_prehashed_param_3(\n  version: Int,\n  prefix: ByteArray,\n  param_0: ByteArray,\n  param_1: ByteArray,\n  param_2: ByteArray,\n) -> ScriptHash {\n  append_first_prehashed_param_to_prefix(version, prefix, param_0)\n    |> bytearray.concat(param_header_28_bytes)\n    |> bytearray.concat(param_1)\n    |> bytearray.concat(param_header_28_bytes)\n    |> bytearray.concat(param_2)\n    |> bytearray.concat(postfix)\n    |> blake2b_224\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.spend_wrapper",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.spend_wrapper",
      "name": "spend_wrapper",
      "signature": "pub fn spend_wrapper(pub fn spend_wrapper(hashed_parameter: Hash<Blake2b_224, p>, parameter_serialiser: fn(p) -> ByteArray, validator_function: fn(p, Option<d>, redeemer, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: ParameterizedRedeemer<p, redeemer>, output_reference: OutputReference, tx: Transaction,",
      "documentation": "Helper function for parameterized spending scripts, which takes care of\nvalidating resolved parameter hashes, provides you with both the parameter,\nand your custom redeemer.",
      "parameters": [],
      "returnType": "ByteArray, validator_function: fn(p, Option<d>, redeemer, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: ParameterizedRedeemer<p, redeemer>, output_reference: OutputReference, tx: Transaction,",
      "line": 172,
      "raw": "pub fn spend_wrapper(pub fn spend_wrapper(hashed_parameter: Hash<Blake2b_224, p>, parameter_serialiser: fn(p) -> ByteArray, validator_function: fn(p, Option<d>, redeemer, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: ParameterizedRedeemer<p, redeemer>, output_reference: OutputReference, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn spend_wrapper(\n  hashed_parameter: Hash<Blake2b_224, p>,\n  parameter_serialiser: fn(p) -> ByteArray,\n  validator_function: fn(p, Option<d>, redeemer, OutputReference, Transaction) ->\n    Bool,\n  datum: Option<d>,\n  outer_redeemer: ParameterizedRedeemer<p, redeemer>,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  let ParameterizedRedeemer { param, redeemer } = outer_redeemer\n  expect (blake2b_224(parameter_serialiser(param)) == hashed_parameter)?\n  validator_function(param, datum, redeemer, output_reference, tx)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.no_datum_wrapper",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.no_datum_wrapper",
      "name": "no_datum_wrapper",
      "signature": "pub fn no_datum_wrapper(pub fn no_datum_wrapper(hashed_parameter: Hash<Blake2b_224, p>, parameter_serialiser: fn(p) -> ByteArray, validator_function: fn(p, redeemer, endpoint_specific, Transaction) -> Bool, outer_redeemer: ParameterizedRedeemer<p, redeemer>, variable_arg: endpoint_specific, tx: Transaction,",
      "documentation": "Similar to [`spend_wrapper`](#spend_wrapper), but for other endpoints that\nare not provided with a datum (mint, withdraw, etc.).",
      "parameters": [],
      "returnType": "ByteArray, validator_function: fn(p, redeemer, endpoint_specific, Transaction) -> Bool, outer_redeemer: ParameterizedRedeemer<p, redeemer>, variable_arg: endpoint_specific, tx: Transaction,",
      "line": 189,
      "raw": "pub fn no_datum_wrapper(pub fn no_datum_wrapper(hashed_parameter: Hash<Blake2b_224, p>, parameter_serialiser: fn(p) -> ByteArray, validator_function: fn(p, redeemer, endpoint_specific, Transaction) -> Bool, outer_redeemer: ParameterizedRedeemer<p, redeemer>, variable_arg: endpoint_specific, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn no_datum_wrapper(\n  hashed_parameter: Hash<Blake2b_224, p>,\n  parameter_serialiser: fn(p) -> ByteArray,\n  validator_function: fn(p, redeemer, endpoint_specific, Transaction) -> Bool,\n  outer_redeemer: ParameterizedRedeemer<p, redeemer>,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  let ParameterizedRedeemer { param, redeemer } = outer_redeemer\n  expect (blake2b_224(parameter_serialiser(param)) == hashed_parameter)?\n  validator_function(param, redeemer, variable_arg, tx)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.spend_wrapper_2",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.spend_wrapper_2",
      "name": "spend_wrapper_2",
      "signature": "pub fn spend_wrapper_2(pub fn spend_wrapper_2(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, Option<d>, r, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: ParameterizedRedeemer2<p, q, r>, output_reference: OutputReference, tx: Transaction,",
      "parameters": [],
      "returnType": "ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, Option<d>, r, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: ParameterizedRedeemer2<p, q, r>, output_reference: OutputReference, tx: Transaction,",
      "line": 208,
      "raw": "pub fn spend_wrapper_2(pub fn spend_wrapper_2(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, Option<d>, r, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: ParameterizedRedeemer2<p, q, r>, output_reference: OutputReference, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn spend_wrapper_2(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  validator_function: fn(p, q, Option<d>, r, OutputReference, Transaction) ->\n    Bool,\n  datum: Option<d>,\n  outer_redeemer: ParameterizedRedeemer2<p, q, r>,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  let ParameterizedRedeemer2 { param_0, param_1, redeemer } = outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n    }?\n  validator_function(param_0, param_1, datum, redeemer, output_reference, tx)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.no_datum_wrapper_2",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.no_datum_wrapper_2",
      "name": "no_datum_wrapper_2",
      "signature": "pub fn no_datum_wrapper_2(pub fn no_datum_wrapper_2(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, redeemer, endpoint_specific, Transaction) -> Bool, outer_redeemer: ParameterizedRedeemer2<p, q, redeemer>, variable_arg: endpoint_specific, tx: Transaction,",
      "parameters": [],
      "returnType": "ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, redeemer, endpoint_specific, Transaction) -> Bool, outer_redeemer: ParameterizedRedeemer2<p, q, redeemer>, variable_arg: endpoint_specific, tx: Transaction,",
      "line": 228,
      "raw": "pub fn no_datum_wrapper_2(pub fn no_datum_wrapper_2(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, redeemer, endpoint_specific, Transaction) -> Bool, outer_redeemer: ParameterizedRedeemer2<p, q, redeemer>, variable_arg: endpoint_specific, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn no_datum_wrapper_2(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  validator_function: fn(p, q, redeemer, endpoint_specific, Transaction) -> Bool,\n  outer_redeemer: ParameterizedRedeemer2<p, q, redeemer>,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  let ParameterizedRedeemer2 { param_0, param_1, redeemer } = outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n    }?\n  validator_function(param_0, param_1, redeemer, variable_arg, tx)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.spend_wrapper_3",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.spend_wrapper_3",
      "name": "spend_wrapper_3",
      "signature": "pub fn spend_wrapper_3(pub fn spend_wrapper_3(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, hashed_parameter_2: Hash<Blake2b_224, s>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, Option<d>, r, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: ParameterizedRedeemer3<p, q, s, r>, output_reference: OutputReference, tx: Transaction,",
      "parameters": [],
      "returnType": "ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, Option<d>, r, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: ParameterizedRedeemer3<p, q, s, r>, output_reference: OutputReference, tx: Transaction,",
      "line": 253,
      "raw": "pub fn spend_wrapper_3(pub fn spend_wrapper_3(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, hashed_parameter_2: Hash<Blake2b_224, s>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, Option<d>, r, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: ParameterizedRedeemer3<p, q, s, r>, output_reference: OutputReference, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn spend_wrapper_3(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  hashed_parameter_2: Hash<Blake2b_224, s>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  parameter_serialiser_2: fn(s) -> ByteArray,\n  validator_function: fn(p, q, s, Option<d>, r, OutputReference, Transaction) ->\n    Bool,\n  datum: Option<d>,\n  outer_redeemer: ParameterizedRedeemer3<p, q, s, r>,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  let ParameterizedRedeemer3 { param_0, param_1, param_2, redeemer } =\n    outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n      blake2b_224(parameter_serialiser_2(param_2)) == hashed_parameter_2,\n    }?\n  validator_function(\n    param_0,\n    param_1,\n    param_2,\n    datum,\n    redeemer,\n    output_reference,\n    tx,\n  )\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.no_datum_wrapper_3",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.no_datum_wrapper_3",
      "name": "no_datum_wrapper_3",
      "signature": "pub fn no_datum_wrapper_3(pub fn no_datum_wrapper_3(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, hashed_parameter_2: Hash<Blake2b_224, s>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, redeemer, endpoint_specific, Transaction) -> Bool, outer_redeemer: ParameterizedRedeemer3<p, q, s, redeemer>, variable_arg: endpoint_specific, tx: Transaction,",
      "parameters": [],
      "returnType": "ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, redeemer, endpoint_specific, Transaction) -> Bool, outer_redeemer: ParameterizedRedeemer3<p, q, s, redeemer>, variable_arg: endpoint_specific, tx: Transaction,",
      "line": 285,
      "raw": "pub fn no_datum_wrapper_3(pub fn no_datum_wrapper_3(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, hashed_parameter_2: Hash<Blake2b_224, s>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, redeemer, endpoint_specific, Transaction) -> Bool, outer_redeemer: ParameterizedRedeemer3<p, q, s, redeemer>, variable_arg: endpoint_specific, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn no_datum_wrapper_3(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  hashed_parameter_2: Hash<Blake2b_224, s>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  parameter_serialiser_2: fn(s) -> ByteArray,\n  validator_function: fn(p, q, s, redeemer, endpoint_specific, Transaction) ->\n    Bool,\n  outer_redeemer: ParameterizedRedeemer3<p, q, s, redeemer>,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  let ParameterizedRedeemer3 { param_0, param_1, param_2, redeemer } =\n    outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n      blake2b_224(parameter_serialiser_2(param_2)) == hashed_parameter_2,\n    }?\n  validator_function(param_0, param_1, param_2, redeemer, variable_arg, tx)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.spend_wrapper_no_redeemer",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.spend_wrapper_no_redeemer",
      "name": "spend_wrapper_no_redeemer",
      "signature": "pub fn spend_wrapper_no_redeemer(pub fn spend_wrapper_no_redeemer(hashed_parameter: Hash<Blake2b_224, p>, parameter_serialiser: fn(p) -> ByteArray, validator_function: fn(p, Option<d>, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: Parameter<p>, output_reference: OutputReference, tx: Transaction,",
      "documentation": "Wrapper function for spending scripts with one parameter that don't need a\nredeemer.",
      "parameters": [],
      "returnType": "ByteArray, validator_function: fn(p, Option<d>, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: Parameter<p>, output_reference: OutputReference, tx: Transaction,",
      "line": 315,
      "raw": "pub fn spend_wrapper_no_redeemer(pub fn spend_wrapper_no_redeemer(hashed_parameter: Hash<Blake2b_224, p>, parameter_serialiser: fn(p) -> ByteArray, validator_function: fn(p, Option<d>, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: Parameter<p>, output_reference: OutputReference, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn spend_wrapper_no_redeemer(\n  hashed_parameter: Hash<Blake2b_224, p>,\n  parameter_serialiser: fn(p) -> ByteArray,\n  validator_function: fn(p, Option<d>, OutputReference, Transaction) -> Bool,\n  datum: Option<d>,\n  outer_redeemer: Parameter<p>,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  let Parameter { param } = outer_redeemer\n  expect (blake2b_224(parameter_serialiser(param)) == hashed_parameter)?\n  validator_function(param, datum, output_reference, tx)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.no_datum_wrapper_no_redeemer",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.no_datum_wrapper_no_redeemer",
      "name": "no_datum_wrapper_no_redeemer",
      "signature": "pub fn no_datum_wrapper_no_redeemer(pub fn no_datum_wrapper_no_redeemer(hashed_parameter: Hash<Blake2b_224, p>, parameter_serialiser: fn(p) -> ByteArray, validator_function: fn(p, endpoint_specific, Transaction) -> Bool, outer_redeemer: Parameter<p>, variable_arg: endpoint_specific, tx: Transaction,",
      "documentation": "Wrapper function for datumless scripts with one parameters that don't need a\nredeemer.",
      "parameters": [],
      "returnType": "ByteArray, validator_function: fn(p, endpoint_specific, Transaction) -> Bool, outer_redeemer: Parameter<p>, variable_arg: endpoint_specific, tx: Transaction,",
      "line": 331,
      "raw": "pub fn no_datum_wrapper_no_redeemer(pub fn no_datum_wrapper_no_redeemer(hashed_parameter: Hash<Blake2b_224, p>, parameter_serialiser: fn(p) -> ByteArray, validator_function: fn(p, endpoint_specific, Transaction) -> Bool, outer_redeemer: Parameter<p>, variable_arg: endpoint_specific, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn no_datum_wrapper_no_redeemer(\n  hashed_parameter: Hash<Blake2b_224, p>,\n  parameter_serialiser: fn(p) -> ByteArray,\n  validator_function: fn(p, endpoint_specific, Transaction) -> Bool,\n  outer_redeemer: Parameter<p>,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  let Parameter { param } = outer_redeemer\n  expect (blake2b_224(parameter_serialiser(param)) == hashed_parameter)?\n  validator_function(param, variable_arg, tx)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.spend_wrapper_no_redeemer_2",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.spend_wrapper_no_redeemer_2",
      "name": "spend_wrapper_no_redeemer_2",
      "signature": "pub fn spend_wrapper_no_redeemer_2(pub fn spend_wrapper_no_redeemer_2(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, Option<d>, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: Parameter2<p, q>, output_reference: OutputReference, tx: Transaction,",
      "parameters": [],
      "returnType": "ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, Option<d>, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: Parameter2<p, q>, output_reference: OutputReference, tx: Transaction,",
      "line": 349,
      "raw": "pub fn spend_wrapper_no_redeemer_2(pub fn spend_wrapper_no_redeemer_2(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, Option<d>, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: Parameter2<p, q>, output_reference: OutputReference, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn spend_wrapper_no_redeemer_2(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  validator_function: fn(p, q, Option<d>, OutputReference, Transaction) -> Bool,\n  datum: Option<d>,\n  outer_redeemer: Parameter2<p, q>,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  let Parameter2 { param_0, param_1 } = outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n    }?\n  validator_function(param_0, param_1, datum, output_reference, tx)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.no_datum_wrapper_no_redeemer_2",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.no_datum_wrapper_no_redeemer_2",
      "name": "no_datum_wrapper_no_redeemer_2",
      "signature": "pub fn no_datum_wrapper_no_redeemer_2(pub fn no_datum_wrapper_no_redeemer_2(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, endpoint_specific, Transaction) -> Bool, outer_redeemer: Parameter2<p, q>, variable_arg: endpoint_specific, tx: Transaction,",
      "parameters": [],
      "returnType": "ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, endpoint_specific, Transaction) -> Bool, outer_redeemer: Parameter2<p, q>, variable_arg: endpoint_specific, tx: Transaction,",
      "line": 368,
      "raw": "pub fn no_datum_wrapper_no_redeemer_2(pub fn no_datum_wrapper_no_redeemer_2(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, validator_function: fn(p, q, endpoint_specific, Transaction) -> Bool, outer_redeemer: Parameter2<p, q>, variable_arg: endpoint_specific, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn no_datum_wrapper_no_redeemer_2(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  validator_function: fn(p, q, endpoint_specific, Transaction) -> Bool,\n  outer_redeemer: Parameter2<p, q>,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  let Parameter2 { param_0, param_1 } = outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n    }?\n  validator_function(param_0, param_1, variable_arg, tx)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.spend_wrapper_no_redeemer_3",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.spend_wrapper_no_redeemer_3",
      "name": "spend_wrapper_no_redeemer_3",
      "signature": "pub fn spend_wrapper_no_redeemer_3(pub fn spend_wrapper_no_redeemer_3(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, hashed_parameter_2: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, Option<d>, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: Parameter3<p, q, s>, output_reference: OutputReference, tx: Transaction,",
      "parameters": [],
      "returnType": "ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, Option<d>, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: Parameter3<p, q, s>, output_reference: OutputReference, tx: Transaction,",
      "line": 392,
      "raw": "pub fn spend_wrapper_no_redeemer_3(pub fn spend_wrapper_no_redeemer_3(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, hashed_parameter_2: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, Option<d>, OutputReference, Transaction) -> Bool, datum: Option<d>, outer_redeemer: Parameter3<p, q, s>, output_reference: OutputReference, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn spend_wrapper_no_redeemer_3(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  hashed_parameter_2: Hash<Blake2b_224, q>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  parameter_serialiser_2: fn(s) -> ByteArray,\n  validator_function: fn(p, q, s, Option<d>, OutputReference, Transaction) ->\n    Bool,\n  datum: Option<d>,\n  outer_redeemer: Parameter3<p, q, s>,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  let Parameter3 { param_0, param_1, param_2 } = outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n      blake2b_224(parameter_serialiser_2(param_2)) == hashed_parameter_2,\n    }?\n  validator_function(param_0, param_1, param_2, datum, output_reference, tx)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.no_datum_wrapper_no_redeemer_3",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.no_datum_wrapper_no_redeemer_3",
      "name": "no_datum_wrapper_no_redeemer_3",
      "signature": "pub fn no_datum_wrapper_no_redeemer_3(pub fn no_datum_wrapper_no_redeemer_3(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, hashed_parameter_2: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, endpoint_specific, Transaction) -> Bool, outer_redeemer: Parameter3<p, q, s>, variable_arg: endpoint_specific, tx: Transaction,",
      "parameters": [],
      "returnType": "ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, endpoint_specific, Transaction) -> Bool, outer_redeemer: Parameter3<p, q, s>, variable_arg: endpoint_specific, tx: Transaction,",
      "line": 415,
      "raw": "pub fn no_datum_wrapper_no_redeemer_3(pub fn no_datum_wrapper_no_redeemer_3(hashed_parameter_0: Hash<Blake2b_224, p>, hashed_parameter_1: Hash<Blake2b_224, q>, hashed_parameter_2: Hash<Blake2b_224, q>, parameter_serialiser_0: fn(p) -> ByteArray, parameter_serialiser_1: fn(q) -> ByteArray, parameter_serialiser_2: fn(s) -> ByteArray, validator_function: fn(p, q, s, endpoint_specific, Transaction) -> Bool, outer_redeemer: Parameter3<p, q, s>, variable_arg: endpoint_specific, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn no_datum_wrapper_no_redeemer_3(\n  hashed_parameter_0: Hash<Blake2b_224, p>,\n  hashed_parameter_1: Hash<Blake2b_224, q>,\n  hashed_parameter_2: Hash<Blake2b_224, q>,\n  parameter_serialiser_0: fn(p) -> ByteArray,\n  parameter_serialiser_1: fn(q) -> ByteArray,\n  parameter_serialiser_2: fn(s) -> ByteArray,\n  validator_function: fn(p, q, s, endpoint_specific, Transaction) -> Bool,\n  outer_redeemer: Parameter3<p, q, s>,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  let Parameter3 { param_0, param_1, param_2 } = outer_redeemer\n  expect and {\n      blake2b_224(parameter_serialiser_0(param_0)) == hashed_parameter_0,\n      blake2b_224(parameter_serialiser_1(param_1)) == hashed_parameter_1,\n      blake2b_224(parameter_serialiser_2(param_2)) == hashed_parameter_2,\n    }?\n  validator_function(param_0, param_1, param_2, variable_arg, tx)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.prehashed_param_spend_wrapper",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.prehashed_param_spend_wrapper",
      "name": "prehashed_param_spend_wrapper",
      "signature": "pub fn prehashed_param_spend_wrapper(pub fn prehashed_param_spend_wrapper(validator_function: fn( Hash<Blake2b_224, a>, Option<d>, redeemer, OutputReference, Transaction, ) -> Bool, parameter: Hash<Blake2b_224, a>, datum: Option<d>, redeemer: redeemer, output_reference: OutputReference, tx: Transaction,",
      "documentation": "Helper function for spending scripts that are parameterized by a single hash\nvalue which is not needed to be resolved.\n\nThe purpose of theses wrappers is to make the parameters appear only once in\nthe resulting CBORs.",
      "parameters": [],
      "returnType": "Bool, parameter: Hash<Blake2b_224, a>, datum: Option<d>, redeemer: redeemer, output_reference: OutputReference, tx: Transaction,",
      "line": 441,
      "raw": "pub fn prehashed_param_spend_wrapper(pub fn prehashed_param_spend_wrapper(validator_function: fn( Hash<Blake2b_224, a>, Option<d>, redeemer, OutputReference, Transaction, ) -> Bool, parameter: Hash<Blake2b_224, a>, datum: Option<d>, redeemer: redeemer, output_reference: OutputReference, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn prehashed_param_spend_wrapper(\n  validator_function: fn(\n    Hash<Blake2b_224, a>,\n    Option<d>,\n    redeemer,\n    OutputReference,\n    Transaction,\n  ) ->\n    Bool,\n  parameter: Hash<Blake2b_224, a>,\n  datum: Option<d>,\n  redeemer: redeemer,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  validator_function(parameter, datum, redeemer, output_reference, tx)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.prehashed_param_no_datum_wrapper",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.prehashed_param_no_datum_wrapper",
      "name": "prehashed_param_no_datum_wrapper",
      "signature": "pub fn prehashed_param_no_datum_wrapper(pub fn prehashed_param_no_datum_wrapper(validator_function: fn( Hash<Blake2b_224, a>, redeemer, endpoint_specific, Transaction, ) -> Bool, param: Hash<Blake2b_224, a>, redeemer: redeemer, variable_arg: endpoint_specific, tx: Transaction,",
      "documentation": "Similar to [`prehashed_param_spend_wrapper`](#prehashed_param_spend_wrapper), but\nfor other endpoints that are not provided with a datum (mint, withdraw,\netc.).",
      "parameters": [],
      "returnType": "Bool, param: Hash<Blake2b_224, a>, redeemer: redeemer, variable_arg: endpoint_specific, tx: Transaction,",
      "line": 462,
      "raw": "pub fn prehashed_param_no_datum_wrapper(pub fn prehashed_param_no_datum_wrapper(validator_function: fn( Hash<Blake2b_224, a>, redeemer, endpoint_specific, Transaction, ) -> Bool, param: Hash<Blake2b_224, a>, redeemer: redeemer, variable_arg: endpoint_specific, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn prehashed_param_no_datum_wrapper(\n  validator_function: fn(\n    Hash<Blake2b_224, a>,\n    redeemer,\n    endpoint_specific,\n    Transaction,\n  ) ->\n    Bool,\n  param: Hash<Blake2b_224, a>,\n  redeemer: redeemer,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  validator_function(param, redeemer, variable_arg, tx)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.prehashed_param_spend_wrapper_2",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.prehashed_param_spend_wrapper_2",
      "name": "prehashed_param_spend_wrapper_2",
      "signature": "pub fn prehashed_param_spend_wrapper_2(pub fn prehashed_param_spend_wrapper_2(validator_function: fn( Hash<Blake2b_224, a>, Hash<Blake2b_224, b>, Option<d>, redeemer, OutputReference, Transaction, ) -> Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, datum: Option<d>, redeemer: redeemer, output_reference: OutputReference, tx: Transaction,",
      "parameters": [],
      "returnType": "Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, datum: Option<d>, redeemer: redeemer, output_reference: OutputReference, tx: Transaction,",
      "line": 478,
      "raw": "pub fn prehashed_param_spend_wrapper_2(pub fn prehashed_param_spend_wrapper_2(validator_function: fn( Hash<Blake2b_224, a>, Hash<Blake2b_224, b>, Option<d>, redeemer, OutputReference, Transaction, ) -> Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, datum: Option<d>, redeemer: redeemer, output_reference: OutputReference, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn prehashed_param_spend_wrapper_2(\n  validator_function: fn(\n    Hash<Blake2b_224, a>,\n    Hash<Blake2b_224, b>,\n    Option<d>,\n    redeemer,\n    OutputReference,\n    Transaction,\n  ) ->\n    Bool,\n  parameter_0: Hash<Blake2b_224, a>,\n  parameter_1: Hash<Blake2b_224, b>,\n  datum: Option<d>,\n  redeemer: redeemer,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  validator_function(\n    parameter_0,\n    parameter_1,\n    datum,\n    redeemer,\n    output_reference,\n    tx,\n  )\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.prehashed_param_no_datum_wrapper_2",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.prehashed_param_no_datum_wrapper_2",
      "name": "prehashed_param_no_datum_wrapper_2",
      "signature": "pub fn prehashed_param_no_datum_wrapper_2(pub fn prehashed_param_no_datum_wrapper_2(validator_function: fn( Hash<Blake2b_224, a>, Hash<Blake2b_224, b>, redeemer, endpoint_specific, Transaction, ) -> Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, redeemer: redeemer, variable_arg: endpoint_specific, tx: Transaction,",
      "parameters": [],
      "returnType": "Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, redeemer: redeemer, variable_arg: endpoint_specific, tx: Transaction,",
      "line": 505,
      "raw": "pub fn prehashed_param_no_datum_wrapper_2(pub fn prehashed_param_no_datum_wrapper_2(validator_function: fn( Hash<Blake2b_224, a>, Hash<Blake2b_224, b>, redeemer, endpoint_specific, Transaction, ) -> Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, redeemer: redeemer, variable_arg: endpoint_specific, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn prehashed_param_no_datum_wrapper_2(\n  validator_function: fn(\n    Hash<Blake2b_224, a>,\n    Hash<Blake2b_224, b>,\n    redeemer,\n    endpoint_specific,\n    Transaction,\n  ) ->\n    Bool,\n  parameter_0: Hash<Blake2b_224, a>,\n  parameter_1: Hash<Blake2b_224, b>,\n  redeemer: redeemer,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  validator_function(parameter_0, parameter_1, redeemer, variable_arg, tx)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.prehashed_param_spend_wrapper_3",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.prehashed_param_spend_wrapper_3",
      "name": "prehashed_param_spend_wrapper_3",
      "signature": "pub fn prehashed_param_spend_wrapper_3(pub fn prehashed_param_spend_wrapper_3(validator_function: fn( Hash<Blake2b_224, a>, Hash<Blake2b_224, b>, Hash<Blake2b_224, c>, Option<d>, redeemer, OutputReference, Transaction, ) -> Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, parameter_2: Hash<Blake2b_224, c>, datum: Option<d>, redeemer: redeemer, output_reference: OutputReference, tx: Transaction,",
      "parameters": [],
      "returnType": "Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, parameter_2: Hash<Blake2b_224, c>, datum: Option<d>, redeemer: redeemer, output_reference: OutputReference, tx: Transaction,",
      "line": 523,
      "raw": "pub fn prehashed_param_spend_wrapper_3(pub fn prehashed_param_spend_wrapper_3(validator_function: fn( Hash<Blake2b_224, a>, Hash<Blake2b_224, b>, Hash<Blake2b_224, c>, Option<d>, redeemer, OutputReference, Transaction, ) -> Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, parameter_2: Hash<Blake2b_224, c>, datum: Option<d>, redeemer: redeemer, output_reference: OutputReference, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn prehashed_param_spend_wrapper_3(\n  validator_function: fn(\n    Hash<Blake2b_224, a>,\n    Hash<Blake2b_224, b>,\n    Hash<Blake2b_224, c>,\n    Option<d>,\n    redeemer,\n    OutputReference,\n    Transaction,\n  ) ->\n    Bool,\n  parameter_0: Hash<Blake2b_224, a>,\n  parameter_1: Hash<Blake2b_224, b>,\n  parameter_2: Hash<Blake2b_224, c>,\n  datum: Option<d>,\n  redeemer: redeemer,\n  output_reference: OutputReference,\n  tx: Transaction,\n) -> Bool {\n  validator_function(\n    parameter_0,\n    parameter_1,\n    parameter_2,\n    datum,\n    redeemer,\n    output_reference,\n    tx,\n  )\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.prehashed_param_no_datum_wrapper_3",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.prehashed_param_no_datum_wrapper_3",
      "name": "prehashed_param_no_datum_wrapper_3",
      "signature": "pub fn prehashed_param_no_datum_wrapper_3(pub fn prehashed_param_no_datum_wrapper_3(validator_function: fn( Hash<Blake2b_224, a>, Hash<Blake2b_224, b>, Hash<Blake2b_224, c>, redeemer, endpoint_specific, Transaction, ) -> Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, parameter_2: Hash<Blake2b_224, c>, redeemer: redeemer, variable_arg: endpoint_specific, tx: Transaction,",
      "parameters": [],
      "returnType": "Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, parameter_2: Hash<Blake2b_224, c>, redeemer: redeemer, variable_arg: endpoint_specific, tx: Transaction,",
      "line": 553,
      "raw": "pub fn prehashed_param_no_datum_wrapper_3(pub fn prehashed_param_no_datum_wrapper_3(validator_function: fn( Hash<Blake2b_224, a>, Hash<Blake2b_224, b>, Hash<Blake2b_224, c>, redeemer, endpoint_specific, Transaction, ) -> Bool, parameter_0: Hash<Blake2b_224, a>, parameter_1: Hash<Blake2b_224, b>, parameter_2: Hash<Blake2b_224, c>, redeemer: redeemer, variable_arg: endpoint_specific, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn prehashed_param_no_datum_wrapper_3(\n  validator_function: fn(\n    Hash<Blake2b_224, a>,\n    Hash<Blake2b_224, b>,\n    Hash<Blake2b_224, c>,\n    redeemer,\n    endpoint_specific,\n    Transaction,\n  ) ->\n    Bool,\n  parameter_0: Hash<Blake2b_224, a>,\n  parameter_1: Hash<Blake2b_224, b>,\n  parameter_2: Hash<Blake2b_224, c>,\n  redeemer: redeemer,\n  variable_arg: endpoint_specific,\n  tx: Transaction,\n) -> Bool {\n  validator_function(\n    parameter_0,\n    parameter_1,\n    parameter_2,\n    redeemer,\n    variable_arg,\n    tx,\n  )\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.singular-utxo-indexer.one_to_one",
      "fullName": "anastasia:aiken-design-patterns.singular-utxo-indexer.one_to_one",
      "name": "one_to_one",
      "signature": "pub fn one_to_one(pub fn one_to_one(validation_logic: fn(Input, Output) -> Bool, input_index: Int, output_index: Int, own_ref: OutputReference, inputs: List<Input>, outputs: List<Output>, double_satisfaction_prevented: Bool,",
      "documentation": "Helper function to be defined in the spending endpoint of your contract, for\nappointing an input at `input_index` against an output at `output_index`. By\nincluding this in your spending endpoint, you'll get an efficient access to\nyour input, and its corresponding output.\n\nWithin the function you pass as `validation_logic`, you have access to the\npicked input and output.\n\nApart from `validation_logic`, the only other validation this function\nperforms for you is the equality of the picked input's output reference with\nthe one extracted from [`ScriptInfo`](https://aiken-lang.github.io/stdlib/cardano/script_context.html#ScriptInfo).\n\n`double_satisfaction_prevented` is a required `Bool`, which is just a\nreminder that this function does NOT cover the\n[double satisfaction](https://github.com/Plutonomicon/plutonomicon/blob/b6906173c3f98fb5d7b40fd206f9d6fe14d0b03b/vulnerabilities.md#double-satisfaction)\nvulnerability out-of-the-box.",
      "parameters": [],
      "returnType": "Bool, input_index: Int, output_index: Int, own_ref: OutputReference, inputs: List<Input>, outputs: List<Output>, double_satisfaction_prevented: Bool,",
      "line": 22,
      "raw": "pub fn one_to_one(pub fn one_to_one(validation_logic: fn(Input, Output) -> Bool, input_index: Int, output_index: Int, own_ref: OutputReference, inputs: List<Input>, outputs: List<Output>, double_satisfaction_prevented: Bool,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn one_to_one(\n  validation_logic: fn(Input, Output) -> Bool,\n  input_index: Int,\n  output_index: Int,\n  own_ref: OutputReference,\n  inputs: List<Input>,\n  outputs: List<Output>,\n  double_satisfaction_prevented: Bool,\n) -> Bool {\n  expect double_satisfaction_prevented\n  expect Some(Input { output_reference: in_ref, .. } as in_input) =\n    inputs |> list.at(input_index)\n\n  expect Some(out_utxo) = outputs |> list.at(output_index)\n\n  // Indicated input must match the spending one.\n  expect own_ref == in_ref\n\n  validation_logic(in_input, out_utxo)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.singular-utxo-indexer.one_to_many",
      "fullName": "anastasia:aiken-design-patterns.singular-utxo-indexer.one_to_many",
      "name": "one_to_many",
      "signature": "pub fn one_to_many(pub fn one_to_many(input_output_validator: fn(Input, Int, Output) -> Bool, input_collective_outputs_validator: fn(Input, List<Output>) -> Bool, input_index: Int, output_indices: List<Int>, own_ref: OutputReference, inputs: List<Input>, outputs: List<Output>, double_satisfaction_prevented: Bool,",
      "documentation": "Helper function for appointing an input against a set of outputs in a\ntransaction. Similar to [`one_to_one`](#one_to-one), this function also\nvalidates the spent UTxO's output reference matches the one found using the\ninput index.\n\nRequired validation functions are provided with:\n1. `Input` itself, output index, and `Output` itself (this validation is\nexecuted for each output)\n2. `Input` itself, and the list of all `Output`s (this validation is\nexecuted only once)\n\nHere we also have the `double_satisfaction_prevented` argument as a mere\nreminder that this function does not cover double satisfaction on its own.",
      "parameters": [],
      "returnType": "Bool, input_collective_outputs_validator: fn(Input, List<Output>) -> Bool, input_index: Int, output_indices: List<Int>, own_ref: OutputReference, inputs: List<Input>, outputs: List<Output>, double_satisfaction_prevented: Bool,",
      "line": 56,
      "raw": "pub fn one_to_many(pub fn one_to_many(input_output_validator: fn(Input, Int, Output) -> Bool, input_collective_outputs_validator: fn(Input, List<Output>) -> Bool, input_index: Int, output_indices: List<Int>, own_ref: OutputReference, inputs: List<Input>, outputs: List<Output>, double_satisfaction_prevented: Bool,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn one_to_many(\n  input_output_validator: fn(Input, Int, Output) -> Bool,\n  input_collective_outputs_validator: fn(Input, List<Output>) -> Bool,\n  input_index: Int,\n  output_indices: List<Int>,\n  own_ref: OutputReference,\n  inputs: List<Input>,\n  outputs: List<Output>,\n  double_satisfaction_prevented: Bool,\n) -> Bool {\n  expect double_satisfaction_prevented\n  expect Some(input) = inputs |> list.at(input_index)\n\n  let\n    _,\n    all_outputs,\n  <-\n    list_extra.foldr2(\n      output_indices,\n      // sufficiently large index to ensure first check passes\n      511,\n      [],\n      fn(curr_ix, prev_ix, outputs_acc, return) {\n        if curr_ix < prev_ix {\n          expect Some(out_utxo) = outputs |> list.at(curr_ix)\n          expect input_output_validator(input, curr_ix, out_utxo)\n          return(curr_ix, list.push(outputs_acc, out_utxo))\n        } else {\n          fail @\"Output indices must be in ascending order\"\n        }\n      },\n    )\n\n  // Indicated input must match the spending one.\n  expect (own_ref == input.output_reference)?\n\n  input_collective_outputs_validator(input, all_outputs)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.stake-validator.spend",
      "fullName": "anastasia:aiken-design-patterns.stake-validator.spend",
      "name": "spend",
      "signature": "pub fn spend(pub fn spend(withdraw_script_hash: ScriptHash, withdraw_redeemer_validator: fn(Redeemer, Lovelace) -> Bool, tx: Transaction,",
      "documentation": "Helper function for implementing validation for spending UTxOs, essentially\ndelegating their requirements to the given withdrawal validator.\n\nIn simpler terms, it says: As long as there is a reward withdrawal of the\ngiven script in transaction, this UTxO can be spent.\n\nAllows you to validate based on both the withdrawal's redeemer (mostly\nuseful for ensuring specific endpoints are invoked), and the withdrawal\nLovelace count.",
      "parameters": [],
      "returnType": "Bool, tx: Transaction,",
      "line": 29,
      "raw": "pub fn spend(pub fn spend(withdraw_script_hash: ScriptHash, withdraw_redeemer_validator: fn(Redeemer, Lovelace) -> Bool, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn spend(\n  withdraw_script_hash: ScriptHash,\n  withdraw_redeemer_validator: fn(Redeemer, Lovelace) -> Bool,\n  tx: Transaction,\n) -> Bool {\n  let Transaction { redeemers, withdrawals, .. } = tx\n\n  let withdraw_script = Script(withdraw_script_hash)\n\n  let withdraw_purpose = Withdraw(withdraw_script)\n\n  let withdraw_redeemer: Redeemer =\n    redeemers |> pairs.get_first(withdraw_purpose)\n\n  expect Some(withdraw_amount) = withdrawals |> pairs.get_first(withdraw_script)\n\n  withdraw_redeemer_validator(withdraw_redeemer, withdraw_amount)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.stake-validator.spend_minimal",
      "fullName": "anastasia:aiken-design-patterns.stake-validator.spend_minimal",
      "name": "spend_minimal",
      "signature": "pub fn spend_minimal(withdraw_script_hash: ScriptHash, tx: Transaction) -> Bool {",
      "documentation": "A more minimal version of [`spend`](#spend), where only the `withdrawals`\nfield is traversed, and no other validations are performed.",
      "parameters": [
        {
          "name": "withdraw_script_hash",
          "type": "ScriptHash",
          "optional": false
        },
        {
          "name": "tx",
          "type": "Transaction",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 50,
      "raw": "pub fn spend_minimal(withdraw_script_hash: ScriptHash, tx: Transaction) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn spend_minimal(withdraw_script_hash: ScriptHash, tx: Transaction) -> Bool {\n  let Transaction { withdrawals, .. } = tx\n\n  let withdraw_script = Script(withdraw_script_hash)\n\n  when withdrawals |> pairs.get_first(withdraw_script) is {\n    Some(_) -> True\n    _ -> False\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.stake-validator.withdraw",
      "fullName": "anastasia:aiken-design-patterns.stake-validator.withdraw",
      "name": "withdraw",
      "signature": "pub fn withdraw(pub fn withdraw(withdrawal_logic: fn(a, ScriptHash, Transaction) -> Bool, redeemer: a, stake_cred: Credential, tx: Transaction,",
      "documentation": "Function to be used under your withdrawal endpoint. The only convenience\nthis function provides is that it'll provide you with the `ScriptHash` of\nyour withdrawal script, so that you don't have to unwrap it yourself.",
      "parameters": [],
      "returnType": "Bool, redeemer: a, stake_cred: Credential, tx: Transaction,",
      "line": 64,
      "raw": "pub fn withdraw(pub fn withdraw(withdrawal_logic: fn(a, ScriptHash, Transaction) -> Bool, redeemer: a, stake_cred: Credential, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn withdraw(\n  withdrawal_logic: fn(a, ScriptHash, Transaction) -> Bool,\n  redeemer: a,\n  stake_cred: Credential,\n  tx: Transaction,\n) -> Bool {\n  expect Script(own_validator) = stake_cred\n\n  withdrawal_logic(redeemer, own_validator, tx)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.tx-level-minter.spend",
      "fullName": "anastasia:aiken-design-patterns.tx-level-minter.spend",
      "name": "spend",
      "signature": "pub fn spend(pub fn spend(mint_script_hash: PolicyId, mint_redeemer_validator: fn(Redeemer) -> Bool, mint_tokens_validator: fn(Dict<AssetName, Int>) -> Bool, tx: Transaction,",
      "documentation": "Function to be used under the spending endpoint of your validator. It looks\nat both the redeemers, and minted tokens to allow you validate both its\nredeemer, and its tokens getting minted/burnt.",
      "parameters": [],
      "returnType": "Bool, mint_tokens_validator: fn(Dict<AssetName, Int>) -> Bool, tx: Transaction,",
      "line": 26,
      "raw": "pub fn spend(pub fn spend(mint_script_hash: PolicyId, mint_redeemer_validator: fn(Redeemer) -> Bool, mint_tokens_validator: fn(Dict<AssetName, Int>) -> Bool, tx: Transaction,",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn spend(\n  mint_script_hash: PolicyId,\n  mint_redeemer_validator: fn(Redeemer) -> Bool,\n  mint_tokens_validator: fn(Dict<AssetName, Int>) -> Bool,\n  tx: Transaction,\n) -> Bool {\n  let Transaction { mint, redeemers, .. } = tx\n\n  let mint_purpose = Mint(mint_script_hash)\n\n  let mint_redeemer: Redeemer = redeemers |> pairs.get_first(mint_purpose)\n\n  let tokens = mint |> assets.tokens(mint_script_hash)\n\n  and {\n    mint_redeemer_validator(mint_redeemer),\n    mint_tokens_validator(tokens),\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.tx-level-minter.spend_minimal",
      "fullName": "anastasia:aiken-design-patterns.tx-level-minter.spend_minimal",
      "name": "spend_minimal",
      "signature": "pub fn spend_minimal(mint_script_hash: PolicyId, tx: Transaction) -> Bool {",
      "documentation": "A minimal version of [`spend`](#spend), where the only validation is\npresence of at least one minting/burning action with the given policy ID.",
      "parameters": [
        {
          "name": "mint_script_hash",
          "type": "PolicyId",
          "optional": false
        },
        {
          "name": "tx",
          "type": "Transaction",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 48,
      "raw": "pub fn spend_minimal(mint_script_hash: PolicyId, tx: Transaction) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn spend_minimal(mint_script_hash: PolicyId, tx: Transaction) -> Bool {\n  !(tx.mint |> assets.tokens(mint_script_hash) |> dict.is_empty)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.sort_inputs",
      "fullName": "anastasia:aiken-design-patterns.utils.sort_inputs",
      "name": "sort_inputs",
      "signature": "pub fn sort_inputs(inputs: List<Input>) -> List<Input> {",
      "parameters": [
        {
          "name": "inputs",
          "type": "List<Input>",
          "optional": false
        }
      ],
      "returnType": "List<Input>",
      "line": 12,
      "raw": "pub fn sort_inputs(inputs: List<Input>) -> List<Input> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn sort_inputs(inputs: List<Input>) -> List<Input> {\n  inputs\n    |> list.sort(\n        fn(i0: Input, i1: Input) {\n          output_reference.compare(i0.output_reference, i1.output_reference)\n        },\n      )\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.resolve_output_reference",
      "fullName": "anastasia:aiken-design-patterns.utils.resolve_output_reference",
      "name": "resolve_output_reference",
      "signature": "pub fn resolve_output_reference(pub fn resolve_output_reference(inputs: List<Input>, output_ref: OutputReference, ) -> Output {",
      "documentation": "Copied from [Fortuna](https://github.com/cardano-miners/fortuna/blob/5eeb1bc31b72252b991bbcaf836b128dca6a74b9/lib/fortuna/utils.ak#L6-L17).",
      "parameters": [],
      "returnType": "Output",
      "line": 22,
      "raw": "pub fn resolve_output_reference(pub fn resolve_output_reference(inputs: List<Input>, output_ref: OutputReference, ) -> Output {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn resolve_output_reference(\n  inputs: List<Input>,\n  output_ref: OutputReference,\n) -> Output {\n  expect [input, ..] = inputs\n\n  if input.output_reference == output_ref {\n    input.output\n  } else {\n    resolve_output_reference(builtin.tail_list(inputs), output_ref)\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.authentic_input_is_reproduced_unchanged",
      "fullName": "anastasia:aiken-design-patterns.utils.authentic_input_is_reproduced_unchanged",
      "name": "authentic_input_is_reproduced_unchanged",
      "signature": "pub fn authentic_input_is_reproduced_unchanged(pub fn authentic_input_is_reproduced_unchanged(auth_symbol: PolicyId, optional_auth_name: Option<AssetName>, in_utxo: Output, out_utxo: Output, ) -> Bool {",
      "parameters": [],
      "returnType": "Bool",
      "line": 35,
      "raw": "pub fn authentic_input_is_reproduced_unchanged(pub fn authentic_input_is_reproduced_unchanged(auth_symbol: PolicyId, optional_auth_name: Option<AssetName>, in_utxo: Output, out_utxo: Output, ) -> Bool {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn authentic_input_is_reproduced_unchanged(\n  auth_symbol: PolicyId,\n  optional_auth_name: Option<AssetName>,\n  in_utxo: Output,\n  out_utxo: Output,\n) -> Bool {\n  expect Output {\n    value: in_val,\n    datum: in_dat,\n    address: in_addr,\n    reference_script: None,\n  } = in_utxo\n  expect Output {\n    value: out_val,\n    datum: out_dat,\n    address: out_addr,\n    reference_script: None,\n  } = out_utxo\n\n  expect [_, (in_sym, in_name, in_quantity)] = in_val |> assets.flatten\n\n  let name_is_authentic =\n    when optional_auth_name is {\n      Some(auth_name) -> in_name == auth_name\n      None -> True\n    }\n  and {\n    in_val == out_val,\n    in_dat == out_dat,\n    in_addr.payment_credential == out_addr.payment_credential,\n    in_sym == auth_symbol,\n    name_is_authentic,\n    in_quantity == 1,\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.sum_of_squares",
      "fullName": "anastasia:aiken-design-patterns.utils.sum_of_squares",
      "name": "sum_of_squares",
      "signature": "pub fn sum_of_squares(xs: List<Int>) -> Int {",
      "parameters": [
        {
          "name": "xs",
          "type": "List<Int>",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 71,
      "raw": "pub fn sum_of_squares(xs: List<Int>) -> Int {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn sum_of_squares(xs: List<Int>) -> Int {\n  xs |> foldl(0, fn(x, acc) { acc + x * x })\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.find_index_of_first_script_input",
      "fullName": "anastasia:aiken-design-patterns.utils.find_index_of_first_script_input",
      "name": "find_index_of_first_script_input",
      "signature": "pub fn find_index_of_first_script_input(inputs: List<Input>) -> Int {",
      "documentation": "Given a list of inputs, this function returns the index of the first inputs\nwhich its address has a `Script` payment part.",
      "parameters": [
        {
          "name": "inputs",
          "type": "List<Input>",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 77,
      "raw": "pub fn find_index_of_first_script_input(inputs: List<Input>) -> Int {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn find_index_of_first_script_input(inputs: List<Input>) -> Int {\n  expect Some(input_index) =\n    list.indexed_foldr(\n      inputs,\n      None,\n      fn(i, input, m_i) {\n        when m_i is {\n          Some(_) -> m_i\n          None ->\n            when input.output.address.payment_credential is {\n              Script(_) -> Some(i)\n              _ -> None\n            }\n        }\n      },\n    )\n  input_index\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.single_specific_asset_value_fuzzer",
      "fullName": "anastasia:aiken-design-patterns.utils.single_specific_asset_value_fuzzer",
      "name": "single_specific_asset_value_fuzzer",
      "signature": "pub fn single_specific_asset_value_fuzzer(policyId: ByteArray) -> Fuzzer<Value> {",
      "documentation": "A fuzzer for `Value` with a single asset. Unsafely expects 28 bytes long\npolicy ID to be provided.",
      "parameters": [
        {
          "name": "policyId",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "Fuzzer<Value>",
      "line": 98,
      "raw": "pub fn single_specific_asset_value_fuzzer(policyId: ByteArray) -> Fuzzer<Value> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn single_specific_asset_value_fuzzer(policyId: ByteArray) -> Fuzzer<Value> {\n  let token_name <- and_then(fuzz.bytearray_between(0, 32))\n  let quantity <- and_then(fuzz.int_at_least(1))\n  fuzz.constant(assets.from_asset(policyId, token_name, quantity))\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.single_asset_value_fuzzer",
      "fullName": "anastasia:aiken-design-patterns.utils.single_asset_value_fuzzer",
      "name": "single_asset_value_fuzzer",
      "signature": "pub fn single_asset_value_fuzzer() -> Fuzzer<Value> {",
      "documentation": "A `Value` fuzzer with a single asset. Randomly generates the policy ID.",
      "parameters": [],
      "returnType": "Fuzzer<Value>",
      "line": 105,
      "raw": "pub fn single_asset_value_fuzzer() -> Fuzzer<Value> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn single_asset_value_fuzzer() -> Fuzzer<Value> {\n  let policyId <- and_then(fuzz.bytearray_fixed(28))\n  single_specific_asset_value_fuzzer(policyId)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.mint_fuzzer",
      "fullName": "anastasia:aiken-design-patterns.utils.mint_fuzzer",
      "name": "mint_fuzzer",
      "signature": "pub fn mint_fuzzer() -> Fuzzer<Value> {",
      "documentation": "A `Value` fuzzer without any lovelaces.",
      "parameters": [],
      "returnType": "Fuzzer<Value>",
      "line": 111,
      "raw": "pub fn mint_fuzzer() -> Fuzzer<Value> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn mint_fuzzer() -> Fuzzer<Value> {\n  let other_assets_values <-\n    and_then(fuzz.list_between(single_asset_value_fuzzer(), 1, 10))\n  fuzz.constant(\n    list.foldl(\n      other_assets_values,\n      assets.zero,\n      fn(v, acc) { assets.merge(v, acc) },\n    ),\n  )\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.value_fuzzer",
      "fullName": "anastasia:aiken-design-patterns.utils.value_fuzzer",
      "name": "value_fuzzer",
      "signature": "pub fn value_fuzzer(min_lovelaces: Int) -> Fuzzer<Value> {",
      "documentation": "A `Value` fuzzer, guaranteed to include some amount of ADA (minimum must be\nspecified).",
      "parameters": [
        {
          "name": "min_lovelaces",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Fuzzer<Value>",
      "line": 125,
      "raw": "pub fn value_fuzzer(min_lovelaces: Int) -> Fuzzer<Value> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn value_fuzzer(min_lovelaces: Int) -> Fuzzer<Value> {\n  let lovelace_count <- and_then(fuzz.int_at_least(min_lovelaces))\n  let lovelace_value = assets.from_lovelace(lovelace_count)\n  let other_assets_values <-\n    and_then(fuzz.list_at_most(single_asset_value_fuzzer(), 10))\n  fuzz.constant(\n    list.foldl(\n      other_assets_values,\n      lovelace_value,\n      fn(v, acc) { assets.merge(v, acc) },\n    ),\n  )\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.output_reference_fuzzer",
      "fullName": "anastasia:aiken-design-patterns.utils.output_reference_fuzzer",
      "name": "output_reference_fuzzer",
      "signature": "pub fn output_reference_fuzzer() -> Fuzzer<OutputReference> {",
      "documentation": "Output reference fuzzer, transaction ID with 32 bytes, and output index\nbetween 0 and 512.",
      "parameters": [],
      "returnType": "Fuzzer<OutputReference>",
      "line": 141,
      "raw": "pub fn output_reference_fuzzer() -> Fuzzer<OutputReference> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn output_reference_fuzzer() -> Fuzzer<OutputReference> {\n  let ref_bytes <- and_then(fuzz.bytearray_fixed(32))\n  let output_index <- and_then(fuzz.int_between(0, 512))\n  fuzz.constant(OutputReference { transaction_id: ref_bytes, output_index })\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.user_output_fuzzer",
      "fullName": "anastasia:aiken-design-patterns.utils.user_output_fuzzer",
      "name": "user_output_fuzzer",
      "signature": "pub fn user_output_fuzzer() -> Fuzzer<Output> {",
      "documentation": "Simple wallet UTxO fuzzer, with a random number of tokens/NFTs.",
      "parameters": [],
      "returnType": "Fuzzer<Output>",
      "line": 148,
      "raw": "pub fn user_output_fuzzer() -> Fuzzer<Output> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn user_output_fuzzer() -> Fuzzer<Output> {\n  let pkh <- and_then(fuzz.bytearray_fixed(28))\n  let skh <- and_then(fuzz.bytearray_fixed(28))\n  let v <- and_then(value_fuzzer(2_000_000))\n  fuzz.constant(\n    Output {\n      address: Address {\n        payment_credential: VerificationKey(pkh),\n        stake_credential: Some(Inline(VerificationKey(skh))),\n      },\n      value: v,\n      datum: NoDatum,\n      reference_script: None,\n    },\n  )\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.user_input_fuzzer",
      "fullName": "anastasia:aiken-design-patterns.utils.user_input_fuzzer",
      "name": "user_input_fuzzer",
      "signature": "pub fn user_input_fuzzer() -> Fuzzer<Input> {",
      "documentation": "Simple wallet UTxO fuzzer, with a random reference output and a random\nnumber of tokens/NFTs.",
      "parameters": [],
      "returnType": "Fuzzer<Input>",
      "line": 167,
      "raw": "pub fn user_input_fuzzer() -> Fuzzer<Input> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn user_input_fuzzer() -> Fuzzer<Input> {\n  let output_reference <- and_then(output_reference_fuzzer())\n  let output <- and_then(user_output_fuzzer())\n  fuzz.constant(Input { output_reference, output })\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.specific_script_output_fuzzer",
      "fullName": "anastasia:aiken-design-patterns.utils.specific_script_output_fuzzer",
      "name": "specific_script_output_fuzzer",
      "signature": "pub fn specific_script_output_fuzzer(pub fn specific_script_output_fuzzer(script_hash: ScriptHash, datum: Datum, ) -> Fuzzer<Output> {",
      "documentation": "Given a script hash and datum, this fuzzer generates a UTxO at an address\nwhich its payment part is the same as the given script hash.",
      "parameters": [],
      "returnType": "Fuzzer<Output>",
      "line": 175,
      "raw": "pub fn specific_script_output_fuzzer(pub fn specific_script_output_fuzzer(script_hash: ScriptHash, datum: Datum, ) -> Fuzzer<Output> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn specific_script_output_fuzzer(\n  script_hash: ScriptHash,\n  datum: Datum,\n) -> Fuzzer<Output> {\n  let v <- and_then(value_fuzzer(2_000_000))\n  fuzz.constant(\n    Output {\n      address: Address {\n        payment_credential: Script(script_hash),\n        stake_credential: None,\n      },\n      value: v,\n      datum,\n      reference_script: None,\n    },\n  )\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.script_output_fuzzer",
      "fullName": "anastasia:aiken-design-patterns.utils.script_output_fuzzer",
      "name": "script_output_fuzzer",
      "signature": "pub fn script_output_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Output)> {",
      "documentation": "Returns a tuple where its first element is the random script hash (payment\npart of the UTxO's address). UTxO value is also random, with 2 ADA.",
      "parameters": [
        {
          "name": "datum",
          "type": "Datum",
          "optional": false
        }
      ],
      "returnType": "Fuzzer<(ByteArray, Output)>",
      "line": 195,
      "raw": "pub fn script_output_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Output)> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn script_output_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Output)> {\n  let script_hash <- and_then(fuzz.bytearray_fixed(28))\n  let utxo <- and_then(specific_script_output_fuzzer(script_hash, datum))\n  fuzz.constant((script_hash, utxo))\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.authentic_script_output_fuzzer",
      "fullName": "anastasia:aiken-design-patterns.utils.authentic_script_output_fuzzer",
      "name": "authentic_script_output_fuzzer",
      "signature": "pub fn authentic_script_output_fuzzer(pub fn authentic_script_output_fuzzer(datum: Datum, ) -> Fuzzer<(ByteArray, Output)> {",
      "documentation": "UTxO fuzzer, where the value is composed of 2 ADA and a beacon NFT, such\nthat its policy ID is equal to the script credential of the payment part of\nUTxO's address. This script hash is also returned.",
      "parameters": [],
      "returnType": "Fuzzer<(ByteArray, Output)>",
      "line": 204,
      "raw": "pub fn authentic_script_output_fuzzer(pub fn authentic_script_output_fuzzer(datum: Datum, ) -> Fuzzer<(ByteArray, Output)> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn authentic_script_output_fuzzer(\n  datum: Datum,\n) -> Fuzzer<(ByteArray, Output)> {\n  let script_hash <- and_then(fuzz.bytearray_fixed(28))\n  let tn <- and_then(fuzz.bytearray_between(0, 32))\n  let lovelace_value = assets.from_lovelace(2_000_000)\n  let beacon = assets.from_asset(script_hash, tn, 1)\n  let v = assets.merge(lovelace_value, beacon)\n  fuzz.constant(\n    (\n      script_hash,\n      Output {\n        address: Address {\n          payment_credential: Script(script_hash),\n          stake_credential: None,\n        },\n        value: v,\n        datum,\n        reference_script: None,\n      },\n    ),\n  )\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.specific_script_input_fuzzer",
      "fullName": "anastasia:aiken-design-patterns.utils.specific_script_input_fuzzer",
      "name": "specific_script_input_fuzzer",
      "signature": "pub fn specific_script_input_fuzzer(pub fn specific_script_input_fuzzer(script_hash: ScriptHash, datum: Datum, ) -> Fuzzer<Input> {",
      "documentation": "Similar to [`specific_script_output_fuzzer`](#specific_script_output_fuzzer),\nwith an additional randomized wrapper for output reference.",
      "parameters": [],
      "returnType": "Fuzzer<Input>",
      "line": 230,
      "raw": "pub fn specific_script_input_fuzzer(pub fn specific_script_input_fuzzer(script_hash: ScriptHash, datum: Datum, ) -> Fuzzer<Input> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn specific_script_input_fuzzer(\n  script_hash: ScriptHash,\n  datum: Datum,\n) -> Fuzzer<Input> {\n  let output_reference <- and_then(output_reference_fuzzer())\n  let output <- and_then(specific_script_output_fuzzer(script_hash, datum))\n  fuzz.constant(Input { output_reference, output })\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.script_input_fuzzer",
      "fullName": "anastasia:aiken-design-patterns.utils.script_input_fuzzer",
      "name": "script_input_fuzzer",
      "signature": "pub fn script_input_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Input)> {",
      "documentation": "Similar to [`script_output_fuzzer`](#script_output_fuzzer), with an\nadditional randomized wrapper for output reference.",
      "parameters": [
        {
          "name": "datum",
          "type": "Datum",
          "optional": false
        }
      ],
      "returnType": "Fuzzer<(ByteArray, Input)>",
      "line": 241,
      "raw": "pub fn script_input_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Input)> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn script_input_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Input)> {\n  let output_reference <- and_then(output_reference_fuzzer())\n  let (script_hash, output) <- and_then(script_output_fuzzer(datum))\n  fuzz.constant((script_hash, Input { output_reference, output }))\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.authentic_script_input_fuzzer",
      "fullName": "anastasia:aiken-design-patterns.utils.authentic_script_input_fuzzer",
      "name": "authentic_script_input_fuzzer",
      "signature": "pub fn authentic_script_input_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Input)> {",
      "documentation": "Similar to [`authentic_script_output_fuzzer`](#script_output_fuzzer), with\nand additional randomized wrapper for output reference.",
      "parameters": [
        {
          "name": "datum",
          "type": "Datum",
          "optional": false
        }
      ],
      "returnType": "Fuzzer<(ByteArray, Input)>",
      "line": 249,
      "raw": "pub fn authentic_script_input_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Input)> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn authentic_script_input_fuzzer(datum: Datum) -> Fuzzer<(ByteArray, Input)> {\n  let output_reference <- and_then(output_reference_fuzzer())\n  let (script_hash, output) <- and_then(authentic_script_output_fuzzer(datum))\n  fuzz.constant((script_hash, Input { output_reference, output }))\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.user_outputs_fuzzer",
      "fullName": "anastasia:aiken-design-patterns.utils.user_outputs_fuzzer",
      "name": "user_outputs_fuzzer",
      "signature": "pub fn user_outputs_fuzzer() -> Fuzzer<List<Output>> {",
      "documentation": "Simple (non-script) outputs fuzzer.",
      "parameters": [],
      "returnType": "Fuzzer<List<Output>>",
      "line": 256,
      "raw": "pub fn user_outputs_fuzzer() -> Fuzzer<List<Output>> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn user_outputs_fuzzer() -> Fuzzer<List<Output>> {\n  fuzz.list_between(user_output_fuzzer(), 1, 10)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.user_inputs_fuzzer",
      "fullName": "anastasia:aiken-design-patterns.utils.user_inputs_fuzzer",
      "name": "user_inputs_fuzzer",
      "signature": "pub fn user_inputs_fuzzer() -> Fuzzer<List<Input>> {",
      "documentation": "Simple (non-script) inputs fuzzer.",
      "parameters": [],
      "returnType": "Fuzzer<List<Input>>",
      "line": 261,
      "raw": "pub fn user_inputs_fuzzer() -> Fuzzer<List<Input>> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn user_inputs_fuzzer() -> Fuzzer<List<Input>> {\n  fuzz.list_between(user_input_fuzzer(), 1, 10)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.utils.inputs_with_an_authentic_script_input_fuzzer",
      "fullName": "anastasia:aiken-design-patterns.utils.inputs_with_an_authentic_script_input_fuzzer",
      "name": "inputs_with_an_authentic_script_input_fuzzer",
      "signature": "pub fn inputs_with_an_authentic_script_input_fuzzer(pub fn inputs_with_an_authentic_script_input_fuzzer(datum: Datum, ) -> Fuzzer<(ByteArray, Input, List<Input>)> {",
      "documentation": "Fuzzer for a sorted list of user/wallet inputs, with the addition of one\nauthentic script input.",
      "parameters": [],
      "returnType": "Fuzzer<(ByteArray, Input, List<Input>)>",
      "line": 267,
      "raw": "pub fn inputs_with_an_authentic_script_input_fuzzer(pub fn inputs_with_an_authentic_script_input_fuzzer(datum: Datum, ) -> Fuzzer<(ByteArray, Input, List<Input>)> {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn inputs_with_an_authentic_script_input_fuzzer(\n  datum: Datum,\n) -> Fuzzer<(ByteArray, Input, List<Input>)> {\n  let wallet_inputs <- and_then(user_inputs_fuzzer())\n  let (spend_script_hash, script_input) <-\n    and_then(authentic_script_input_fuzzer(datum))\n  fuzz.constant(\n    (\n      spend_script_hash,\n      script_input,\n      [script_input, ..wallet_inputs] |> sort_inputs,\n    ),\n  )\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.validity-range-normalization.normalize_time_range",
      "fullName": "anastasia:aiken-design-patterns.validity-range-normalization.normalize_time_range",
      "name": "normalize_time_range",
      "signature": "pub fn normalize_time_range(pub fn normalize_time_range(validity_range: ValidityRange, ) -> NormalizedTimeRange {",
      "documentation": "Validates the given time range, and returns a normalized version.",
      "parameters": [],
      "returnType": "NormalizedTimeRange",
      "line": 24,
      "raw": "pub fn normalize_time_range(pub fn normalize_time_range(validity_range: ValidityRange, ) -> NormalizedTimeRange {",
      "isPublic": true,
      "source": "anastasia",
      "implementation": "pub fn normalize_time_range(\n  validity_range: ValidityRange,\n) -> NormalizedTimeRange {\n  let Interval {\n    lower_bound: IntervalBound {\n      bound_type: lower_bound_type,\n      is_inclusive: lower_is_inclusive,\n    },\n    upper_bound: IntervalBound {\n      bound_type: upper_bound_type,\n      is_inclusive: upper_is_inclusive,\n    },\n  } = validity_range\n  when (lower_bound_type, upper_bound_type) is {\n    (interval.NegativeInfinity, interval.PositiveInfinity) -> Always\n    (interval.NegativeInfinity, interval.Finite(upper_int)) ->\n      FromNegInf { upper: resolve_upper(upper_int, upper_is_inclusive) }\n    (interval.Finite(init_lower_int), interval.Finite(init_upper_int)) ->\n      ClosedRange {\n        lower: resolve_lower(init_lower_int, lower_is_inclusive),\n        upper: resolve_upper(init_upper_int, upper_is_inclusive),\n      }\n    (interval.Finite(init_lower_int), interval.PositiveInfinity) ->\n      ToPosInf { lower: resolve_lower(init_lower_int, lower_is_inclusive) }\n    _ -> fail @\"Improper validity range encountered\"\n  }\n}"
    }
  ],
  "atoms": [
    {
      "key": "stdlib:aiken.cbor.return",
      "fullName": "stdlib:aiken.cbor.return",
      "name": "return",
      "signature": "fn return(data: Data) -> Decoder<Data> {",
      "parameters": [
        {
          "name": "data",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "Decoder<Data>",
      "line": 121,
      "raw": "fn return(data: Data) -> Decoder<Data> {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn return(data: Data) -> Decoder<Data> {\n  fn(cursor) { Pair(data, cursor) }\n}"
    },
    {
      "key": "stdlib:aiken.cbor.decode_data",
      "fullName": "stdlib:aiken.cbor.decode_data",
      "name": "decode_data",
      "signature": "fn decode_data(peek: Peek<Data>, take: Take<Data>) -> Decoder<Data> {",
      "parameters": [
        {
          "name": "peek",
          "type": "Peek<Data>",
          "optional": false
        },
        {
          "name": "take",
          "type": "Take<Data>",
          "optional": false
        }
      ],
      "returnType": "Decoder<Data>",
      "line": 138,
      "raw": "fn decode_data(peek: Peek<Data>, take: Take<Data>) -> Decoder<Data> {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn decode_data(peek: Peek<Data>, take: Take<Data>) -> Decoder<Data> {\n  let next <- peek(1)\n  let major_type = next / 32\n  if major_type <= 2 {\n    if major_type == 0 {\n      let i <- decode_uint(peek, take, next)\n      return(builtin.i_data(i))\n    } else if major_type == 1 {\n      let i <- decode_uint(peek, take, next - 32)\n      return(builtin.i_data(-i - 1))\n    } else {\n      if next == token_begin_bytes {\n        let b <- decode_chunks(peek, take)\n        return(builtin.b_data(b))\n      } else {\n        let b <- decode_bytes(peek, take, next - 64)\n        return(builtin.b_data(b))\n      }\n    }\n  } else if major_type == 6 {\n    let tag <- decode_uint(peek, take, next - 192)\n    let next <- peek(1)\n    if tag == 102 {\n      fn(_) { deserialise_failure }\n    } else {\n      let ix =\n        if tag >= 1280 {\n          tag - 1280 + 7\n        } else {\n          tag - 121\n        }\n      if next == token_begin_list {\n        let fields <- decode_indefinite(peek, take, decode_data)\n        return(builtin.constr_data(ix, fields))\n      } else {\n        let size <- decode_uint(peek, take, next - 128)\n        let fields <- decode_definite(peek, take, decode_data, size)\n        return(builtin.constr_data(ix, fields))\n      }\n    }\n  } else if major_type == 4 {\n    if next == token_begin_list {\n      let xs <- decode_indefinite(peek, take, decode_data)\n      return(builtin.list_data(xs))\n    } else {\n      let size <- decode_uint(peek, take, next - 128)\n      let xs <- decode_definite(peek, take, decode_data, size)\n      return(builtin.list_data(xs))\n    }\n  } else if major_type == 5 {\n    if next == token_begin_map {\n      let xs <- decode_indefinite(peek, take, decode_pair)\n      return(builtin.map_data(xs))\n    } else {\n      let size <- decode_uint(peek, take, next - 160)\n      let xs <- decode_definite(peek, take, decode_pair, size)\n      return(builtin.map_data(xs))\n    }\n  } else {\n    fn(_) { deserialise_failure }\n  }\n}"
    },
    {
      "key": "stdlib:aiken.cbor.decode_pair",
      "fullName": "stdlib:aiken.cbor.decode_pair",
      "name": "decode_pair",
      "signature": "fn decode_pair(peek: Peek<Data>, take: Take<Data>) -> Decoder<Pair<Data, Data>> {",
      "parameters": [
        {
          "name": "peek",
          "type": "Peek<Data>",
          "optional": false
        },
        {
          "name": "take",
          "type": "Take<Data>",
          "optional": false
        }
      ],
      "returnType": "Decoder<Pair<Data, Data>>",
      "line": 201,
      "raw": "fn decode_pair(peek: Peek<Data>, take: Take<Data>) -> Decoder<Pair<Data, Data>> {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn decode_pair(peek: Peek<Data>, take: Take<Data>) -> Decoder<Pair<Data, Data>> {\n  fn(cursor) {\n    let Pair(k, cursor) = decode_data(peek, take)(cursor)\n    let Pair(v, cursor) = decode_data(peek, take)(cursor)\n    Pair(Pair(k, v), cursor)\n  }\n}"
    },
    {
      "key": "stdlib:aiken.cbor.decode_uint",
      "fullName": "stdlib:aiken.cbor.decode_uint",
      "name": "decode_uint",
      "signature": "fn decode_uint(fn decode_uint(peek: Peek<Data>, take: Take<Data>, header: Int, and_then: fn(Int) -> Decoder<Data>,",
      "parameters": [],
      "returnType": "Decoder<Data>,",
      "line": 209,
      "raw": "fn decode_uint(fn decode_uint(peek: Peek<Data>, take: Take<Data>, header: Int, and_then: fn(Int) -> Decoder<Data>,",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn decode_uint(\n  peek: Peek<Data>,\n  take: Take<Data>,\n  header: Int,\n  and_then: fn(Int) -> Decoder<Data>,\n) -> Decoder<Data> {\n  if header < 24 {\n    and_then(header)\n  } else if header == 24 {\n    let payload <- peek(1)\n    and_then(payload)\n  } else if header < 28 {\n    let width = bytearray.at(#[2, 4, 8], header - 25)\n    let payload <- take(width)\n    and_then(bytearray.to_int_big_endian(payload))\n  } else {\n    fn(_) { deserialise_failure }\n  }\n}"
    },
    {
      "key": "stdlib:aiken.cbor.decode_bytes",
      "fullName": "stdlib:aiken.cbor.decode_bytes",
      "name": "decode_bytes",
      "signature": "fn decode_bytes(fn decode_bytes(peek: Peek<Data>, take: Take<Data>, header: Int, and_then: fn(ByteArray) -> Decoder<Data>,",
      "parameters": [],
      "returnType": "Decoder<Data>,",
      "line": 229,
      "raw": "fn decode_bytes(fn decode_bytes(peek: Peek<Data>, take: Take<Data>, header: Int, and_then: fn(ByteArray) -> Decoder<Data>,",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn decode_bytes(\n  peek: Peek<Data>,\n  take: Take<Data>,\n  header: Int,\n  and_then: fn(ByteArray) -> Decoder<Data>,\n) -> Decoder<Data> {\n  let width <- decode_uint(peek, take, header)\n  let bytes <- take(width)\n  and_then(bytes)\n}"
    },
    {
      "key": "stdlib:aiken.cbor.decode_chunks",
      "fullName": "stdlib:aiken.cbor.decode_chunks",
      "name": "decode_chunks",
      "signature": "fn decode_chunks(fn decode_chunks(peek: Peek<Data>, take: Take<Data>, and_then: fn(ByteArray) -> Decoder<Data>,",
      "parameters": [],
      "returnType": "Decoder<Data>,",
      "line": 240,
      "raw": "fn decode_chunks(fn decode_chunks(peek: Peek<Data>, take: Take<Data>, and_then: fn(ByteArray) -> Decoder<Data>,",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn decode_chunks(\n  peek: Peek<Data>,\n  take: Take<Data>,\n  and_then: fn(ByteArray) -> Decoder<Data>,\n) -> Decoder<Data> {\n  let next <- peek(1)\n  if next == token_break {\n    and_then(\"\")\n  } else {\n    let chunk <- decode_bytes(peek, take, next - 64)\n    let chunks <- decode_chunks(peek, take)\n    and_then(builtin.append_bytearray(chunk, chunks))\n  }\n}"
    },
    {
      "key": "stdlib:aiken.cbor.decode_definite",
      "fullName": "stdlib:aiken.cbor.decode_definite",
      "name": "decode_definite",
      "signature": "fn decode_definite(fn decode_definite(peek: Peek<Data>, take: Take<Data>, decode_one: fn(Peek<Data>, Take<Data>) -> Decoder<a>, size: Int, and_then: fn(List<a>) -> Decoder<Data>,",
      "parameters": [],
      "returnType": "Decoder<a>, size: Int, and_then: fn(List<a>) -> Decoder<Data>,",
      "line": 255,
      "raw": "fn decode_definite(fn decode_definite(peek: Peek<Data>, take: Take<Data>, decode_one: fn(Peek<Data>, Take<Data>) -> Decoder<a>, size: Int, and_then: fn(List<a>) -> Decoder<Data>,",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn decode_definite(\n  peek: Peek<Data>,\n  take: Take<Data>,\n  decode_one: fn(Peek<Data>, Take<Data>) -> Decoder<a>,\n  size: Int,\n  and_then: fn(List<a>) -> Decoder<Data>,\n) -> Decoder<Data> {\n  if size <= 0 {\n    and_then([])\n  } else {\n    fn(cursor) {\n      let Pair(elem, cursor) = decode_one(peek, take)(cursor)\n      {\n        let elems <- decode_definite(peek, take, decode_one, size - 1)\n        and_then([elem, ..elems])\n      }(cursor)\n    }\n  }\n}"
    },
    {
      "key": "stdlib:aiken.cbor.decode_indefinite",
      "fullName": "stdlib:aiken.cbor.decode_indefinite",
      "name": "decode_indefinite",
      "signature": "fn decode_indefinite(fn decode_indefinite(peek: Peek<Data>, take: Take<Data>, decode_one: fn(Peek<Data>, Take<Data>) -> Decoder<a>, and_then: fn(List<a>) -> Decoder<Data>,",
      "parameters": [],
      "returnType": "Decoder<a>, and_then: fn(List<a>) -> Decoder<Data>,",
      "line": 275,
      "raw": "fn decode_indefinite(fn decode_indefinite(peek: Peek<Data>, take: Take<Data>, decode_one: fn(Peek<Data>, Take<Data>) -> Decoder<a>, and_then: fn(List<a>) -> Decoder<Data>,",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn decode_indefinite(\n  peek: Peek<Data>,\n  take: Take<Data>,\n  decode_one: fn(Peek<Data>, Take<Data>) -> Decoder<a>,\n  and_then: fn(List<a>) -> Decoder<Data>,\n) -> Decoder<Data> {\n  let next <- peek(1)\n  if next == token_break {\n    and_then([])\n  } else {\n    fn(cursor) {\n      let Pair(elem, cursor) = decode_one(peek, take)(cursor + 1)\n      {\n        let elems <- decode_indefinite(peek, take, decode_one)\n        and_then([elem, ..elems])\n      }(cursor)\n    }\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.check_ascending_list",
      "fullName": "stdlib:aiken.collection.dict.check_ascending_list",
      "name": "check_ascending_list",
      "signature": "fn check_ascending_list(xs: Pairs<ByteArray, value>) {",
      "parameters": [
        {
          "name": "xs",
          "type": "Pairs<ByteArray, value>",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 77,
      "raw": "fn check_ascending_list(xs: Pairs<ByteArray, value>) {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn check_ascending_list(xs: Pairs<ByteArray, value>) {\n  when xs is {\n    [] -> Void\n    [_] -> Void\n    [Pair(x0, _), Pair(x1, _) as e, ..rest] ->\n      if builtin.less_than_bytearray(x0, x1) {\n        check_ascending_list([e, ..rest])\n      } else {\n        fail @\"keys in associative list aren't in ascending order\"\n      }\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.check_ascending_pairs_with",
      "fullName": "stdlib:aiken.collection.dict.check_ascending_pairs_with",
      "name": "check_ascending_pairs_with",
      "signature": "fn check_ascending_pairs_with(fn check_ascending_pairs_with(xs: Pairs<ByteArray, value>, predicate: fn(value) -> Bool,",
      "parameters": [],
      "returnType": "Bool,",
      "line": 106,
      "raw": "fn check_ascending_pairs_with(fn check_ascending_pairs_with(xs: Pairs<ByteArray, value>, predicate: fn(value) -> Bool,",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn check_ascending_pairs_with(\n  xs: Pairs<ByteArray, value>,\n  predicate: fn(value) -> Bool,\n) {\n  when xs is {\n    [] -> Void\n    [Pair(_, v)] ->\n      if predicate(v) {\n        Void\n      } else {\n        fail @\"value doesn't satisfy predicate\"\n      }\n    [Pair(x0, v0), Pair(x1, _) as e, ..rest] ->\n      if builtin.less_than_bytearray(x0, x1) {\n        if predicate(v0) {\n          check_ascending_pairs_with([e, ..rest], predicate)\n        } else {\n          fail @\"value doesn't satisfy predicate\"\n        }\n      } else {\n        fail @\"keys in pairs aren't in ascending order\"\n      }\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.do_from_pairs",
      "fullName": "stdlib:aiken.collection.dict.do_from_pairs",
      "name": "do_from_pairs",
      "signature": "fn do_from_pairs(xs: Pairs<ByteArray, value>) -> Pairs<ByteArray, value> {",
      "parameters": [
        {
          "name": "xs",
          "type": "Pairs<ByteArray, value>",
          "optional": false
        }
      ],
      "returnType": "Pairs<ByteArray, value>",
      "line": 161,
      "raw": "fn do_from_pairs(xs: Pairs<ByteArray, value>) -> Pairs<ByteArray, value> {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_from_pairs(xs: Pairs<ByteArray, value>) -> Pairs<ByteArray, value> {\n  when xs is {\n    [] -> []\n    [Pair(k, v), ..rest] ->\n      do_insert_with(do_from_pairs(rest), k, v, strategy.keep_left())\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.do_find",
      "fullName": "stdlib:aiken.collection.dict.do_find",
      "name": "do_find",
      "signature": "fn do_find(self: Pairs<ByteArray, value>, value v: value) -> Option<ByteArray> {",
      "parameters": [
        {
          "name": "self",
          "type": "Pairs<ByteArray, value>",
          "optional": false
        }
      ],
      "returnType": "Option<ByteArray>",
      "line": 219,
      "raw": "fn do_find(self: Pairs<ByteArray, value>, value v: value) -> Option<ByteArray> {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_find(self: Pairs<ByteArray, value>, value v: value) -> Option<ByteArray> {\n  when self is {\n    [] -> None\n    [Pair(k2, v2), ..rest] ->\n      if v == v2 {\n        Some(k2)\n      } else {\n        do_find(rest, v)\n      }\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.do_get",
      "fullName": "stdlib:aiken.collection.dict.do_get",
      "name": "do_get",
      "signature": "fn do_get(self: Pairs<ByteArray, value>, key k: ByteArray) -> Option<value> {",
      "parameters": [
        {
          "name": "self",
          "type": "Pairs<ByteArray, value>",
          "optional": false
        }
      ],
      "returnType": "Option<value>",
      "line": 275,
      "raw": "fn do_get(self: Pairs<ByteArray, value>, key k: ByteArray) -> Option<value> {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_get(self: Pairs<ByteArray, value>, key k: ByteArray) -> Option<value> {\n  when self is {\n    [] -> None\n    [Pair(k2, v), ..rest] ->\n      if builtin.less_than_equals_bytearray(k, k2) {\n        if k == k2 {\n          Some(v)\n        } else {\n          None\n        }\n      } else {\n        do_get(rest, k)\n      }\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.do_has_key",
      "fullName": "stdlib:aiken.collection.dict.do_has_key",
      "name": "do_has_key",
      "signature": "fn do_has_key(self: Pairs<ByteArray, value>, key k: ByteArray) -> Bool {",
      "parameters": [
        {
          "name": "self",
          "type": "Pairs<ByteArray, value>",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 359,
      "raw": "fn do_has_key(self: Pairs<ByteArray, value>, key k: ByteArray) -> Bool {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_has_key(self: Pairs<ByteArray, value>, key k: ByteArray) -> Bool {\n  when self is {\n    [] -> False\n    [Pair(k2, _), ..rest] ->\n      if builtin.less_than_equals_bytearray(k, k2) {\n        k == k2\n      } else {\n        do_has_key(rest, k)\n      }\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.do_keys",
      "fullName": "stdlib:aiken.collection.dict.do_keys",
      "name": "do_keys",
      "signature": "fn do_keys(self: Pairs<ByteArray, value>) -> List<ByteArray> {",
      "parameters": [
        {
          "name": "self",
          "type": "Pairs<ByteArray, value>",
          "optional": false
        }
      ],
      "returnType": "List<ByteArray>",
      "line": 431,
      "raw": "fn do_keys(self: Pairs<ByteArray, value>) -> List<ByteArray> {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_keys(self: Pairs<ByteArray, value>) -> List<ByteArray> {\n  when self is {\n    [] -> []\n    [Pair(k, _), ..rest] -> [k, ..do_keys(rest)]\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.do_size",
      "fullName": "stdlib:aiken.collection.dict.do_size",
      "name": "do_size",
      "signature": "fn do_size(self: Pairs<key, value>) -> Int {",
      "parameters": [
        {
          "name": "self",
          "type": "Pairs<key, value>",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 466,
      "raw": "fn do_size(self: Pairs<key, value>) -> Int {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_size(self: Pairs<key, value>) -> Int {\n  when self is {\n    [] -> 0\n    [_, ..rest] -> 1 + do_size(rest)\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.do_values",
      "fullName": "stdlib:aiken.collection.dict.do_values",
      "name": "do_values",
      "signature": "fn do_values(self: Pairs<key, value>) -> List<value> {",
      "parameters": [
        {
          "name": "self",
          "type": "Pairs<key, value>",
          "optional": false
        }
      ],
      "returnType": "List<value>",
      "line": 508,
      "raw": "fn do_values(self: Pairs<key, value>) -> List<value> {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_values(self: Pairs<key, value>) -> List<value> {\n  when self is {\n    [] -> []\n    [Pair(_, v), ..rest] -> [v, ..do_values(rest)]\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.do_delete",
      "fullName": "stdlib:aiken.collection.dict.do_delete",
      "name": "do_delete",
      "signature": "fn do_delete(fn do_delete(self: Pairs<ByteArray, value>, key k: ByteArray, ) -> Pairs<ByteArray, value> {",
      "parameters": [],
      "returnType": "Pairs<ByteArray, value>",
      "line": 545,
      "raw": "fn do_delete(fn do_delete(self: Pairs<ByteArray, value>, key k: ByteArray, ) -> Pairs<ByteArray, value> {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_delete(\n  self: Pairs<ByteArray, value>,\n  key k: ByteArray,\n) -> Pairs<ByteArray, value> {\n  when self is {\n    [] -> []\n    [Pair(k2, v2), ..rest] ->\n      if builtin.less_than_equals_bytearray(k, k2) {\n        if k == k2 {\n          rest\n        } else {\n          self\n        }\n      } else {\n        [Pair(k2, v2), ..do_delete(rest, k)]\n      }\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.do_filter",
      "fullName": "stdlib:aiken.collection.dict.do_filter",
      "name": "do_filter",
      "signature": "fn do_filter(fn do_filter(self: Pairs<ByteArray, value>, with: fn(ByteArray, value) -> Bool,",
      "parameters": [],
      "returnType": "Bool,",
      "line": 635,
      "raw": "fn do_filter(fn do_filter(self: Pairs<ByteArray, value>, with: fn(ByteArray, value) -> Bool,",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_filter(\n  self: Pairs<ByteArray, value>,\n  with: fn(ByteArray, value) -> Bool,\n) -> Pairs<ByteArray, value> {\n  when self is {\n    [] -> []\n    [Pair(k, v), ..rest] ->\n      if with(k, v) {\n        [Pair(k, v), ..do_filter(rest, with)]\n      } else {\n        do_filter(rest, with)\n      }\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.do_insert",
      "fullName": "stdlib:aiken.collection.dict.do_insert",
      "name": "do_insert",
      "signature": "fn do_insert(fn do_insert(self: Pairs<ByteArray, value>, key k: ByteArray, value v: value, ) -> Pairs<ByteArray, value> {",
      "parameters": [],
      "returnType": "Pairs<ByteArray, value>",
      "line": 688,
      "raw": "fn do_insert(fn do_insert(self: Pairs<ByteArray, value>, key k: ByteArray, value v: value, ) -> Pairs<ByteArray, value> {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_insert(\n  self: Pairs<ByteArray, value>,\n  key k: ByteArray,\n  value v: value,\n) -> Pairs<ByteArray, value> {\n  when self is {\n    [] -> [Pair(k, v)]\n    [Pair(k2, v2), ..rest] ->\n      if builtin.less_than_bytearray(k, k2) {\n        [Pair(k, v), ..self]\n      } else {\n        if k == k2 {\n          [Pair(k, v), ..rest]\n        } else {\n          [Pair(k2, v2), ..do_insert(rest, k, v)]\n        }\n      }\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.do_map",
      "fullName": "stdlib:aiken.collection.dict.do_map",
      "name": "do_map",
      "signature": "fn do_map(fn do_map(self: Pairs<ByteArray, a>, with: fn(ByteArray, a) -> b,",
      "parameters": [],
      "returnType": "b,",
      "line": 819,
      "raw": "fn do_map(fn do_map(self: Pairs<ByteArray, a>, with: fn(ByteArray, a) -> b,",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_map(\n  self: Pairs<ByteArray, a>,\n  with: fn(ByteArray, a) -> b,\n) -> Pairs<ByteArray, b> {\n  when self is {\n    [] -> []\n    [Pair(k, v), ..rest] -> [Pair(k, with(k, v)), ..do_map(rest, with)]\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.do_pop",
      "fullName": "stdlib:aiken.collection.dict.do_pop",
      "name": "do_pop",
      "signature": "fn do_pop(fn do_pop(self: Pairs<ByteArray, value>, key k: ByteArray, return: fn(Option<value>, Pairs<ByteArray, value>) -> result,",
      "parameters": [],
      "returnType": "result,",
      "line": 861,
      "raw": "fn do_pop(fn do_pop(self: Pairs<ByteArray, value>, key k: ByteArray, return: fn(Option<value>, Pairs<ByteArray, value>) -> result,",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_pop(\n  self: Pairs<ByteArray, value>,\n  key k: ByteArray,\n  return: fn(Option<value>, Pairs<ByteArray, value>) -> result,\n) -> result {\n  when self is {\n    [] -> return(None, [])\n    [Pair(k2, v2), ..rest] ->\n      if builtin.less_than_equals_bytearray(k, k2) {\n        if k == k2 {\n          return(Some(v2), rest)\n        } else {\n          return(None, self)\n        }\n      } else {\n        do_pop(\n          rest,\n          k,\n          fn(value, inner) { return(value, [Pair(k2, v2), ..inner]) },\n        )\n      }\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.do_union",
      "fullName": "stdlib:aiken.collection.dict.do_union",
      "name": "do_union",
      "signature": "fn do_union(fn do_union(left: Pairs<ByteArray, value>, right: Pairs<ByteArray, value>, ) -> Pairs<ByteArray, value> {",
      "parameters": [],
      "returnType": "Pairs<ByteArray, value>",
      "line": 949,
      "raw": "fn do_union(fn do_union(left: Pairs<ByteArray, value>, right: Pairs<ByteArray, value>, ) -> Pairs<ByteArray, value> {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_union(\n  left: Pairs<ByteArray, value>,\n  right: Pairs<ByteArray, value>,\n) -> Pairs<ByteArray, value> {\n  when left is {\n    [] -> right\n    [Pair(k, v), ..rest] -> do_union(rest, do_insert(right, k, v))\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.do_union_with",
      "fullName": "stdlib:aiken.collection.dict.do_union_with",
      "name": "do_union_with",
      "signature": "fn do_union_with(fn do_union_with(left: Pairs<ByteArray, value>, right: Pairs<ByteArray, value>, with: UnionStrategy<ByteArray, value>, ) -> Pairs<ByteArray, value> {",
      "parameters": [],
      "returnType": "Pairs<ByteArray, value>",
      "line": 1019,
      "raw": "fn do_union_with(fn do_union_with(left: Pairs<ByteArray, value>, right: Pairs<ByteArray, value>, with: UnionStrategy<ByteArray, value>, ) -> Pairs<ByteArray, value> {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_union_with(\n  left: Pairs<ByteArray, value>,\n  right: Pairs<ByteArray, value>,\n  with: UnionStrategy<ByteArray, value>,\n) -> Pairs<ByteArray, value> {\n  when left is {\n    [] -> right\n    [Pair(k, v), ..rest] ->\n      do_union_with(rest, do_insert_with(right, k, v, with), with)\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.do_insert_with",
      "fullName": "stdlib:aiken.collection.dict.do_insert_with",
      "name": "do_insert_with",
      "signature": "fn do_insert_with(fn do_insert_with(self: Pairs<ByteArray, value>, key k: ByteArray, value v: value, with: UnionStrategy<ByteArray, value>, ) -> Pairs<ByteArray, value> {",
      "parameters": [],
      "returnType": "Pairs<ByteArray, value>",
      "line": 1031,
      "raw": "fn do_insert_with(fn do_insert_with(self: Pairs<ByteArray, value>, key k: ByteArray, value v: value, with: UnionStrategy<ByteArray, value>, ) -> Pairs<ByteArray, value> {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_insert_with(\n  self: Pairs<ByteArray, value>,\n  key k: ByteArray,\n  value v: value,\n  with: UnionStrategy<ByteArray, value>,\n) -> Pairs<ByteArray, value> {\n  when self is {\n    [] -> [Pair(k, v)]\n    [Pair(k2, v2), ..rest] ->\n      if builtin.less_than_bytearray(k, k2) {\n        [Pair(k, v), ..self]\n      } else {\n        if k == k2 {\n          with(\n            k,\n            v,\n            v2,\n            fn(combined) { [Pair(k, combined), ..rest] },\n            fn() { rest },\n          )\n        } else {\n          [Pair(k2, v2), ..do_insert_with(rest, k, v, with)]\n        }\n      }\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.do_foldl",
      "fullName": "stdlib:aiken.collection.dict.do_foldl",
      "name": "do_foldl",
      "signature": "fn do_foldl(fn do_foldl(self: Pairs<ByteArray, value>, zero: result, with: fn(ByteArray, value, result) -> result,",
      "parameters": [],
      "returnType": "result,",
      "line": 1096,
      "raw": "fn do_foldl(fn do_foldl(self: Pairs<ByteArray, value>, zero: result, with: fn(ByteArray, value, result) -> result,",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_foldl(\n  self: Pairs<ByteArray, value>,\n  zero: result,\n  with: fn(ByteArray, value, result) -> result,\n) -> result {\n  when self is {\n    [] -> zero\n    [Pair(k, v), ..rest] -> do_foldl(rest, with(k, v, zero), with)\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.dict.do_foldr",
      "fullName": "stdlib:aiken.collection.dict.do_foldr",
      "name": "do_foldr",
      "signature": "fn do_foldr(fn do_foldr(self: Pairs<ByteArray, value>, zero: result, with: fn(ByteArray, value, result) -> result,",
      "parameters": [],
      "returnType": "result,",
      "line": 1136,
      "raw": "fn do_foldr(fn do_foldr(self: Pairs<ByteArray, value>, zero: result, with: fn(ByteArray, value, result) -> result,",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_foldr(\n  self: Pairs<ByteArray, value>,\n  zero: result,\n  with: fn(ByteArray, value, result) -> result,\n) -> result {\n  when self is {\n    [] -> zero\n    [Pair(k, v), ..rest] -> with(k, v, do_foldr(rest, zero, with))\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.list.do_index_of",
      "fullName": "stdlib:aiken.collection.list.do_index_of",
      "name": "do_index_of",
      "signature": "fn do_index_of(self: List<a>, elem: a, i: Int) -> Option<Int> {",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "elem",
          "type": "a",
          "optional": false
        },
        {
          "name": "i",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Option<Int>",
      "line": 318,
      "raw": "fn do_index_of(self: List<a>, elem: a, i: Int) -> Option<Int> {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_index_of(self: List<a>, elem: a, i: Int) -> Option<Int> {\n  when self is {\n    [] -> None\n    [x, ..xs] ->\n      if x == elem {\n        Some(i)\n      } else {\n        do_index_of(xs, elem, i + 1)\n      }\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.list.do_init",
      "fullName": "stdlib:aiken.collection.list.do_init",
      "name": "do_init",
      "signature": "fn do_init(self: List<a>) -> List<a> {",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        }
      ],
      "returnType": "List<a>",
      "line": 592,
      "raw": "fn do_init(self: List<a>) -> List<a> {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_init(self: List<a>) -> List<a> {\n  when self is {\n    [] -> fail @\"unreachable\"\n    [_] -> []\n    [x, ..xs] -> [x, ..do_init(xs)]\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.list.do_indexed_map",
      "fullName": "stdlib:aiken.collection.list.do_indexed_map",
      "name": "do_indexed_map",
      "signature": "fn do_indexed_map(fn do_indexed_map(n: Int, self: List<a>, with: fn(Int, a) -> result,",
      "parameters": [],
      "returnType": "result,",
      "line": 900,
      "raw": "fn do_indexed_map(fn do_indexed_map(n: Int, self: List<a>, with: fn(Int, a) -> result,",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_indexed_map(\n  n: Int,\n  self: List<a>,\n  with: fn(Int, a) -> result,\n) -> List<result> {\n  when self is {\n    [] -> []\n    [x, ..xs] -> [with(n, x), ..do_indexed_map(n + 1, xs, with)]\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.list.insert",
      "fullName": "stdlib:aiken.collection.list.insert",
      "name": "insert",
      "signature": "fn insert(self: List<a>, e: a, compare: fn(a, a) -> Ordering) -> List<a> {",
      "parameters": [
        {
          "name": "self",
          "type": "List<a>",
          "optional": false
        },
        {
          "name": "e",
          "type": "a",
          "optional": false
        },
        {
          "name": "compare",
          "type": "fn(a, a",
          "optional": false
        }
      ],
      "returnType": "Ordering) -> List<a>",
      "line": 1049,
      "raw": "fn insert(self: List<a>, e: a, compare: fn(a, a) -> Ordering) -> List<a> {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn insert(self: List<a>, e: a, compare: fn(a, a) -> Ordering) -> List<a> {\n  when self is {\n    [] -> [e]\n    [x, ..xs] ->\n      if compare(e, x) == Less {\n        [e, ..self]\n      } else {\n        [x, ..insert(xs, e, compare)]\n      }\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.list.do_foldr2",
      "fullName": "stdlib:aiken.collection.list.do_foldr2",
      "name": "do_foldr2",
      "signature": "fn do_foldr2(fn do_foldr2(self: List<elem>, with: fn(elem, a, b, Fold2<a, b, result>) -> result, return: Fold2<a, b, result>,",
      "parameters": [],
      "returnType": "result, return: Fold2<a, b, result>,",
      "line": 1387,
      "raw": "fn do_foldr2(fn do_foldr2(self: List<elem>, with: fn(elem, a, b, Fold2<a, b, result>) -> result, return: Fold2<a, b, result>,",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_foldr2(\n  self: List<elem>,\n  with: fn(elem, a, b, Fold2<a, b, result>) -> result,\n  return: Fold2<a, b, result>,\n) -> Fold2<a, b, result> {\n  when self is {\n    [] -> return\n    [x, ..xs] -> do_foldr2(xs, with, fn(a, b) { with(x, a, b, return) })\n  }\n}"
    },
    {
      "key": "stdlib:aiken.collection.list.do_indexed_foldr",
      "fullName": "stdlib:aiken.collection.list.do_indexed_foldr",
      "name": "do_indexed_foldr",
      "signature": "fn do_indexed_foldr(fn do_indexed_foldr(n: Int, self: List<a>, zero: result, with: fn(Int, a, result) -> result,",
      "parameters": [],
      "returnType": "result,",
      "line": 1434,
      "raw": "fn do_indexed_foldr(fn do_indexed_foldr(n: Int, self: List<a>, zero: result, with: fn(Int, a, result) -> result,",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_indexed_foldr(\n  n: Int,\n  self: List<a>,\n  zero: result,\n  with: fn(Int, a, result) -> result,\n) -> result {\n  when self is {\n    [] -> zero\n    [x, ..xs] -> with(n, x, do_indexed_foldr(n + 1, xs, zero, with))\n  }\n}"
    },
    {
      "key": "stdlib:aiken.crypto.bitwise.do_scale2",
      "fullName": "stdlib:aiken.crypto.bitwise.do_scale2",
      "name": "do_scale2",
      "signature": "fn do_scale2(self: State<t>, k: Int, mul) -> State<t> {",
      "parameters": [
        {
          "name": "self",
          "type": "State<t>",
          "optional": false
        },
        {
          "name": "k",
          "type": "Int",
          "optional": false
        },
        {
          "name": "mul",
          "type": "Unknown",
          "optional": false
        }
      ],
      "returnType": "State<t>",
      "line": 114,
      "raw": "fn do_scale2(self: State<t>, k: Int, mul) -> State<t> {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_scale2(self: State<t>, k: Int, mul) -> State<t> {\n  if k == 0 {\n    self\n  } else {\n    do_scale2(mul(self, self), k - 1, mul)\n  }\n}"
    },
    {
      "key": "stdlib:aiken.interval.bound_type_to_string",
      "fullName": "stdlib:aiken.interval.bound_type_to_string",
      "name": "bound_type_to_string",
      "signature": "fn bound_type_to_string(self: IntervalBoundType) -> String {",
      "parameters": [
        {
          "name": "self",
          "type": "IntervalBoundType",
          "optional": false
        }
      ],
      "returnType": "String",
      "line": 606,
      "raw": "fn bound_type_to_string(self: IntervalBoundType) -> String {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn bound_type_to_string(self: IntervalBoundType) -> String {\n  when self is {\n    NegativeInfinity -> @\"-∞\"\n    Finite(i) -> string.from_int(i)\n    PositiveInfinity -> @\"+∞\"\n  }\n}"
    },
    {
      "key": "stdlib:aiken.interval.compare_bound_type",
      "fullName": "stdlib:aiken.interval.compare_bound_type",
      "name": "compare_bound_type",
      "signature": "fn compare_bound_type(fn compare_bound_type(left: IntervalBoundType, right: IntervalBoundType, less: fn() -> a, equal: fn(Bool) -> a, greater: fn() -> a,",
      "parameters": [],
      "returnType": "a, equal: fn(Bool) -> a, greater: fn() -> a,",
      "line": 874,
      "raw": "fn compare_bound_type(fn compare_bound_type(left: IntervalBoundType, right: IntervalBoundType, less: fn() -> a, equal: fn(Bool) -> a, greater: fn() -> a,",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn compare_bound_type(\n  left: IntervalBoundType,\n  right: IntervalBoundType,\n  less: fn() -> a,\n  equal: fn(Bool) -> a,\n  greater: fn() -> a,\n) -> a {\n  when left is {\n    NegativeInfinity ->\n      when right is {\n        NegativeInfinity -> equal(True)\n        _ -> less()\n      }\n    PositiveInfinity ->\n      when right is {\n        PositiveInfinity -> equal(False)\n        _ -> greater()\n      }\n    Finite(left) ->\n      when right is {\n        NegativeInfinity -> greater()\n        PositiveInfinity -> less()\n        Finite(right) ->\n          if left < right {\n            less()\n          } else if left == right {\n            equal(left < 0)\n          } else {\n            greater()\n          }\n      }\n  }\n}"
    },
    {
      "key": "stdlib:aiken.math.rational.ratio",
      "fullName": "stdlib:aiken.math.rational.ratio",
      "name": "ratio",
      "signature": "fn ratio(numerator: Int, denominator: Int) -> Rational {",
      "documentation": "An unsafe constructor for `Rational` values. Assumes that the following invariants are\nenforced:\n\n- the denominator is positive (the sign is managed in the numerator);\n- the denominator is not null.\n\nThis function is mainly used as a quick way to construct rationals from literal values.",
      "parameters": [
        {
          "name": "numerator",
          "type": "Int",
          "optional": false
        },
        {
          "name": "denominator",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Rational",
      "line": 53,
      "raw": "fn ratio(numerator: Int, denominator: Int) -> Rational {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn ratio(numerator: Int, denominator: Int) -> Rational {\n  Rational { numerator, denominator }\n}"
    },
    {
      "key": "stdlib:aiken.math.do_gcd",
      "fullName": "stdlib:aiken.math.do_gcd",
      "name": "do_gcd",
      "signature": "fn do_gcd(x: Int, y: Int) -> Int {",
      "parameters": [
        {
          "name": "x",
          "type": "Int",
          "optional": false
        },
        {
          "name": "y",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 85,
      "raw": "fn do_gcd(x: Int, y: Int) -> Int {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_gcd(x: Int, y: Int) -> Int {\n  when y is {\n    0 -> x\n    _ -> do_gcd(y, x % y)\n  }\n}"
    },
    {
      "key": "stdlib:aiken.math.sqrt_babylonian",
      "fullName": "stdlib:aiken.math.sqrt_babylonian",
      "name": "sqrt_babylonian",
      "signature": "fn sqrt_babylonian(self: Int, x: Int, y: Int) -> Int {",
      "parameters": [
        {
          "name": "self",
          "type": "Int",
          "optional": false
        },
        {
          "name": "x",
          "type": "Int",
          "optional": false
        },
        {
          "name": "y",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 394,
      "raw": "fn sqrt_babylonian(self: Int, x: Int, y: Int) -> Int {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn sqrt_babylonian(self: Int, x: Int, y: Int) -> Int {\n  if y >= x {\n    x\n  } else {\n    sqrt_babylonian(self, y, ( y + self / y ) / 2)\n  }\n}"
    },
    {
      "key": "stdlib:aiken.option.try_decrement",
      "fullName": "stdlib:aiken.option.try_decrement",
      "name": "try_decrement",
      "signature": "fn try_decrement(n: Int) -> Option<Int> {",
      "parameters": [
        {
          "name": "n",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Option<Int>",
      "line": 59,
      "raw": "fn try_decrement(n: Int) -> Option<Int> {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn try_decrement(n: Int) -> Option<Int> {\n  if n > 0 {\n    Some(n - 1)\n  } else {\n    None\n  }\n}"
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.do_index_of",
      "fullName": "stdlib:aiken.primitive.bytearray.do_index_of",
      "name": "do_index_of",
      "signature": "fn do_index_of(fn do_index_of(self: ByteArray, bytes: ByteArray, cursor: Int, offset: Int, size: Int, ) -> Option<Int> {",
      "parameters": [],
      "returnType": "Option<Int>",
      "line": 146,
      "raw": "fn do_index_of(fn do_index_of(self: ByteArray, bytes: ByteArray, cursor: Int, offset: Int, size: Int, ) -> Option<Int> {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_index_of(\n  self: ByteArray,\n  bytes: ByteArray,\n  cursor: Int,\n  offset: Int,\n  size: Int,\n) -> Option<Int> {\n  if cursor + offset > size {\n    None\n  } else {\n    if builtin.slice_bytearray(cursor, offset, self) == bytes {\n      Some(cursor)\n    } else {\n      do_index_of(self, bytes, cursor + 1, offset, size)\n    }\n  }\n}"
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.do_foldl",
      "fullName": "stdlib:aiken.primitive.bytearray.do_foldl",
      "name": "do_foldl",
      "signature": "fn do_foldl(fn do_foldl(self: ByteArray, zero: result, len: Int, cursor: Int, with: fn(Int, result) -> result,",
      "parameters": [],
      "returnType": "result,",
      "line": 436,
      "raw": "fn do_foldl(fn do_foldl(self: ByteArray, zero: result, len: Int, cursor: Int, with: fn(Int, result) -> result,",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_foldl(\n  self: ByteArray,\n  zero: result,\n  len: Int,\n  cursor: Int,\n  with: fn(Int, result) -> result,\n) -> result {\n  if cursor == len {\n    zero\n  } else {\n    do_foldl(\n      self,\n      with(builtin.index_bytearray(self, cursor), zero),\n      len,\n      cursor + 1,\n      with,\n    )\n  }\n}"
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.do_foldr",
      "fullName": "stdlib:aiken.primitive.bytearray.do_foldr",
      "name": "do_foldr",
      "signature": "fn do_foldr(fn do_foldr(self: ByteArray, zero: result, cursor: Int, with: fn(Int, result) -> result,",
      "parameters": [],
      "returnType": "result,",
      "line": 490,
      "raw": "fn do_foldr(fn do_foldr(self: ByteArray, zero: result, cursor: Int, with: fn(Int, result) -> result,",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_foldr(\n  self: ByteArray,\n  zero: result,\n  cursor: Int,\n  with: fn(Int, result) -> result,\n) -> result {\n  if cursor < 0 {\n    zero\n  } else {\n    do_foldr(\n      self,\n      with(builtin.index_bytearray(self, cursor), zero),\n      cursor - 1,\n      with,\n    )\n  }\n}"
    },
    {
      "key": "stdlib:aiken.primitive.string.do_join",
      "fullName": "stdlib:aiken.primitive.string.do_join",
      "name": "do_join",
      "signature": "fn do_join(xs, delimiter, bytes) {",
      "parameters": [
        {
          "name": "xs",
          "type": "Unknown",
          "optional": false
        },
        {
          "name": "delimiter",
          "type": "Unknown",
          "optional": false
        },
        {
          "name": "bytes",
          "type": "Unknown",
          "optional": false
        }
      ],
      "returnType": "Unknown",
      "line": 94,
      "raw": "fn do_join(xs, delimiter, bytes) {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn do_join(xs, delimiter, bytes) {\n  when xs is {\n    [] -> bytes\n    [x, ..rest] ->\n      do_join(\n        rest,\n        delimiter,\n        if length_of_bytearray(bytes) == 0 {\n          encode_utf8(x)\n        } else {\n          append_bytearray(bytes, append_bytearray(delimiter, encode_utf8(x)))\n        },\n      )\n  }\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.get_protocol_param",
      "fullName": "stdlib:cardano.governance.protocol_parameters.get_protocol_param",
      "name": "get_protocol_param",
      "signature": "fn get_protocol_param(fn get_protocol_param(self: Pairs<ProtocolParametersIndex, Data>, ix: ProtocolParametersIndex, into: fn(Data) -> a,",
      "parameters": [],
      "returnType": "a,",
      "line": 265,
      "raw": "fn get_protocol_param(fn get_protocol_param(self: Pairs<ProtocolParametersIndex, Data>, ix: ProtocolParametersIndex, into: fn(Data) -> a,",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn get_protocol_param(\n  self: Pairs<ProtocolParametersIndex, Data>,\n  ix: ProtocolParametersIndex,\n  into: fn(Data) -> a,\n) -> Option<a> {\n  when self is {\n    [] -> None\n    [Pair(jx, param), ..tail] ->\n      if ix == jx {\n        Some(into(param))\n      } else {\n        get_protocol_param(tail, ix, into)\n      }\n  }\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.into_int",
      "fullName": "stdlib:cardano.governance.protocol_parameters.into_int",
      "name": "into_int",
      "signature": "fn into_int(param: Data) -> Int {",
      "parameters": [
        {
          "name": "param",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 281,
      "raw": "fn into_int(param: Data) -> Int {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn into_int(param: Data) -> Int {\n  expect param: Int = param\n  param\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.into_rational",
      "fullName": "stdlib:cardano.governance.protocol_parameters.into_rational",
      "name": "into_rational",
      "signature": "fn into_rational(param: Data) -> Rational {",
      "parameters": [
        {
          "name": "param",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "Rational",
      "line": 286,
      "raw": "fn into_rational(param: Data) -> Rational {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn into_rational(param: Data) -> Rational {\n  expect [numerator, denominator]: List<Int> = param\n  expect Some(r) = rational.new(numerator, denominator)\n  r\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.into_execution_units",
      "fullName": "stdlib:cardano.governance.protocol_parameters.into_execution_units",
      "name": "into_execution_units",
      "signature": "fn into_execution_units(param: Data) -> ExecutionUnits {",
      "parameters": [
        {
          "name": "param",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "ExecutionUnits",
      "line": 292,
      "raw": "fn into_execution_units(param: Data) -> ExecutionUnits {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn into_execution_units(param: Data) -> ExecutionUnits {\n  expect [memory, cpu]: List<Int> = param\n  ExecutionUnits { memory, cpu }\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.into_script_execution_prices",
      "fullName": "stdlib:cardano.governance.protocol_parameters.into_script_execution_prices",
      "name": "into_script_execution_prices",
      "signature": "fn into_script_execution_prices(param: Data) -> ScriptExecutionPrices {",
      "parameters": [
        {
          "name": "param",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "ScriptExecutionPrices",
      "line": 297,
      "raw": "fn into_script_execution_prices(param: Data) -> ScriptExecutionPrices {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn into_script_execution_prices(param: Data) -> ScriptExecutionPrices {\n  expect [memory, cpu]: List<Data> = param\n  let memory = into_rational(memory)\n  let cpu = into_rational(cpu)\n  ScriptExecutionPrices { memory, cpu }\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.into_spo_voting_thresholds",
      "fullName": "stdlib:cardano.governance.protocol_parameters.into_spo_voting_thresholds",
      "name": "into_spo_voting_thresholds",
      "signature": "fn into_spo_voting_thresholds(param: Data) -> StakePoolOperatorVotingThresholds {",
      "parameters": [
        {
          "name": "param",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "StakePoolOperatorVotingThresholds",
      "line": 304,
      "raw": "fn into_spo_voting_thresholds(param: Data) -> StakePoolOperatorVotingThresholds {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn into_spo_voting_thresholds(param: Data) -> StakePoolOperatorVotingThresholds {\n  expect [\n    motion_of_no_confidence, constitutional_committee,\n    constitutional_committee_under_no_confidence, hard_fork,\n    protocol_parameters_security_group,\n  ]: List<Data> = param\n\n  StakePoolOperatorVotingThresholds {\n    motion_of_no_confidence: into_rational(motion_of_no_confidence),\n    constitutional_committee: ConstitutionalCommitteeThresholds {\n      default: into_rational(constitutional_committee),\n      under_no_confidence: into_rational(\n        constitutional_committee_under_no_confidence,\n      ),\n    },\n    hard_fork: into_rational(hard_fork),\n    protocol_parameters: ProtocolParametersThresholds {\n      security_group: into_rational(protocol_parameters_security_group),\n      network_group: Void,\n      economic_group: Void,\n      technical_group: Void,\n      governance_group: Void,\n    },\n  }\n}"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.into_drep_voting_thresholds",
      "fullName": "stdlib:cardano.governance.protocol_parameters.into_drep_voting_thresholds",
      "name": "into_drep_voting_thresholds",
      "signature": "fn into_drep_voting_thresholds(fn into_drep_voting_thresholds(param: Data, ) -> DelegateRepresentativeVotingThresholds {",
      "parameters": [],
      "returnType": "DelegateRepresentativeVotingThresholds",
      "line": 330,
      "raw": "fn into_drep_voting_thresholds(fn into_drep_voting_thresholds(param: Data, ) -> DelegateRepresentativeVotingThresholds {",
      "isPublic": false,
      "source": "stdlib",
      "implementation": "fn into_drep_voting_thresholds(\n  param: Data,\n) -> DelegateRepresentativeVotingThresholds {\n  expect [\n    motion_of_no_confidence, constitutional_committee,\n    constitutional_committee_under_no_confidence, constitution, hard_fork,\n    protocol_parameters_network_group, protocol_parameters_economic_group,\n    protocol_parameters_technical_group, protocol_parameters_governance_group,\n    treasury_withdrawal,\n  ]: List<Data> = param\n\n  DelegateRepresentativeVotingThresholds {\n    motion_of_no_confidence: into_rational(motion_of_no_confidence),\n    constitutional_committee: ConstitutionalCommitteeThresholds {\n      default: into_rational(constitutional_committee),\n      under_no_confidence: into_rational(\n        constitutional_committee_under_no_confidence,\n      ),\n    },\n    constitution: into_rational(constitution),\n    hard_fork: into_rational(hard_fork),\n    protocol_parameters: ProtocolParametersThresholds {\n      security_group: Void,\n      network_group: into_rational(protocol_parameters_network_group),\n      economic_group: into_rational(protocol_parameters_economic_group),\n      technical_group: into_rational(protocol_parameters_technical_group),\n      governance_group: into_rational(protocol_parameters_governance_group),\n    },\n    treasury_withdrawal: into_rational(treasury_withdrawal),\n  }\n}"
    },
    {
      "key": "vodka:cocktail.vodka_converter.convert_int_to_bytes_go",
      "fullName": "vodka:cocktail.vodka_converter.convert_int_to_bytes_go",
      "name": "convert_int_to_bytes_go",
      "signature": "fn convert_int_to_bytes_go(newInt: Int, digit: Int) -> ByteArray {",
      "parameters": [
        {
          "name": "newInt",
          "type": "Int",
          "optional": false
        },
        {
          "name": "digit",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 12,
      "raw": "fn convert_int_to_bytes_go(newInt: Int, digit: Int) -> ByteArray {",
      "isPublic": false,
      "source": "vodka",
      "implementation": "fn convert_int_to_bytes_go(newInt: Int, digit: Int) -> ByteArray {\n  if digit == 1 {\n    bytearray.push(\"\", newInt + 48)\n  } else {\n    bytearray.push(\n      convert_int_to_bytes_go(newInt % digit, digit / 10),\n      newInt / digit + 48,\n    )\n  }\n}"
    },
    {
      "key": "vodka:cocktail.vodka_converter.go_get_number_digit",
      "fullName": "vodka:cocktail.vodka_converter.go_get_number_digit",
      "name": "go_get_number_digit",
      "signature": "fn go_get_number_digit(newInt: Int, digit: Int) -> Int {",
      "parameters": [
        {
          "name": "newInt",
          "type": "Int",
          "optional": false
        },
        {
          "name": "digit",
          "type": "Int",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 28,
      "raw": "fn go_get_number_digit(newInt: Int, digit: Int) -> Int {",
      "isPublic": false,
      "source": "vodka",
      "implementation": "fn go_get_number_digit(newInt: Int, digit: Int) -> Int {\n  if newInt < 10 {\n    digit\n  } else {\n    go_get_number_digit(newInt / 10, digit * 10)\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.filter_map_pre",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.filter_map_pre",
      "name": "filter_map_pre",
      "signature": "fn filter_map_pre(fn filter_map_pre(self: List<a>, predicate: fn(b) -> Bool, transform: fn(a) -> b,",
      "parameters": [],
      "returnType": "Bool, transform: fn(a) -> b,",
      "line": 553,
      "raw": "fn filter_map_pre(fn filter_map_pre(self: List<a>, predicate: fn(b) -> Bool, transform: fn(a) -> b,",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn filter_map_pre(\n  self: List<a>,\n  predicate: fn(b) -> Bool,\n  transform: fn(a) -> b,\n) -> List<b> {\n  when self is {\n    [] -> []\n    [x, ..xs] -> {\n      let y = transform(x)\n      if predicate(y) {\n        [y, ..filter_map_pre(xs, predicate, transform)]\n      } else {\n        filter_map_pre(xs, predicate, transform)\n      }\n    }\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.filter_map_post",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.filter_map_post",
      "name": "filter_map_post",
      "signature": "fn filter_map_post(fn filter_map_post(self: List<a>, predicate: fn(a) -> Bool, transform: fn(a) -> b,",
      "parameters": [],
      "returnType": "Bool, transform: fn(a) -> b,",
      "line": 572,
      "raw": "fn filter_map_post(fn filter_map_post(self: List<a>, predicate: fn(a) -> Bool, transform: fn(a) -> b,",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn filter_map_post(\n  self: List<a>,\n  predicate: fn(a) -> Bool,\n  transform: fn(a) -> b,\n) -> List<b> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      if predicate(x) {\n        [transform(x), ..filter_map_post(xs, predicate, transform)]\n      } else {\n        filter_map_post(xs, predicate, transform)\n      }\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.has_data_cs",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.has_data_cs",
      "name": "has_data_cs",
      "signature": "fn has_data_cs(cs: PolicyId, value: Value) -> Bool {",
      "parameters": [
        {
          "name": "cs",
          "type": "PolicyId",
          "optional": false
        },
        {
          "name": "value",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 589,
      "raw": "fn has_data_cs(cs: PolicyId, value: Value) -> Bool {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn has_data_cs(cs: PolicyId, value: Value) -> Bool {\n  value\n    |> to_dict()\n    |> has_key(cs)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.is_root_node",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.is_root_node",
      "name": "is_root_node",
      "signature": "fn is_root_node(node_key: NodeKey) -> Bool {",
      "parameters": [
        {
          "name": "node_key",
          "type": "NodeKey",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 595,
      "raw": "fn is_root_node(node_key: NodeKey) -> Bool {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn is_root_node(node_key: NodeKey) -> Bool {\n  node_key == Empty\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.is_last_node",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.is_last_node",
      "name": "is_last_node",
      "signature": "fn is_last_node(node_link: NodeKey) -> Bool {",
      "parameters": [
        {
          "name": "node_link",
          "type": "NodeKey",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 599,
      "raw": "fn is_last_node(node_link: NodeKey) -> Bool {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn is_last_node(node_link: NodeKey) -> Bool {\n  node_link == Empty\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.is_empty_list",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.is_empty_list",
      "name": "is_empty_list",
      "signature": "fn is_empty_list(node_key: NodeKey, node_link: NodeKey) -> Bool {",
      "parameters": [
        {
          "name": "node_key",
          "type": "NodeKey",
          "optional": false
        },
        {
          "name": "node_link",
          "type": "NodeKey",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 603,
      "raw": "fn is_empty_list(node_key: NodeKey, node_link: NodeKey) -> Bool {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn is_empty_list(node_key: NodeKey, node_link: NodeKey) -> Bool {\n  and {\n    is_root_node(node_key),\n    is_last_node(node_link),\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.key_added",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.key_added",
      "name": "key_added",
      "signature": "fn key_added(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {",
      "parameters": [
        {
          "name": "key",
          "type": "NodeKey",
          "optional": false
        },
        {
          "name": "node_mint",
          "type": "Dict<AssetName, Int>",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 610,
      "raw": "fn key_added(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn key_added(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {\n  and {\n    dict.size(node_mint) == 1,\n    dict.get(node_mint, serialize_key(key)) == Some(1),\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.key_removed",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.key_removed",
      "name": "key_removed",
      "signature": "fn key_removed(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {",
      "parameters": [
        {
          "name": "key",
          "type": "NodeKey",
          "optional": false
        },
        {
          "name": "node_mint",
          "type": "Dict<AssetName, Int>",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 617,
      "raw": "fn key_removed(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn key_removed(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {\n  and {\n    dict.size(node_mint) == 1,\n    dict.get(node_mint, serialize_key(key)) == Some(-1),\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.is_member",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.is_member",
      "name": "is_member",
      "signature": "fn is_member(k: NodeKey, node_key: NodeKey) -> Bool {",
      "parameters": [
        {
          "name": "k",
          "type": "NodeKey",
          "optional": false
        },
        {
          "name": "node_key",
          "type": "NodeKey",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 624,
      "raw": "fn is_member(k: NodeKey, node_key: NodeKey) -> Bool {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn is_member(k: NodeKey, node_key: NodeKey) -> Bool {\n  k == node_key\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.is_not_member",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.is_not_member",
      "name": "is_not_member",
      "signature": "fn is_not_member(k: NodeKey, node_key: NodeKey, node_link: NodeKey) -> Bool {",
      "parameters": [
        {
          "name": "k",
          "type": "NodeKey",
          "optional": false
        },
        {
          "name": "node_key",
          "type": "NodeKey",
          "optional": false
        },
        {
          "name": "node_link",
          "type": "NodeKey",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 628,
      "raw": "fn is_not_member(k: NodeKey, node_key: NodeKey, node_link: NodeKey) -> Bool {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn is_not_member(k: NodeKey, node_key: NodeKey, node_link: NodeKey) -> Bool {\n  // k must contain a key.\n  expect Key(actual_k) = k\n  // k must be \"between\" the node's key and link.\n  and {\n    // The node is either the root node or its key is less than k.\n    when node_key is {\n      Empty -> True\n      Key(actual_node_key) ->\n        bytearray.compare(actual_node_key, actual_k) == Less\n    },\n    // The node is either the last node or k is less than its link.\n    when node_link is {\n      Empty -> True\n      Key(actual_node_link) ->\n        bytearray.compare(actual_k, actual_node_link) == Less\n    },\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.filter_map_pre",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.filter_map_pre",
      "name": "filter_map_pre",
      "signature": "fn filter_map_pre(fn filter_map_pre(self: List<a>, predicate: fn(b) -> Bool, transform: fn(a) -> b,",
      "parameters": [],
      "returnType": "Bool, transform: fn(a) -> b,",
      "line": 442,
      "raw": "fn filter_map_pre(fn filter_map_pre(self: List<a>, predicate: fn(b) -> Bool, transform: fn(a) -> b,",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn filter_map_pre(\n  self: List<a>,\n  predicate: fn(b) -> Bool,\n  transform: fn(a) -> b,\n) -> List<b> {\n  when self is {\n    [] -> []\n    [x, ..xs] -> {\n      let y = transform(x)\n      if predicate(y) {\n        [y, ..filter_map_pre(xs, predicate, transform)]\n      } else {\n        filter_map_pre(xs, predicate, transform)\n      }\n    }\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.filter_map_post",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.filter_map_post",
      "name": "filter_map_post",
      "signature": "fn filter_map_post(fn filter_map_post(self: List<a>, predicate: fn(a) -> Bool, transform: fn(a) -> b,",
      "parameters": [],
      "returnType": "Bool, transform: fn(a) -> b,",
      "line": 461,
      "raw": "fn filter_map_post(fn filter_map_post(self: List<a>, predicate: fn(a) -> Bool, transform: fn(a) -> b,",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn filter_map_post(\n  self: List<a>,\n  predicate: fn(a) -> Bool,\n  transform: fn(a) -> b,\n) -> List<b> {\n  when self is {\n    [] -> []\n    [x, ..xs] ->\n      if predicate(x) {\n        [transform(x), ..filter_map_post(xs, predicate, transform)]\n      } else {\n        filter_map_post(xs, predicate, transform)\n      }\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.has_data_cs",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.has_data_cs",
      "name": "has_data_cs",
      "signature": "fn has_data_cs(cs: PolicyId, value: Value) -> Bool {",
      "parameters": [
        {
          "name": "cs",
          "type": "PolicyId",
          "optional": false
        },
        {
          "name": "value",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 478,
      "raw": "fn has_data_cs(cs: PolicyId, value: Value) -> Bool {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn has_data_cs(cs: PolicyId, value: Value) -> Bool {\n  value\n    |> to_dict()\n    |> has_key(cs)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.is_root_node",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.is_root_node",
      "name": "is_root_node",
      "signature": "fn is_root_node(node_key: NodeKey) -> Bool {",
      "parameters": [
        {
          "name": "node_key",
          "type": "NodeKey",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 484,
      "raw": "fn is_root_node(node_key: NodeKey) -> Bool {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn is_root_node(node_key: NodeKey) -> Bool {\n  node_key == Empty\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.is_last_node",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.is_last_node",
      "name": "is_last_node",
      "signature": "fn is_last_node(node_link: NodeKey) -> Bool {",
      "parameters": [
        {
          "name": "node_link",
          "type": "NodeKey",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 488,
      "raw": "fn is_last_node(node_link: NodeKey) -> Bool {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn is_last_node(node_link: NodeKey) -> Bool {\n  node_link == Empty\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.is_empty_list",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.is_empty_list",
      "name": "is_empty_list",
      "signature": "fn is_empty_list(node_key: NodeKey, node_link: NodeKey) -> Bool {",
      "parameters": [
        {
          "name": "node_key",
          "type": "NodeKey",
          "optional": false
        },
        {
          "name": "node_link",
          "type": "NodeKey",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 492,
      "raw": "fn is_empty_list(node_key: NodeKey, node_link: NodeKey) -> Bool {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn is_empty_list(node_key: NodeKey, node_link: NodeKey) -> Bool {\n  and {\n    is_root_node(node_key),\n    is_last_node(node_link),\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.key_added",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.key_added",
      "name": "key_added",
      "signature": "fn key_added(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {",
      "parameters": [
        {
          "name": "key",
          "type": "NodeKey",
          "optional": false
        },
        {
          "name": "node_mint",
          "type": "Dict<AssetName, Int>",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 499,
      "raw": "fn key_added(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn key_added(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {\n  and {\n    dict.size(node_mint) == 1,\n    dict.get(node_mint, serialize_key(key)) == Some(1),\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.key_removed",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.key_removed",
      "name": "key_removed",
      "signature": "fn key_removed(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {",
      "parameters": [
        {
          "name": "key",
          "type": "NodeKey",
          "optional": false
        },
        {
          "name": "node_mint",
          "type": "Dict<AssetName, Int>",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 506,
      "raw": "fn key_removed(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn key_removed(key: NodeKey, node_mint: Dict<AssetName, Int>) -> Bool {\n  and {\n    dict.size(node_mint) == 1,\n    dict.get(node_mint, serialize_key(key)) == Some(-1),\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.is_member",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.is_member",
      "name": "is_member",
      "signature": "fn is_member(k: NodeKey, node_key: NodeKey) -> Bool {",
      "parameters": [
        {
          "name": "k",
          "type": "NodeKey",
          "optional": false
        },
        {
          "name": "node_key",
          "type": "NodeKey",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 513,
      "raw": "fn is_member(k: NodeKey, node_key: NodeKey) -> Bool {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn is_member(k: NodeKey, node_key: NodeKey) -> Bool {\n  k == node_key\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.merkelized-validator.data_to_ints",
      "fullName": "anastasia:aiken-design-patterns.merkelized-validator.data_to_ints",
      "name": "data_to_ints",
      "signature": "fn data_to_ints(d: Data) -> List<Int> {",
      "parameters": [
        {
          "name": "d",
          "type": "Data",
          "optional": false
        }
      ],
      "returnType": "List<Int>",
      "line": 135,
      "raw": "fn data_to_ints(d: Data) -> List<Int> {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn data_to_ints(d: Data) -> List<Int> {\n  expect ints: List<Int> = d\n  ints\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.multi-utxo-indexer-one-to-many.tests_fuzzer",
      "fullName": "anastasia:aiken-design-patterns.multi-utxo-indexer-one-to-many.tests_fuzzer",
      "name": "tests_fuzzer",
      "signature": "fn tests_fuzzer() -> Fuzzer<",
      "parameters": [],
      "returnType": "Fuzzer<",
      "line": 334,
      "raw": "fn tests_fuzzer() -> Fuzzer<",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn tests_fuzzer() -> Fuzzer<\n  (\n    ScriptHash,\n    List<Input>,\n    List<Output>,\n    Pairs<Int, List<Int>>,\n    Int,\n    Pairs<ScriptPurpose, Redeemer>,\n  ),\n> {\n  let script_hash <- fuzz.and_then(fuzz.bytearray_fixed(28))\n  let wallet_inputs <- fuzz.and_then(utils.user_inputs_fuzzer())\n  let script_inputs <-\n    fuzz.and_then(\n      fuzz.list_between(\n        utils.specific_script_input_fuzzer(script_hash, NoDatum),\n        1,\n        10,\n      ),\n    )\n  let inputs = list.concat(wallet_inputs, script_inputs) |> utils.sort_inputs\n  let (script_input_indices, script_outputs) =\n    list.indexed_foldr(\n      inputs,\n      ([], []),\n      fn(i, input, acc) {\n        let (i_indices, outputs) = acc\n        when input.output.address.payment_credential is {\n          Script(_) ->\n            (\n              i_indices |> list.push(i),\n              outputs\n                |> list.push(input.output)\n                |> list.push(input.output)\n                |> list.push(input.output)\n                |> list.push(input.output)\n                |> list.push(input.output),\n            )\n          _ -> acc\n        }\n      },\n    )\n  let redeemer =\n    script_input_indices\n      |> list.indexed_foldr(\n          [],\n          fn(i, script_input_index, acc) {\n            list.push(\n              acc,\n              Pair(script_input_index, list.range(i * 5, i * 5 + 4)),\n            )\n          },\n        )\n  fuzz.constant(\n    (\n      script_hash,\n      inputs,\n      script_outputs,\n      redeemer,\n      list.length(script_inputs),\n      list.map(\n        script_inputs,\n        fn(i) { Pair(Spend(i.output_reference), builtin.i_data(0)) },\n      ),\n    ),\n  )\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.multi-utxo-indexer.tests_fuzzer",
      "fullName": "anastasia:aiken-design-patterns.multi-utxo-indexer.tests_fuzzer",
      "name": "tests_fuzzer",
      "signature": "fn tests_fuzzer() -> Fuzzer<",
      "parameters": [],
      "returnType": "Fuzzer<",
      "line": 155,
      "raw": "fn tests_fuzzer() -> Fuzzer<",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn tests_fuzzer() -> Fuzzer<\n  (\n    ScriptHash,\n    List<Input>,\n    List<Output>,\n    Pairs<Int, Int>,\n    Pairs<ScriptPurpose, Redeemer>,\n  ),\n> {\n  let script_hash <- fuzz.and_then(fuzz.bytearray_fixed(28))\n  let wallet_inputs <- fuzz.and_then(utils.user_inputs_fuzzer())\n  let script_inputs <-\n    fuzz.and_then(\n      fuzz.list_between(\n        utils.specific_script_input_fuzzer(script_hash, NoDatum),\n        1,\n        10,\n      ),\n    )\n  let inputs = list.concat(wallet_inputs, script_inputs) |> utils.sort_inputs\n  let (script_input_indices, script_outputs) =\n    list.indexed_foldr(\n      inputs,\n      ([], []),\n      fn(i, input, acc) {\n        let (i_indices, outputs) = acc\n        when input.output.address.payment_credential is {\n          Script(_) ->\n            (i_indices |> list.push(i), outputs |> list.push(input.output))\n          _ -> acc\n        }\n      },\n    )\n  let redeemer =\n    script_input_indices\n      |> list.indexed_foldr(\n          [],\n          fn(i, script_input_index, acc) {\n            list.push(acc, Pair(script_input_index, i))\n          },\n        )\n  fuzz.constant(\n    (\n      script_hash,\n      inputs,\n      script_outputs,\n      redeemer,\n      list.map(\n        script_inputs,\n        fn(i) { Pair(Spend(i.output_reference), builtin.i_data(0)) },\n      ),\n    ),\n  )\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.append_first_param_to_prefix",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.append_first_param_to_prefix",
      "name": "append_first_param_to_prefix",
      "signature": "fn append_first_param_to_prefix(fn append_first_param_to_prefix(version: Int, prefix: ByteArray, param: ByteArray, ) -> ByteArray {",
      "parameters": [],
      "returnType": "ByteArray",
      "line": 42,
      "raw": "fn append_first_param_to_prefix(fn append_first_param_to_prefix(version: Int, prefix: ByteArray, param: ByteArray, ) -> ByteArray {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn append_first_param_to_prefix(\n  version: Int,\n  prefix: ByteArray,\n  param: ByteArray,\n) -> ByteArray {\n  builtin.integer_to_bytearray(True, 1, version)\n    |> bytearray.concat(prefix)\n    |> bytearray.concat(blake2b_224(param))\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.append_param",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.append_param",
      "name": "append_param",
      "signature": "fn append_param(prefix: ByteArray, param: ByteArray) -> ByteArray {",
      "parameters": [
        {
          "name": "prefix",
          "type": "ByteArray",
          "optional": false
        },
        {
          "name": "param",
          "type": "ByteArray",
          "optional": false
        }
      ],
      "returnType": "ByteArray",
      "line": 52,
      "raw": "fn append_param(prefix: ByteArray, param: ByteArray) -> ByteArray {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn append_param(prefix: ByteArray, param: ByteArray) -> ByteArray {\n  prefix\n    |> bytearray.concat(blake2b_224(param))\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.append_first_prehashed_param_to_prefix",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.append_first_prehashed_param_to_prefix",
      "name": "append_first_prehashed_param_to_prefix",
      "signature": "fn append_first_prehashed_param_to_prefix(fn append_first_prehashed_param_to_prefix(version: Int, prefix: ByteArray, param: ByteArray, ) -> ByteArray {",
      "parameters": [],
      "returnType": "ByteArray",
      "line": 57,
      "raw": "fn append_first_prehashed_param_to_prefix(fn append_first_prehashed_param_to_prefix(version: Int, prefix: ByteArray, param: ByteArray, ) -> ByteArray {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn append_first_prehashed_param_to_prefix(\n  version: Int,\n  prefix: ByteArray,\n  param: ByteArray,\n) -> ByteArray {\n  builtin.integer_to_bytearray(True, 1, version)\n    |> bytearray.concat(prefix)\n    |> bytearray.concat(param)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.singular-utxo-indexer.always_true_in_out",
      "fullName": "anastasia:aiken-design-patterns.singular-utxo-indexer.always_true_in_out",
      "name": "always_true_in_out",
      "signature": "fn always_true_in_out(_i: Input, _o: Output) -> Bool {",
      "parameters": [
        {
          "name": "_i",
          "type": "Input",
          "optional": false
        },
        {
          "name": "_o",
          "type": "Output",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 95,
      "raw": "fn always_true_in_out(_i: Input, _o: Output) -> Bool {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn always_true_in_out(_i: Input, _o: Output) -> Bool {\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.singular-utxo-indexer.always_true_in_outs",
      "fullName": "anastasia:aiken-design-patterns.singular-utxo-indexer.always_true_in_outs",
      "name": "always_true_in_outs",
      "signature": "fn always_true_in_outs(_i: Input, _os: List<Output>) -> Bool {",
      "parameters": [
        {
          "name": "_i",
          "type": "Input",
          "optional": false
        },
        {
          "name": "_os",
          "type": "List<Output>",
          "optional": false
        }
      ],
      "returnType": "Bool",
      "line": 99,
      "raw": "fn always_true_in_outs(_i: Input, _os: List<Output>) -> Bool {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn always_true_in_outs(_i: Input, _os: List<Output>) -> Bool {\n  True\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.tests.test_224_01",
      "fullName": "anastasia:aiken-design-patterns.tests.test_224_01",
      "name": "test_224_01",
      "signature": "fn test_224_01() {",
      "parameters": [],
      "returnType": "Unknown",
      "line": 12,
      "raw": "fn test_224_01() {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn test_224_01() {\n  bytearray.take(blake2b_256(#\"01\"), 28)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.tests.test_224_02",
      "fullName": "anastasia:aiken-design-patterns.tests.test_224_02",
      "name": "test_224_02",
      "signature": "fn test_224_02() {",
      "parameters": [],
      "returnType": "Unknown",
      "line": 17,
      "raw": "fn test_224_02() {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn test_224_02() {\n  bytearray.take(blake2b_256(#\"02\"), 28)\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.tests.test_utxo_01",
      "fullName": "anastasia:aiken-design-patterns.tests.test_utxo_01",
      "name": "test_utxo_01",
      "signature": "fn test_utxo_01() {",
      "parameters": [],
      "returnType": "Unknown",
      "line": 22,
      "raw": "fn test_utxo_01() {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn test_utxo_01() {\n  Output {\n    address: Address {\n      payment_credential: Script(test_224_01()),\n      stake_credential: None,\n    },\n    value: assets.add(assets.from_lovelace(2_000_000), test_224_01(), #\"01\", 1),\n    datum: InlineDatum(1),\n    reference_script: None,\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.tests.test_utxo_02",
      "fullName": "anastasia:aiken-design-patterns.tests.test_utxo_02",
      "name": "test_utxo_02",
      "signature": "fn test_utxo_02() {",
      "parameters": [],
      "returnType": "Unknown",
      "line": 35,
      "raw": "fn test_utxo_02() {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn test_utxo_02() {\n  Output {\n    address: Address {\n      payment_credential: Script(test_224_02()),\n      stake_credential: None,\n    },\n    value: assets.add(assets.from_lovelace(2_000_000), test_224_02(), #\"02\", 1),\n    datum: InlineDatum(1),\n    reference_script: None,\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.tx-level-minter.grab_a_policy_from_mint",
      "fullName": "anastasia:aiken-design-patterns.tx-level-minter.grab_a_policy_from_mint",
      "name": "grab_a_policy_from_mint",
      "signature": "fn grab_a_policy_from_mint(m: Value) -> Fuzzer<(PolicyId, Value)> {",
      "parameters": [
        {
          "name": "m",
          "type": "Value",
          "optional": false
        }
      ],
      "returnType": "Fuzzer<(PolicyId, Value)>",
      "line": 52,
      "raw": "fn grab_a_policy_from_mint(m: Value) -> Fuzzer<(PolicyId, Value)> {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn grab_a_policy_from_mint(m: Value) -> Fuzzer<(PolicyId, Value)> {\n  let policies = m |> assets.policies\n  fuzz.map(\n    fuzz.int_between(0, list.length(policies) - 1),\n    fn(i) {\n      trace list.length(policies)\n      trace i\n      expect Some(p) = list.at(policies, i)\n      (p, m)\n    },\n  )\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.validity-range-normalization.resolve_lower",
      "fullName": "anastasia:aiken-design-patterns.validity-range-normalization.resolve_lower",
      "name": "resolve_lower",
      "signature": "fn resolve_lower(init_lower: Int, is_inclusive: Bool) -> Int {",
      "parameters": [
        {
          "name": "init_lower",
          "type": "Int",
          "optional": false
        },
        {
          "name": "is_inclusive",
          "type": "Bool",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 52,
      "raw": "fn resolve_lower(init_lower: Int, is_inclusive: Bool) -> Int {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn resolve_lower(init_lower: Int, is_inclusive: Bool) -> Int {\n  if is_inclusive {\n    init_lower\n  } else {\n    init_lower + 1\n  }\n}"
    },
    {
      "key": "anastasia:aiken-design-patterns.validity-range-normalization.resolve_upper",
      "fullName": "anastasia:aiken-design-patterns.validity-range-normalization.resolve_upper",
      "name": "resolve_upper",
      "signature": "fn resolve_upper(init_upper: Int, is_inclusive: Bool) -> Int {",
      "parameters": [
        {
          "name": "init_upper",
          "type": "Int",
          "optional": false
        },
        {
          "name": "is_inclusive",
          "type": "Bool",
          "optional": false
        }
      ],
      "returnType": "Int",
      "line": 60,
      "raw": "fn resolve_upper(init_upper: Int, is_inclusive: Bool) -> Int {",
      "isPublic": false,
      "source": "anastasia",
      "implementation": "fn resolve_upper(init_upper: Int, is_inclusive: Bool) -> Int {\n  if is_inclusive {\n    init_upper\n  } else {\n    init_upper - 1\n  }\n}"
    }
  ],
  "types": [
    {
      "key": "stdlib:aiken.collection.dict.strategy.UnionStrategy<key, value>",
      "fullName": "stdlib:aiken.collection.dict.strategy.UnionStrategy<key, value>",
      "name": "UnionStrategy<key, value>",
      "definition": "fn(key, value, value, KeepValue<key, value>, DiscardValue<key, value>) ->",
      "line": 2,
      "raw": "pub type UnionStrategy<key, value> =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.collection.dict.strategy.KeepValue<key, value>",
      "fullName": "stdlib:aiken.collection.dict.strategy.KeepValue<key, value>",
      "name": "KeepValue<key, value>",
      "definition": "fn(value) -> Pairs<key, value>",
      "line": 7,
      "raw": "pub type KeepValue<key, value> =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.collection.dict.strategy.DiscardValue<key, value>",
      "fullName": "stdlib:aiken.collection.dict.strategy.DiscardValue<key, value>",
      "name": "DiscardValue<key, value>",
      "definition": "fn() -> Pairs<key, value>",
      "line": 11,
      "raw": "pub type DiscardValue<key, value> =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.collection.dict.Dict<key, value>",
      "fullName": "stdlib:aiken.collection.dict.Dict<key, value>",
      "name": "Dict<key, value>",
      "definition": "opaque { inner: Pairs<ByteArray, value>, }",
      "line": 31,
      "raw": "pub opaque type Dict<key, value> {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.collection.list.Fold2<a, b, result>",
      "fullName": "stdlib:aiken.collection.list.Fold2<a, b, result>",
      "name": "Fold2<a, b, result>",
      "definition": "fn(a, b) -> result",
      "line": 1207,
      "raw": "pub type Fold2<a, b, result> =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.collection.Index",
      "fullName": "stdlib:aiken.collection.Index",
      "name": "Index",
      "definition": "Int",
      "line": 3,
      "raw": "pub type Index =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.bitwise.State<t>",
      "fullName": "stdlib:aiken.crypto.bitwise.State<t>",
      "name": "State<t>",
      "definition": "opaque { inner: Int, }",
      "line": 5,
      "raw": "pub opaque type State<t> {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.Scalar",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.Scalar",
      "name": "Scalar",
      "definition": "ByteArray",
      "line": 28,
      "raw": "pub type Scalar =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int224.Bits224",
      "fullName": "stdlib:aiken.crypto.int224.Bits224",
      "name": "Bits224",
      "definition": "opaque { Bits224 }",
      "line": 12,
      "raw": "pub opaque type Bits224 {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int224.State",
      "fullName": "stdlib:aiken.crypto.int224.State",
      "name": "State",
      "definition": "bitwise.State<Bits224>",
      "line": 16,
      "raw": "pub type State =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int256.Bits256",
      "fullName": "stdlib:aiken.crypto.int256.Bits256",
      "name": "Bits256",
      "definition": "opaque { Bits256 }",
      "line": 20,
      "raw": "pub opaque type Bits256 {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int256.State",
      "fullName": "stdlib:aiken.crypto.int256.State",
      "name": "State",
      "definition": "bitwise.State<Bits256>",
      "line": 24,
      "raw": "pub type State =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.VerificationKey",
      "fullName": "stdlib:aiken.crypto.VerificationKey",
      "name": "VerificationKey",
      "definition": "ByteArray",
      "line": 3,
      "raw": "pub type VerificationKey =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.VerificationKeyHash",
      "fullName": "stdlib:aiken.crypto.VerificationKeyHash",
      "name": "VerificationKeyHash",
      "definition": "Hash<Blake2b_224, VerificationKey>",
      "line": 6,
      "raw": "pub type VerificationKeyHash =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.Script",
      "fullName": "stdlib:aiken.crypto.Script",
      "name": "Script",
      "definition": "ByteArray",
      "line": 9,
      "raw": "pub type Script =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.ScriptHash",
      "fullName": "stdlib:aiken.crypto.ScriptHash",
      "name": "ScriptHash",
      "definition": "Hash<Blake2b_224, Script>",
      "line": 12,
      "raw": "pub type ScriptHash =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.Signature",
      "fullName": "stdlib:aiken.crypto.Signature",
      "name": "Signature",
      "definition": "ByteArray",
      "line": 15,
      "raw": "pub type Signature =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.DataHash",
      "fullName": "stdlib:aiken.crypto.DataHash",
      "name": "DataHash",
      "definition": "Hash<Blake2b_256, Data>",
      "line": 18,
      "raw": "pub type DataHash =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.Hash<alg, a>",
      "fullName": "stdlib:aiken.crypto.Hash<alg, a>",
      "name": "Hash<alg, a>",
      "definition": "ByteArray",
      "line": 51,
      "raw": "pub type Hash<alg, a> =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.Blake2b_224",
      "fullName": "stdlib:aiken.crypto.Blake2b_224",
      "name": "Blake2b_224",
      "definition": "opaque { Blake2b_224 }",
      "line": 62,
      "raw": "pub opaque type Blake2b_224 {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.Blake2b_256",
      "fullName": "stdlib:aiken.crypto.Blake2b_256",
      "name": "Blake2b_256",
      "definition": "opaque { Blake2b_256 }",
      "line": 77,
      "raw": "pub opaque type Blake2b_256 {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.Keccak_256",
      "fullName": "stdlib:aiken.crypto.Keccak_256",
      "name": "Keccak_256",
      "definition": "opaque { Keccak_256 }",
      "line": 87,
      "raw": "pub opaque type Keccak_256 {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.Sha2_256",
      "fullName": "stdlib:aiken.crypto.Sha2_256",
      "name": "Sha2_256",
      "definition": "opaque { Sha2_256 }",
      "line": 97,
      "raw": "pub opaque type Sha2_256 {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.Sha3_256",
      "fullName": "stdlib:aiken.crypto.Sha3_256",
      "name": "Sha3_256",
      "definition": "opaque { Sha3_256 }",
      "line": 107,
      "raw": "pub opaque type Sha3_256 {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.interval.Interval",
      "fullName": "stdlib:aiken.interval.Interval",
      "name": "Interval",
      "definition": "{ lower_bound: IntervalBound, upper_bound: IntervalBound, }",
      "line": 94,
      "raw": "pub type Interval {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.interval.IntervalBound",
      "fullName": "stdlib:aiken.interval.IntervalBound",
      "name": "IntervalBound",
      "definition": "{ bound_type: IntervalBoundType, is_inclusive: Bool, }",
      "line": 100,
      "raw": "pub type IntervalBound {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.interval.IntervalBoundType",
      "fullName": "stdlib:aiken.interval.IntervalBoundType",
      "name": "IntervalBoundType",
      "definition": "{ NegativeInfinity Finite(Int) PositiveInfinity }",
      "line": 107,
      "raw": "pub type IntervalBoundType {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.math.rational.Rational",
      "fullName": "stdlib:aiken.math.rational.Rational",
      "name": "Rational",
      "definition": "opaque { numerator: Int, denominator: Int, }",
      "line": 20,
      "raw": "pub opaque type Rational {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.primitive.bytearray.Byte",
      "fullName": "stdlib:aiken.primitive.bytearray.Byte",
      "name": "Byte",
      "definition": "Int",
      "line": 5,
      "raw": "pub type Byte =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.address.Credential",
      "fullName": "stdlib:cardano.address.Credential",
      "name": "Credential",
      "definition": "{ VerificationKey(VerificationKeyHash) Script(ScriptHash) }",
      "line": 9,
      "raw": "pub type Credential {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.address.Address",
      "fullName": "stdlib:cardano.address.Address",
      "name": "Address",
      "definition": "{ payment_credential: PaymentCredential, stake_credential: Option<StakeCredential>, }",
      "line": 22,
      "raw": "pub type Address {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.address.Referenced<a>",
      "fullName": "stdlib:cardano.address.Referenced<a>",
      "name": "Referenced<a>",
      "definition": "{ Inline(a) Pointer { slot_number: Int, transaction_index: Int, certificate_index: Int } }",
      "line": 64,
      "raw": "pub type Referenced<a> {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.address.StakeCredential",
      "fullName": "stdlib:cardano.address.StakeCredential",
      "name": "StakeCredential",
      "definition": "Referenced<Credential>",
      "line": 76,
      "raw": "pub type StakeCredential =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.address.PaymentCredential",
      "fullName": "stdlib:cardano.address.PaymentCredential",
      "name": "PaymentCredential",
      "definition": "Credential",
      "line": 85,
      "raw": "pub type PaymentCredential =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.assets.strategy.FlattenStrategy<result>",
      "fullName": "stdlib:cardano.assets.strategy.FlattenStrategy<result>",
      "name": "FlattenStrategy<result>",
      "definition": "fn( Hash<Blake2b_224, Script>, ByteArray, Int, KeepResult<result>, DiscardResult<result>, ) ->",
      "line": 4,
      "raw": "pub type FlattenStrategy<result> =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.assets.strategy.KeepResult<result>",
      "fullName": "stdlib:cardano.assets.strategy.KeepResult<result>",
      "name": "KeepResult<result>",
      "definition": "fn(result) -> List<result>",
      "line": 15,
      "raw": "pub type KeepResult<result> =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.assets.strategy.DiscardResult<result>",
      "fullName": "stdlib:cardano.assets.strategy.DiscardResult<result>",
      "name": "DiscardResult<result>",
      "definition": "fn() -> List<result>",
      "line": 19,
      "raw": "pub type DiscardResult<result> =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.assets.Lovelace",
      "fullName": "stdlib:cardano.assets.Lovelace",
      "name": "Lovelace",
      "definition": "Int",
      "line": 10,
      "raw": "pub type Lovelace =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.assets.PolicyId",
      "fullName": "stdlib:cardano.assets.PolicyId",
      "name": "PolicyId",
      "definition": "Hash<Blake2b_224, Script>",
      "line": 14,
      "raw": "pub type PolicyId =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.assets.AssetName",
      "fullName": "stdlib:cardano.assets.AssetName",
      "name": "AssetName",
      "definition": "ByteArray",
      "line": 25,
      "raw": "pub type AssetName =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.assets.Value",
      "fullName": "stdlib:cardano.assets.Value",
      "name": "Value",
      "definition": "opaque { inner: Dict<PolicyId, Dict<AssetName, Int>>, }",
      "line": 39,
      "raw": "pub opaque type Value {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.certificate.StakePoolId",
      "fullName": "stdlib:cardano.certificate.StakePoolId",
      "name": "StakePoolId",
      "definition": "Hash<Blake2b_224, VerificationKey>",
      "line": 5,
      "raw": "pub type StakePoolId =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.certificate.Certificate",
      "fullName": "stdlib:cardano.certificate.Certificate",
      "name": "Certificate",
      "definition": "{ /// Register a stake credential with an optional deposit amount. /// The deposit is always present when using the new registration certificate /// format available since the Conway era. RegisterCredential { credential: Credential, /// > [!NOTE] /// > The `deposit` ought to be an `Option<Lovelace>`, but due to unfortunate /// > circumstances it will always be instantiated to `None` even when set in /// > the host transaction. This is what the `Never` type captures here. deposit: Never, } /// Un-Register a stake credential with an optional refund amount /// The deposit is always present when using the new de-registration certificate /// format available since the Conway era. UnregisterCredential { credential: Credential, /// > [!NOTE] /// > The `refund` ought to be an `Option<Lovelace>`, but due to unfortunate /// > circumstances it will always be instantiated to `None` even when set in /// > the host transaction. This is what the `Never` type captures here. refund: Never, } /// Delegate stake to a [Delegate](#Delegate). DelegateCredential { credential: Credential, delegate: Delegate } /// Register and delegate staking credential to a Delegatee in one certificate. RegisterAndDelegateCredential { credential: Credential, delegate: Delegate, deposit: Lovelace, } /// Register a delegate representative (a.k.a DRep). The deposit is explicit and /// is refunded when the delegate steps down (unregister). RegisterDelegateRepresentative { delegate_representative: Credential, deposit: Lovelace, } /// Update a delegate representative (a.k.a DRep). The certificate also contains /// metadata which aren't visible on-chain. UpdateDelegateRepresentative { delegate_representative: Credential } /// UnRegister a delegate representative, and refund back its past deposit. UnregisterDelegateRepresentative { delegate_representative: Credential, refund: Lovelace, } /// Register a new stake pool RegisterStakePool { /// The hash digest of the stake pool's cold (public) key stake_pool: StakePoolId, /// The hash digest of the stake pool's VRF (public) key vrf: VerificationKeyHash, } /// Retire a stake pool. 'at_epoch' indicates in which the retirement will take place RetireStakePool { stake_pool: StakePoolId, at_epoch: Int } /// Authorize a Hot credential for a specific Committee member's cold credential AuthorizeConstitutionalCommitteeProxy { constitutional_committee_member: Credential, proxy: Credential, } /// Step down from the constitutional committee as a member. RetireFromConstitutionalCommittee { constitutional_committee_member: Credential, } }",
      "line": 11,
      "raw": "pub type Certificate {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.certificate.Delegate",
      "fullName": "stdlib:cardano.certificate.Delegate",
      "name": "Delegate",
      "definition": "{ DelegateBlockProduction { stake_pool: StakePoolId } DelegateVote { delegate_representative: DelegateRepresentative } DelegateBoth { stake_pool: StakePoolId, delegate_representative: DelegateRepresentative, } }",
      "line": 80,
      "raw": "pub type Delegate {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.certificate.DelegateRepresentative",
      "fullName": "stdlib:cardano.certificate.DelegateRepresentative",
      "name": "DelegateRepresentative",
      "definition": "{ Registered(Credential) AlwaysAbstain AlwaysNoConfidence }",
      "line": 89,
      "raw": "pub type DelegateRepresentative {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.ProtocolParametersUpdate",
      "fullName": "stdlib:cardano.governance.protocol_parameters.ProtocolParametersUpdate",
      "name": "ProtocolParametersUpdate",
      "definition": "opaque { inner: Pairs<ProtocolParametersIndex, Data>, }",
      "line": 4,
      "raw": "pub opaque type ProtocolParametersUpdate {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.ScriptExecutionPrices",
      "fullName": "stdlib:cardano.governance.protocol_parameters.ScriptExecutionPrices",
      "name": "ScriptExecutionPrices",
      "definition": "{ memory: Rational, cpu: Rational, }",
      "line": 8,
      "raw": "pub type ScriptExecutionPrices {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.ExecutionUnits",
      "fullName": "stdlib:cardano.governance.protocol_parameters.ExecutionUnits",
      "name": "ExecutionUnits",
      "definition": "{ memory: Int, cpu: Int, }",
      "line": 13,
      "raw": "pub type ExecutionUnits {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.StakePoolOperatorVotingThresholds",
      "fullName": "stdlib:cardano.governance.protocol_parameters.StakePoolOperatorVotingThresholds",
      "name": "StakePoolOperatorVotingThresholds",
      "definition": "{ motion_of_no_confidence: Rational, constitutional_committee: ConstitutionalCommitteeThresholds, hard_fork: Rational, protocol_parameters: ProtocolParametersThresholds< Rational, Void, Void, Void, Void, >, }",
      "line": 18,
      "raw": "pub type StakePoolOperatorVotingThresholds {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.DelegateRepresentativeVotingThresholds",
      "fullName": "stdlib:cardano.governance.protocol_parameters.DelegateRepresentativeVotingThresholds",
      "name": "DelegateRepresentativeVotingThresholds",
      "definition": "{ motion_of_no_confidence: Rational, constitutional_committee: ConstitutionalCommitteeThresholds, constitution: Rational, hard_fork: Rational, protocol_parameters: ProtocolParametersThresholds< Void, Rational, Rational, Rational, Rational, >, treasury_withdrawal: Rational, }",
      "line": 31,
      "raw": "pub type DelegateRepresentativeVotingThresholds {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.ConstitutionalCommitteeThresholds",
      "fullName": "stdlib:cardano.governance.protocol_parameters.ConstitutionalCommitteeThresholds",
      "name": "ConstitutionalCommitteeThresholds",
      "definition": "{ default: Rational, under_no_confidence: Rational, }",
      "line": 60,
      "raw": "pub type ConstitutionalCommitteeThresholds {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.governance.ProposalProcedure",
      "fullName": "stdlib:cardano.governance.ProposalProcedure",
      "name": "ProposalProcedure",
      "definition": "{ deposit: Lovelace, return_address: Credential, governance_action: GovernanceAction, }",
      "line": 8,
      "raw": "pub type ProposalProcedure {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.governance.GovernanceAction",
      "fullName": "stdlib:cardano.governance.GovernanceAction",
      "name": "GovernanceAction",
      "definition": "{ ProtocolParameters { /// The last governance action of type 'ProtocolParameters'. They must all /// form a chain. ancestor: Option<GovernanceActionId>, /// The new proposed protocol parameters. Only values set to `Some` are relevant. new_parameters: ProtocolParametersUpdate, /// The optional guardrails script defined in the constitution. The script /// is executed by the ledger in addition to the hard-coded ledger rules. /// /// It must pass for the new protocol parameters to be deemed valid. guardrails: Option<ScriptHash>, } HardFork { /// The last governance action of type `HardFork`. They must all /// form a chain. ancestor: Option<GovernanceActionId>, /// The new proposed version. Few rules apply to proposing new versions: /// /// - The `major` component, if incremented, must be exactly one more than the current. /// - The `minor` component, if incremented, must be exactly one more than the current. /// - If the `major` component is incremented, `minor` must be set to `0`. /// - Neither `minor` nor `major` can be decremented. new_version: ProtocolVersion, } TreasuryWithdrawal { /// A collection of beneficiaries, which can be plain verification key /// hashes or script hashes (e.g. DAO). beneficiaries: Pairs<Credential, Lovelace>, /// The optional guardrails script defined in the constitution. The script /// is executed by the ledger in addition to the hard-coded ledger rules. /// /// It must pass for the withdrawals to be authorized. guardrails: Option<ScriptHash>, } NoConfidence { /// The last governance action of type `NoConfidence` or /// `ConstitutionalCommittee`. They must all / form a chain. ancestor: Option<GovernanceActionId>, } ConstitutionalCommittee { /// The last governance action of type `NoConfidence` or /// `ConstitutionalCommittee`. They must all / form a chain. ancestor: Option<GovernanceActionId>, /// Constitutional members to be removed. evicted_members: List<Credential>, /// Constitutional members to be added. added_members: Pairs<Credential, Mandate>, /// The new quorum value, as a ratio of a numerator and a denominator. The /// quorum specifies the threshold of 'Yes' votes necessary for the /// constitutional committee to accept a proposal procedure. quorum: Rational, } NewConstitution { /// The last governance action of type `Constitution` or /// `ConstitutionalCommittee`. They must all / form a chain. ancestor: Option<GovernanceActionId>, /// The new proposed constitution. constitution: Constitution, } NicePoll }",
      "line": 14,
      "raw": "pub type GovernanceAction {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.governance.Vote",
      "fullName": "stdlib:cardano.governance.Vote",
      "name": "Vote",
      "definition": "{ No Yes Abstain }",
      "line": 77,
      "raw": "pub type Vote {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.governance.TransactionId",
      "fullName": "stdlib:cardano.governance.TransactionId",
      "name": "TransactionId",
      "definition": "Hash<Blake2b_256, ByteArray>",
      "line": 83,
      "raw": "pub type TransactionId =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.governance.GovernanceActionId",
      "fullName": "stdlib:cardano.governance.GovernanceActionId",
      "name": "GovernanceActionId",
      "definition": "{ transaction: TransactionId, proposal_procedure: Index, }",
      "line": 86,
      "raw": "pub type GovernanceActionId {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.governance.ProtocolVersion",
      "fullName": "stdlib:cardano.governance.ProtocolVersion",
      "name": "ProtocolVersion",
      "definition": "{ major: Int, minor: Int, }",
      "line": 91,
      "raw": "pub type ProtocolVersion {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.governance.Constitution",
      "fullName": "stdlib:cardano.governance.Constitution",
      "name": "Constitution",
      "definition": "{ guardrails: Option<ScriptHash>, }",
      "line": 96,
      "raw": "pub type Constitution {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.governance.Mandate",
      "fullName": "stdlib:cardano.governance.Mandate",
      "name": "Mandate",
      "definition": "Int",
      "line": 102,
      "raw": "pub type Mandate =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.governance.Voter",
      "fullName": "stdlib:cardano.governance.Voter",
      "name": "Voter",
      "definition": "{ ConstitutionalCommitteeMember(Credential) DelegateRepresentative(Credential) StakePool(VerificationKeyHash) }",
      "line": 105,
      "raw": "pub type Voter {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.script_context.ScriptContext",
      "fullName": "stdlib:cardano.script_context.ScriptContext",
      "name": "ScriptContext",
      "definition": "{ transaction: Transaction, redeemer: Redeemer, info: ScriptInfo, }",
      "line": 27,
      "raw": "pub type ScriptContext {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.script_context.ScriptInfo",
      "fullName": "stdlib:cardano.script_context.ScriptInfo",
      "name": "ScriptInfo",
      "definition": "{ /// For scripts executed as minting/burning policies, to insert /// or remove assets from circulation. It's parameterized by the identifier /// of the associated policy. Minting(PolicyId) /// For scripts that are used as payment credentials for addresses in /// transaction outputs. They govern the rule by which the output they /// reference can be spent. Spending { output: OutputReference, datum: Option<Data> } /// For scripts that validate reward withdrawals from a reward account. /// /// The argument identifies the target reward account. Withdrawing(Credential) /// Needed when delegating to a pool using stake credentials defined as a /// custom script. This purpose is also triggered when de-registering such /// stake credentials. /// /// The Int is a 0-based index of the given `Certificate` in `certificates`. Publishing { at: Index, certificate: Certificate } /// Voting for a type of voter using a governance action id to vote /// yes / no / abstain inside a transaction. /// /// The voter is who is doing the governance action. Voting(Voter) /// Used to propose a governance action. /// /// A 0-based index of the given `ProposalProcedure` in `proposal_procedures`. Proposing { at: Index, proposal_procedure: ProposalProcedure } }",
      "line": 34,
      "raw": "pub type ScriptInfo {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.transaction.TransactionId",
      "fullName": "stdlib:cardano.transaction.TransactionId",
      "name": "TransactionId",
      "definition": "Hash<Blake2b_256, Transaction>",
      "line": 15,
      "raw": "pub type TransactionId =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.transaction.ScriptPurpose",
      "fullName": "stdlib:cardano.transaction.ScriptPurpose",
      "name": "ScriptPurpose",
      "definition": "{ /// For scripts executed as minting/burning policies, to insert /// or remove assets from circulation. It's parameterized by the identifier /// of the associated policy. Mint(PolicyId) /// For scripts that are used as payment credentials for addresses in /// transaction outputs. They govern the rule by which the output they /// reference can be spent. Spend(OutputReference) /// For scripts that validate reward withdrawals from a reward account. /// /// The argument identifies the target reward account. Withdraw(Credential) /// Needed when delegating to a pool using stake credentials defined as a /// custom script. This purpose is also triggered when de-registering such /// stake credentials. /// /// The Int is a 0-based index of the given `Certificate` in `certificates`. Publish { at: Index, certificate: Certificate } /// Voting for a type of voter using a governance action id to vote /// yes / no / abstain inside a transaction. /// /// The voter is who is doing the governance action. Vote(Voter) /// Used to propose a governance action. /// /// A 0-based index of the given `ProposalProcedure` in `proposal_procedures`. Propose { at: Index, proposal_procedure: ProposalProcedure } }",
      "line": 19,
      "raw": "pub type ScriptPurpose {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.transaction.Transaction",
      "fullName": "stdlib:cardano.transaction.Transaction",
      "name": "Transaction",
      "definition": "{ inputs: List<Input>, reference_inputs: List<Input>, outputs: List<Output>, fee: Lovelace, mint: Value, certificates: List<Certificate>, /// > [!IMPORTANT] /// > Withdrawals are ordered by ascending [Credential](./credential.html#Credential). Yet, note that [`Script`](./credential.html#Credential) credentials are treated as **lower values** than [`VerificationKey`](./credential.html#Credential) credentials. withdrawals: Pairs<Credential, Lovelace>, validity_range: ValidityRange, extra_signatories: List<VerificationKeyHash>, /// > [!IMPORTANT] /// > Redeemers are ordered by ascending [ScriptPurpose](./transaction.html#ScriptPurpose). redeemers: Pairs<ScriptPurpose, Redeemer>, datums: Dict<DataHash, Data>, id: TransactionId, /// > [!IMPORTANT] /// > Votes are ordered by ascending [Voter](./governance.html#Voter) and [GovernanceActionId](./governance.html#GovernanceActionId).<br/>First constructor variants in a type are treated as lower indices; except for [Credential](./credential.html#Credential) where [`Script`](./credential.html#Credential) credentials are treated as **lower values** than [`VerificationKey`](./credential.html#Credential) credentials. votes: Pairs<Voter, Pairs<GovernanceActionId, Vote>>, proposal_procedures: List<ProposalProcedure>, current_treasury_amount: Option<Lovelace>, treasury_donation: Option<Lovelace>, }",
      "line": 55,
      "raw": "pub type Transaction {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.transaction.ValidityRange",
      "fullName": "stdlib:cardano.transaction.ValidityRange",
      "name": "ValidityRange",
      "definition": "Interval",
      "line": 81,
      "raw": "pub type ValidityRange =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.transaction.Input",
      "fullName": "stdlib:cardano.transaction.Input",
      "name": "Input",
      "definition": "{ output_reference: OutputReference, output: Output, }",
      "line": 85,
      "raw": "pub type Input {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.transaction.OutputReference",
      "fullName": "stdlib:cardano.transaction.OutputReference",
      "name": "OutputReference",
      "definition": "{ transaction_id: Hash<Blake2b_256, Transaction>, output_index: Int, }",
      "line": 93,
      "raw": "pub type OutputReference {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.transaction.Output",
      "fullName": "stdlib:cardano.transaction.Output",
      "name": "Output",
      "definition": "{ address: Address, value: Value, datum: Datum, reference_script: Option<ScriptHash>, }",
      "line": 99,
      "raw": "pub type Output {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.transaction.Datum",
      "fullName": "stdlib:cardano.transaction.Datum",
      "name": "Datum",
      "definition": "{ NoDatum /// A datum referenced by its hash digest. DatumHash(DataHash) /// A datum completely inlined in the output. InlineDatum(Data) }",
      "line": 107,
      "raw": "pub type Datum {",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.transaction.Redeemer",
      "fullName": "stdlib:cardano.transaction.Redeemer",
      "name": "Redeemer",
      "definition": "Data",
      "line": 118,
      "raw": "pub type Redeemer =",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "prelude:aiken.Bool",
      "fullName": "prelude:aiken.Bool",
      "name": "Bool",
      "definition": "{ False True }",
      "line": 5,
      "raw": "pub type Bool {",
      "isPublic": true,
      "source": "prelude"
    },
    {
      "key": "prelude:aiken.Ordering",
      "fullName": "prelude:aiken.Ordering",
      "name": "Ordering",
      "definition": "{ Less Equal Greater }",
      "line": 26,
      "raw": "pub type Ordering {",
      "isPublic": true,
      "source": "prelude"
    },
    {
      "key": "prelude:aiken.ByteArray",
      "fullName": "prelude:aiken.ByteArray",
      "name": "ByteArray",
      "definition": "opaque { ByteArray }",
      "line": 36,
      "raw": "pub opaque type ByteArray {",
      "isPublic": true,
      "source": "prelude"
    },
    {
      "key": "prelude:aiken.Data",
      "fullName": "prelude:aiken.Data",
      "name": "Data",
      "definition": "opaque { Data }",
      "line": 44,
      "raw": "pub opaque type Data {",
      "isPublic": true,
      "source": "prelude"
    },
    {
      "key": "prelude:aiken.Int",
      "fullName": "prelude:aiken.Int",
      "name": "Int",
      "definition": "opaque { Int }",
      "line": 54,
      "raw": "pub opaque type Int {",
      "isPublic": true,
      "source": "prelude"
    },
    {
      "key": "prelude:aiken.String",
      "fullName": "prelude:aiken.String",
      "name": "String",
      "definition": "opaque { String }",
      "line": 62,
      "raw": "pub opaque type String {",
      "isPublic": true,
      "source": "prelude"
    },
    {
      "key": "prelude:aiken.Void",
      "fullName": "prelude:aiken.Void",
      "name": "Void",
      "definition": "opaque { Void }",
      "line": 70,
      "raw": "pub opaque type Void {",
      "isPublic": true,
      "source": "prelude"
    },
    {
      "key": "prelude:aiken.List<a>",
      "fullName": "prelude:aiken.List<a>",
      "name": "List<a>",
      "definition": "opaque { List }",
      "line": 78,
      "raw": "pub opaque type List<a> {",
      "isPublic": true,
      "source": "prelude"
    },
    {
      "key": "prelude:aiken.Pair<k, v>",
      "fullName": "prelude:aiken.Pair<k, v>",
      "name": "Pair<k, v>",
      "definition": "opaque { Pair }",
      "line": 86,
      "raw": "pub opaque type Pair<k, v> {",
      "isPublic": true,
      "source": "prelude"
    },
    {
      "key": "prelude:aiken.Pairs<k, v>",
      "fullName": "prelude:aiken.Pairs<k, v>",
      "name": "Pairs<k, v>",
      "definition": "List<Pair<k, v>>",
      "line": 94,
      "raw": "pub type Pairs<k, v> =",
      "isPublic": true,
      "source": "prelude"
    },
    {
      "key": "prelude:aiken.G1Element",
      "fullName": "prelude:aiken.G1Element",
      "name": "G1Element",
      "definition": "opaque { G1Element }",
      "line": 101,
      "raw": "pub opaque type G1Element {",
      "isPublic": true,
      "source": "prelude"
    },
    {
      "key": "prelude:aiken.G2Element",
      "fullName": "prelude:aiken.G2Element",
      "name": "G2Element",
      "definition": "opaque { G2Element }",
      "line": 109,
      "raw": "pub opaque type G2Element {",
      "isPublic": true,
      "source": "prelude"
    },
    {
      "key": "prelude:aiken.MillerLoopResult",
      "fullName": "prelude:aiken.MillerLoopResult",
      "name": "MillerLoopResult",
      "definition": "opaque { MillerLoopResult }",
      "line": 117,
      "raw": "pub opaque type MillerLoopResult {",
      "isPublic": true,
      "source": "prelude"
    },
    {
      "key": "prelude:aiken.Option<a>",
      "fullName": "prelude:aiken.Option<a>",
      "name": "Option<a>",
      "definition": "{ Some(a) None }",
      "line": 125,
      "raw": "pub type Option<a> {",
      "isPublic": true,
      "source": "prelude"
    },
    {
      "key": "prelude:aiken.Never",
      "fullName": "prelude:aiken.Never",
      "name": "Never",
      "definition": "{ Never }",
      "line": 140,
      "raw": "pub type Never {",
      "isPublic": true,
      "source": "prelude"
    },
    {
      "key": "prelude:aiken.PRNG",
      "fullName": "prelude:aiken.PRNG",
      "name": "PRNG",
      "definition": "{ Seeded { seed: ByteArray, choices: ByteArray } Replayed { cursor: Int, choices: ByteArray } }",
      "line": 148,
      "raw": "pub type PRNG {",
      "isPublic": true,
      "source": "prelude"
    },
    {
      "key": "prelude:aiken.Fuzzer<a>",
      "fullName": "prelude:aiken.Fuzzer<a>",
      "name": "Fuzzer<a>",
      "definition": "fn(PRNG) -> Option<(PRNG, a)>",
      "line": 158,
      "raw": "pub type Fuzzer<a> =",
      "isPublic": true,
      "source": "prelude"
    },
    {
      "key": "prelude:aiken.Sampler<a>",
      "fullName": "prelude:aiken.Sampler<a>",
      "name": "Sampler<a>",
      "definition": "fn(Int) -> Fuzzer<a>",
      "line": 166,
      "raw": "pub type Sampler<a> =",
      "isPublic": true,
      "source": "prelude"
    },
    {
      "key": "vodka:cip.CIP68Metadata",
      "fullName": "vodka:cip.CIP68Metadata",
      "name": "CIP68Metadata",
      "definition": "{ metadata: Pairs<Data, Data>, version: Int, }",
      "line": 70,
      "raw": "pub type CIP68Metadata {",
      "isPublic": true,
      "source": "vodka"
    },
    {
      "key": "vodka:mocktail.MocktailTx",
      "fullName": "vodka:mocktail.MocktailTx",
      "name": "MocktailTx",
      "definition": "{ tx: Transaction, queue_input: Option<Input>, queue_output: Option<Output>, queue_ref_input: Option<Input>, }",
      "line": 46,
      "raw": "pub type MocktailTx {",
      "isPublic": true,
      "source": "vodka"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.NodeDatum",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.NodeDatum",
      "name": "NodeDatum",
      "definition": "{ key: NodeKey, link: NodeKey, data: Data, }",
      "line": 18,
      "raw": "pub type NodeDatum {",
      "isPublic": true,
      "source": "anastasia"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.NodeKey",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.NodeKey",
      "name": "NodeKey",
      "definition": "{ Key { key: ByteArray } Empty }",
      "line": 25,
      "raw": "pub type NodeKey {",
      "isPublic": true,
      "source": "anastasia"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.NodeDatum",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.NodeDatum",
      "name": "NodeDatum",
      "definition": "{ key: NodeKey, link: NodeKey, data: Data, }",
      "line": 18,
      "raw": "pub type NodeDatum {",
      "isPublic": true,
      "source": "anastasia"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.NodeKey",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.NodeKey",
      "name": "NodeKey",
      "definition": "{ Key { key: ByteArray } Empty }",
      "line": 25,
      "raw": "pub type NodeKey {",
      "isPublic": true,
      "source": "anastasia"
    },
    {
      "key": "anastasia:aiken-design-patterns.merkelized-validator.WithdrawRedeemerIO<a, b>",
      "fullName": "anastasia:aiken-design-patterns.merkelized-validator.WithdrawRedeemerIO<a, b>",
      "name": "WithdrawRedeemerIO<a, b>",
      "definition": "{ input_arg: a, result: b, }",
      "line": 39,
      "raw": "pub type WithdrawRedeemerIO<a, b> {",
      "isPublic": true,
      "source": "anastasia"
    },
    {
      "key": "anastasia:aiken-design-patterns.merkelized-validator.WithdrawRedeemer<a>",
      "fullName": "anastasia:aiken-design-patterns.merkelized-validator.WithdrawRedeemer<a>",
      "name": "WithdrawRedeemer<a>",
      "definition": "{ input_arg: a, }",
      "line": 47,
      "raw": "pub type WithdrawRedeemer<a> {",
      "isPublic": true,
      "source": "anastasia"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.ParameterizedRedeemer<p, r>",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.ParameterizedRedeemer<p, r>",
      "name": "ParameterizedRedeemer<p, r>",
      "definition": "{ param: p, redeemer: r, }",
      "line": 164,
      "raw": "pub type ParameterizedRedeemer<p, r> {",
      "isPublic": true,
      "source": "anastasia"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.ParameterizedRedeemer2<p, q, r>",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.ParameterizedRedeemer2<p, q, r>",
      "name": "ParameterizedRedeemer2<p, q, r>",
      "definition": "{ param_0: p, param_1: q, redeemer: r, }",
      "line": 202,
      "raw": "pub type ParameterizedRedeemer2<p, q, r> {",
      "isPublic": true,
      "source": "anastasia"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.ParameterizedRedeemer3<p, q, s, r>",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.ParameterizedRedeemer3<p, q, s, r>",
      "name": "ParameterizedRedeemer3<p, q, s, r>",
      "definition": "{ param_0: p, param_1: q, param_2: s, redeemer: r, }",
      "line": 246,
      "raw": "pub type ParameterizedRedeemer3<p, q, s, r> {",
      "isPublic": true,
      "source": "anastasia"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.Parameter<p>",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.Parameter<p>",
      "name": "Parameter<p>",
      "definition": "{ param: p, }",
      "line": 309,
      "raw": "pub type Parameter<p> {",
      "isPublic": true,
      "source": "anastasia"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.Parameter2<p, q>",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.Parameter2<p, q>",
      "name": "Parameter2<p, q>",
      "definition": "{ param_0: p, param_1: q, }",
      "line": 344,
      "raw": "pub type Parameter2<p, q> {",
      "isPublic": true,
      "source": "anastasia"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.Parameter3<p, q, s>",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.Parameter3<p, q, s>",
      "name": "Parameter3<p, q, s>",
      "definition": "{ param_0: p, param_1: q, param_2: s, }",
      "line": 386,
      "raw": "pub type Parameter3<p, q, s> {",
      "isPublic": true,
      "source": "anastasia"
    },
    {
      "key": "anastasia:aiken-design-patterns.validity-range-normalization.NormalizedTimeRange",
      "fullName": "anastasia:aiken-design-patterns.validity-range-normalization.NormalizedTimeRange",
      "name": "NormalizedTimeRange",
      "definition": "{ ClosedRange { lower: Int, upper: Int } FromNegInf { upper: Int } ToPosInf { lower: Int } Always }",
      "line": 16,
      "raw": "pub type NormalizedTimeRange {",
      "isPublic": true,
      "source": "anastasia"
    }
  ],
  "privateTypes": [
    {
      "key": "stdlib:aiken.cbor.Byte",
      "fullName": "stdlib:aiken.cbor.Byte",
      "name": "Byte",
      "definition": "Int",
      "line": 109,
      "raw": "type Byte =",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.cbor.Decoder<a>",
      "fullName": "stdlib:aiken.cbor.Decoder<a>",
      "name": "Decoder<a>",
      "definition": "fn(Int) -> Pair<a, Int>",
      "line": 112,
      "raw": "type Decoder<a> =",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.cbor.Peek<a>",
      "fullName": "stdlib:aiken.cbor.Peek<a>",
      "name": "Peek<a>",
      "definition": "fn(Int, fn(Byte) -> Decoder<a>) -> Decoder<a>",
      "line": 115,
      "raw": "type Peek<a> =",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.cbor.Take<a>",
      "fullName": "stdlib:aiken.cbor.Take<a>",
      "name": "Take<a>",
      "definition": "fn(Int, fn(ByteArray) -> Decoder<a>) -> Decoder<a>",
      "line": 118,
      "raw": "type Take<a> =",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.collection.list.Foo",
      "fullName": "stdlib:aiken.collection.list.Foo",
      "name": "Foo",
      "definition": "{ Foo(Int, Int) }",
      "line": 1278,
      "raw": "type Foo {",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.BitwiseScalarBytes",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.BitwiseScalarBytes",
      "name": "BitwiseScalarBytes",
      "definition": "fn(State<Scalar>, ByteArray) -> State<Scalar>",
      "line": 72,
      "raw": "type BitwiseScalarBytes =",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.BitwiseScalarInt",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.BitwiseScalarInt",
      "name": "BitwiseScalarInt",
      "definition": "fn(State<Scalar>, Int) -> State<Scalar>",
      "line": 75,
      "raw": "type BitwiseScalarInt =",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.BitwiseScalarState",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.BitwiseScalarState",
      "name": "BitwiseScalarState",
      "definition": "fn(State<Scalar>, State<Scalar>) -> State<Scalar>",
      "line": 78,
      "raw": "type BitwiseScalarState =",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int224.Over<a>",
      "fullName": "stdlib:aiken.crypto.int224.Over<a>",
      "name": "Over<a>",
      "definition": "fn(State, a) -> State",
      "line": 19,
      "raw": "type Over<a> =",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int256.Over<a>",
      "fullName": "stdlib:aiken.crypto.int256.Over<a>",
      "name": "Over<a>",
      "definition": "fn(State, a) -> State",
      "line": 27,
      "raw": "type Over<a> =",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.governance.protocol_parameters.ProtocolParametersIndex",
      "fullName": "stdlib:cardano.governance.protocol_parameters.ProtocolParametersIndex",
      "name": "ProtocolParametersIndex",
      "definition": "Int",
      "line": 262,
      "raw": "type ProtocolParametersIndex =",
      "isPublic": false,
      "source": "stdlib"
    }
  ],
  "constants": [
    {
      "key": "stdlib:aiken.collection.dict.empty",
      "fullName": "stdlib:aiken.collection.dict.empty",
      "name": "empty",
      "type": "Dict<key, value>",
      "value": "Dict { inner: [] }",
      "line": 41,
      "raw": "pub const empty: Dict<key, value> = Dict { inner: [] }",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.bitwise.zero",
      "fullName": "stdlib:aiken.crypto.bitwise.zero",
      "name": "zero",
      "type": "Unknown",
      "value": "State { inner: 0 }",
      "line": 9,
      "raw": "pub const zero = State { inner: 0 }",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.bitwise.one",
      "fullName": "stdlib:aiken.crypto.bitwise.one",
      "name": "one",
      "type": "Unknown",
      "value": "State { inner: 1 }",
      "line": 11,
      "raw": "pub const one = State { inner: 1 }",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.field_size",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.field_size",
      "name": "field_size",
      "type": "Unknown",
      "value": "32",
      "line": 26,
      "raw": "pub const field_size = 32",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int224.field_size",
      "fullName": "stdlib:aiken.crypto.int224.field_size",
      "name": "field_size",
      "type": "Unknown",
      "value": "28",
      "line": 29,
      "raw": "pub const field_size = 28",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int256.field_size",
      "fullName": "stdlib:aiken.crypto.int256.field_size",
      "name": "field_size",
      "type": "Unknown",
      "value": "32",
      "line": 18,
      "raw": "pub const field_size = 32",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.math.rational.zero",
      "fullName": "stdlib:aiken.math.rational.zero",
      "name": "zero",
      "type": "Rational",
      "value": "Rational { numerator: 0, denominator: 1 }",
      "line": 88,
      "raw": "pub const zero: Rational = Rational { numerator: 0, denominator: 1 }",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.assets.ada_policy_id",
      "fullName": "stdlib:cardano.assets.ada_policy_id",
      "name": "ada_policy_id",
      "type": "Unknown",
      "value": "\"\"",
      "line": 21,
      "raw": "pub const ada_policy_id = \"\"",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.assets.ada_asset_name",
      "fullName": "stdlib:cardano.assets.ada_asset_name",
      "name": "ada_asset_name",
      "type": "Unknown",
      "value": "\"\"",
      "line": 32,
      "raw": "pub const ada_asset_name = \"\"",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.assets.zero",
      "fullName": "stdlib:cardano.assets.zero",
      "name": "zero",
      "type": "Value",
      "value": "Value { inner: dict.empty }",
      "line": 169,
      "raw": "pub const zero: Value = Value { inner: dict.empty }",
      "isPublic": true,
      "source": "stdlib"
    },
    {
      "key": "vodka:cip.cip68_100_prefix",
      "fullName": "vodka:cip.cip68_100_prefix",
      "name": "cip68_100_prefix",
      "type": "ByteArray",
      "value": "#\"000643b0\"",
      "line": 17,
      "raw": "pub const cip68_100_prefix: ByteArray = #\"000643b0\"",
      "isPublic": true,
      "source": "vodka"
    },
    {
      "key": "vodka:cip.cip68_222_prefix",
      "fullName": "vodka:cip.cip68_222_prefix",
      "name": "cip68_222_prefix",
      "type": "ByteArray",
      "value": "#\"000de140\"",
      "line": 20,
      "raw": "pub const cip68_222_prefix: ByteArray = #\"000de140\"",
      "isPublic": true,
      "source": "vodka"
    },
    {
      "key": "vodka:cip.cip68_333_prefix",
      "fullName": "vodka:cip.cip68_333_prefix",
      "name": "cip68_333_prefix",
      "type": "ByteArray",
      "value": "#\"0014df10\"",
      "line": 23,
      "raw": "pub const cip68_333_prefix: ByteArray = #\"0014df10\"",
      "isPublic": true,
      "source": "vodka"
    },
    {
      "key": "vodka:cip.cip68_444_prefix",
      "fullName": "vodka:cip.cip68_444_prefix",
      "name": "cip68_444_prefix",
      "type": "ByteArray",
      "value": "#\"001bc280\"",
      "line": 26,
      "raw": "pub const cip68_444_prefix: ByteArray = #\"001bc280\"",
      "isPublic": true,
      "source": "vodka"
    },
    {
      "key": "vodka:cocktail.compare_script_address",
      "fullName": "vodka:cocktail.compare_script_address",
      "name": "compare_script_address",
      "type": "Unknown",
      "value": "vodka_address.compare_script_address",
      "line": 32,
      "raw": "pub const compare_script_address = vodka_address.compare_script_address",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["compare_script_address"]
    },
    {
      "key": "vodka:cocktail.compare_address",
      "fullName": "vodka:cocktail.compare_address",
      "name": "compare_address",
      "type": "Unknown",
      "value": "vodka_address.compare_address",
      "line": 35,
      "raw": "pub const compare_address = vodka_address.compare_address",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["compare_address"]
    },
    {
      "key": "vodka:cocktail.address_payment_key",
      "fullName": "vodka:cocktail.address_payment_key",
      "name": "address_payment_key",
      "type": "Unknown",
      "value": "vodka_address.address_payment_key",
      "line": 38,
      "raw": "pub const address_payment_key = vodka_address.address_payment_key",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["address_payment_key"]
    },
    {
      "key": "vodka:cocktail.address_pub_key",
      "fullName": "vodka:cocktail.address_pub_key",
      "name": "address_pub_key",
      "type": "Unknown",
      "value": "vodka_address.address_pub_key",
      "line": 41,
      "raw": "pub const address_pub_key = vodka_address.address_pub_key",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["address_pub_key"]
    },
    {
      "key": "vodka:cocktail.address_script_hash",
      "fullName": "vodka:cocktail.address_script_hash",
      "name": "address_script_hash",
      "type": "Unknown",
      "value": "vodka_address.address_script_hash",
      "line": 44,
      "raw": "pub const address_script_hash = vodka_address.address_script_hash",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["address_script_hash"]
    },
    {
      "key": "vodka:cocktail.convert_int_to_bytes",
      "fullName": "vodka:cocktail.convert_int_to_bytes",
      "name": "convert_int_to_bytes",
      "type": "Unknown",
      "value": "vodka_converter.convert_int_to_bytes",
      "line": 49,
      "raw": "pub const convert_int_to_bytes = vodka_converter.convert_int_to_bytes",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["convert_int_to_bytes"]
    },
    {
      "key": "vodka:cocktail.get_number_digit",
      "fullName": "vodka:cocktail.get_number_digit",
      "name": "get_number_digit",
      "type": "Unknown",
      "value": "vodka_converter.get_number_digit",
      "line": 52,
      "raw": "pub const get_number_digit = vodka_converter.get_number_digit",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["get_number_digit"]
    },
    {
      "key": "vodka:cocktail.key_signed",
      "fullName": "vodka:cocktail.key_signed",
      "name": "key_signed",
      "type": "Unknown",
      "value": "vodka_extra_signatories.key_signed",
      "line": 57,
      "raw": "pub const key_signed = vodka_extra_signatories.key_signed",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["key_signed"]
    },
    {
      "key": "vodka:cocktail.one_of_keys_signed",
      "fullName": "vodka:cocktail.one_of_keys_signed",
      "name": "one_of_keys_signed",
      "type": "Unknown",
      "value": "vodka_extra_signatories.one_of_keys_signed",
      "line": 60,
      "raw": "pub const one_of_keys_signed = vodka_extra_signatories.one_of_keys_signed",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["one_of_keys_signed"]
    },
    {
      "key": "vodka:cocktail.all_key_signed",
      "fullName": "vodka:cocktail.all_key_signed",
      "name": "all_key_signed",
      "type": "Unknown",
      "value": "vodka_extra_signatories.all_key_signed",
      "line": 63,
      "raw": "pub const all_key_signed = vodka_extra_signatories.all_key_signed",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["all_key_signed"]
    },
    {
      "key": "vodka:cocktail.input_inline_datum",
      "fullName": "vodka:cocktail.input_inline_datum",
      "name": "input_inline_datum",
      "type": "Unknown",
      "value": "vodka_inputs.input_inline_datum",
      "line": 68,
      "raw": "pub const input_inline_datum = vodka_inputs.input_inline_datum",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["input_inline_datum"]
    },
    {
      "key": "vodka:cocktail.only_input_datum_with",
      "fullName": "vodka:cocktail.only_input_datum_with",
      "name": "only_input_datum_with",
      "type": "Unknown",
      "value": "vodka_inputs.only_input_datum_with",
      "line": 71,
      "raw": "pub const only_input_datum_with = vodka_inputs.only_input_datum_with",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["only_input_datum_with"]
    },
    {
      "key": "vodka:cocktail.inputs_at",
      "fullName": "vodka:cocktail.inputs_at",
      "name": "inputs_at",
      "type": "Unknown",
      "value": "vodka_inputs.inputs_at",
      "line": 74,
      "raw": "pub const inputs_at = vodka_inputs.inputs_at",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["inputs_at"]
    },
    {
      "key": "vodka:cocktail.inputs_with",
      "fullName": "vodka:cocktail.inputs_with",
      "name": "inputs_with",
      "type": "Unknown",
      "value": "vodka_inputs.inputs_with",
      "line": 77,
      "raw": "pub const inputs_with = vodka_inputs.inputs_with",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["inputs_with"]
    },
    {
      "key": "vodka:cocktail.inputs_with_policy",
      "fullName": "vodka:cocktail.inputs_with_policy",
      "name": "inputs_with_policy",
      "type": "Unknown",
      "value": "vodka_inputs.inputs_with_policy",
      "line": 80,
      "raw": "pub const inputs_with_policy = vodka_inputs.inputs_with_policy",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["inputs_with_policy"]
    },
    {
      "key": "vodka:cocktail.inputs_at_with",
      "fullName": "vodka:cocktail.inputs_at_with",
      "name": "inputs_at_with",
      "type": "Unknown",
      "value": "vodka_inputs.inputs_at_with",
      "line": 83,
      "raw": "pub const inputs_at_with = vodka_inputs.inputs_at_with",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["inputs_at_with"]
    },
    {
      "key": "vodka:cocktail.inputs_at_with_policy",
      "fullName": "vodka:cocktail.inputs_at_with_policy",
      "name": "inputs_at_with_policy",
      "type": "Unknown",
      "value": "vodka_inputs.inputs_at_with_policy",
      "line": 86,
      "raw": "pub const inputs_at_with_policy = vodka_inputs.inputs_at_with_policy",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["inputs_at_with_policy"]
    },
    {
      "key": "vodka:cocktail.inputs_token_quantity",
      "fullName": "vodka:cocktail.inputs_token_quantity",
      "name": "inputs_token_quantity",
      "type": "Unknown",
      "value": "vodka_inputs.inputs_token_quantity",
      "line": 89,
      "raw": "pub const inputs_token_quantity = vodka_inputs.inputs_token_quantity",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["inputs_token_quantity"]
    },
    {
      "key": "vodka:cocktail.check_policy_only_burn",
      "fullName": "vodka:cocktail.check_policy_only_burn",
      "name": "check_policy_only_burn",
      "type": "Unknown",
      "value": "vodka_mints.check_policy_only_burn",
      "line": 94,
      "raw": "pub const check_policy_only_burn = vodka_mints.check_policy_only_burn",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["check_policy_only_burn"]
    },
    {
      "key": "vodka:cocktail.only_minted_token",
      "fullName": "vodka:cocktail.only_minted_token",
      "name": "only_minted_token",
      "type": "Unknown",
      "value": "vodka_mints.only_minted_token",
      "line": 97,
      "raw": "pub const only_minted_token = vodka_mints.only_minted_token",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["only_minted_token"]
    },
    {
      "key": "vodka:cocktail.policy_only_minted_token",
      "fullName": "vodka:cocktail.policy_only_minted_token",
      "name": "policy_only_minted_token",
      "type": "Unknown",
      "value": "vodka_mints.policy_only_minted_token",
      "line": 100,
      "raw": "pub const policy_only_minted_token = vodka_mints.policy_only_minted_token",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["policy_only_minted_token"]
    },
    {
      "key": "vodka:cocktail.token_minted",
      "fullName": "vodka:cocktail.token_minted",
      "name": "token_minted",
      "type": "Unknown",
      "value": "vodka_mints.token_minted",
      "line": 103,
      "raw": "pub const token_minted = vodka_mints.token_minted",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["token_minted"]
    },
    {
      "key": "vodka:cocktail.output_inline_datum",
      "fullName": "vodka:cocktail.output_inline_datum",
      "name": "output_inline_datum",
      "type": "Unknown",
      "value": "vodka_outputs.output_inline_datum",
      "line": 108,
      "raw": "pub const output_inline_datum = vodka_outputs.output_inline_datum",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["output_inline_datum"]
    },
    {
      "key": "vodka:cocktail.outputs_at",
      "fullName": "vodka:cocktail.outputs_at",
      "name": "outputs_at",
      "type": "Unknown",
      "value": "vodka_outputs.outputs_at",
      "line": 111,
      "raw": "pub const outputs_at = vodka_outputs.outputs_at",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["outputs_at"]
    },
    {
      "key": "vodka:cocktail.outputs_with",
      "fullName": "vodka:cocktail.outputs_with",
      "name": "outputs_with",
      "type": "Unknown",
      "value": "vodka_outputs.outputs_with",
      "line": 114,
      "raw": "pub const outputs_with = vodka_outputs.outputs_with",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["outputs_with"]
    },
    {
      "key": "vodka:cocktail.outputs_with_policy",
      "fullName": "vodka:cocktail.outputs_with_policy",
      "name": "outputs_with_policy",
      "type": "Unknown",
      "value": "vodka_outputs.outputs_with_policy",
      "line": 117,
      "raw": "pub const outputs_with_policy = vodka_outputs.outputs_with_policy",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["outputs_with_policy"]
    },
    {
      "key": "vodka:cocktail.outputs_at_with",
      "fullName": "vodka:cocktail.outputs_at_with",
      "name": "outputs_at_with",
      "type": "Unknown",
      "value": "vodka_outputs.outputs_at_with",
      "line": 120,
      "raw": "pub const outputs_at_with = vodka_outputs.outputs_at_with",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["outputs_at_with"]
    },
    {
      "key": "vodka:cocktail.outputs_at_with_policy",
      "fullName": "vodka:cocktail.outputs_at_with_policy",
      "name": "outputs_at_with_policy",
      "type": "Unknown",
      "value": "vodka_outputs.outputs_at_with_policy",
      "line": 123,
      "raw": "pub const outputs_at_with_policy = vodka_outputs.outputs_at_with_policy",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["outputs_at_with_policy"]
    },
    {
      "key": "vodka:cocktail.redeemer_from",
      "fullName": "vodka:cocktail.redeemer_from",
      "name": "redeemer_from",
      "type": "Unknown",
      "value": "vodka_redeemers.redeemer_from",
      "line": 128,
      "raw": "pub const redeemer_from = vodka_redeemers.redeemer_from",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["redeemer_from"]
    },
    {
      "key": "vodka:cocktail.withdrawal_redeemer",
      "fullName": "vodka:cocktail.withdrawal_redeemer",
      "name": "withdrawal_redeemer",
      "type": "Unknown",
      "value": "vodka_redeemers.withdrawal_redeemer",
      "line": 131,
      "raw": "pub const withdrawal_redeemer = vodka_redeemers.withdrawal_redeemer",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["withdrawal_redeemer"]
    },
    {
      "key": "vodka:cocktail.compare_output_reference",
      "fullName": "vodka:cocktail.compare_output_reference",
      "name": "compare_output_reference",
      "type": "Unknown",
      "value": "vodka_redeemers.compare_output_reference",
      "line": 134,
      "raw": "pub const compare_output_reference = vodka_redeemers.compare_output_reference",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["compare_output_reference"]
    },
    {
      "key": "vodka:cocktail.valid_after",
      "fullName": "vodka:cocktail.valid_after",
      "name": "valid_after",
      "type": "Unknown",
      "value": "vodka_validity_range.valid_after",
      "line": 139,
      "raw": "pub const valid_after = vodka_validity_range.valid_after",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["valid_after"]
    },
    {
      "key": "vodka:cocktail.valid_before",
      "fullName": "vodka:cocktail.valid_before",
      "name": "valid_before",
      "type": "Unknown",
      "value": "vodka_validity_range.valid_before",
      "line": 142,
      "raw": "pub const valid_before = vodka_validity_range.valid_before",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["valid_before"]
    },
    {
      "key": "vodka:cocktail.value_length",
      "fullName": "vodka:cocktail.value_length",
      "name": "value_length",
      "type": "Unknown",
      "value": "vodka_value.value_length",
      "line": 147,
      "raw": "pub const value_length = vodka_value.value_length",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["value_length"]
    },
    {
      "key": "vodka:cocktail.get_all_value_to",
      "fullName": "vodka:cocktail.get_all_value_to",
      "name": "get_all_value_to",
      "type": "Unknown",
      "value": "vodka_value.get_all_value_to",
      "line": 150,
      "raw": "pub const get_all_value_to = vodka_value.get_all_value_to",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["get_all_value_to"]
    },
    {
      "key": "vodka:cocktail.get_all_value_from",
      "fullName": "vodka:cocktail.get_all_value_from",
      "name": "get_all_value_from",
      "type": "Unknown",
      "value": "vodka_value.get_all_value_from",
      "line": 153,
      "raw": "pub const get_all_value_from = vodka_value.get_all_value_from",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["get_all_value_from"]
    },
    {
      "key": "vodka:cocktail.value_geq",
      "fullName": "vodka:cocktail.value_geq",
      "name": "value_geq",
      "type": "Unknown",
      "value": "vodka_value.value_geq",
      "line": 156,
      "raw": "pub const value_geq = vodka_value.value_geq",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["value_geq"]
    },
    {
      "key": "vodka:cocktail.value_policy_info",
      "fullName": "vodka:cocktail.value_policy_info",
      "name": "value_policy_info",
      "type": "Unknown",
      "value": "vodka_value.value_policy_info",
      "line": 159,
      "raw": "pub const value_policy_info = vodka_value.value_policy_info",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["value_policy_info"]
    },
    {
      "key": "vodka:cocktail.value_tokens",
      "fullName": "vodka:cocktail.value_tokens",
      "name": "value_tokens",
      "type": "Unknown",
      "value": "vodka_value.value_tokens",
      "line": 162,
      "raw": "pub const value_tokens = vodka_value.value_tokens",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["value_tokens"]
    },
    {
      "key": "vodka:mocktail.mock_pub_key_address",
      "fullName": "vodka:mocktail.mock_pub_key_address",
      "name": "mock_pub_key_address",
      "type": "Unknown",
      "value": "virgin_address.mock_pub_key_address",
      "line": 710,
      "raw": "pub const mock_pub_key_address = virgin_address.mock_pub_key_address",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["mock_pub_key_address"]
    },
    {
      "key": "vodka:mocktail.mock_script_credential",
      "fullName": "vodka:mocktail.mock_script_credential",
      "name": "mock_script_credential",
      "type": "Unknown",
      "value": "virgin_address.mock_script_credential",
      "line": 713,
      "raw": "pub const mock_script_credential = virgin_address.mock_script_credential",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["mock_script_credential"]
    },
    {
      "key": "vodka:mocktail.mock_script_address",
      "fullName": "vodka:mocktail.mock_script_address",
      "name": "mock_script_address",
      "type": "Unknown",
      "value": "virgin_address.mock_script_address",
      "line": 716,
      "raw": "pub const mock_script_address = virgin_address.mock_script_address",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["mock_script_address"]
    },
    {
      "key": "vodka:mocktail.mock_key_hash",
      "fullName": "vodka:mocktail.mock_key_hash",
      "name": "mock_key_hash",
      "type": "Unknown",
      "value": "virgin_key_hash.mock_key_hash",
      "line": 721,
      "raw": "pub const mock_key_hash = virgin_key_hash.mock_key_hash",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["mock_key_hash"]
    },
    {
      "key": "vodka:mocktail.mock_policy_id",
      "fullName": "vodka:mocktail.mock_policy_id",
      "name": "mock_policy_id",
      "type": "Unknown",
      "value": "virgin_key_hash.mock_policy_id",
      "line": 724,
      "raw": "pub const mock_policy_id = virgin_key_hash.mock_policy_id",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["mock_policy_id"]
    },
    {
      "key": "vodka:mocktail.mock_pub_key_hash",
      "fullName": "vodka:mocktail.mock_pub_key_hash",
      "name": "mock_pub_key_hash",
      "type": "Unknown",
      "value": "virgin_key_hash.mock_pub_key_hash",
      "line": 727,
      "raw": "pub const mock_pub_key_hash = virgin_key_hash.mock_pub_key_hash",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["mock_pub_key_hash"]
    },
    {
      "key": "vodka:mocktail.mock_script_hash",
      "fullName": "vodka:mocktail.mock_script_hash",
      "name": "mock_script_hash",
      "type": "Unknown",
      "value": "virgin_key_hash.mock_script_hash",
      "line": 730,
      "raw": "pub const mock_script_hash = virgin_key_hash.mock_script_hash",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["mock_script_hash"]
    },
    {
      "key": "vodka:mocktail.mock_stake_key_hash",
      "fullName": "vodka:mocktail.mock_stake_key_hash",
      "name": "mock_stake_key_hash",
      "type": "Unknown",
      "value": "virgin_key_hash.mock_stake_key_hash",
      "line": 733,
      "raw": "pub const mock_stake_key_hash = virgin_key_hash.mock_stake_key_hash",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["mock_stake_key_hash"]
    },
    {
      "key": "vodka:mocktail.mock_tx_hash",
      "fullName": "vodka:mocktail.mock_tx_hash",
      "name": "mock_tx_hash",
      "type": "Unknown",
      "value": "virgin_output_reference.mock_tx_hash",
      "line": 742,
      "raw": "pub const mock_tx_hash = virgin_output_reference.mock_tx_hash",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["mock_tx_hash"]
    },
    {
      "key": "vodka:mocktail.mock_utxo_ref",
      "fullName": "vodka:mocktail.mock_utxo_ref",
      "name": "mock_utxo_ref",
      "type": "Unknown",
      "value": "virgin_output_reference.mock_utxo_ref",
      "line": 745,
      "raw": "pub const mock_utxo_ref = virgin_output_reference.mock_utxo_ref",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["mock_utxo_ref"]
    },
    {
      "key": "vodka:mocktail.mock_output",
      "fullName": "vodka:mocktail.mock_output",
      "name": "mock_output",
      "type": "Unknown",
      "value": "virgin_outputs.mock_output",
      "line": 750,
      "raw": "pub const mock_output = virgin_outputs.mock_output",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["mock_output"]
    },
    {
      "key": "vodka:mocktail.mock_pub_key_output",
      "fullName": "vodka:mocktail.mock_pub_key_output",
      "name": "mock_pub_key_output",
      "type": "Unknown",
      "value": "virgin_outputs.mock_pub_key_output",
      "line": 753,
      "raw": "pub const mock_pub_key_output = virgin_outputs.mock_pub_key_output",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["mock_pub_key_output"]
    },
    {
      "key": "vodka:mocktail.mock_script_output",
      "fullName": "vodka:mocktail.mock_script_output",
      "name": "mock_script_output",
      "type": "Unknown",
      "value": "virgin_outputs.mock_script_output",
      "line": 756,
      "raw": "pub const mock_script_output = virgin_outputs.mock_script_output",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["mock_script_output"]
    },
    {
      "key": "vodka:mocktail.mock_interval",
      "fullName": "vodka:mocktail.mock_interval",
      "name": "mock_interval",
      "type": "Unknown",
      "value": "virgin_validity_range.mock_interval",
      "line": 761,
      "raw": "pub const mock_interval = virgin_validity_range.mock_interval",
      "isPublic": true,
      "source": "vodka",
      "reExportedAs": ["mock_interval"]
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.ordered.node_prefix",
      "fullName": "anastasia:aiken-design-patterns.linked-list.ordered.node_prefix",
      "name": "node_prefix",
      "type": "ByteArray",
      "value": "\"Node\"",
      "line": 11,
      "raw": "pub const node_prefix: ByteArray = \"Node\"",
      "isPublic": true,
      "source": "anastasia"
    },
    {
      "key": "anastasia:aiken-design-patterns.linked-list.unordered.node_prefix",
      "fullName": "anastasia:aiken-design-patterns.linked-list.unordered.node_prefix",
      "name": "node_prefix",
      "type": "ByteArray",
      "value": "\"Node\"",
      "line": 11,
      "raw": "pub const node_prefix: ByteArray = \"Node\"",
      "isPublic": true,
      "source": "anastasia"
    }
  ],
  "privateConstants": [
    {
      "key": "stdlib:aiken.cbor.deserialise_failure",
      "fullName": "stdlib:aiken.cbor.deserialise_failure",
      "name": "deserialise_failure",
      "type": "Pair<Data, Int>",
      "value": "{ let empty: Data = \"\" Pair(empty, -1) }",
      "line": 125,
      "raw": "const deserialise_failure: Pair<Data, Int> = {",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.cbor.token_begin_bytes",
      "fullName": "stdlib:aiken.cbor.token_begin_bytes",
      "name": "token_begin_bytes",
      "type": "Unknown",
      "value": "0x5f",
      "line": 130,
      "raw": "const token_begin_bytes = 0x5f",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.cbor.token_begin_list",
      "fullName": "stdlib:aiken.cbor.token_begin_list",
      "name": "token_begin_list",
      "type": "Unknown",
      "value": "0x9f",
      "line": 132,
      "raw": "const token_begin_list = 0x9f",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.cbor.token_begin_map",
      "fullName": "stdlib:aiken.cbor.token_begin_map",
      "name": "token_begin_map",
      "type": "Unknown",
      "value": "0xbf",
      "line": 134,
      "raw": "const token_begin_map = 0xbf",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.cbor.token_break",
      "fullName": "stdlib:aiken.cbor.token_break",
      "name": "token_break",
      "type": "Unknown",
      "value": "0xff",
      "line": 136,
      "raw": "const token_break = 0xff",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.collection.dict.foo",
      "fullName": "stdlib:aiken.collection.dict.foo",
      "name": "foo",
      "type": "Unknown",
      "value": "#\"666f6f\"",
      "line": 43,
      "raw": "const foo = #\"666f6f\"",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.collection.dict.bar",
      "fullName": "stdlib:aiken.collection.dict.bar",
      "name": "bar",
      "type": "Unknown",
      "value": "#\"626172\"",
      "line": 45,
      "raw": "const bar = #\"626172\"",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.collection.dict.baz",
      "fullName": "stdlib:aiken.collection.dict.baz",
      "name": "baz",
      "type": "Unknown",
      "value": "#\"62617a\"",
      "line": 47,
      "raw": "const baz = #\"62617a\"",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.add_s_scalar",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.add_s_scalar",
      "name": "add_s_scalar",
      "type": "BitwiseScalarState",
      "value": "bitwise.add_state(field_prime)",
      "line": 128,
      "raw": "const add_s_scalar: BitwiseScalarState = bitwise.add_state(field_prime)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.add_bit_scalar",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.add_bit_scalar",
      "name": "add_bit_scalar",
      "type": "BitwiseScalarBytes",
      "value": "bitwise.add_bits(field_prime, True)",
      "line": 135,
      "raw": "const add_bit_scalar: BitwiseScalarBytes = bitwise.add_bits(field_prime, True)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.add_i_scalar",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.add_i_scalar",
      "name": "add_i_scalar",
      "type": "BitwiseScalarInt",
      "value": "bitwise.add_int(field_prime)",
      "line": 141,
      "raw": "const add_i_scalar: BitwiseScalarInt = bitwise.add_int(field_prime)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.mul_s_scalar",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.mul_s_scalar",
      "name": "mul_s_scalar",
      "type": "BitwiseScalarState",
      "value": "bitwise.mul_state(field_prime)",
      "line": 201,
      "raw": "const mul_s_scalar: BitwiseScalarState = bitwise.mul_state(field_prime)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.mul_bit_scalar",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.mul_bit_scalar",
      "name": "mul_bit_scalar",
      "type": "BitwiseScalarBytes",
      "value": "bitwise.mul_bits(field_prime, True)",
      "line": 208,
      "raw": "const mul_bit_scalar: BitwiseScalarBytes = bitwise.mul_bits(field_prime, True)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.mul_i_scalar",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.mul_i_scalar",
      "name": "mul_i_scalar",
      "type": "BitwiseScalarInt",
      "value": "bitwise.mul_int(field_prime)",
      "line": 214,
      "raw": "const mul_i_scalar: BitwiseScalarInt = bitwise.mul_int(field_prime)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.neg_scalar",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.neg_scalar",
      "name": "neg_scalar",
      "type": "fn(State<Scalar>) -> State<Scalar>",
      "value": "bitwise.neg(field_prime)",
      "line": 231,
      "raw": "const neg_scalar: fn(State<Scalar>) -> State<Scalar> = bitwise.neg(field_prime)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.sub_s_scalar",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.sub_s_scalar",
      "name": "sub_s_scalar",
      "type": "BitwiseScalarState",
      "value": "bitwise.sub_state(field_prime)",
      "line": 266,
      "raw": "const sub_s_scalar: BitwiseScalarState = bitwise.sub_state(field_prime)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.sub_bit_scalar",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.sub_bit_scalar",
      "name": "sub_bit_scalar",
      "type": "BitwiseScalarBytes",
      "value": "bitwise.sub_bits(field_prime, True)",
      "line": 273,
      "raw": "const sub_bit_scalar: BitwiseScalarBytes = bitwise.sub_bits(field_prime, True)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.bls12_381.scalar.sub_i_scalar",
      "fullName": "stdlib:aiken.crypto.bls12_381.scalar.sub_i_scalar",
      "name": "sub_i_scalar",
      "type": "BitwiseScalarInt",
      "value": "bitwise.sub_int(field_prime)",
      "line": 279,
      "raw": "const sub_i_scalar: BitwiseScalarInt = bitwise.sub_int(field_prime)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int224.add_s_bits224",
      "fullName": "stdlib:aiken.crypto.int224.add_s_bits224",
      "name": "add_s_bits224",
      "type": "Over<State>",
      "value": "bitwise.add_state(field)",
      "line": 68,
      "raw": "const add_s_bits224: Over<State> = bitwise.add_state(field)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int224.add_bit224",
      "fullName": "stdlib:aiken.crypto.int224.add_bit224",
      "name": "add_bit224",
      "type": "Over<ByteArray>",
      "value": "bitwise.add_bits(field, True)",
      "line": 75,
      "raw": "const add_bit224: Over<ByteArray> = bitwise.add_bits(field, True)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int224.add_i224",
      "fullName": "stdlib:aiken.crypto.int224.add_i224",
      "name": "add_i224",
      "type": "Over<Int>",
      "value": "bitwise.add_int(field)",
      "line": 82,
      "raw": "const add_i224: Over<Int> = bitwise.add_int(field)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int224.mul_s_bits224",
      "fullName": "stdlib:aiken.crypto.int224.mul_s_bits224",
      "name": "mul_s_bits224",
      "type": "Over<State>",
      "value": "bitwise.mul_state(field)",
      "line": 89,
      "raw": "const mul_s_bits224: Over<State> = bitwise.mul_state(field)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int224.mul_bit224",
      "fullName": "stdlib:aiken.crypto.int224.mul_bit224",
      "name": "mul_bit224",
      "type": "Over<ByteArray>",
      "value": "bitwise.mul_bits(field, True)",
      "line": 96,
      "raw": "const mul_bit224: Over<ByteArray> = bitwise.mul_bits(field, True)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int224.mul_i224",
      "fullName": "stdlib:aiken.crypto.int224.mul_i224",
      "name": "mul_i224",
      "type": "Over<Int>",
      "value": "bitwise.mul_int(field)",
      "line": 103,
      "raw": "const mul_i224: Over<Int> = bitwise.mul_int(field)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int224.neg224",
      "fullName": "stdlib:aiken.crypto.int224.neg224",
      "name": "neg224",
      "type": "fn(State) -> State",
      "value": "bitwise.neg(field)",
      "line": 110,
      "raw": "const neg224: fn(State) -> State = bitwise.neg(field)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int224.sub_s_bits224",
      "fullName": "stdlib:aiken.crypto.int224.sub_s_bits224",
      "name": "sub_s_bits224",
      "type": "Over<State>",
      "value": "bitwise.sub_state(field)",
      "line": 117,
      "raw": "const sub_s_bits224: Over<State> = bitwise.sub_state(field)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int224.sub_bit224",
      "fullName": "stdlib:aiken.crypto.int224.sub_bit224",
      "name": "sub_bit224",
      "type": "Over<ByteArray>",
      "value": "bitwise.sub_bits(field, True)",
      "line": 124,
      "raw": "const sub_bit224: Over<ByteArray> = bitwise.sub_bits(field, True)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int224.sub_i224",
      "fullName": "stdlib:aiken.crypto.int224.sub_i224",
      "name": "sub_i224",
      "type": "Over<Int>",
      "value": "bitwise.sub_int(field)",
      "line": 131,
      "raw": "const sub_i224: Over<Int> = bitwise.sub_int(field)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int256.add_s_hash256",
      "fullName": "stdlib:aiken.crypto.int256.add_s_hash256",
      "name": "add_s_hash256",
      "type": "Over<State>",
      "value": "bitwise.add_state(field)",
      "line": 67,
      "raw": "const add_s_hash256: Over<State> = bitwise.add_state(field)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int256.add_bit256",
      "fullName": "stdlib:aiken.crypto.int256.add_bit256",
      "name": "add_bit256",
      "type": "Over<ByteArray>",
      "value": "bitwise.add_bits(field, True)",
      "line": 74,
      "raw": "const add_bit256: Over<ByteArray> = bitwise.add_bits(field, True)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int256.add_i256",
      "fullName": "stdlib:aiken.crypto.int256.add_i256",
      "name": "add_i256",
      "type": "Over<Int>",
      "value": "bitwise.add_int(field)",
      "line": 81,
      "raw": "const add_i256: Over<Int> = bitwise.add_int(field)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int256.mul_s_hash256",
      "fullName": "stdlib:aiken.crypto.int256.mul_s_hash256",
      "name": "mul_s_hash256",
      "type": "Over<State>",
      "value": "bitwise.mul_state(field)",
      "line": 88,
      "raw": "const mul_s_hash256: Over<State> = bitwise.mul_state(field)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int256.mul_bit256",
      "fullName": "stdlib:aiken.crypto.int256.mul_bit256",
      "name": "mul_bit256",
      "type": "Over<ByteArray>",
      "value": "bitwise.mul_bits(field, True)",
      "line": 95,
      "raw": "const mul_bit256: Over<ByteArray> = bitwise.mul_bits(field, True)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int256.mul_i256",
      "fullName": "stdlib:aiken.crypto.int256.mul_i256",
      "name": "mul_i256",
      "type": "Over<Int>",
      "value": "bitwise.mul_int(field)",
      "line": 102,
      "raw": "const mul_i256: Over<Int> = bitwise.mul_int(field)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int256.neg256",
      "fullName": "stdlib:aiken.crypto.int256.neg256",
      "name": "neg256",
      "type": "fn(State) -> State",
      "value": "bitwise.neg(field)",
      "line": 109,
      "raw": "const neg256: fn(State) -> State = bitwise.neg(field)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int256.sub_s_hash256",
      "fullName": "stdlib:aiken.crypto.int256.sub_s_hash256",
      "name": "sub_s_hash256",
      "type": "Over<State>",
      "value": "bitwise.sub_state(field)",
      "line": 116,
      "raw": "const sub_s_hash256: Over<State> = bitwise.sub_state(field)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int256.sub_bit256",
      "fullName": "stdlib:aiken.crypto.int256.sub_bit256",
      "name": "sub_bit256",
      "type": "Over<ByteArray>",
      "value": "bitwise.sub_bits(field, True)",
      "line": 123,
      "raw": "const sub_bit256: Over<ByteArray> = bitwise.sub_bits(field, True)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:aiken.crypto.int256.sub_i256",
      "fullName": "stdlib:aiken.crypto.int256.sub_i256",
      "name": "sub_i256",
      "type": "Over<Int>",
      "value": "bitwise.sub_int(field)",
      "line": 130,
      "raw": "const sub_i256: Over<Int> = bitwise.sub_int(field)",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "stdlib:cardano.assets.fixture_match_benchmark_right",
      "fullName": "stdlib:cardano.assets.fixture_match_benchmark_right",
      "name": "fixture_match_benchmark_right",
      "type": "Data",
      "value": "fixture_match_benchmark_left",
      "line": 498,
      "raw": "const fixture_match_benchmark_right: Data = fixture_match_benchmark_left",
      "isPublic": false,
      "source": "stdlib"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.param_header_28_bytes",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.param_header_28_bytes",
      "name": "param_header_28_bytes",
      "type": "Unknown",
      "value": "#\"004c011e581c\"",
      "line": 38,
      "raw": "const param_header_28_bytes = #\"004c011e581c\"",
      "isPublic": false,
      "source": "anastasia"
    },
    {
      "key": "anastasia:aiken-design-patterns.parameter-validation.postfix",
      "fullName": "anastasia:aiken-design-patterns.parameter-validation.postfix",
      "name": "postfix",
      "type": "ByteArray",
      "value": "#\"0001\"",
      "line": 40,
      "raw": "const postfix: ByteArray = #\"0001\"",
      "isPublic": false,
      "source": "anastasia"
    }
  ],
  "stats": {
    "totalModules": 67,
    "totalFunctions": 628,
    "totalAtoms": 87,
    "totalTypes": 104,
    "totalPrivateTypes": 11,
    "totalConstants": 69,
    "totalPrivateConstants": 41,
    "totalDependencies": 67,
    "sourceStats": {
      "stdlib": {
        "modules": 35,
        "functions": 341,
        "atoms": 51,
        "types": 71,
        "privateTypes": 11,
        "constants": 10,
        "privateConstants": 39
      },
      "prelude": {
        "modules": 2,
        "functions": 94,
        "atoms": 0,
        "types": 18,
        "privateTypes": 0,
        "constants": 0,
        "privateConstants": 0
      },
      "vodka": {
        "modules": 18,
        "functions": 93,
        "atoms": 2,
        "types": 2,
        "privateTypes": 0,
        "constants": 57,
        "privateConstants": 0
      },
      "anastasia": {
        "modules": 12,
        "functions": 100,
        "atoms": 34,
        "types": 13,
        "privateTypes": 0,
        "constants": 2,
        "privateConstants": 2
      }
    }
  }
}
